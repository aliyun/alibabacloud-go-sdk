// This file is auto-generated, don't edit it. Thanks.
/**
 *
 */
package client

import (
	openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
	endpointutil "github.com/alibabacloud-go/endpoint-util/service"
	openapiutil "github.com/alibabacloud-go/openapi-util/service"
	util "github.com/alibabacloud-go/tea-utils/v2/service"
	"github.com/alibabacloud-go/tea/tea"
)

type AsyncTaskVO struct {
	DatasetId  *string `json:"DatasetId,omitempty" xml:"DatasetId,omitempty"`
	Id         *int64  `json:"Id,omitempty" xml:"Id,omitempty"`
	Remark     *string `json:"Remark,omitempty" xml:"Remark,omitempty"`
	TaskName   *string `json:"TaskName,omitempty" xml:"TaskName,omitempty"`
	TaskStatus *int32  `json:"TaskStatus,omitempty" xml:"TaskStatus,omitempty"`
	TaskType   *int32  `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
	UserId     *int64  `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s AsyncTaskVO) String() string {
	return tea.Prettify(s)
}

func (s AsyncTaskVO) GoString() string {
	return s.String()
}

func (s *AsyncTaskVO) SetDatasetId(v string) *AsyncTaskVO {
	s.DatasetId = &v
	return s
}

func (s *AsyncTaskVO) SetId(v int64) *AsyncTaskVO {
	s.Id = &v
	return s
}

func (s *AsyncTaskVO) SetRemark(v string) *AsyncTaskVO {
	s.Remark = &v
	return s
}

func (s *AsyncTaskVO) SetTaskName(v string) *AsyncTaskVO {
	s.TaskName = &v
	return s
}

func (s *AsyncTaskVO) SetTaskStatus(v int32) *AsyncTaskVO {
	s.TaskStatus = &v
	return s
}

func (s *AsyncTaskVO) SetTaskType(v int32) *AsyncTaskVO {
	s.TaskType = &v
	return s
}

func (s *AsyncTaskVO) SetUserId(v int64) *AsyncTaskVO {
	s.UserId = &v
	return s
}

type DatasetItemVO struct {
	AsyncTaskList    []*AsyncTaskVO          `json:"AsyncTaskList,omitempty" xml:"AsyncTaskList,omitempty" type:"Repeated"`
	DatasetStatus    *int32                  `json:"DatasetStatus,omitempty" xml:"DatasetStatus,omitempty"`
	DatasetType      *int32                  `json:"DatasetType,omitempty" xml:"DatasetType,omitempty"`
	Digest           *string                 `json:"Digest,omitempty" xml:"Digest,omitempty"`
	FileSystem       *string                 `json:"FileSystem,omitempty" xml:"FileSystem,omitempty"`
	Id               *string                 `json:"Id,omitempty" xml:"Id,omitempty"`
	KeyName          *string                 `json:"KeyName,omitempty" xml:"KeyName,omitempty"`
	MoreInfo         *string                 `json:"MoreInfo,omitempty" xml:"MoreInfo,omitempty"`
	Path             *string                 `json:"Path,omitempty" xml:"Path,omitempty"`
	ProjectsLinked   []*ProjectDetailsLiteVO `json:"ProjectsLinked,omitempty" xml:"ProjectsLinked,omitempty" type:"Repeated"`
	RecentTaskStatus *int32                  `json:"RecentTaskStatus,omitempty" xml:"RecentTaskStatus,omitempty"`
	Remark           *string                 `json:"Remark,omitempty" xml:"Remark,omitempty"`
	Schema           *string                 `json:"Schema,omitempty" xml:"Schema,omitempty"`
	TableName        *string                 `json:"TableName,omitempty" xml:"TableName,omitempty"`
	Url              *string                 `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s DatasetItemVO) String() string {
	return tea.Prettify(s)
}

func (s DatasetItemVO) GoString() string {
	return s.String()
}

func (s *DatasetItemVO) SetAsyncTaskList(v []*AsyncTaskVO) *DatasetItemVO {
	s.AsyncTaskList = v
	return s
}

func (s *DatasetItemVO) SetDatasetStatus(v int32) *DatasetItemVO {
	s.DatasetStatus = &v
	return s
}

func (s *DatasetItemVO) SetDatasetType(v int32) *DatasetItemVO {
	s.DatasetType = &v
	return s
}

func (s *DatasetItemVO) SetDigest(v string) *DatasetItemVO {
	s.Digest = &v
	return s
}

func (s *DatasetItemVO) SetFileSystem(v string) *DatasetItemVO {
	s.FileSystem = &v
	return s
}

func (s *DatasetItemVO) SetId(v string) *DatasetItemVO {
	s.Id = &v
	return s
}

func (s *DatasetItemVO) SetKeyName(v string) *DatasetItemVO {
	s.KeyName = &v
	return s
}

func (s *DatasetItemVO) SetMoreInfo(v string) *DatasetItemVO {
	s.MoreInfo = &v
	return s
}

func (s *DatasetItemVO) SetPath(v string) *DatasetItemVO {
	s.Path = &v
	return s
}

func (s *DatasetItemVO) SetProjectsLinked(v []*ProjectDetailsLiteVO) *DatasetItemVO {
	s.ProjectsLinked = v
	return s
}

func (s *DatasetItemVO) SetRecentTaskStatus(v int32) *DatasetItemVO {
	s.RecentTaskStatus = &v
	return s
}

func (s *DatasetItemVO) SetRemark(v string) *DatasetItemVO {
	s.Remark = &v
	return s
}

func (s *DatasetItemVO) SetSchema(v string) *DatasetItemVO {
	s.Schema = &v
	return s
}

func (s *DatasetItemVO) SetTableName(v string) *DatasetItemVO {
	s.TableName = &v
	return s
}

func (s *DatasetItemVO) SetUrl(v string) *DatasetItemVO {
	s.Url = &v
	return s
}

type GetTableDataKeyVO struct {
	ColName    *string `json:"ColName,omitempty" xml:"ColName,omitempty"`
	DbName     *string `json:"DbName,omitempty" xml:"DbName,omitempty"`
	MekId      *int64  `json:"MekId,omitempty" xml:"MekId,omitempty"`
	SchemaName *string `json:"SchemaName,omitempty" xml:"SchemaName,omitempty"`
	TblName    *string `json:"TblName,omitempty" xml:"TblName,omitempty"`
	UserName   *string `json:"UserName,omitempty" xml:"UserName,omitempty"`
}

func (s GetTableDataKeyVO) String() string {
	return tea.Prettify(s)
}

func (s GetTableDataKeyVO) GoString() string {
	return s.String()
}

func (s *GetTableDataKeyVO) SetColName(v string) *GetTableDataKeyVO {
	s.ColName = &v
	return s
}

func (s *GetTableDataKeyVO) SetDbName(v string) *GetTableDataKeyVO {
	s.DbName = &v
	return s
}

func (s *GetTableDataKeyVO) SetMekId(v int64) *GetTableDataKeyVO {
	s.MekId = &v
	return s
}

func (s *GetTableDataKeyVO) SetSchemaName(v string) *GetTableDataKeyVO {
	s.SchemaName = &v
	return s
}

func (s *GetTableDataKeyVO) SetTblName(v string) *GetTableDataKeyVO {
	s.TblName = &v
	return s
}

func (s *GetTableDataKeyVO) SetUserName(v string) *GetTableDataKeyVO {
	s.UserName = &v
	return s
}

type ImportMasterKeyVO struct {
	EncryptMekDataBase64 *string  `json:"EncryptMekDataBase64,omitempty" xml:"EncryptMekDataBase64,omitempty"`
	MekId                *int64   `json:"MekId,omitempty" xml:"MekId,omitempty"`
	ProjectId            []*int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty" type:"Repeated"`
}

func (s ImportMasterKeyVO) String() string {
	return tea.Prettify(s)
}

func (s ImportMasterKeyVO) GoString() string {
	return s.String()
}

func (s *ImportMasterKeyVO) SetEncryptMekDataBase64(v string) *ImportMasterKeyVO {
	s.EncryptMekDataBase64 = &v
	return s
}

func (s *ImportMasterKeyVO) SetMekId(v int64) *ImportMasterKeyVO {
	s.MekId = &v
	return s
}

func (s *ImportMasterKeyVO) SetProjectId(v []*int64) *ImportMasterKeyVO {
	s.ProjectId = v
	return s
}

type ProjectDetailsLiteVO struct {
	Id          *int64  `json:"Id,omitempty" xml:"Id,omitempty"`
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
}

func (s ProjectDetailsLiteVO) String() string {
	return tea.Prettify(s)
}

func (s ProjectDetailsLiteVO) GoString() string {
	return s.String()
}

func (s *ProjectDetailsLiteVO) SetId(v int64) *ProjectDetailsLiteVO {
	s.Id = &v
	return s
}

func (s *ProjectDetailsLiteVO) SetProjectName(v string) *ProjectDetailsLiteVO {
	s.ProjectName = &v
	return s
}

type StsApplyVO struct {
	AliyunId *string `json:"AliyunId,omitempty" xml:"AliyunId,omitempty"`
	Duration *int64  `json:"Duration,omitempty" xml:"Duration,omitempty"`
}

func (s StsApplyVO) String() string {
	return tea.Prettify(s)
}

func (s StsApplyVO) GoString() string {
	return s.String()
}

func (s *StsApplyVO) SetAliyunId(v string) *StsApplyVO {
	s.AliyunId = &v
	return s
}

func (s *StsApplyVO) SetDuration(v int64) *StsApplyVO {
	s.Duration = &v
	return s
}

type StsTokenVO struct {
	AccessKeyId     *string `json:"AccessKeyId,omitempty" xml:"AccessKeyId,omitempty"`
	AccessKeySecret *string `json:"AccessKeySecret,omitempty" xml:"AccessKeySecret,omitempty"`
	Expiration      *string `json:"Expiration,omitempty" xml:"Expiration,omitempty"`
	SecurityToken   *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s StsTokenVO) String() string {
	return tea.Prettify(s)
}

func (s StsTokenVO) GoString() string {
	return s.String()
}

func (s *StsTokenVO) SetAccessKeyId(v string) *StsTokenVO {
	s.AccessKeyId = &v
	return s
}

func (s *StsTokenVO) SetAccessKeySecret(v string) *StsTokenVO {
	s.AccessKeySecret = &v
	return s
}

func (s *StsTokenVO) SetExpiration(v string) *StsTokenVO {
	s.Expiration = &v
	return s
}

func (s *StsTokenVO) SetSecurityToken(v string) *StsTokenVO {
	s.SecurityToken = &v
	return s
}

type TeeEvidenceVO struct {
	CipherSuite          *string   `json:"CipherSuite,omitempty" xml:"CipherSuite,omitempty"`
	EnclaveData          *string   `json:"EnclaveData,omitempty" xml:"EnclaveData,omitempty"`
	EncryptPublicKeyPem  *string   `json:"EncryptPublicKeyPem,omitempty" xml:"EncryptPublicKeyPem,omitempty"`
	EncryptPublicKeyType *string   `json:"EncryptPublicKeyType,omitempty" xml:"EncryptPublicKeyType,omitempty"`
	ModifiedDate         *string   `json:"ModifiedDate,omitempty" xml:"ModifiedDate,omitempty"`
	PublicKey            *string   `json:"PublicKey,omitempty" xml:"PublicKey,omitempty"`
	PublicKeyRaBase64    *string   `json:"PublicKeyRaBase64,omitempty" xml:"PublicKeyRaBase64,omitempty"`
	PublicKeyRaType      *string   `json:"PublicKeyRaType,omitempty" xml:"PublicKeyRaType,omitempty"`
	QuoteReport          *string   `json:"QuoteReport,omitempty" xml:"QuoteReport,omitempty"`
	SignPublicKeyPem     *string   `json:"SignPublicKeyPem,omitempty" xml:"SignPublicKeyPem,omitempty"`
	SignPublicKeyType    *string   `json:"SignPublicKeyType,omitempty" xml:"SignPublicKeyType,omitempty"`
	TrustedMrEnclave     []*string `json:"TrustedMrEnclave,omitempty" xml:"TrustedMrEnclave,omitempty" type:"Repeated"`
}

func (s TeeEvidenceVO) String() string {
	return tea.Prettify(s)
}

func (s TeeEvidenceVO) GoString() string {
	return s.String()
}

func (s *TeeEvidenceVO) SetCipherSuite(v string) *TeeEvidenceVO {
	s.CipherSuite = &v
	return s
}

func (s *TeeEvidenceVO) SetEnclaveData(v string) *TeeEvidenceVO {
	s.EnclaveData = &v
	return s
}

func (s *TeeEvidenceVO) SetEncryptPublicKeyPem(v string) *TeeEvidenceVO {
	s.EncryptPublicKeyPem = &v
	return s
}

func (s *TeeEvidenceVO) SetEncryptPublicKeyType(v string) *TeeEvidenceVO {
	s.EncryptPublicKeyType = &v
	return s
}

func (s *TeeEvidenceVO) SetModifiedDate(v string) *TeeEvidenceVO {
	s.ModifiedDate = &v
	return s
}

func (s *TeeEvidenceVO) SetPublicKey(v string) *TeeEvidenceVO {
	s.PublicKey = &v
	return s
}

func (s *TeeEvidenceVO) SetPublicKeyRaBase64(v string) *TeeEvidenceVO {
	s.PublicKeyRaBase64 = &v
	return s
}

func (s *TeeEvidenceVO) SetPublicKeyRaType(v string) *TeeEvidenceVO {
	s.PublicKeyRaType = &v
	return s
}

func (s *TeeEvidenceVO) SetQuoteReport(v string) *TeeEvidenceVO {
	s.QuoteReport = &v
	return s
}

func (s *TeeEvidenceVO) SetSignPublicKeyPem(v string) *TeeEvidenceVO {
	s.SignPublicKeyPem = &v
	return s
}

func (s *TeeEvidenceVO) SetSignPublicKeyType(v string) *TeeEvidenceVO {
	s.SignPublicKeyType = &v
	return s
}

func (s *TeeEvidenceVO) SetTrustedMrEnclave(v []*string) *TeeEvidenceVO {
	s.TrustedMrEnclave = v
	return s
}

type UsersDetailsVO struct {
	ApprovalSignatureBase64 *string `json:"ApprovalSignatureBase64,omitempty" xml:"ApprovalSignatureBase64,omitempty"`
	ApprovalSqlTemplate     *string `json:"ApprovalSqlTemplate,omitempty" xml:"ApprovalSqlTemplate,omitempty"`
	ApprovalStatus          *string `json:"ApprovalStatus,omitempty" xml:"ApprovalStatus,omitempty"`
	Creator                 *int32  `json:"Creator,omitempty" xml:"Creator,omitempty"`
	DataReady               *int32  `json:"DataReady,omitempty" xml:"DataReady,omitempty"`
	Id                      *int64  `json:"Id,omitempty" xml:"Id,omitempty"`
	Mekid                   *int64  `json:"Mekid,omitempty" xml:"Mekid,omitempty"`
	PathPrefix              *string `json:"PathPrefix,omitempty" xml:"PathPrefix,omitempty"`
	ResultParty             *int32  `json:"ResultParty,omitempty" xml:"ResultParty,omitempty"`
	Uid                     *string `json:"Uid,omitempty" xml:"Uid,omitempty"`
	UserConfirmed           *int32  `json:"UserConfirmed,omitempty" xml:"UserConfirmed,omitempty"`
	UserName                *string `json:"UserName,omitempty" xml:"UserName,omitempty"`
	UserPublicKeyPem        *string `json:"UserPublicKeyPem,omitempty" xml:"UserPublicKeyPem,omitempty"`
}

func (s UsersDetailsVO) String() string {
	return tea.Prettify(s)
}

func (s UsersDetailsVO) GoString() string {
	return s.String()
}

func (s *UsersDetailsVO) SetApprovalSignatureBase64(v string) *UsersDetailsVO {
	s.ApprovalSignatureBase64 = &v
	return s
}

func (s *UsersDetailsVO) SetApprovalSqlTemplate(v string) *UsersDetailsVO {
	s.ApprovalSqlTemplate = &v
	return s
}

func (s *UsersDetailsVO) SetApprovalStatus(v string) *UsersDetailsVO {
	s.ApprovalStatus = &v
	return s
}

func (s *UsersDetailsVO) SetCreator(v int32) *UsersDetailsVO {
	s.Creator = &v
	return s
}

func (s *UsersDetailsVO) SetDataReady(v int32) *UsersDetailsVO {
	s.DataReady = &v
	return s
}

func (s *UsersDetailsVO) SetId(v int64) *UsersDetailsVO {
	s.Id = &v
	return s
}

func (s *UsersDetailsVO) SetMekid(v int64) *UsersDetailsVO {
	s.Mekid = &v
	return s
}

func (s *UsersDetailsVO) SetPathPrefix(v string) *UsersDetailsVO {
	s.PathPrefix = &v
	return s
}

func (s *UsersDetailsVO) SetResultParty(v int32) *UsersDetailsVO {
	s.ResultParty = &v
	return s
}

func (s *UsersDetailsVO) SetUid(v string) *UsersDetailsVO {
	s.Uid = &v
	return s
}

func (s *UsersDetailsVO) SetUserConfirmed(v int32) *UsersDetailsVO {
	s.UserConfirmed = &v
	return s
}

func (s *UsersDetailsVO) SetUserName(v string) *UsersDetailsVO {
	s.UserName = &v
	return s
}

func (s *UsersDetailsVO) SetUserPublicKeyPem(v string) *UsersDetailsVO {
	s.UserPublicKeyPem = &v
	return s
}

type AddDesensitizationRuleRequest struct {
	// The parameters of the algorithm.
	FunctionParams []map[string]*string `json:"FunctionParams,omitempty" xml:"FunctionParams,omitempty" type:"Repeated"`
	// The type of the masking algorithm.
	//
	// Valid values:
	//
	// *   FIX_POS : masks characters in the specified position.
	// *   DATE_ROUNDING: rounds the date.
	// *   PLAINTEXT: does not mask data.
	// *   SHA1: masks characters by using the secure hash algorithm 1 (SHA-1)
	// *   HMAC: masks characters by using the hash-based message authentication code (HMAC).
	// *   STRING_TRANSFORM: shift characters.
	// *   NUMBER_ROUNDING: rounds numbers.
	// *   AES: masks characters by using the advanced encryption standard (AES) algorithm.
	// *   SHA256: masks characters by using SHA-256 algorithm.
	// *   DES: masks characters by using the data encryption standard (DES) algorithm.
	// *   MAP_REPLACE: masks the mapped data.
	// *   FIX_CHAR: masks fixed characters.
	// *   DEFAULT: masks all characters.
	// *   RANDOM_REPLACE: randomly replaces characters.
	// *   MD5: masks characters by using the MD5 algorithm.
	FunctionType *string `json:"FunctionType,omitempty" xml:"FunctionType,omitempty"`
	// The description of the rule.
	RuleDescription *string `json:"RuleDescription,omitempty" xml:"RuleDescription,omitempty"`
	// The name of the rule.
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	// The masking algorithm.
	//
	// Valid values:
	//
	// *   PLAINTEXT
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   TRANSFORM
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   ENCRYPT
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   REPLACE
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   HASH
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   MASK
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	RuleType *string `json:"RuleType,omitempty" xml:"RuleType,omitempty"`
	// The tenant ID.
	//
	// >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the [View information about the current tenant](~~181330~~) section of the "Manage DMS tenants" topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s AddDesensitizationRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s AddDesensitizationRuleRequest) GoString() string {
	return s.String()
}

func (s *AddDesensitizationRuleRequest) SetFunctionParams(v []map[string]*string) *AddDesensitizationRuleRequest {
	s.FunctionParams = v
	return s
}

func (s *AddDesensitizationRuleRequest) SetFunctionType(v string) *AddDesensitizationRuleRequest {
	s.FunctionType = &v
	return s
}

func (s *AddDesensitizationRuleRequest) SetRuleDescription(v string) *AddDesensitizationRuleRequest {
	s.RuleDescription = &v
	return s
}

func (s *AddDesensitizationRuleRequest) SetRuleName(v string) *AddDesensitizationRuleRequest {
	s.RuleName = &v
	return s
}

func (s *AddDesensitizationRuleRequest) SetRuleType(v string) *AddDesensitizationRuleRequest {
	s.RuleType = &v
	return s
}

func (s *AddDesensitizationRuleRequest) SetTid(v int64) *AddDesensitizationRuleRequest {
	s.Tid = &v
	return s
}

type AddDesensitizationRuleResponseBody struct {
	// The error code that is returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message that is returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID generated for the data masking rule.
	RuleId *int32 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddDesensitizationRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddDesensitizationRuleResponseBody) GoString() string {
	return s.String()
}

func (s *AddDesensitizationRuleResponseBody) SetErrorCode(v string) *AddDesensitizationRuleResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *AddDesensitizationRuleResponseBody) SetErrorMessage(v string) *AddDesensitizationRuleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *AddDesensitizationRuleResponseBody) SetRequestId(v string) *AddDesensitizationRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddDesensitizationRuleResponseBody) SetRuleId(v int32) *AddDesensitizationRuleResponseBody {
	s.RuleId = &v
	return s
}

func (s *AddDesensitizationRuleResponseBody) SetSuccess(v bool) *AddDesensitizationRuleResponseBody {
	s.Success = &v
	return s
}

type AddDesensitizationRuleResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddDesensitizationRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddDesensitizationRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s AddDesensitizationRuleResponse) GoString() string {
	return s.String()
}

func (s *AddDesensitizationRuleResponse) SetHeaders(v map[string]*string) *AddDesensitizationRuleResponse {
	s.Headers = v
	return s
}

func (s *AddDesensitizationRuleResponse) SetStatusCode(v int32) *AddDesensitizationRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *AddDesensitizationRuleResponse) SetBody(v *AddDesensitizationRuleResponseBody) *AddDesensitizationRuleResponse {
	s.Body = v
	return s
}

type AddInstanceRequest struct {
	DataLinkName     *string `json:"DataLinkName,omitempty" xml:"DataLinkName,omitempty"`
	DatabasePassword *string `json:"DatabasePassword,omitempty" xml:"DatabasePassword,omitempty"`
	DatabaseUser     *string `json:"DatabaseUser,omitempty" xml:"DatabaseUser,omitempty"`
	DbaId            *int64  `json:"DbaId,omitempty" xml:"DbaId,omitempty"`
	DdlOnline        *int32  `json:"DdlOnline,omitempty" xml:"DdlOnline,omitempty"`
	EcsInstanceId    *string `json:"EcsInstanceId,omitempty" xml:"EcsInstanceId,omitempty"`
	EcsRegion        *string `json:"EcsRegion,omitempty" xml:"EcsRegion,omitempty"`
	EnableSellCommon *string `json:"EnableSellCommon,omitempty" xml:"EnableSellCommon,omitempty"`
	EnableSellSitd   *string `json:"EnableSellSitd,omitempty" xml:"EnableSellSitd,omitempty"`
	EnableSellStable *string `json:"EnableSellStable,omitempty" xml:"EnableSellStable,omitempty"`
	EnableSellTrust  *string `json:"EnableSellTrust,omitempty" xml:"EnableSellTrust,omitempty"`
	EnvType          *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	ExportTimeout    *int32  `json:"ExportTimeout,omitempty" xml:"ExportTimeout,omitempty"`
	Host             *string `json:"Host,omitempty" xml:"Host,omitempty"`
	InstanceAlias    *string `json:"InstanceAlias,omitempty" xml:"InstanceAlias,omitempty"`
	InstanceSource   *string `json:"InstanceSource,omitempty" xml:"InstanceSource,omitempty"`
	InstanceType     *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	NetworkType      *string `json:"NetworkType,omitempty" xml:"NetworkType,omitempty"`
	Port             *int32  `json:"Port,omitempty" xml:"Port,omitempty"`
	QueryTimeout     *int32  `json:"QueryTimeout,omitempty" xml:"QueryTimeout,omitempty"`
	SafeRule         *string `json:"SafeRule,omitempty" xml:"SafeRule,omitempty"`
	Sid              *string `json:"Sid,omitempty" xml:"Sid,omitempty"`
	SkipTest         *bool   `json:"SkipTest,omitempty" xml:"SkipTest,omitempty"`
	TemplateId       *int64  `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	TemplateType     *string `json:"TemplateType,omitempty" xml:"TemplateType,omitempty"`
	Tid              *int64  `json:"Tid,omitempty" xml:"Tid,omitempty"`
	UseDsql          *int32  `json:"UseDsql,omitempty" xml:"UseDsql,omitempty"`
	VpcId            *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s AddInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s AddInstanceRequest) GoString() string {
	return s.String()
}

func (s *AddInstanceRequest) SetDataLinkName(v string) *AddInstanceRequest {
	s.DataLinkName = &v
	return s
}

func (s *AddInstanceRequest) SetDatabasePassword(v string) *AddInstanceRequest {
	s.DatabasePassword = &v
	return s
}

func (s *AddInstanceRequest) SetDatabaseUser(v string) *AddInstanceRequest {
	s.DatabaseUser = &v
	return s
}

func (s *AddInstanceRequest) SetDbaId(v int64) *AddInstanceRequest {
	s.DbaId = &v
	return s
}

func (s *AddInstanceRequest) SetDdlOnline(v int32) *AddInstanceRequest {
	s.DdlOnline = &v
	return s
}

func (s *AddInstanceRequest) SetEcsInstanceId(v string) *AddInstanceRequest {
	s.EcsInstanceId = &v
	return s
}

func (s *AddInstanceRequest) SetEcsRegion(v string) *AddInstanceRequest {
	s.EcsRegion = &v
	return s
}

func (s *AddInstanceRequest) SetEnableSellCommon(v string) *AddInstanceRequest {
	s.EnableSellCommon = &v
	return s
}

func (s *AddInstanceRequest) SetEnableSellSitd(v string) *AddInstanceRequest {
	s.EnableSellSitd = &v
	return s
}

func (s *AddInstanceRequest) SetEnableSellStable(v string) *AddInstanceRequest {
	s.EnableSellStable = &v
	return s
}

func (s *AddInstanceRequest) SetEnableSellTrust(v string) *AddInstanceRequest {
	s.EnableSellTrust = &v
	return s
}

func (s *AddInstanceRequest) SetEnvType(v string) *AddInstanceRequest {
	s.EnvType = &v
	return s
}

func (s *AddInstanceRequest) SetExportTimeout(v int32) *AddInstanceRequest {
	s.ExportTimeout = &v
	return s
}

func (s *AddInstanceRequest) SetHost(v string) *AddInstanceRequest {
	s.Host = &v
	return s
}

func (s *AddInstanceRequest) SetInstanceAlias(v string) *AddInstanceRequest {
	s.InstanceAlias = &v
	return s
}

func (s *AddInstanceRequest) SetInstanceSource(v string) *AddInstanceRequest {
	s.InstanceSource = &v
	return s
}

func (s *AddInstanceRequest) SetInstanceType(v string) *AddInstanceRequest {
	s.InstanceType = &v
	return s
}

func (s *AddInstanceRequest) SetNetworkType(v string) *AddInstanceRequest {
	s.NetworkType = &v
	return s
}

func (s *AddInstanceRequest) SetPort(v int32) *AddInstanceRequest {
	s.Port = &v
	return s
}

func (s *AddInstanceRequest) SetQueryTimeout(v int32) *AddInstanceRequest {
	s.QueryTimeout = &v
	return s
}

func (s *AddInstanceRequest) SetSafeRule(v string) *AddInstanceRequest {
	s.SafeRule = &v
	return s
}

func (s *AddInstanceRequest) SetSid(v string) *AddInstanceRequest {
	s.Sid = &v
	return s
}

func (s *AddInstanceRequest) SetSkipTest(v bool) *AddInstanceRequest {
	s.SkipTest = &v
	return s
}

func (s *AddInstanceRequest) SetTemplateId(v int64) *AddInstanceRequest {
	s.TemplateId = &v
	return s
}

func (s *AddInstanceRequest) SetTemplateType(v string) *AddInstanceRequest {
	s.TemplateType = &v
	return s
}

func (s *AddInstanceRequest) SetTid(v int64) *AddInstanceRequest {
	s.Tid = &v
	return s
}

func (s *AddInstanceRequest) SetUseDsql(v int32) *AddInstanceRequest {
	s.UseDsql = &v
	return s
}

func (s *AddInstanceRequest) SetVpcId(v string) *AddInstanceRequest {
	s.VpcId = &v
	return s
}

type AddInstanceResponseBody struct {
	ErrorCode    *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *AddInstanceResponseBody) SetErrorCode(v string) *AddInstanceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *AddInstanceResponseBody) SetErrorMessage(v string) *AddInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *AddInstanceResponseBody) SetRequestId(v string) *AddInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddInstanceResponseBody) SetSuccess(v bool) *AddInstanceResponseBody {
	s.Success = &v
	return s
}

type AddInstanceResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s AddInstanceResponse) GoString() string {
	return s.String()
}

func (s *AddInstanceResponse) SetHeaders(v map[string]*string) *AddInstanceResponse {
	s.Headers = v
	return s
}

func (s *AddInstanceResponse) SetStatusCode(v int32) *AddInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *AddInstanceResponse) SetBody(v *AddInstanceResponseBody) *AddInstanceResponse {
	s.Body = v
	return s
}

type AddLhMembersRequest struct {
	// The information about the users to be added.
	Members []*AddLhMembersRequestMembers `json:"Members,omitempty" xml:"Members,omitempty" type:"Repeated"`
	// The ID of the object.
	//
	// *   If the object is a workspace, you can call the [GetLhSpaceByName](~~424379~~) operation to obtain the workspace ID.
	// *   If the object is a task flow, you can call the [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the task flow ID.
	ObjectId *int64 `json:"ObjectId,omitempty" xml:"ObjectId,omitempty"`
	// The type of the object. Valid values:
	//
	// *   **0**: workspace
	// *   **1**: task flow
	ObjectType *int32 `json:"ObjectType,omitempty" xml:"ObjectType,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s AddLhMembersRequest) String() string {
	return tea.Prettify(s)
}

func (s AddLhMembersRequest) GoString() string {
	return s.String()
}

func (s *AddLhMembersRequest) SetMembers(v []*AddLhMembersRequestMembers) *AddLhMembersRequest {
	s.Members = v
	return s
}

func (s *AddLhMembersRequest) SetObjectId(v int64) *AddLhMembersRequest {
	s.ObjectId = &v
	return s
}

func (s *AddLhMembersRequest) SetObjectType(v int32) *AddLhMembersRequest {
	s.ObjectType = &v
	return s
}

func (s *AddLhMembersRequest) SetTid(v int64) *AddLhMembersRequest {
	s.Tid = &v
	return s
}

type AddLhMembersRequestMembers struct {
	// The role. Valid values:
	//
	// *   **ADMIN**: workspace administrator. You can add a workspace administrator only as a DMS administrator or a DBA.
	// *   **MEMBER**: workspace member.
	// *   **DEVELOPER**: task flow developer. Only a workspace member can be added as a task flow developer.
	Roles []*string `json:"Roles,omitempty" xml:"Roles,omitempty" type:"Repeated"`
	// The ID of the user to be added. You can call the [ListUsers](~~141938~~) or [GetUser](~~147098~~) operation to obtain the user ID.
	UserId *int64 `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s AddLhMembersRequestMembers) String() string {
	return tea.Prettify(s)
}

func (s AddLhMembersRequestMembers) GoString() string {
	return s.String()
}

func (s *AddLhMembersRequestMembers) SetRoles(v []*string) *AddLhMembersRequestMembers {
	s.Roles = v
	return s
}

func (s *AddLhMembersRequestMembers) SetUserId(v int64) *AddLhMembersRequestMembers {
	s.UserId = &v
	return s
}

type AddLhMembersShrinkRequest struct {
	// The information about the users to be added.
	MembersShrink *string `json:"Members,omitempty" xml:"Members,omitempty"`
	// The ID of the object.
	//
	// *   If the object is a workspace, you can call the [GetLhSpaceByName](~~424379~~) operation to obtain the workspace ID.
	// *   If the object is a task flow, you can call the [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the task flow ID.
	ObjectId *int64 `json:"ObjectId,omitempty" xml:"ObjectId,omitempty"`
	// The type of the object. Valid values:
	//
	// *   **0**: workspace
	// *   **1**: task flow
	ObjectType *int32 `json:"ObjectType,omitempty" xml:"ObjectType,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s AddLhMembersShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s AddLhMembersShrinkRequest) GoString() string {
	return s.String()
}

func (s *AddLhMembersShrinkRequest) SetMembersShrink(v string) *AddLhMembersShrinkRequest {
	s.MembersShrink = &v
	return s
}

func (s *AddLhMembersShrinkRequest) SetObjectId(v int64) *AddLhMembersShrinkRequest {
	s.ObjectId = &v
	return s
}

func (s *AddLhMembersShrinkRequest) SetObjectType(v int32) *AddLhMembersShrinkRequest {
	s.ObjectType = &v
	return s
}

func (s *AddLhMembersShrinkRequest) SetTid(v int64) *AddLhMembersShrinkRequest {
	s.Tid = &v
	return s
}

type AddLhMembersResponseBody struct {
	// The error code returned if the request fails.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**: The request is successful.
	// *   **false**: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddLhMembersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddLhMembersResponseBody) GoString() string {
	return s.String()
}

func (s *AddLhMembersResponseBody) SetErrorCode(v string) *AddLhMembersResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *AddLhMembersResponseBody) SetErrorMessage(v string) *AddLhMembersResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *AddLhMembersResponseBody) SetRequestId(v string) *AddLhMembersResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddLhMembersResponseBody) SetSuccess(v bool) *AddLhMembersResponseBody {
	s.Success = &v
	return s
}

type AddLhMembersResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddLhMembersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddLhMembersResponse) String() string {
	return tea.Prettify(s)
}

func (s AddLhMembersResponse) GoString() string {
	return s.String()
}

func (s *AddLhMembersResponse) SetHeaders(v map[string]*string) *AddLhMembersResponse {
	s.Headers = v
	return s
}

func (s *AddLhMembersResponse) SetStatusCode(v int32) *AddLhMembersResponse {
	s.StatusCode = &v
	return s
}

func (s *AddLhMembersResponse) SetBody(v *AddLhMembersResponseBody) *AddLhMembersResponse {
	s.Body = v
	return s
}

type AddLogicTableRouteConfigRequest struct {
	// The routing algorithm expression. For more information about how to configure a routing algorithm expression, see [Configure a routing algorithm](https://www.alibabacloud.com/help/en/data-management-service/latest/configure-a-routing-algorithm).
	RouteExpr *string `json:"RouteExpr,omitempty" xml:"RouteExpr,omitempty"`
	// The unique key of the routing algorithm.
	//
	// > - You can create a custom unique key for the routing algorithm. No requirements are imposed on custom unique keys.
	// > - The unique key of the routing algorithm in the same logical table must be unique.
	RouteKey *string `json:"RouteKey,omitempty" xml:"RouteKey,omitempty"`
	// The ID of the logical table. You can call the [ListLogicTables](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogictables) operation to query the ID of the logical table.
	TableId *int64 `json:"TableId,omitempty" xml:"TableId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s AddLogicTableRouteConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s AddLogicTableRouteConfigRequest) GoString() string {
	return s.String()
}

func (s *AddLogicTableRouteConfigRequest) SetRouteExpr(v string) *AddLogicTableRouteConfigRequest {
	s.RouteExpr = &v
	return s
}

func (s *AddLogicTableRouteConfigRequest) SetRouteKey(v string) *AddLogicTableRouteConfigRequest {
	s.RouteKey = &v
	return s
}

func (s *AddLogicTableRouteConfigRequest) SetTableId(v int64) *AddLogicTableRouteConfigRequest {
	s.TableId = &v
	return s
}

func (s *AddLogicTableRouteConfigRequest) SetTid(v int64) *AddLogicTableRouteConfigRequest {
	s.Tid = &v
	return s
}

type AddLogicTableRouteConfigResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// - **true**: The request was successful.
	// - **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddLogicTableRouteConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddLogicTableRouteConfigResponseBody) GoString() string {
	return s.String()
}

func (s *AddLogicTableRouteConfigResponseBody) SetErrorCode(v string) *AddLogicTableRouteConfigResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *AddLogicTableRouteConfigResponseBody) SetErrorMessage(v string) *AddLogicTableRouteConfigResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *AddLogicTableRouteConfigResponseBody) SetRequestId(v string) *AddLogicTableRouteConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddLogicTableRouteConfigResponseBody) SetSuccess(v bool) *AddLogicTableRouteConfigResponseBody {
	s.Success = &v
	return s
}

type AddLogicTableRouteConfigResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddLogicTableRouteConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddLogicTableRouteConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s AddLogicTableRouteConfigResponse) GoString() string {
	return s.String()
}

func (s *AddLogicTableRouteConfigResponse) SetHeaders(v map[string]*string) *AddLogicTableRouteConfigResponse {
	s.Headers = v
	return s
}

func (s *AddLogicTableRouteConfigResponse) SetStatusCode(v int32) *AddLogicTableRouteConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *AddLogicTableRouteConfigResponse) SetBody(v *AddLogicTableRouteConfigResponseBody) *AddLogicTableRouteConfigResponse {
	s.Body = v
	return s
}

type AddTaskFlowEdgesRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The list of edges of the task flow.
	Edges []*AddTaskFlowEdgesRequestEdges `json:"Edges,omitempty" xml:"Edges,omitempty" type:"Repeated"`
	// The ID of the tenant.
	//
	// > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s AddTaskFlowEdgesRequest) String() string {
	return tea.Prettify(s)
}

func (s AddTaskFlowEdgesRequest) GoString() string {
	return s.String()
}

func (s *AddTaskFlowEdgesRequest) SetDagId(v int64) *AddTaskFlowEdgesRequest {
	s.DagId = &v
	return s
}

func (s *AddTaskFlowEdgesRequest) SetEdges(v []*AddTaskFlowEdgesRequestEdges) *AddTaskFlowEdgesRequest {
	s.Edges = v
	return s
}

func (s *AddTaskFlowEdgesRequest) SetTid(v int64) *AddTaskFlowEdgesRequest {
	s.Tid = &v
	return s
}

type AddTaskFlowEdgesRequestEdges struct {
	// The ID of the node where the end node of the edge is located.
	NodeEnd *int64 `json:"NodeEnd,omitempty" xml:"NodeEnd,omitempty"`
	// The ID of the node where the start node of the edge is located.
	NodeFrom *int64 `json:"NodeFrom,omitempty" xml:"NodeFrom,omitempty"`
}

func (s AddTaskFlowEdgesRequestEdges) String() string {
	return tea.Prettify(s)
}

func (s AddTaskFlowEdgesRequestEdges) GoString() string {
	return s.String()
}

func (s *AddTaskFlowEdgesRequestEdges) SetNodeEnd(v int64) *AddTaskFlowEdgesRequestEdges {
	s.NodeEnd = &v
	return s
}

func (s *AddTaskFlowEdgesRequestEdges) SetNodeFrom(v int64) *AddTaskFlowEdgesRequestEdges {
	s.NodeFrom = &v
	return s
}

type AddTaskFlowEdgesShrinkRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The list of edges of the task flow.
	EdgesShrink *string `json:"Edges,omitempty" xml:"Edges,omitempty"`
	// The ID of the tenant.
	//
	// > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s AddTaskFlowEdgesShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s AddTaskFlowEdgesShrinkRequest) GoString() string {
	return s.String()
}

func (s *AddTaskFlowEdgesShrinkRequest) SetDagId(v int64) *AddTaskFlowEdgesShrinkRequest {
	s.DagId = &v
	return s
}

func (s *AddTaskFlowEdgesShrinkRequest) SetEdgesShrink(v string) *AddTaskFlowEdgesShrinkRequest {
	s.EdgesShrink = &v
	return s
}

func (s *AddTaskFlowEdgesShrinkRequest) SetTid(v int64) *AddTaskFlowEdgesShrinkRequest {
	s.Tid = &v
	return s
}

type AddTaskFlowEdgesResponseBody struct {
	// The list of task flow edge IDs.
	EdgeIds *AddTaskFlowEdgesResponseBodyEdgeIds `json:"EdgeIds,omitempty" xml:"EdgeIds,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddTaskFlowEdgesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddTaskFlowEdgesResponseBody) GoString() string {
	return s.String()
}

func (s *AddTaskFlowEdgesResponseBody) SetEdgeIds(v *AddTaskFlowEdgesResponseBodyEdgeIds) *AddTaskFlowEdgesResponseBody {
	s.EdgeIds = v
	return s
}

func (s *AddTaskFlowEdgesResponseBody) SetErrorCode(v string) *AddTaskFlowEdgesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *AddTaskFlowEdgesResponseBody) SetErrorMessage(v string) *AddTaskFlowEdgesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *AddTaskFlowEdgesResponseBody) SetRequestId(v string) *AddTaskFlowEdgesResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddTaskFlowEdgesResponseBody) SetSuccess(v bool) *AddTaskFlowEdgesResponseBody {
	s.Success = &v
	return s
}

type AddTaskFlowEdgesResponseBodyEdgeIds struct {
	EdgeId []*int64 `json:"EdgeId,omitempty" xml:"EdgeId,omitempty" type:"Repeated"`
}

func (s AddTaskFlowEdgesResponseBodyEdgeIds) String() string {
	return tea.Prettify(s)
}

func (s AddTaskFlowEdgesResponseBodyEdgeIds) GoString() string {
	return s.String()
}

func (s *AddTaskFlowEdgesResponseBodyEdgeIds) SetEdgeId(v []*int64) *AddTaskFlowEdgesResponseBodyEdgeIds {
	s.EdgeId = v
	return s
}

type AddTaskFlowEdgesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddTaskFlowEdgesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddTaskFlowEdgesResponse) String() string {
	return tea.Prettify(s)
}

func (s AddTaskFlowEdgesResponse) GoString() string {
	return s.String()
}

func (s *AddTaskFlowEdgesResponse) SetHeaders(v map[string]*string) *AddTaskFlowEdgesResponse {
	s.Headers = v
	return s
}

func (s *AddTaskFlowEdgesResponse) SetStatusCode(v int32) *AddTaskFlowEdgesResponse {
	s.StatusCode = &v
	return s
}

func (s *AddTaskFlowEdgesResponse) SetBody(v *AddTaskFlowEdgesResponseBody) *AddTaskFlowEdgesResponse {
	s.Body = v
	return s
}

type AnalyzeSQLLineageRequest struct {
	// The database ID.
	//
	// >  You can call one of the [SearchDatabase](~~141876~~), [ListDatabases](~~141873~~), and [GetDatabase](~~141869~~) operations to obtain the database ID provided in the DatabaseId response parameter.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The SQL statement.
	SqlContent *string `json:"SqlContent,omitempty" xml:"SqlContent,omitempty"`
	// The tenant ID.
	//
	// >  To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s AnalyzeSQLLineageRequest) String() string {
	return tea.Prettify(s)
}

func (s AnalyzeSQLLineageRequest) GoString() string {
	return s.String()
}

func (s *AnalyzeSQLLineageRequest) SetDbId(v int64) *AnalyzeSQLLineageRequest {
	s.DbId = &v
	return s
}

func (s *AnalyzeSQLLineageRequest) SetSqlContent(v string) *AnalyzeSQLLineageRequest {
	s.SqlContent = &v
	return s
}

func (s *AnalyzeSQLLineageRequest) SetTid(v int64) *AnalyzeSQLLineageRequest {
	s.Tid = &v
	return s
}

type AnalyzeSQLLineageResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// Returned data set of SQL lineage.
	LineageResult *AnalyzeSQLLineageResponseBodyLineageResult `json:"LineageResult,omitempty" xml:"LineageResult,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AnalyzeSQLLineageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AnalyzeSQLLineageResponseBody) GoString() string {
	return s.String()
}

func (s *AnalyzeSQLLineageResponseBody) SetErrorCode(v string) *AnalyzeSQLLineageResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *AnalyzeSQLLineageResponseBody) SetErrorMessage(v string) *AnalyzeSQLLineageResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *AnalyzeSQLLineageResponseBody) SetLineageResult(v *AnalyzeSQLLineageResponseBodyLineageResult) *AnalyzeSQLLineageResponseBody {
	s.LineageResult = v
	return s
}

func (s *AnalyzeSQLLineageResponseBody) SetRequestId(v string) *AnalyzeSQLLineageResponseBody {
	s.RequestId = &v
	return s
}

func (s *AnalyzeSQLLineageResponseBody) SetSuccess(v bool) *AnalyzeSQLLineageResponseBody {
	s.Success = &v
	return s
}

type AnalyzeSQLLineageResponseBodyLineageResult struct {
	// The details about the lineage.
	Lineages []*AnalyzeSQLLineageResponseBodyLineageResultLineages `json:"Lineages,omitempty" xml:"Lineages,omitempty" type:"Repeated"`
	// The table and field metadata information.
	ObjectMetadata []*AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata `json:"ObjectMetadata,omitempty" xml:"ObjectMetadata,omitempty" type:"Repeated"`
}

func (s AnalyzeSQLLineageResponseBodyLineageResult) String() string {
	return tea.Prettify(s)
}

func (s AnalyzeSQLLineageResponseBodyLineageResult) GoString() string {
	return s.String()
}

func (s *AnalyzeSQLLineageResponseBodyLineageResult) SetLineages(v []*AnalyzeSQLLineageResponseBodyLineageResultLineages) *AnalyzeSQLLineageResponseBodyLineageResult {
	s.Lineages = v
	return s
}

func (s *AnalyzeSQLLineageResponseBodyLineageResult) SetObjectMetadata(v []*AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata) *AnalyzeSQLLineageResponseBodyLineageResult {
	s.ObjectMetadata = v
	return s
}

type AnalyzeSQLLineageResponseBodyLineageResultLineages struct {
	// The target.
	Dst *string `json:"Dst,omitempty" xml:"Dst,omitempty"`
	// The type of the lineage. Valid values:
	//
	// *   **FIELD_DEPEND_FIELD**: Fields depend on fields.
	// *   **TABLE_DEPEND_TABLE**: Tables depend on tables.
	// *   **FIELD_INFLU_TABLE**: Fields influence tables.
	// *   **FIELD_INFLU_FIELD**: Fields influence fields.
	// *   **FIELD_INFLU_TABLE**: Tables influence fields.
	// *   **FIELD_JOIN_FIELD**: Fields are associated with fields.
	LineageType *string `json:"LineageType,omitempty" xml:"LineageType,omitempty"`
	// The operation type of the SQL statement in which the data lineage is generated. For example, if the operation type is SELECT, the data lineage is generated from a SELECT statement.
	//
	// >  This field is an extended field which has no practical use.
	OperType *string `json:"OperType,omitempty" xml:"OperType,omitempty"`
	// The handling details. This parameter is returned only when LineageType is FIELD_DEPEND_FIELD.
	ProcessDetail *AnalyzeSQLLineageResponseBodyLineageResultLineagesProcessDetail `json:"ProcessDetail,omitempty" xml:"ProcessDetail,omitempty" type:"Struct"`
	// The source.
	Src *string `json:"Src,omitempty" xml:"Src,omitempty"`
}

func (s AnalyzeSQLLineageResponseBodyLineageResultLineages) String() string {
	return tea.Prettify(s)
}

func (s AnalyzeSQLLineageResponseBodyLineageResultLineages) GoString() string {
	return s.String()
}

func (s *AnalyzeSQLLineageResponseBodyLineageResultLineages) SetDst(v string) *AnalyzeSQLLineageResponseBodyLineageResultLineages {
	s.Dst = &v
	return s
}

func (s *AnalyzeSQLLineageResponseBodyLineageResultLineages) SetLineageType(v string) *AnalyzeSQLLineageResponseBodyLineageResultLineages {
	s.LineageType = &v
	return s
}

func (s *AnalyzeSQLLineageResponseBodyLineageResultLineages) SetOperType(v string) *AnalyzeSQLLineageResponseBodyLineageResultLineages {
	s.OperType = &v
	return s
}

func (s *AnalyzeSQLLineageResponseBodyLineageResultLineages) SetProcessDetail(v *AnalyzeSQLLineageResponseBodyLineageResultLineagesProcessDetail) *AnalyzeSQLLineageResponseBodyLineageResultLineages {
	s.ProcessDetail = v
	return s
}

func (s *AnalyzeSQLLineageResponseBodyLineageResultLineages) SetSrc(v string) *AnalyzeSQLLineageResponseBodyLineageResultLineages {
	s.Src = &v
	return s
}

type AnalyzeSQLLineageResponseBodyLineageResultLineagesProcessDetail struct {
	// The calculating method. Valid values:
	//
	// *   **DIRECT**: No function or expression is used.
	// *   **EXPR**: A function or expression is used.
	CalWay *string `json:"CalWay,omitempty" xml:"CalWay,omitempty"`
	// The SQL code snippet for field processing.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
}

func (s AnalyzeSQLLineageResponseBodyLineageResultLineagesProcessDetail) String() string {
	return tea.Prettify(s)
}

func (s AnalyzeSQLLineageResponseBodyLineageResultLineagesProcessDetail) GoString() string {
	return s.String()
}

func (s *AnalyzeSQLLineageResponseBodyLineageResultLineagesProcessDetail) SetCalWay(v string) *AnalyzeSQLLineageResponseBodyLineageResultLineagesProcessDetail {
	s.CalWay = &v
	return s
}

func (s *AnalyzeSQLLineageResponseBodyLineageResultLineagesProcessDetail) SetCode(v string) *AnalyzeSQLLineageResponseBodyLineageResultLineagesProcessDetail {
	s.Code = &v
	return s
}

type AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata struct {
	// The fields in the metatable.
	Fields []*AnalyzeSQLLineageResponseBodyLineageResultObjectMetadataFields `json:"Fields,omitempty" xml:"Fields,omitempty" type:"Repeated"`
	// The object name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The source of metadata. Valid values:
	//
	// *   **DDL**: The metadata comes from parsed SQL statements or definition of databases and tables collected by DMS.
	// *   **LINEAGE**: The metadata comes from lineage analysis results.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The object type. Valid values:
	//
	// *   **TABLE**
	// *   **VIEW**
	// *   **TMP_TABLE**
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata) String() string {
	return tea.Prettify(s)
}

func (s AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata) GoString() string {
	return s.String()
}

func (s *AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata) SetFields(v []*AnalyzeSQLLineageResponseBodyLineageResultObjectMetadataFields) *AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata {
	s.Fields = v
	return s
}

func (s *AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata) SetName(v string) *AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata {
	s.Name = &v
	return s
}

func (s *AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata) SetSource(v string) *AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata {
	s.Source = &v
	return s
}

func (s *AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata) SetType(v string) *AnalyzeSQLLineageResponseBodyLineageResultObjectMetadata {
	s.Type = &v
	return s
}

type AnalyzeSQLLineageResponseBodyLineageResultObjectMetadataFields struct {
	// The name of the field.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s AnalyzeSQLLineageResponseBodyLineageResultObjectMetadataFields) String() string {
	return tea.Prettify(s)
}

func (s AnalyzeSQLLineageResponseBodyLineageResultObjectMetadataFields) GoString() string {
	return s.String()
}

func (s *AnalyzeSQLLineageResponseBodyLineageResultObjectMetadataFields) SetName(v string) *AnalyzeSQLLineageResponseBodyLineageResultObjectMetadataFields {
	s.Name = &v
	return s
}

type AnalyzeSQLLineageResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AnalyzeSQLLineageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AnalyzeSQLLineageResponse) String() string {
	return tea.Prettify(s)
}

func (s AnalyzeSQLLineageResponse) GoString() string {
	return s.String()
}

func (s *AnalyzeSQLLineageResponse) SetHeaders(v map[string]*string) *AnalyzeSQLLineageResponse {
	s.Headers = v
	return s
}

func (s *AnalyzeSQLLineageResponse) SetStatusCode(v int32) *AnalyzeSQLLineageResponse {
	s.StatusCode = &v
	return s
}

func (s *AnalyzeSQLLineageResponse) SetBody(v *AnalyzeSQLLineageResponseBody) *AnalyzeSQLLineageResponse {
	s.Body = v
	return s
}

type ApproveOrderRequest struct {
	// If ApprovalType is set to ADD_APPROVAL_NODE, you need to specify this parameter. The ID of the user that is added as the new approval node. This node must be a user-defined approval node. You can call the ListUserDefineWorkFlowNodes operation to obtain the value of this parameter.
	ApprovalNodeId *int64 `json:"ApprovalNodeId,omitempty" xml:"ApprovalNodeId,omitempty"`
	// If ApprovalType is set to ADD_APPROVAL_NODE, you need to specify this parameter. The position of the new approval node. Valid values:
	//
	// *   **PRE_ADD_APPROVAL_NODE**: before the current approval node.
	// *   **POST_ADD_APPROVAL_NODE**: after the current approval node.
	ApprovalNodePos *string `json:"ApprovalNodePos,omitempty" xml:"ApprovalNodePos,omitempty"`
	// The action that you want to perform on the ticket. Valid values:
	//
	// *   **AGREE**
	// *   **CANCEL**
	// *   **REJECT**
	// *   **TRANSFER**
	// *   **ADD_APPROVAL_NODE**
	ApprovalType *string `json:"ApprovalType,omitempty" xml:"ApprovalType,omitempty"`
	// The description of the ticket.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The ID of the user to which the ticket is transferred. If ApprovalType is set to TRANSFER, you need to specify this parameter.
	NewApprover *int64 `json:"NewApprover,omitempty" xml:"NewApprover,omitempty"`
	// The ID of the user that transfers the ticket to another user. The default value is the ID of the current user. If the current user is an administrator or a database administrator (DBA), the user can change the value of this parameter to the ID of another user.
	OldApprover *int64 `json:"OldApprover,omitempty" xml:"OldApprover,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The ID of the approval process. You can call the [GetOrderBaseInfo](~~144642~~) operation to obtain the ID of the approval process.
	WorkflowInstanceId *int64 `json:"WorkflowInstanceId,omitempty" xml:"WorkflowInstanceId,omitempty"`
}

func (s ApproveOrderRequest) String() string {
	return tea.Prettify(s)
}

func (s ApproveOrderRequest) GoString() string {
	return s.String()
}

func (s *ApproveOrderRequest) SetApprovalNodeId(v int64) *ApproveOrderRequest {
	s.ApprovalNodeId = &v
	return s
}

func (s *ApproveOrderRequest) SetApprovalNodePos(v string) *ApproveOrderRequest {
	s.ApprovalNodePos = &v
	return s
}

func (s *ApproveOrderRequest) SetApprovalType(v string) *ApproveOrderRequest {
	s.ApprovalType = &v
	return s
}

func (s *ApproveOrderRequest) SetComment(v string) *ApproveOrderRequest {
	s.Comment = &v
	return s
}

func (s *ApproveOrderRequest) SetNewApprover(v int64) *ApproveOrderRequest {
	s.NewApprover = &v
	return s
}

func (s *ApproveOrderRequest) SetOldApprover(v int64) *ApproveOrderRequest {
	s.OldApprover = &v
	return s
}

func (s *ApproveOrderRequest) SetTid(v int64) *ApproveOrderRequest {
	s.Tid = &v
	return s
}

func (s *ApproveOrderRequest) SetWorkflowInstanceId(v int64) *ApproveOrderRequest {
	s.WorkflowInstanceId = &v
	return s
}

type ApproveOrderResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ApproveOrderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ApproveOrderResponseBody) GoString() string {
	return s.String()
}

func (s *ApproveOrderResponseBody) SetErrorCode(v string) *ApproveOrderResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ApproveOrderResponseBody) SetErrorMessage(v string) *ApproveOrderResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ApproveOrderResponseBody) SetRequestId(v string) *ApproveOrderResponseBody {
	s.RequestId = &v
	return s
}

func (s *ApproveOrderResponseBody) SetSuccess(v bool) *ApproveOrderResponseBody {
	s.Success = &v
	return s
}

type ApproveOrderResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ApproveOrderResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ApproveOrderResponse) String() string {
	return tea.Prettify(s)
}

func (s ApproveOrderResponse) GoString() string {
	return s.String()
}

func (s *ApproveOrderResponse) SetHeaders(v map[string]*string) *ApproveOrderResponse {
	s.Headers = v
	return s
}

func (s *ApproveOrderResponse) SetStatusCode(v int32) *ApproveOrderResponse {
	s.StatusCode = &v
	return s
}

func (s *ApproveOrderResponse) SetBody(v *ApproveOrderResponseBody) *ApproveOrderResponse {
	s.Body = v
	return s
}

type BackFillRequest struct {
	// The running sequence of task flows for data backfill. Valid values:
	//
	// *   **0**: reverse chronological order.
	// *   **1**: chronological order. This is the default value.
	Asc *bool `json:"Asc,omitempty" xml:"Asc,omitempty"`
	// The date for the data to be backfilled. This parameter is required if you specify a date for data backfill.
	BackFillDate *string `json:"BackFillDate,omitempty" xml:"BackFillDate,omitempty"`
	// The start date of the date range for the data to be backfilled. This parameter is required if you specify a date range for data backfill.
	BackFillDateBegin *string `json:"BackFillDateBegin,omitempty" xml:"BackFillDateBegin,omitempty"`
	// The end date of the date range for the data to be backfilled. This parameter is required if you specify a date range for data backfill.
	BackFillDateEnd *string `json:"BackFillDateEnd,omitempty" xml:"BackFillDateEnd,omitempty"`
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// Filter condition, which specifies the list of node IDs in the task flow that do not need to supplement data.
	FilterNodeIds []*int64 `json:"FilterNodeIds,omitempty" xml:"FilterNodeIds,omitempty" type:"Repeated"`
	// The ID of the historical task flow.
	HistoryDagId *int64 `json:"HistoryDagId,omitempty" xml:"HistoryDagId,omitempty"`
	// The interval at which data backfill is performed. Unit: hours. Minimum value: 1. Default value: 24.
	Interval *int32 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// Specifies whether to run descendant nodes. Default value: true.
	IsTriggerSubTree *bool `json:"IsTriggerSubTree,omitempty" xml:"IsTriggerSubTree,omitempty"`
	// The number of nodes for which you want to backfill data.
	StartNodeIds []*int64 `json:"StartNodeIds,omitempty" xml:"StartNodeIds,omitempty" type:"Repeated"`
	// The ID of the tenant.
	//
	// >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s BackFillRequest) String() string {
	return tea.Prettify(s)
}

func (s BackFillRequest) GoString() string {
	return s.String()
}

func (s *BackFillRequest) SetAsc(v bool) *BackFillRequest {
	s.Asc = &v
	return s
}

func (s *BackFillRequest) SetBackFillDate(v string) *BackFillRequest {
	s.BackFillDate = &v
	return s
}

func (s *BackFillRequest) SetBackFillDateBegin(v string) *BackFillRequest {
	s.BackFillDateBegin = &v
	return s
}

func (s *BackFillRequest) SetBackFillDateEnd(v string) *BackFillRequest {
	s.BackFillDateEnd = &v
	return s
}

func (s *BackFillRequest) SetDagId(v int64) *BackFillRequest {
	s.DagId = &v
	return s
}

func (s *BackFillRequest) SetFilterNodeIds(v []*int64) *BackFillRequest {
	s.FilterNodeIds = v
	return s
}

func (s *BackFillRequest) SetHistoryDagId(v int64) *BackFillRequest {
	s.HistoryDagId = &v
	return s
}

func (s *BackFillRequest) SetInterval(v int32) *BackFillRequest {
	s.Interval = &v
	return s
}

func (s *BackFillRequest) SetIsTriggerSubTree(v bool) *BackFillRequest {
	s.IsTriggerSubTree = &v
	return s
}

func (s *BackFillRequest) SetStartNodeIds(v []*int64) *BackFillRequest {
	s.StartNodeIds = v
	return s
}

func (s *BackFillRequest) SetTid(v int64) *BackFillRequest {
	s.Tid = &v
	return s
}

type BackFillShrinkRequest struct {
	// The running sequence of task flows for data backfill. Valid values:
	//
	// *   **0**: reverse chronological order.
	// *   **1**: chronological order. This is the default value.
	Asc *bool `json:"Asc,omitempty" xml:"Asc,omitempty"`
	// The date for the data to be backfilled. This parameter is required if you specify a date for data backfill.
	BackFillDate *string `json:"BackFillDate,omitempty" xml:"BackFillDate,omitempty"`
	// The start date of the date range for the data to be backfilled. This parameter is required if you specify a date range for data backfill.
	BackFillDateBegin *string `json:"BackFillDateBegin,omitempty" xml:"BackFillDateBegin,omitempty"`
	// The end date of the date range for the data to be backfilled. This parameter is required if you specify a date range for data backfill.
	BackFillDateEnd *string `json:"BackFillDateEnd,omitempty" xml:"BackFillDateEnd,omitempty"`
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// Filter condition, which specifies the list of node IDs in the task flow that do not need to supplement data.
	FilterNodeIdsShrink *string `json:"FilterNodeIds,omitempty" xml:"FilterNodeIds,omitempty"`
	// The ID of the historical task flow.
	HistoryDagId *int64 `json:"HistoryDagId,omitempty" xml:"HistoryDagId,omitempty"`
	// The interval at which data backfill is performed. Unit: hours. Minimum value: 1. Default value: 24.
	Interval *int32 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// Specifies whether to run descendant nodes. Default value: true.
	IsTriggerSubTree *bool `json:"IsTriggerSubTree,omitempty" xml:"IsTriggerSubTree,omitempty"`
	// The number of nodes for which you want to backfill data.
	StartNodeIdsShrink *string `json:"StartNodeIds,omitempty" xml:"StartNodeIds,omitempty"`
	// The ID of the tenant.
	//
	// >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s BackFillShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s BackFillShrinkRequest) GoString() string {
	return s.String()
}

func (s *BackFillShrinkRequest) SetAsc(v bool) *BackFillShrinkRequest {
	s.Asc = &v
	return s
}

func (s *BackFillShrinkRequest) SetBackFillDate(v string) *BackFillShrinkRequest {
	s.BackFillDate = &v
	return s
}

func (s *BackFillShrinkRequest) SetBackFillDateBegin(v string) *BackFillShrinkRequest {
	s.BackFillDateBegin = &v
	return s
}

func (s *BackFillShrinkRequest) SetBackFillDateEnd(v string) *BackFillShrinkRequest {
	s.BackFillDateEnd = &v
	return s
}

func (s *BackFillShrinkRequest) SetDagId(v int64) *BackFillShrinkRequest {
	s.DagId = &v
	return s
}

func (s *BackFillShrinkRequest) SetFilterNodeIdsShrink(v string) *BackFillShrinkRequest {
	s.FilterNodeIdsShrink = &v
	return s
}

func (s *BackFillShrinkRequest) SetHistoryDagId(v int64) *BackFillShrinkRequest {
	s.HistoryDagId = &v
	return s
}

func (s *BackFillShrinkRequest) SetInterval(v int32) *BackFillShrinkRequest {
	s.Interval = &v
	return s
}

func (s *BackFillShrinkRequest) SetIsTriggerSubTree(v bool) *BackFillShrinkRequest {
	s.IsTriggerSubTree = &v
	return s
}

func (s *BackFillShrinkRequest) SetStartNodeIdsShrink(v string) *BackFillShrinkRequest {
	s.StartNodeIdsShrink = &v
	return s
}

func (s *BackFillShrinkRequest) SetTid(v int64) *BackFillShrinkRequest {
	s.Tid = &v
	return s
}

type BackFillResponseBody struct {
	// The ID of the execution record of the task flow.
	DagInstanceId *int64 `json:"DagInstanceId,omitempty" xml:"DagInstanceId,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the node.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BackFillResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BackFillResponseBody) GoString() string {
	return s.String()
}

func (s *BackFillResponseBody) SetDagInstanceId(v int64) *BackFillResponseBody {
	s.DagInstanceId = &v
	return s
}

func (s *BackFillResponseBody) SetErrorCode(v string) *BackFillResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *BackFillResponseBody) SetErrorMessage(v string) *BackFillResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BackFillResponseBody) SetNodeId(v int64) *BackFillResponseBody {
	s.NodeId = &v
	return s
}

func (s *BackFillResponseBody) SetRequestId(v string) *BackFillResponseBody {
	s.RequestId = &v
	return s
}

func (s *BackFillResponseBody) SetSuccess(v bool) *BackFillResponseBody {
	s.Success = &v
	return s
}

type BackFillResponse struct {
	Headers    map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BackFillResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BackFillResponse) String() string {
	return tea.Prettify(s)
}

func (s BackFillResponse) GoString() string {
	return s.String()
}

func (s *BackFillResponse) SetHeaders(v map[string]*string) *BackFillResponse {
	s.Headers = v
	return s
}

func (s *BackFillResponse) SetStatusCode(v int32) *BackFillResponse {
	s.StatusCode = &v
	return s
}

func (s *BackFillResponse) SetBody(v *BackFillResponseBody) *BackFillResponse {
	s.Body = v
	return s
}

type BuyPayAsYouGoOrderRequest struct {
	// The type of the resource that you want to purchase.
	//
	// *   **VersionType**: DMS that supports control modes
	// *   **SensitiveDataProtection**: DMS that supports sensitive data protection
	CommodityType *string `json:"CommodityType,omitempty" xml:"CommodityType,omitempty"`
	// The number of database instances that you want to use DMS to manage.
	//
	// > A quota can be used for only one database instance.
	InsNum *int32 `json:"InsNum,omitempty" xml:"InsNum,omitempty"`
	// The ID of the tenant.
	//
	// > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The control mode of DMS. Valid values:
	//
	// *   **stand**: Stable Change
	// *   **safety**: Security Collaboration
	VersionType *string `json:"VersionType,omitempty" xml:"VersionType,omitempty"`
}

func (s BuyPayAsYouGoOrderRequest) String() string {
	return tea.Prettify(s)
}

func (s BuyPayAsYouGoOrderRequest) GoString() string {
	return s.String()
}

func (s *BuyPayAsYouGoOrderRequest) SetCommodityType(v string) *BuyPayAsYouGoOrderRequest {
	s.CommodityType = &v
	return s
}

func (s *BuyPayAsYouGoOrderRequest) SetInsNum(v int32) *BuyPayAsYouGoOrderRequest {
	s.InsNum = &v
	return s
}

func (s *BuyPayAsYouGoOrderRequest) SetTid(v int64) *BuyPayAsYouGoOrderRequest {
	s.Tid = &v
	return s
}

func (s *BuyPayAsYouGoOrderRequest) SetVersionType(v string) *BuyPayAsYouGoOrderRequest {
	s.VersionType = &v
	return s
}

type BuyPayAsYouGoOrderResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// If the purchase is successful, the ID of the purchased instance is returned.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BuyPayAsYouGoOrderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BuyPayAsYouGoOrderResponseBody) GoString() string {
	return s.String()
}

func (s *BuyPayAsYouGoOrderResponseBody) SetErrorCode(v string) *BuyPayAsYouGoOrderResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *BuyPayAsYouGoOrderResponseBody) SetErrorMessage(v string) *BuyPayAsYouGoOrderResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BuyPayAsYouGoOrderResponseBody) SetInstanceId(v string) *BuyPayAsYouGoOrderResponseBody {
	s.InstanceId = &v
	return s
}

func (s *BuyPayAsYouGoOrderResponseBody) SetRequestId(v string) *BuyPayAsYouGoOrderResponseBody {
	s.RequestId = &v
	return s
}

func (s *BuyPayAsYouGoOrderResponseBody) SetSuccess(v bool) *BuyPayAsYouGoOrderResponseBody {
	s.Success = &v
	return s
}

type BuyPayAsYouGoOrderResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BuyPayAsYouGoOrderResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BuyPayAsYouGoOrderResponse) String() string {
	return tea.Prettify(s)
}

func (s BuyPayAsYouGoOrderResponse) GoString() string {
	return s.String()
}

func (s *BuyPayAsYouGoOrderResponse) SetHeaders(v map[string]*string) *BuyPayAsYouGoOrderResponse {
	s.Headers = v
	return s
}

func (s *BuyPayAsYouGoOrderResponse) SetStatusCode(v int32) *BuyPayAsYouGoOrderResponse {
	s.StatusCode = &v
	return s
}

func (s *BuyPayAsYouGoOrderResponse) SetBody(v *BuyPayAsYouGoOrderResponseBody) *BuyPayAsYouGoOrderResponse {
	s.Body = v
	return s
}

type ChangeColumnSecLevelRequest struct {
	// The name of the field. You can call the [ListSensitiveColumns](~~188103~~) operation to obtain the name of the field.
	//
	// > You can also call the [ListColumns](~~141870~~) operation to obtain the name of the field.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The ID of the database. You can call the [SearchDatabase](~~141876~~) operation to obtain the ID of the database.
	//
	// > You can also call the [ListDatabases](~~141873~~) operation to obtain the ID of a physical database and the [ListLogicDatabases](~~141874~~) operation to obtain the ID of a logical database.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// Specifies whether the database is a logical database. Valid values:
	//
	// *   true: The database is a physical database.
	// *   false: The database is a logical database.
	IsLogic *bool `json:"IsLogic,omitempty" xml:"IsLogic,omitempty"`
	// The new sensitivity level of the field that you want to specify. Valid values:
	//
	// *   INNER: low sensitivity level
	// *   SENSITIVE: medium sensitivity level
	// *   CONFIDENTIAL: high sensitivity level
	NewLevel *string `json:"NewLevel,omitempty" xml:"NewLevel,omitempty"`
	// The name of the database. You can call the [ListSensitiveColumns](~~188103~~) operation to obtain the name of the database.
	//
	// *   You can also call the [SearchDatabase](~~141876~~) operation to obtain the name of the database.
	// *   You can also call the [ListDatabases](~~141873~~) operation to obtain the name of a physical database and the [ListLogicDatabases](~~141874~~) operation to obtain the name of a logical database.
	SchemaName *string `json:"SchemaName,omitempty" xml:"SchemaName,omitempty"`
	// The name of the table. You can call the [ListSensitiveColumns](~~188103~~) operation to obtain the name of the table.
	//
	// > You can also call the [ListTables](~~141878~~) operation to obtain the name of the table.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	// The ID of the tenant.
	//
	// > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ChangeColumnSecLevelRequest) String() string {
	return tea.Prettify(s)
}

func (s ChangeColumnSecLevelRequest) GoString() string {
	return s.String()
}

func (s *ChangeColumnSecLevelRequest) SetColumnName(v string) *ChangeColumnSecLevelRequest {
	s.ColumnName = &v
	return s
}

func (s *ChangeColumnSecLevelRequest) SetDbId(v int64) *ChangeColumnSecLevelRequest {
	s.DbId = &v
	return s
}

func (s *ChangeColumnSecLevelRequest) SetIsLogic(v bool) *ChangeColumnSecLevelRequest {
	s.IsLogic = &v
	return s
}

func (s *ChangeColumnSecLevelRequest) SetNewLevel(v string) *ChangeColumnSecLevelRequest {
	s.NewLevel = &v
	return s
}

func (s *ChangeColumnSecLevelRequest) SetSchemaName(v string) *ChangeColumnSecLevelRequest {
	s.SchemaName = &v
	return s
}

func (s *ChangeColumnSecLevelRequest) SetTableName(v string) *ChangeColumnSecLevelRequest {
	s.TableName = &v
	return s
}

func (s *ChangeColumnSecLevelRequest) SetTid(v int64) *ChangeColumnSecLevelRequest {
	s.Tid = &v
	return s
}

type ChangeColumnSecLevelResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ChangeColumnSecLevelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ChangeColumnSecLevelResponseBody) GoString() string {
	return s.String()
}

func (s *ChangeColumnSecLevelResponseBody) SetErrorCode(v string) *ChangeColumnSecLevelResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ChangeColumnSecLevelResponseBody) SetErrorMessage(v string) *ChangeColumnSecLevelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ChangeColumnSecLevelResponseBody) SetRequestId(v string) *ChangeColumnSecLevelResponseBody {
	s.RequestId = &v
	return s
}

func (s *ChangeColumnSecLevelResponseBody) SetSuccess(v bool) *ChangeColumnSecLevelResponseBody {
	s.Success = &v
	return s
}

type ChangeColumnSecLevelResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ChangeColumnSecLevelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ChangeColumnSecLevelResponse) String() string {
	return tea.Prettify(s)
}

func (s ChangeColumnSecLevelResponse) GoString() string {
	return s.String()
}

func (s *ChangeColumnSecLevelResponse) SetHeaders(v map[string]*string) *ChangeColumnSecLevelResponse {
	s.Headers = v
	return s
}

func (s *ChangeColumnSecLevelResponse) SetStatusCode(v int32) *ChangeColumnSecLevelResponse {
	s.StatusCode = &v
	return s
}

func (s *ChangeColumnSecLevelResponse) SetBody(v *ChangeColumnSecLevelResponseBody) *ChangeColumnSecLevelResponse {
	s.Body = v
	return s
}

type ChangeColumnSecurityLevelRequest struct {
	ColumnName          *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	DbId                *int64  `json:"DbId,omitempty" xml:"DbId,omitempty"`
	IsLogic             *bool   `json:"IsLogic,omitempty" xml:"IsLogic,omitempty"`
	NewSensitivityLevel *string `json:"NewSensitivityLevel,omitempty" xml:"NewSensitivityLevel,omitempty"`
	SchemaName          *string `json:"SchemaName,omitempty" xml:"SchemaName,omitempty"`
	TableName           *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	Tid                 *int64  `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ChangeColumnSecurityLevelRequest) String() string {
	return tea.Prettify(s)
}

func (s ChangeColumnSecurityLevelRequest) GoString() string {
	return s.String()
}

func (s *ChangeColumnSecurityLevelRequest) SetColumnName(v string) *ChangeColumnSecurityLevelRequest {
	s.ColumnName = &v
	return s
}

func (s *ChangeColumnSecurityLevelRequest) SetDbId(v int64) *ChangeColumnSecurityLevelRequest {
	s.DbId = &v
	return s
}

func (s *ChangeColumnSecurityLevelRequest) SetIsLogic(v bool) *ChangeColumnSecurityLevelRequest {
	s.IsLogic = &v
	return s
}

func (s *ChangeColumnSecurityLevelRequest) SetNewSensitivityLevel(v string) *ChangeColumnSecurityLevelRequest {
	s.NewSensitivityLevel = &v
	return s
}

func (s *ChangeColumnSecurityLevelRequest) SetSchemaName(v string) *ChangeColumnSecurityLevelRequest {
	s.SchemaName = &v
	return s
}

func (s *ChangeColumnSecurityLevelRequest) SetTableName(v string) *ChangeColumnSecurityLevelRequest {
	s.TableName = &v
	return s
}

func (s *ChangeColumnSecurityLevelRequest) SetTid(v int64) *ChangeColumnSecurityLevelRequest {
	s.Tid = &v
	return s
}

type ChangeColumnSecurityLevelResponseBody struct {
	ErrorCode    *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ChangeColumnSecurityLevelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ChangeColumnSecurityLevelResponseBody) GoString() string {
	return s.String()
}

func (s *ChangeColumnSecurityLevelResponseBody) SetErrorCode(v string) *ChangeColumnSecurityLevelResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ChangeColumnSecurityLevelResponseBody) SetErrorMessage(v string) *ChangeColumnSecurityLevelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ChangeColumnSecurityLevelResponseBody) SetRequestId(v string) *ChangeColumnSecurityLevelResponseBody {
	s.RequestId = &v
	return s
}

func (s *ChangeColumnSecurityLevelResponseBody) SetSuccess(v bool) *ChangeColumnSecurityLevelResponseBody {
	s.Success = &v
	return s
}

type ChangeColumnSecurityLevelResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ChangeColumnSecurityLevelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ChangeColumnSecurityLevelResponse) String() string {
	return tea.Prettify(s)
}

func (s ChangeColumnSecurityLevelResponse) GoString() string {
	return s.String()
}

func (s *ChangeColumnSecurityLevelResponse) SetHeaders(v map[string]*string) *ChangeColumnSecurityLevelResponse {
	s.Headers = v
	return s
}

func (s *ChangeColumnSecurityLevelResponse) SetStatusCode(v int32) *ChangeColumnSecurityLevelResponse {
	s.StatusCode = &v
	return s
}

func (s *ChangeColumnSecurityLevelResponse) SetBody(v *ChangeColumnSecurityLevelResponseBody) *ChangeColumnSecurityLevelResponse {
	s.Body = v
	return s
}

type ChangeLhDagOwnerRequest struct {
	// The ID of the task flow. You can call the [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the user to be specified as the new owner of the task flow. You can call the [ListUsers](~~141938~~) or [GetUser](~~147098~~) operation to obtain the user ID.
	OwnerUserId *int64 `json:"OwnerUserId,omitempty" xml:"OwnerUserId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ChangeLhDagOwnerRequest) String() string {
	return tea.Prettify(s)
}

func (s ChangeLhDagOwnerRequest) GoString() string {
	return s.String()
}

func (s *ChangeLhDagOwnerRequest) SetDagId(v int64) *ChangeLhDagOwnerRequest {
	s.DagId = &v
	return s
}

func (s *ChangeLhDagOwnerRequest) SetOwnerUserId(v int64) *ChangeLhDagOwnerRequest {
	s.OwnerUserId = &v
	return s
}

func (s *ChangeLhDagOwnerRequest) SetTid(v int64) *ChangeLhDagOwnerRequest {
	s.Tid = &v
	return s
}

type ChangeLhDagOwnerResponseBody struct {
	// The error code returned if the request fails.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**: The request is successful.
	// *   **false**: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ChangeLhDagOwnerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ChangeLhDagOwnerResponseBody) GoString() string {
	return s.String()
}

func (s *ChangeLhDagOwnerResponseBody) SetErrorCode(v string) *ChangeLhDagOwnerResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ChangeLhDagOwnerResponseBody) SetErrorMessage(v string) *ChangeLhDagOwnerResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ChangeLhDagOwnerResponseBody) SetRequestId(v string) *ChangeLhDagOwnerResponseBody {
	s.RequestId = &v
	return s
}

func (s *ChangeLhDagOwnerResponseBody) SetSuccess(v bool) *ChangeLhDagOwnerResponseBody {
	s.Success = &v
	return s
}

type ChangeLhDagOwnerResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ChangeLhDagOwnerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ChangeLhDagOwnerResponse) String() string {
	return tea.Prettify(s)
}

func (s ChangeLhDagOwnerResponse) GoString() string {
	return s.String()
}

func (s *ChangeLhDagOwnerResponse) SetHeaders(v map[string]*string) *ChangeLhDagOwnerResponse {
	s.Headers = v
	return s
}

func (s *ChangeLhDagOwnerResponse) SetStatusCode(v int32) *ChangeLhDagOwnerResponse {
	s.StatusCode = &v
	return s
}

func (s *ChangeLhDagOwnerResponse) SetBody(v *ChangeLhDagOwnerResponseBody) *ChangeLhDagOwnerResponse {
	s.Body = v
	return s
}

type CloseOrderRequest struct {
	// The reason why the ticket is closed.
	CloseReason *string `json:"CloseReason,omitempty" xml:"CloseReason,omitempty"`
	// The ID of the ticket.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant.
	//
	// > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CloseOrderRequest) String() string {
	return tea.Prettify(s)
}

func (s CloseOrderRequest) GoString() string {
	return s.String()
}

func (s *CloseOrderRequest) SetCloseReason(v string) *CloseOrderRequest {
	s.CloseReason = &v
	return s
}

func (s *CloseOrderRequest) SetOrderId(v int64) *CloseOrderRequest {
	s.OrderId = &v
	return s
}

func (s *CloseOrderRequest) SetTid(v int64) *CloseOrderRequest {
	s.Tid = &v
	return s
}

type CloseOrderResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CloseOrderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CloseOrderResponseBody) GoString() string {
	return s.String()
}

func (s *CloseOrderResponseBody) SetErrorCode(v string) *CloseOrderResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CloseOrderResponseBody) SetErrorMessage(v string) *CloseOrderResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CloseOrderResponseBody) SetRequestId(v string) *CloseOrderResponseBody {
	s.RequestId = &v
	return s
}

func (s *CloseOrderResponseBody) SetSuccess(v bool) *CloseOrderResponseBody {
	s.Success = &v
	return s
}

type CloseOrderResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CloseOrderResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CloseOrderResponse) String() string {
	return tea.Prettify(s)
}

func (s CloseOrderResponse) GoString() string {
	return s.String()
}

func (s *CloseOrderResponse) SetHeaders(v map[string]*string) *CloseOrderResponse {
	s.Headers = v
	return s
}

func (s *CloseOrderResponse) SetStatusCode(v int32) *CloseOrderResponse {
	s.StatusCode = &v
	return s
}

func (s *CloseOrderResponse) SetBody(v *CloseOrderResponseBody) *CloseOrderResponse {
	s.Body = v
	return s
}

type CreateAuthorityTemplateRequest struct {
	// The description of the permission template.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the permission template.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateAuthorityTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAuthorityTemplateRequest) GoString() string {
	return s.String()
}

func (s *CreateAuthorityTemplateRequest) SetDescription(v string) *CreateAuthorityTemplateRequest {
	s.Description = &v
	return s
}

func (s *CreateAuthorityTemplateRequest) SetName(v string) *CreateAuthorityTemplateRequest {
	s.Name = &v
	return s
}

func (s *CreateAuthorityTemplateRequest) SetTid(v int64) *CreateAuthorityTemplateRequest {
	s.Tid = &v
	return s
}

type CreateAuthorityTemplateResponseBody struct {
	// The details of the permission template.
	AuthorityTemplateView *CreateAuthorityTemplateResponseBodyAuthorityTemplateView `json:"AuthorityTemplateView,omitempty" xml:"AuthorityTemplateView,omitempty" type:"Struct"`
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool  `json:"Success,omitempty" xml:"Success,omitempty"`
	Tid     *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateAuthorityTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateAuthorityTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *CreateAuthorityTemplateResponseBody) SetAuthorityTemplateView(v *CreateAuthorityTemplateResponseBodyAuthorityTemplateView) *CreateAuthorityTemplateResponseBody {
	s.AuthorityTemplateView = v
	return s
}

func (s *CreateAuthorityTemplateResponseBody) SetErrorCode(v string) *CreateAuthorityTemplateResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateAuthorityTemplateResponseBody) SetErrorMessage(v string) *CreateAuthorityTemplateResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateAuthorityTemplateResponseBody) SetRequestId(v string) *CreateAuthorityTemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateAuthorityTemplateResponseBody) SetSuccess(v bool) *CreateAuthorityTemplateResponseBody {
	s.Success = &v
	return s
}

func (s *CreateAuthorityTemplateResponseBody) SetTid(v int64) *CreateAuthorityTemplateResponseBody {
	s.Tid = &v
	return s
}

type CreateAuthorityTemplateResponseBodyAuthorityTemplateView struct {
	// The time when the permission template was created. The time is in the yyyy-MM-DD HH:mm:ss format.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the user who created the permission template.
	CreatorId *int64 `json:"CreatorId,omitempty" xml:"CreatorId,omitempty"`
	// The description of the permission template.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the permission template.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the permission template.
	TemplateId *int64 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
}

func (s CreateAuthorityTemplateResponseBodyAuthorityTemplateView) String() string {
	return tea.Prettify(s)
}

func (s CreateAuthorityTemplateResponseBodyAuthorityTemplateView) GoString() string {
	return s.String()
}

func (s *CreateAuthorityTemplateResponseBodyAuthorityTemplateView) SetCreateTime(v string) *CreateAuthorityTemplateResponseBodyAuthorityTemplateView {
	s.CreateTime = &v
	return s
}

func (s *CreateAuthorityTemplateResponseBodyAuthorityTemplateView) SetCreatorId(v int64) *CreateAuthorityTemplateResponseBodyAuthorityTemplateView {
	s.CreatorId = &v
	return s
}

func (s *CreateAuthorityTemplateResponseBodyAuthorityTemplateView) SetDescription(v string) *CreateAuthorityTemplateResponseBodyAuthorityTemplateView {
	s.Description = &v
	return s
}

func (s *CreateAuthorityTemplateResponseBodyAuthorityTemplateView) SetName(v string) *CreateAuthorityTemplateResponseBodyAuthorityTemplateView {
	s.Name = &v
	return s
}

func (s *CreateAuthorityTemplateResponseBodyAuthorityTemplateView) SetTemplateId(v int64) *CreateAuthorityTemplateResponseBodyAuthorityTemplateView {
	s.TemplateId = &v
	return s
}

type CreateAuthorityTemplateResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateAuthorityTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateAuthorityTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateAuthorityTemplateResponse) GoString() string {
	return s.String()
}

func (s *CreateAuthorityTemplateResponse) SetHeaders(v map[string]*string) *CreateAuthorityTemplateResponse {
	s.Headers = v
	return s
}

func (s *CreateAuthorityTemplateResponse) SetStatusCode(v int32) *CreateAuthorityTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateAuthorityTemplateResponse) SetBody(v *CreateAuthorityTemplateResponseBody) *CreateAuthorityTemplateResponse {
	s.Body = v
	return s
}

type CreateDataArchiveOrderRequest struct {
	// The description of the task.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The parameters for archiving data.
	Param *CreateDataArchiveOrderRequestParam `json:"Param,omitempty" xml:"Param,omitempty" type:"Struct"`
	// The ID of the parent ticket. A parent ticket is generated only when a sub ticket is created.
	ParentId *int64 `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
	// The plugin type. Default value: DATA_ARCHIVE.
	PluginType *string `json:"PluginType,omitempty" xml:"PluginType,omitempty"`
	// The list of the related users.
	RelatedUserList []*string `json:"RelatedUserList,omitempty" xml:"RelatedUserList,omitempty" type:"Repeated"`
	// The tenant ID. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateDataArchiveOrderRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDataArchiveOrderRequest) GoString() string {
	return s.String()
}

func (s *CreateDataArchiveOrderRequest) SetComment(v string) *CreateDataArchiveOrderRequest {
	s.Comment = &v
	return s
}

func (s *CreateDataArchiveOrderRequest) SetParam(v *CreateDataArchiveOrderRequestParam) *CreateDataArchiveOrderRequest {
	s.Param = v
	return s
}

func (s *CreateDataArchiveOrderRequest) SetParentId(v int64) *CreateDataArchiveOrderRequest {
	s.ParentId = &v
	return s
}

func (s *CreateDataArchiveOrderRequest) SetPluginType(v string) *CreateDataArchiveOrderRequest {
	s.PluginType = &v
	return s
}

func (s *CreateDataArchiveOrderRequest) SetRelatedUserList(v []*string) *CreateDataArchiveOrderRequest {
	s.RelatedUserList = v
	return s
}

func (s *CreateDataArchiveOrderRequest) SetTid(v int64) *CreateDataArchiveOrderRequest {
	s.Tid = &v
	return s
}

type CreateDataArchiveOrderRequestParam struct {
	// The database for archiving data. Valid values:
	//
	// *   inner_oss: Built-in Object Storage Service (OSS) of Database Backup (DBS).
	// *   oss_userself: OSS of user.
	// *   mysql: ApsaraDB RDS for MySQL.
	// *   polardb: PolarDB for MySQL.
	// *   lindorm: Lindorm.
	ArchiveMethod *string `json:"ArchiveMethod,omitempty" xml:"ArchiveMethod,omitempty"`
	// 填写Crontab表达式，以便定期执行任务，更多信息，请参见[Crontab表达式](~~206581~~)。
	// 当运行方式为周期归档时需要填写该参数。
	CronStr *string `json:"CronStr,omitempty" xml:"CronStr,omitempty"`
	// Specifies whether the database is a logical database.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The post behaviors.
	OrderAfter []*string `json:"OrderAfter,omitempty" xml:"OrderAfter,omitempty" type:"Repeated"`
	// The running mode. Only now is supported, which indicates that data archiving is immediately executed.
	RunMethod *string `json:"RunMethod,omitempty" xml:"RunMethod,omitempty"`
	// 源库目录（catalog）。
	// - **def**：对于两层逻辑结构的数据库，如MySQL，PolarDB MySQL，AnalyticDB MySQL，固定为def。
	// - **空字符串**： 对于lindorm与MongoDB，填入空字符串。
	// - **catalog名**：对于三层逻辑结构的数据库，如PostgreSQL，填入catalog名。
	SourceCatalogName *string `json:"SourceCatalogName,omitempty" xml:"SourceCatalogName,omitempty"`
	// 源实例名称。
	SourceInstanceName *string `json:"SourceInstanceName,omitempty" xml:"SourceInstanceName,omitempty"`
	// 源库Schema，源库与目标库同名。
	// 如MySQL为库名，PostgreSQL为Schema名。
	SourceSchemaName *string `json:"SourceSchemaName,omitempty" xml:"SourceSchemaName,omitempty"`
	// The collection of tables to be archived.
	TableIncludes []*CreateDataArchiveOrderRequestParamTableIncludes `json:"TableIncludes,omitempty" xml:"TableIncludes,omitempty" type:"Repeated"`
	// The table names mapped in the destination database.
	TableMapping []*string `json:"TableMapping,omitempty" xml:"TableMapping,omitempty" type:"Repeated"`
	// 目标库Host，若目标实例同时开放了内网与公网，优先写入内网Host。
	//
	// - 若归档目标为OSS，则为Bucket名。
	// - 若归档目标为专属存储，则为inner_oss。
	TargetInstanceHost *string `json:"TargetInstanceHost,omitempty" xml:"TargetInstanceHost,omitempty"`
	// The configuration of archiving variables.
	Variables []*CreateDataArchiveOrderRequestParamVariables `json:"Variables,omitempty" xml:"Variables,omitempty" type:"Repeated"`
}

func (s CreateDataArchiveOrderRequestParam) String() string {
	return tea.Prettify(s)
}

func (s CreateDataArchiveOrderRequestParam) GoString() string {
	return s.String()
}

func (s *CreateDataArchiveOrderRequestParam) SetArchiveMethod(v string) *CreateDataArchiveOrderRequestParam {
	s.ArchiveMethod = &v
	return s
}

func (s *CreateDataArchiveOrderRequestParam) SetCronStr(v string) *CreateDataArchiveOrderRequestParam {
	s.CronStr = &v
	return s
}

func (s *CreateDataArchiveOrderRequestParam) SetLogic(v bool) *CreateDataArchiveOrderRequestParam {
	s.Logic = &v
	return s
}

func (s *CreateDataArchiveOrderRequestParam) SetOrderAfter(v []*string) *CreateDataArchiveOrderRequestParam {
	s.OrderAfter = v
	return s
}

func (s *CreateDataArchiveOrderRequestParam) SetRunMethod(v string) *CreateDataArchiveOrderRequestParam {
	s.RunMethod = &v
	return s
}

func (s *CreateDataArchiveOrderRequestParam) SetSourceCatalogName(v string) *CreateDataArchiveOrderRequestParam {
	s.SourceCatalogName = &v
	return s
}

func (s *CreateDataArchiveOrderRequestParam) SetSourceInstanceName(v string) *CreateDataArchiveOrderRequestParam {
	s.SourceInstanceName = &v
	return s
}

func (s *CreateDataArchiveOrderRequestParam) SetSourceSchemaName(v string) *CreateDataArchiveOrderRequestParam {
	s.SourceSchemaName = &v
	return s
}

func (s *CreateDataArchiveOrderRequestParam) SetTableIncludes(v []*CreateDataArchiveOrderRequestParamTableIncludes) *CreateDataArchiveOrderRequestParam {
	s.TableIncludes = v
	return s
}

func (s *CreateDataArchiveOrderRequestParam) SetTableMapping(v []*string) *CreateDataArchiveOrderRequestParam {
	s.TableMapping = v
	return s
}

func (s *CreateDataArchiveOrderRequestParam) SetTargetInstanceHost(v string) *CreateDataArchiveOrderRequestParam {
	s.TargetInstanceHost = &v
	return s
}

func (s *CreateDataArchiveOrderRequestParam) SetVariables(v []*CreateDataArchiveOrderRequestParamVariables) *CreateDataArchiveOrderRequestParam {
	s.Variables = v
	return s
}

type CreateDataArchiveOrderRequestParamTableIncludes struct {
	// The name of the table.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	// The filter condition specified by the WHERE clause of the archiving configuration.
	TableWhere *string `json:"TableWhere,omitempty" xml:"TableWhere,omitempty"`
}

func (s CreateDataArchiveOrderRequestParamTableIncludes) String() string {
	return tea.Prettify(s)
}

func (s CreateDataArchiveOrderRequestParamTableIncludes) GoString() string {
	return s.String()
}

func (s *CreateDataArchiveOrderRequestParamTableIncludes) SetTableName(v string) *CreateDataArchiveOrderRequestParamTableIncludes {
	s.TableName = &v
	return s
}

func (s *CreateDataArchiveOrderRequestParamTableIncludes) SetTableWhere(v string) *CreateDataArchiveOrderRequestParamTableIncludes {
	s.TableWhere = &v
	return s
}

type CreateDataArchiveOrderRequestParamVariables struct {
	Name    *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Pattern *string `json:"Pattern,omitempty" xml:"Pattern,omitempty"`
}

func (s CreateDataArchiveOrderRequestParamVariables) String() string {
	return tea.Prettify(s)
}

func (s CreateDataArchiveOrderRequestParamVariables) GoString() string {
	return s.String()
}

func (s *CreateDataArchiveOrderRequestParamVariables) SetName(v string) *CreateDataArchiveOrderRequestParamVariables {
	s.Name = &v
	return s
}

func (s *CreateDataArchiveOrderRequestParamVariables) SetPattern(v string) *CreateDataArchiveOrderRequestParamVariables {
	s.Pattern = &v
	return s
}

type CreateDataArchiveOrderShrinkRequest struct {
	// The description of the task.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The parameters for archiving data.
	ParamShrink *string `json:"Param,omitempty" xml:"Param,omitempty"`
	// The ID of the parent ticket. A parent ticket is generated only when a sub ticket is created.
	ParentId *int64 `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
	// The plugin type. Default value: DATA_ARCHIVE.
	PluginType *string `json:"PluginType,omitempty" xml:"PluginType,omitempty"`
	// The list of the related users.
	RelatedUserListShrink *string `json:"RelatedUserList,omitempty" xml:"RelatedUserList,omitempty"`
	// The tenant ID. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateDataArchiveOrderShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDataArchiveOrderShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateDataArchiveOrderShrinkRequest) SetComment(v string) *CreateDataArchiveOrderShrinkRequest {
	s.Comment = &v
	return s
}

func (s *CreateDataArchiveOrderShrinkRequest) SetParamShrink(v string) *CreateDataArchiveOrderShrinkRequest {
	s.ParamShrink = &v
	return s
}

func (s *CreateDataArchiveOrderShrinkRequest) SetParentId(v int64) *CreateDataArchiveOrderShrinkRequest {
	s.ParentId = &v
	return s
}

func (s *CreateDataArchiveOrderShrinkRequest) SetPluginType(v string) *CreateDataArchiveOrderShrinkRequest {
	s.PluginType = &v
	return s
}

func (s *CreateDataArchiveOrderShrinkRequest) SetRelatedUserListShrink(v string) *CreateDataArchiveOrderShrinkRequest {
	s.RelatedUserListShrink = &v
	return s
}

func (s *CreateDataArchiveOrderShrinkRequest) SetTid(v int64) *CreateDataArchiveOrderShrinkRequest {
	s.Tid = &v
	return s
}

type CreateDataArchiveOrderResponseBody struct {
	// The data archiving ticket IDs.
	CreateOrderResult []*int64 `json:"CreateOrderResult,omitempty" xml:"CreateOrderResult,omitempty" type:"Repeated"`
	// Error code
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request, which is used to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   true
	// *   false
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateDataArchiveOrderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDataArchiveOrderResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDataArchiveOrderResponseBody) SetCreateOrderResult(v []*int64) *CreateDataArchiveOrderResponseBody {
	s.CreateOrderResult = v
	return s
}

func (s *CreateDataArchiveOrderResponseBody) SetErrorCode(v string) *CreateDataArchiveOrderResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateDataArchiveOrderResponseBody) SetErrorMessage(v string) *CreateDataArchiveOrderResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateDataArchiveOrderResponseBody) SetRequestId(v string) *CreateDataArchiveOrderResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDataArchiveOrderResponseBody) SetSuccess(v bool) *CreateDataArchiveOrderResponseBody {
	s.Success = &v
	return s
}

type CreateDataArchiveOrderResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDataArchiveOrderResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDataArchiveOrderResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDataArchiveOrderResponse) GoString() string {
	return s.String()
}

func (s *CreateDataArchiveOrderResponse) SetHeaders(v map[string]*string) *CreateDataArchiveOrderResponse {
	s.Headers = v
	return s
}

func (s *CreateDataArchiveOrderResponse) SetStatusCode(v int32) *CreateDataArchiveOrderResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDataArchiveOrderResponse) SetBody(v *CreateDataArchiveOrderResponseBody) *CreateDataArchiveOrderResponse {
	s.Body = v
	return s
}

type CreateDataCorrectOrderRequest struct {
	// The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key from the value of the AttachmentKey parameter.
	AttachmentKey *string `json:"AttachmentKey,omitempty" xml:"AttachmentKey,omitempty"`
	// The purpose or objective of the data change. This parameter is used to help reduce unnecessary communication.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The parameters of the ticket.
	Param *CreateDataCorrectOrderRequestParam `json:"Param,omitempty" xml:"Param,omitempty" type:"Struct"`
	// The stakeholders of the data change. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
	RelatedUserList []*int64 `json:"RelatedUserList,omitempty" xml:"RelatedUserList,omitempty" type:"Repeated"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateDataCorrectOrderRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDataCorrectOrderRequest) GoString() string {
	return s.String()
}

func (s *CreateDataCorrectOrderRequest) SetAttachmentKey(v string) *CreateDataCorrectOrderRequest {
	s.AttachmentKey = &v
	return s
}

func (s *CreateDataCorrectOrderRequest) SetComment(v string) *CreateDataCorrectOrderRequest {
	s.Comment = &v
	return s
}

func (s *CreateDataCorrectOrderRequest) SetParam(v *CreateDataCorrectOrderRequestParam) *CreateDataCorrectOrderRequest {
	s.Param = v
	return s
}

func (s *CreateDataCorrectOrderRequest) SetRelatedUserList(v []*int64) *CreateDataCorrectOrderRequest {
	s.RelatedUserList = v
	return s
}

func (s *CreateDataCorrectOrderRequest) SetTid(v int64) *CreateDataCorrectOrderRequest {
	s.Tid = &v
	return s
}

type CreateDataCorrectOrderRequestParam struct {
	// The key of the attachment that contains the SQL statements used to change data. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key from the value of the AttachmentKey parameter.
	//
	// >  This parameter is required if you set the **SqlType** parameter to **ATTACHMENT**.
	AttachmentName *string `json:"AttachmentName,omitempty" xml:"AttachmentName,omitempty"`
	// The reason for the data change.
	Classify *string `json:"Classify,omitempty" xml:"Classify,omitempty"`
	// The databases in which you want to change data.
	DbItemList []*CreateDataCorrectOrderRequestParamDbItemList `json:"DbItemList,omitempty" xml:"DbItemList,omitempty" type:"Repeated"`
	// The estimated number of data rows to be affected by the data change.
	EstimateAffectRows *int64 `json:"EstimateAffectRows,omitempty" xml:"EstimateAffectRows,omitempty"`
	// The execution mode of the ticket after the ticket is approved. Valid values:
	//
	// *   **COMMITOR**: The data change is performed by the user who submits the ticket.
	// *   **AUTO**: The data change is automatically performed after the ticket is approved.
	// *   **LAST_AUDITOR**: The data change is performed by the last approver of the ticket.
	ExecMode *string `json:"ExecMode,omitempty" xml:"ExecMode,omitempty"`
	// The SQL statements that you want to execute to change data.
	//
	// >  This parameter is required if you set the **SqlType** parameter to **TEXT**.
	ExecSQL *string `json:"ExecSQL,omitempty" xml:"ExecSQL,omitempty"`
	// The key of the attachment that contains the SQL statements used to roll back the data change. You can call the [GetUserUploadFileJob](~~206069~~) operation to the attachment key from the value of the AttachmentKey parameter.
	//
	// >  This parameter is required if you set the **RollbackSqlType** parameter to **ATTACHMENT**.
	RollbackAttachmentName *string `json:"RollbackAttachmentName,omitempty" xml:"RollbackAttachmentName,omitempty"`
	// The SQL statements used to roll back the data change.
	//
	// > This parameter is required if you set the **RollbackSqlType** parameter to **TEXT**.
	RollbackSQL *string `json:"RollbackSQL,omitempty" xml:"RollbackSQL,omitempty"`
	// The format of the SQL statements used to roll back the data change. Valid values:
	//
	// *   **TEXT**: text
	// *   **ATTACHMENT**: attachment
	RollbackSqlType *string `json:"RollbackSqlType,omitempty" xml:"RollbackSqlType,omitempty"`
	// The format of the SQL statements used to change data. Valid values:
	//
	// *   **TEXT**: text
	// *   **ATTACHMENT**: attachment
	SqlType *string `json:"SqlType,omitempty" xml:"SqlType,omitempty"`
}

func (s CreateDataCorrectOrderRequestParam) String() string {
	return tea.Prettify(s)
}

func (s CreateDataCorrectOrderRequestParam) GoString() string {
	return s.String()
}

func (s *CreateDataCorrectOrderRequestParam) SetAttachmentName(v string) *CreateDataCorrectOrderRequestParam {
	s.AttachmentName = &v
	return s
}

func (s *CreateDataCorrectOrderRequestParam) SetClassify(v string) *CreateDataCorrectOrderRequestParam {
	s.Classify = &v
	return s
}

func (s *CreateDataCorrectOrderRequestParam) SetDbItemList(v []*CreateDataCorrectOrderRequestParamDbItemList) *CreateDataCorrectOrderRequestParam {
	s.DbItemList = v
	return s
}

func (s *CreateDataCorrectOrderRequestParam) SetEstimateAffectRows(v int64) *CreateDataCorrectOrderRequestParam {
	s.EstimateAffectRows = &v
	return s
}

func (s *CreateDataCorrectOrderRequestParam) SetExecMode(v string) *CreateDataCorrectOrderRequestParam {
	s.ExecMode = &v
	return s
}

func (s *CreateDataCorrectOrderRequestParam) SetExecSQL(v string) *CreateDataCorrectOrderRequestParam {
	s.ExecSQL = &v
	return s
}

func (s *CreateDataCorrectOrderRequestParam) SetRollbackAttachmentName(v string) *CreateDataCorrectOrderRequestParam {
	s.RollbackAttachmentName = &v
	return s
}

func (s *CreateDataCorrectOrderRequestParam) SetRollbackSQL(v string) *CreateDataCorrectOrderRequestParam {
	s.RollbackSQL = &v
	return s
}

func (s *CreateDataCorrectOrderRequestParam) SetRollbackSqlType(v string) *CreateDataCorrectOrderRequestParam {
	s.RollbackSqlType = &v
	return s
}

func (s *CreateDataCorrectOrderRequestParam) SetSqlType(v string) *CreateDataCorrectOrderRequestParam {
	s.SqlType = &v
	return s
}

type CreateDataCorrectOrderRequestParamDbItemList struct {
	// The ID of the database. The database can be a physical database or a logical database.
	//
	// *   To obtain the ID of a physical database, call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation.
	// *   To obtain the ID of a logical database, call the [ListLogicDatabases](~~141874~~) or [SearchDatabase](~~141876~~) operation.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// Specifies whether the database is a logical database. Valid values:
	//
	// *   **true**: The database is a logical database.
	// *   **false**: The database is a physical database.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
}

func (s CreateDataCorrectOrderRequestParamDbItemList) String() string {
	return tea.Prettify(s)
}

func (s CreateDataCorrectOrderRequestParamDbItemList) GoString() string {
	return s.String()
}

func (s *CreateDataCorrectOrderRequestParamDbItemList) SetDbId(v int64) *CreateDataCorrectOrderRequestParamDbItemList {
	s.DbId = &v
	return s
}

func (s *CreateDataCorrectOrderRequestParamDbItemList) SetLogic(v bool) *CreateDataCorrectOrderRequestParamDbItemList {
	s.Logic = &v
	return s
}

type CreateDataCorrectOrderShrinkRequest struct {
	// The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key from the value of the AttachmentKey parameter.
	AttachmentKey *string `json:"AttachmentKey,omitempty" xml:"AttachmentKey,omitempty"`
	// The purpose or objective of the data change. This parameter is used to help reduce unnecessary communication.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The parameters of the ticket.
	ParamShrink *string `json:"Param,omitempty" xml:"Param,omitempty"`
	// The stakeholders of the data change. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
	RelatedUserListShrink *string `json:"RelatedUserList,omitempty" xml:"RelatedUserList,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateDataCorrectOrderShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDataCorrectOrderShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateDataCorrectOrderShrinkRequest) SetAttachmentKey(v string) *CreateDataCorrectOrderShrinkRequest {
	s.AttachmentKey = &v
	return s
}

func (s *CreateDataCorrectOrderShrinkRequest) SetComment(v string) *CreateDataCorrectOrderShrinkRequest {
	s.Comment = &v
	return s
}

func (s *CreateDataCorrectOrderShrinkRequest) SetParamShrink(v string) *CreateDataCorrectOrderShrinkRequest {
	s.ParamShrink = &v
	return s
}

func (s *CreateDataCorrectOrderShrinkRequest) SetRelatedUserListShrink(v string) *CreateDataCorrectOrderShrinkRequest {
	s.RelatedUserListShrink = &v
	return s
}

func (s *CreateDataCorrectOrderShrinkRequest) SetTid(v int64) *CreateDataCorrectOrderShrinkRequest {
	s.Tid = &v
	return s
}

type CreateDataCorrectOrderResponseBody struct {
	// The IDs of the tickets.
	CreateOrderResult []*int64 `json:"CreateOrderResult,omitempty" xml:"CreateOrderResult,omitempty" type:"Repeated"`
	// The error code returned if the request fails.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**: The request is successful.
	// *   **false**: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateDataCorrectOrderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDataCorrectOrderResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDataCorrectOrderResponseBody) SetCreateOrderResult(v []*int64) *CreateDataCorrectOrderResponseBody {
	s.CreateOrderResult = v
	return s
}

func (s *CreateDataCorrectOrderResponseBody) SetErrorCode(v string) *CreateDataCorrectOrderResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateDataCorrectOrderResponseBody) SetErrorMessage(v string) *CreateDataCorrectOrderResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateDataCorrectOrderResponseBody) SetRequestId(v string) *CreateDataCorrectOrderResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDataCorrectOrderResponseBody) SetSuccess(v bool) *CreateDataCorrectOrderResponseBody {
	s.Success = &v
	return s
}

type CreateDataCorrectOrderResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDataCorrectOrderResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDataCorrectOrderResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDataCorrectOrderResponse) GoString() string {
	return s.String()
}

func (s *CreateDataCorrectOrderResponse) SetHeaders(v map[string]*string) *CreateDataCorrectOrderResponse {
	s.Headers = v
	return s
}

func (s *CreateDataCorrectOrderResponse) SetStatusCode(v int32) *CreateDataCorrectOrderResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDataCorrectOrderResponse) SetBody(v *CreateDataCorrectOrderResponseBody) *CreateDataCorrectOrderResponse {
	s.Body = v
	return s
}

type CreateDataCronClearOrderRequest struct {
	// The key of the attachment for the ticket. The attachment provides more instructions for this operation.
	//
	// You can call the [GetUserUploadFileJob](~~206069~~) operation to query the key of the attachment.
	AttachmentKey *string `json:"AttachmentKey,omitempty" xml:"AttachmentKey,omitempty"`
	// The purpose or objective of the data change. This reduces unnecessary communication.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The parameters of the ticket.
	Param *CreateDataCronClearOrderRequestParam `json:"Param,omitempty" xml:"Param,omitempty" type:"Struct"`
	// The stakeholders of this operation. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than Data Management (DMS) administrators and database administrators (DBAs) are not allowed to view the ticket details.
	RelatedUserList []*int64 `json:"RelatedUserList,omitempty" xml:"RelatedUserList,omitempty" type:"Repeated"`
	// The ID of the tenant.
	//
	// >  The ID of the tenant is displayed when you move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the [View information about the current tenant](~~181330~~) section of the Manage DMS tenants topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateDataCronClearOrderRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDataCronClearOrderRequest) GoString() string {
	return s.String()
}

func (s *CreateDataCronClearOrderRequest) SetAttachmentKey(v string) *CreateDataCronClearOrderRequest {
	s.AttachmentKey = &v
	return s
}

func (s *CreateDataCronClearOrderRequest) SetComment(v string) *CreateDataCronClearOrderRequest {
	s.Comment = &v
	return s
}

func (s *CreateDataCronClearOrderRequest) SetParam(v *CreateDataCronClearOrderRequestParam) *CreateDataCronClearOrderRequest {
	s.Param = v
	return s
}

func (s *CreateDataCronClearOrderRequest) SetRelatedUserList(v []*int64) *CreateDataCronClearOrderRequest {
	s.RelatedUserList = v
	return s
}

func (s *CreateDataCronClearOrderRequest) SetTid(v int64) *CreateDataCronClearOrderRequest {
	s.Tid = &v
	return s
}

type CreateDataCronClearOrderRequestParam struct {
	// The reason for the data change.
	Classify *string `json:"Classify,omitempty" xml:"Classify,omitempty"`
	// The tables for which you want to clear historical data.
	CronClearItemList []*CreateDataCronClearOrderRequestParamCronClearItemList `json:"CronClearItemList,omitempty" xml:"CronClearItemList,omitempty" type:"Repeated"`
	// The crontab expression that you can use to run the task at a specified time. For more information, see [Crontab expression](~~206581~~).
	CronFormat *string `json:"CronFormat,omitempty" xml:"CronFormat,omitempty"`
	// The databases for which you want to clear historical data.
	DbItemList []*CreateDataCronClearOrderRequestParamDbItemList `json:"DbItemList,omitempty" xml:"DbItemList,omitempty" type:"Repeated"`
	// The amount of time taken to run the task. Unit: hours.
	//
	// >  If the **specifyDuration** parameter is set to **true**, this parameter is required.
	DurationHour *int64 `json:"DurationHour,omitempty" xml:"DurationHour,omitempty"`
	// Specifies whether to specify an end time for the task. Valid values:
	//
	// *   **true**: specifies an end time for the task. The task is automatically suspended after this end time.
	// *   **false**: does not specify an end time for the task. The task is stopped after the historical data is cleared.
	SpecifyDuration *bool `json:"specifyDuration,omitempty" xml:"specifyDuration,omitempty"`
}

func (s CreateDataCronClearOrderRequestParam) String() string {
	return tea.Prettify(s)
}

func (s CreateDataCronClearOrderRequestParam) GoString() string {
	return s.String()
}

func (s *CreateDataCronClearOrderRequestParam) SetClassify(v string) *CreateDataCronClearOrderRequestParam {
	s.Classify = &v
	return s
}

func (s *CreateDataCronClearOrderRequestParam) SetCronClearItemList(v []*CreateDataCronClearOrderRequestParamCronClearItemList) *CreateDataCronClearOrderRequestParam {
	s.CronClearItemList = v
	return s
}

func (s *CreateDataCronClearOrderRequestParam) SetCronFormat(v string) *CreateDataCronClearOrderRequestParam {
	s.CronFormat = &v
	return s
}

func (s *CreateDataCronClearOrderRequestParam) SetDbItemList(v []*CreateDataCronClearOrderRequestParamDbItemList) *CreateDataCronClearOrderRequestParam {
	s.DbItemList = v
	return s
}

func (s *CreateDataCronClearOrderRequestParam) SetDurationHour(v int64) *CreateDataCronClearOrderRequestParam {
	s.DurationHour = &v
	return s
}

func (s *CreateDataCronClearOrderRequestParam) SetSpecifyDuration(v bool) *CreateDataCronClearOrderRequestParam {
	s.SpecifyDuration = &v
	return s
}

type CreateDataCronClearOrderRequestParamCronClearItemList struct {
	// The name of the field.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The filter conditions.
	FilterSQL *string `json:"FilterSQL,omitempty" xml:"FilterSQL,omitempty"`
	// The retention period of the historical data. Unit: days. For example, if you set the parameter to 7, DMS deletes the data that is retained for more than seven days.
	RemainDays *int64 `json:"RemainDays,omitempty" xml:"RemainDays,omitempty"`
	// The name of the table. You can call the [ListTables](~~141878~~) operation to query the name of the table.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	// The type of time granularity. If the ColumnName parameter specifies a field of a time type, this parameter is required. Valid values:
	//
	// *   **MILLISECONDS**: milliseconds
	// *   **SECONDS**: seconds
	TimeUnit *string `json:"TimeUnit,omitempty" xml:"TimeUnit,omitempty"`
}

func (s CreateDataCronClearOrderRequestParamCronClearItemList) String() string {
	return tea.Prettify(s)
}

func (s CreateDataCronClearOrderRequestParamCronClearItemList) GoString() string {
	return s.String()
}

func (s *CreateDataCronClearOrderRequestParamCronClearItemList) SetColumnName(v string) *CreateDataCronClearOrderRequestParamCronClearItemList {
	s.ColumnName = &v
	return s
}

func (s *CreateDataCronClearOrderRequestParamCronClearItemList) SetFilterSQL(v string) *CreateDataCronClearOrderRequestParamCronClearItemList {
	s.FilterSQL = &v
	return s
}

func (s *CreateDataCronClearOrderRequestParamCronClearItemList) SetRemainDays(v int64) *CreateDataCronClearOrderRequestParamCronClearItemList {
	s.RemainDays = &v
	return s
}

func (s *CreateDataCronClearOrderRequestParamCronClearItemList) SetTableName(v string) *CreateDataCronClearOrderRequestParamCronClearItemList {
	s.TableName = &v
	return s
}

func (s *CreateDataCronClearOrderRequestParamCronClearItemList) SetTimeUnit(v string) *CreateDataCronClearOrderRequestParamCronClearItemList {
	s.TimeUnit = &v
	return s
}

type CreateDataCronClearOrderRequestParamDbItemList struct {
	// The ID of the database. You can call the [SearchDatabases](~~141876~~) operation to query the ID of the database.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// Indicates whether the database is a logical database. Valid values:
	//
	// *   **true**: The database is a logical database.
	// *   **false**: The database is not a logical database.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
}

func (s CreateDataCronClearOrderRequestParamDbItemList) String() string {
	return tea.Prettify(s)
}

func (s CreateDataCronClearOrderRequestParamDbItemList) GoString() string {
	return s.String()
}

func (s *CreateDataCronClearOrderRequestParamDbItemList) SetDbId(v int64) *CreateDataCronClearOrderRequestParamDbItemList {
	s.DbId = &v
	return s
}

func (s *CreateDataCronClearOrderRequestParamDbItemList) SetLogic(v bool) *CreateDataCronClearOrderRequestParamDbItemList {
	s.Logic = &v
	return s
}

type CreateDataCronClearOrderShrinkRequest struct {
	// The key of the attachment for the ticket. The attachment provides more instructions for this operation.
	//
	// You can call the [GetUserUploadFileJob](~~206069~~) operation to query the key of the attachment.
	AttachmentKey *string `json:"AttachmentKey,omitempty" xml:"AttachmentKey,omitempty"`
	// The purpose or objective of the data change. This reduces unnecessary communication.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The parameters of the ticket.
	ParamShrink *string `json:"Param,omitempty" xml:"Param,omitempty"`
	// The stakeholders of this operation. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than Data Management (DMS) administrators and database administrators (DBAs) are not allowed to view the ticket details.
	RelatedUserListShrink *string `json:"RelatedUserList,omitempty" xml:"RelatedUserList,omitempty"`
	// The ID of the tenant.
	//
	// >  The ID of the tenant is displayed when you move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the [View information about the current tenant](~~181330~~) section of the Manage DMS tenants topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateDataCronClearOrderShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDataCronClearOrderShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateDataCronClearOrderShrinkRequest) SetAttachmentKey(v string) *CreateDataCronClearOrderShrinkRequest {
	s.AttachmentKey = &v
	return s
}

func (s *CreateDataCronClearOrderShrinkRequest) SetComment(v string) *CreateDataCronClearOrderShrinkRequest {
	s.Comment = &v
	return s
}

func (s *CreateDataCronClearOrderShrinkRequest) SetParamShrink(v string) *CreateDataCronClearOrderShrinkRequest {
	s.ParamShrink = &v
	return s
}

func (s *CreateDataCronClearOrderShrinkRequest) SetRelatedUserListShrink(v string) *CreateDataCronClearOrderShrinkRequest {
	s.RelatedUserListShrink = &v
	return s
}

func (s *CreateDataCronClearOrderShrinkRequest) SetTid(v int64) *CreateDataCronClearOrderShrinkRequest {
	s.Tid = &v
	return s
}

type CreateDataCronClearOrderResponseBody struct {
	// The ID of the ticket.
	CreateOrderResult []*int64 `json:"CreateOrderResult,omitempty" xml:"CreateOrderResult,omitempty" type:"Repeated"`
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateDataCronClearOrderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDataCronClearOrderResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDataCronClearOrderResponseBody) SetCreateOrderResult(v []*int64) *CreateDataCronClearOrderResponseBody {
	s.CreateOrderResult = v
	return s
}

func (s *CreateDataCronClearOrderResponseBody) SetErrorCode(v string) *CreateDataCronClearOrderResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateDataCronClearOrderResponseBody) SetErrorMessage(v string) *CreateDataCronClearOrderResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateDataCronClearOrderResponseBody) SetRequestId(v string) *CreateDataCronClearOrderResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDataCronClearOrderResponseBody) SetSuccess(v bool) *CreateDataCronClearOrderResponseBody {
	s.Success = &v
	return s
}

type CreateDataCronClearOrderResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDataCronClearOrderResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDataCronClearOrderResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDataCronClearOrderResponse) GoString() string {
	return s.String()
}

func (s *CreateDataCronClearOrderResponse) SetHeaders(v map[string]*string) *CreateDataCronClearOrderResponse {
	s.Headers = v
	return s
}

func (s *CreateDataCronClearOrderResponse) SetStatusCode(v int32) *CreateDataCronClearOrderResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDataCronClearOrderResponse) SetBody(v *CreateDataCronClearOrderResponseBody) *CreateDataCronClearOrderResponse {
	s.Body = v
	return s
}

type CreateDataExportOrderRequest struct {
	// The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key.
	AttachmentKey *string `json:"AttachmentKey,omitempty" xml:"AttachmentKey,omitempty"`
	// The purpose or objective of the ticket. This parameter helps reduce unnecessary communication.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The ID of the parent ticket.
	ParentId *int64 `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
	// The parameters of the ticket.
	PluginParam *CreateDataExportOrderRequestPluginParam `json:"PluginParam,omitempty" xml:"PluginParam,omitempty" type:"Struct"`
	// The stakeholders involved in this operation.
	RelatedUserList []*int64 `json:"RelatedUserList,omitempty" xml:"RelatedUserList,omitempty" type:"Repeated"`
	// The tenant ID.
	//
	// > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the [View information about the current tenant](~~181330~~) section of the "Manage DMS tenants" topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateDataExportOrderRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDataExportOrderRequest) GoString() string {
	return s.String()
}

func (s *CreateDataExportOrderRequest) SetAttachmentKey(v string) *CreateDataExportOrderRequest {
	s.AttachmentKey = &v
	return s
}

func (s *CreateDataExportOrderRequest) SetComment(v string) *CreateDataExportOrderRequest {
	s.Comment = &v
	return s
}

func (s *CreateDataExportOrderRequest) SetParentId(v int64) *CreateDataExportOrderRequest {
	s.ParentId = &v
	return s
}

func (s *CreateDataExportOrderRequest) SetPluginParam(v *CreateDataExportOrderRequestPluginParam) *CreateDataExportOrderRequest {
	s.PluginParam = v
	return s
}

func (s *CreateDataExportOrderRequest) SetRelatedUserList(v []*int64) *CreateDataExportOrderRequest {
	s.RelatedUserList = v
	return s
}

func (s *CreateDataExportOrderRequest) SetTid(v int64) *CreateDataExportOrderRequest {
	s.Tid = &v
	return s
}

type CreateDataExportOrderRequestPluginParam struct {
	// The estimated number of data rows to be affected.
	AffectRows *int64 `json:"AffectRows,omitempty" xml:"AffectRows,omitempty"`
	// The reason for the export ticket.
	Classify *string `json:"Classify,omitempty" xml:"Classify,omitempty"`
	// The database ID.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The SQL statements that can be executed.
	ExeSQL *string `json:"ExeSQL,omitempty" xml:"ExeSQL,omitempty"`
	// Specifies whether to skip verification. Valid values:
	//
	// *   **true**
	// *   **false**
	IgnoreAffectRows *bool `json:"IgnoreAffectRows,omitempty" xml:"IgnoreAffectRows,omitempty"`
	// The reason for skipping verification. This parameter is required if you set IgnoreAffectRows to true.
	IgnoreAffectRowsReason *string `json:"IgnoreAffectRowsReason,omitempty" xml:"IgnoreAffectRowsReason,omitempty"`
	// The instance ID.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// Specifies whether the database is a logical database. Valid values:
	//
	// *   **true**
	// *   **false**
	//
	// > If you set this parameter to **true**, the database that you specify must be a logical database.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The information about the watermarks.
	Watermark *CreateDataExportOrderRequestPluginParamWatermark `json:"Watermark,omitempty" xml:"Watermark,omitempty" type:"Struct"`
}

func (s CreateDataExportOrderRequestPluginParam) String() string {
	return tea.Prettify(s)
}

func (s CreateDataExportOrderRequestPluginParam) GoString() string {
	return s.String()
}

func (s *CreateDataExportOrderRequestPluginParam) SetAffectRows(v int64) *CreateDataExportOrderRequestPluginParam {
	s.AffectRows = &v
	return s
}

func (s *CreateDataExportOrderRequestPluginParam) SetClassify(v string) *CreateDataExportOrderRequestPluginParam {
	s.Classify = &v
	return s
}

func (s *CreateDataExportOrderRequestPluginParam) SetDbId(v int64) *CreateDataExportOrderRequestPluginParam {
	s.DbId = &v
	return s
}

func (s *CreateDataExportOrderRequestPluginParam) SetExeSQL(v string) *CreateDataExportOrderRequestPluginParam {
	s.ExeSQL = &v
	return s
}

func (s *CreateDataExportOrderRequestPluginParam) SetIgnoreAffectRows(v bool) *CreateDataExportOrderRequestPluginParam {
	s.IgnoreAffectRows = &v
	return s
}

func (s *CreateDataExportOrderRequestPluginParam) SetIgnoreAffectRowsReason(v string) *CreateDataExportOrderRequestPluginParam {
	s.IgnoreAffectRowsReason = &v
	return s
}

func (s *CreateDataExportOrderRequestPluginParam) SetInstanceId(v int64) *CreateDataExportOrderRequestPluginParam {
	s.InstanceId = &v
	return s
}

func (s *CreateDataExportOrderRequestPluginParam) SetLogic(v bool) *CreateDataExportOrderRequestPluginParam {
	s.Logic = &v
	return s
}

func (s *CreateDataExportOrderRequestPluginParam) SetWatermark(v *CreateDataExportOrderRequestPluginParamWatermark) *CreateDataExportOrderRequestPluginParam {
	s.Watermark = v
	return s
}

type CreateDataExportOrderRequestPluginParamWatermark struct {
	// The field into which the watermark is to be embedded.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The information to be embedded as a watermark into data.
	DataWatermark *string `json:"DataWatermark,omitempty" xml:"DataWatermark,omitempty"`
	// The information to be embedded as a watermark into files.
	FileWatermark *string `json:"FileWatermark,omitempty" xml:"FileWatermark,omitempty"`
	// One or more primary keys or unique keys.
	Keys []*string `json:"Keys,omitempty" xml:"Keys,omitempty" type:"Repeated"`
	// The methods in which the watermark is embedded.
	WatermarkTypes []*string `json:"WatermarkTypes,omitempty" xml:"WatermarkTypes,omitempty" type:"Repeated"`
}

func (s CreateDataExportOrderRequestPluginParamWatermark) String() string {
	return tea.Prettify(s)
}

func (s CreateDataExportOrderRequestPluginParamWatermark) GoString() string {
	return s.String()
}

func (s *CreateDataExportOrderRequestPluginParamWatermark) SetColumnName(v string) *CreateDataExportOrderRequestPluginParamWatermark {
	s.ColumnName = &v
	return s
}

func (s *CreateDataExportOrderRequestPluginParamWatermark) SetDataWatermark(v string) *CreateDataExportOrderRequestPluginParamWatermark {
	s.DataWatermark = &v
	return s
}

func (s *CreateDataExportOrderRequestPluginParamWatermark) SetFileWatermark(v string) *CreateDataExportOrderRequestPluginParamWatermark {
	s.FileWatermark = &v
	return s
}

func (s *CreateDataExportOrderRequestPluginParamWatermark) SetKeys(v []*string) *CreateDataExportOrderRequestPluginParamWatermark {
	s.Keys = v
	return s
}

func (s *CreateDataExportOrderRequestPluginParamWatermark) SetWatermarkTypes(v []*string) *CreateDataExportOrderRequestPluginParamWatermark {
	s.WatermarkTypes = v
	return s
}

type CreateDataExportOrderShrinkRequest struct {
	// The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key.
	AttachmentKey *string `json:"AttachmentKey,omitempty" xml:"AttachmentKey,omitempty"`
	// The purpose or objective of the ticket. This parameter helps reduce unnecessary communication.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The ID of the parent ticket.
	ParentId *int64 `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
	// The parameters of the ticket.
	PluginParamShrink *string `json:"PluginParam,omitempty" xml:"PluginParam,omitempty"`
	// The stakeholders involved in this operation.
	RelatedUserListShrink *string `json:"RelatedUserList,omitempty" xml:"RelatedUserList,omitempty"`
	// The tenant ID.
	//
	// > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the [View information about the current tenant](~~181330~~) section of the "Manage DMS tenants" topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateDataExportOrderShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDataExportOrderShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateDataExportOrderShrinkRequest) SetAttachmentKey(v string) *CreateDataExportOrderShrinkRequest {
	s.AttachmentKey = &v
	return s
}

func (s *CreateDataExportOrderShrinkRequest) SetComment(v string) *CreateDataExportOrderShrinkRequest {
	s.Comment = &v
	return s
}

func (s *CreateDataExportOrderShrinkRequest) SetParentId(v int64) *CreateDataExportOrderShrinkRequest {
	s.ParentId = &v
	return s
}

func (s *CreateDataExportOrderShrinkRequest) SetPluginParamShrink(v string) *CreateDataExportOrderShrinkRequest {
	s.PluginParamShrink = &v
	return s
}

func (s *CreateDataExportOrderShrinkRequest) SetRelatedUserListShrink(v string) *CreateDataExportOrderShrinkRequest {
	s.RelatedUserListShrink = &v
	return s
}

func (s *CreateDataExportOrderShrinkRequest) SetTid(v int64) *CreateDataExportOrderShrinkRequest {
	s.Tid = &v
	return s
}

type CreateDataExportOrderResponseBody struct {
	// The content of the ticket.
	CreateOrderResult *CreateDataExportOrderResponseBodyCreateOrderResult `json:"CreateOrderResult,omitempty" xml:"CreateOrderResult,omitempty" type:"Struct"`
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true
	// *   false
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateDataExportOrderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDataExportOrderResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDataExportOrderResponseBody) SetCreateOrderResult(v *CreateDataExportOrderResponseBodyCreateOrderResult) *CreateDataExportOrderResponseBody {
	s.CreateOrderResult = v
	return s
}

func (s *CreateDataExportOrderResponseBody) SetErrorCode(v string) *CreateDataExportOrderResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateDataExportOrderResponseBody) SetErrorMessage(v string) *CreateDataExportOrderResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateDataExportOrderResponseBody) SetRequestId(v string) *CreateDataExportOrderResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDataExportOrderResponseBody) SetSuccess(v bool) *CreateDataExportOrderResponseBody {
	s.Success = &v
	return s
}

type CreateDataExportOrderResponseBodyCreateOrderResult struct {
	CreateOrderResult []*int64 `json:"CreateOrderResult,omitempty" xml:"CreateOrderResult,omitempty" type:"Repeated"`
}

func (s CreateDataExportOrderResponseBodyCreateOrderResult) String() string {
	return tea.Prettify(s)
}

func (s CreateDataExportOrderResponseBodyCreateOrderResult) GoString() string {
	return s.String()
}

func (s *CreateDataExportOrderResponseBodyCreateOrderResult) SetCreateOrderResult(v []*int64) *CreateDataExportOrderResponseBodyCreateOrderResult {
	s.CreateOrderResult = v
	return s
}

type CreateDataExportOrderResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDataExportOrderResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDataExportOrderResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDataExportOrderResponse) GoString() string {
	return s.String()
}

func (s *CreateDataExportOrderResponse) SetHeaders(v map[string]*string) *CreateDataExportOrderResponse {
	s.Headers = v
	return s
}

func (s *CreateDataExportOrderResponse) SetStatusCode(v int32) *CreateDataExportOrderResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDataExportOrderResponse) SetBody(v *CreateDataExportOrderResponseBody) *CreateDataExportOrderResponse {
	s.Body = v
	return s
}

type CreateDataImportOrderRequest struct {
	// The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key from the value of the AttachmentKey parameter.
	AttachmentKey *string `json:"AttachmentKey,omitempty" xml:"AttachmentKey,omitempty"`
	// The purpose or objective of the data import. This parameter is used to help reduce unnecessary communication.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The parameters of the ticket.
	Param *CreateDataImportOrderRequestParam `json:"Param,omitempty" xml:"Param,omitempty" type:"Struct"`
	// The stakeholders of the data import. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
	RelatedUserList []*int64 `json:"RelatedUserList,omitempty" xml:"RelatedUserList,omitempty" type:"Repeated"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateDataImportOrderRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDataImportOrderRequest) GoString() string {
	return s.String()
}

func (s *CreateDataImportOrderRequest) SetAttachmentKey(v string) *CreateDataImportOrderRequest {
	s.AttachmentKey = &v
	return s
}

func (s *CreateDataImportOrderRequest) SetComment(v string) *CreateDataImportOrderRequest {
	s.Comment = &v
	return s
}

func (s *CreateDataImportOrderRequest) SetParam(v *CreateDataImportOrderRequestParam) *CreateDataImportOrderRequest {
	s.Param = v
	return s
}

func (s *CreateDataImportOrderRequest) SetRelatedUserList(v []*int64) *CreateDataImportOrderRequest {
	s.RelatedUserList = v
	return s
}

func (s *CreateDataImportOrderRequest) SetTid(v int64) *CreateDataImportOrderRequest {
	s.Tid = &v
	return s
}

type CreateDataImportOrderRequestParam struct {
	// The key of the attachment that contains the SQL statements used to import data. You can call the [GetUserUploadFileJob](~~206069~~) operation to the attachment key from the value of the AttachmentKey parameter.
	AttachmentName *string `json:"AttachmentName,omitempty" xml:"AttachmentName,omitempty"`
	// The reason for the data import.
	Classify *string `json:"Classify,omitempty" xml:"Classify,omitempty"`
	// The type of the CSV file. Valid values:
	//
	// *   **true**: The first row in the CSV file contains field names.
	// *   **false**: The first row in the CSV file contains data.
	//
	// >  This parameter is required if you set the **FileType** parameter to **CSV**.
	CsvFirstRowIsColumnDef *bool `json:"CsvFirstRowIsColumnDef,omitempty" xml:"CsvFirstRowIsColumnDef,omitempty"`
	// The database to which you want to import data. You can specify only one database.
	DbItemList []*CreateDataImportOrderRequestParamDbItemList `json:"DbItemList,omitempty" xml:"DbItemList,omitempty" type:"Repeated"`
	// The encoding algorithm to be used by the destination database. Valid values:
	//
	// *   **AUTO**: automatic identification
	// *   **UTF-8**: UTF-8 encoding
	// *   **GBK**: GBK encoding
	// *   **ISO-8859-1**: ISO-8859-1 encoding
	FileEncoding *string `json:"FileEncoding,omitempty" xml:"FileEncoding,omitempty"`
	// The format of the file for the data import. Valid values:
	//
	// *   **SQL**: an SQL file
	// *   **CSV**: a CSV file
	FileType *string `json:"FileType,omitempty" xml:"FileType,omitempty"`
	// Specifies whether to skip an error that occurs. Valid values:
	//
	// *   **true**: skips the error and continues to execute SQL statements.
	// *   **false**: stops executing SQL statements.
	IgnoreError *bool `json:"IgnoreError,omitempty" xml:"IgnoreError,omitempty"`
	// The import mode. Valid values:
	//
	// *   **FAST_MODE**: In the Execute step, the uploaded file is read and SQL statements are executed to import data to the specified destination database. Compared with the security mode, this mode can be used to import data in a less secure but more efficient manner.
	// *   **SAFE_MODE**: In the Precheck step, the uploaded file is parsed, and SQL statements or CSV file data is cached. In the Execute step, the cached SQL statements are read and executed to import data, or the cached CSV file data is read and imported to the specified destination database. This mode can be used to import data in a more secure but less efficient manner.
	ImportMode *string `json:"ImportMode,omitempty" xml:"ImportMode,omitempty"`
	// The mode in which the data in the CSV format is to be written to the destination table. Valid values:
	//
	// *   **INSERT**: The database checks the primary key when data is written. If a duplicate primary key value exists, an error message is returned.
	// *   **INSERT_IGNORE**: If the imported data contains data records that are the same as those in the destination table, the new data records are ignored.
	// *   **REPLACE_INTO**: If the imported data contains a row that has the same value for the primary key or unique index as one row in the destination table, the database deletes the existing row and inserts the new row into the destination table.
	//
	// >  This parameter is required if you set the **FileType** parameter to **CSV**.
	InsertType *string `json:"InsertType,omitempty" xml:"InsertType,omitempty"`
	// The key of the attachment that contains the SQL statements used to roll back the data import. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key from the value of the AttachmentKey parameter.
	//
	// >  This parameter is required if you set the **RollbackSqlType** parameter to **ATTACHMENT**.
	RollbackAttachmentName *string `json:"RollbackAttachmentName,omitempty" xml:"RollbackAttachmentName,omitempty"`
	// The SQL statements used to roll back the data import.
	//
	// >  This parameter is required if you set the **RollbackSqlType** parameter to **TEXT**.
	RollbackSQL *string `json:"RollbackSQL,omitempty" xml:"RollbackSQL,omitempty"`
	// The format of the SQL statements used to roll back the data import. Valid values:
	//
	// *   **TEXT**: text
	// *   **ATTACHMENT**: attachment
	RollbackSqlType *string `json:"RollbackSqlType,omitempty" xml:"RollbackSqlType,omitempty"`
	// The destination table to which you want to import the data in the CSV format.
	//
	// >  This parameter is required if you set the **FileType** parameter to **CSV**.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s CreateDataImportOrderRequestParam) String() string {
	return tea.Prettify(s)
}

func (s CreateDataImportOrderRequestParam) GoString() string {
	return s.String()
}

func (s *CreateDataImportOrderRequestParam) SetAttachmentName(v string) *CreateDataImportOrderRequestParam {
	s.AttachmentName = &v
	return s
}

func (s *CreateDataImportOrderRequestParam) SetClassify(v string) *CreateDataImportOrderRequestParam {
	s.Classify = &v
	return s
}

func (s *CreateDataImportOrderRequestParam) SetCsvFirstRowIsColumnDef(v bool) *CreateDataImportOrderRequestParam {
	s.CsvFirstRowIsColumnDef = &v
	return s
}

func (s *CreateDataImportOrderRequestParam) SetDbItemList(v []*CreateDataImportOrderRequestParamDbItemList) *CreateDataImportOrderRequestParam {
	s.DbItemList = v
	return s
}

func (s *CreateDataImportOrderRequestParam) SetFileEncoding(v string) *CreateDataImportOrderRequestParam {
	s.FileEncoding = &v
	return s
}

func (s *CreateDataImportOrderRequestParam) SetFileType(v string) *CreateDataImportOrderRequestParam {
	s.FileType = &v
	return s
}

func (s *CreateDataImportOrderRequestParam) SetIgnoreError(v bool) *CreateDataImportOrderRequestParam {
	s.IgnoreError = &v
	return s
}

func (s *CreateDataImportOrderRequestParam) SetImportMode(v string) *CreateDataImportOrderRequestParam {
	s.ImportMode = &v
	return s
}

func (s *CreateDataImportOrderRequestParam) SetInsertType(v string) *CreateDataImportOrderRequestParam {
	s.InsertType = &v
	return s
}

func (s *CreateDataImportOrderRequestParam) SetRollbackAttachmentName(v string) *CreateDataImportOrderRequestParam {
	s.RollbackAttachmentName = &v
	return s
}

func (s *CreateDataImportOrderRequestParam) SetRollbackSQL(v string) *CreateDataImportOrderRequestParam {
	s.RollbackSQL = &v
	return s
}

func (s *CreateDataImportOrderRequestParam) SetRollbackSqlType(v string) *CreateDataImportOrderRequestParam {
	s.RollbackSqlType = &v
	return s
}

func (s *CreateDataImportOrderRequestParam) SetTableName(v string) *CreateDataImportOrderRequestParam {
	s.TableName = &v
	return s
}

type CreateDataImportOrderRequestParamDbItemList struct {
	// The ID of the database. The database can be a physical database or a logical database.
	//
	// *   To obtain the ID of a physical database, call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation.
	// *   To obtain the ID of a logical database, call the [ListLogicDatabases](~~141874~~) or [SearchDatabase](~~141876~~) operation.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// Specifies whether the database is a logical database. Valid values:
	//
	// *   **true**: The database is a logical database.
	// *   **false**: The database is a physical database.
	//
	// >  If you set this parameter to **true**, the database that you specify must be a logical database.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
}

func (s CreateDataImportOrderRequestParamDbItemList) String() string {
	return tea.Prettify(s)
}

func (s CreateDataImportOrderRequestParamDbItemList) GoString() string {
	return s.String()
}

func (s *CreateDataImportOrderRequestParamDbItemList) SetDbId(v int64) *CreateDataImportOrderRequestParamDbItemList {
	s.DbId = &v
	return s
}

func (s *CreateDataImportOrderRequestParamDbItemList) SetLogic(v bool) *CreateDataImportOrderRequestParamDbItemList {
	s.Logic = &v
	return s
}

type CreateDataImportOrderShrinkRequest struct {
	// The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key from the value of the AttachmentKey parameter.
	AttachmentKey *string `json:"AttachmentKey,omitempty" xml:"AttachmentKey,omitempty"`
	// The purpose or objective of the data import. This parameter is used to help reduce unnecessary communication.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The parameters of the ticket.
	ParamShrink *string `json:"Param,omitempty" xml:"Param,omitempty"`
	// The stakeholders of the data import. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
	RelatedUserListShrink *string `json:"RelatedUserList,omitempty" xml:"RelatedUserList,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateDataImportOrderShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDataImportOrderShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateDataImportOrderShrinkRequest) SetAttachmentKey(v string) *CreateDataImportOrderShrinkRequest {
	s.AttachmentKey = &v
	return s
}

func (s *CreateDataImportOrderShrinkRequest) SetComment(v string) *CreateDataImportOrderShrinkRequest {
	s.Comment = &v
	return s
}

func (s *CreateDataImportOrderShrinkRequest) SetParamShrink(v string) *CreateDataImportOrderShrinkRequest {
	s.ParamShrink = &v
	return s
}

func (s *CreateDataImportOrderShrinkRequest) SetRelatedUserListShrink(v string) *CreateDataImportOrderShrinkRequest {
	s.RelatedUserListShrink = &v
	return s
}

func (s *CreateDataImportOrderShrinkRequest) SetTid(v int64) *CreateDataImportOrderShrinkRequest {
	s.Tid = &v
	return s
}

type CreateDataImportOrderResponseBody struct {
	// The ID of the ticket.
	CreateOrderResult []*int64 `json:"CreateOrderResult,omitempty" xml:"CreateOrderResult,omitempty" type:"Repeated"`
	// The error code returned if the request fails.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**: The request is successful.
	// *   **false**: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateDataImportOrderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDataImportOrderResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDataImportOrderResponseBody) SetCreateOrderResult(v []*int64) *CreateDataImportOrderResponseBody {
	s.CreateOrderResult = v
	return s
}

func (s *CreateDataImportOrderResponseBody) SetErrorCode(v string) *CreateDataImportOrderResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateDataImportOrderResponseBody) SetErrorMessage(v string) *CreateDataImportOrderResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateDataImportOrderResponseBody) SetRequestId(v string) *CreateDataImportOrderResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDataImportOrderResponseBody) SetSuccess(v bool) *CreateDataImportOrderResponseBody {
	s.Success = &v
	return s
}

type CreateDataImportOrderResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDataImportOrderResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDataImportOrderResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDataImportOrderResponse) GoString() string {
	return s.String()
}

func (s *CreateDataImportOrderResponse) SetHeaders(v map[string]*string) *CreateDataImportOrderResponse {
	s.Headers = v
	return s
}

func (s *CreateDataImportOrderResponse) SetStatusCode(v int32) *CreateDataImportOrderResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDataImportOrderResponse) SetBody(v *CreateDataImportOrderResponseBody) *CreateDataImportOrderResponse {
	s.Body = v
	return s
}

type CreateDataTrackOrderRequest struct {
	// The purpose or objective of the data tracking ticket. This parameter is used to help reduce unnecessary communication.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The parameters of the ticket.
	Param *CreateDataTrackOrderRequestParam `json:"Param,omitempty" xml:"Param,omitempty" type:"Struct"`
	// The IDs of the operators that are related to the ticket.
	RelatedUserList []*string `json:"RelatedUserList,omitempty" xml:"RelatedUserList,omitempty" type:"Repeated"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateDataTrackOrderRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDataTrackOrderRequest) GoString() string {
	return s.String()
}

func (s *CreateDataTrackOrderRequest) SetComment(v string) *CreateDataTrackOrderRequest {
	s.Comment = &v
	return s
}

func (s *CreateDataTrackOrderRequest) SetParam(v *CreateDataTrackOrderRequestParam) *CreateDataTrackOrderRequest {
	s.Param = v
	return s
}

func (s *CreateDataTrackOrderRequest) SetRelatedUserList(v []*string) *CreateDataTrackOrderRequest {
	s.RelatedUserList = v
	return s
}

func (s *CreateDataTrackOrderRequest) SetTid(v int64) *CreateDataTrackOrderRequest {
	s.Tid = &v
	return s
}

type CreateDataTrackOrderRequestParam struct {
	// The ID of the database. You can call the [SearchDatabases](~~141876~~) operation to query the ID of the database.
	//
	// > You can call this operation to create a data tracking ticket for only physical databases. This operation is not applicable to logical databases.
	DbId *string `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The end time of the time range in which you want to track data operations. The time must be in the yyyy-MM-dd HH:mm:ss format.
	JobEndTime *string `json:"JobEndTime,omitempty" xml:"JobEndTime,omitempty"`
	// The start time of the time range in which you want to track data operations. The time must be in the yyyy-MM-dd HH:mm:ss format.
	JobStartTime *string `json:"JobStartTime,omitempty" xml:"JobStartTime,omitempty"`
	// The names of the tables for which you want to track data operations.
	TableNames []*string `json:"TableNames,omitempty" xml:"TableNames,omitempty" type:"Repeated"`
	// The types of data operations that you want to track.
	TrackTypes []*string `json:"TrackTypes,omitempty" xml:"TrackTypes,omitempty" type:"Repeated"`
}

func (s CreateDataTrackOrderRequestParam) String() string {
	return tea.Prettify(s)
}

func (s CreateDataTrackOrderRequestParam) GoString() string {
	return s.String()
}

func (s *CreateDataTrackOrderRequestParam) SetDbId(v string) *CreateDataTrackOrderRequestParam {
	s.DbId = &v
	return s
}

func (s *CreateDataTrackOrderRequestParam) SetJobEndTime(v string) *CreateDataTrackOrderRequestParam {
	s.JobEndTime = &v
	return s
}

func (s *CreateDataTrackOrderRequestParam) SetJobStartTime(v string) *CreateDataTrackOrderRequestParam {
	s.JobStartTime = &v
	return s
}

func (s *CreateDataTrackOrderRequestParam) SetTableNames(v []*string) *CreateDataTrackOrderRequestParam {
	s.TableNames = v
	return s
}

func (s *CreateDataTrackOrderRequestParam) SetTrackTypes(v []*string) *CreateDataTrackOrderRequestParam {
	s.TrackTypes = v
	return s
}

type CreateDataTrackOrderShrinkRequest struct {
	// The purpose or objective of the data tracking ticket. This parameter is used to help reduce unnecessary communication.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The parameters of the ticket.
	ParamShrink *string `json:"Param,omitempty" xml:"Param,omitempty"`
	// The IDs of the operators that are related to the ticket.
	RelatedUserListShrink *string `json:"RelatedUserList,omitempty" xml:"RelatedUserList,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateDataTrackOrderShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDataTrackOrderShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateDataTrackOrderShrinkRequest) SetComment(v string) *CreateDataTrackOrderShrinkRequest {
	s.Comment = &v
	return s
}

func (s *CreateDataTrackOrderShrinkRequest) SetParamShrink(v string) *CreateDataTrackOrderShrinkRequest {
	s.ParamShrink = &v
	return s
}

func (s *CreateDataTrackOrderShrinkRequest) SetRelatedUserListShrink(v string) *CreateDataTrackOrderShrinkRequest {
	s.RelatedUserListShrink = &v
	return s
}

func (s *CreateDataTrackOrderShrinkRequest) SetTid(v int64) *CreateDataTrackOrderShrinkRequest {
	s.Tid = &v
	return s
}

type CreateDataTrackOrderResponseBody struct {
	// The IDs of the data tracking tickets.
	CreateOrderResult []*int64 `json:"CreateOrderResult,omitempty" xml:"CreateOrderResult,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateDataTrackOrderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDataTrackOrderResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDataTrackOrderResponseBody) SetCreateOrderResult(v []*int64) *CreateDataTrackOrderResponseBody {
	s.CreateOrderResult = v
	return s
}

func (s *CreateDataTrackOrderResponseBody) SetErrorCode(v string) *CreateDataTrackOrderResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateDataTrackOrderResponseBody) SetErrorMessage(v string) *CreateDataTrackOrderResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateDataTrackOrderResponseBody) SetRequestId(v string) *CreateDataTrackOrderResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDataTrackOrderResponseBody) SetSuccess(v bool) *CreateDataTrackOrderResponseBody {
	s.Success = &v
	return s
}

type CreateDataTrackOrderResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDataTrackOrderResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDataTrackOrderResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDataTrackOrderResponse) GoString() string {
	return s.String()
}

func (s *CreateDataTrackOrderResponse) SetHeaders(v map[string]*string) *CreateDataTrackOrderResponse {
	s.Headers = v
	return s
}

func (s *CreateDataTrackOrderResponse) SetStatusCode(v int32) *CreateDataTrackOrderResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDataTrackOrderResponse) SetBody(v *CreateDataTrackOrderResponseBody) *CreateDataTrackOrderResponse {
	s.Body = v
	return s
}

type CreateDatabaseExportOrderRequest struct {
	// The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key.
	AttachmentKey *string `json:"AttachmentKey,omitempty" xml:"AttachmentKey,omitempty"`
	// The purpose or objective of the ticket. This parameter helps reduce unnecessary communication.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The ID of the parent ticket.
	ParentId *int64 `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
	// The parameters of the ticket.
	PluginParam *CreateDatabaseExportOrderRequestPluginParam `json:"PluginParam,omitempty" xml:"PluginParam,omitempty" type:"Struct"`
	// The stakeholders involved in this operation.
	RelatedUserList []*int64 `json:"RelatedUserList,omitempty" xml:"RelatedUserList,omitempty" type:"Repeated"`
	// The tenant ID.
	//
	// > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the [View information about the current tenant](~~181330~~) section of the "Manage DMS tenants" topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateDatabaseExportOrderRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDatabaseExportOrderRequest) GoString() string {
	return s.String()
}

func (s *CreateDatabaseExportOrderRequest) SetAttachmentKey(v string) *CreateDatabaseExportOrderRequest {
	s.AttachmentKey = &v
	return s
}

func (s *CreateDatabaseExportOrderRequest) SetComment(v string) *CreateDatabaseExportOrderRequest {
	s.Comment = &v
	return s
}

func (s *CreateDatabaseExportOrderRequest) SetParentId(v int64) *CreateDatabaseExportOrderRequest {
	s.ParentId = &v
	return s
}

func (s *CreateDatabaseExportOrderRequest) SetPluginParam(v *CreateDatabaseExportOrderRequestPluginParam) *CreateDatabaseExportOrderRequest {
	s.PluginParam = v
	return s
}

func (s *CreateDatabaseExportOrderRequest) SetRelatedUserList(v []*int64) *CreateDatabaseExportOrderRequest {
	s.RelatedUserList = v
	return s
}

func (s *CreateDatabaseExportOrderRequest) SetTid(v int64) *CreateDatabaseExportOrderRequest {
	s.Tid = &v
	return s
}

type CreateDatabaseExportOrderRequestPluginParam struct {
	// The reason for the database export.
	Classify *string `json:"Classify,omitempty" xml:"Classify,omitempty"`
	// The configurations for database export.
	Config *CreateDatabaseExportOrderRequestPluginParamConfig `json:"Config,omitempty" xml:"Config,omitempty" type:"Struct"`
	// The database ID.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The instance ID.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// Specifies whether the database is a logical database. Valid values:
	//
	// *   **true**
	// *   **false**
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The name that is used to search for the database.
	SearchName *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
}

func (s CreateDatabaseExportOrderRequestPluginParam) String() string {
	return tea.Prettify(s)
}

func (s CreateDatabaseExportOrderRequestPluginParam) GoString() string {
	return s.String()
}

func (s *CreateDatabaseExportOrderRequestPluginParam) SetClassify(v string) *CreateDatabaseExportOrderRequestPluginParam {
	s.Classify = &v
	return s
}

func (s *CreateDatabaseExportOrderRequestPluginParam) SetConfig(v *CreateDatabaseExportOrderRequestPluginParamConfig) *CreateDatabaseExportOrderRequestPluginParam {
	s.Config = v
	return s
}

func (s *CreateDatabaseExportOrderRequestPluginParam) SetDbId(v int64) *CreateDatabaseExportOrderRequestPluginParam {
	s.DbId = &v
	return s
}

func (s *CreateDatabaseExportOrderRequestPluginParam) SetInstanceId(v int64) *CreateDatabaseExportOrderRequestPluginParam {
	s.InstanceId = &v
	return s
}

func (s *CreateDatabaseExportOrderRequestPluginParam) SetLogic(v bool) *CreateDatabaseExportOrderRequestPluginParam {
	s.Logic = &v
	return s
}

func (s *CreateDatabaseExportOrderRequestPluginParam) SetSearchName(v string) *CreateDatabaseExportOrderRequestPluginParam {
	s.SearchName = &v
	return s
}

type CreateDatabaseExportOrderRequestPluginParamConfig struct {
	// The export options for big data. The options are used to filter the big data to be exported. You can leave this parameter empty.
	DataOption []*string `json:"DataOption,omitempty" xml:"DataOption,omitempty" type:"Repeated"`
	// The type of data that you want to export. Valid values:
	//
	// *   **DATA**: The data of the database is exported.
	// *   **STRUCT**: The schema of the database is exported.
	// *   **DATA_STRUCT**: The data and schema of the database are exported.
	ExportContent *string `json:"ExportContent,omitempty" xml:"ExportContent,omitempty"`
	// The types of schemas that you want to export.
	ExportTypes []*string `json:"ExportTypes,omitempty" xml:"ExportTypes,omitempty" type:"Repeated"`
	// The extension options of the SQL script. You can leave this parameter empty.
	SQLExtOption []*string `json:"SQLExtOption,omitempty" xml:"SQLExtOption,omitempty" type:"Repeated"`
	// The tables that you want to export.
	SelectedTables []*string `json:"SelectedTables,omitempty" xml:"SelectedTables,omitempty" type:"Repeated"`
	// The conditions used to filter the tables to be exported.
	Tables map[string]*string `json:"Tables,omitempty" xml:"Tables,omitempty"`
	// The format in which the database is exported. Valid values:
	//
	// *   **SQL**
	// *   **CSV**
	// *   **XLSX**
	TargetOption *string `json:"TargetOption,omitempty" xml:"TargetOption,omitempty"`
}

func (s CreateDatabaseExportOrderRequestPluginParamConfig) String() string {
	return tea.Prettify(s)
}

func (s CreateDatabaseExportOrderRequestPluginParamConfig) GoString() string {
	return s.String()
}

func (s *CreateDatabaseExportOrderRequestPluginParamConfig) SetDataOption(v []*string) *CreateDatabaseExportOrderRequestPluginParamConfig {
	s.DataOption = v
	return s
}

func (s *CreateDatabaseExportOrderRequestPluginParamConfig) SetExportContent(v string) *CreateDatabaseExportOrderRequestPluginParamConfig {
	s.ExportContent = &v
	return s
}

func (s *CreateDatabaseExportOrderRequestPluginParamConfig) SetExportTypes(v []*string) *CreateDatabaseExportOrderRequestPluginParamConfig {
	s.ExportTypes = v
	return s
}

func (s *CreateDatabaseExportOrderRequestPluginParamConfig) SetSQLExtOption(v []*string) *CreateDatabaseExportOrderRequestPluginParamConfig {
	s.SQLExtOption = v
	return s
}

func (s *CreateDatabaseExportOrderRequestPluginParamConfig) SetSelectedTables(v []*string) *CreateDatabaseExportOrderRequestPluginParamConfig {
	s.SelectedTables = v
	return s
}

func (s *CreateDatabaseExportOrderRequestPluginParamConfig) SetTables(v map[string]*string) *CreateDatabaseExportOrderRequestPluginParamConfig {
	s.Tables = v
	return s
}

func (s *CreateDatabaseExportOrderRequestPluginParamConfig) SetTargetOption(v string) *CreateDatabaseExportOrderRequestPluginParamConfig {
	s.TargetOption = &v
	return s
}

type CreateDatabaseExportOrderShrinkRequest struct {
	// The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key.
	AttachmentKey *string `json:"AttachmentKey,omitempty" xml:"AttachmentKey,omitempty"`
	// The purpose or objective of the ticket. This parameter helps reduce unnecessary communication.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The ID of the parent ticket.
	ParentId *int64 `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
	// The parameters of the ticket.
	PluginParamShrink *string `json:"PluginParam,omitempty" xml:"PluginParam,omitempty"`
	// The stakeholders involved in this operation.
	RelatedUserListShrink *string `json:"RelatedUserList,omitempty" xml:"RelatedUserList,omitempty"`
	// The tenant ID.
	//
	// > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the [View information about the current tenant](~~181330~~) section of the "Manage DMS tenants" topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateDatabaseExportOrderShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDatabaseExportOrderShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateDatabaseExportOrderShrinkRequest) SetAttachmentKey(v string) *CreateDatabaseExportOrderShrinkRequest {
	s.AttachmentKey = &v
	return s
}

func (s *CreateDatabaseExportOrderShrinkRequest) SetComment(v string) *CreateDatabaseExportOrderShrinkRequest {
	s.Comment = &v
	return s
}

func (s *CreateDatabaseExportOrderShrinkRequest) SetParentId(v int64) *CreateDatabaseExportOrderShrinkRequest {
	s.ParentId = &v
	return s
}

func (s *CreateDatabaseExportOrderShrinkRequest) SetPluginParamShrink(v string) *CreateDatabaseExportOrderShrinkRequest {
	s.PluginParamShrink = &v
	return s
}

func (s *CreateDatabaseExportOrderShrinkRequest) SetRelatedUserListShrink(v string) *CreateDatabaseExportOrderShrinkRequest {
	s.RelatedUserListShrink = &v
	return s
}

func (s *CreateDatabaseExportOrderShrinkRequest) SetTid(v int64) *CreateDatabaseExportOrderShrinkRequest {
	s.Tid = &v
	return s
}

type CreateDatabaseExportOrderResponseBody struct {
	// The information about the ticket.
	CreateOrderResult *CreateDatabaseExportOrderResponseBodyCreateOrderResult `json:"CreateOrderResult,omitempty" xml:"CreateOrderResult,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true
	// *   false
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateDatabaseExportOrderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDatabaseExportOrderResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDatabaseExportOrderResponseBody) SetCreateOrderResult(v *CreateDatabaseExportOrderResponseBodyCreateOrderResult) *CreateDatabaseExportOrderResponseBody {
	s.CreateOrderResult = v
	return s
}

func (s *CreateDatabaseExportOrderResponseBody) SetErrorCode(v string) *CreateDatabaseExportOrderResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateDatabaseExportOrderResponseBody) SetErrorMessage(v string) *CreateDatabaseExportOrderResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateDatabaseExportOrderResponseBody) SetRequestId(v string) *CreateDatabaseExportOrderResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDatabaseExportOrderResponseBody) SetSuccess(v bool) *CreateDatabaseExportOrderResponseBody {
	s.Success = &v
	return s
}

type CreateDatabaseExportOrderResponseBodyCreateOrderResult struct {
	CreateOrderResult []*int64 `json:"CreateOrderResult,omitempty" xml:"CreateOrderResult,omitempty" type:"Repeated"`
}

func (s CreateDatabaseExportOrderResponseBodyCreateOrderResult) String() string {
	return tea.Prettify(s)
}

func (s CreateDatabaseExportOrderResponseBodyCreateOrderResult) GoString() string {
	return s.String()
}

func (s *CreateDatabaseExportOrderResponseBodyCreateOrderResult) SetCreateOrderResult(v []*int64) *CreateDatabaseExportOrderResponseBodyCreateOrderResult {
	s.CreateOrderResult = v
	return s
}

type CreateDatabaseExportOrderResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDatabaseExportOrderResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDatabaseExportOrderResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDatabaseExportOrderResponse) GoString() string {
	return s.String()
}

func (s *CreateDatabaseExportOrderResponse) SetHeaders(v map[string]*string) *CreateDatabaseExportOrderResponse {
	s.Headers = v
	return s
}

func (s *CreateDatabaseExportOrderResponse) SetStatusCode(v int32) *CreateDatabaseExportOrderResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDatabaseExportOrderResponse) SetBody(v *CreateDatabaseExportOrderResponseBody) *CreateDatabaseExportOrderResponse {
	s.Body = v
	return s
}

type CreateFreeLockCorrectOrderRequest struct {
	// The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key from the value of the AttachmentKey parameter.
	AttachmentKey *string `json:"AttachmentKey,omitempty" xml:"AttachmentKey,omitempty"`
	// The purpose or objective of the data change. This parameter is used to help reduce unnecessary communication.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The parameters of the ticket.
	Param *CreateFreeLockCorrectOrderRequestParam `json:"Param,omitempty" xml:"Param,omitempty" type:"Struct"`
	// The stakeholders of the data change. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
	RelatedUserList []*int64 `json:"RelatedUserList,omitempty" xml:"RelatedUserList,omitempty" type:"Repeated"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateFreeLockCorrectOrderRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateFreeLockCorrectOrderRequest) GoString() string {
	return s.String()
}

func (s *CreateFreeLockCorrectOrderRequest) SetAttachmentKey(v string) *CreateFreeLockCorrectOrderRequest {
	s.AttachmentKey = &v
	return s
}

func (s *CreateFreeLockCorrectOrderRequest) SetComment(v string) *CreateFreeLockCorrectOrderRequest {
	s.Comment = &v
	return s
}

func (s *CreateFreeLockCorrectOrderRequest) SetParam(v *CreateFreeLockCorrectOrderRequestParam) *CreateFreeLockCorrectOrderRequest {
	s.Param = v
	return s
}

func (s *CreateFreeLockCorrectOrderRequest) SetRelatedUserList(v []*int64) *CreateFreeLockCorrectOrderRequest {
	s.RelatedUserList = v
	return s
}

func (s *CreateFreeLockCorrectOrderRequest) SetTid(v int64) *CreateFreeLockCorrectOrderRequest {
	s.Tid = &v
	return s
}

type CreateFreeLockCorrectOrderRequestParam struct {
	// The key of the attachment that contains the SQL statements used to change data. This parameter is not supported.
	AttachmentName *string `json:"AttachmentName,omitempty" xml:"AttachmentName,omitempty"`
	// The reason for the data change.
	Classify *string `json:"Classify,omitempty" xml:"Classify,omitempty"`
	// The databases in which you want to change data.
	DbItemList []*CreateFreeLockCorrectOrderRequestParamDbItemList `json:"DbItemList,omitempty" xml:"DbItemList,omitempty" type:"Repeated"`
	// The execution mode of the ticket after the ticket is approved. Valid values:
	//
	// *   **COMMITOR**: The data change is performed by the user who submits the ticket.
	// *   **AUTO**: The data change is automatically performed after the ticket is approved.
	// *   **LAST_AUDITOR**: The data change is performed by the last approver of the ticket.
	ExecMode *string `json:"ExecMode,omitempty" xml:"ExecMode,omitempty"`
	// The SQL statements that you want to execute to change data.
	ExecSQL *string `json:"ExecSQL,omitempty" xml:"ExecSQL,omitempty"`
	// The key of the attachment that contains the SQL statements used to roll back the data change.
	RollbackAttachmentName *string `json:"RollbackAttachmentName,omitempty" xml:"RollbackAttachmentName,omitempty"`
	// The SQL statements used to roll back the data change.
	RollbackSQL *string `json:"RollbackSQL,omitempty" xml:"RollbackSQL,omitempty"`
	// The format of the SQL statements used to roll back the data change. Valid values:
	//
	// *   **TEXT**: text
	// *   **ATTACHMENT**: attachment. This value is not supported.
	RollbackSqlType *string `json:"RollbackSqlType,omitempty" xml:"RollbackSqlType,omitempty"`
	// The format of the SQL statements used to change data. Valid values:
	//
	// *   **TEXT**: text
	// *   **ATTACHMENT**: attachment. This value is not supported.
	SqlType *string `json:"SqlType,omitempty" xml:"SqlType,omitempty"`
}

func (s CreateFreeLockCorrectOrderRequestParam) String() string {
	return tea.Prettify(s)
}

func (s CreateFreeLockCorrectOrderRequestParam) GoString() string {
	return s.String()
}

func (s *CreateFreeLockCorrectOrderRequestParam) SetAttachmentName(v string) *CreateFreeLockCorrectOrderRequestParam {
	s.AttachmentName = &v
	return s
}

func (s *CreateFreeLockCorrectOrderRequestParam) SetClassify(v string) *CreateFreeLockCorrectOrderRequestParam {
	s.Classify = &v
	return s
}

func (s *CreateFreeLockCorrectOrderRequestParam) SetDbItemList(v []*CreateFreeLockCorrectOrderRequestParamDbItemList) *CreateFreeLockCorrectOrderRequestParam {
	s.DbItemList = v
	return s
}

func (s *CreateFreeLockCorrectOrderRequestParam) SetExecMode(v string) *CreateFreeLockCorrectOrderRequestParam {
	s.ExecMode = &v
	return s
}

func (s *CreateFreeLockCorrectOrderRequestParam) SetExecSQL(v string) *CreateFreeLockCorrectOrderRequestParam {
	s.ExecSQL = &v
	return s
}

func (s *CreateFreeLockCorrectOrderRequestParam) SetRollbackAttachmentName(v string) *CreateFreeLockCorrectOrderRequestParam {
	s.RollbackAttachmentName = &v
	return s
}

func (s *CreateFreeLockCorrectOrderRequestParam) SetRollbackSQL(v string) *CreateFreeLockCorrectOrderRequestParam {
	s.RollbackSQL = &v
	return s
}

func (s *CreateFreeLockCorrectOrderRequestParam) SetRollbackSqlType(v string) *CreateFreeLockCorrectOrderRequestParam {
	s.RollbackSqlType = &v
	return s
}

func (s *CreateFreeLockCorrectOrderRequestParam) SetSqlType(v string) *CreateFreeLockCorrectOrderRequestParam {
	s.SqlType = &v
	return s
}

type CreateFreeLockCorrectOrderRequestParamDbItemList struct {
	// The ID of the database. The database can be a physical database or a logical database.
	//
	// *   To obtain the ID of a physical database, call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation.
	// *   To obtain the ID of a logical database, call the [ListLogicDatabases](~~141874~~) or [SearchDatabase](~~141876~~) operation.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// Specifies whether the database is a logical database. Valid values:
	//
	// *   **true**: The database is a logical database.
	// *   **false**: The database is a physical database.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
}

func (s CreateFreeLockCorrectOrderRequestParamDbItemList) String() string {
	return tea.Prettify(s)
}

func (s CreateFreeLockCorrectOrderRequestParamDbItemList) GoString() string {
	return s.String()
}

func (s *CreateFreeLockCorrectOrderRequestParamDbItemList) SetDbId(v int64) *CreateFreeLockCorrectOrderRequestParamDbItemList {
	s.DbId = &v
	return s
}

func (s *CreateFreeLockCorrectOrderRequestParamDbItemList) SetLogic(v bool) *CreateFreeLockCorrectOrderRequestParamDbItemList {
	s.Logic = &v
	return s
}

type CreateFreeLockCorrectOrderShrinkRequest struct {
	// The key of the attachment that provides more instructions for the ticket. You can call the [GetUserUploadFileJob](~~206069~~) operation to obtain the attachment key from the value of the AttachmentKey parameter.
	AttachmentKey *string `json:"AttachmentKey,omitempty" xml:"AttachmentKey,omitempty"`
	// The purpose or objective of the data change. This parameter is used to help reduce unnecessary communication.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The parameters of the ticket.
	ParamShrink *string `json:"Param,omitempty" xml:"Param,omitempty"`
	// The stakeholders of the data change. All stakeholders can view the ticket details and assist in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
	RelatedUserListShrink *string `json:"RelatedUserList,omitempty" xml:"RelatedUserList,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateFreeLockCorrectOrderShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateFreeLockCorrectOrderShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateFreeLockCorrectOrderShrinkRequest) SetAttachmentKey(v string) *CreateFreeLockCorrectOrderShrinkRequest {
	s.AttachmentKey = &v
	return s
}

func (s *CreateFreeLockCorrectOrderShrinkRequest) SetComment(v string) *CreateFreeLockCorrectOrderShrinkRequest {
	s.Comment = &v
	return s
}

func (s *CreateFreeLockCorrectOrderShrinkRequest) SetParamShrink(v string) *CreateFreeLockCorrectOrderShrinkRequest {
	s.ParamShrink = &v
	return s
}

func (s *CreateFreeLockCorrectOrderShrinkRequest) SetRelatedUserListShrink(v string) *CreateFreeLockCorrectOrderShrinkRequest {
	s.RelatedUserListShrink = &v
	return s
}

func (s *CreateFreeLockCorrectOrderShrinkRequest) SetTid(v int64) *CreateFreeLockCorrectOrderShrinkRequest {
	s.Tid = &v
	return s
}

type CreateFreeLockCorrectOrderResponseBody struct {
	// The ID of the ticket.
	CreateOrderResult []*int64 `json:"CreateOrderResult,omitempty" xml:"CreateOrderResult,omitempty" type:"Repeated"`
	// The error code returned if the request fails.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**: The request is successful.
	// *   **false**: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateFreeLockCorrectOrderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateFreeLockCorrectOrderResponseBody) GoString() string {
	return s.String()
}

func (s *CreateFreeLockCorrectOrderResponseBody) SetCreateOrderResult(v []*int64) *CreateFreeLockCorrectOrderResponseBody {
	s.CreateOrderResult = v
	return s
}

func (s *CreateFreeLockCorrectOrderResponseBody) SetErrorCode(v string) *CreateFreeLockCorrectOrderResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateFreeLockCorrectOrderResponseBody) SetErrorMessage(v string) *CreateFreeLockCorrectOrderResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateFreeLockCorrectOrderResponseBody) SetRequestId(v string) *CreateFreeLockCorrectOrderResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateFreeLockCorrectOrderResponseBody) SetSuccess(v bool) *CreateFreeLockCorrectOrderResponseBody {
	s.Success = &v
	return s
}

type CreateFreeLockCorrectOrderResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateFreeLockCorrectOrderResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateFreeLockCorrectOrderResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateFreeLockCorrectOrderResponse) GoString() string {
	return s.String()
}

func (s *CreateFreeLockCorrectOrderResponse) SetHeaders(v map[string]*string) *CreateFreeLockCorrectOrderResponse {
	s.Headers = v
	return s
}

func (s *CreateFreeLockCorrectOrderResponse) SetStatusCode(v int32) *CreateFreeLockCorrectOrderResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateFreeLockCorrectOrderResponse) SetBody(v *CreateFreeLockCorrectOrderResponseBody) *CreateFreeLockCorrectOrderResponse {
	s.Body = v
	return s
}

type CreateLakeHouseSpaceRequest struct {
	// The description of the workspace.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the development database. You can call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation to obtain the ID.
	DevDbId *string `json:"DevDbId,omitempty" xml:"DevDbId,omitempty"`
	// The type of the database. Valid values:
	//
	// *   **14**: AnalyticDB for MySQL
	// *   **18**: AnalyticDB for PostgreSQL
	DwDbType *string `json:"DwDbType,omitempty" xml:"DwDbType,omitempty"`
	// The mode in which the workspace runs. Valid values:
	//
	// *   **0**: basic mode. This mode is unavailable.
	// *   **1**: standard mode.
	Mode *string `json:"Mode,omitempty" xml:"Mode,omitempty"`
	// The ID of the production database. You can call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation to obtain the ID.
	ProdDbId *string `json:"ProdDbId,omitempty" xml:"ProdDbId,omitempty"`
	// The configuration of the workspace. Valid values:
	//
	// *   **skipManualRunCheck**: No security rule check is required in the trial run phase.
	// *   **skipPublishApprove**: No approval is required for publishing and O\&M.
	SpaceConfig *string `json:"SpaceConfig,omitempty" xml:"SpaceConfig,omitempty"`
	// The name of the workspace.
	SpaceName *string `json:"SpaceName,omitempty" xml:"SpaceName,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateLakeHouseSpaceRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateLakeHouseSpaceRequest) GoString() string {
	return s.String()
}

func (s *CreateLakeHouseSpaceRequest) SetDescription(v string) *CreateLakeHouseSpaceRequest {
	s.Description = &v
	return s
}

func (s *CreateLakeHouseSpaceRequest) SetDevDbId(v string) *CreateLakeHouseSpaceRequest {
	s.DevDbId = &v
	return s
}

func (s *CreateLakeHouseSpaceRequest) SetDwDbType(v string) *CreateLakeHouseSpaceRequest {
	s.DwDbType = &v
	return s
}

func (s *CreateLakeHouseSpaceRequest) SetMode(v string) *CreateLakeHouseSpaceRequest {
	s.Mode = &v
	return s
}

func (s *CreateLakeHouseSpaceRequest) SetProdDbId(v string) *CreateLakeHouseSpaceRequest {
	s.ProdDbId = &v
	return s
}

func (s *CreateLakeHouseSpaceRequest) SetSpaceConfig(v string) *CreateLakeHouseSpaceRequest {
	s.SpaceConfig = &v
	return s
}

func (s *CreateLakeHouseSpaceRequest) SetSpaceName(v string) *CreateLakeHouseSpaceRequest {
	s.SpaceName = &v
	return s
}

func (s *CreateLakeHouseSpaceRequest) SetTid(v int64) *CreateLakeHouseSpaceRequest {
	s.Tid = &v
	return s
}

type CreateLakeHouseSpaceResponseBody struct {
	// The error code returned if the request fails.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the workspace.
	SpaceId *int64 `json:"SpaceId,omitempty" xml:"SpaceId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**: The request is successful.
	// *   **false**: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateLakeHouseSpaceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateLakeHouseSpaceResponseBody) GoString() string {
	return s.String()
}

func (s *CreateLakeHouseSpaceResponseBody) SetErrorCode(v string) *CreateLakeHouseSpaceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateLakeHouseSpaceResponseBody) SetErrorMessage(v string) *CreateLakeHouseSpaceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateLakeHouseSpaceResponseBody) SetRequestId(v string) *CreateLakeHouseSpaceResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateLakeHouseSpaceResponseBody) SetSpaceId(v int64) *CreateLakeHouseSpaceResponseBody {
	s.SpaceId = &v
	return s
}

func (s *CreateLakeHouseSpaceResponseBody) SetSuccess(v bool) *CreateLakeHouseSpaceResponseBody {
	s.Success = &v
	return s
}

type CreateLakeHouseSpaceResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateLakeHouseSpaceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateLakeHouseSpaceResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateLakeHouseSpaceResponse) GoString() string {
	return s.String()
}

func (s *CreateLakeHouseSpaceResponse) SetHeaders(v map[string]*string) *CreateLakeHouseSpaceResponse {
	s.Headers = v
	return s
}

func (s *CreateLakeHouseSpaceResponse) SetStatusCode(v int32) *CreateLakeHouseSpaceResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateLakeHouseSpaceResponse) SetBody(v *CreateLakeHouseSpaceResponseBody) *CreateLakeHouseSpaceResponse {
	s.Body = v
	return s
}

type CreateLogicDatabaseRequest struct {
	// The alias of the logical database.
	Alias *string `json:"Alias,omitempty" xml:"Alias,omitempty"`
	// The IDs of the physical databases that compose the logical database. You can specify one or more database IDs. You can call the [ListDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listdatabases) or [SearchDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/searchdatabase) operation to query the IDs of the physical databases.
	DatabaseIds []*int64 `json:"DatabaseIds,omitempty" xml:"DatabaseIds,omitempty" type:"Repeated"`
	// The ID of the tenant.
	//
	// >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://www.alibabacloud.com/help/en/data-management-service/latest/manage-dms-tenants) topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateLogicDatabaseRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateLogicDatabaseRequest) GoString() string {
	return s.String()
}

func (s *CreateLogicDatabaseRequest) SetAlias(v string) *CreateLogicDatabaseRequest {
	s.Alias = &v
	return s
}

func (s *CreateLogicDatabaseRequest) SetDatabaseIds(v []*int64) *CreateLogicDatabaseRequest {
	s.DatabaseIds = v
	return s
}

func (s *CreateLogicDatabaseRequest) SetTid(v int64) *CreateLogicDatabaseRequest {
	s.Tid = &v
	return s
}

type CreateLogicDatabaseShrinkRequest struct {
	// The alias of the logical database.
	Alias *string `json:"Alias,omitempty" xml:"Alias,omitempty"`
	// The IDs of the physical databases that compose the logical database. You can specify one or more database IDs. You can call the [ListDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listdatabases) or [SearchDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/searchdatabase) operation to query the IDs of the physical databases.
	DatabaseIdsShrink *string `json:"DatabaseIds,omitempty" xml:"DatabaseIds,omitempty"`
	// The ID of the tenant.
	//
	// >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://www.alibabacloud.com/help/en/data-management-service/latest/manage-dms-tenants) topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateLogicDatabaseShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateLogicDatabaseShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateLogicDatabaseShrinkRequest) SetAlias(v string) *CreateLogicDatabaseShrinkRequest {
	s.Alias = &v
	return s
}

func (s *CreateLogicDatabaseShrinkRequest) SetDatabaseIdsShrink(v string) *CreateLogicDatabaseShrinkRequest {
	s.DatabaseIdsShrink = &v
	return s
}

func (s *CreateLogicDatabaseShrinkRequest) SetTid(v int64) *CreateLogicDatabaseShrinkRequest {
	s.Tid = &v
	return s
}

type CreateLogicDatabaseResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the logical database.
	LogicDbId *int64 `json:"LogicDbId,omitempty" xml:"LogicDbId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// - true: The request is successful.
	// - false: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateLogicDatabaseResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateLogicDatabaseResponseBody) GoString() string {
	return s.String()
}

func (s *CreateLogicDatabaseResponseBody) SetErrorCode(v string) *CreateLogicDatabaseResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateLogicDatabaseResponseBody) SetErrorMessage(v string) *CreateLogicDatabaseResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateLogicDatabaseResponseBody) SetLogicDbId(v int64) *CreateLogicDatabaseResponseBody {
	s.LogicDbId = &v
	return s
}

func (s *CreateLogicDatabaseResponseBody) SetRequestId(v string) *CreateLogicDatabaseResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateLogicDatabaseResponseBody) SetSuccess(v bool) *CreateLogicDatabaseResponseBody {
	s.Success = &v
	return s
}

type CreateLogicDatabaseResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateLogicDatabaseResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateLogicDatabaseResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateLogicDatabaseResponse) GoString() string {
	return s.String()
}

func (s *CreateLogicDatabaseResponse) SetHeaders(v map[string]*string) *CreateLogicDatabaseResponse {
	s.Headers = v
	return s
}

func (s *CreateLogicDatabaseResponse) SetStatusCode(v int32) *CreateLogicDatabaseResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateLogicDatabaseResponse) SetBody(v *CreateLogicDatabaseResponseBody) *CreateLogicDatabaseResponse {
	s.Body = v
	return s
}

type CreateOrderRequest struct {
	// The key of an attachment that is returned after the attachment is uploaded. You can call the [GetUserUploadFileJob](~~206069~~) operation to query the key of the attachment.
	AttachmentKey *string `json:"AttachmentKey,omitempty" xml:"AttachmentKey,omitempty"`
	// The description of the ticket to be created.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The ticket creation parameter. The value is a JSON string. The value of this parameter differs based on the type of the ticket. For more information, see the **PluginParam parameter** section in this topic.
	PluginParam map[string]interface{} `json:"PluginParam,omitempty" xml:"PluginParam,omitempty"`
	// The type of the ticket. For more information, see [PluginType parameter](~~429109~~).
	PluginType *string `json:"PluginType,omitempty" xml:"PluginType,omitempty"`
	// The IDs of the stakeholders that are involved in the ticket. Separate multiple IDs with commas (,).
	RelatedUserList *string `json:"RelatedUserList,omitempty" xml:"RelatedUserList,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateOrderRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateOrderRequest) GoString() string {
	return s.String()
}

func (s *CreateOrderRequest) SetAttachmentKey(v string) *CreateOrderRequest {
	s.AttachmentKey = &v
	return s
}

func (s *CreateOrderRequest) SetComment(v string) *CreateOrderRequest {
	s.Comment = &v
	return s
}

func (s *CreateOrderRequest) SetPluginParam(v map[string]interface{}) *CreateOrderRequest {
	s.PluginParam = v
	return s
}

func (s *CreateOrderRequest) SetPluginType(v string) *CreateOrderRequest {
	s.PluginType = &v
	return s
}

func (s *CreateOrderRequest) SetRelatedUserList(v string) *CreateOrderRequest {
	s.RelatedUserList = &v
	return s
}

func (s *CreateOrderRequest) SetTid(v int64) *CreateOrderRequest {
	s.Tid = &v
	return s
}

type CreateOrderShrinkRequest struct {
	// The key of an attachment that is returned after the attachment is uploaded. You can call the [GetUserUploadFileJob](~~206069~~) operation to query the key of the attachment.
	AttachmentKey *string `json:"AttachmentKey,omitempty" xml:"AttachmentKey,omitempty"`
	// The description of the ticket to be created.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The ticket creation parameter. The value is a JSON string. The value of this parameter differs based on the type of the ticket. For more information, see the **PluginParam parameter** section in this topic.
	PluginParamShrink *string `json:"PluginParam,omitempty" xml:"PluginParam,omitempty"`
	// The type of the ticket. For more information, see [PluginType parameter](~~429109~~).
	PluginType *string `json:"PluginType,omitempty" xml:"PluginType,omitempty"`
	// The IDs of the stakeholders that are involved in the ticket. Separate multiple IDs with commas (,).
	RelatedUserList *string `json:"RelatedUserList,omitempty" xml:"RelatedUserList,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateOrderShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateOrderShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateOrderShrinkRequest) SetAttachmentKey(v string) *CreateOrderShrinkRequest {
	s.AttachmentKey = &v
	return s
}

func (s *CreateOrderShrinkRequest) SetComment(v string) *CreateOrderShrinkRequest {
	s.Comment = &v
	return s
}

func (s *CreateOrderShrinkRequest) SetPluginParamShrink(v string) *CreateOrderShrinkRequest {
	s.PluginParamShrink = &v
	return s
}

func (s *CreateOrderShrinkRequest) SetPluginType(v string) *CreateOrderShrinkRequest {
	s.PluginType = &v
	return s
}

func (s *CreateOrderShrinkRequest) SetRelatedUserList(v string) *CreateOrderShrinkRequest {
	s.RelatedUserList = &v
	return s
}

func (s *CreateOrderShrinkRequest) SetTid(v int64) *CreateOrderShrinkRequest {
	s.Tid = &v
	return s
}

type CreateOrderResponseBody struct {
	// The ID of the ticket.
	CreateOrderResult *CreateOrderResponseBodyCreateOrderResult `json:"CreateOrderResult,omitempty" xml:"CreateOrderResult,omitempty" type:"Struct"`
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateOrderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateOrderResponseBody) GoString() string {
	return s.String()
}

func (s *CreateOrderResponseBody) SetCreateOrderResult(v *CreateOrderResponseBodyCreateOrderResult) *CreateOrderResponseBody {
	s.CreateOrderResult = v
	return s
}

func (s *CreateOrderResponseBody) SetErrorCode(v string) *CreateOrderResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateOrderResponseBody) SetErrorMessage(v string) *CreateOrderResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateOrderResponseBody) SetRequestId(v string) *CreateOrderResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateOrderResponseBody) SetSuccess(v bool) *CreateOrderResponseBody {
	s.Success = &v
	return s
}

type CreateOrderResponseBodyCreateOrderResult struct {
	OrderIds []*int64 `json:"OrderIds,omitempty" xml:"OrderIds,omitempty" type:"Repeated"`
}

func (s CreateOrderResponseBodyCreateOrderResult) String() string {
	return tea.Prettify(s)
}

func (s CreateOrderResponseBodyCreateOrderResult) GoString() string {
	return s.String()
}

func (s *CreateOrderResponseBodyCreateOrderResult) SetOrderIds(v []*int64) *CreateOrderResponseBodyCreateOrderResult {
	s.OrderIds = v
	return s
}

type CreateOrderResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateOrderResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateOrderResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateOrderResponse) GoString() string {
	return s.String()
}

func (s *CreateOrderResponse) SetHeaders(v map[string]*string) *CreateOrderResponse {
	s.Headers = v
	return s
}

func (s *CreateOrderResponse) SetStatusCode(v int32) *CreateOrderResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateOrderResponse) SetBody(v *CreateOrderResponseBody) *CreateOrderResponse {
	s.Body = v
	return s
}

type CreateProcCorrectOrderRequest struct {
	AttachmentKey   *string                             `json:"AttachmentKey,omitempty" xml:"AttachmentKey,omitempty"`
	Comment         *string                             `json:"Comment,omitempty" xml:"Comment,omitempty"`
	Param           *CreateProcCorrectOrderRequestParam `json:"Param,omitempty" xml:"Param,omitempty" type:"Struct"`
	RelatedUserList []*int64                            `json:"RelatedUserList,omitempty" xml:"RelatedUserList,omitempty" type:"Repeated"`
	Tid             *int64                              `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateProcCorrectOrderRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateProcCorrectOrderRequest) GoString() string {
	return s.String()
}

func (s *CreateProcCorrectOrderRequest) SetAttachmentKey(v string) *CreateProcCorrectOrderRequest {
	s.AttachmentKey = &v
	return s
}

func (s *CreateProcCorrectOrderRequest) SetComment(v string) *CreateProcCorrectOrderRequest {
	s.Comment = &v
	return s
}

func (s *CreateProcCorrectOrderRequest) SetParam(v *CreateProcCorrectOrderRequestParam) *CreateProcCorrectOrderRequest {
	s.Param = v
	return s
}

func (s *CreateProcCorrectOrderRequest) SetRelatedUserList(v []*int64) *CreateProcCorrectOrderRequest {
	s.RelatedUserList = v
	return s
}

func (s *CreateProcCorrectOrderRequest) SetTid(v int64) *CreateProcCorrectOrderRequest {
	s.Tid = &v
	return s
}

type CreateProcCorrectOrderRequestParam struct {
	Classify               *string                                         `json:"Classify,omitempty" xml:"Classify,omitempty"`
	DbItemList             []*CreateProcCorrectOrderRequestParamDbItemList `json:"DbItemList,omitempty" xml:"DbItemList,omitempty" type:"Repeated"`
	ExecMode               *string                                         `json:"ExecMode,omitempty" xml:"ExecMode,omitempty"`
	ExecSQL                *string                                         `json:"ExecSQL,omitempty" xml:"ExecSQL,omitempty"`
	RollbackAttachmentName *string                                         `json:"RollbackAttachmentName,omitempty" xml:"RollbackAttachmentName,omitempty"`
	RollbackSQL            *string                                         `json:"RollbackSQL,omitempty" xml:"RollbackSQL,omitempty"`
	RollbackSqlType        *string                                         `json:"RollbackSqlType,omitempty" xml:"RollbackSqlType,omitempty"`
}

func (s CreateProcCorrectOrderRequestParam) String() string {
	return tea.Prettify(s)
}

func (s CreateProcCorrectOrderRequestParam) GoString() string {
	return s.String()
}

func (s *CreateProcCorrectOrderRequestParam) SetClassify(v string) *CreateProcCorrectOrderRequestParam {
	s.Classify = &v
	return s
}

func (s *CreateProcCorrectOrderRequestParam) SetDbItemList(v []*CreateProcCorrectOrderRequestParamDbItemList) *CreateProcCorrectOrderRequestParam {
	s.DbItemList = v
	return s
}

func (s *CreateProcCorrectOrderRequestParam) SetExecMode(v string) *CreateProcCorrectOrderRequestParam {
	s.ExecMode = &v
	return s
}

func (s *CreateProcCorrectOrderRequestParam) SetExecSQL(v string) *CreateProcCorrectOrderRequestParam {
	s.ExecSQL = &v
	return s
}

func (s *CreateProcCorrectOrderRequestParam) SetRollbackAttachmentName(v string) *CreateProcCorrectOrderRequestParam {
	s.RollbackAttachmentName = &v
	return s
}

func (s *CreateProcCorrectOrderRequestParam) SetRollbackSQL(v string) *CreateProcCorrectOrderRequestParam {
	s.RollbackSQL = &v
	return s
}

func (s *CreateProcCorrectOrderRequestParam) SetRollbackSqlType(v string) *CreateProcCorrectOrderRequestParam {
	s.RollbackSqlType = &v
	return s
}

type CreateProcCorrectOrderRequestParamDbItemList struct {
	DbId  *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	Logic *bool  `json:"Logic,omitempty" xml:"Logic,omitempty"`
}

func (s CreateProcCorrectOrderRequestParamDbItemList) String() string {
	return tea.Prettify(s)
}

func (s CreateProcCorrectOrderRequestParamDbItemList) GoString() string {
	return s.String()
}

func (s *CreateProcCorrectOrderRequestParamDbItemList) SetDbId(v int64) *CreateProcCorrectOrderRequestParamDbItemList {
	s.DbId = &v
	return s
}

func (s *CreateProcCorrectOrderRequestParamDbItemList) SetLogic(v bool) *CreateProcCorrectOrderRequestParamDbItemList {
	s.Logic = &v
	return s
}

type CreateProcCorrectOrderShrinkRequest struct {
	AttachmentKey         *string `json:"AttachmentKey,omitempty" xml:"AttachmentKey,omitempty"`
	Comment               *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	ParamShrink           *string `json:"Param,omitempty" xml:"Param,omitempty"`
	RelatedUserListShrink *string `json:"RelatedUserList,omitempty" xml:"RelatedUserList,omitempty"`
	Tid                   *int64  `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateProcCorrectOrderShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateProcCorrectOrderShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateProcCorrectOrderShrinkRequest) SetAttachmentKey(v string) *CreateProcCorrectOrderShrinkRequest {
	s.AttachmentKey = &v
	return s
}

func (s *CreateProcCorrectOrderShrinkRequest) SetComment(v string) *CreateProcCorrectOrderShrinkRequest {
	s.Comment = &v
	return s
}

func (s *CreateProcCorrectOrderShrinkRequest) SetParamShrink(v string) *CreateProcCorrectOrderShrinkRequest {
	s.ParamShrink = &v
	return s
}

func (s *CreateProcCorrectOrderShrinkRequest) SetRelatedUserListShrink(v string) *CreateProcCorrectOrderShrinkRequest {
	s.RelatedUserListShrink = &v
	return s
}

func (s *CreateProcCorrectOrderShrinkRequest) SetTid(v int64) *CreateProcCorrectOrderShrinkRequest {
	s.Tid = &v
	return s
}

type CreateProcCorrectOrderResponseBody struct {
	CreateOrderResult []*int64 `json:"CreateOrderResult,omitempty" xml:"CreateOrderResult,omitempty" type:"Repeated"`
	ErrorCode         *string  `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage      *string  `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId         *string  `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success           *bool    `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateProcCorrectOrderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateProcCorrectOrderResponseBody) GoString() string {
	return s.String()
}

func (s *CreateProcCorrectOrderResponseBody) SetCreateOrderResult(v []*int64) *CreateProcCorrectOrderResponseBody {
	s.CreateOrderResult = v
	return s
}

func (s *CreateProcCorrectOrderResponseBody) SetErrorCode(v string) *CreateProcCorrectOrderResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateProcCorrectOrderResponseBody) SetErrorMessage(v string) *CreateProcCorrectOrderResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateProcCorrectOrderResponseBody) SetRequestId(v string) *CreateProcCorrectOrderResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateProcCorrectOrderResponseBody) SetSuccess(v bool) *CreateProcCorrectOrderResponseBody {
	s.Success = &v
	return s
}

type CreateProcCorrectOrderResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateProcCorrectOrderResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateProcCorrectOrderResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateProcCorrectOrderResponse) GoString() string {
	return s.String()
}

func (s *CreateProcCorrectOrderResponse) SetHeaders(v map[string]*string) *CreateProcCorrectOrderResponse {
	s.Headers = v
	return s
}

func (s *CreateProcCorrectOrderResponse) SetStatusCode(v int32) *CreateProcCorrectOrderResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateProcCorrectOrderResponse) SetBody(v *CreateProcCorrectOrderResponseBody) *CreateProcCorrectOrderResponse {
	s.Body = v
	return s
}

type CreateProxyRequest struct {
	// The ID of the database instance. You can call the [ListInstances](https://www.alibabacloud.com/help/en/data-management-service/latest/listinstances) or [GetInstance](https://www.alibabacloud.com/help/en/data-management-service/latest/getinstance) operation to query the database instance ID.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The password of the database account.
	Password *string `json:"Password,omitempty" xml:"Password,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The username of the database account.
	Username *string `json:"Username,omitempty" xml:"Username,omitempty"`
}

func (s CreateProxyRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateProxyRequest) GoString() string {
	return s.String()
}

func (s *CreateProxyRequest) SetInstanceId(v int64) *CreateProxyRequest {
	s.InstanceId = &v
	return s
}

func (s *CreateProxyRequest) SetPassword(v string) *CreateProxyRequest {
	s.Password = &v
	return s
}

func (s *CreateProxyRequest) SetTid(v int64) *CreateProxyRequest {
	s.Tid = &v
	return s
}

func (s *CreateProxyRequest) SetUsername(v string) *CreateProxyRequest {
	s.Username = &v
	return s
}

type CreateProxyResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the secure access proxy.
	ProxyId *int64 `json:"ProxyId,omitempty" xml:"ProxyId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// - **true**: The request was successful.
	// - **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateProxyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateProxyResponseBody) GoString() string {
	return s.String()
}

func (s *CreateProxyResponseBody) SetErrorCode(v string) *CreateProxyResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateProxyResponseBody) SetErrorMessage(v string) *CreateProxyResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateProxyResponseBody) SetProxyId(v int64) *CreateProxyResponseBody {
	s.ProxyId = &v
	return s
}

func (s *CreateProxyResponseBody) SetRequestId(v string) *CreateProxyResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateProxyResponseBody) SetSuccess(v bool) *CreateProxyResponseBody {
	s.Success = &v
	return s
}

type CreateProxyResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateProxyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateProxyResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateProxyResponse) GoString() string {
	return s.String()
}

func (s *CreateProxyResponse) SetHeaders(v map[string]*string) *CreateProxyResponse {
	s.Headers = v
	return s
}

func (s *CreateProxyResponse) SetStatusCode(v int32) *CreateProxyResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateProxyResponse) SetBody(v *CreateProxyResponseBody) *CreateProxyResponse {
	s.Body = v
	return s
}

type CreateProxyAccessRequest struct {
	// The database account.
	IndepAccount *string `json:"IndepAccount,omitempty" xml:"IndepAccount,omitempty"`
	// The password that is used to log on to the database.
	IndepPassword *string `json:"IndepPassword,omitempty" xml:"IndepPassword,omitempty"`
	// The ID of the security protection agent. You can call the [ListProxies](https://www.alibabacloud.com/help/en/data-management-service/latest/listproxies) or [GetProxy](https://www.alibabacloud.com/help/en/data-management-service/latest/getproxy) operation to obtain this parameter.
	ProxyId *int64 `json:"ProxyId,omitempty" xml:"ProxyId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) or [ListUserTenants](https://www.alibabacloud.com/help/en/data-management-service/latest/listusertenants) operation to obtain this parameter.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The ID of the user. You can call the [ListUsers](https://www.alibabacloud.com/help/en/data-management-service/latest/listusers) or [GetUser](https://www.alibabacloud.com/help/en/data-management-service/latest/getuser) operation to obtain this parameter.
	UserId *int64 `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s CreateProxyAccessRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateProxyAccessRequest) GoString() string {
	return s.String()
}

func (s *CreateProxyAccessRequest) SetIndepAccount(v string) *CreateProxyAccessRequest {
	s.IndepAccount = &v
	return s
}

func (s *CreateProxyAccessRequest) SetIndepPassword(v string) *CreateProxyAccessRequest {
	s.IndepPassword = &v
	return s
}

func (s *CreateProxyAccessRequest) SetProxyId(v int64) *CreateProxyAccessRequest {
	s.ProxyId = &v
	return s
}

func (s *CreateProxyAccessRequest) SetTid(v int64) *CreateProxyAccessRequest {
	s.Tid = &v
	return s
}

func (s *CreateProxyAccessRequest) SetUserId(v int64) *CreateProxyAccessRequest {
	s.UserId = &v
	return s
}

type CreateProxyAccessResponseBody struct {
	// The error code returned to the query task.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message that is returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the security protection authorization. After the security protection agent authorizes the target user, the system automatically generates a security protection authorization ID. The ID is globally unique.
	ProxyAccessId *int64 `json:"ProxyAccessId,omitempty" xml:"ProxyAccessId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateProxyAccessResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateProxyAccessResponseBody) GoString() string {
	return s.String()
}

func (s *CreateProxyAccessResponseBody) SetErrorCode(v string) *CreateProxyAccessResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateProxyAccessResponseBody) SetErrorMessage(v string) *CreateProxyAccessResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateProxyAccessResponseBody) SetProxyAccessId(v int64) *CreateProxyAccessResponseBody {
	s.ProxyAccessId = &v
	return s
}

func (s *CreateProxyAccessResponseBody) SetRequestId(v string) *CreateProxyAccessResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateProxyAccessResponseBody) SetSuccess(v bool) *CreateProxyAccessResponseBody {
	s.Success = &v
	return s
}

type CreateProxyAccessResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateProxyAccessResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateProxyAccessResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateProxyAccessResponse) GoString() string {
	return s.String()
}

func (s *CreateProxyAccessResponse) SetHeaders(v map[string]*string) *CreateProxyAccessResponse {
	s.Headers = v
	return s
}

func (s *CreateProxyAccessResponse) SetStatusCode(v int32) *CreateProxyAccessResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateProxyAccessResponse) SetBody(v *CreateProxyAccessResponseBody) *CreateProxyAccessResponse {
	s.Body = v
	return s
}

type CreatePublishGroupTaskRequest struct {
	// The ID of the database for which the schema design is executed.
	DbId *int32 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// Indicates whether the database is a logical database.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The ID of the ticket.
	//
	// > : You can create a schema design ticket in the DMS console. For more information, see [Design schemas](~~69711~~). You can also create a schema design ticket by calling the [CreateOrder](~~144649~~) operation and obtain the ticket ID.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The time to execute the schema design ticket.
	PlanTime *string `json:"PlanTime,omitempty" xml:"PlanTime,omitempty"`
	// The policy to execute the schema design ticket. Valid values:
	//
	// *   IMMEDIATELY: immediately executes the schema design ticket.
	// *   REGULARLY: executes the schema design ticket at a scheduled time.
	PublishStrategy *string `json:"PublishStrategy,omitempty" xml:"PublishStrategy,omitempty"`
	// The ID of the tenant.
	//
	// > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreatePublishGroupTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s CreatePublishGroupTaskRequest) GoString() string {
	return s.String()
}

func (s *CreatePublishGroupTaskRequest) SetDbId(v int32) *CreatePublishGroupTaskRequest {
	s.DbId = &v
	return s
}

func (s *CreatePublishGroupTaskRequest) SetLogic(v bool) *CreatePublishGroupTaskRequest {
	s.Logic = &v
	return s
}

func (s *CreatePublishGroupTaskRequest) SetOrderId(v int64) *CreatePublishGroupTaskRequest {
	s.OrderId = &v
	return s
}

func (s *CreatePublishGroupTaskRequest) SetPlanTime(v string) *CreatePublishGroupTaskRequest {
	s.PlanTime = &v
	return s
}

func (s *CreatePublishGroupTaskRequest) SetPublishStrategy(v string) *CreatePublishGroupTaskRequest {
	s.PublishStrategy = &v
	return s
}

func (s *CreatePublishGroupTaskRequest) SetTid(v int64) *CreatePublishGroupTaskRequest {
	s.Tid = &v
	return s
}

type CreatePublishGroupTaskResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The ID of the job.
	TaskId *int64 `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s CreatePublishGroupTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreatePublishGroupTaskResponseBody) GoString() string {
	return s.String()
}

func (s *CreatePublishGroupTaskResponseBody) SetErrorCode(v string) *CreatePublishGroupTaskResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreatePublishGroupTaskResponseBody) SetErrorMessage(v string) *CreatePublishGroupTaskResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreatePublishGroupTaskResponseBody) SetRequestId(v string) *CreatePublishGroupTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreatePublishGroupTaskResponseBody) SetSuccess(v bool) *CreatePublishGroupTaskResponseBody {
	s.Success = &v
	return s
}

func (s *CreatePublishGroupTaskResponseBody) SetTaskId(v int64) *CreatePublishGroupTaskResponseBody {
	s.TaskId = &v
	return s
}

type CreatePublishGroupTaskResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreatePublishGroupTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreatePublishGroupTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s CreatePublishGroupTaskResponse) GoString() string {
	return s.String()
}

func (s *CreatePublishGroupTaskResponse) SetHeaders(v map[string]*string) *CreatePublishGroupTaskResponse {
	s.Headers = v
	return s
}

func (s *CreatePublishGroupTaskResponse) SetStatusCode(v int32) *CreatePublishGroupTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *CreatePublishGroupTaskResponse) SetBody(v *CreatePublishGroupTaskResponseBody) *CreatePublishGroupTaskResponse {
	s.Body = v
	return s
}

type CreateSQLReviewOrderRequest struct {
	// The purpose or objective of the SQL review. This reduces unnecessary communication.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The parameters of the ticket.
	Param *CreateSQLReviewOrderRequestParam `json:"Param,omitempty" xml:"Param,omitempty" type:"Struct"`
	// The stakeholders involved in this operation. All the specified stakeholders can view the ticket details and take part in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
	RelatedUserList []*int64 `json:"RelatedUserList,omitempty" xml:"RelatedUserList,omitempty" type:"Repeated"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateSQLReviewOrderRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateSQLReviewOrderRequest) GoString() string {
	return s.String()
}

func (s *CreateSQLReviewOrderRequest) SetComment(v string) *CreateSQLReviewOrderRequest {
	s.Comment = &v
	return s
}

func (s *CreateSQLReviewOrderRequest) SetParam(v *CreateSQLReviewOrderRequestParam) *CreateSQLReviewOrderRequest {
	s.Param = v
	return s
}

func (s *CreateSQLReviewOrderRequest) SetRelatedUserList(v []*int64) *CreateSQLReviewOrderRequest {
	s.RelatedUserList = v
	return s
}

func (s *CreateSQLReviewOrderRequest) SetTid(v int64) *CreateSQLReviewOrderRequest {
	s.Tid = &v
	return s
}

type CreateSQLReviewOrderRequestParam struct {
	// The files to be reviewed. Multiple files can be reviewed at a time.
	AttachmentKeyList []*string `json:"AttachmentKeyList,omitempty" xml:"AttachmentKeyList,omitempty" type:"Repeated"`
	// The ID of the database. You can call the [SearchDatabases](~~141876~~) operation to query the ID of the database.
	//
	// >  You can call this operation to query only physical databases. This operation is unavailable to query logical databases.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The name of the project.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
}

func (s CreateSQLReviewOrderRequestParam) String() string {
	return tea.Prettify(s)
}

func (s CreateSQLReviewOrderRequestParam) GoString() string {
	return s.String()
}

func (s *CreateSQLReviewOrderRequestParam) SetAttachmentKeyList(v []*string) *CreateSQLReviewOrderRequestParam {
	s.AttachmentKeyList = v
	return s
}

func (s *CreateSQLReviewOrderRequestParam) SetDbId(v int64) *CreateSQLReviewOrderRequestParam {
	s.DbId = &v
	return s
}

func (s *CreateSQLReviewOrderRequestParam) SetProjectName(v string) *CreateSQLReviewOrderRequestParam {
	s.ProjectName = &v
	return s
}

type CreateSQLReviewOrderShrinkRequest struct {
	// The purpose or objective of the SQL review. This reduces unnecessary communication.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The parameters of the ticket.
	ParamShrink *string `json:"Param,omitempty" xml:"Param,omitempty"`
	// The stakeholders involved in this operation. All the specified stakeholders can view the ticket details and take part in the approval process. Irrelevant users other than DMS administrators and database administrators (DBAs) are not allowed to view the ticket details.
	RelatedUserListShrink *string `json:"RelatedUserList,omitempty" xml:"RelatedUserList,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateSQLReviewOrderShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateSQLReviewOrderShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateSQLReviewOrderShrinkRequest) SetComment(v string) *CreateSQLReviewOrderShrinkRequest {
	s.Comment = &v
	return s
}

func (s *CreateSQLReviewOrderShrinkRequest) SetParamShrink(v string) *CreateSQLReviewOrderShrinkRequest {
	s.ParamShrink = &v
	return s
}

func (s *CreateSQLReviewOrderShrinkRequest) SetRelatedUserListShrink(v string) *CreateSQLReviewOrderShrinkRequest {
	s.RelatedUserListShrink = &v
	return s
}

func (s *CreateSQLReviewOrderShrinkRequest) SetTid(v int64) *CreateSQLReviewOrderShrinkRequest {
	s.Tid = &v
	return s
}

type CreateSQLReviewOrderResponseBody struct {
	// The result of the ticket creation task.
	CreateOrderResult []*int64 `json:"CreateOrderResult,omitempty" xml:"CreateOrderResult,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateSQLReviewOrderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateSQLReviewOrderResponseBody) GoString() string {
	return s.String()
}

func (s *CreateSQLReviewOrderResponseBody) SetCreateOrderResult(v []*int64) *CreateSQLReviewOrderResponseBody {
	s.CreateOrderResult = v
	return s
}

func (s *CreateSQLReviewOrderResponseBody) SetErrorCode(v string) *CreateSQLReviewOrderResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateSQLReviewOrderResponseBody) SetErrorMessage(v string) *CreateSQLReviewOrderResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateSQLReviewOrderResponseBody) SetRequestId(v string) *CreateSQLReviewOrderResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateSQLReviewOrderResponseBody) SetSuccess(v bool) *CreateSQLReviewOrderResponseBody {
	s.Success = &v
	return s
}

type CreateSQLReviewOrderResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateSQLReviewOrderResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateSQLReviewOrderResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateSQLReviewOrderResponse) GoString() string {
	return s.String()
}

func (s *CreateSQLReviewOrderResponse) SetHeaders(v map[string]*string) *CreateSQLReviewOrderResponse {
	s.Headers = v
	return s
}

func (s *CreateSQLReviewOrderResponse) SetStatusCode(v int32) *CreateSQLReviewOrderResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateSQLReviewOrderResponse) SetBody(v *CreateSQLReviewOrderResponseBody) *CreateSQLReviewOrderResponse {
	s.Body = v
	return s
}

type CreateScenarioRequest struct {
	// The description of the business scenario.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the business scenario.
	ScenarioName *string `json:"ScenarioName,omitempty" xml:"ScenarioName,omitempty"`
	// The ID of the tenant.
	//
	// > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateScenarioRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateScenarioRequest) GoString() string {
	return s.String()
}

func (s *CreateScenarioRequest) SetDescription(v string) *CreateScenarioRequest {
	s.Description = &v
	return s
}

func (s *CreateScenarioRequest) SetScenarioName(v string) *CreateScenarioRequest {
	s.ScenarioName = &v
	return s
}

func (s *CreateScenarioRequest) SetTid(v int64) *CreateScenarioRequest {
	s.Tid = &v
	return s
}

type CreateScenarioResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the business scenario.
	ScenarioId *int64 `json:"ScenarioId,omitempty" xml:"ScenarioId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateScenarioResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateScenarioResponseBody) GoString() string {
	return s.String()
}

func (s *CreateScenarioResponseBody) SetErrorCode(v string) *CreateScenarioResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateScenarioResponseBody) SetErrorMessage(v string) *CreateScenarioResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateScenarioResponseBody) SetRequestId(v string) *CreateScenarioResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateScenarioResponseBody) SetScenarioId(v int64) *CreateScenarioResponseBody {
	s.ScenarioId = &v
	return s
}

func (s *CreateScenarioResponseBody) SetSuccess(v bool) *CreateScenarioResponseBody {
	s.Success = &v
	return s
}

type CreateScenarioResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateScenarioResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateScenarioResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateScenarioResponse) GoString() string {
	return s.String()
}

func (s *CreateScenarioResponse) SetHeaders(v map[string]*string) *CreateScenarioResponse {
	s.Headers = v
	return s
}

func (s *CreateScenarioResponse) SetStatusCode(v int32) *CreateScenarioResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateScenarioResponse) SetBody(v *CreateScenarioResponseBody) *CreateScenarioResponse {
	s.Body = v
	return s
}

type CreateStandardGroupRequest struct {
	// The type of the database engine. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The description of the security rule set.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the security rule set.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the tenant.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateStandardGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateStandardGroupRequest) GoString() string {
	return s.String()
}

func (s *CreateStandardGroupRequest) SetDbType(v string) *CreateStandardGroupRequest {
	s.DbType = &v
	return s
}

func (s *CreateStandardGroupRequest) SetDescription(v string) *CreateStandardGroupRequest {
	s.Description = &v
	return s
}

func (s *CreateStandardGroupRequest) SetGroupName(v string) *CreateStandardGroupRequest {
	s.GroupName = &v
	return s
}

func (s *CreateStandardGroupRequest) SetTid(v int64) *CreateStandardGroupRequest {
	s.Tid = &v
	return s
}

type CreateStandardGroupResponseBody struct {
	// The error code returned if the request fails.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The created security rule set.
	StandardGroup *CreateStandardGroupResponseBodyStandardGroup `json:"StandardGroup,omitempty" xml:"StandardGroup,omitempty" type:"Struct"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateStandardGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateStandardGroupResponseBody) GoString() string {
	return s.String()
}

func (s *CreateStandardGroupResponseBody) SetErrorCode(v string) *CreateStandardGroupResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateStandardGroupResponseBody) SetErrorMessage(v string) *CreateStandardGroupResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateStandardGroupResponseBody) SetRequestId(v string) *CreateStandardGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateStandardGroupResponseBody) SetStandardGroup(v *CreateStandardGroupResponseBodyStandardGroup) *CreateStandardGroupResponseBody {
	s.StandardGroup = v
	return s
}

func (s *CreateStandardGroupResponseBody) SetSuccess(v bool) *CreateStandardGroupResponseBody {
	s.Success = &v
	return s
}

type CreateStandardGroupResponseBodyStandardGroup struct {
	// The type of the database engine. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The description of the security rule set.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	GroupId     *int64  `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The control mode. Valid values:
	//
	// *   **NONE_CONTROL**: Flexible Management
	// *   **STABLE**: Stable Change
	// *   **COMMON**: Security Collaboration
	GroupMode *string `json:"GroupMode,omitempty" xml:"GroupMode,omitempty"`
	// The name of the security rule set.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the user who creates the security rule set.
	LastMenderId *int64 `json:"LastMenderId,omitempty" xml:"LastMenderId,omitempty"`
}

func (s CreateStandardGroupResponseBodyStandardGroup) String() string {
	return tea.Prettify(s)
}

func (s CreateStandardGroupResponseBodyStandardGroup) GoString() string {
	return s.String()
}

func (s *CreateStandardGroupResponseBodyStandardGroup) SetDbType(v string) *CreateStandardGroupResponseBodyStandardGroup {
	s.DbType = &v
	return s
}

func (s *CreateStandardGroupResponseBodyStandardGroup) SetDescription(v string) *CreateStandardGroupResponseBodyStandardGroup {
	s.Description = &v
	return s
}

func (s *CreateStandardGroupResponseBodyStandardGroup) SetGroupId(v int64) *CreateStandardGroupResponseBodyStandardGroup {
	s.GroupId = &v
	return s
}

func (s *CreateStandardGroupResponseBodyStandardGroup) SetGroupMode(v string) *CreateStandardGroupResponseBodyStandardGroup {
	s.GroupMode = &v
	return s
}

func (s *CreateStandardGroupResponseBodyStandardGroup) SetGroupName(v string) *CreateStandardGroupResponseBodyStandardGroup {
	s.GroupName = &v
	return s
}

func (s *CreateStandardGroupResponseBodyStandardGroup) SetLastMenderId(v int64) *CreateStandardGroupResponseBodyStandardGroup {
	s.LastMenderId = &v
	return s
}

type CreateStandardGroupResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateStandardGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateStandardGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateStandardGroupResponse) GoString() string {
	return s.String()
}

func (s *CreateStandardGroupResponse) SetHeaders(v map[string]*string) *CreateStandardGroupResponse {
	s.Headers = v
	return s
}

func (s *CreateStandardGroupResponse) SetStatusCode(v int32) *CreateStandardGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateStandardGroupResponse) SetBody(v *CreateStandardGroupResponseBody) *CreateStandardGroupResponse {
	s.Body = v
	return s
}

type CreateStructSyncOrderRequest struct {
	// The key of an attachment that is returned after the attachment is uploaded. You can call the [GetUserUploadFileJob](~~206069~~) operation to query the key of the attachment.
	AttachmentKey *string `json:"AttachmentKey,omitempty" xml:"AttachmentKey,omitempty"`
	// The remarks of the ticket.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The parameters of the ticket.
	Param *CreateStructSyncOrderRequestParam `json:"Param,omitempty" xml:"Param,omitempty" type:"Struct"`
	// The IDs of the stakeholders.
	RelatedUserList []*int64 `json:"RelatedUserList,omitempty" xml:"RelatedUserList,omitempty" type:"Repeated"`
	// The ID of the tenant.
	//
	// >  To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateStructSyncOrderRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateStructSyncOrderRequest) GoString() string {
	return s.String()
}

func (s *CreateStructSyncOrderRequest) SetAttachmentKey(v string) *CreateStructSyncOrderRequest {
	s.AttachmentKey = &v
	return s
}

func (s *CreateStructSyncOrderRequest) SetComment(v string) *CreateStructSyncOrderRequest {
	s.Comment = &v
	return s
}

func (s *CreateStructSyncOrderRequest) SetParam(v *CreateStructSyncOrderRequestParam) *CreateStructSyncOrderRequest {
	s.Param = v
	return s
}

func (s *CreateStructSyncOrderRequest) SetRelatedUserList(v []*int64) *CreateStructSyncOrderRequest {
	s.RelatedUserList = v
	return s
}

func (s *CreateStructSyncOrderRequest) SetTid(v int64) *CreateStructSyncOrderRequest {
	s.Tid = &v
	return s
}

type CreateStructSyncOrderRequestParam struct {
	// Specifies whether to skip an error that occurs in executing an SQL statement. Valid values:
	//
	// *   **true**: continues to execute subsequent SQL statements if an error occurs in executing an SQL statement.
	// *   **false**: stops executing subsequent SQL statements if an error occurs in executing an SQL statement.
	IgnoreError *bool `json:"IgnoreError,omitempty" xml:"IgnoreError,omitempty"`
	// The information about the base database.
	Source *CreateStructSyncOrderRequestParamSource `json:"Source,omitempty" xml:"Source,omitempty" type:"Struct"`
	// The information about the table of which you want to synchronize the schema.
	TableInfoList []*CreateStructSyncOrderRequestParamTableInfoList `json:"TableInfoList,omitempty" xml:"TableInfoList,omitempty" type:"Repeated"`
	// The information about the database to which you want to synchronize the schema of a table.
	Target *CreateStructSyncOrderRequestParamTarget `json:"Target,omitempty" xml:"Target,omitempty" type:"Struct"`
}

func (s CreateStructSyncOrderRequestParam) String() string {
	return tea.Prettify(s)
}

func (s CreateStructSyncOrderRequestParam) GoString() string {
	return s.String()
}

func (s *CreateStructSyncOrderRequestParam) SetIgnoreError(v bool) *CreateStructSyncOrderRequestParam {
	s.IgnoreError = &v
	return s
}

func (s *CreateStructSyncOrderRequestParam) SetSource(v *CreateStructSyncOrderRequestParamSource) *CreateStructSyncOrderRequestParam {
	s.Source = v
	return s
}

func (s *CreateStructSyncOrderRequestParam) SetTableInfoList(v []*CreateStructSyncOrderRequestParamTableInfoList) *CreateStructSyncOrderRequestParam {
	s.TableInfoList = v
	return s
}

func (s *CreateStructSyncOrderRequestParam) SetTarget(v *CreateStructSyncOrderRequestParamTarget) *CreateStructSyncOrderRequestParam {
	s.Target = v
	return s
}

type CreateStructSyncOrderRequestParamSource struct {
	// The ID of the database. You can call the [SearchDatabases](~~141876~~) operation to query the ID of the database.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The name that is used to search for the database. You can call the [SearchDatabases](~~141876~~) operation to query the name of the database.
	DbSearchName *string `json:"DbSearchName,omitempty" xml:"DbSearchName,omitempty"`
	// Specifies whether the database is a logical database. Valid values:
	//
	// *   **true**: The database is a logical database.
	// *   **false**: The database is not a logical database.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The version number of the schema. The default value is the latest schema version number. For more information, see [Manage schema versions](~~202275~~).
	VersionId *string `json:"VersionId,omitempty" xml:"VersionId,omitempty"`
}

func (s CreateStructSyncOrderRequestParamSource) String() string {
	return tea.Prettify(s)
}

func (s CreateStructSyncOrderRequestParamSource) GoString() string {
	return s.String()
}

func (s *CreateStructSyncOrderRequestParamSource) SetDbId(v int64) *CreateStructSyncOrderRequestParamSource {
	s.DbId = &v
	return s
}

func (s *CreateStructSyncOrderRequestParamSource) SetDbSearchName(v string) *CreateStructSyncOrderRequestParamSource {
	s.DbSearchName = &v
	return s
}

func (s *CreateStructSyncOrderRequestParamSource) SetLogic(v bool) *CreateStructSyncOrderRequestParamSource {
	s.Logic = &v
	return s
}

func (s *CreateStructSyncOrderRequestParamSource) SetVersionId(v string) *CreateStructSyncOrderRequestParamSource {
	s.VersionId = &v
	return s
}

type CreateStructSyncOrderRequestParamTableInfoList struct {
	// The name of the source table.
	SourceTableName *string `json:"SourceTableName,omitempty" xml:"SourceTableName,omitempty"`
	// The name of the destination table.
	TargetTableName *string `json:"TargetTableName,omitempty" xml:"TargetTableName,omitempty"`
}

func (s CreateStructSyncOrderRequestParamTableInfoList) String() string {
	return tea.Prettify(s)
}

func (s CreateStructSyncOrderRequestParamTableInfoList) GoString() string {
	return s.String()
}

func (s *CreateStructSyncOrderRequestParamTableInfoList) SetSourceTableName(v string) *CreateStructSyncOrderRequestParamTableInfoList {
	s.SourceTableName = &v
	return s
}

func (s *CreateStructSyncOrderRequestParamTableInfoList) SetTargetTableName(v string) *CreateStructSyncOrderRequestParamTableInfoList {
	s.TargetTableName = &v
	return s
}

type CreateStructSyncOrderRequestParamTarget struct {
	// The ID of the database. You can call the [SearchDatabases](~~141876~~) operation to query the ID of the database.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The name that is used to search for the database. You can call the [SearchDatabases](~~141876~~) operation to query the name of the database.
	DbSearchName *string `json:"DbSearchName,omitempty" xml:"DbSearchName,omitempty"`
	// Specifies whether the database is a logical database. Valid values:
	//
	// *   **true**: The database is a logical database.
	// *   **false**: The database is not a logical database.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The version number. By default, this parameter is left empty.
	//
	// >  If you specify the schema version number of the destination database, Data Management (DMS) only compares the schemas of the two databases.
	VersionId *string `json:"VersionId,omitempty" xml:"VersionId,omitempty"`
}

func (s CreateStructSyncOrderRequestParamTarget) String() string {
	return tea.Prettify(s)
}

func (s CreateStructSyncOrderRequestParamTarget) GoString() string {
	return s.String()
}

func (s *CreateStructSyncOrderRequestParamTarget) SetDbId(v int64) *CreateStructSyncOrderRequestParamTarget {
	s.DbId = &v
	return s
}

func (s *CreateStructSyncOrderRequestParamTarget) SetDbSearchName(v string) *CreateStructSyncOrderRequestParamTarget {
	s.DbSearchName = &v
	return s
}

func (s *CreateStructSyncOrderRequestParamTarget) SetLogic(v bool) *CreateStructSyncOrderRequestParamTarget {
	s.Logic = &v
	return s
}

func (s *CreateStructSyncOrderRequestParamTarget) SetVersionId(v string) *CreateStructSyncOrderRequestParamTarget {
	s.VersionId = &v
	return s
}

type CreateStructSyncOrderShrinkRequest struct {
	// The key of an attachment that is returned after the attachment is uploaded. You can call the [GetUserUploadFileJob](~~206069~~) operation to query the key of the attachment.
	AttachmentKey *string `json:"AttachmentKey,omitempty" xml:"AttachmentKey,omitempty"`
	// The remarks of the ticket.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The parameters of the ticket.
	ParamShrink *string `json:"Param,omitempty" xml:"Param,omitempty"`
	// The IDs of the stakeholders.
	RelatedUserListShrink *string `json:"RelatedUserList,omitempty" xml:"RelatedUserList,omitempty"`
	// The ID of the tenant.
	//
	// >  To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateStructSyncOrderShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateStructSyncOrderShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateStructSyncOrderShrinkRequest) SetAttachmentKey(v string) *CreateStructSyncOrderShrinkRequest {
	s.AttachmentKey = &v
	return s
}

func (s *CreateStructSyncOrderShrinkRequest) SetComment(v string) *CreateStructSyncOrderShrinkRequest {
	s.Comment = &v
	return s
}

func (s *CreateStructSyncOrderShrinkRequest) SetParamShrink(v string) *CreateStructSyncOrderShrinkRequest {
	s.ParamShrink = &v
	return s
}

func (s *CreateStructSyncOrderShrinkRequest) SetRelatedUserListShrink(v string) *CreateStructSyncOrderShrinkRequest {
	s.RelatedUserListShrink = &v
	return s
}

func (s *CreateStructSyncOrderShrinkRequest) SetTid(v int64) *CreateStructSyncOrderShrinkRequest {
	s.Tid = &v
	return s
}

type CreateStructSyncOrderResponseBody struct {
	// The result of creating the ticket.
	CreateOrderResult []*int64 `json:"CreateOrderResult,omitempty" xml:"CreateOrderResult,omitempty" type:"Repeated"`
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateStructSyncOrderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateStructSyncOrderResponseBody) GoString() string {
	return s.String()
}

func (s *CreateStructSyncOrderResponseBody) SetCreateOrderResult(v []*int64) *CreateStructSyncOrderResponseBody {
	s.CreateOrderResult = v
	return s
}

func (s *CreateStructSyncOrderResponseBody) SetErrorCode(v string) *CreateStructSyncOrderResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateStructSyncOrderResponseBody) SetErrorMessage(v string) *CreateStructSyncOrderResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateStructSyncOrderResponseBody) SetRequestId(v string) *CreateStructSyncOrderResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateStructSyncOrderResponseBody) SetSuccess(v bool) *CreateStructSyncOrderResponseBody {
	s.Success = &v
	return s
}

type CreateStructSyncOrderResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateStructSyncOrderResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateStructSyncOrderResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateStructSyncOrderResponse) GoString() string {
	return s.String()
}

func (s *CreateStructSyncOrderResponse) SetHeaders(v map[string]*string) *CreateStructSyncOrderResponse {
	s.Headers = v
	return s
}

func (s *CreateStructSyncOrderResponse) SetStatusCode(v int32) *CreateStructSyncOrderResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateStructSyncOrderResponse) SetBody(v *CreateStructSyncOrderResponseBody) *CreateStructSyncOrderResponse {
	s.Body = v
	return s
}

type CreateTaskRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The position of the node on the Directed Acyclic Graph (DAG).
	GraphParam *string `json:"GraphParam,omitempty" xml:"GraphParam,omitempty"`
	// The configuration of the node.
	NodeContent *string `json:"NodeContent,omitempty" xml:"NodeContent,omitempty"`
	// The name of the node that you want to create.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The output variables configured for the task.
	NodeOutput *string `json:"NodeOutput,omitempty" xml:"NodeOutput,omitempty"`
	// The type of the node that you want to create. For more information about the valid values for this parameter, see [NodeType parameter](~~424705~~).
	NodeType *string `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
	// The tenant ID.
	//
	// >  To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The time variables configured for the node.
	TimeVariables *string `json:"TimeVariables,omitempty" xml:"TimeVariables,omitempty"`
}

func (s CreateTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateTaskRequest) GoString() string {
	return s.String()
}

func (s *CreateTaskRequest) SetDagId(v int64) *CreateTaskRequest {
	s.DagId = &v
	return s
}

func (s *CreateTaskRequest) SetGraphParam(v string) *CreateTaskRequest {
	s.GraphParam = &v
	return s
}

func (s *CreateTaskRequest) SetNodeContent(v string) *CreateTaskRequest {
	s.NodeContent = &v
	return s
}

func (s *CreateTaskRequest) SetNodeName(v string) *CreateTaskRequest {
	s.NodeName = &v
	return s
}

func (s *CreateTaskRequest) SetNodeOutput(v string) *CreateTaskRequest {
	s.NodeOutput = &v
	return s
}

func (s *CreateTaskRequest) SetNodeType(v string) *CreateTaskRequest {
	s.NodeType = &v
	return s
}

func (s *CreateTaskRequest) SetTid(v int64) *CreateTaskRequest {
	s.Tid = &v
	return s
}

func (s *CreateTaskRequest) SetTimeVariables(v string) *CreateTaskRequest {
	s.TimeVariables = &v
	return s
}

type CreateTaskResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the task node returned when the task was created.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true
	// *   false
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateTaskResponseBody) GoString() string {
	return s.String()
}

func (s *CreateTaskResponseBody) SetErrorCode(v string) *CreateTaskResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateTaskResponseBody) SetErrorMessage(v string) *CreateTaskResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateTaskResponseBody) SetNodeId(v int64) *CreateTaskResponseBody {
	s.NodeId = &v
	return s
}

func (s *CreateTaskResponseBody) SetRequestId(v string) *CreateTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateTaskResponseBody) SetSuccess(v bool) *CreateTaskResponseBody {
	s.Success = &v
	return s
}

type CreateTaskResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateTaskResponse) GoString() string {
	return s.String()
}

func (s *CreateTaskResponse) SetHeaders(v map[string]*string) *CreateTaskResponse {
	s.Headers = v
	return s
}

func (s *CreateTaskResponse) SetStatusCode(v int32) *CreateTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateTaskResponse) SetBody(v *CreateTaskResponseBody) *CreateTaskResponse {
	s.Body = v
	return s
}

type CreateTaskFlowRequest struct {
	// The name of the task flow.
	DagName *string `json:"DagName,omitempty" xml:"DagName,omitempty"`
	// The description of the task flow.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the scenario.
	ScenarioId *int64 `json:"ScenarioId,omitempty" xml:"ScenarioId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s CreateTaskFlowRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateTaskFlowRequest) GoString() string {
	return s.String()
}

func (s *CreateTaskFlowRequest) SetDagName(v string) *CreateTaskFlowRequest {
	s.DagName = &v
	return s
}

func (s *CreateTaskFlowRequest) SetDescription(v string) *CreateTaskFlowRequest {
	s.Description = &v
	return s
}

func (s *CreateTaskFlowRequest) SetScenarioId(v int64) *CreateTaskFlowRequest {
	s.ScenarioId = &v
	return s
}

func (s *CreateTaskFlowRequest) SetTid(v int64) *CreateTaskFlowRequest {
	s.Tid = &v
	return s
}

type CreateTaskFlowResponseBody struct {
	// The ID of the task flow.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateTaskFlowResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateTaskFlowResponseBody) GoString() string {
	return s.String()
}

func (s *CreateTaskFlowResponseBody) SetDagId(v int64) *CreateTaskFlowResponseBody {
	s.DagId = &v
	return s
}

func (s *CreateTaskFlowResponseBody) SetErrorCode(v string) *CreateTaskFlowResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateTaskFlowResponseBody) SetErrorMessage(v string) *CreateTaskFlowResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateTaskFlowResponseBody) SetRequestId(v string) *CreateTaskFlowResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateTaskFlowResponseBody) SetSuccess(v bool) *CreateTaskFlowResponseBody {
	s.Success = &v
	return s
}

type CreateTaskFlowResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateTaskFlowResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateTaskFlowResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateTaskFlowResponse) GoString() string {
	return s.String()
}

func (s *CreateTaskFlowResponse) SetHeaders(v map[string]*string) *CreateTaskFlowResponse {
	s.Headers = v
	return s
}

func (s *CreateTaskFlowResponse) SetStatusCode(v int32) *CreateTaskFlowResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateTaskFlowResponse) SetBody(v *CreateTaskFlowResponseBody) *CreateTaskFlowResponse {
	s.Body = v
	return s
}

type CreateUploadFileJobRequest struct {
	// The name of the attachment file.
	//
	// >  The file name must end with .txt or .sql. For example, the file name can be test.txt or test.sql.
	FileName *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	// The purpose of the attachment file. Valid values:
	//
	// *   **datacorrect**: The file is uploaded to change data.
	// *   **order_info_attachment**: The file is uploaded as an attachment in a ticket.
	// *   **big-file**: The file is uploaded to import multiple data records at a time.
	// *   **sqlreview**: The file is uploaded for SQL review.
	FileSource *string `json:"FileSource,omitempty" xml:"FileSource,omitempty"`
	// The ID of the tenant.
	//
	// >  You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The URL of the attachment file. The URL must be an HTTP URL or an HTTPS URL.
	//
	// >  You can upload the attachment file to an Object Storage Service (OSS) bucket and obtain the URL of the file in the OSS console. For more information, see [Share objects](~~195674~~).
	UploadURL *string `json:"UploadURL,omitempty" xml:"UploadURL,omitempty"`
}

func (s CreateUploadFileJobRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateUploadFileJobRequest) GoString() string {
	return s.String()
}

func (s *CreateUploadFileJobRequest) SetFileName(v string) *CreateUploadFileJobRequest {
	s.FileName = &v
	return s
}

func (s *CreateUploadFileJobRequest) SetFileSource(v string) *CreateUploadFileJobRequest {
	s.FileSource = &v
	return s
}

func (s *CreateUploadFileJobRequest) SetTid(v int64) *CreateUploadFileJobRequest {
	s.Tid = &v
	return s
}

func (s *CreateUploadFileJobRequest) SetUploadURL(v string) *CreateUploadFileJobRequest {
	s.UploadURL = &v
	return s
}

type CreateUploadFileJobResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The key of the task.
	//
	// >  You can call the [GetUserUploadFileJob](~~206069~~) operation to query the progress and details of the task.
	JobKey *string `json:"JobKey,omitempty" xml:"JobKey,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateUploadFileJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateUploadFileJobResponseBody) GoString() string {
	return s.String()
}

func (s *CreateUploadFileJobResponseBody) SetErrorCode(v string) *CreateUploadFileJobResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateUploadFileJobResponseBody) SetErrorMessage(v string) *CreateUploadFileJobResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateUploadFileJobResponseBody) SetJobKey(v string) *CreateUploadFileJobResponseBody {
	s.JobKey = &v
	return s
}

func (s *CreateUploadFileJobResponseBody) SetRequestId(v string) *CreateUploadFileJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateUploadFileJobResponseBody) SetSuccess(v bool) *CreateUploadFileJobResponseBody {
	s.Success = &v
	return s
}

type CreateUploadFileJobResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateUploadFileJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateUploadFileJobResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateUploadFileJobResponse) GoString() string {
	return s.String()
}

func (s *CreateUploadFileJobResponse) SetHeaders(v map[string]*string) *CreateUploadFileJobResponse {
	s.Headers = v
	return s
}

func (s *CreateUploadFileJobResponse) SetStatusCode(v int32) *CreateUploadFileJobResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateUploadFileJobResponse) SetBody(v *CreateUploadFileJobResponseBody) *CreateUploadFileJobResponse {
	s.Body = v
	return s
}

type CreateUploadOSSFileJobRequest struct {
	// The name of the file.
	//
	// > The file name must end with .txt or .sql. For example, the file name can be text.txt.
	FileName *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	// The purpose of the file upload task. Valid values:
	//
	// *   **datacorrect**: The file is uploaded to change data.
	// *   **order_info_attachment**: The file is uploaded as an attachment in a ticket.
	// *   **big-file**: The file is uploaded to import multiple data records at a time.
	// *   **sqlreview**: The file is uploaded for SQL review.
	FileSource *string `json:"FileSource,omitempty" xml:"FileSource,omitempty"`
	// The ID of the tenant.
	//
	// > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The information about the OSS file to be uploaded.
	UploadTarget *CreateUploadOSSFileJobRequestUploadTarget `json:"UploadTarget,omitempty" xml:"UploadTarget,omitempty" type:"Struct"`
}

func (s CreateUploadOSSFileJobRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateUploadOSSFileJobRequest) GoString() string {
	return s.String()
}

func (s *CreateUploadOSSFileJobRequest) SetFileName(v string) *CreateUploadOSSFileJobRequest {
	s.FileName = &v
	return s
}

func (s *CreateUploadOSSFileJobRequest) SetFileSource(v string) *CreateUploadOSSFileJobRequest {
	s.FileSource = &v
	return s
}

func (s *CreateUploadOSSFileJobRequest) SetTid(v int64) *CreateUploadOSSFileJobRequest {
	s.Tid = &v
	return s
}

func (s *CreateUploadOSSFileJobRequest) SetUploadTarget(v *CreateUploadOSSFileJobRequestUploadTarget) *CreateUploadOSSFileJobRequest {
	s.UploadTarget = v
	return s
}

type CreateUploadOSSFileJobRequestUploadTarget struct {
	// The name of the OSS bucket.
	BucketName *string `json:"BucketName,omitempty" xml:"BucketName,omitempty"`
	// The endpoint of the OSS bucket.
	Endpoint *string `json:"Endpoint,omitempty" xml:"Endpoint,omitempty"`
	// The name of the OSS object.
	ObjectName *string `json:"ObjectName,omitempty" xml:"ObjectName,omitempty"`
}

func (s CreateUploadOSSFileJobRequestUploadTarget) String() string {
	return tea.Prettify(s)
}

func (s CreateUploadOSSFileJobRequestUploadTarget) GoString() string {
	return s.String()
}

func (s *CreateUploadOSSFileJobRequestUploadTarget) SetBucketName(v string) *CreateUploadOSSFileJobRequestUploadTarget {
	s.BucketName = &v
	return s
}

func (s *CreateUploadOSSFileJobRequestUploadTarget) SetEndpoint(v string) *CreateUploadOSSFileJobRequestUploadTarget {
	s.Endpoint = &v
	return s
}

func (s *CreateUploadOSSFileJobRequestUploadTarget) SetObjectName(v string) *CreateUploadOSSFileJobRequestUploadTarget {
	s.ObjectName = &v
	return s
}

type CreateUploadOSSFileJobShrinkRequest struct {
	// The name of the file.
	//
	// > The file name must end with .txt or .sql. For example, the file name can be text.txt.
	FileName *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	// The purpose of the file upload task. Valid values:
	//
	// *   **datacorrect**: The file is uploaded to change data.
	// *   **order_info_attachment**: The file is uploaded as an attachment in a ticket.
	// *   **big-file**: The file is uploaded to import multiple data records at a time.
	// *   **sqlreview**: The file is uploaded for SQL review.
	FileSource *string `json:"FileSource,omitempty" xml:"FileSource,omitempty"`
	// The ID of the tenant.
	//
	// > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The information about the OSS file to be uploaded.
	UploadTargetShrink *string `json:"UploadTarget,omitempty" xml:"UploadTarget,omitempty"`
}

func (s CreateUploadOSSFileJobShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateUploadOSSFileJobShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateUploadOSSFileJobShrinkRequest) SetFileName(v string) *CreateUploadOSSFileJobShrinkRequest {
	s.FileName = &v
	return s
}

func (s *CreateUploadOSSFileJobShrinkRequest) SetFileSource(v string) *CreateUploadOSSFileJobShrinkRequest {
	s.FileSource = &v
	return s
}

func (s *CreateUploadOSSFileJobShrinkRequest) SetTid(v int64) *CreateUploadOSSFileJobShrinkRequest {
	s.Tid = &v
	return s
}

func (s *CreateUploadOSSFileJobShrinkRequest) SetUploadTargetShrink(v string) *CreateUploadOSSFileJobShrinkRequest {
	s.UploadTargetShrink = &v
	return s
}

type CreateUploadOSSFileJobResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The key of the file upload task. You can query the upload progress and task details. For more information, see [GetUserUploadFileJob](~~206069~~).
	JobKey *string `json:"JobKey,omitempty" xml:"JobKey,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateUploadOSSFileJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateUploadOSSFileJobResponseBody) GoString() string {
	return s.String()
}

func (s *CreateUploadOSSFileJobResponseBody) SetErrorCode(v string) *CreateUploadOSSFileJobResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateUploadOSSFileJobResponseBody) SetErrorMessage(v string) *CreateUploadOSSFileJobResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateUploadOSSFileJobResponseBody) SetJobKey(v string) *CreateUploadOSSFileJobResponseBody {
	s.JobKey = &v
	return s
}

func (s *CreateUploadOSSFileJobResponseBody) SetRequestId(v string) *CreateUploadOSSFileJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateUploadOSSFileJobResponseBody) SetSuccess(v bool) *CreateUploadOSSFileJobResponseBody {
	s.Success = &v
	return s
}

type CreateUploadOSSFileJobResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateUploadOSSFileJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateUploadOSSFileJobResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateUploadOSSFileJobResponse) GoString() string {
	return s.String()
}

func (s *CreateUploadOSSFileJobResponse) SetHeaders(v map[string]*string) *CreateUploadOSSFileJobResponse {
	s.Headers = v
	return s
}

func (s *CreateUploadOSSFileJobResponse) SetStatusCode(v int32) *CreateUploadOSSFileJobResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateUploadOSSFileJobResponse) SetBody(v *CreateUploadOSSFileJobResponseBody) *CreateUploadOSSFileJobResponse {
	s.Body = v
	return s
}

type DeleteAuthorityTemplateRequest struct {
	TemplateId *int64 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	Tid        *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s DeleteAuthorityTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAuthorityTemplateRequest) GoString() string {
	return s.String()
}

func (s *DeleteAuthorityTemplateRequest) SetTemplateId(v int64) *DeleteAuthorityTemplateRequest {
	s.TemplateId = &v
	return s
}

func (s *DeleteAuthorityTemplateRequest) SetTid(v int64) *DeleteAuthorityTemplateRequest {
	s.Tid = &v
	return s
}

type DeleteAuthorityTemplateResponseBody struct {
	ErrorCode    *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
	Tid          *int64  `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s DeleteAuthorityTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAuthorityTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAuthorityTemplateResponseBody) SetErrorCode(v string) *DeleteAuthorityTemplateResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteAuthorityTemplateResponseBody) SetErrorMessage(v string) *DeleteAuthorityTemplateResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteAuthorityTemplateResponseBody) SetRequestId(v string) *DeleteAuthorityTemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteAuthorityTemplateResponseBody) SetSuccess(v bool) *DeleteAuthorityTemplateResponseBody {
	s.Success = &v
	return s
}

func (s *DeleteAuthorityTemplateResponseBody) SetTid(v int64) *DeleteAuthorityTemplateResponseBody {
	s.Tid = &v
	return s
}

type DeleteAuthorityTemplateResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteAuthorityTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteAuthorityTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAuthorityTemplateResponse) GoString() string {
	return s.String()
}

func (s *DeleteAuthorityTemplateResponse) SetHeaders(v map[string]*string) *DeleteAuthorityTemplateResponse {
	s.Headers = v
	return s
}

func (s *DeleteAuthorityTemplateResponse) SetStatusCode(v int32) *DeleteAuthorityTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAuthorityTemplateResponse) SetBody(v *DeleteAuthorityTemplateResponseBody) *DeleteAuthorityTemplateResponse {
	s.Body = v
	return s
}

type DeleteInstanceRequest struct {
	// The endpoint of the database instance. You can call the [ListInstances](~~141936~~) or [GetInstance](~~141567~~) operation to obtain the endpoint.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The port number that is used to connect to the database instance. You can call the [ListInstances](~~141936~~) or [GetInstance](~~141567~~) operation to obtain the port number.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The system ID (SID) of the database instance. You can call the [ListInstances](~~141936~~) or [GetInstance](~~141567~~) operation to obtain the SID.
	Sid *string `json:"Sid,omitempty" xml:"Sid,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s DeleteInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteInstanceRequest) GoString() string {
	return s.String()
}

func (s *DeleteInstanceRequest) SetHost(v string) *DeleteInstanceRequest {
	s.Host = &v
	return s
}

func (s *DeleteInstanceRequest) SetPort(v int32) *DeleteInstanceRequest {
	s.Port = &v
	return s
}

func (s *DeleteInstanceRequest) SetSid(v string) *DeleteInstanceRequest {
	s.Sid = &v
	return s
}

func (s *DeleteInstanceRequest) SetTid(v int64) *DeleteInstanceRequest {
	s.Tid = &v
	return s
}

type DeleteInstanceResponseBody struct {
	// The error code that is returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message that is returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteInstanceResponseBody) SetErrorCode(v string) *DeleteInstanceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteInstanceResponseBody) SetErrorMessage(v string) *DeleteInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteInstanceResponseBody) SetRequestId(v string) *DeleteInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteInstanceResponseBody) SetSuccess(v bool) *DeleteInstanceResponseBody {
	s.Success = &v
	return s
}

type DeleteInstanceResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteInstanceResponse) GoString() string {
	return s.String()
}

func (s *DeleteInstanceResponse) SetHeaders(v map[string]*string) *DeleteInstanceResponse {
	s.Headers = v
	return s
}

func (s *DeleteInstanceResponse) SetStatusCode(v int32) *DeleteInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteInstanceResponse) SetBody(v *DeleteInstanceResponseBody) *DeleteInstanceResponse {
	s.Body = v
	return s
}

type DeleteLakeHouseSpaceRequest struct {
	// The ID of the workspace. You can call the [GetLhSpaceByName](~~424379~~) operation to obtain the workspace ID.
	SpaceId *int64 `json:"SpaceId,omitempty" xml:"SpaceId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s DeleteLakeHouseSpaceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteLakeHouseSpaceRequest) GoString() string {
	return s.String()
}

func (s *DeleteLakeHouseSpaceRequest) SetSpaceId(v int64) *DeleteLakeHouseSpaceRequest {
	s.SpaceId = &v
	return s
}

func (s *DeleteLakeHouseSpaceRequest) SetTid(v int64) *DeleteLakeHouseSpaceRequest {
	s.Tid = &v
	return s
}

type DeleteLakeHouseSpaceResponseBody struct {
	// The error code returned if the request fails.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   true: The request is successful.
	// *   false: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteLakeHouseSpaceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteLakeHouseSpaceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteLakeHouseSpaceResponseBody) SetErrorCode(v string) *DeleteLakeHouseSpaceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteLakeHouseSpaceResponseBody) SetErrorMessage(v string) *DeleteLakeHouseSpaceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteLakeHouseSpaceResponseBody) SetRequestId(v string) *DeleteLakeHouseSpaceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteLakeHouseSpaceResponseBody) SetSuccess(v bool) *DeleteLakeHouseSpaceResponseBody {
	s.Success = &v
	return s
}

type DeleteLakeHouseSpaceResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteLakeHouseSpaceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteLakeHouseSpaceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteLakeHouseSpaceResponse) GoString() string {
	return s.String()
}

func (s *DeleteLakeHouseSpaceResponse) SetHeaders(v map[string]*string) *DeleteLakeHouseSpaceResponse {
	s.Headers = v
	return s
}

func (s *DeleteLakeHouseSpaceResponse) SetStatusCode(v int32) *DeleteLakeHouseSpaceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteLakeHouseSpaceResponse) SetBody(v *DeleteLakeHouseSpaceResponseBody) *DeleteLakeHouseSpaceResponse {
	s.Body = v
	return s
}

type DeleteLhMembersRequest struct {
	// The ID of the user to be removed. You can call the [ListUsers](~~141938~~) or [GetUser](~~147098~~) operation to obtain the user ID.
	MemberIds []*int32 `json:"MemberIds,omitempty" xml:"MemberIds,omitempty" type:"Repeated"`
	// The ID of the object.
	//
	// *   If the object is a workspace, you can call the [GetLhSpaceByName](~~424379~~) operation to obtain the workspace ID.
	// *   If the object is a task flow, you can call the [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the task flow ID.
	ObjectId *int64 `json:"ObjectId,omitempty" xml:"ObjectId,omitempty"`
	// The type of the object. Valid values:
	//
	// *   **0**: workspace
	// *   **1**: task flow
	ObjectType *int32 `json:"ObjectType,omitempty" xml:"ObjectType,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s DeleteLhMembersRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteLhMembersRequest) GoString() string {
	return s.String()
}

func (s *DeleteLhMembersRequest) SetMemberIds(v []*int32) *DeleteLhMembersRequest {
	s.MemberIds = v
	return s
}

func (s *DeleteLhMembersRequest) SetObjectId(v int64) *DeleteLhMembersRequest {
	s.ObjectId = &v
	return s
}

func (s *DeleteLhMembersRequest) SetObjectType(v int32) *DeleteLhMembersRequest {
	s.ObjectType = &v
	return s
}

func (s *DeleteLhMembersRequest) SetTid(v int64) *DeleteLhMembersRequest {
	s.Tid = &v
	return s
}

type DeleteLhMembersShrinkRequest struct {
	// The ID of the user to be removed. You can call the [ListUsers](~~141938~~) or [GetUser](~~147098~~) operation to obtain the user ID.
	MemberIdsShrink *string `json:"MemberIds,omitempty" xml:"MemberIds,omitempty"`
	// The ID of the object.
	//
	// *   If the object is a workspace, you can call the [GetLhSpaceByName](~~424379~~) operation to obtain the workspace ID.
	// *   If the object is a task flow, you can call the [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the task flow ID.
	ObjectId *int64 `json:"ObjectId,omitempty" xml:"ObjectId,omitempty"`
	// The type of the object. Valid values:
	//
	// *   **0**: workspace
	// *   **1**: task flow
	ObjectType *int32 `json:"ObjectType,omitempty" xml:"ObjectType,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s DeleteLhMembersShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteLhMembersShrinkRequest) GoString() string {
	return s.String()
}

func (s *DeleteLhMembersShrinkRequest) SetMemberIdsShrink(v string) *DeleteLhMembersShrinkRequest {
	s.MemberIdsShrink = &v
	return s
}

func (s *DeleteLhMembersShrinkRequest) SetObjectId(v int64) *DeleteLhMembersShrinkRequest {
	s.ObjectId = &v
	return s
}

func (s *DeleteLhMembersShrinkRequest) SetObjectType(v int32) *DeleteLhMembersShrinkRequest {
	s.ObjectType = &v
	return s
}

func (s *DeleteLhMembersShrinkRequest) SetTid(v int64) *DeleteLhMembersShrinkRequest {
	s.Tid = &v
	return s
}

type DeleteLhMembersResponseBody struct {
	// The error code returned if the request fails.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**: The request is successful.
	// *   **false**: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteLhMembersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteLhMembersResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteLhMembersResponseBody) SetErrorCode(v string) *DeleteLhMembersResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteLhMembersResponseBody) SetErrorMessage(v string) *DeleteLhMembersResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteLhMembersResponseBody) SetRequestId(v string) *DeleteLhMembersResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteLhMembersResponseBody) SetSuccess(v bool) *DeleteLhMembersResponseBody {
	s.Success = &v
	return s
}

type DeleteLhMembersResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteLhMembersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteLhMembersResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteLhMembersResponse) GoString() string {
	return s.String()
}

func (s *DeleteLhMembersResponse) SetHeaders(v map[string]*string) *DeleteLhMembersResponse {
	s.Headers = v
	return s
}

func (s *DeleteLhMembersResponse) SetStatusCode(v int32) *DeleteLhMembersResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteLhMembersResponse) SetBody(v *DeleteLhMembersResponseBody) *DeleteLhMembersResponse {
	s.Body = v
	return s
}

type DeleteLogicDatabaseRequest struct {
	// The ID of the logical database. You can call the [ListLogicDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogicdatabases) or [SearchDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/searchdatabase) operation to query the ID of the logical database.
	LogicDbId *int64 `json:"LogicDbId,omitempty" xml:"LogicDbId,omitempty"`
	// The ID of the tenant.
	//
	// >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://www.alibabacloud.com/help/en/data-management-service/latest/manage-dms-tenants) topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s DeleteLogicDatabaseRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteLogicDatabaseRequest) GoString() string {
	return s.String()
}

func (s *DeleteLogicDatabaseRequest) SetLogicDbId(v int64) *DeleteLogicDatabaseRequest {
	s.LogicDbId = &v
	return s
}

func (s *DeleteLogicDatabaseRequest) SetTid(v int64) *DeleteLogicDatabaseRequest {
	s.Tid = &v
	return s
}

type DeleteLogicDatabaseResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// - true: The request is successful.
	// - false: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteLogicDatabaseResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteLogicDatabaseResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteLogicDatabaseResponseBody) SetErrorCode(v string) *DeleteLogicDatabaseResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteLogicDatabaseResponseBody) SetErrorMessage(v string) *DeleteLogicDatabaseResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteLogicDatabaseResponseBody) SetRequestId(v string) *DeleteLogicDatabaseResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteLogicDatabaseResponseBody) SetSuccess(v bool) *DeleteLogicDatabaseResponseBody {
	s.Success = &v
	return s
}

type DeleteLogicDatabaseResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteLogicDatabaseResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteLogicDatabaseResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteLogicDatabaseResponse) GoString() string {
	return s.String()
}

func (s *DeleteLogicDatabaseResponse) SetHeaders(v map[string]*string) *DeleteLogicDatabaseResponse {
	s.Headers = v
	return s
}

func (s *DeleteLogicDatabaseResponse) SetStatusCode(v int32) *DeleteLogicDatabaseResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteLogicDatabaseResponse) SetBody(v *DeleteLogicDatabaseResponseBody) *DeleteLogicDatabaseResponse {
	s.Body = v
	return s
}

type DeleteLogicTableRouteConfigRequest struct {
	// The unique key of the routing algorithm. You can call the [ListLogicTableRouteConfig](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogictablerouteconfig) operation to query the unique key.
	RouteKey *string `json:"RouteKey,omitempty" xml:"RouteKey,omitempty"`
	// The ID of the logical table. You can call the [ListLogicTables](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogictables) operation to query the ID of the logical table.
	TableId *int64 `json:"TableId,omitempty" xml:"TableId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s DeleteLogicTableRouteConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteLogicTableRouteConfigRequest) GoString() string {
	return s.String()
}

func (s *DeleteLogicTableRouteConfigRequest) SetRouteKey(v string) *DeleteLogicTableRouteConfigRequest {
	s.RouteKey = &v
	return s
}

func (s *DeleteLogicTableRouteConfigRequest) SetTableId(v int64) *DeleteLogicTableRouteConfigRequest {
	s.TableId = &v
	return s
}

func (s *DeleteLogicTableRouteConfigRequest) SetTid(v int64) *DeleteLogicTableRouteConfigRequest {
	s.Tid = &v
	return s
}

type DeleteLogicTableRouteConfigResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// - **true**: The request was successful.
	// - **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteLogicTableRouteConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteLogicTableRouteConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteLogicTableRouteConfigResponseBody) SetErrorCode(v string) *DeleteLogicTableRouteConfigResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteLogicTableRouteConfigResponseBody) SetErrorMessage(v string) *DeleteLogicTableRouteConfigResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteLogicTableRouteConfigResponseBody) SetRequestId(v string) *DeleteLogicTableRouteConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteLogicTableRouteConfigResponseBody) SetSuccess(v bool) *DeleteLogicTableRouteConfigResponseBody {
	s.Success = &v
	return s
}

type DeleteLogicTableRouteConfigResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteLogicTableRouteConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteLogicTableRouteConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteLogicTableRouteConfigResponse) GoString() string {
	return s.String()
}

func (s *DeleteLogicTableRouteConfigResponse) SetHeaders(v map[string]*string) *DeleteLogicTableRouteConfigResponse {
	s.Headers = v
	return s
}

func (s *DeleteLogicTableRouteConfigResponse) SetStatusCode(v int32) *DeleteLogicTableRouteConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteLogicTableRouteConfigResponse) SetBody(v *DeleteLogicTableRouteConfigResponseBody) *DeleteLogicTableRouteConfigResponse {
	s.Body = v
	return s
}

type DeleteProxyRequest struct {
	// The ID of the security protection agent. You can call the [ListProxies](https://www.alibabacloud.com/help/en/data-management-service/latest/listproxies) or [GetProxy](https://www.alibabacloud.com/help/en/data-management-service/latest/getproxy) operation to obtain this parameter.
	ProxyId *int64 `json:"ProxyId,omitempty" xml:"ProxyId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) or [ListUserTenants](https://www.alibabacloud.com/help/en/data-management-service/latest/listusertenants) operation to obtain this parameter.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s DeleteProxyRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteProxyRequest) GoString() string {
	return s.String()
}

func (s *DeleteProxyRequest) SetProxyId(v int64) *DeleteProxyRequest {
	s.ProxyId = &v
	return s
}

func (s *DeleteProxyRequest) SetTid(v int64) *DeleteProxyRequest {
	s.Tid = &v
	return s
}

type DeleteProxyResponseBody struct {
	// The error code returned to the query task.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message that is returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteProxyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteProxyResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteProxyResponseBody) SetErrorCode(v string) *DeleteProxyResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteProxyResponseBody) SetErrorMessage(v string) *DeleteProxyResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteProxyResponseBody) SetRequestId(v string) *DeleteProxyResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteProxyResponseBody) SetSuccess(v bool) *DeleteProxyResponseBody {
	s.Success = &v
	return s
}

type DeleteProxyResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteProxyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteProxyResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteProxyResponse) GoString() string {
	return s.String()
}

func (s *DeleteProxyResponse) SetHeaders(v map[string]*string) *DeleteProxyResponse {
	s.Headers = v
	return s
}

func (s *DeleteProxyResponse) SetStatusCode(v int32) *DeleteProxyResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteProxyResponse) SetBody(v *DeleteProxyResponseBody) *DeleteProxyResponse {
	s.Body = v
	return s
}

type DeleteProxyAccessRequest struct {
	// The ID of the security protection authorization. After the security protection agent authorizes the target user, the system automatically generates a security protection authorization ID. The ID is globally unique. You can call the [ListProxyAccesses](https://www.alibabacloud.com/help/en/data-management-service/latest/listproxyaccesses) operation to obtain this parameter.
	ProxyAccessId *int64 `json:"ProxyAccessId,omitempty" xml:"ProxyAccessId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) or [ListUserTenants](https://www.alibabacloud.com/help/en/data-management-service/latest/listusertenants) operation to obtain this parameter.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s DeleteProxyAccessRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteProxyAccessRequest) GoString() string {
	return s.String()
}

func (s *DeleteProxyAccessRequest) SetProxyAccessId(v int64) *DeleteProxyAccessRequest {
	s.ProxyAccessId = &v
	return s
}

func (s *DeleteProxyAccessRequest) SetTid(v int64) *DeleteProxyAccessRequest {
	s.Tid = &v
	return s
}

type DeleteProxyAccessResponseBody struct {
	// The error code returned to the query task.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message that is returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteProxyAccessResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteProxyAccessResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteProxyAccessResponseBody) SetErrorCode(v string) *DeleteProxyAccessResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteProxyAccessResponseBody) SetErrorMessage(v string) *DeleteProxyAccessResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteProxyAccessResponseBody) SetRequestId(v string) *DeleteProxyAccessResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteProxyAccessResponseBody) SetSuccess(v bool) *DeleteProxyAccessResponseBody {
	s.Success = &v
	return s
}

type DeleteProxyAccessResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteProxyAccessResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteProxyAccessResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteProxyAccessResponse) GoString() string {
	return s.String()
}

func (s *DeleteProxyAccessResponse) SetHeaders(v map[string]*string) *DeleteProxyAccessResponse {
	s.Headers = v
	return s
}

func (s *DeleteProxyAccessResponse) SetStatusCode(v int32) *DeleteProxyAccessResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteProxyAccessResponse) SetBody(v *DeleteProxyAccessResponseBody) *DeleteProxyAccessResponse {
	s.Body = v
	return s
}

type DeleteScenarioRequest struct {
	// The ID of the business scenario.
	ScenarioId *int64 `json:"ScenarioId,omitempty" xml:"ScenarioId,omitempty"`
	// The ID of the tenant.
	//
	// >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s DeleteScenarioRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteScenarioRequest) GoString() string {
	return s.String()
}

func (s *DeleteScenarioRequest) SetScenarioId(v int64) *DeleteScenarioRequest {
	s.ScenarioId = &v
	return s
}

func (s *DeleteScenarioRequest) SetTid(v int64) *DeleteScenarioRequest {
	s.Tid = &v
	return s
}

type DeleteScenarioResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteScenarioResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteScenarioResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteScenarioResponseBody) SetErrorCode(v string) *DeleteScenarioResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteScenarioResponseBody) SetErrorMessage(v string) *DeleteScenarioResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteScenarioResponseBody) SetRequestId(v string) *DeleteScenarioResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteScenarioResponseBody) SetSuccess(v bool) *DeleteScenarioResponseBody {
	s.Success = &v
	return s
}

type DeleteScenarioResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteScenarioResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteScenarioResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteScenarioResponse) GoString() string {
	return s.String()
}

func (s *DeleteScenarioResponse) SetHeaders(v map[string]*string) *DeleteScenarioResponse {
	s.Headers = v
	return s
}

func (s *DeleteScenarioResponse) SetStatusCode(v int32) *DeleteScenarioResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteScenarioResponse) SetBody(v *DeleteScenarioResponseBody) *DeleteScenarioResponse {
	s.Body = v
	return s
}

type DeleteStandardGroupRequest struct {
	GroupId *int64 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	Tid     *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s DeleteStandardGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteStandardGroupRequest) GoString() string {
	return s.String()
}

func (s *DeleteStandardGroupRequest) SetGroupId(v int64) *DeleteStandardGroupRequest {
	s.GroupId = &v
	return s
}

func (s *DeleteStandardGroupRequest) SetTid(v int64) *DeleteStandardGroupRequest {
	s.Tid = &v
	return s
}

type DeleteStandardGroupResponseBody struct {
	ErrorCode    *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteStandardGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteStandardGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteStandardGroupResponseBody) SetErrorCode(v string) *DeleteStandardGroupResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteStandardGroupResponseBody) SetErrorMessage(v string) *DeleteStandardGroupResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteStandardGroupResponseBody) SetRequestId(v string) *DeleteStandardGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteStandardGroupResponseBody) SetSuccess(v bool) *DeleteStandardGroupResponseBody {
	s.Success = &v
	return s
}

type DeleteStandardGroupResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteStandardGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteStandardGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteStandardGroupResponse) GoString() string {
	return s.String()
}

func (s *DeleteStandardGroupResponse) SetHeaders(v map[string]*string) *DeleteStandardGroupResponse {
	s.Headers = v
	return s
}

func (s *DeleteStandardGroupResponse) SetStatusCode(v int32) *DeleteStandardGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteStandardGroupResponse) SetBody(v *DeleteStandardGroupResponseBody) *DeleteStandardGroupResponse {
	s.Body = v
	return s
}

type DeleteTaskRequest struct {
	// The ID of the node you want to delete.
	NodeId *string `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The ID of the tenant.
	//
	// >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s DeleteTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteTaskRequest) GoString() string {
	return s.String()
}

func (s *DeleteTaskRequest) SetNodeId(v string) *DeleteTaskRequest {
	s.NodeId = &v
	return s
}

func (s *DeleteTaskRequest) SetTid(v int64) *DeleteTaskRequest {
	s.Tid = &v
	return s
}

type DeleteTaskResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteTaskResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteTaskResponseBody) SetErrorCode(v string) *DeleteTaskResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteTaskResponseBody) SetErrorMessage(v string) *DeleteTaskResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteTaskResponseBody) SetRequestId(v string) *DeleteTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteTaskResponseBody) SetSuccess(v bool) *DeleteTaskResponseBody {
	s.Success = &v
	return s
}

type DeleteTaskResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteTaskResponse) GoString() string {
	return s.String()
}

func (s *DeleteTaskResponse) SetHeaders(v map[string]*string) *DeleteTaskResponse {
	s.Headers = v
	return s
}

func (s *DeleteTaskResponse) SetStatusCode(v int32) *DeleteTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteTaskResponse) SetBody(v *DeleteTaskResponseBody) *DeleteTaskResponse {
	s.Body = v
	return s
}

type DeleteTaskFlowRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the ID of the task flow.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s DeleteTaskFlowRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteTaskFlowRequest) GoString() string {
	return s.String()
}

func (s *DeleteTaskFlowRequest) SetDagId(v int64) *DeleteTaskFlowRequest {
	s.DagId = &v
	return s
}

func (s *DeleteTaskFlowRequest) SetTid(v int64) *DeleteTaskFlowRequest {
	s.Tid = &v
	return s
}

type DeleteTaskFlowResponseBody struct {
	// The error code returned if the request fails.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**: The request is successful.
	// *   **false**: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteTaskFlowResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteTaskFlowResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteTaskFlowResponseBody) SetErrorCode(v string) *DeleteTaskFlowResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteTaskFlowResponseBody) SetErrorMessage(v string) *DeleteTaskFlowResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteTaskFlowResponseBody) SetRequestId(v string) *DeleteTaskFlowResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteTaskFlowResponseBody) SetSuccess(v bool) *DeleteTaskFlowResponseBody {
	s.Success = &v
	return s
}

type DeleteTaskFlowResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteTaskFlowResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteTaskFlowResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteTaskFlowResponse) GoString() string {
	return s.String()
}

func (s *DeleteTaskFlowResponse) SetHeaders(v map[string]*string) *DeleteTaskFlowResponse {
	s.Headers = v
	return s
}

func (s *DeleteTaskFlowResponse) SetStatusCode(v int32) *DeleteTaskFlowResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteTaskFlowResponse) SetBody(v *DeleteTaskFlowResponseBody) *DeleteTaskFlowResponse {
	s.Body = v
	return s
}

type DeleteTaskFlowEdgesByConditionRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the task flow edge to delete.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the end node of the edge to delete.
	NodeEnd *int64 `json:"NodeEnd,omitempty" xml:"NodeEnd,omitempty"`
	// The ID of the start node on the edge to delete.
	NodeFrom *int64 `json:"NodeFrom,omitempty" xml:"NodeFrom,omitempty"`
	// The ID of the tenant.
	//
	// >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s DeleteTaskFlowEdgesByConditionRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteTaskFlowEdgesByConditionRequest) GoString() string {
	return s.String()
}

func (s *DeleteTaskFlowEdgesByConditionRequest) SetDagId(v int64) *DeleteTaskFlowEdgesByConditionRequest {
	s.DagId = &v
	return s
}

func (s *DeleteTaskFlowEdgesByConditionRequest) SetId(v int64) *DeleteTaskFlowEdgesByConditionRequest {
	s.Id = &v
	return s
}

func (s *DeleteTaskFlowEdgesByConditionRequest) SetNodeEnd(v int64) *DeleteTaskFlowEdgesByConditionRequest {
	s.NodeEnd = &v
	return s
}

func (s *DeleteTaskFlowEdgesByConditionRequest) SetNodeFrom(v int64) *DeleteTaskFlowEdgesByConditionRequest {
	s.NodeFrom = &v
	return s
}

func (s *DeleteTaskFlowEdgesByConditionRequest) SetTid(v int64) *DeleteTaskFlowEdgesByConditionRequest {
	s.Tid = &v
	return s
}

type DeleteTaskFlowEdgesByConditionResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can use the ID to locate logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteTaskFlowEdgesByConditionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteTaskFlowEdgesByConditionResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteTaskFlowEdgesByConditionResponseBody) SetErrorCode(v string) *DeleteTaskFlowEdgesByConditionResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteTaskFlowEdgesByConditionResponseBody) SetErrorMessage(v string) *DeleteTaskFlowEdgesByConditionResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteTaskFlowEdgesByConditionResponseBody) SetRequestId(v string) *DeleteTaskFlowEdgesByConditionResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteTaskFlowEdgesByConditionResponseBody) SetSuccess(v bool) *DeleteTaskFlowEdgesByConditionResponseBody {
	s.Success = &v
	return s
}

type DeleteTaskFlowEdgesByConditionResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteTaskFlowEdgesByConditionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteTaskFlowEdgesByConditionResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteTaskFlowEdgesByConditionResponse) GoString() string {
	return s.String()
}

func (s *DeleteTaskFlowEdgesByConditionResponse) SetHeaders(v map[string]*string) *DeleteTaskFlowEdgesByConditionResponse {
	s.Headers = v
	return s
}

func (s *DeleteTaskFlowEdgesByConditionResponse) SetStatusCode(v int32) *DeleteTaskFlowEdgesByConditionResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteTaskFlowEdgesByConditionResponse) SetBody(v *DeleteTaskFlowEdgesByConditionResponseBody) *DeleteTaskFlowEdgesByConditionResponse {
	s.Body = v
	return s
}

type DeleteUserRequest struct {
	// The ID of the tenant.
	//
	// >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://www.alibabacloud.com/help/en/data-management-service/latest/manage-dms-tenants) topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The unique ID (UID) of Alibaba Cloud account to delete.
	Uid *string `json:"Uid,omitempty" xml:"Uid,omitempty"`
}

func (s DeleteUserRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteUserRequest) GoString() string {
	return s.String()
}

func (s *DeleteUserRequest) SetTid(v int64) *DeleteUserRequest {
	s.Tid = &v
	return s
}

func (s *DeleteUserRequest) SetUid(v string) *DeleteUserRequest {
	s.Uid = &v
	return s
}

type DeleteUserResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteUserResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteUserResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteUserResponseBody) SetErrorCode(v string) *DeleteUserResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteUserResponseBody) SetErrorMessage(v string) *DeleteUserResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteUserResponseBody) SetRequestId(v string) *DeleteUserResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteUserResponseBody) SetSuccess(v bool) *DeleteUserResponseBody {
	s.Success = &v
	return s
}

type DeleteUserResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteUserResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteUserResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteUserResponse) GoString() string {
	return s.String()
}

func (s *DeleteUserResponse) SetHeaders(v map[string]*string) *DeleteUserResponse {
	s.Headers = v
	return s
}

func (s *DeleteUserResponse) SetStatusCode(v int32) *DeleteUserResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteUserResponse) SetBody(v *DeleteUserResponseBody) *DeleteUserResponse {
	s.Body = v
	return s
}

type DisableUserRequest struct {
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The UID of the Alibaba Cloud account.
	Uid *string `json:"Uid,omitempty" xml:"Uid,omitempty"`
}

func (s DisableUserRequest) String() string {
	return tea.Prettify(s)
}

func (s DisableUserRequest) GoString() string {
	return s.String()
}

func (s *DisableUserRequest) SetTid(v int64) *DisableUserRequest {
	s.Tid = &v
	return s
}

func (s *DisableUserRequest) SetUid(v string) *DisableUserRequest {
	s.Uid = &v
	return s
}

type DisableUserResponseBody struct {
	// The error code returned if the request fails.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// - true: The request is successful.
	// - false: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DisableUserResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DisableUserResponseBody) GoString() string {
	return s.String()
}

func (s *DisableUserResponseBody) SetErrorCode(v string) *DisableUserResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DisableUserResponseBody) SetErrorMessage(v string) *DisableUserResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DisableUserResponseBody) SetRequestId(v string) *DisableUserResponseBody {
	s.RequestId = &v
	return s
}

func (s *DisableUserResponseBody) SetSuccess(v bool) *DisableUserResponseBody {
	s.Success = &v
	return s
}

type DisableUserResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DisableUserResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DisableUserResponse) String() string {
	return tea.Prettify(s)
}

func (s DisableUserResponse) GoString() string {
	return s.String()
}

func (s *DisableUserResponse) SetHeaders(v map[string]*string) *DisableUserResponse {
	s.Headers = v
	return s
}

func (s *DisableUserResponse) SetStatusCode(v int32) *DisableUserResponse {
	s.StatusCode = &v
	return s
}

func (s *DisableUserResponse) SetBody(v *DisableUserResponseBody) *DisableUserResponse {
	s.Body = v
	return s
}

type DownloadDataTrackResultRequest struct {
	// The condition to filter columns.
	ColumnFilter *DownloadDataTrackResultRequestColumnFilter `json:"ColumnFilter,omitempty" xml:"ColumnFilter,omitempty" type:"Struct"`
	// The IDs of the events.
	EventIdList []*int64 `json:"EventIdList,omitempty" xml:"EventIdList,omitempty" type:"Repeated"`
	// The end time of the time range in which you want to track data operations. The time must be specified in the yyyy-MM-dd HH:mm:ss format.
	FilterEndTime *string `json:"FilterEndTime,omitempty" xml:"FilterEndTime,omitempty"`
	// The start time of the time range in which you want to track data operations. The time must be specified in the yyyy-MM-dd HH:mm:ss format.
	FilterStartTime *string `json:"FilterStartTime,omitempty" xml:"FilterStartTime,omitempty"`
	// The names of the tables for which you want to track data operations.
	FilterTableList []*string `json:"FilterTableList,omitempty" xml:"FilterTableList,omitempty" type:"Repeated"`
	// The types of data operations that you want to track.
	FilterTypeList []*string `json:"FilterTypeList,omitempty" xml:"FilterTypeList,omitempty" type:"Repeated"`
	// The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to obtain the ticket ID.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The type of the SQL statement.
	//
	// *   **REVERSE**: undoes or rolls back an executed SQL statement, which is equivalent to the UNDO SQL statement.
	// *   **FORWARD**: redoes or re-executes an SQL statement that failed to be executed, which is equivalent to the REDO SQL statement.
	RollbackSQLType *string `json:"RollbackSQLType,omitempty" xml:"RollbackSQLType,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s DownloadDataTrackResultRequest) String() string {
	return tea.Prettify(s)
}

func (s DownloadDataTrackResultRequest) GoString() string {
	return s.String()
}

func (s *DownloadDataTrackResultRequest) SetColumnFilter(v *DownloadDataTrackResultRequestColumnFilter) *DownloadDataTrackResultRequest {
	s.ColumnFilter = v
	return s
}

func (s *DownloadDataTrackResultRequest) SetEventIdList(v []*int64) *DownloadDataTrackResultRequest {
	s.EventIdList = v
	return s
}

func (s *DownloadDataTrackResultRequest) SetFilterEndTime(v string) *DownloadDataTrackResultRequest {
	s.FilterEndTime = &v
	return s
}

func (s *DownloadDataTrackResultRequest) SetFilterStartTime(v string) *DownloadDataTrackResultRequest {
	s.FilterStartTime = &v
	return s
}

func (s *DownloadDataTrackResultRequest) SetFilterTableList(v []*string) *DownloadDataTrackResultRequest {
	s.FilterTableList = v
	return s
}

func (s *DownloadDataTrackResultRequest) SetFilterTypeList(v []*string) *DownloadDataTrackResultRequest {
	s.FilterTypeList = v
	return s
}

func (s *DownloadDataTrackResultRequest) SetOrderId(v int64) *DownloadDataTrackResultRequest {
	s.OrderId = &v
	return s
}

func (s *DownloadDataTrackResultRequest) SetRollbackSQLType(v string) *DownloadDataTrackResultRequest {
	s.RollbackSQLType = &v
	return s
}

func (s *DownloadDataTrackResultRequest) SetTid(v int64) *DownloadDataTrackResultRequest {
	s.Tid = &v
	return s
}

type DownloadDataTrackResultRequestColumnFilter struct {
	// The end value of the range used in the filter condition. This parameter takes effect only when Operator is set to BETWEEN.
	BetweenEnd *string `json:"BetweenEnd,omitempty" xml:"BetweenEnd,omitempty"`
	// The start value of the range used in the filter condition. This parameter takes effect only when Operator is set to BETWEEN.
	BetweenStart *string `json:"BetweenStart,omitempty" xml:"BetweenStart,omitempty"`
	// The name of the column.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The IN list used in the filter condition.
	InList []*string `json:"InList,omitempty" xml:"InList,omitempty" type:"Repeated"`
	// The type of the operator used to configure the filter condition. Valid values:
	//
	// *   **EQUAL**: retrieves the column whose value is equal to the specified value.
	// *   **NOT_EQUAL**: retrieves the column whose value is not equal to the specified value.
	// *   **IN**: retrieves the column whose value is in the IN list.
	// *   **BETWEEN**: retrieves the column whose value is in the specified range.
	// *   **LESS**: retrieves the column whose value is less than the specified value.
	// *   **MORE**: retrieves the column whose value is greater than the specified value.
	// *   **NOT_IN**: retrieves the column whose value is not in the IN list.
	Operator *string `json:"Operator,omitempty" xml:"Operator,omitempty"`
	// The value used in the filter condition.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DownloadDataTrackResultRequestColumnFilter) String() string {
	return tea.Prettify(s)
}

func (s DownloadDataTrackResultRequestColumnFilter) GoString() string {
	return s.String()
}

func (s *DownloadDataTrackResultRequestColumnFilter) SetBetweenEnd(v string) *DownloadDataTrackResultRequestColumnFilter {
	s.BetweenEnd = &v
	return s
}

func (s *DownloadDataTrackResultRequestColumnFilter) SetBetweenStart(v string) *DownloadDataTrackResultRequestColumnFilter {
	s.BetweenStart = &v
	return s
}

func (s *DownloadDataTrackResultRequestColumnFilter) SetColumnName(v string) *DownloadDataTrackResultRequestColumnFilter {
	s.ColumnName = &v
	return s
}

func (s *DownloadDataTrackResultRequestColumnFilter) SetInList(v []*string) *DownloadDataTrackResultRequestColumnFilter {
	s.InList = v
	return s
}

func (s *DownloadDataTrackResultRequestColumnFilter) SetOperator(v string) *DownloadDataTrackResultRequestColumnFilter {
	s.Operator = &v
	return s
}

func (s *DownloadDataTrackResultRequestColumnFilter) SetValue(v string) *DownloadDataTrackResultRequestColumnFilter {
	s.Value = &v
	return s
}

type DownloadDataTrackResultShrinkRequest struct {
	// The condition to filter columns.
	ColumnFilterShrink *string `json:"ColumnFilter,omitempty" xml:"ColumnFilter,omitempty"`
	// The IDs of the events.
	EventIdListShrink *string `json:"EventIdList,omitempty" xml:"EventIdList,omitempty"`
	// The end time of the time range in which you want to track data operations. The time must be specified in the yyyy-MM-dd HH:mm:ss format.
	FilterEndTime *string `json:"FilterEndTime,omitempty" xml:"FilterEndTime,omitempty"`
	// The start time of the time range in which you want to track data operations. The time must be specified in the yyyy-MM-dd HH:mm:ss format.
	FilterStartTime *string `json:"FilterStartTime,omitempty" xml:"FilterStartTime,omitempty"`
	// The names of the tables for which you want to track data operations.
	FilterTableListShrink *string `json:"FilterTableList,omitempty" xml:"FilterTableList,omitempty"`
	// The types of data operations that you want to track.
	FilterTypeListShrink *string `json:"FilterTypeList,omitempty" xml:"FilterTypeList,omitempty"`
	// The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to obtain the ticket ID.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The type of the SQL statement.
	//
	// *   **REVERSE**: undoes or rolls back an executed SQL statement, which is equivalent to the UNDO SQL statement.
	// *   **FORWARD**: redoes or re-executes an SQL statement that failed to be executed, which is equivalent to the REDO SQL statement.
	RollbackSQLType *string `json:"RollbackSQLType,omitempty" xml:"RollbackSQLType,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s DownloadDataTrackResultShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s DownloadDataTrackResultShrinkRequest) GoString() string {
	return s.String()
}

func (s *DownloadDataTrackResultShrinkRequest) SetColumnFilterShrink(v string) *DownloadDataTrackResultShrinkRequest {
	s.ColumnFilterShrink = &v
	return s
}

func (s *DownloadDataTrackResultShrinkRequest) SetEventIdListShrink(v string) *DownloadDataTrackResultShrinkRequest {
	s.EventIdListShrink = &v
	return s
}

func (s *DownloadDataTrackResultShrinkRequest) SetFilterEndTime(v string) *DownloadDataTrackResultShrinkRequest {
	s.FilterEndTime = &v
	return s
}

func (s *DownloadDataTrackResultShrinkRequest) SetFilterStartTime(v string) *DownloadDataTrackResultShrinkRequest {
	s.FilterStartTime = &v
	return s
}

func (s *DownloadDataTrackResultShrinkRequest) SetFilterTableListShrink(v string) *DownloadDataTrackResultShrinkRequest {
	s.FilterTableListShrink = &v
	return s
}

func (s *DownloadDataTrackResultShrinkRequest) SetFilterTypeListShrink(v string) *DownloadDataTrackResultShrinkRequest {
	s.FilterTypeListShrink = &v
	return s
}

func (s *DownloadDataTrackResultShrinkRequest) SetOrderId(v int64) *DownloadDataTrackResultShrinkRequest {
	s.OrderId = &v
	return s
}

func (s *DownloadDataTrackResultShrinkRequest) SetRollbackSQLType(v string) *DownloadDataTrackResultShrinkRequest {
	s.RollbackSQLType = &v
	return s
}

func (s *DownloadDataTrackResultShrinkRequest) SetTid(v int64) *DownloadDataTrackResultShrinkRequest {
	s.Tid = &v
	return s
}

type DownloadDataTrackResultResponseBody struct {
	// The ID of the download key, which is used to download the parsing result of the data tracking task.
	DownloadKeyId *string `json:"DownloadKeyId,omitempty" xml:"DownloadKeyId,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DownloadDataTrackResultResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DownloadDataTrackResultResponseBody) GoString() string {
	return s.String()
}

func (s *DownloadDataTrackResultResponseBody) SetDownloadKeyId(v string) *DownloadDataTrackResultResponseBody {
	s.DownloadKeyId = &v
	return s
}

func (s *DownloadDataTrackResultResponseBody) SetErrorCode(v string) *DownloadDataTrackResultResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DownloadDataTrackResultResponseBody) SetErrorMessage(v string) *DownloadDataTrackResultResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DownloadDataTrackResultResponseBody) SetRequestId(v string) *DownloadDataTrackResultResponseBody {
	s.RequestId = &v
	return s
}

func (s *DownloadDataTrackResultResponseBody) SetSuccess(v bool) *DownloadDataTrackResultResponseBody {
	s.Success = &v
	return s
}

type DownloadDataTrackResultResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DownloadDataTrackResultResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DownloadDataTrackResultResponse) String() string {
	return tea.Prettify(s)
}

func (s DownloadDataTrackResultResponse) GoString() string {
	return s.String()
}

func (s *DownloadDataTrackResultResponse) SetHeaders(v map[string]*string) *DownloadDataTrackResultResponse {
	s.Headers = v
	return s
}

func (s *DownloadDataTrackResultResponse) SetStatusCode(v int32) *DownloadDataTrackResultResponse {
	s.StatusCode = &v
	return s
}

func (s *DownloadDataTrackResultResponse) SetBody(v *DownloadDataTrackResultResponseBody) *DownloadDataTrackResultResponse {
	s.Body = v
	return s
}

type EditLogicDatabaseRequest struct {
	// - The alias of the logical database. If you want to change the alias, specify a new alias.
	// - If you do not need to change the alias of the logical database, call the [GetLogicDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/getlogicdatabase) or [GetDBTopology](https://www.alibabacloud.com/help/en/data-management-service/latest/getdbtopology) operation to query the alias of the logical database.
	Alias *string `json:"Alias,omitempty" xml:"Alias,omitempty"`
	// - The IDs of the physical databases that compose the logical database. If you want to change the physical databases, you can call the [ListDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listdatabases) or [SearchDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/searchdatabase) operation to query the IDs of the new physical databases that you want to specify.
	// - If you do not want to change the physical databases, you can call the [GetDBTopology](https://www.alibabacloud.com/help/en/data-management-service/latest/getdbtopology) operation to query the IDs of the physical databases that compose the logical database.
	DatabaseIds []*int64 `json:"DatabaseIds,omitempty" xml:"DatabaseIds,omitempty" type:"Repeated"`
	// The ID of the logical database. You can call the [ListLogicDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogicdatabases) operation to query the ID of the logical database.
	LogicDbId *int64 `json:"LogicDbId,omitempty" xml:"LogicDbId,omitempty"`
	// The ID of the tenant.
	//
	// >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://www.alibabacloud.com/help/en/data-management-service/latest/manage-dms-tenants) topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s EditLogicDatabaseRequest) String() string {
	return tea.Prettify(s)
}

func (s EditLogicDatabaseRequest) GoString() string {
	return s.String()
}

func (s *EditLogicDatabaseRequest) SetAlias(v string) *EditLogicDatabaseRequest {
	s.Alias = &v
	return s
}

func (s *EditLogicDatabaseRequest) SetDatabaseIds(v []*int64) *EditLogicDatabaseRequest {
	s.DatabaseIds = v
	return s
}

func (s *EditLogicDatabaseRequest) SetLogicDbId(v int64) *EditLogicDatabaseRequest {
	s.LogicDbId = &v
	return s
}

func (s *EditLogicDatabaseRequest) SetTid(v int64) *EditLogicDatabaseRequest {
	s.Tid = &v
	return s
}

type EditLogicDatabaseShrinkRequest struct {
	// - The alias of the logical database. If you want to change the alias, specify a new alias.
	// - If you do not need to change the alias of the logical database, call the [GetLogicDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/getlogicdatabase) or [GetDBTopology](https://www.alibabacloud.com/help/en/data-management-service/latest/getdbtopology) operation to query the alias of the logical database.
	Alias *string `json:"Alias,omitempty" xml:"Alias,omitempty"`
	// - The IDs of the physical databases that compose the logical database. If you want to change the physical databases, you can call the [ListDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listdatabases) or [SearchDatabase](https://www.alibabacloud.com/help/en/data-management-service/latest/searchdatabase) operation to query the IDs of the new physical databases that you want to specify.
	// - If you do not want to change the physical databases, you can call the [GetDBTopology](https://www.alibabacloud.com/help/en/data-management-service/latest/getdbtopology) operation to query the IDs of the physical databases that compose the logical database.
	DatabaseIdsShrink *string `json:"DatabaseIds,omitempty" xml:"DatabaseIds,omitempty"`
	// The ID of the logical database. You can call the [ListLogicDatabases](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogicdatabases) operation to query the ID of the logical database.
	LogicDbId *int64 `json:"LogicDbId,omitempty" xml:"LogicDbId,omitempty"`
	// The ID of the tenant.
	//
	// >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](https://www.alibabacloud.com/help/en/data-management-service/latest/manage-dms-tenants) topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s EditLogicDatabaseShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s EditLogicDatabaseShrinkRequest) GoString() string {
	return s.String()
}

func (s *EditLogicDatabaseShrinkRequest) SetAlias(v string) *EditLogicDatabaseShrinkRequest {
	s.Alias = &v
	return s
}

func (s *EditLogicDatabaseShrinkRequest) SetDatabaseIdsShrink(v string) *EditLogicDatabaseShrinkRequest {
	s.DatabaseIdsShrink = &v
	return s
}

func (s *EditLogicDatabaseShrinkRequest) SetLogicDbId(v int64) *EditLogicDatabaseShrinkRequest {
	s.LogicDbId = &v
	return s
}

func (s *EditLogicDatabaseShrinkRequest) SetTid(v int64) *EditLogicDatabaseShrinkRequest {
	s.Tid = &v
	return s
}

type EditLogicDatabaseResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// - true: The request is successful.
	// - false: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s EditLogicDatabaseResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EditLogicDatabaseResponseBody) GoString() string {
	return s.String()
}

func (s *EditLogicDatabaseResponseBody) SetErrorCode(v string) *EditLogicDatabaseResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *EditLogicDatabaseResponseBody) SetErrorMessage(v string) *EditLogicDatabaseResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *EditLogicDatabaseResponseBody) SetRequestId(v string) *EditLogicDatabaseResponseBody {
	s.RequestId = &v
	return s
}

func (s *EditLogicDatabaseResponseBody) SetSuccess(v bool) *EditLogicDatabaseResponseBody {
	s.Success = &v
	return s
}

type EditLogicDatabaseResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *EditLogicDatabaseResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s EditLogicDatabaseResponse) String() string {
	return tea.Prettify(s)
}

func (s EditLogicDatabaseResponse) GoString() string {
	return s.String()
}

func (s *EditLogicDatabaseResponse) SetHeaders(v map[string]*string) *EditLogicDatabaseResponse {
	s.Headers = v
	return s
}

func (s *EditLogicDatabaseResponse) SetStatusCode(v int32) *EditLogicDatabaseResponse {
	s.StatusCode = &v
	return s
}

func (s *EditLogicDatabaseResponse) SetBody(v *EditLogicDatabaseResponseBody) *EditLogicDatabaseResponse {
	s.Body = v
	return s
}

type EnableUserRequest struct {
	// The ID of the tenant.
	//
	// >  To obtain the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Tenant information](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The UID of the Alibaba Cloud account.
	Uid *string `json:"Uid,omitempty" xml:"Uid,omitempty"`
}

func (s EnableUserRequest) String() string {
	return tea.Prettify(s)
}

func (s EnableUserRequest) GoString() string {
	return s.String()
}

func (s *EnableUserRequest) SetTid(v int64) *EnableUserRequest {
	s.Tid = &v
	return s
}

func (s *EnableUserRequest) SetUid(v string) *EnableUserRequest {
	s.Uid = &v
	return s
}

type EnableUserResponseBody struct {
	// The error code returned if the request fails.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**: The request is successful.
	// *   **false**: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s EnableUserResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EnableUserResponseBody) GoString() string {
	return s.String()
}

func (s *EnableUserResponseBody) SetErrorCode(v string) *EnableUserResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *EnableUserResponseBody) SetErrorMessage(v string) *EnableUserResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *EnableUserResponseBody) SetRequestId(v string) *EnableUserResponseBody {
	s.RequestId = &v
	return s
}

func (s *EnableUserResponseBody) SetSuccess(v bool) *EnableUserResponseBody {
	s.Success = &v
	return s
}

type EnableUserResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *EnableUserResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s EnableUserResponse) String() string {
	return tea.Prettify(s)
}

func (s EnableUserResponse) GoString() string {
	return s.String()
}

func (s *EnableUserResponse) SetHeaders(v map[string]*string) *EnableUserResponse {
	s.Headers = v
	return s
}

func (s *EnableUserResponse) SetStatusCode(v int32) *EnableUserResponse {
	s.StatusCode = &v
	return s
}

func (s *EnableUserResponse) SetBody(v *EnableUserResponseBody) *EnableUserResponse {
	s.Body = v
	return s
}

type ExecuteDataCorrectRequest struct {
	// The parameters that are required to perform the data change.
	//
	// ```
	//
	// json
	// "actionDetail" : {
	//     "startTime" :"2021-07-01 00:00:00", // Specify the start time to change data. If you want to immediately change data, you do not need to set this parameter.
	//     "endTime" : "2021-07-01 01:00:00", // Specify the end time to change data. If you want to immediately change data, you do not need to set this parameter.
	//     "transaction" : false, // Specify whether to change data as a transaction.
	//     "backupData" : true // Specify whether to back up data.
	//   }
	// ```
	ActionDetail map[string]interface{} `json:"ActionDetail,omitempty" xml:"ActionDetail,omitempty"`
	// The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to query the ID of the ticket.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
	Tid *string `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ExecuteDataCorrectRequest) String() string {
	return tea.Prettify(s)
}

func (s ExecuteDataCorrectRequest) GoString() string {
	return s.String()
}

func (s *ExecuteDataCorrectRequest) SetActionDetail(v map[string]interface{}) *ExecuteDataCorrectRequest {
	s.ActionDetail = v
	return s
}

func (s *ExecuteDataCorrectRequest) SetOrderId(v int64) *ExecuteDataCorrectRequest {
	s.OrderId = &v
	return s
}

func (s *ExecuteDataCorrectRequest) SetTid(v string) *ExecuteDataCorrectRequest {
	s.Tid = &v
	return s
}

type ExecuteDataCorrectShrinkRequest struct {
	// The parameters that are required to perform the data change.
	//
	// ```
	//
	// json
	// "actionDetail" : {
	//     "startTime" :"2021-07-01 00:00:00", // Specify the start time to change data. If you want to immediately change data, you do not need to set this parameter.
	//     "endTime" : "2021-07-01 01:00:00", // Specify the end time to change data. If you want to immediately change data, you do not need to set this parameter.
	//     "transaction" : false, // Specify whether to change data as a transaction.
	//     "backupData" : true // Specify whether to back up data.
	//   }
	// ```
	ActionDetailShrink *string `json:"ActionDetail,omitempty" xml:"ActionDetail,omitempty"`
	// The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to query the ID of the ticket.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
	Tid *string `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ExecuteDataCorrectShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ExecuteDataCorrectShrinkRequest) GoString() string {
	return s.String()
}

func (s *ExecuteDataCorrectShrinkRequest) SetActionDetailShrink(v string) *ExecuteDataCorrectShrinkRequest {
	s.ActionDetailShrink = &v
	return s
}

func (s *ExecuteDataCorrectShrinkRequest) SetOrderId(v int64) *ExecuteDataCorrectShrinkRequest {
	s.OrderId = &v
	return s
}

func (s *ExecuteDataCorrectShrinkRequest) SetTid(v string) *ExecuteDataCorrectShrinkRequest {
	s.Tid = &v
	return s
}

type ExecuteDataCorrectResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**: The request is successful.
	// *   **false**: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ExecuteDataCorrectResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ExecuteDataCorrectResponseBody) GoString() string {
	return s.String()
}

func (s *ExecuteDataCorrectResponseBody) SetErrorCode(v string) *ExecuteDataCorrectResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ExecuteDataCorrectResponseBody) SetErrorMessage(v string) *ExecuteDataCorrectResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ExecuteDataCorrectResponseBody) SetRequestId(v string) *ExecuteDataCorrectResponseBody {
	s.RequestId = &v
	return s
}

func (s *ExecuteDataCorrectResponseBody) SetSuccess(v bool) *ExecuteDataCorrectResponseBody {
	s.Success = &v
	return s
}

type ExecuteDataCorrectResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ExecuteDataCorrectResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ExecuteDataCorrectResponse) String() string {
	return tea.Prettify(s)
}

func (s ExecuteDataCorrectResponse) GoString() string {
	return s.String()
}

func (s *ExecuteDataCorrectResponse) SetHeaders(v map[string]*string) *ExecuteDataCorrectResponse {
	s.Headers = v
	return s
}

func (s *ExecuteDataCorrectResponse) SetStatusCode(v int32) *ExecuteDataCorrectResponse {
	s.StatusCode = &v
	return s
}

func (s *ExecuteDataCorrectResponse) SetBody(v *ExecuteDataCorrectResponseBody) *ExecuteDataCorrectResponse {
	s.Body = v
	return s
}

type ExecuteDataExportRequest struct {
	// The parameters that are required to perform the operation:
	//
	// ```json
	// {
	//    "fileType": "CSV", // The format of the exported file.
	//    "encoding": "" // The encoding format.
	//  }
	// ```
	ActionDetail map[string]interface{} `json:"ActionDetail,omitempty" xml:"ActionDetail,omitempty"`
	// The ID of the ticket.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant.
	//
	// > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ExecuteDataExportRequest) String() string {
	return tea.Prettify(s)
}

func (s ExecuteDataExportRequest) GoString() string {
	return s.String()
}

func (s *ExecuteDataExportRequest) SetActionDetail(v map[string]interface{}) *ExecuteDataExportRequest {
	s.ActionDetail = v
	return s
}

func (s *ExecuteDataExportRequest) SetOrderId(v int64) *ExecuteDataExportRequest {
	s.OrderId = &v
	return s
}

func (s *ExecuteDataExportRequest) SetTid(v int64) *ExecuteDataExportRequest {
	s.Tid = &v
	return s
}

type ExecuteDataExportShrinkRequest struct {
	// The parameters that are required to perform the operation:
	//
	// ```json
	// {
	//    "fileType": "CSV", // The format of the exported file.
	//    "encoding": "" // The encoding format.
	//  }
	// ```
	ActionDetailShrink *string `json:"ActionDetail,omitempty" xml:"ActionDetail,omitempty"`
	// The ID of the ticket.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant.
	//
	// > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ExecuteDataExportShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ExecuteDataExportShrinkRequest) GoString() string {
	return s.String()
}

func (s *ExecuteDataExportShrinkRequest) SetActionDetailShrink(v string) *ExecuteDataExportShrinkRequest {
	s.ActionDetailShrink = &v
	return s
}

func (s *ExecuteDataExportShrinkRequest) SetOrderId(v int64) *ExecuteDataExportShrinkRequest {
	s.OrderId = &v
	return s
}

func (s *ExecuteDataExportShrinkRequest) SetTid(v int64) *ExecuteDataExportShrinkRequest {
	s.Tid = &v
	return s
}

type ExecuteDataExportResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ExecuteDataExportResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ExecuteDataExportResponseBody) GoString() string {
	return s.String()
}

func (s *ExecuteDataExportResponseBody) SetErrorCode(v string) *ExecuteDataExportResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ExecuteDataExportResponseBody) SetErrorMessage(v string) *ExecuteDataExportResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ExecuteDataExportResponseBody) SetRequestId(v string) *ExecuteDataExportResponseBody {
	s.RequestId = &v
	return s
}

func (s *ExecuteDataExportResponseBody) SetSuccess(v bool) *ExecuteDataExportResponseBody {
	s.Success = &v
	return s
}

type ExecuteDataExportResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ExecuteDataExportResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ExecuteDataExportResponse) String() string {
	return tea.Prettify(s)
}

func (s ExecuteDataExportResponse) GoString() string {
	return s.String()
}

func (s *ExecuteDataExportResponse) SetHeaders(v map[string]*string) *ExecuteDataExportResponse {
	s.Headers = v
	return s
}

func (s *ExecuteDataExportResponse) SetStatusCode(v int32) *ExecuteDataExportResponse {
	s.StatusCode = &v
	return s
}

func (s *ExecuteDataExportResponse) SetBody(v *ExecuteDataExportResponseBody) *ExecuteDataExportResponse {
	s.Body = v
	return s
}

type ExecuteScriptRequest struct {
	// The ID of the database.
	//
	// >  This parameter is equivalent to the DatabaseId parameter in the SearchDatabase, ListDatabases, and GetDatabase operations. You can call one of these operations to obtain the required database ID. For more information, see [SearchDatabase](~~141876~~), [ListDatabases](~~141873~~), and [GetDatabase](~~141869~~).
	DbId *int32 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// Specifies whether the database is a logical database.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The SQL statements to be executed. Data query language (DQL) statements, data definition language (DDL) statements, and data manipulation language (DML) statements are supported. The control mode of the instance that you want to query determines whether you can execute DDL and DML statements.
	Script *string `json:"Script,omitempty" xml:"Script,omitempty"`
	// The ID of the tenant.
	//
	// >  To obtain the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Tenant information](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ExecuteScriptRequest) String() string {
	return tea.Prettify(s)
}

func (s ExecuteScriptRequest) GoString() string {
	return s.String()
}

func (s *ExecuteScriptRequest) SetDbId(v int32) *ExecuteScriptRequest {
	s.DbId = &v
	return s
}

func (s *ExecuteScriptRequest) SetLogic(v bool) *ExecuteScriptRequest {
	s.Logic = &v
	return s
}

func (s *ExecuteScriptRequest) SetScript(v string) *ExecuteScriptRequest {
	s.Script = &v
	return s
}

func (s *ExecuteScriptRequest) SetTid(v int64) *ExecuteScriptRequest {
	s.Tid = &v
	return s
}

type ExecuteScriptResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message about the gateway.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The results of the SQL statements that are executed, in the format of an array. Each entry in the array indicates the result of an SQL statement.
	Results []*ExecuteScriptResponseBodyResults `json:"Results,omitempty" xml:"Results,omitempty" type:"Repeated"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ExecuteScriptResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ExecuteScriptResponseBody) GoString() string {
	return s.String()
}

func (s *ExecuteScriptResponseBody) SetErrorCode(v string) *ExecuteScriptResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ExecuteScriptResponseBody) SetErrorMessage(v string) *ExecuteScriptResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ExecuteScriptResponseBody) SetRequestId(v string) *ExecuteScriptResponseBody {
	s.RequestId = &v
	return s
}

func (s *ExecuteScriptResponseBody) SetResults(v []*ExecuteScriptResponseBodyResults) *ExecuteScriptResponseBody {
	s.Results = v
	return s
}

func (s *ExecuteScriptResponseBody) SetSuccess(v bool) *ExecuteScriptResponseBody {
	s.Success = &v
	return s
}

type ExecuteScriptResponseBodyResults struct {
	// The fields that are queried after the SQL statement is executed.
	ColumnNames []*string `json:"ColumnNames,omitempty" xml:"ColumnNames,omitempty" type:"Repeated"`
	// The error message that is returned if the SQL statement fails to be executed. For example, an error message is returned because the SQL statement is invalid.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The total number of entries that are returned.
	RowCount *int64 `json:"RowCount,omitempty" xml:"RowCount,omitempty"`
	// The rows that are queried after the SQL statement is executed.
	Rows []map[string]interface{} `json:"Rows,omitempty" xml:"Rows,omitempty" type:"Repeated"`
	// Indicates whether the SQL statement is executed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ExecuteScriptResponseBodyResults) String() string {
	return tea.Prettify(s)
}

func (s ExecuteScriptResponseBodyResults) GoString() string {
	return s.String()
}

func (s *ExecuteScriptResponseBodyResults) SetColumnNames(v []*string) *ExecuteScriptResponseBodyResults {
	s.ColumnNames = v
	return s
}

func (s *ExecuteScriptResponseBodyResults) SetMessage(v string) *ExecuteScriptResponseBodyResults {
	s.Message = &v
	return s
}

func (s *ExecuteScriptResponseBodyResults) SetRowCount(v int64) *ExecuteScriptResponseBodyResults {
	s.RowCount = &v
	return s
}

func (s *ExecuteScriptResponseBodyResults) SetRows(v []map[string]interface{}) *ExecuteScriptResponseBodyResults {
	s.Rows = v
	return s
}

func (s *ExecuteScriptResponseBodyResults) SetSuccess(v bool) *ExecuteScriptResponseBodyResults {
	s.Success = &v
	return s
}

type ExecuteScriptResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ExecuteScriptResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ExecuteScriptResponse) String() string {
	return tea.Prettify(s)
}

func (s ExecuteScriptResponse) GoString() string {
	return s.String()
}

func (s *ExecuteScriptResponse) SetHeaders(v map[string]*string) *ExecuteScriptResponse {
	s.Headers = v
	return s
}

func (s *ExecuteScriptResponse) SetStatusCode(v int32) *ExecuteScriptResponse {
	s.StatusCode = &v
	return s
}

func (s *ExecuteScriptResponse) SetBody(v *ExecuteScriptResponseBody) *ExecuteScriptResponse {
	s.Body = v
	return s
}

type ExecuteStructSyncRequest struct {
	// The ID of the ticket.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant.
	//
	// > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ExecuteStructSyncRequest) String() string {
	return tea.Prettify(s)
}

func (s ExecuteStructSyncRequest) GoString() string {
	return s.String()
}

func (s *ExecuteStructSyncRequest) SetOrderId(v int64) *ExecuteStructSyncRequest {
	s.OrderId = &v
	return s
}

func (s *ExecuteStructSyncRequest) SetTid(v int64) *ExecuteStructSyncRequest {
	s.Tid = &v
	return s
}

type ExecuteStructSyncResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ExecuteStructSyncResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ExecuteStructSyncResponseBody) GoString() string {
	return s.String()
}

func (s *ExecuteStructSyncResponseBody) SetErrorCode(v string) *ExecuteStructSyncResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ExecuteStructSyncResponseBody) SetErrorMessage(v string) *ExecuteStructSyncResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ExecuteStructSyncResponseBody) SetRequestId(v string) *ExecuteStructSyncResponseBody {
	s.RequestId = &v
	return s
}

func (s *ExecuteStructSyncResponseBody) SetSuccess(v bool) *ExecuteStructSyncResponseBody {
	s.Success = &v
	return s
}

type ExecuteStructSyncResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ExecuteStructSyncResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ExecuteStructSyncResponse) String() string {
	return tea.Prettify(s)
}

func (s ExecuteStructSyncResponse) GoString() string {
	return s.String()
}

func (s *ExecuteStructSyncResponse) SetHeaders(v map[string]*string) *ExecuteStructSyncResponse {
	s.Headers = v
	return s
}

func (s *ExecuteStructSyncResponse) SetStatusCode(v int32) *ExecuteStructSyncResponse {
	s.StatusCode = &v
	return s
}

func (s *ExecuteStructSyncResponse) SetBody(v *ExecuteStructSyncResponseBody) *ExecuteStructSyncResponse {
	s.Body = v
	return s
}

type GetApprovalDetailRequest struct {
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The ID of the approval process. You can call the [GetOrderBaseInfo](~~144642~~) operation to obtain the ID of the approval process.
	WorkflowInstanceId *int64 `json:"WorkflowInstanceId,omitempty" xml:"WorkflowInstanceId,omitempty"`
}

func (s GetApprovalDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetApprovalDetailRequest) GoString() string {
	return s.String()
}

func (s *GetApprovalDetailRequest) SetTid(v int64) *GetApprovalDetailRequest {
	s.Tid = &v
	return s
}

func (s *GetApprovalDetailRequest) SetWorkflowInstanceId(v int64) *GetApprovalDetailRequest {
	s.WorkflowInstanceId = &v
	return s
}

type GetApprovalDetailResponseBody struct {
	// The approval details of the ticket.
	ApprovalDetail *GetApprovalDetailResponseBodyApprovalDetail `json:"ApprovalDetail,omitempty" xml:"ApprovalDetail,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**: The request is successful.
	// *   **false**: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetApprovalDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetApprovalDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetApprovalDetailResponseBody) SetApprovalDetail(v *GetApprovalDetailResponseBodyApprovalDetail) *GetApprovalDetailResponseBody {
	s.ApprovalDetail = v
	return s
}

func (s *GetApprovalDetailResponseBody) SetErrorCode(v string) *GetApprovalDetailResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetApprovalDetailResponseBody) SetErrorMessage(v string) *GetApprovalDetailResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetApprovalDetailResponseBody) SetRequestId(v string) *GetApprovalDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetApprovalDetailResponseBody) SetSuccess(v bool) *GetApprovalDetailResponseBody {
	s.Success = &v
	return s
}

type GetApprovalDetailResponseBodyApprovalDetail struct {
	// The ID of the approval process.
	AuditId *int64 `json:"AuditId,omitempty" xml:"AuditId,omitempty"`
	// The time when the approval process was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The information about the approver.
	CurrentHandlers *GetApprovalDetailResponseBodyApprovalDetailCurrentHandlers `json:"CurrentHandlers,omitempty" xml:"CurrentHandlers,omitempty" type:"Struct"`
	// The description of the approval process.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the ticket.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The type of the ticket. Valid values:
	//
	// *   **NDDL**: a schema design ticket
	// *   **DATA_TRACK**: a data tracking ticket
	// *   **TABLE_SYNC**: a table synchronization ticket
	// *   **PERM_APPLY**: a permission application ticket
	// *   **DATA_EXPORT**: a data export ticket
	// *   **DATA_CORRECT**: a data change ticket
	// *   **OWNER_APPLY**: an owner role application ticket
	// *   **SENSITIVITY**: a column sensitivity level change ticket
	OrderType *string `json:"OrderType,omitempty" xml:"OrderType,omitempty"`
	// The reasons for the approval.
	ReasonList *GetApprovalDetailResponseBodyApprovalDetailReasonList `json:"ReasonList,omitempty" xml:"ReasonList,omitempty" type:"Struct"`
	// The ID of the workflow template.
	TemplateId *int64 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The title of the approval process.
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The approval status of the ticket. Valid values:
	//
	// *   **AUDITING**: The ticket is being reviewed.
	// *   **REJECT**: The ticket was rejected.
	// *   **CANCEL**: The ticket was revoked.
	// *   **APPROVED**: The ticket was approved.
	//
	// > An approval process contains multiple approval nodes, and this parameter is returned for each approval node.
	WorkflowInsCode *string `json:"WorkflowInsCode,omitempty" xml:"WorkflowInsCode,omitempty"`
	// The details of approval nodes.
	WorkflowNodes *GetApprovalDetailResponseBodyApprovalDetailWorkflowNodes `json:"WorkflowNodes,omitempty" xml:"WorkflowNodes,omitempty" type:"Struct"`
}

func (s GetApprovalDetailResponseBodyApprovalDetail) String() string {
	return tea.Prettify(s)
}

func (s GetApprovalDetailResponseBodyApprovalDetail) GoString() string {
	return s.String()
}

func (s *GetApprovalDetailResponseBodyApprovalDetail) SetAuditId(v int64) *GetApprovalDetailResponseBodyApprovalDetail {
	s.AuditId = &v
	return s
}

func (s *GetApprovalDetailResponseBodyApprovalDetail) SetCreateTime(v string) *GetApprovalDetailResponseBodyApprovalDetail {
	s.CreateTime = &v
	return s
}

func (s *GetApprovalDetailResponseBodyApprovalDetail) SetCurrentHandlers(v *GetApprovalDetailResponseBodyApprovalDetailCurrentHandlers) *GetApprovalDetailResponseBodyApprovalDetail {
	s.CurrentHandlers = v
	return s
}

func (s *GetApprovalDetailResponseBodyApprovalDetail) SetDescription(v string) *GetApprovalDetailResponseBodyApprovalDetail {
	s.Description = &v
	return s
}

func (s *GetApprovalDetailResponseBodyApprovalDetail) SetOrderId(v int64) *GetApprovalDetailResponseBodyApprovalDetail {
	s.OrderId = &v
	return s
}

func (s *GetApprovalDetailResponseBodyApprovalDetail) SetOrderType(v string) *GetApprovalDetailResponseBodyApprovalDetail {
	s.OrderType = &v
	return s
}

func (s *GetApprovalDetailResponseBodyApprovalDetail) SetReasonList(v *GetApprovalDetailResponseBodyApprovalDetailReasonList) *GetApprovalDetailResponseBodyApprovalDetail {
	s.ReasonList = v
	return s
}

func (s *GetApprovalDetailResponseBodyApprovalDetail) SetTemplateId(v int64) *GetApprovalDetailResponseBodyApprovalDetail {
	s.TemplateId = &v
	return s
}

func (s *GetApprovalDetailResponseBodyApprovalDetail) SetTitle(v string) *GetApprovalDetailResponseBodyApprovalDetail {
	s.Title = &v
	return s
}

func (s *GetApprovalDetailResponseBodyApprovalDetail) SetWorkflowInsCode(v string) *GetApprovalDetailResponseBodyApprovalDetail {
	s.WorkflowInsCode = &v
	return s
}

func (s *GetApprovalDetailResponseBodyApprovalDetail) SetWorkflowNodes(v *GetApprovalDetailResponseBodyApprovalDetailWorkflowNodes) *GetApprovalDetailResponseBodyApprovalDetail {
	s.WorkflowNodes = v
	return s
}

type GetApprovalDetailResponseBodyApprovalDetailCurrentHandlers struct {
	CurrentHandler []*GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler `json:"CurrentHandler,omitempty" xml:"CurrentHandler,omitempty" type:"Repeated"`
}

func (s GetApprovalDetailResponseBodyApprovalDetailCurrentHandlers) String() string {
	return tea.Prettify(s)
}

func (s GetApprovalDetailResponseBodyApprovalDetailCurrentHandlers) GoString() string {
	return s.String()
}

func (s *GetApprovalDetailResponseBodyApprovalDetailCurrentHandlers) SetCurrentHandler(v []*GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler) *GetApprovalDetailResponseBodyApprovalDetailCurrentHandlers {
	s.CurrentHandler = v
	return s
}

type GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler struct {
	// The ID of the user.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The nickname of the user.
	NickName *string `json:"NickName,omitempty" xml:"NickName,omitempty"`
}

func (s GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler) String() string {
	return tea.Prettify(s)
}

func (s GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler) GoString() string {
	return s.String()
}

func (s *GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler) SetId(v int64) *GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler {
	s.Id = &v
	return s
}

func (s *GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler) SetNickName(v string) *GetApprovalDetailResponseBodyApprovalDetailCurrentHandlersCurrentHandler {
	s.NickName = &v
	return s
}

type GetApprovalDetailResponseBodyApprovalDetailReasonList struct {
	Reasons []*string `json:"Reasons,omitempty" xml:"Reasons,omitempty" type:"Repeated"`
}

func (s GetApprovalDetailResponseBodyApprovalDetailReasonList) String() string {
	return tea.Prettify(s)
}

func (s GetApprovalDetailResponseBodyApprovalDetailReasonList) GoString() string {
	return s.String()
}

func (s *GetApprovalDetailResponseBodyApprovalDetailReasonList) SetReasons(v []*string) *GetApprovalDetailResponseBodyApprovalDetailReasonList {
	s.Reasons = v
	return s
}

type GetApprovalDetailResponseBodyApprovalDetailWorkflowNodes struct {
	WorkflowNode []*GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode `json:"WorkflowNode,omitempty" xml:"WorkflowNode,omitempty" type:"Repeated"`
}

func (s GetApprovalDetailResponseBodyApprovalDetailWorkflowNodes) String() string {
	return tea.Prettify(s)
}

func (s GetApprovalDetailResponseBodyApprovalDetailWorkflowNodes) GoString() string {
	return s.String()
}

func (s *GetApprovalDetailResponseBodyApprovalDetailWorkflowNodes) SetWorkflowNode(v []*GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode) *GetApprovalDetailResponseBodyApprovalDetailWorkflowNodes {
	s.WorkflowNode = v
	return s
}

type GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode struct {
	// The IDs of the approvers.
	AuditUserIdList *GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNodeAuditUserIdList `json:"AuditUserIdList,omitempty" xml:"AuditUserIdList,omitempty" type:"Struct"`
	// The name of the approval node.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The remarks of the approval.
	OperateComment *string `json:"OperateComment,omitempty" xml:"OperateComment,omitempty"`
	// The time when the ticket was submitted.
	OperateTime *string `json:"OperateTime,omitempty" xml:"OperateTime,omitempty"`
	// The ID of the user who submitted the ticket.
	OperatorId *int64 `json:"OperatorId,omitempty" xml:"OperatorId,omitempty"`
	// The approval status of the ticket. Valid values:
	//
	// *   **START**: The ticket was submitted.
	// *   **ERROR**: An error occurred.
	// *   **AUDITING**: The ticket is being reviewed.
	// *   **REJECT**: The ticket was rejected.
	// *   **CANCEL**: The ticket was revoked.
	// *   **APPROVED**: The ticket was approved.
	WorkflowInsCode *string `json:"WorkflowInsCode,omitempty" xml:"WorkflowInsCode,omitempty"`
}

func (s GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode) String() string {
	return tea.Prettify(s)
}

func (s GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode) GoString() string {
	return s.String()
}

func (s *GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode) SetAuditUserIdList(v *GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNodeAuditUserIdList) *GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode {
	s.AuditUserIdList = v
	return s
}

func (s *GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode) SetNodeName(v string) *GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode {
	s.NodeName = &v
	return s
}

func (s *GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode) SetOperateComment(v string) *GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode {
	s.OperateComment = &v
	return s
}

func (s *GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode) SetOperateTime(v string) *GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode {
	s.OperateTime = &v
	return s
}

func (s *GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode) SetOperatorId(v int64) *GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode {
	s.OperatorId = &v
	return s
}

func (s *GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode) SetWorkflowInsCode(v string) *GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNode {
	s.WorkflowInsCode = &v
	return s
}

type GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNodeAuditUserIdList struct {
	AuditUserIds []*string `json:"AuditUserIds,omitempty" xml:"AuditUserIds,omitempty" type:"Repeated"`
}

func (s GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNodeAuditUserIdList) String() string {
	return tea.Prettify(s)
}

func (s GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNodeAuditUserIdList) GoString() string {
	return s.String()
}

func (s *GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNodeAuditUserIdList) SetAuditUserIds(v []*string) *GetApprovalDetailResponseBodyApprovalDetailWorkflowNodesWorkflowNodeAuditUserIdList {
	s.AuditUserIds = v
	return s
}

type GetApprovalDetailResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetApprovalDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetApprovalDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetApprovalDetailResponse) GoString() string {
	return s.String()
}

func (s *GetApprovalDetailResponse) SetHeaders(v map[string]*string) *GetApprovalDetailResponse {
	s.Headers = v
	return s
}

func (s *GetApprovalDetailResponse) SetStatusCode(v int32) *GetApprovalDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetApprovalDetailResponse) SetBody(v *GetApprovalDetailResponseBody) *GetApprovalDetailResponse {
	s.Body = v
	return s
}

type GetAuthorityTemplateRequest struct {
	// The ID of the permission template.
	TemplateId *int64 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetAuthorityTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAuthorityTemplateRequest) GoString() string {
	return s.String()
}

func (s *GetAuthorityTemplateRequest) SetTemplateId(v int64) *GetAuthorityTemplateRequest {
	s.TemplateId = &v
	return s
}

func (s *GetAuthorityTemplateRequest) SetTid(v int64) *GetAuthorityTemplateRequest {
	s.Tid = &v
	return s
}

type GetAuthorityTemplateResponseBody struct {
	// The details of the permission template.
	AuthorityTemplateView *GetAuthorityTemplateResponseBodyAuthorityTemplateView `json:"AuthorityTemplateView,omitempty" xml:"AuthorityTemplateView,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The ID of the tenant.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetAuthorityTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAuthorityTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *GetAuthorityTemplateResponseBody) SetAuthorityTemplateView(v *GetAuthorityTemplateResponseBodyAuthorityTemplateView) *GetAuthorityTemplateResponseBody {
	s.AuthorityTemplateView = v
	return s
}

func (s *GetAuthorityTemplateResponseBody) SetErrorCode(v string) *GetAuthorityTemplateResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetAuthorityTemplateResponseBody) SetErrorMessage(v string) *GetAuthorityTemplateResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetAuthorityTemplateResponseBody) SetRequestId(v string) *GetAuthorityTemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetAuthorityTemplateResponseBody) SetSuccess(v bool) *GetAuthorityTemplateResponseBody {
	s.Success = &v
	return s
}

func (s *GetAuthorityTemplateResponseBody) SetTid(v int64) *GetAuthorityTemplateResponseBody {
	s.Tid = &v
	return s
}

type GetAuthorityTemplateResponseBodyAuthorityTemplateView struct {
	// The resource information in the permission template.
	AuthorityTemplateItemList *GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemList `json:"AuthorityTemplateItemList,omitempty" xml:"AuthorityTemplateItemList,omitempty" type:"Struct"`
	// The time when the permission template was created. The time is in the yyyy-MM-DD HH:mm:ss format.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the user who created the permission template.
	CreatorId *int64 `json:"CreatorId,omitempty" xml:"CreatorId,omitempty"`
	// The description of the permission template.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the permission template.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the permission template.
	TemplateId *int64 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
}

func (s GetAuthorityTemplateResponseBodyAuthorityTemplateView) String() string {
	return tea.Prettify(s)
}

func (s GetAuthorityTemplateResponseBodyAuthorityTemplateView) GoString() string {
	return s.String()
}

func (s *GetAuthorityTemplateResponseBodyAuthorityTemplateView) SetAuthorityTemplateItemList(v *GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemList) *GetAuthorityTemplateResponseBodyAuthorityTemplateView {
	s.AuthorityTemplateItemList = v
	return s
}

func (s *GetAuthorityTemplateResponseBodyAuthorityTemplateView) SetCreateTime(v string) *GetAuthorityTemplateResponseBodyAuthorityTemplateView {
	s.CreateTime = &v
	return s
}

func (s *GetAuthorityTemplateResponseBodyAuthorityTemplateView) SetCreatorId(v int64) *GetAuthorityTemplateResponseBodyAuthorityTemplateView {
	s.CreatorId = &v
	return s
}

func (s *GetAuthorityTemplateResponseBodyAuthorityTemplateView) SetDescription(v string) *GetAuthorityTemplateResponseBodyAuthorityTemplateView {
	s.Description = &v
	return s
}

func (s *GetAuthorityTemplateResponseBodyAuthorityTemplateView) SetName(v string) *GetAuthorityTemplateResponseBodyAuthorityTemplateView {
	s.Name = &v
	return s
}

func (s *GetAuthorityTemplateResponseBodyAuthorityTemplateView) SetTemplateId(v int64) *GetAuthorityTemplateResponseBodyAuthorityTemplateView {
	s.TemplateId = &v
	return s
}

type GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemList struct {
	AuthorityTemplateItem []*GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem `json:"AuthorityTemplateItem,omitempty" xml:"AuthorityTemplateItem,omitempty" type:"Repeated"`
}

func (s GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemList) String() string {
	return tea.Prettify(s)
}

func (s GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemList) GoString() string {
	return s.String()
}

func (s *GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemList) SetAuthorityTemplateItem(v []*GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem) *GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemList {
	s.AuthorityTemplateItem = v
	return s
}

type GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem struct {
	// Other information. For example, you can add the logon permission on an instance to the permission template.
	Attribute *string `json:"Attribute,omitempty" xml:"Attribute,omitempty"`
	// The ID of the database.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The ID of the instance.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the resource.
	ItemId *int64 `json:"ItemId,omitempty" xml:"ItemId,omitempty"`
	// The ID of the user who modified the resource.
	ModifierId *int64 `json:"ModifierId,omitempty" xml:"ModifierId,omitempty"`
	// The type of the resource. Valid values:
	//
	// *   **INSTANCE**: instance
	// *   **LOGIC_DB**: logical database
	// *   **META_DB**: physical database
	// *   **LOGIC_TABLE**: logical table
	// *   **SINGLE_TABLE**: physical table
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The name of the table.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	// The ID of the permission template.
	TemplateId *int64 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
}

func (s GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem) String() string {
	return tea.Prettify(s)
}

func (s GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem) GoString() string {
	return s.String()
}

func (s *GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem) SetAttribute(v string) *GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem {
	s.Attribute = &v
	return s
}

func (s *GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem) SetDbId(v int64) *GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem {
	s.DbId = &v
	return s
}

func (s *GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem) SetInstanceId(v int64) *GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem {
	s.InstanceId = &v
	return s
}

func (s *GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem) SetItemId(v int64) *GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem {
	s.ItemId = &v
	return s
}

func (s *GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem) SetModifierId(v int64) *GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem {
	s.ModifierId = &v
	return s
}

func (s *GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem) SetResourceType(v string) *GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem {
	s.ResourceType = &v
	return s
}

func (s *GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem) SetTableName(v string) *GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem {
	s.TableName = &v
	return s
}

func (s *GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem) SetTemplateId(v int64) *GetAuthorityTemplateResponseBodyAuthorityTemplateViewAuthorityTemplateItemListAuthorityTemplateItem {
	s.TemplateId = &v
	return s
}

type GetAuthorityTemplateResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAuthorityTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAuthorityTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAuthorityTemplateResponse) GoString() string {
	return s.String()
}

func (s *GetAuthorityTemplateResponse) SetHeaders(v map[string]*string) *GetAuthorityTemplateResponse {
	s.Headers = v
	return s
}

func (s *GetAuthorityTemplateResponse) SetStatusCode(v int32) *GetAuthorityTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAuthorityTemplateResponse) SetBody(v *GetAuthorityTemplateResponseBody) *GetAuthorityTemplateResponse {
	s.Body = v
	return s
}

type GetAuthorityTemplateItemRequest struct {
	// The ID of the permission template.
	TemplateId *int64 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetAuthorityTemplateItemRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAuthorityTemplateItemRequest) GoString() string {
	return s.String()
}

func (s *GetAuthorityTemplateItemRequest) SetTemplateId(v int64) *GetAuthorityTemplateItemRequest {
	s.TemplateId = &v
	return s
}

func (s *GetAuthorityTemplateItemRequest) SetTid(v int64) *GetAuthorityTemplateItemRequest {
	s.Tid = &v
	return s
}

type GetAuthorityTemplateItemResponseBody struct {
	// The permission templates.
	AuthorityTemplateItemList *GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemList `json:"AuthorityTemplateItemList,omitempty" xml:"AuthorityTemplateItemList,omitempty" type:"Struct"`
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The ID of the tenant.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetAuthorityTemplateItemResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAuthorityTemplateItemResponseBody) GoString() string {
	return s.String()
}

func (s *GetAuthorityTemplateItemResponseBody) SetAuthorityTemplateItemList(v *GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemList) *GetAuthorityTemplateItemResponseBody {
	s.AuthorityTemplateItemList = v
	return s
}

func (s *GetAuthorityTemplateItemResponseBody) SetErrorCode(v string) *GetAuthorityTemplateItemResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetAuthorityTemplateItemResponseBody) SetErrorMessage(v string) *GetAuthorityTemplateItemResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetAuthorityTemplateItemResponseBody) SetRequestId(v string) *GetAuthorityTemplateItemResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetAuthorityTemplateItemResponseBody) SetSuccess(v bool) *GetAuthorityTemplateItemResponseBody {
	s.Success = &v
	return s
}

func (s *GetAuthorityTemplateItemResponseBody) SetTid(v int64) *GetAuthorityTemplateItemResponseBody {
	s.Tid = &v
	return s
}

type GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemList struct {
	AuthorityTemplateItem []*GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem `json:"AuthorityTemplateItem,omitempty" xml:"AuthorityTemplateItem,omitempty" type:"Repeated"`
}

func (s GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemList) String() string {
	return tea.Prettify(s)
}

func (s GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemList) GoString() string {
	return s.String()
}

func (s *GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemList) SetAuthorityTemplateItem(v []*GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem) *GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemList {
	s.AuthorityTemplateItem = v
	return s
}

type GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem struct {
	// The additional information. For example, permissions to log on to an instance are added to the permission template.
	Attribute *string `json:"Attribute,omitempty" xml:"Attribute,omitempty"`
	// The ID of the database.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The ID of the instance.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the resource.
	ItemId *int64 `json:"ItemId,omitempty" xml:"ItemId,omitempty"`
	// The ID of the user who modifies the resource.
	ModifierId *int64 `json:"ModifierId,omitempty" xml:"ModifierId,omitempty"`
	// The type of the resource. Valid values:
	//
	// *   **INSTANCE**: instance
	// *   **LOGIC_DB**: logical database
	// *   **META_DB**: physical database
	// *   **LOGIC_TABLE**: logical table
	// *   **LOGIC_TABLE**: physical table
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The name of the table.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	// The ID of the permission template.
	TemplateId *int64 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
}

func (s GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem) String() string {
	return tea.Prettify(s)
}

func (s GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem) GoString() string {
	return s.String()
}

func (s *GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem) SetAttribute(v string) *GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem {
	s.Attribute = &v
	return s
}

func (s *GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem) SetDbId(v int64) *GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem {
	s.DbId = &v
	return s
}

func (s *GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem) SetInstanceId(v int64) *GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem {
	s.InstanceId = &v
	return s
}

func (s *GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem) SetItemId(v int64) *GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem {
	s.ItemId = &v
	return s
}

func (s *GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem) SetModifierId(v int64) *GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem {
	s.ModifierId = &v
	return s
}

func (s *GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem) SetResourceType(v string) *GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem {
	s.ResourceType = &v
	return s
}

func (s *GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem) SetTableName(v string) *GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem {
	s.TableName = &v
	return s
}

func (s *GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem) SetTemplateId(v int64) *GetAuthorityTemplateItemResponseBodyAuthorityTemplateItemListAuthorityTemplateItem {
	s.TemplateId = &v
	return s
}

type GetAuthorityTemplateItemResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAuthorityTemplateItemResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAuthorityTemplateItemResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAuthorityTemplateItemResponse) GoString() string {
	return s.String()
}

func (s *GetAuthorityTemplateItemResponse) SetHeaders(v map[string]*string) *GetAuthorityTemplateItemResponse {
	s.Headers = v
	return s
}

func (s *GetAuthorityTemplateItemResponse) SetStatusCode(v int32) *GetAuthorityTemplateItemResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAuthorityTemplateItemResponse) SetBody(v *GetAuthorityTemplateItemResponseBody) *GetAuthorityTemplateItemResponse {
	s.Body = v
	return s
}

type GetClassificationTemplateRequest struct {
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	Tid        *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetClassificationTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s GetClassificationTemplateRequest) GoString() string {
	return s.String()
}

func (s *GetClassificationTemplateRequest) SetInstanceId(v int64) *GetClassificationTemplateRequest {
	s.InstanceId = &v
	return s
}

func (s *GetClassificationTemplateRequest) SetTid(v int64) *GetClassificationTemplateRequest {
	s.Tid = &v
	return s
}

type GetClassificationTemplateResponseBody struct {
	ClassificationResourceTemplateMap *GetClassificationTemplateResponseBodyClassificationResourceTemplateMap `json:"ClassificationResourceTemplateMap,omitempty" xml:"ClassificationResourceTemplateMap,omitempty" type:"Struct"`
	ErrorCode                         *string                                                                 `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage                      *string                                                                 `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId                         *string                                                                 `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success                           *bool                                                                   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetClassificationTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetClassificationTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *GetClassificationTemplateResponseBody) SetClassificationResourceTemplateMap(v *GetClassificationTemplateResponseBodyClassificationResourceTemplateMap) *GetClassificationTemplateResponseBody {
	s.ClassificationResourceTemplateMap = v
	return s
}

func (s *GetClassificationTemplateResponseBody) SetErrorCode(v string) *GetClassificationTemplateResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetClassificationTemplateResponseBody) SetErrorMessage(v string) *GetClassificationTemplateResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetClassificationTemplateResponseBody) SetRequestId(v string) *GetClassificationTemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetClassificationTemplateResponseBody) SetSuccess(v bool) *GetClassificationTemplateResponseBody {
	s.Success = &v
	return s
}

type GetClassificationTemplateResponseBodyClassificationResourceTemplateMap struct {
	ResourceId   *int64  `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	TemplateId   *int64  `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	TemplateType *string `json:"TemplateType,omitempty" xml:"TemplateType,omitempty"`
}

func (s GetClassificationTemplateResponseBodyClassificationResourceTemplateMap) String() string {
	return tea.Prettify(s)
}

func (s GetClassificationTemplateResponseBodyClassificationResourceTemplateMap) GoString() string {
	return s.String()
}

func (s *GetClassificationTemplateResponseBodyClassificationResourceTemplateMap) SetResourceId(v int64) *GetClassificationTemplateResponseBodyClassificationResourceTemplateMap {
	s.ResourceId = &v
	return s
}

func (s *GetClassificationTemplateResponseBodyClassificationResourceTemplateMap) SetResourceType(v string) *GetClassificationTemplateResponseBodyClassificationResourceTemplateMap {
	s.ResourceType = &v
	return s
}

func (s *GetClassificationTemplateResponseBodyClassificationResourceTemplateMap) SetTemplateId(v int64) *GetClassificationTemplateResponseBodyClassificationResourceTemplateMap {
	s.TemplateId = &v
	return s
}

func (s *GetClassificationTemplateResponseBodyClassificationResourceTemplateMap) SetTemplateType(v string) *GetClassificationTemplateResponseBodyClassificationResourceTemplateMap {
	s.TemplateType = &v
	return s
}

type GetClassificationTemplateResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetClassificationTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetClassificationTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s GetClassificationTemplateResponse) GoString() string {
	return s.String()
}

func (s *GetClassificationTemplateResponse) SetHeaders(v map[string]*string) *GetClassificationTemplateResponse {
	s.Headers = v
	return s
}

func (s *GetClassificationTemplateResponse) SetStatusCode(v int32) *GetClassificationTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *GetClassificationTemplateResponse) SetBody(v *GetClassificationTemplateResponseBody) *GetClassificationTemplateResponse {
	s.Body = v
	return s
}

type GetDBTaskSQLJobLogRequest struct {
	// The ID of the SQL task. You can call the [ListDBTaskSQLJob](~~207049~~) operation to query the ID of the SQL task.
	JobId *int64 `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetDBTaskSQLJobLogRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDBTaskSQLJobLogRequest) GoString() string {
	return s.String()
}

func (s *GetDBTaskSQLJobLogRequest) SetJobId(v int64) *GetDBTaskSQLJobLogRequest {
	s.JobId = &v
	return s
}

func (s *GetDBTaskSQLJobLogRequest) SetTid(v int64) *GetDBTaskSQLJobLogRequest {
	s.Tid = &v
	return s
}

type GetDBTaskSQLJobLogResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The log that records the scheduling details.
	Log *string `json:"Log,omitempty" xml:"Log,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDBTaskSQLJobLogResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDBTaskSQLJobLogResponseBody) GoString() string {
	return s.String()
}

func (s *GetDBTaskSQLJobLogResponseBody) SetErrorCode(v string) *GetDBTaskSQLJobLogResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetDBTaskSQLJobLogResponseBody) SetErrorMessage(v string) *GetDBTaskSQLJobLogResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDBTaskSQLJobLogResponseBody) SetLog(v string) *GetDBTaskSQLJobLogResponseBody {
	s.Log = &v
	return s
}

func (s *GetDBTaskSQLJobLogResponseBody) SetRequestId(v string) *GetDBTaskSQLJobLogResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDBTaskSQLJobLogResponseBody) SetSuccess(v bool) *GetDBTaskSQLJobLogResponseBody {
	s.Success = &v
	return s
}

type GetDBTaskSQLJobLogResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDBTaskSQLJobLogResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDBTaskSQLJobLogResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDBTaskSQLJobLogResponse) GoString() string {
	return s.String()
}

func (s *GetDBTaskSQLJobLogResponse) SetHeaders(v map[string]*string) *GetDBTaskSQLJobLogResponse {
	s.Headers = v
	return s
}

func (s *GetDBTaskSQLJobLogResponse) SetStatusCode(v int32) *GetDBTaskSQLJobLogResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDBTaskSQLJobLogResponse) SetBody(v *GetDBTaskSQLJobLogResponseBody) *GetDBTaskSQLJobLogResponse {
	s.Body = v
	return s
}

type GetDBTopologyRequest struct {
	// The ID of the logical database.
	//
	// > You can call the [ListLogicDatabases](~~141874~~) operation to query the ID of the logical database.
	LogicDbId *int64 `json:"LogicDbId,omitempty" xml:"LogicDbId,omitempty"`
	// The ID of the tenant.
	//
	// > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetDBTopologyRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDBTopologyRequest) GoString() string {
	return s.String()
}

func (s *GetDBTopologyRequest) SetLogicDbId(v int64) *GetDBTopologyRequest {
	s.LogicDbId = &v
	return s
}

func (s *GetDBTopologyRequest) SetTid(v int64) *GetDBTopologyRequest {
	s.Tid = &v
	return s
}

type GetDBTopologyResponseBody struct {
	// The topology of the logical database.
	DBTopology *GetDBTopologyResponseBodyDBTopology `json:"DBTopology,omitempty" xml:"DBTopology,omitempty" type:"Struct"`
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDBTopologyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDBTopologyResponseBody) GoString() string {
	return s.String()
}

func (s *GetDBTopologyResponseBody) SetDBTopology(v *GetDBTopologyResponseBodyDBTopology) *GetDBTopologyResponseBody {
	s.DBTopology = v
	return s
}

func (s *GetDBTopologyResponseBody) SetErrorCode(v string) *GetDBTopologyResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetDBTopologyResponseBody) SetErrorMessage(v string) *GetDBTopologyResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDBTopologyResponseBody) SetRequestId(v string) *GetDBTopologyResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDBTopologyResponseBody) SetSuccess(v bool) *GetDBTopologyResponseBody {
	s.Success = &v
	return s
}

type GetDBTopologyResponseBodyDBTopology struct {
	// The alias of the logical database.
	Alias *string `json:"Alias,omitempty" xml:"Alias,omitempty"`
	// The topologies of the physical database shards.
	DBTopologyInfoList []*GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList `json:"DBTopologyInfoList,omitempty" xml:"DBTopologyInfoList,omitempty" type:"Repeated"`
	// The type of the database. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The type of the environment to which the logical database belongs. Valid values:
	//
	// *   **product**: production environment
	// *   **dev**: development environment
	// *   **pre**: pre-release environment
	// *   **test**: test environment
	// *   **sit**: system integration testing (SIT) environment
	// *   **uat**: user acceptance testing (UAT) environment
	// *   **pet**: stress testing environment
	// *   **stag**: staging environment
	//
	// > For more information, see [Change the environment type of an instance](~~163309~~).
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The ID of the logical database.
	LogicDbId *int64 `json:"LogicDbId,omitempty" xml:"LogicDbId,omitempty"`
	// The name of the logical database.
	LogicDbName *string `json:"LogicDbName,omitempty" xml:"LogicDbName,omitempty"`
	// The name that is used to search for the logical database.
	SearchName *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
}

func (s GetDBTopologyResponseBodyDBTopology) String() string {
	return tea.Prettify(s)
}

func (s GetDBTopologyResponseBodyDBTopology) GoString() string {
	return s.String()
}

func (s *GetDBTopologyResponseBodyDBTopology) SetAlias(v string) *GetDBTopologyResponseBodyDBTopology {
	s.Alias = &v
	return s
}

func (s *GetDBTopologyResponseBodyDBTopology) SetDBTopologyInfoList(v []*GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList) *GetDBTopologyResponseBodyDBTopology {
	s.DBTopologyInfoList = v
	return s
}

func (s *GetDBTopologyResponseBodyDBTopology) SetDbType(v string) *GetDBTopologyResponseBodyDBTopology {
	s.DbType = &v
	return s
}

func (s *GetDBTopologyResponseBodyDBTopology) SetEnvType(v string) *GetDBTopologyResponseBodyDBTopology {
	s.EnvType = &v
	return s
}

func (s *GetDBTopologyResponseBodyDBTopology) SetLogicDbId(v int64) *GetDBTopologyResponseBodyDBTopology {
	s.LogicDbId = &v
	return s
}

func (s *GetDBTopologyResponseBodyDBTopology) SetLogicDbName(v string) *GetDBTopologyResponseBodyDBTopology {
	s.LogicDbName = &v
	return s
}

func (s *GetDBTopologyResponseBodyDBTopology) SetSearchName(v string) *GetDBTopologyResponseBodyDBTopology {
	s.SearchName = &v
	return s
}

type GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList struct {
	// The name of the catalog to which the database belongs.
	//
	// > If the database is a PostgreSQL database, the value of this parameter is the name of the database.
	CatalogName *string `json:"CatalogName,omitempty" xml:"CatalogName,omitempty"`
	// The ID of the logical database.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The type of the database. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The type of the environment to which the logical database belongs. Valid values:
	//
	// *   **product**: production environment
	// *   **dev**: development environment
	// *   **pre**: pre-release environment
	// *   **test**: test environment
	// *   **sit**: SIT environment
	// *   **uat**: UAT environment
	// *   **pet**: stress testing environment
	// *   **stag**: staging environment
	//
	// > For more information, see [Change the environment type of an instance](~~163309~~).
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The ID of the instance in which the logical database resides.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the resource related to the instance. The resource corresponds with the database instance type returned in the InstanceSource parameter.
	//
	// *   If the value of the InstanceSource parameter is RDS, the ID of an ApsaraDB RDS instance is returned.
	// *   If the value of the InstanceSource parameter is ECS_OWN, the ID of a self-managed database that is hosted on an Elastic Compute Service (ECS) instance is returned.
	// *   If the value of the InstanceSource parameter is PUBLIC_OWN, an empty string is returned.
	// *   If the value of the InstanceSource parameter is VPC_ID, the ID of a self-managed database instance in a virtual private cloud (VPC) that is connected over Express Connect circuits is returned.
	// *   If the value of the InstanceSource parameter is GATEWAY, the ID of a database instance connected by using a database gateway is returned.
	InstanceResourceId *string `json:"InstanceResourceId,omitempty" xml:"InstanceResourceId,omitempty"`
	// The type of the database instance. Valid values:
	//
	// *   **RDS**: an ApsaraDB RDS instance.
	// *   **ECS_OWN**: a self-managed database that is hosted on an ECS instance.
	// *   **PUBLIC_OWN**: a self-managed database instance that is connected over the Internet.
	// *   **VPC_ID**: a self-managed database instance in a VPC that is connected over Express Connect circuits.
	// *   **GATEWAY**: a database instance connected by using a database gateway.
	InstanceSource *string `json:"InstanceSource,omitempty" xml:"InstanceSource,omitempty"`
	// The ID of the region in which the instance resides.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The name of the logical database.
	//
	// > If the database is a PostgreSQL database, the value of this parameter is the name of the database schema.
	SchemaName *string `json:"SchemaName,omitempty" xml:"SchemaName,omitempty"`
	// The name that is used to search for the database.
	SearchName *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
}

func (s GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList) String() string {
	return tea.Prettify(s)
}

func (s GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList) GoString() string {
	return s.String()
}

func (s *GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList) SetCatalogName(v string) *GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList {
	s.CatalogName = &v
	return s
}

func (s *GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList) SetDbId(v int64) *GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList {
	s.DbId = &v
	return s
}

func (s *GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList) SetDbType(v string) *GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList {
	s.DbType = &v
	return s
}

func (s *GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList) SetEnvType(v string) *GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList {
	s.EnvType = &v
	return s
}

func (s *GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList) SetInstanceId(v int64) *GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList {
	s.InstanceId = &v
	return s
}

func (s *GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList) SetInstanceResourceId(v string) *GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList {
	s.InstanceResourceId = &v
	return s
}

func (s *GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList) SetInstanceSource(v string) *GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList {
	s.InstanceSource = &v
	return s
}

func (s *GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList) SetRegionId(v string) *GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList {
	s.RegionId = &v
	return s
}

func (s *GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList) SetSchemaName(v string) *GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList {
	s.SchemaName = &v
	return s
}

func (s *GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList) SetSearchName(v string) *GetDBTopologyResponseBodyDBTopologyDBTopologyInfoList {
	s.SearchName = &v
	return s
}

type GetDBTopologyResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDBTopologyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDBTopologyResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDBTopologyResponse) GoString() string {
	return s.String()
}

func (s *GetDBTopologyResponse) SetHeaders(v map[string]*string) *GetDBTopologyResponse {
	s.Headers = v
	return s
}

func (s *GetDBTopologyResponse) SetStatusCode(v int32) *GetDBTopologyResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDBTopologyResponse) SetBody(v *GetDBTopologyResponseBody) *GetDBTopologyResponse {
	s.Body = v
	return s
}

type GetDataArchiveCountRequest struct {
	// The type of the identity. Default value: AS_ADMIN.
	OrderResultType *string `json:"OrderResultType,omitempty" xml:"OrderResultType,omitempty"`
	// The plugin type. Default value: DATA_ARCHIVE.
	PluginType *string `json:"PluginType,omitempty" xml:"PluginType,omitempty"`
	// The time when the ticket is modified or created. The statistics of data archiving tickets are calculated based on the creation time.
	SearchDateType *string `json:"SearchDateType,omitempty" xml:"SearchDateType,omitempty"`
	// The tenant ID.
	//
	// >  To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetDataArchiveCountRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDataArchiveCountRequest) GoString() string {
	return s.String()
}

func (s *GetDataArchiveCountRequest) SetOrderResultType(v string) *GetDataArchiveCountRequest {
	s.OrderResultType = &v
	return s
}

func (s *GetDataArchiveCountRequest) SetPluginType(v string) *GetDataArchiveCountRequest {
	s.PluginType = &v
	return s
}

func (s *GetDataArchiveCountRequest) SetSearchDateType(v string) *GetDataArchiveCountRequest {
	s.SearchDateType = &v
	return s
}

func (s *GetDataArchiveCountRequest) SetTid(v int64) *GetDataArchiveCountRequest {
	s.Tid = &v
	return s
}

type GetDataArchiveCountResponseBody struct {
	// The data returned.
	Data *GetDataArchiveCountResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDataArchiveCountResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDataArchiveCountResponseBody) GoString() string {
	return s.String()
}

func (s *GetDataArchiveCountResponseBody) SetData(v *GetDataArchiveCountResponseBodyData) *GetDataArchiveCountResponseBody {
	s.Data = v
	return s
}

func (s *GetDataArchiveCountResponseBody) SetRequestId(v string) *GetDataArchiveCountResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDataArchiveCountResponseBody) SetSuccess(v bool) *GetDataArchiveCountResponseBody {
	s.Success = &v
	return s
}

type GetDataArchiveCountResponseBodyData struct {
	// The number of failed archiving tickets.
	FailCount *int64 `json:"FailCount,omitempty" xml:"FailCount,omitempty"`
	// The number of in-progress archiving tickets.
	ProcessingCount *int64 `json:"ProcessingCount,omitempty" xml:"ProcessingCount,omitempty"`
	// The number of successful archiving tickets.
	SuccessCount *int64 `json:"SuccessCount,omitempty" xml:"SuccessCount,omitempty"`
	// The total number of archiving tickets.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s GetDataArchiveCountResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetDataArchiveCountResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetDataArchiveCountResponseBodyData) SetFailCount(v int64) *GetDataArchiveCountResponseBodyData {
	s.FailCount = &v
	return s
}

func (s *GetDataArchiveCountResponseBodyData) SetProcessingCount(v int64) *GetDataArchiveCountResponseBodyData {
	s.ProcessingCount = &v
	return s
}

func (s *GetDataArchiveCountResponseBodyData) SetSuccessCount(v int64) *GetDataArchiveCountResponseBodyData {
	s.SuccessCount = &v
	return s
}

func (s *GetDataArchiveCountResponseBodyData) SetTotalCount(v int64) *GetDataArchiveCountResponseBodyData {
	s.TotalCount = &v
	return s
}

type GetDataArchiveCountResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDataArchiveCountResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDataArchiveCountResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDataArchiveCountResponse) GoString() string {
	return s.String()
}

func (s *GetDataArchiveCountResponse) SetHeaders(v map[string]*string) *GetDataArchiveCountResponse {
	s.Headers = v
	return s
}

func (s *GetDataArchiveCountResponse) SetStatusCode(v int32) *GetDataArchiveCountResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDataArchiveCountResponse) SetBody(v *GetDataArchiveCountResponseBody) *GetDataArchiveCountResponse {
	s.Body = v
	return s
}

type GetDataArchiveOrderDetailRequest struct {
	// The IDs of data archiving tickets.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The tenant ID.
	//
	// >  To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetDataArchiveOrderDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDataArchiveOrderDetailRequest) GoString() string {
	return s.String()
}

func (s *GetDataArchiveOrderDetailRequest) SetOrderId(v int64) *GetDataArchiveOrderDetailRequest {
	s.OrderId = &v
	return s
}

func (s *GetDataArchiveOrderDetailRequest) SetTid(v int64) *GetDataArchiveOrderDetailRequest {
	s.Tid = &v
	return s
}

type GetDataArchiveOrderDetailResponseBody struct {
	// The details of data archiving tickets.
	DataArchiveOrderDetail *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail `json:"DataArchiveOrderDetail,omitempty" xml:"DataArchiveOrderDetail,omitempty" type:"Struct"`
	// The error code returned if the call failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message that is returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request, which is used to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   true
	// *   false
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// Tracks service requests.
	TraceId *string `json:"TraceId,omitempty" xml:"TraceId,omitempty"`
}

func (s GetDataArchiveOrderDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDataArchiveOrderDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetDataArchiveOrderDetailResponseBody) SetDataArchiveOrderDetail(v *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail) *GetDataArchiveOrderDetailResponseBody {
	s.DataArchiveOrderDetail = v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBody) SetErrorCode(v string) *GetDataArchiveOrderDetailResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBody) SetErrorMessage(v string) *GetDataArchiveOrderDetailResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBody) SetRequestId(v string) *GetDataArchiveOrderDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBody) SetSuccess(v bool) *GetDataArchiveOrderDetailResponseBody {
	s.Success = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBody) SetTraceId(v string) *GetDataArchiveOrderDetailResponseBody {
	s.TraceId = &v
	return s
}

type GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail struct {
	// The description of the data archiving tickets.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The user who submitted the ticket.
	Committer *string `json:"Committer,omitempty" xml:"Committer,omitempty"`
	// The ID of the user who submitted the ticket. The ID is a user ID and not the ID of an Alibaba Cloud account.
	CommitterId *int64 `json:"CommitterId,omitempty" xml:"CommitterId,omitempty"`
	// The time when the ticket was created.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The time when the ticket was last modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of data archiving tickets.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The additional information about the ticket.
	PluginExtraData *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData `json:"PluginExtraData,omitempty" xml:"PluginExtraData,omitempty" type:"Struct"`
	// The ticket creation parameter. The value is a JSON string. For more information, see [PluginType parameter](~~429109~~).
	PluginParam *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam `json:"PluginParam,omitempty" xml:"PluginParam,omitempty" type:"Struct"`
	// The plug-in type that corresponds to the type of the ticket. The plug-in type for data archiving is DATA_ARCHIVE. For more information, see [PluginType parameter](~~429109~~).
	PluginType *string `json:"PluginType,omitempty" xml:"PluginType,omitempty"`
	// The user IDs related to the ticket.
	RelatedUserList []*int64 `json:"RelatedUserList,omitempty" xml:"RelatedUserList,omitempty" type:"Repeated"`
	// The nicknames of the users that are related to the ticket.
	RelatedUserNickList []*string `json:"RelatedUserNickList,omitempty" xml:"RelatedUserNickList,omitempty" type:"Repeated"`
	// The status code of the ticket. Valid values:
	//
	// *   **new**: newly created.
	// *   **toaudit**: being reviewed.
	// *   **Approved**: approved.
	// *   **reject**: rejected.
	// *   **processing**: being executed.
	// *   **Success**: successful.
	// *   **closed**: disabled.
	StatusCode *string `json:"StatusCode,omitempty" xml:"StatusCode,omitempty"`
	// The status description of the ticket.
	StatusDesc *string `json:"StatusDesc,omitempty" xml:"StatusDesc,omitempty"`
	// The ID of the approval process. You can call the [GetOrderBaseInfo](~~144642~~) operation to obtain the ID of the approval process.
	WorkflowInstanceId *int64 `json:"WorkflowInstanceId,omitempty" xml:"WorkflowInstanceId,omitempty"`
	// The description of the approval process.
	WorkflowStatusDesc *string `json:"WorkflowStatusDesc,omitempty" xml:"WorkflowStatusDesc,omitempty"`
}

func (s GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail) String() string {
	return tea.Prettify(s)
}

func (s GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail) GoString() string {
	return s.String()
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail) SetComment(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail {
	s.Comment = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail) SetCommitter(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail {
	s.Committer = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail) SetCommitterId(v int64) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail {
	s.CommitterId = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail) SetGmtCreate(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail {
	s.GmtCreate = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail) SetGmtModified(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail {
	s.GmtModified = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail) SetId(v int64) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail {
	s.Id = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail) SetPluginExtraData(v *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail {
	s.PluginExtraData = v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail) SetPluginParam(v *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail {
	s.PluginParam = v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail) SetPluginType(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail {
	s.PluginType = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail) SetRelatedUserList(v []*int64) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail {
	s.RelatedUserList = v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail) SetRelatedUserNickList(v []*string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail {
	s.RelatedUserNickList = v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail) SetStatusCode(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail {
	s.StatusCode = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail) SetStatusDesc(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail {
	s.StatusDesc = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail) SetWorkflowInstanceId(v int64) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail {
	s.WorkflowInstanceId = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail) SetWorkflowStatusDesc(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetail {
	s.WorkflowStatusDesc = &v
	return s
}

type GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData struct {
	// The information about the workflow.
	DagInfo *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo `json:"DagInfo,omitempty" xml:"DagInfo,omitempty" type:"Struct"`
	// The database information related to data archiving tickets.
	DbBaseInfo *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo `json:"DbBaseInfo,omitempty" xml:"DbBaseInfo,omitempty" type:"Struct"`
	// The total number of archiving tasks.
	InstanceTotal *int64 `json:"InstanceTotal,omitempty" xml:"InstanceTotal,omitempty"`
	// The list of archiving tasks.
	Instances []*GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances `json:"Instances,omitempty" xml:"Instances,omitempty" type:"Repeated"`
	// The time when the next task is triggered.
	NextFireTimeResult *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataNextFireTimeResult `json:"NextFireTimeResult,omitempty" xml:"NextFireTimeResult,omitempty" type:"Struct"`
	// The page number.
	PageIndex *int64 `json:"PageIndex,omitempty" xml:"PageIndex,omitempty"`
	// The number of entries per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The name of the temporary table that is generated by the archiving task (indicated by the archiving task ID).
	TempTableNameMap map[string]interface{} `json:"TempTableNameMap,omitempty" xml:"TempTableNameMap,omitempty"`
}

func (s GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData) String() string {
	return tea.Prettify(s)
}

func (s GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData) GoString() string {
	return s.String()
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData) SetDagInfo(v *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData {
	s.DagInfo = v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData) SetDbBaseInfo(v *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData {
	s.DbBaseInfo = v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData) SetInstanceTotal(v int64) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData {
	s.InstanceTotal = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData) SetInstances(v []*GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData {
	s.Instances = v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData) SetNextFireTimeResult(v *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataNextFireTimeResult) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData {
	s.NextFireTimeResult = v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData) SetPageIndex(v int64) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData {
	s.PageIndex = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData) SetPageSize(v int64) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData {
	s.PageSize = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData) SetTempTableNameMap(v map[string]interface{}) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraData {
	s.TempTableNameMap = v
	return s
}

type GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo struct {
	// The ID of the user who created the task flow.
	CreatorId *string `json:"CreatorId,omitempty" xml:"CreatorId,omitempty"`
	// The start time for scheduling. The task flow is not scheduled before this point in time.
	CronBeginDate *string `json:"CronBeginDate,omitempty" xml:"CronBeginDate,omitempty"`
	// The end time for scheduling. The task flow is not scheduled after this point in time.
	CronEndDate *string `json:"CronEndDate,omitempty" xml:"CronEndDate,omitempty"`
	// Indicates whether the archiving task is a scheduled task. Valid values:
	//
	// *   **true**
	// *   **false**
	CronTrigger *bool `json:"CronTrigger,omitempty" xml:"CronTrigger,omitempty"`
	// Indicates whether the task is used to develop warehouses.
	//
	// >  This field is a retained field that is not in use.
	DWDevelop *bool `json:"DWDevelop,omitempty" xml:"DWDevelop,omitempty"`
	// The name of the workflow.
	DagName *string `json:"DagName,omitempty" xml:"DagName,omitempty"`
	// The ID of the owner of the workflow.
	DagOwnerId *string `json:"DagOwnerId,omitempty" xml:"DagOwnerId,omitempty"`
	// The ID of the deployment record.
	DeployId *int64 `json:"DeployId,omitempty" xml:"DeployId,omitempty"`
	// The description of the workflow.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the editable workflow version.
	EditDagId *int64 `json:"EditDagId,omitempty" xml:"EditDagId,omitempty"`
	// The time when the workflow was created.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The time when the workflow was last modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the task flow.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// Indicates whether the workflow is public. Valid values:
	//
	// *   **0**: not public.
	// *   **1**: public.
	IsPublic *int64 `json:"IsPublic,omitempty" xml:"IsPublic,omitempty"`
	// Indicates whether the task is a historical task. Valid values:
	//
	// *   **true**
	// *   **false**
	Legacy *bool `json:"Legacy,omitempty" xml:"Legacy,omitempty"`
	// Indicates whether the task was created by the system. Valid values:
	//
	// *   **true**
	// *   **false**
	System *bool `json:"System,omitempty" xml:"System,omitempty"`
	// The tenant ID.
	TenantId *string `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
	// Indicates whether the workflow is triggered to run once. Valid values:
	//
	// *   **true**
	// *   **false**
	TriggerOnce *bool `json:"TriggerOnce,omitempty" xml:"TriggerOnce,omitempty"`
}

func (s GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo) String() string {
	return tea.Prettify(s)
}

func (s GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo) GoString() string {
	return s.String()
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo) SetCreatorId(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo {
	s.CreatorId = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo) SetCronBeginDate(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo {
	s.CronBeginDate = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo) SetCronEndDate(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo {
	s.CronEndDate = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo) SetCronTrigger(v bool) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo {
	s.CronTrigger = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo) SetDWDevelop(v bool) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo {
	s.DWDevelop = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo) SetDagName(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo {
	s.DagName = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo) SetDagOwnerId(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo {
	s.DagOwnerId = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo) SetDeployId(v int64) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo {
	s.DeployId = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo) SetDescription(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo {
	s.Description = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo) SetEditDagId(v int64) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo {
	s.EditDagId = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo) SetGmtCreate(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo {
	s.GmtCreate = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo) SetGmtModified(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo {
	s.GmtModified = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo) SetId(v int64) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo {
	s.Id = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo) SetIsPublic(v int64) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo {
	s.IsPublic = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo) SetLegacy(v bool) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo {
	s.Legacy = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo) SetSystem(v bool) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo {
	s.System = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo) SetTenantId(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo {
	s.TenantId = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo) SetTriggerOnce(v bool) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDagInfo {
	s.TriggerOnce = &v
	return s
}

type GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo struct {
	// The alias of the database instance.
	Alias *string `json:"Alias,omitempty" xml:"Alias,omitempty"`
	// The timeout period of queries on the database.
	AlterTimeout *int64 `json:"AlterTimeout,omitempty" xml:"AlterTimeout,omitempty"`
	// Indicates whether access control is enabled for data assets. Valid values:
	//
	// *   **true**
	// *   **false**
	AssetControl *bool `json:"AssetControl,omitempty" xml:"AssetControl,omitempty"`
	// The name of the instance in the instance list.
	CatalogName *string `json:"CatalogName,omitempty" xml:"CatalogName,omitempty"`
	// Indicates whether the instance is added to the DMS whitelist.
	ClusterNode *string `json:"ClusterNode,omitempty" xml:"ClusterNode,omitempty"`
	// The ID of the database. You can call the [SearchDatabase](~~141876~~) operation to query the ID of the database.
	//
	// >  You can call the [ListDatabases](~~141873~~) operation to query the ID of a physical database or the [ListLogicDatabases](~~141874~~) operation to query the ID of a logical database.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The type of the database. For information about the valid values of this parameter, see [DbType parameter](~~198106~~).
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The ID of the database administrator (DBA) of the instance.
	DbaId *int64 `json:"DbaId,omitempty" xml:"DbaId,omitempty"`
	// The nickname of the DBA of the instance.
	DbaName *string `json:"DbaName,omitempty" xml:"DbaName,omitempty"`
	// The complete endpoint of the database.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The encoding format of the database.
	Encoding *string `json:"Encoding,omitempty" xml:"Encoding,omitempty"`
	// The type of the environment to which the database belongs. Valid values:
	//
	// *   **product**: production environment
	// *   **dev**: development environment
	// *   **pre**: staging environment
	// *   **test**: test environment
	// *   **sit**: system integration testing (SIT) environment
	// *   **uat**: user acceptance testing (UAT) environment
	// *   **pet**: stress testing environment
	// *   **stag**: STAG environment
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// Indicates whether the instance needs special attention. Valid values:
	//
	// *   **true**
	// *   **false**
	Follow *bool `json:"Follow,omitempty" xml:"Follow,omitempty"`
	// The endpoint that is used to connect to the database.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The region in which the database instance resides.
	Idc *string `json:"Idc,omitempty" xml:"Idc,omitempty"`
	// The name of the region in which the database instance resides.
	IdcTitle *string `json:"IdcTitle,omitempty" xml:"IdcTitle,omitempty"`
	// The ID of the instance to which the database belongs.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The source of the database instance.Valid values:
	//
	// *   **RDS**: an ApsaraDB RDS instance.
	// *   **ECS_OWN**: a self-managed database deployed on an Elastic Compute Service (ECS) instance.
	// *   **PUBLIC_OWN**: a self-managed database instance that is connected over the Internet.
	// *   **VPC_ID**: a self-managed database instance in a virtual private cloud (VPC) that is connected over Express Connect circuits.
	// *   **GATEWAY**: a database instance connected by using a database gateway.
	InstanceSource *string `json:"InstanceSource,omitempty" xml:"InstanceSource,omitempty"`
	// The time when the database information was last obtained.
	LastSyncTime *string `json:"LastSyncTime,omitempty" xml:"LastSyncTime,omitempty"`
	// The instance level.
	Level *string `json:"Level,omitempty" xml:"Level,omitempty"`
	// Indicates whether the database is logical. Valid values:
	//
	// *   **true**
	// *   **false**
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The IDs of the owners of the databases, which are stored as an array. You can call the [GetUser](~~147098~~) or [ListUsers](~~141938~~) operation to query the IDs of the owners.
	//
	// >  The value of OwnerIds is the same as the value of UserId
	OwnerIds []*int64 `json:"OwnerIds,omitempty" xml:"OwnerIds,omitempty" type:"Repeated"`
	// The usernames of the database owners.
	OwnerNames []*string `json:"OwnerNames,omitempty" xml:"OwnerNames,omitempty" type:"Repeated"`
	// The port that is used to connect to the database.
	Port *int64 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The name of the database.
	SchemaName *string `json:"SchemaName,omitempty" xml:"SchemaName,omitempty"`
	// The name that is used to search for the database.
	SearchName *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
	// The details of the control mode of the instance.
	StandardGroup *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup `json:"StandardGroup,omitempty" xml:"StandardGroup,omitempty" type:"Struct"`
	// The status of the database. Valid values:
	//
	// *   **NORMAL**: The database is running as expected.
	// *   **DISABLE**: The database is disabled.
	// *   **OFFLINE**: The database is unpublished.
	// *   **NOT_EXIST**: The database does not exist.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// The number of tables.
	TableCount *int64 `json:"TableCount,omitempty" xml:"TableCount,omitempty"`
	// The name of TNS.
	TnsName *string `json:"TnsName,omitempty" xml:"TnsName,omitempty"`
	// The unit type.
	UnitType *string `json:"UnitType,omitempty" xml:"UnitType,omitempty"`
}

func (s GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) String() string {
	return tea.Prettify(s)
}

func (s GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) GoString() string {
	return s.String()
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetAlias(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.Alias = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetAlterTimeout(v int64) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.AlterTimeout = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetAssetControl(v bool) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.AssetControl = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetCatalogName(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.CatalogName = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetClusterNode(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.ClusterNode = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetDbId(v int64) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.DbId = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetDbType(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.DbType = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetDbaId(v int64) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.DbaId = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetDbaName(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.DbaName = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetDescription(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.Description = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetEncoding(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.Encoding = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetEnvType(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.EnvType = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetFollow(v bool) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.Follow = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetHost(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.Host = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetIdc(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.Idc = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetIdcTitle(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.IdcTitle = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetInstanceId(v int64) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.InstanceId = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetInstanceSource(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.InstanceSource = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetLastSyncTime(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.LastSyncTime = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetLevel(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.Level = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetLogic(v bool) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.Logic = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetOwnerIds(v []*int64) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.OwnerIds = v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetOwnerNames(v []*string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.OwnerNames = v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetPort(v int64) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.Port = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetSchemaName(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.SchemaName = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetSearchName(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.SearchName = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetStandardGroup(v *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.StandardGroup = v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetState(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.State = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetTableCount(v int64) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.TableCount = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetTnsName(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.TnsName = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo) SetUnitType(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfo {
	s.UnitType = &v
	return s
}

type GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup struct {
	// The type of the instance engine. For information about the valid values of this parameter, see [DbType parameter](~~198106~~).
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The description of the security rule set.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether the instance is managed in Flexible Management or Stable Change mode. Valid values:
	//
	// *   **true**
	// *   **false**
	FreeOrStable *bool `json:"FreeOrStable,omitempty" xml:"FreeOrStable,omitempty"`
	// The time when the security rule was created.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The time when the security rule was last modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The type of the control mode of the instance. Valid values:
	//
	// *   **COMMON**: The instance is managed in Security Collaboration mode.
	// *   **NONE_CONTROL**: The instance is managed in Flexible Management mode.
	// *   **STABLE**: The instance is managed in Stable Change mode.
	GroupMode *string `json:"GroupMode,omitempty" xml:"GroupMode,omitempty"`
	// The name of the security rule that corresponds to the control mode.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the security rule.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The user ID of the last modified security rule.
	LastMenderId *int64 `json:"LastMenderId,omitempty" xml:"LastMenderId,omitempty"`
}

func (s GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup) String() string {
	return tea.Prettify(s)
}

func (s GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup) GoString() string {
	return s.String()
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup) SetDbType(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup {
	s.DbType = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup) SetDescription(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup {
	s.Description = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup) SetFreeOrStable(v bool) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup {
	s.FreeOrStable = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup) SetGmtCreate(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup {
	s.GmtCreate = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup) SetGmtModified(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup {
	s.GmtModified = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup) SetGroupMode(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup {
	s.GroupMode = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup) SetGroupName(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup {
	s.GroupName = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup) SetId(v int64) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup {
	s.Id = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup) SetLastMenderId(v int64) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataDbBaseInfoStandardGroup {
	s.LastMenderId = &v
	return s
}

type GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances struct {
	// The business time of the task flow. The time is in the yyyy-MM-DD HH:mm:ss format.
	BusinessTime *string `json:"BusinessTime,omitempty" xml:"BusinessTime,omitempty"`
	// The ID of the task. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The end time of the task flow. The time is in the yyyy-MM-DD HH:mm:ss format.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time when the task flow was created.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The time when the task flow was last modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the historical task flow.
	HistoryDagId *int64 `json:"HistoryDagId,omitempty" xml:"HistoryDagId,omitempty"`
	// The instance ID of the running task flow.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The running scenario of the last task flow.
	LastRunningContext *string `json:"LastRunningContext,omitempty" xml:"LastRunningContext,omitempty"`
	// The running details of the task.
	Msg *string `json:"Msg,omitempty" xml:"Msg,omitempty"`
	// The status of the task. Valid values:
	//
	// *   **0**: waiting for execution.
	// *   **1**: running.
	// *   **2**: suspended.
	// *   **3**: failed.
	// *   **4**: successful.
	// *   **5**: complete.
	Status *int64 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tenant ID.
	TenantId *string `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
	// The mode in which the task flow was triggered. Valid values:
	//
	// *   **0**: The task flow was triggered based on a schedule.
	// *   **1**: The task flow was manually triggered.
	TriggerType *int64 `json:"TriggerType,omitempty" xml:"TriggerType,omitempty"`
	// The version number.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances) String() string {
	return tea.Prettify(s)
}

func (s GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances) GoString() string {
	return s.String()
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances) SetBusinessTime(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances {
	s.BusinessTime = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances) SetDagId(v int64) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances {
	s.DagId = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances) SetEndTime(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances {
	s.EndTime = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances) SetGmtCreate(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances {
	s.GmtCreate = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances) SetGmtModified(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances {
	s.GmtModified = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances) SetHistoryDagId(v int64) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances {
	s.HistoryDagId = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances) SetId(v int64) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances {
	s.Id = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances) SetLastRunningContext(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances {
	s.LastRunningContext = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances) SetMsg(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances {
	s.Msg = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances) SetStatus(v int64) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances {
	s.Status = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances) SetTenantId(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances {
	s.TenantId = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances) SetTriggerType(v int64) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances {
	s.TriggerType = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances) SetVersion(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataInstances {
	s.Version = &v
	return s
}

type GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataNextFireTimeResult struct {
	// The type of scheduled triggering.
	CronFireType *string `json:"CronFireType,omitempty" xml:"CronFireType,omitempty"`
}

func (s GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataNextFireTimeResult) String() string {
	return tea.Prettify(s)
}

func (s GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataNextFireTimeResult) GoString() string {
	return s.String()
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataNextFireTimeResult) SetCronFireType(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginExtraDataNextFireTimeResult {
	s.CronFireType = &v
	return s
}

type GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam struct {
	// The type of the archiving destination.
	ArchiveMethod *string `json:"ArchiveMethod,omitempty" xml:"ArchiveMethod,omitempty"`
	// The schema of the database and table to be archived.
	DbSchema *string `json:"DbSchema,omitempty" xml:"DbSchema,omitempty"`
	// Indicates whether the database is logical.
	//
	// *   **true**
	// *   **false**
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The post behavior of archiving.
	OrderAfter []*string `json:"OrderAfter,omitempty" xml:"OrderAfter,omitempty" type:"Repeated"`
	// The running method, which indicates whether to run the task immediately or at a specific point in time.
	RunMethod *string `json:"RunMethod,omitempty" xml:"RunMethod,omitempty"`
	// The ID of the source database.
	SourceDatabaseId *int64 `json:"SourceDatabaseId,omitempty" xml:"SourceDatabaseId,omitempty"`
	// The list of the archived tables and the filter conditions.
	TableIncludes []*GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParamTableIncludes `json:"TableIncludes,omitempty" xml:"TableIncludes,omitempty" type:"Repeated"`
	// The mapping of schemas.
	TableMapping []*string `json:"TableMapping,omitempty" xml:"TableMapping,omitempty" type:"Repeated"`
	// The ID of the destination instance.
	TargetInstanceId *string `json:"TargetInstanceId,omitempty" xml:"TargetInstanceId,omitempty"`
	// The time variable defined for scheduled archiving.
	Variables []*string `json:"Variables,omitempty" xml:"Variables,omitempty" type:"Repeated"`
}

func (s GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam) String() string {
	return tea.Prettify(s)
}

func (s GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam) GoString() string {
	return s.String()
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam) SetArchiveMethod(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam {
	s.ArchiveMethod = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam) SetDbSchema(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam {
	s.DbSchema = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam) SetLogic(v bool) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam {
	s.Logic = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam) SetOrderAfter(v []*string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam {
	s.OrderAfter = v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam) SetRunMethod(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam {
	s.RunMethod = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam) SetSourceDatabaseId(v int64) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam {
	s.SourceDatabaseId = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam) SetTableIncludes(v []*GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParamTableIncludes) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam {
	s.TableIncludes = v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam) SetTableMapping(v []*string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam {
	s.TableMapping = v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam) SetTargetInstanceId(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam {
	s.TargetInstanceId = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam) SetVariables(v []*string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParam {
	s.Variables = v
	return s
}

type GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParamTableIncludes struct {
	// The name of the table.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	// The filter conditions.
	TableWhere *string `json:"TableWhere,omitempty" xml:"TableWhere,omitempty"`
}

func (s GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParamTableIncludes) String() string {
	return tea.Prettify(s)
}

func (s GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParamTableIncludes) GoString() string {
	return s.String()
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParamTableIncludes) SetTableName(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParamTableIncludes {
	s.TableName = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParamTableIncludes) SetTableWhere(v string) *GetDataArchiveOrderDetailResponseBodyDataArchiveOrderDetailPluginParamTableIncludes {
	s.TableWhere = &v
	return s
}

type GetDataArchiveOrderDetailResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDataArchiveOrderDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDataArchiveOrderDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDataArchiveOrderDetailResponse) GoString() string {
	return s.String()
}

func (s *GetDataArchiveOrderDetailResponse) SetHeaders(v map[string]*string) *GetDataArchiveOrderDetailResponse {
	s.Headers = v
	return s
}

func (s *GetDataArchiveOrderDetailResponse) SetStatusCode(v int32) *GetDataArchiveOrderDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDataArchiveOrderDetailResponse) SetBody(v *GetDataArchiveOrderDetailResponseBody) *GetDataArchiveOrderDetailResponse {
	s.Body = v
	return s
}

type GetDataCorrectBackupFilesRequest struct {
	// The parameters that are required to perform the operation. You do not need to specify this parameter.
	ActionDetail map[string]interface{} `json:"ActionDetail,omitempty" xml:"ActionDetail,omitempty"`
	// The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to obtain the ticket ID.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetDataCorrectBackupFilesRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDataCorrectBackupFilesRequest) GoString() string {
	return s.String()
}

func (s *GetDataCorrectBackupFilesRequest) SetActionDetail(v map[string]interface{}) *GetDataCorrectBackupFilesRequest {
	s.ActionDetail = v
	return s
}

func (s *GetDataCorrectBackupFilesRequest) SetOrderId(v int64) *GetDataCorrectBackupFilesRequest {
	s.OrderId = &v
	return s
}

func (s *GetDataCorrectBackupFilesRequest) SetTid(v int64) *GetDataCorrectBackupFilesRequest {
	s.Tid = &v
	return s
}

type GetDataCorrectBackupFilesShrinkRequest struct {
	// The parameters that are required to perform the operation. You do not need to specify this parameter.
	ActionDetailShrink *string `json:"ActionDetail,omitempty" xml:"ActionDetail,omitempty"`
	// The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to obtain the ticket ID.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetDataCorrectBackupFilesShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDataCorrectBackupFilesShrinkRequest) GoString() string {
	return s.String()
}

func (s *GetDataCorrectBackupFilesShrinkRequest) SetActionDetailShrink(v string) *GetDataCorrectBackupFilesShrinkRequest {
	s.ActionDetailShrink = &v
	return s
}

func (s *GetDataCorrectBackupFilesShrinkRequest) SetOrderId(v int64) *GetDataCorrectBackupFilesShrinkRequest {
	s.OrderId = &v
	return s
}

func (s *GetDataCorrectBackupFilesShrinkRequest) SetTid(v int64) *GetDataCorrectBackupFilesShrinkRequest {
	s.Tid = &v
	return s
}

type GetDataCorrectBackupFilesResponseBody struct {
	// The download URL of the backup file for the ticket.
	DataCorrectBackupFiles *GetDataCorrectBackupFilesResponseBodyDataCorrectBackupFiles `json:"DataCorrectBackupFiles,omitempty" xml:"DataCorrectBackupFiles,omitempty" type:"Struct"`
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDataCorrectBackupFilesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDataCorrectBackupFilesResponseBody) GoString() string {
	return s.String()
}

func (s *GetDataCorrectBackupFilesResponseBody) SetDataCorrectBackupFiles(v *GetDataCorrectBackupFilesResponseBodyDataCorrectBackupFiles) *GetDataCorrectBackupFilesResponseBody {
	s.DataCorrectBackupFiles = v
	return s
}

func (s *GetDataCorrectBackupFilesResponseBody) SetErrorCode(v string) *GetDataCorrectBackupFilesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetDataCorrectBackupFilesResponseBody) SetErrorMessage(v string) *GetDataCorrectBackupFilesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDataCorrectBackupFilesResponseBody) SetRequestId(v string) *GetDataCorrectBackupFilesResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDataCorrectBackupFilesResponseBody) SetSuccess(v bool) *GetDataCorrectBackupFilesResponseBody {
	s.Success = &v
	return s
}

type GetDataCorrectBackupFilesResponseBodyDataCorrectBackupFiles struct {
	FileUrl []*string `json:"FileUrl,omitempty" xml:"FileUrl,omitempty" type:"Repeated"`
}

func (s GetDataCorrectBackupFilesResponseBodyDataCorrectBackupFiles) String() string {
	return tea.Prettify(s)
}

func (s GetDataCorrectBackupFilesResponseBodyDataCorrectBackupFiles) GoString() string {
	return s.String()
}

func (s *GetDataCorrectBackupFilesResponseBodyDataCorrectBackupFiles) SetFileUrl(v []*string) *GetDataCorrectBackupFilesResponseBodyDataCorrectBackupFiles {
	s.FileUrl = v
	return s
}

type GetDataCorrectBackupFilesResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDataCorrectBackupFilesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDataCorrectBackupFilesResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDataCorrectBackupFilesResponse) GoString() string {
	return s.String()
}

func (s *GetDataCorrectBackupFilesResponse) SetHeaders(v map[string]*string) *GetDataCorrectBackupFilesResponse {
	s.Headers = v
	return s
}

func (s *GetDataCorrectBackupFilesResponse) SetStatusCode(v int32) *GetDataCorrectBackupFilesResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDataCorrectBackupFilesResponse) SetBody(v *GetDataCorrectBackupFilesResponseBody) *GetDataCorrectBackupFilesResponse {
	s.Body = v
	return s
}

type GetDataCorrectOrderDetailRequest struct {
	// The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to obtain the ticket ID.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetDataCorrectOrderDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDataCorrectOrderDetailRequest) GoString() string {
	return s.String()
}

func (s *GetDataCorrectOrderDetailRequest) SetOrderId(v int64) *GetDataCorrectOrderDetailRequest {
	s.OrderId = &v
	return s
}

func (s *GetDataCorrectOrderDetailRequest) SetTid(v int64) *GetDataCorrectOrderDetailRequest {
	s.Tid = &v
	return s
}

type GetDataCorrectOrderDetailResponseBody struct {
	// The information about the data change ticket.
	DataCorrectOrderDetail *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail `json:"DataCorrectOrderDetail,omitempty" xml:"DataCorrectOrderDetail,omitempty" type:"Struct"`
	// The error code returned if the request fails.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// - **true**: The request is successful.
	// - **false**: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDataCorrectOrderDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDataCorrectOrderDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetDataCorrectOrderDetailResponseBody) SetDataCorrectOrderDetail(v *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail) *GetDataCorrectOrderDetailResponseBody {
	s.DataCorrectOrderDetail = v
	return s
}

func (s *GetDataCorrectOrderDetailResponseBody) SetErrorCode(v string) *GetDataCorrectOrderDetailResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetDataCorrectOrderDetailResponseBody) SetErrorMessage(v string) *GetDataCorrectOrderDetailResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDataCorrectOrderDetailResponseBody) SetRequestId(v string) *GetDataCorrectOrderDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDataCorrectOrderDetailResponseBody) SetSuccess(v bool) *GetDataCorrectOrderDetailResponseBody {
	s.Success = &v
	return s
}

type GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail struct {
	// The information about the database in which data is changed.
	DatabaseList *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseList `json:"DatabaseList,omitempty" xml:"DatabaseList,omitempty" type:"Struct"`
	// The execution mode of the ticket after the ticket is approved. Valid values:
	//
	// - **COMMITOR**: The data change is performed by the user who submits the ticket.
	// - **AUTO**: The data change is automatically performed after the ticket is approved.
	// - **LAST_AUDITOR**: The data change is performed by the last approver of the ticket.
	ExecMode *string `json:"ExecMode,omitempty" xml:"ExecMode,omitempty"`
	// The details of the ticket.
	OrderDetail *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail `json:"OrderDetail,omitempty" xml:"OrderDetail,omitempty" type:"Struct"`
	// The precheck details of the ticket.
	PreCheckDetail *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetail `json:"PreCheckDetail,omitempty" xml:"PreCheckDetail,omitempty" type:"Struct"`
	// The status of the ticket. Valid values:
	//
	// - **new**: The ticket is created.
	// - **precheck**: The ticket is being prechecked.
	// - **precheck_fail**: The ticket fails the precheck.
	// - **precheck_success**: The ticket passes the precheck and waits to be submitted for approval.
	// - **toaudit**: The ticket is being reviewed.
	// - **Approved**: The ticket is approved.
	// - **reject**: The ticket is rejected.
	// - **waiting**: The ticket is submitted and waits to be scheduled.
	// - **processing**: The ticket is being executed.
	// - **success**: The ticket is executed.
	// - **closed**: The ticket is closed.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail) String() string {
	return tea.Prettify(s)
}

func (s GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail) GoString() string {
	return s.String()
}

func (s *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail) SetDatabaseList(v *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseList) *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail {
	s.DatabaseList = v
	return s
}

func (s *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail) SetExecMode(v string) *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail {
	s.ExecMode = &v
	return s
}

func (s *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail) SetOrderDetail(v *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail) *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail {
	s.OrderDetail = v
	return s
}

func (s *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail) SetPreCheckDetail(v *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetail) *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail {
	s.PreCheckDetail = v
	return s
}

func (s *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail) SetStatus(v string) *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetail {
	s.Status = &v
	return s
}

type GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseList struct {
	Database []*GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase `json:"Database,omitempty" xml:"Database,omitempty" type:"Repeated"`
}

func (s GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseList) String() string {
	return tea.Prettify(s)
}

func (s GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseList) GoString() string {
	return s.String()
}

func (s *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseList) SetDatabase(v []*GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase) *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseList {
	s.Database = v
	return s
}

type GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase struct {
	// The ID of the database.
	DbId *int32 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The engine of the database.
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The type of the environment to which the database belongs. Valid values:
	//
	// - product: production environment
	// - dev: development environment
	// - pre: staging environment
	// - test: test environment
	// - sit: system integration testing (SIT) environment
	// - uat: user acceptance testing (UAT) environment
	// - pet: stress testing environment
	// - stag: STAG environment
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// Indicates whether the database is a logical database. Valid values:
	//
	// - **true**: The database is a logical database.
	// - **false**: The database is a physical database.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The name that is used to search for the database.
	SearchName *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
}

func (s GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase) String() string {
	return tea.Prettify(s)
}

func (s GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase) GoString() string {
	return s.String()
}

func (s *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase) SetDbId(v int32) *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase {
	s.DbId = &v
	return s
}

func (s *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase) SetDbType(v string) *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase {
	s.DbType = &v
	return s
}

func (s *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase) SetEnvType(v string) *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase {
	s.EnvType = &v
	return s
}

func (s *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase) SetLogic(v bool) *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase {
	s.Logic = &v
	return s
}

func (s *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase) SetSearchName(v string) *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailDatabaseListDatabase {
	s.SearchName = &v
	return s
}

type GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail struct {
	// The number of affected rows that is obtained by the precheck.
	ActualAffectRows *int64 `json:"ActualAffectRows,omitempty" xml:"ActualAffectRows,omitempty"`
	// The name of the attachment that contains the SQL statements used to change data.
	AttachmentName *string `json:"AttachmentName,omitempty" xml:"AttachmentName,omitempty"`
	// The category of the reason for the data change.
	Classify *string `json:"Classify,omitempty" xml:"Classify,omitempty"`
	// The estimated number of affected rows.
	EstimateAffectRows *int64 `json:"EstimateAffectRows,omitempty" xml:"EstimateAffectRows,omitempty"`
	// The executed SQL statements.
	ExeSQL *string `json:"ExeSQL,omitempty" xml:"ExeSQL,omitempty"`
	// Indicates whether the precheck result is ignored. Valid values:
	//
	// - **true**: The precheck result is ignored.
	// - **false**: The precheck result is not ignored.
	IgnoreAffectRows *bool `json:"IgnoreAffectRows,omitempty" xml:"IgnoreAffectRows,omitempty"`
	// The reason why the precheck result is ignored.
	IgnoreAffectRowsReason *string `json:"IgnoreAffectRowsReason,omitempty" xml:"IgnoreAffectRowsReason,omitempty"`
	// The name of the attachment that contains the SQL statements used to roll back the data change.
	RbAttachmentName *string `json:"RbAttachmentName,omitempty" xml:"RbAttachmentName,omitempty"`
	// The SQL statements used to roll back the data change.
	RbSQL *string `json:"RbSQL,omitempty" xml:"RbSQL,omitempty"`
	// The format of the SQL statements used to roll back the data change. Valid values:
	//
	// - **TEXT**: text
	// - **ATTACHMENT**: attachment
	RbSQLType *string `json:"RbSQLType,omitempty" xml:"RbSQLType,omitempty"`
	// The format of the SQL statements used to change data. Valid values:
	//
	// - **TEXT**: text
	// - **ATTACHMENT**: attachment
	SqlType *string `json:"SqlType,omitempty" xml:"SqlType,omitempty"`
}

func (s GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail) String() string {
	return tea.Prettify(s)
}

func (s GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail) GoString() string {
	return s.String()
}

func (s *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail) SetActualAffectRows(v int64) *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail {
	s.ActualAffectRows = &v
	return s
}

func (s *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail) SetAttachmentName(v string) *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail {
	s.AttachmentName = &v
	return s
}

func (s *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail) SetClassify(v string) *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail {
	s.Classify = &v
	return s
}

func (s *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail) SetEstimateAffectRows(v int64) *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail {
	s.EstimateAffectRows = &v
	return s
}

func (s *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail) SetExeSQL(v string) *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail {
	s.ExeSQL = &v
	return s
}

func (s *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail) SetIgnoreAffectRows(v bool) *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail {
	s.IgnoreAffectRows = &v
	return s
}

func (s *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail) SetIgnoreAffectRowsReason(v string) *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail {
	s.IgnoreAffectRowsReason = &v
	return s
}

func (s *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail) SetRbAttachmentName(v string) *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail {
	s.RbAttachmentName = &v
	return s
}

func (s *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail) SetRbSQL(v string) *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail {
	s.RbSQL = &v
	return s
}

func (s *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail) SetRbSQLType(v string) *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail {
	s.RbSQLType = &v
	return s
}

func (s *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail) SetSqlType(v string) *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailOrderDetail {
	s.SqlType = &v
	return s
}

type GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetail struct {
	TaskCheckDO []*GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO `json:"TaskCheckDO,omitempty" xml:"TaskCheckDO,omitempty" type:"Repeated"`
}

func (s GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetail) String() string {
	return tea.Prettify(s)
}

func (s GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetail) GoString() string {
	return s.String()
}

func (s *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetail) SetTaskCheckDO(v []*GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO) *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetail {
	s.TaskCheckDO = v
	return s
}

type GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO struct {
	// The status of the precheck. Valid values:
	//
	// *   **WAITING**: The ticket is pending precheck.
	// *   **RUNNING**: The ticket is being prechecked.
	// *   **SUCCESS**: The ticket passes the precheck.
	// *   **FAIL**: The ticket fails the precheck.
	CheckStatus *string `json:"CheckStatus,omitempty" xml:"CheckStatus,omitempty"`
	// The check step of the precheck. Valid values:
	//
	// *   **SQL_PARSE**: The system checks the syntax of the SQL statement.
	// *   **SQL_TYPE_CHECK**: The system checks the type of the SQL statement.
	// *   **PERMISSION_CHECK**: The system checks the permissions required for the data change.
	// *   **ROW_CHECK**: The system checks the number of affected rows.
	CheckStep *string `json:"CheckStep,omitempty" xml:"CheckStep,omitempty"`
	// The message that indicates a check step.
	UserTip *string `json:"UserTip,omitempty" xml:"UserTip,omitempty"`
}

func (s GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO) String() string {
	return tea.Prettify(s)
}

func (s GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO) GoString() string {
	return s.String()
}

func (s *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO) SetCheckStatus(v string) *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO {
	s.CheckStatus = &v
	return s
}

func (s *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO) SetCheckStep(v string) *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO {
	s.CheckStep = &v
	return s
}

func (s *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO) SetUserTip(v string) *GetDataCorrectOrderDetailResponseBodyDataCorrectOrderDetailPreCheckDetailTaskCheckDO {
	s.UserTip = &v
	return s
}

type GetDataCorrectOrderDetailResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDataCorrectOrderDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDataCorrectOrderDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDataCorrectOrderDetailResponse) GoString() string {
	return s.String()
}

func (s *GetDataCorrectOrderDetailResponse) SetHeaders(v map[string]*string) *GetDataCorrectOrderDetailResponse {
	s.Headers = v
	return s
}

func (s *GetDataCorrectOrderDetailResponse) SetStatusCode(v int32) *GetDataCorrectOrderDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDataCorrectOrderDetailResponse) SetBody(v *GetDataCorrectOrderDetailResponseBody) *GetDataCorrectOrderDetailResponse {
	s.Body = v
	return s
}

type GetDataCorrectRollbackFileRequest struct {
	// The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to query the ticket ID.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant.
	//
	// > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetDataCorrectRollbackFileRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDataCorrectRollbackFileRequest) GoString() string {
	return s.String()
}

func (s *GetDataCorrectRollbackFileRequest) SetOrderId(v int64) *GetDataCorrectRollbackFileRequest {
	s.OrderId = &v
	return s
}

func (s *GetDataCorrectRollbackFileRequest) SetTid(v int64) *GetDataCorrectRollbackFileRequest {
	s.Tid = &v
	return s
}

type GetDataCorrectRollbackFileResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The download URL of the attachment.
	FileUrl *string `json:"FileUrl,omitempty" xml:"FileUrl,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDataCorrectRollbackFileResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDataCorrectRollbackFileResponseBody) GoString() string {
	return s.String()
}

func (s *GetDataCorrectRollbackFileResponseBody) SetErrorCode(v string) *GetDataCorrectRollbackFileResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetDataCorrectRollbackFileResponseBody) SetErrorMessage(v string) *GetDataCorrectRollbackFileResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDataCorrectRollbackFileResponseBody) SetFileUrl(v string) *GetDataCorrectRollbackFileResponseBody {
	s.FileUrl = &v
	return s
}

func (s *GetDataCorrectRollbackFileResponseBody) SetRequestId(v string) *GetDataCorrectRollbackFileResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDataCorrectRollbackFileResponseBody) SetSuccess(v bool) *GetDataCorrectRollbackFileResponseBody {
	s.Success = &v
	return s
}

type GetDataCorrectRollbackFileResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDataCorrectRollbackFileResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDataCorrectRollbackFileResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDataCorrectRollbackFileResponse) GoString() string {
	return s.String()
}

func (s *GetDataCorrectRollbackFileResponse) SetHeaders(v map[string]*string) *GetDataCorrectRollbackFileResponse {
	s.Headers = v
	return s
}

func (s *GetDataCorrectRollbackFileResponse) SetStatusCode(v int32) *GetDataCorrectRollbackFileResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDataCorrectRollbackFileResponse) SetBody(v *GetDataCorrectRollbackFileResponseBody) *GetDataCorrectRollbackFileResponse {
	s.Body = v
	return s
}

type GetDataCorrectSQLFileRequest struct {
	// The ID of the ticket.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant.
	//
	// > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetDataCorrectSQLFileRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDataCorrectSQLFileRequest) GoString() string {
	return s.String()
}

func (s *GetDataCorrectSQLFileRequest) SetOrderId(v int64) *GetDataCorrectSQLFileRequest {
	s.OrderId = &v
	return s
}

func (s *GetDataCorrectSQLFileRequest) SetTid(v int64) *GetDataCorrectSQLFileRequest {
	s.Tid = &v
	return s
}

type GetDataCorrectSQLFileResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The download URL of the SQL script.
	FileUrl *string `json:"FileUrl,omitempty" xml:"FileUrl,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDataCorrectSQLFileResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDataCorrectSQLFileResponseBody) GoString() string {
	return s.String()
}

func (s *GetDataCorrectSQLFileResponseBody) SetErrorCode(v string) *GetDataCorrectSQLFileResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetDataCorrectSQLFileResponseBody) SetErrorMessage(v string) *GetDataCorrectSQLFileResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDataCorrectSQLFileResponseBody) SetFileUrl(v string) *GetDataCorrectSQLFileResponseBody {
	s.FileUrl = &v
	return s
}

func (s *GetDataCorrectSQLFileResponseBody) SetRequestId(v string) *GetDataCorrectSQLFileResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDataCorrectSQLFileResponseBody) SetSuccess(v bool) *GetDataCorrectSQLFileResponseBody {
	s.Success = &v
	return s
}

type GetDataCorrectSQLFileResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDataCorrectSQLFileResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDataCorrectSQLFileResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDataCorrectSQLFileResponse) GoString() string {
	return s.String()
}

func (s *GetDataCorrectSQLFileResponse) SetHeaders(v map[string]*string) *GetDataCorrectSQLFileResponse {
	s.Headers = v
	return s
}

func (s *GetDataCorrectSQLFileResponse) SetStatusCode(v int32) *GetDataCorrectSQLFileResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDataCorrectSQLFileResponse) SetBody(v *GetDataCorrectSQLFileResponseBody) *GetDataCorrectSQLFileResponse {
	s.Body = v
	return s
}

type GetDataCorrectTaskDetailRequest struct {
	// The ID of the ticket. You can call the [CreateDataCorrectOrder](~~208388~~), [CreateDataImportOrder](~~208387~~), or [CreateFreeLockCorrectOrder](~~208386~~) operation to obtain the ticket ID.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant.
	//
	// > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetDataCorrectTaskDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDataCorrectTaskDetailRequest) GoString() string {
	return s.String()
}

func (s *GetDataCorrectTaskDetailRequest) SetOrderId(v int64) *GetDataCorrectTaskDetailRequest {
	s.OrderId = &v
	return s
}

func (s *GetDataCorrectTaskDetailRequest) SetTid(v int64) *GetDataCorrectTaskDetailRequest {
	s.Tid = &v
	return s
}

type GetDataCorrectTaskDetailResponseBody struct {
	// The details of the data change task.
	DataCorrectTaskDetail *GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail `json:"DataCorrectTaskDetail,omitempty" xml:"DataCorrectTaskDetail,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDataCorrectTaskDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDataCorrectTaskDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetDataCorrectTaskDetailResponseBody) SetDataCorrectTaskDetail(v *GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail) *GetDataCorrectTaskDetailResponseBody {
	s.DataCorrectTaskDetail = v
	return s
}

func (s *GetDataCorrectTaskDetailResponseBody) SetErrorCode(v string) *GetDataCorrectTaskDetailResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetDataCorrectTaskDetailResponseBody) SetErrorMessage(v string) *GetDataCorrectTaskDetailResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDataCorrectTaskDetailResponseBody) SetRequestId(v string) *GetDataCorrectTaskDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDataCorrectTaskDetailResponseBody) SetSuccess(v bool) *GetDataCorrectTaskDetailResponseBody {
	s.Success = &v
	return s
}

type GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail struct {
	// The number of rows affected by the SQL statement.
	ActualAffectRows *int64 `json:"ActualAffectRows,omitempty" xml:"ActualAffectRows,omitempty"`
	// The time when the task was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the SQL task group.
	DBTaskGroupId *int64 `json:"DBTaskGroupId,omitempty" xml:"DBTaskGroupId,omitempty"`
	// The state of the SQL task. Valid values:
	//
	// *   **INIT**: The SQL task was initialized.
	// *   **PENDING**: The SQL task waited to be run.
	// *   **BE_SCHEDULED**: The SQL task waited to be scheduled.
	// *   **FAIL**: The SQL task failed.
	// *   **SUCCESS**: The SQL task was successful.
	// *   **PAUSE**: The SQL task was paused.
	// *   **DELETE**: The SQL task was deleted.
	// *   **RUNNING**: The SQL task was being run.
	JobStatus *string `json:"jobStatus,omitempty" xml:"jobStatus,omitempty"`
}

func (s GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail) String() string {
	return tea.Prettify(s)
}

func (s GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail) GoString() string {
	return s.String()
}

func (s *GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail) SetActualAffectRows(v int64) *GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail {
	s.ActualAffectRows = &v
	return s
}

func (s *GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail) SetCreateTime(v string) *GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail {
	s.CreateTime = &v
	return s
}

func (s *GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail) SetDBTaskGroupId(v int64) *GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail {
	s.DBTaskGroupId = &v
	return s
}

func (s *GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail) SetJobStatus(v string) *GetDataCorrectTaskDetailResponseBodyDataCorrectTaskDetail {
	s.JobStatus = &v
	return s
}

type GetDataCorrectTaskDetailResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDataCorrectTaskDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDataCorrectTaskDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDataCorrectTaskDetailResponse) GoString() string {
	return s.String()
}

func (s *GetDataCorrectTaskDetailResponse) SetHeaders(v map[string]*string) *GetDataCorrectTaskDetailResponse {
	s.Headers = v
	return s
}

func (s *GetDataCorrectTaskDetailResponse) SetStatusCode(v int32) *GetDataCorrectTaskDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDataCorrectTaskDetailResponse) SetBody(v *GetDataCorrectTaskDetailResponseBody) *GetDataCorrectTaskDetailResponse {
	s.Body = v
	return s
}

type GetDataCronClearConfigRequest struct {
	// The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to query the ticket ID.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant.
	//
	// > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetDataCronClearConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDataCronClearConfigRequest) GoString() string {
	return s.String()
}

func (s *GetDataCronClearConfigRequest) SetOrderId(v int64) *GetDataCronClearConfigRequest {
	s.OrderId = &v
	return s
}

func (s *GetDataCronClearConfigRequest) SetTid(v int64) *GetDataCronClearConfigRequest {
	s.Tid = &v
	return s
}

type GetDataCronClearConfigResponseBody struct {
	// Data configuration.
	DataCronClearConfig *GetDataCronClearConfigResponseBodyDataCronClearConfig `json:"DataCronClearConfig,omitempty" xml:"DataCronClearConfig,omitempty" type:"Struct"`
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDataCronClearConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDataCronClearConfigResponseBody) GoString() string {
	return s.String()
}

func (s *GetDataCronClearConfigResponseBody) SetDataCronClearConfig(v *GetDataCronClearConfigResponseBodyDataCronClearConfig) *GetDataCronClearConfigResponseBody {
	s.DataCronClearConfig = v
	return s
}

func (s *GetDataCronClearConfigResponseBody) SetErrorCode(v string) *GetDataCronClearConfigResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetDataCronClearConfigResponseBody) SetErrorMessage(v string) *GetDataCronClearConfigResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDataCronClearConfigResponseBody) SetRequestId(v string) *GetDataCronClearConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDataCronClearConfigResponseBody) SetSuccess(v bool) *GetDataCronClearConfigResponseBody {
	s.Success = &v
	return s
}

type GetDataCronClearConfigResponseBodyDataCronClearConfig struct {
	// The number of times that the task is run.
	CronCallTimes *string `json:"CronCallTimes,omitempty" xml:"CronCallTimes,omitempty"`
	// The crontab expression that you can use to run the task at a specified time. For more information, see [Crontab expression](~~206581~~).
	CronFormat *string `json:"CronFormat,omitempty" xml:"CronFormat,omitempty"`
	// The time when the task was last run.
	CronLastCallStartTime *string `json:"CronLastCallStartTime,omitempty" xml:"CronLastCallStartTime,omitempty"`
	// The time when the task is run next time. This parameter is displayed only when the status of the scheduled task is SUCCESS.
	CronNextCallTime *string `json:"CronNextCallTime,omitempty" xml:"CronNextCallTime,omitempty"`
	// The status of the scheduled task. If this parameter is empty, it indicates the task is not run. Valid values:
	//
	// *   PAUSE: The task is suspended.
	// *   WAITING: The task is waiting to be run.
	// *   SUCCESS: The task is complete.
	CronStatus *string `json:"CronStatus,omitempty" xml:"CronStatus,omitempty"`
	// The number of times that the Optimize Table statement is automatically exeuted. This parameter is valid only when the value of the OptimizeTableAfterEveryClearTimes parameter is greater than 0.
	CurrentClearTaskCount *int64 `json:"CurrentClearTaskCount,omitempty" xml:"CurrentClearTaskCount,omitempty"`
	// The execution duration of the task. Unit: hours. If the value is 0, it indicates the duration is not specified.
	Duration *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// Specifies whether to enable automatic execution of the OPTIMIZE TABLE statement. Valid values:
	//
	// *   0: disables automatic execution
	// *   A number greater than 0: enables automatic execution. The number specifies the number of times that cleanup operations must be performed before the OPTIMIZE TABLE statement is automatically executed.
	OptimizeTableAfterEveryClearTimes *int64 `json:"OptimizeTableAfterEveryClearTimes,omitempty" xml:"OptimizeTableAfterEveryClearTimes,omitempty"`
}

func (s GetDataCronClearConfigResponseBodyDataCronClearConfig) String() string {
	return tea.Prettify(s)
}

func (s GetDataCronClearConfigResponseBodyDataCronClearConfig) GoString() string {
	return s.String()
}

func (s *GetDataCronClearConfigResponseBodyDataCronClearConfig) SetCronCallTimes(v string) *GetDataCronClearConfigResponseBodyDataCronClearConfig {
	s.CronCallTimes = &v
	return s
}

func (s *GetDataCronClearConfigResponseBodyDataCronClearConfig) SetCronFormat(v string) *GetDataCronClearConfigResponseBodyDataCronClearConfig {
	s.CronFormat = &v
	return s
}

func (s *GetDataCronClearConfigResponseBodyDataCronClearConfig) SetCronLastCallStartTime(v string) *GetDataCronClearConfigResponseBodyDataCronClearConfig {
	s.CronLastCallStartTime = &v
	return s
}

func (s *GetDataCronClearConfigResponseBodyDataCronClearConfig) SetCronNextCallTime(v string) *GetDataCronClearConfigResponseBodyDataCronClearConfig {
	s.CronNextCallTime = &v
	return s
}

func (s *GetDataCronClearConfigResponseBodyDataCronClearConfig) SetCronStatus(v string) *GetDataCronClearConfigResponseBodyDataCronClearConfig {
	s.CronStatus = &v
	return s
}

func (s *GetDataCronClearConfigResponseBodyDataCronClearConfig) SetCurrentClearTaskCount(v int64) *GetDataCronClearConfigResponseBodyDataCronClearConfig {
	s.CurrentClearTaskCount = &v
	return s
}

func (s *GetDataCronClearConfigResponseBodyDataCronClearConfig) SetDuration(v string) *GetDataCronClearConfigResponseBodyDataCronClearConfig {
	s.Duration = &v
	return s
}

func (s *GetDataCronClearConfigResponseBodyDataCronClearConfig) SetOptimizeTableAfterEveryClearTimes(v int64) *GetDataCronClearConfigResponseBodyDataCronClearConfig {
	s.OptimizeTableAfterEveryClearTimes = &v
	return s
}

type GetDataCronClearConfigResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDataCronClearConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDataCronClearConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDataCronClearConfigResponse) GoString() string {
	return s.String()
}

func (s *GetDataCronClearConfigResponse) SetHeaders(v map[string]*string) *GetDataCronClearConfigResponse {
	s.Headers = v
	return s
}

func (s *GetDataCronClearConfigResponse) SetStatusCode(v int32) *GetDataCronClearConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDataCronClearConfigResponse) SetBody(v *GetDataCronClearConfigResponseBody) *GetDataCronClearConfigResponse {
	s.Body = v
	return s
}

type GetDataCronClearTaskDetailListRequest struct {
	// The ID of the ticket. You can query the ticket ID from the response parameters of the [CreateDataCronClearOrder](~~208385~~) operation.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The number of the page to return.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the tenant.
	//
	// > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetDataCronClearTaskDetailListRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDataCronClearTaskDetailListRequest) GoString() string {
	return s.String()
}

func (s *GetDataCronClearTaskDetailListRequest) SetOrderId(v int64) *GetDataCronClearTaskDetailListRequest {
	s.OrderId = &v
	return s
}

func (s *GetDataCronClearTaskDetailListRequest) SetPageNumber(v int64) *GetDataCronClearTaskDetailListRequest {
	s.PageNumber = &v
	return s
}

func (s *GetDataCronClearTaskDetailListRequest) SetPageSize(v int64) *GetDataCronClearTaskDetailListRequest {
	s.PageSize = &v
	return s
}

func (s *GetDataCronClearTaskDetailListRequest) SetTid(v int64) *GetDataCronClearTaskDetailListRequest {
	s.Tid = &v
	return s
}

type GetDataCronClearTaskDetailListResponseBody struct {
	// The historical data cleansing tasks
	DataCronClearTaskDetailList []*GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList `json:"DataCronClearTaskDetailList,omitempty" xml:"DataCronClearTaskDetailList,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of SQL tasks.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s GetDataCronClearTaskDetailListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDataCronClearTaskDetailListResponseBody) GoString() string {
	return s.String()
}

func (s *GetDataCronClearTaskDetailListResponseBody) SetDataCronClearTaskDetailList(v []*GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList) *GetDataCronClearTaskDetailListResponseBody {
	s.DataCronClearTaskDetailList = v
	return s
}

func (s *GetDataCronClearTaskDetailListResponseBody) SetErrorCode(v string) *GetDataCronClearTaskDetailListResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetDataCronClearTaskDetailListResponseBody) SetErrorMessage(v string) *GetDataCronClearTaskDetailListResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDataCronClearTaskDetailListResponseBody) SetRequestId(v string) *GetDataCronClearTaskDetailListResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDataCronClearTaskDetailListResponseBody) SetSuccess(v bool) *GetDataCronClearTaskDetailListResponseBody {
	s.Success = &v
	return s
}

func (s *GetDataCronClearTaskDetailListResponseBody) SetTotalCount(v int64) *GetDataCronClearTaskDetailListResponseBody {
	s.TotalCount = &v
	return s
}

type GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList struct {
	// The number of rows affected by the SQL task.
	ActualAffectRows *int64 `json:"ActualAffectRows,omitempty" xml:"ActualAffectRows,omitempty"`
	// The time when the SQL task was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the SQL task group.
	DBTaskGroupId *int64 `json:"DBTaskGroupId,omitempty" xml:"DBTaskGroupId,omitempty"`
	// The state of the SQL task. Valid values:
	//
	// *   **INIT**: The SQL task was initialized.
	// *   **PENDING**: The SQL task waited to be run.
	// *   **BE_SCHEDULED**: The SQL task waited to be scheduled.
	// *   **FAIL**: The SQL task failed.
	// *   **SUCCESS**: The SQL task was successful.
	// *   **PAUSE**: The SQL task was paused.
	// *   **DELETE**: The SQL task was deleted.
	// *   **RUNNING**: The SQL task was being run.
	JobStatus *string `json:"jobStatus,omitempty" xml:"jobStatus,omitempty"`
}

func (s GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList) String() string {
	return tea.Prettify(s)
}

func (s GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList) GoString() string {
	return s.String()
}

func (s *GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList) SetActualAffectRows(v int64) *GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList {
	s.ActualAffectRows = &v
	return s
}

func (s *GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList) SetCreateTime(v string) *GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList {
	s.CreateTime = &v
	return s
}

func (s *GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList) SetDBTaskGroupId(v int64) *GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList {
	s.DBTaskGroupId = &v
	return s
}

func (s *GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList) SetJobStatus(v string) *GetDataCronClearTaskDetailListResponseBodyDataCronClearTaskDetailList {
	s.JobStatus = &v
	return s
}

type GetDataCronClearTaskDetailListResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDataCronClearTaskDetailListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDataCronClearTaskDetailListResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDataCronClearTaskDetailListResponse) GoString() string {
	return s.String()
}

func (s *GetDataCronClearTaskDetailListResponse) SetHeaders(v map[string]*string) *GetDataCronClearTaskDetailListResponse {
	s.Headers = v
	return s
}

func (s *GetDataCronClearTaskDetailListResponse) SetStatusCode(v int32) *GetDataCronClearTaskDetailListResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDataCronClearTaskDetailListResponse) SetBody(v *GetDataCronClearTaskDetailListResponseBody) *GetDataCronClearTaskDetailListResponse {
	s.Body = v
	return s
}

type GetDataExportDownloadURLRequest struct {
	// The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to obtain the ticket ID.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetDataExportDownloadURLRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDataExportDownloadURLRequest) GoString() string {
	return s.String()
}

func (s *GetDataExportDownloadURLRequest) SetOrderId(v int64) *GetDataExportDownloadURLRequest {
	s.OrderId = &v
	return s
}

func (s *GetDataExportDownloadURLRequest) SetTid(v int64) *GetDataExportDownloadURLRequest {
	s.Tid = &v
	return s
}

type GetDataExportDownloadURLResponseBody struct {
	// The details about the download URL of the file that records the export results for the ticket.
	DownloadURLResult *GetDataExportDownloadURLResponseBodyDownloadURLResult `json:"DownloadURLResult,omitempty" xml:"DownloadURLResult,omitempty" type:"Struct"`
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDataExportDownloadURLResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDataExportDownloadURLResponseBody) GoString() string {
	return s.String()
}

func (s *GetDataExportDownloadURLResponseBody) SetDownloadURLResult(v *GetDataExportDownloadURLResponseBodyDownloadURLResult) *GetDataExportDownloadURLResponseBody {
	s.DownloadURLResult = v
	return s
}

func (s *GetDataExportDownloadURLResponseBody) SetErrorCode(v string) *GetDataExportDownloadURLResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetDataExportDownloadURLResponseBody) SetErrorMessage(v string) *GetDataExportDownloadURLResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDataExportDownloadURLResponseBody) SetRequestId(v string) *GetDataExportDownloadURLResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDataExportDownloadURLResponseBody) SetSuccess(v bool) *GetDataExportDownloadURLResponseBody {
	s.Success = &v
	return s
}

type GetDataExportDownloadURLResponseBodyDownloadURLResult struct {
	// Indicates whether export results are available for download. Valid values:
	//
	// *   **true**: Export results are available for download.
	// *   **false**: No export results are available for download.
	HasResult *bool `json:"HasResult,omitempty" xml:"HasResult,omitempty"`
	// The message that indicates an exception.
	TipMessage *string `json:"TipMessage,omitempty" xml:"TipMessage,omitempty"`
	// The download URL of the file that records the export results for the ticket.
	URL *string `json:"URL,omitempty" xml:"URL,omitempty"`
}

func (s GetDataExportDownloadURLResponseBodyDownloadURLResult) String() string {
	return tea.Prettify(s)
}

func (s GetDataExportDownloadURLResponseBodyDownloadURLResult) GoString() string {
	return s.String()
}

func (s *GetDataExportDownloadURLResponseBodyDownloadURLResult) SetHasResult(v bool) *GetDataExportDownloadURLResponseBodyDownloadURLResult {
	s.HasResult = &v
	return s
}

func (s *GetDataExportDownloadURLResponseBodyDownloadURLResult) SetTipMessage(v string) *GetDataExportDownloadURLResponseBodyDownloadURLResult {
	s.TipMessage = &v
	return s
}

func (s *GetDataExportDownloadURLResponseBodyDownloadURLResult) SetURL(v string) *GetDataExportDownloadURLResponseBodyDownloadURLResult {
	s.URL = &v
	return s
}

type GetDataExportDownloadURLResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDataExportDownloadURLResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDataExportDownloadURLResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDataExportDownloadURLResponse) GoString() string {
	return s.String()
}

func (s *GetDataExportDownloadURLResponse) SetHeaders(v map[string]*string) *GetDataExportDownloadURLResponse {
	s.Headers = v
	return s
}

func (s *GetDataExportDownloadURLResponse) SetStatusCode(v int32) *GetDataExportDownloadURLResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDataExportDownloadURLResponse) SetBody(v *GetDataExportDownloadURLResponseBody) *GetDataExportDownloadURLResponse {
	s.Body = v
	return s
}

type GetDataExportOrderDetailRequest struct {
	// The ticket ID. You can call the [ListOrders](~~465867~~) operation to query the ticket ID.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant.
	//
	// > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetDataExportOrderDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDataExportOrderDetailRequest) GoString() string {
	return s.String()
}

func (s *GetDataExportOrderDetailRequest) SetOrderId(v int64) *GetDataExportOrderDetailRequest {
	s.OrderId = &v
	return s
}

func (s *GetDataExportOrderDetailRequest) SetTid(v int64) *GetDataExportOrderDetailRequest {
	s.Tid = &v
	return s
}

type GetDataExportOrderDetailResponseBody struct {
	// The information about the data export ticket.
	DataExportOrderDetail *GetDataExportOrderDetailResponseBodyDataExportOrderDetail `json:"DataExportOrderDetail,omitempty" xml:"DataExportOrderDetail,omitempty" type:"Struct"`
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values: Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDataExportOrderDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDataExportOrderDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetDataExportOrderDetailResponseBody) SetDataExportOrderDetail(v *GetDataExportOrderDetailResponseBodyDataExportOrderDetail) *GetDataExportOrderDetailResponseBody {
	s.DataExportOrderDetail = v
	return s
}

func (s *GetDataExportOrderDetailResponseBody) SetErrorCode(v string) *GetDataExportOrderDetailResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetDataExportOrderDetailResponseBody) SetErrorMessage(v string) *GetDataExportOrderDetailResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDataExportOrderDetailResponseBody) SetRequestId(v string) *GetDataExportOrderDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDataExportOrderDetailResponseBody) SetSuccess(v bool) *GetDataExportOrderDetailResponseBody {
	s.Success = &v
	return s
}

type GetDataExportOrderDetailResponseBodyDataExportOrderDetail struct {
	// The information about the ticket.
	KeyInfo *GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo `json:"KeyInfo,omitempty" xml:"KeyInfo,omitempty" type:"Struct"`
	// The details of the ticket.
	OrderDetail *GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail `json:"OrderDetail,omitempty" xml:"OrderDetail,omitempty" type:"Struct"`
}

func (s GetDataExportOrderDetailResponseBodyDataExportOrderDetail) String() string {
	return tea.Prettify(s)
}

func (s GetDataExportOrderDetailResponseBodyDataExportOrderDetail) GoString() string {
	return s.String()
}

func (s *GetDataExportOrderDetailResponseBodyDataExportOrderDetail) SetKeyInfo(v *GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo) *GetDataExportOrderDetailResponseBodyDataExportOrderDetail {
	s.KeyInfo = v
	return s
}

func (s *GetDataExportOrderDetailResponseBodyDataExportOrderDetail) SetOrderDetail(v *GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail) *GetDataExportOrderDetailResponseBodyDataExportOrderDetail {
	s.OrderDetail = v
	return s
}

type GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo struct {
	// The state of the data export ticket. Valid values:
	//
	// *   **PRE_CHECKING**: The ticket was being prechecked.
	// *   **PRE_CHECK_SUCCESS**: The ticket passed the precheck.
	// *   **PRE_CHECK_FAIL**: The ticket failed to pass the prechecked.
	// *   **WAITING_APPLY_AUDIT**: The ticket was to be submitted for approval.
	// *   **APPLY_AUDIT_SUCCESS**: The ticket was submitted for approval.
	// *   **ENABLE_EXPORT**: The ticket was approved. Data can be exported.
	// *   **WAITING_EXPORT**: Data was to be scheduled for export.
	// *   **DOING_EXPORT**: Data was being exported.
	// *   **EXPORT_FAIL**: Data failed to be exported.
	// *   **EXPORT_SUCCESS**: Data was exported.
	JobStatus *string `json:"JobStatus,omitempty" xml:"JobStatus,omitempty"`
	// The precheck ID.
	PreCheckId *int64 `json:"PreCheckId,omitempty" xml:"PreCheckId,omitempty"`
}

func (s GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo) String() string {
	return tea.Prettify(s)
}

func (s GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo) GoString() string {
	return s.String()
}

func (s *GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo) SetJobStatus(v string) *GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo {
	s.JobStatus = &v
	return s
}

func (s *GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo) SetPreCheckId(v int64) *GetDataExportOrderDetailResponseBodyDataExportOrderDetailKeyInfo {
	s.PreCheckId = &v
	return s
}

type GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail struct {
	// The number of rows that were affected by the SQL statement.
	ActualAffectRows *int64 `json:"ActualAffectRows,omitempty" xml:"ActualAffectRows,omitempty"`
	// The category of the reason for the data export.
	Classify *string `json:"Classify,omitempty" xml:"Classify,omitempty"`
	// The name of the database from which data was exported.
	Database *string `json:"Database,omitempty" xml:"Database,omitempty"`
	// The ID of the database from which data was exported.
	DbId *int32 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The type of the environment to which the database belongs.
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The SQL statement that was executed to export data.
	ExeSQL *string `json:"ExeSQL,omitempty" xml:"ExeSQL,omitempty"`
	// Indicates whether the affected rows are skipped.
	IgnoreAffectRows *bool `json:"IgnoreAffectRows,omitempty" xml:"IgnoreAffectRows,omitempty"`
	// The reason why the affected rows are skipped.
	IgnoreAffectRowsReason *string `json:"IgnoreAffectRowsReason,omitempty" xml:"IgnoreAffectRowsReason,omitempty"`
	// Indicates whether the database is a logical database.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
}

func (s GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail) String() string {
	return tea.Prettify(s)
}

func (s GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail) GoString() string {
	return s.String()
}

func (s *GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail) SetActualAffectRows(v int64) *GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail {
	s.ActualAffectRows = &v
	return s
}

func (s *GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail) SetClassify(v string) *GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail {
	s.Classify = &v
	return s
}

func (s *GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail) SetDatabase(v string) *GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail {
	s.Database = &v
	return s
}

func (s *GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail) SetDbId(v int32) *GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail {
	s.DbId = &v
	return s
}

func (s *GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail) SetEnvType(v string) *GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail {
	s.EnvType = &v
	return s
}

func (s *GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail) SetExeSQL(v string) *GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail {
	s.ExeSQL = &v
	return s
}

func (s *GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail) SetIgnoreAffectRows(v bool) *GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail {
	s.IgnoreAffectRows = &v
	return s
}

func (s *GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail) SetIgnoreAffectRowsReason(v string) *GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail {
	s.IgnoreAffectRowsReason = &v
	return s
}

func (s *GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail) SetLogic(v bool) *GetDataExportOrderDetailResponseBodyDataExportOrderDetailOrderDetail {
	s.Logic = &v
	return s
}

type GetDataExportOrderDetailResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDataExportOrderDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDataExportOrderDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDataExportOrderDetailResponse) GoString() string {
	return s.String()
}

func (s *GetDataExportOrderDetailResponse) SetHeaders(v map[string]*string) *GetDataExportOrderDetailResponse {
	s.Headers = v
	return s
}

func (s *GetDataExportOrderDetailResponse) SetStatusCode(v int32) *GetDataExportOrderDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDataExportOrderDetailResponse) SetBody(v *GetDataExportOrderDetailResponseBody) *GetDataExportOrderDetailResponse {
	s.Body = v
	return s
}

type GetDataExportPreCheckDetailRequest struct {
	// The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to obtain the ticket ID.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetDataExportPreCheckDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDataExportPreCheckDetailRequest) GoString() string {
	return s.String()
}

func (s *GetDataExportPreCheckDetailRequest) SetOrderId(v int64) *GetDataExportPreCheckDetailRequest {
	s.OrderId = &v
	return s
}

func (s *GetDataExportPreCheckDetailRequest) SetTid(v int64) *GetDataExportPreCheckDetailRequest {
	s.Tid = &v
	return s
}

type GetDataExportPreCheckDetailResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// Indicates the result of the precheck task.
	PreCheckResult *GetDataExportPreCheckDetailResponseBodyPreCheckResult `json:"PreCheckResult,omitempty" xml:"PreCheckResult,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDataExportPreCheckDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDataExportPreCheckDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetDataExportPreCheckDetailResponseBody) SetErrorCode(v string) *GetDataExportPreCheckDetailResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetDataExportPreCheckDetailResponseBody) SetErrorMessage(v string) *GetDataExportPreCheckDetailResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDataExportPreCheckDetailResponseBody) SetPreCheckResult(v *GetDataExportPreCheckDetailResponseBodyPreCheckResult) *GetDataExportPreCheckDetailResponseBody {
	s.PreCheckResult = v
	return s
}

func (s *GetDataExportPreCheckDetailResponseBody) SetRequestId(v string) *GetDataExportPreCheckDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDataExportPreCheckDetailResponseBody) SetSuccess(v bool) *GetDataExportPreCheckDetailResponseBody {
	s.Success = &v
	return s
}

type GetDataExportPreCheckDetailResponseBodyPreCheckResult struct {
	// Specifies whether to skip verification. Valid values:
	//
	// - true
	// - false
	IgnoreAffectRows *bool `json:"IgnoreAffectRows,omitempty" xml:"IgnoreAffectRows,omitempty"`
	// The list of pre-check details.
	PreCheckDetailList *GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailList `json:"PreCheckDetailList,omitempty" xml:"PreCheckDetailList,omitempty" type:"Struct"`
}

func (s GetDataExportPreCheckDetailResponseBodyPreCheckResult) String() string {
	return tea.Prettify(s)
}

func (s GetDataExportPreCheckDetailResponseBodyPreCheckResult) GoString() string {
	return s.String()
}

func (s *GetDataExportPreCheckDetailResponseBodyPreCheckResult) SetIgnoreAffectRows(v bool) *GetDataExportPreCheckDetailResponseBodyPreCheckResult {
	s.IgnoreAffectRows = &v
	return s
}

func (s *GetDataExportPreCheckDetailResponseBodyPreCheckResult) SetPreCheckDetailList(v *GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailList) *GetDataExportPreCheckDetailResponseBodyPreCheckResult {
	s.PreCheckDetailList = v
	return s
}

type GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailList struct {
	PreCheckDetailList []*GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailListPreCheckDetailList `json:"PreCheckDetailList,omitempty" xml:"PreCheckDetailList,omitempty" type:"Repeated"`
}

func (s GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailList) String() string {
	return tea.Prettify(s)
}

func (s GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailList) GoString() string {
	return s.String()
}

func (s *GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailList) SetPreCheckDetailList(v []*GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailListPreCheckDetailList) *GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailList {
	s.PreCheckDetailList = v
	return s
}

type GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailListPreCheckDetailList struct {
	// The estimated number of data rows to be affected.
	AffectRows *int64 `json:"AffectRows,omitempty" xml:"AffectRows,omitempty"`
	// The SQL statement.
	SQL *string `json:"SQL,omitempty" xml:"SQL,omitempty"`
}

func (s GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailListPreCheckDetailList) String() string {
	return tea.Prettify(s)
}

func (s GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailListPreCheckDetailList) GoString() string {
	return s.String()
}

func (s *GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailListPreCheckDetailList) SetAffectRows(v int64) *GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailListPreCheckDetailList {
	s.AffectRows = &v
	return s
}

func (s *GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailListPreCheckDetailList) SetSQL(v string) *GetDataExportPreCheckDetailResponseBodyPreCheckResultPreCheckDetailListPreCheckDetailList {
	s.SQL = &v
	return s
}

type GetDataExportPreCheckDetailResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDataExportPreCheckDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDataExportPreCheckDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDataExportPreCheckDetailResponse) GoString() string {
	return s.String()
}

func (s *GetDataExportPreCheckDetailResponse) SetHeaders(v map[string]*string) *GetDataExportPreCheckDetailResponse {
	s.Headers = v
	return s
}

func (s *GetDataExportPreCheckDetailResponse) SetStatusCode(v int32) *GetDataExportPreCheckDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDataExportPreCheckDetailResponse) SetBody(v *GetDataExportPreCheckDetailResponseBody) *GetDataExportPreCheckDetailResponse {
	s.Body = v
	return s
}

type GetDataImportSQLRequest struct {
	// The ticket ID. You can call the [ListOrders](~~144643~~) operation to query the ticket ID.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The SQL ID. You can call the ListDataImportSQLPreCheckDetail operation to query the SQL ID.
	SqlId *int64 `json:"SqlId,omitempty" xml:"SqlId,omitempty"`
	// The tenant ID. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetDataImportSQLRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDataImportSQLRequest) GoString() string {
	return s.String()
}

func (s *GetDataImportSQLRequest) SetOrderId(v int64) *GetDataImportSQLRequest {
	s.OrderId = &v
	return s
}

func (s *GetDataImportSQLRequest) SetSqlId(v int64) *GetDataImportSQLRequest {
	s.SqlId = &v
	return s
}

func (s *GetDataImportSQLRequest) SetTid(v int64) *GetDataImportSQLRequest {
	s.Tid = &v
	return s
}

type GetDataImportSQLResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID. You can use the ID to locate logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The details of SQL statements.
	SQLDetail *GetDataImportSQLResponseBodySQLDetail `json:"SQLDetail,omitempty" xml:"SQLDetail,omitempty" type:"Struct"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDataImportSQLResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDataImportSQLResponseBody) GoString() string {
	return s.String()
}

func (s *GetDataImportSQLResponseBody) SetErrorCode(v string) *GetDataImportSQLResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetDataImportSQLResponseBody) SetErrorMessage(v string) *GetDataImportSQLResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDataImportSQLResponseBody) SetRequestId(v string) *GetDataImportSQLResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDataImportSQLResponseBody) SetSQLDetail(v *GetDataImportSQLResponseBodySQLDetail) *GetDataImportSQLResponseBody {
	s.SQLDetail = v
	return s
}

func (s *GetDataImportSQLResponseBody) SetSuccess(v bool) *GetDataImportSQLResponseBody {
	s.Success = &v
	return s
}

type GetDataImportSQLResponseBodySQLDetail struct {
	// The SQL script.
	ExecSql *string `json:"ExecSql,omitempty" xml:"ExecSql,omitempty"`
}

func (s GetDataImportSQLResponseBodySQLDetail) String() string {
	return tea.Prettify(s)
}

func (s GetDataImportSQLResponseBodySQLDetail) GoString() string {
	return s.String()
}

func (s *GetDataImportSQLResponseBodySQLDetail) SetExecSql(v string) *GetDataImportSQLResponseBodySQLDetail {
	s.ExecSql = &v
	return s
}

type GetDataImportSQLResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDataImportSQLResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDataImportSQLResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDataImportSQLResponse) GoString() string {
	return s.String()
}

func (s *GetDataImportSQLResponse) SetHeaders(v map[string]*string) *GetDataImportSQLResponse {
	s.Headers = v
	return s
}

func (s *GetDataImportSQLResponse) SetStatusCode(v int32) *GetDataImportSQLResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDataImportSQLResponse) SetBody(v *GetDataImportSQLResponseBody) *GetDataImportSQLResponse {
	s.Body = v
	return s
}

type GetDataTrackJobDegreeRequest struct {
	// The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to query the ticket ID.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetDataTrackJobDegreeRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDataTrackJobDegreeRequest) GoString() string {
	return s.String()
}

func (s *GetDataTrackJobDegreeRequest) SetOrderId(v int64) *GetDataTrackJobDegreeRequest {
	s.OrderId = &v
	return s
}

func (s *GetDataTrackJobDegreeRequest) SetTid(v int64) *GetDataTrackJobDegreeRequest {
	s.Tid = &v
	return s
}

type GetDataTrackJobDegreeResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The progress details of the data tracking task.
	JobDegree *GetDataTrackJobDegreeResponseBodyJobDegree `json:"JobDegree,omitempty" xml:"JobDegree,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDataTrackJobDegreeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDataTrackJobDegreeResponseBody) GoString() string {
	return s.String()
}

func (s *GetDataTrackJobDegreeResponseBody) SetErrorCode(v string) *GetDataTrackJobDegreeResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetDataTrackJobDegreeResponseBody) SetErrorMessage(v string) *GetDataTrackJobDegreeResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDataTrackJobDegreeResponseBody) SetJobDegree(v *GetDataTrackJobDegreeResponseBodyJobDegree) *GetDataTrackJobDegreeResponseBody {
	s.JobDegree = v
	return s
}

func (s *GetDataTrackJobDegreeResponseBody) SetRequestId(v string) *GetDataTrackJobDegreeResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDataTrackJobDegreeResponseBody) SetSuccess(v bool) *GetDataTrackJobDegreeResponseBody {
	s.Success = &v
	return s
}

type GetDataTrackJobDegreeResponseBodyJobDegree struct {
	// The progress of binary log download. Valid values: 0 to 1. A value of 1 indicates that binary log download is complete.
	DownloadCompletionDegree *float64 `json:"DownloadCompletionDegree,omitempty" xml:"DownloadCompletionDegree,omitempty"`
	// The progress of binary log parsing. Valid values: 0 to 1. A value of 1 indicates that binary log parsing is complete.
	FilterCompletionDegree *float64 `json:"FilterCompletionDegree,omitempty" xml:"FilterCompletionDegree,omitempty"`
	// The status of the data tracking task. Valid values:
	//
	// *   **INIT**: The task is being initialized.
	// *   **LISTING**: The binary logs are being obtained.
	// *   **LIST_SUCCESS**: The binary logs are successfully obtained.
	// *   **DOWNLOADING**: The binary logs are being downloaded.
	// *   **DOWNLOAD_FAIL**: The binary logs failed to be downloaded.
	// *   **DOWNLOAD_SUCCESS**: The binary logs are successfully downloaded.
	// *   **FILTERING**: The binary logs are being parsed.
	// *   **FILTER_FAIL**: The binary logs failed to be parsed.
	// *   **FILTER_SUCCESS**: The binary logs are successfully parsed.
	JobStatus *string `json:"JobStatus,omitempty" xml:"JobStatus,omitempty"`
	// The progress of binary log obtaining. Valid values: 0 to 1. A value of 1 indicates that binary log obtaining is complete.
	ListCompletionDegree *float64 `json:"ListCompletionDegree,omitempty" xml:"ListCompletionDegree,omitempty"`
	// The description of the task status.
	StatusDesc *string `json:"StatusDesc,omitempty" xml:"StatusDesc,omitempty"`
}

func (s GetDataTrackJobDegreeResponseBodyJobDegree) String() string {
	return tea.Prettify(s)
}

func (s GetDataTrackJobDegreeResponseBodyJobDegree) GoString() string {
	return s.String()
}

func (s *GetDataTrackJobDegreeResponseBodyJobDegree) SetDownloadCompletionDegree(v float64) *GetDataTrackJobDegreeResponseBodyJobDegree {
	s.DownloadCompletionDegree = &v
	return s
}

func (s *GetDataTrackJobDegreeResponseBodyJobDegree) SetFilterCompletionDegree(v float64) *GetDataTrackJobDegreeResponseBodyJobDegree {
	s.FilterCompletionDegree = &v
	return s
}

func (s *GetDataTrackJobDegreeResponseBodyJobDegree) SetJobStatus(v string) *GetDataTrackJobDegreeResponseBodyJobDegree {
	s.JobStatus = &v
	return s
}

func (s *GetDataTrackJobDegreeResponseBodyJobDegree) SetListCompletionDegree(v float64) *GetDataTrackJobDegreeResponseBodyJobDegree {
	s.ListCompletionDegree = &v
	return s
}

func (s *GetDataTrackJobDegreeResponseBodyJobDegree) SetStatusDesc(v string) *GetDataTrackJobDegreeResponseBodyJobDegree {
	s.StatusDesc = &v
	return s
}

type GetDataTrackJobDegreeResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDataTrackJobDegreeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDataTrackJobDegreeResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDataTrackJobDegreeResponse) GoString() string {
	return s.String()
}

func (s *GetDataTrackJobDegreeResponse) SetHeaders(v map[string]*string) *GetDataTrackJobDegreeResponse {
	s.Headers = v
	return s
}

func (s *GetDataTrackJobDegreeResponse) SetStatusCode(v int32) *GetDataTrackJobDegreeResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDataTrackJobDegreeResponse) SetBody(v *GetDataTrackJobDegreeResponseBody) *GetDataTrackJobDegreeResponse {
	s.Body = v
	return s
}

type GetDataTrackJobTableMetaRequest struct {
	// The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to query the ID of the ticket.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the ID of the tenant.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetDataTrackJobTableMetaRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDataTrackJobTableMetaRequest) GoString() string {
	return s.String()
}

func (s *GetDataTrackJobTableMetaRequest) SetOrderId(v int64) *GetDataTrackJobTableMetaRequest {
	s.OrderId = &v
	return s
}

func (s *GetDataTrackJobTableMetaRequest) SetTid(v int64) *GetDataTrackJobTableMetaRequest {
	s.Tid = &v
	return s
}

type GetDataTrackJobTableMetaResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The metadata of tables.
	TableMetaList []*GetDataTrackJobTableMetaResponseBodyTableMetaList `json:"TableMetaList,omitempty" xml:"TableMetaList,omitempty" type:"Repeated"`
}

func (s GetDataTrackJobTableMetaResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDataTrackJobTableMetaResponseBody) GoString() string {
	return s.String()
}

func (s *GetDataTrackJobTableMetaResponseBody) SetErrorCode(v string) *GetDataTrackJobTableMetaResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetDataTrackJobTableMetaResponseBody) SetErrorMessage(v string) *GetDataTrackJobTableMetaResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDataTrackJobTableMetaResponseBody) SetRequestId(v string) *GetDataTrackJobTableMetaResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDataTrackJobTableMetaResponseBody) SetSuccess(v bool) *GetDataTrackJobTableMetaResponseBody {
	s.Success = &v
	return s
}

func (s *GetDataTrackJobTableMetaResponseBody) SetTableMetaList(v []*GetDataTrackJobTableMetaResponseBodyTableMetaList) *GetDataTrackJobTableMetaResponseBody {
	s.TableMetaList = v
	return s
}

type GetDataTrackJobTableMetaResponseBodyTableMetaList struct {
	// The information about columns.
	Columns []*GetDataTrackJobTableMetaResponseBodyTableMetaListColumns `json:"Columns,omitempty" xml:"Columns,omitempty" type:"Repeated"`
	// The name of the database.
	SchemaName *string `json:"SchemaName,omitempty" xml:"SchemaName,omitempty"`
	// The name of the table.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s GetDataTrackJobTableMetaResponseBodyTableMetaList) String() string {
	return tea.Prettify(s)
}

func (s GetDataTrackJobTableMetaResponseBodyTableMetaList) GoString() string {
	return s.String()
}

func (s *GetDataTrackJobTableMetaResponseBodyTableMetaList) SetColumns(v []*GetDataTrackJobTableMetaResponseBodyTableMetaListColumns) *GetDataTrackJobTableMetaResponseBodyTableMetaList {
	s.Columns = v
	return s
}

func (s *GetDataTrackJobTableMetaResponseBodyTableMetaList) SetSchemaName(v string) *GetDataTrackJobTableMetaResponseBodyTableMetaList {
	s.SchemaName = &v
	return s
}

func (s *GetDataTrackJobTableMetaResponseBodyTableMetaList) SetTableName(v string) *GetDataTrackJobTableMetaResponseBodyTableMetaList {
	s.TableName = &v
	return s
}

type GetDataTrackJobTableMetaResponseBodyTableMetaListColumns struct {
	// The name of the character set.
	Charset *string `json:"Charset,omitempty" xml:"Charset,omitempty"`
	// The name of the column.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The position of the column.
	ColumnPosition *int32 `json:"ColumnPosition,omitempty" xml:"ColumnPosition,omitempty"`
	// The data type of the column. Examples: BIGINT, INT, and VARCHAR.
	ColumnType *string `json:"ColumnType,omitempty" xml:"ColumnType,omitempty"`
	// Indicates whether the column is a virtual column. Valid values:
	//
	// *   **true**
	// *   **false**
	Fictive *bool `json:"Fictive,omitempty" xml:"Fictive,omitempty"`
}

func (s GetDataTrackJobTableMetaResponseBodyTableMetaListColumns) String() string {
	return tea.Prettify(s)
}

func (s GetDataTrackJobTableMetaResponseBodyTableMetaListColumns) GoString() string {
	return s.String()
}

func (s *GetDataTrackJobTableMetaResponseBodyTableMetaListColumns) SetCharset(v string) *GetDataTrackJobTableMetaResponseBodyTableMetaListColumns {
	s.Charset = &v
	return s
}

func (s *GetDataTrackJobTableMetaResponseBodyTableMetaListColumns) SetColumnName(v string) *GetDataTrackJobTableMetaResponseBodyTableMetaListColumns {
	s.ColumnName = &v
	return s
}

func (s *GetDataTrackJobTableMetaResponseBodyTableMetaListColumns) SetColumnPosition(v int32) *GetDataTrackJobTableMetaResponseBodyTableMetaListColumns {
	s.ColumnPosition = &v
	return s
}

func (s *GetDataTrackJobTableMetaResponseBodyTableMetaListColumns) SetColumnType(v string) *GetDataTrackJobTableMetaResponseBodyTableMetaListColumns {
	s.ColumnType = &v
	return s
}

func (s *GetDataTrackJobTableMetaResponseBodyTableMetaListColumns) SetFictive(v bool) *GetDataTrackJobTableMetaResponseBodyTableMetaListColumns {
	s.Fictive = &v
	return s
}

type GetDataTrackJobTableMetaResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDataTrackJobTableMetaResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDataTrackJobTableMetaResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDataTrackJobTableMetaResponse) GoString() string {
	return s.String()
}

func (s *GetDataTrackJobTableMetaResponse) SetHeaders(v map[string]*string) *GetDataTrackJobTableMetaResponse {
	s.Headers = v
	return s
}

func (s *GetDataTrackJobTableMetaResponse) SetStatusCode(v int32) *GetDataTrackJobTableMetaResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDataTrackJobTableMetaResponse) SetBody(v *GetDataTrackJobTableMetaResponseBody) *GetDataTrackJobTableMetaResponse {
	s.Body = v
	return s
}

type GetDataTrackOrderDetailRequest struct {
	// The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to query the ticket ID.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetDataTrackOrderDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDataTrackOrderDetailRequest) GoString() string {
	return s.String()
}

func (s *GetDataTrackOrderDetailRequest) SetOrderId(v int64) *GetDataTrackOrderDetailRequest {
	s.OrderId = &v
	return s
}

func (s *GetDataTrackOrderDetailRequest) SetTid(v int64) *GetDataTrackOrderDetailRequest {
	s.Tid = &v
	return s
}

type GetDataTrackOrderDetailResponseBody struct {
	// The details of the ticket.
	DataTrackOrderDetail *GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail `json:"DataTrackOrderDetail,omitempty" xml:"DataTrackOrderDetail,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDataTrackOrderDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDataTrackOrderDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetDataTrackOrderDetailResponseBody) SetDataTrackOrderDetail(v *GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail) *GetDataTrackOrderDetailResponseBody {
	s.DataTrackOrderDetail = v
	return s
}

func (s *GetDataTrackOrderDetailResponseBody) SetErrorCode(v string) *GetDataTrackOrderDetailResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetDataTrackOrderDetailResponseBody) SetErrorMessage(v string) *GetDataTrackOrderDetailResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDataTrackOrderDetailResponseBody) SetRequestId(v string) *GetDataTrackOrderDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDataTrackOrderDetailResponseBody) SetSuccess(v bool) *GetDataTrackOrderDetailResponseBody {
	s.Success = &v
	return s
}

type GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail struct {
	// The name that is used to search for the database.
	DatabaseSearchName *string `json:"DatabaseSearchName,omitempty" xml:"DatabaseSearchName,omitempty"`
	// The ID of the database.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The end time of the time range in which data operations are tracked. The time is in the yyyy-MM-dd HH:mm:ss format.
	JobEndTime *string `json:"JobEndTime,omitempty" xml:"JobEndTime,omitempty"`
	// The start time of the time range in which data operations are tracked. The time is in the yyyy-MM-dd HH:mm:ss format.
	JobStartTime *string `json:"JobStartTime,omitempty" xml:"JobStartTime,omitempty"`
	// The status of the data tracking task. Valid values:
	//
	// *   **INIT**: The task is being initialized.
	// *   **LISTING**: The binary logs are being obtained.
	// *   **LIST_SUCCESS**: The binary logs are successfully obtained.
	// *   **DOWNLOADING**: The binary logs are being downloaded.
	// *   **DOWNLOAD_FAIL**: The binary logs failed to be downloaded.
	// *   **DOWNLOAD_SUCCESS**: The binary logs are successfully downloaded.
	// *   **FILTERING**: The binary logs are being parsed.
	// *   **FILTER_FAIL**: The binary logs failed to be parsed.
	// *   **FILTER_SUCCESS**: The binary logs are successfully parsed.
	JobStatus *string `json:"JobStatus,omitempty" xml:"JobStatus,omitempty"`
	// Indicates whether the database is a logical database. Valid values:
	//
	// *   **true**
	// *   **false**
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The name of the database.
	SchemaName *string `json:"SchemaName,omitempty" xml:"SchemaName,omitempty"`
	// The description of the task status.
	StatusDesc *string `json:"StatusDesc,omitempty" xml:"StatusDesc,omitempty"`
	// The names of the tables for which data operations are tracked.
	TableNames []*string `json:"TableNames,omitempty" xml:"TableNames,omitempty" type:"Repeated"`
	// The types of data operations that are tracked.
	TrackTypes []*string `json:"TrackTypes,omitempty" xml:"TrackTypes,omitempty" type:"Repeated"`
}

func (s GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail) String() string {
	return tea.Prettify(s)
}

func (s GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail) GoString() string {
	return s.String()
}

func (s *GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail) SetDatabaseSearchName(v string) *GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail {
	s.DatabaseSearchName = &v
	return s
}

func (s *GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail) SetDbId(v int64) *GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail {
	s.DbId = &v
	return s
}

func (s *GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail) SetJobEndTime(v string) *GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail {
	s.JobEndTime = &v
	return s
}

func (s *GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail) SetJobStartTime(v string) *GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail {
	s.JobStartTime = &v
	return s
}

func (s *GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail) SetJobStatus(v string) *GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail {
	s.JobStatus = &v
	return s
}

func (s *GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail) SetLogic(v bool) *GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail {
	s.Logic = &v
	return s
}

func (s *GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail) SetSchemaName(v string) *GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail {
	s.SchemaName = &v
	return s
}

func (s *GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail) SetStatusDesc(v string) *GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail {
	s.StatusDesc = &v
	return s
}

func (s *GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail) SetTableNames(v []*string) *GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail {
	s.TableNames = v
	return s
}

func (s *GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail) SetTrackTypes(v []*string) *GetDataTrackOrderDetailResponseBodyDataTrackOrderDetail {
	s.TrackTypes = v
	return s
}

type GetDataTrackOrderDetailResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDataTrackOrderDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDataTrackOrderDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDataTrackOrderDetailResponse) GoString() string {
	return s.String()
}

func (s *GetDataTrackOrderDetailResponse) SetHeaders(v map[string]*string) *GetDataTrackOrderDetailResponse {
	s.Headers = v
	return s
}

func (s *GetDataTrackOrderDetailResponse) SetStatusCode(v int32) *GetDataTrackOrderDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDataTrackOrderDetailResponse) SetBody(v *GetDataTrackOrderDetailResponseBody) *GetDataTrackOrderDetailResponse {
	s.Body = v
	return s
}

type GetDatabaseRequest struct {
	// The endpoint that is used to connect to the database.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The port that is used to connect to the database.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The name of the database.
	SchemaName *string `json:"SchemaName,omitempty" xml:"SchemaName,omitempty"`
	// The system identifier (SID) of the database.
	//
	// >  The SID uniquely identifies an Oracle database. After a database is created, a SID is generated for the database.
	Sid *string `json:"Sid,omitempty" xml:"Sid,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the ID of the tenant.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetDatabaseRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDatabaseRequest) GoString() string {
	return s.String()
}

func (s *GetDatabaseRequest) SetHost(v string) *GetDatabaseRequest {
	s.Host = &v
	return s
}

func (s *GetDatabaseRequest) SetPort(v int32) *GetDatabaseRequest {
	s.Port = &v
	return s
}

func (s *GetDatabaseRequest) SetSchemaName(v string) *GetDatabaseRequest {
	s.SchemaName = &v
	return s
}

func (s *GetDatabaseRequest) SetSid(v string) *GetDatabaseRequest {
	s.Sid = &v
	return s
}

func (s *GetDatabaseRequest) SetTid(v int64) *GetDatabaseRequest {
	s.Tid = &v
	return s
}

type GetDatabaseResponseBody struct {
	// The details of the database.
	Database *GetDatabaseResponseBodyDatabase `json:"Database,omitempty" xml:"Database,omitempty" type:"Struct"`
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**: The request is successful.
	// *   **false**: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDatabaseResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDatabaseResponseBody) GoString() string {
	return s.String()
}

func (s *GetDatabaseResponseBody) SetDatabase(v *GetDatabaseResponseBodyDatabase) *GetDatabaseResponseBody {
	s.Database = v
	return s
}

func (s *GetDatabaseResponseBody) SetErrorCode(v string) *GetDatabaseResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetDatabaseResponseBody) SetErrorMessage(v string) *GetDatabaseResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDatabaseResponseBody) SetRequestId(v string) *GetDatabaseResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDatabaseResponseBody) SetSuccess(v bool) *GetDatabaseResponseBody {
	s.Success = &v
	return s
}

type GetDatabaseResponseBodyDatabase struct {
	// The name of the catalog to which the database belongs.
	CatalogName *string `json:"CatalogName,omitempty" xml:"CatalogName,omitempty"`
	// The ID of the database.
	DatabaseId *string `json:"DatabaseId,omitempty" xml:"DatabaseId,omitempty"`
	// The type of the database. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The ID of the database administrator (DBA).
	DbaId *string `json:"DbaId,omitempty" xml:"DbaId,omitempty"`
	// The nickname of the DBA.
	DbaName *string `json:"DbaName,omitempty" xml:"DbaName,omitempty"`
	// The encoding format of the database.
	Encoding *string `json:"Encoding,omitempty" xml:"Encoding,omitempty"`
	// The type of the environment to which the database belongs. Valid values:
	//
	// *   **product**: production environment
	// *   **dev**: development environment
	// *   **pre**: staging environment
	// *   **test**: test environment
	// *   **sit**: SIT environment
	// *   **uat**: user acceptance testing (UAT) environment
	// *   **pet**: stress testing environment
	// *   **stag**: STAG environment
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The endpoint that is used to connect to the database.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The alias of the instance.
	InstanceAlias *string `json:"InstanceAlias,omitempty" xml:"InstanceAlias,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The IDs of the owners of the database.
	OwnerIdList *GetDatabaseResponseBodyDatabaseOwnerIdList `json:"OwnerIdList,omitempty" xml:"OwnerIdList,omitempty" type:"Struct"`
	// The names of the owners of the database.
	OwnerNameList *GetDatabaseResponseBodyDatabaseOwnerNameList `json:"OwnerNameList,omitempty" xml:"OwnerNameList,omitempty" type:"Struct"`
	// The port that is used to connect to the database.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The name of the database.
	SchemaName *string `json:"SchemaName,omitempty" xml:"SchemaName,omitempty"`
	// The keyword that is used to search for the database.
	SearchName *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
	// The SID of the database.
	//
	// >  The value of the parameter is returned only for Oracle databases.
	Sid *string `json:"Sid,omitempty" xml:"Sid,omitempty"`
	// The status of the database. Valid values:
	//
	// *   **NORMAL**: The database is running as expected.
	// *   **DISABLE**: The database is disabled.
	// *   **OFFLINE**: The database is unpublished.
	// *   **NOT_EXIST**: The database does not exist.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s GetDatabaseResponseBodyDatabase) String() string {
	return tea.Prettify(s)
}

func (s GetDatabaseResponseBodyDatabase) GoString() string {
	return s.String()
}

func (s *GetDatabaseResponseBodyDatabase) SetCatalogName(v string) *GetDatabaseResponseBodyDatabase {
	s.CatalogName = &v
	return s
}

func (s *GetDatabaseResponseBodyDatabase) SetDatabaseId(v string) *GetDatabaseResponseBodyDatabase {
	s.DatabaseId = &v
	return s
}

func (s *GetDatabaseResponseBodyDatabase) SetDbType(v string) *GetDatabaseResponseBodyDatabase {
	s.DbType = &v
	return s
}

func (s *GetDatabaseResponseBodyDatabase) SetDbaId(v string) *GetDatabaseResponseBodyDatabase {
	s.DbaId = &v
	return s
}

func (s *GetDatabaseResponseBodyDatabase) SetDbaName(v string) *GetDatabaseResponseBodyDatabase {
	s.DbaName = &v
	return s
}

func (s *GetDatabaseResponseBodyDatabase) SetEncoding(v string) *GetDatabaseResponseBodyDatabase {
	s.Encoding = &v
	return s
}

func (s *GetDatabaseResponseBodyDatabase) SetEnvType(v string) *GetDatabaseResponseBodyDatabase {
	s.EnvType = &v
	return s
}

func (s *GetDatabaseResponseBodyDatabase) SetHost(v string) *GetDatabaseResponseBodyDatabase {
	s.Host = &v
	return s
}

func (s *GetDatabaseResponseBodyDatabase) SetInstanceAlias(v string) *GetDatabaseResponseBodyDatabase {
	s.InstanceAlias = &v
	return s
}

func (s *GetDatabaseResponseBodyDatabase) SetInstanceId(v string) *GetDatabaseResponseBodyDatabase {
	s.InstanceId = &v
	return s
}

func (s *GetDatabaseResponseBodyDatabase) SetOwnerIdList(v *GetDatabaseResponseBodyDatabaseOwnerIdList) *GetDatabaseResponseBodyDatabase {
	s.OwnerIdList = v
	return s
}

func (s *GetDatabaseResponseBodyDatabase) SetOwnerNameList(v *GetDatabaseResponseBodyDatabaseOwnerNameList) *GetDatabaseResponseBodyDatabase {
	s.OwnerNameList = v
	return s
}

func (s *GetDatabaseResponseBodyDatabase) SetPort(v int32) *GetDatabaseResponseBodyDatabase {
	s.Port = &v
	return s
}

func (s *GetDatabaseResponseBodyDatabase) SetSchemaName(v string) *GetDatabaseResponseBodyDatabase {
	s.SchemaName = &v
	return s
}

func (s *GetDatabaseResponseBodyDatabase) SetSearchName(v string) *GetDatabaseResponseBodyDatabase {
	s.SearchName = &v
	return s
}

func (s *GetDatabaseResponseBodyDatabase) SetSid(v string) *GetDatabaseResponseBodyDatabase {
	s.Sid = &v
	return s
}

func (s *GetDatabaseResponseBodyDatabase) SetState(v string) *GetDatabaseResponseBodyDatabase {
	s.State = &v
	return s
}

type GetDatabaseResponseBodyDatabaseOwnerIdList struct {
	OwnerIds []*string `json:"OwnerIds,omitempty" xml:"OwnerIds,omitempty" type:"Repeated"`
}

func (s GetDatabaseResponseBodyDatabaseOwnerIdList) String() string {
	return tea.Prettify(s)
}

func (s GetDatabaseResponseBodyDatabaseOwnerIdList) GoString() string {
	return s.String()
}

func (s *GetDatabaseResponseBodyDatabaseOwnerIdList) SetOwnerIds(v []*string) *GetDatabaseResponseBodyDatabaseOwnerIdList {
	s.OwnerIds = v
	return s
}

type GetDatabaseResponseBodyDatabaseOwnerNameList struct {
	OwnerNames []*string `json:"OwnerNames,omitempty" xml:"OwnerNames,omitempty" type:"Repeated"`
}

func (s GetDatabaseResponseBodyDatabaseOwnerNameList) String() string {
	return tea.Prettify(s)
}

func (s GetDatabaseResponseBodyDatabaseOwnerNameList) GoString() string {
	return s.String()
}

func (s *GetDatabaseResponseBodyDatabaseOwnerNameList) SetOwnerNames(v []*string) *GetDatabaseResponseBodyDatabaseOwnerNameList {
	s.OwnerNames = v
	return s
}

type GetDatabaseResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDatabaseResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDatabaseResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDatabaseResponse) GoString() string {
	return s.String()
}

func (s *GetDatabaseResponse) SetHeaders(v map[string]*string) *GetDatabaseResponse {
	s.Headers = v
	return s
}

func (s *GetDatabaseResponse) SetStatusCode(v int32) *GetDatabaseResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDatabaseResponse) SetBody(v *GetDatabaseResponseBody) *GetDatabaseResponse {
	s.Body = v
	return s
}

type GetDatabaseExportOrderDetailRequest struct {
	// The ticket ID. You can call the [ListOrders](~~144643~~) operation to obtain the ticket ID.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant.
	//
	// > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the [View information about the current tenant](~~181330~~) section of the "Manage DMS tenants" topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetDatabaseExportOrderDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDatabaseExportOrderDetailRequest) GoString() string {
	return s.String()
}

func (s *GetDatabaseExportOrderDetailRequest) SetOrderId(v int64) *GetDatabaseExportOrderDetailRequest {
	s.OrderId = &v
	return s
}

func (s *GetDatabaseExportOrderDetailRequest) SetTid(v int64) *GetDatabaseExportOrderDetailRequest {
	s.Tid = &v
	return s
}

type GetDatabaseExportOrderDetailResponseBody struct {
	// The details of the database export ticket.
	DatabaseExportOrderDetail *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail `json:"DatabaseExportOrderDetail,omitempty" xml:"DatabaseExportOrderDetail,omitempty" type:"Struct"`
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDatabaseExportOrderDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDatabaseExportOrderDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetDatabaseExportOrderDetailResponseBody) SetDatabaseExportOrderDetail(v *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail) *GetDatabaseExportOrderDetailResponseBody {
	s.DatabaseExportOrderDetail = v
	return s
}

func (s *GetDatabaseExportOrderDetailResponseBody) SetErrorCode(v string) *GetDatabaseExportOrderDetailResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetDatabaseExportOrderDetailResponseBody) SetErrorMessage(v string) *GetDatabaseExportOrderDetailResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDatabaseExportOrderDetailResponseBody) SetRequestId(v string) *GetDatabaseExportOrderDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDatabaseExportOrderDetailResponseBody) SetSuccess(v bool) *GetDatabaseExportOrderDetailResponseBody {
	s.Success = &v
	return s
}

type GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail struct {
	// The business background information of the database export ticket.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The user who submitted the ticket.
	Committer *string `json:"Committer,omitempty" xml:"Committer,omitempty"`
	// The ID of the user who submitted the ticket. This ID is a user ID and is not the ID of an Alibaba Cloud account.
	CommitterId *string `json:"CommitterId,omitempty" xml:"CommitterId,omitempty"`
	// The ticket ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The key information about the ticket.
	KeyInfo *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo `json:"KeyInfo,omitempty" xml:"KeyInfo,omitempty" type:"Struct"`
	// The execution logs.
	Log *string `json:"Log,omitempty" xml:"Log,omitempty"`
	// The name that is used to search for the database.
	SearchName *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
	// The status description of the ticket.
	StatusDesc *string `json:"StatusDesc,omitempty" xml:"StatusDesc,omitempty"`
	// The status description of the workflow.
	WorkflowStatusDesc *string `json:"WorkflowStatusDesc,omitempty" xml:"WorkflowStatusDesc,omitempty"`
}

func (s GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail) String() string {
	return tea.Prettify(s)
}

func (s GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail) GoString() string {
	return s.String()
}

func (s *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail) SetComment(v string) *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail {
	s.Comment = &v
	return s
}

func (s *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail) SetCommitter(v string) *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail {
	s.Committer = &v
	return s
}

func (s *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail) SetCommitterId(v string) *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail {
	s.CommitterId = &v
	return s
}

func (s *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail) SetId(v int64) *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail {
	s.Id = &v
	return s
}

func (s *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail) SetKeyInfo(v *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo) *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail {
	s.KeyInfo = v
	return s
}

func (s *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail) SetLog(v string) *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail {
	s.Log = &v
	return s
}

func (s *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail) SetSearchName(v string) *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail {
	s.SearchName = &v
	return s
}

func (s *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail) SetStatusDesc(v string) *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail {
	s.StatusDesc = &v
	return s
}

func (s *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail) SetWorkflowStatusDesc(v string) *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetail {
	s.WorkflowStatusDesc = &v
	return s
}

type GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo struct {
	// The time when the ticket was submitted.
	AuditDate *string `json:"AuditDate,omitempty" xml:"AuditDate,omitempty"`
	// The configuration information about the ticket.
	Config *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig `json:"Config,omitempty" xml:"Config,omitempty" type:"Struct"`
	// The database ID.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The URL that is used to download the export result.
	DownloadURL *string `json:"DownloadURL,omitempty" xml:"DownloadURL,omitempty"`
}

func (s GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo) String() string {
	return tea.Prettify(s)
}

func (s GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo) GoString() string {
	return s.String()
}

func (s *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo) SetAuditDate(v string) *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo {
	s.AuditDate = &v
	return s
}

func (s *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo) SetConfig(v *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig) *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo {
	s.Config = v
	return s
}

func (s *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo) SetDbId(v int64) *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo {
	s.DbId = &v
	return s
}

func (s *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo) SetDownloadURL(v string) *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfo {
	s.DownloadURL = &v
	return s
}

type GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig struct {
	// The database name.
	DbName *string `json:"DbName,omitempty" xml:"DbName,omitempty"`
	// The type of data that was exported. Valid values:
	//
	// *   **DATA**: The data of the database was exported.
	// *   **STRUCT**: The schema of the database was exported.
	// *   **DATA_STRUCT**: The data and schema of the database were exported.
	ExportContent *string `json:"ExportContent,omitempty" xml:"ExportContent,omitempty"`
	// The type of schema that was exported.
	ExportTypes *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigExportTypes `json:"ExportTypes,omitempty" xml:"ExportTypes,omitempty" type:"Struct"`
	// The extension options of the SQL script.
	SQLExtOption *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSQLExtOption `json:"SQLExtOption,omitempty" xml:"SQLExtOption,omitempty" type:"Struct"`
	// The tables that were exported from the database.
	SelectedTables *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSelectedTables `json:"SelectedTables,omitempty" xml:"SelectedTables,omitempty" type:"Struct"`
	// The format in which the database was exported. Valid values:
	//
	// *   **SQL**
	// *   **CSV**
	// *   **XLSX**
	TargetOption *string `json:"TargetOption,omitempty" xml:"TargetOption,omitempty"`
}

func (s GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig) String() string {
	return tea.Prettify(s)
}

func (s GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig) GoString() string {
	return s.String()
}

func (s *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig) SetDbName(v string) *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig {
	s.DbName = &v
	return s
}

func (s *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig) SetExportContent(v string) *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig {
	s.ExportContent = &v
	return s
}

func (s *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig) SetExportTypes(v *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigExportTypes) *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig {
	s.ExportTypes = v
	return s
}

func (s *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig) SetSQLExtOption(v *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSQLExtOption) *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig {
	s.SQLExtOption = v
	return s
}

func (s *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig) SetSelectedTables(v *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSelectedTables) *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig {
	s.SelectedTables = v
	return s
}

func (s *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig) SetTargetOption(v string) *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfig {
	s.TargetOption = &v
	return s
}

type GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigExportTypes struct {
	ExportTypes []*string `json:"ExportTypes,omitempty" xml:"ExportTypes,omitempty" type:"Repeated"`
}

func (s GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigExportTypes) String() string {
	return tea.Prettify(s)
}

func (s GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigExportTypes) GoString() string {
	return s.String()
}

func (s *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigExportTypes) SetExportTypes(v []*string) *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigExportTypes {
	s.ExportTypes = v
	return s
}

type GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSQLExtOption struct {
	SQLExtOption []*string `json:"SQLExtOption,omitempty" xml:"SQLExtOption,omitempty" type:"Repeated"`
}

func (s GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSQLExtOption) String() string {
	return tea.Prettify(s)
}

func (s GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSQLExtOption) GoString() string {
	return s.String()
}

func (s *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSQLExtOption) SetSQLExtOption(v []*string) *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSQLExtOption {
	s.SQLExtOption = v
	return s
}

type GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSelectedTables struct {
	SelectedTables []*string `json:"SelectedTables,omitempty" xml:"SelectedTables,omitempty" type:"Repeated"`
}

func (s GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSelectedTables) String() string {
	return tea.Prettify(s)
}

func (s GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSelectedTables) GoString() string {
	return s.String()
}

func (s *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSelectedTables) SetSelectedTables(v []*string) *GetDatabaseExportOrderDetailResponseBodyDatabaseExportOrderDetailKeyInfoConfigSelectedTables {
	s.SelectedTables = v
	return s
}

type GetDatabaseExportOrderDetailResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDatabaseExportOrderDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDatabaseExportOrderDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDatabaseExportOrderDetailResponse) GoString() string {
	return s.String()
}

func (s *GetDatabaseExportOrderDetailResponse) SetHeaders(v map[string]*string) *GetDatabaseExportOrderDetailResponse {
	s.Headers = v
	return s
}

func (s *GetDatabaseExportOrderDetailResponse) SetStatusCode(v int32) *GetDatabaseExportOrderDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDatabaseExportOrderDetailResponse) SetBody(v *GetDatabaseExportOrderDetailResponseBody) *GetDatabaseExportOrderDetailResponse {
	s.Body = v
	return s
}

type GetDbExportDownloadURLRequest struct {
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	Tid     *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetDbExportDownloadURLRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDbExportDownloadURLRequest) GoString() string {
	return s.String()
}

func (s *GetDbExportDownloadURLRequest) SetOrderId(v int64) *GetDbExportDownloadURLRequest {
	s.OrderId = &v
	return s
}

func (s *GetDbExportDownloadURLRequest) SetTid(v int64) *GetDbExportDownloadURLRequest {
	s.Tid = &v
	return s
}

type GetDbExportDownloadURLResponseBody struct {
	DownloadURLResult *GetDbExportDownloadURLResponseBodyDownloadURLResult `json:"DownloadURLResult,omitempty" xml:"DownloadURLResult,omitempty" type:"Struct"`
	ErrorCode         *string                                              `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage      *string                                              `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId         *string                                              `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success           *bool                                                `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDbExportDownloadURLResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDbExportDownloadURLResponseBody) GoString() string {
	return s.String()
}

func (s *GetDbExportDownloadURLResponseBody) SetDownloadURLResult(v *GetDbExportDownloadURLResponseBodyDownloadURLResult) *GetDbExportDownloadURLResponseBody {
	s.DownloadURLResult = v
	return s
}

func (s *GetDbExportDownloadURLResponseBody) SetErrorCode(v string) *GetDbExportDownloadURLResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetDbExportDownloadURLResponseBody) SetErrorMessage(v string) *GetDbExportDownloadURLResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDbExportDownloadURLResponseBody) SetRequestId(v string) *GetDbExportDownloadURLResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDbExportDownloadURLResponseBody) SetSuccess(v bool) *GetDbExportDownloadURLResponseBody {
	s.Success = &v
	return s
}

type GetDbExportDownloadURLResponseBodyDownloadURLResult struct {
	HasResult  *bool   `json:"HasResult,omitempty" xml:"HasResult,omitempty"`
	TipMessage *string `json:"TipMessage,omitempty" xml:"TipMessage,omitempty"`
	URL        *string `json:"URL,omitempty" xml:"URL,omitempty"`
}

func (s GetDbExportDownloadURLResponseBodyDownloadURLResult) String() string {
	return tea.Prettify(s)
}

func (s GetDbExportDownloadURLResponseBodyDownloadURLResult) GoString() string {
	return s.String()
}

func (s *GetDbExportDownloadURLResponseBodyDownloadURLResult) SetHasResult(v bool) *GetDbExportDownloadURLResponseBodyDownloadURLResult {
	s.HasResult = &v
	return s
}

func (s *GetDbExportDownloadURLResponseBodyDownloadURLResult) SetTipMessage(v string) *GetDbExportDownloadURLResponseBodyDownloadURLResult {
	s.TipMessage = &v
	return s
}

func (s *GetDbExportDownloadURLResponseBodyDownloadURLResult) SetURL(v string) *GetDbExportDownloadURLResponseBodyDownloadURLResult {
	s.URL = &v
	return s
}

type GetDbExportDownloadURLResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDbExportDownloadURLResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDbExportDownloadURLResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDbExportDownloadURLResponse) GoString() string {
	return s.String()
}

func (s *GetDbExportDownloadURLResponse) SetHeaders(v map[string]*string) *GetDbExportDownloadURLResponse {
	s.Headers = v
	return s
}

func (s *GetDbExportDownloadURLResponse) SetStatusCode(v int32) *GetDbExportDownloadURLResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDbExportDownloadURLResponse) SetBody(v *GetDbExportDownloadURLResponseBody) *GetDbExportDownloadURLResponse {
	s.Body = v
	return s
}

type GetInstanceRequest struct {
	// The endpoint of the database instance. You can call the [ListInstances](~~141936~~) operation to obtain the endpoint.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The port number that is used to connect to the database instance. You can call the [ListInstances](~~141936~~) operation to obtain the port number.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The system ID (SID) of the database instance. You can call the [ListInstances](~~141936~~) operation to obtain the SID.
	Sid *string `json:"Sid,omitempty" xml:"Sid,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceRequest) GoString() string {
	return s.String()
}

func (s *GetInstanceRequest) SetHost(v string) *GetInstanceRequest {
	s.Host = &v
	return s
}

func (s *GetInstanceRequest) SetPort(v int32) *GetInstanceRequest {
	s.Port = &v
	return s
}

func (s *GetInstanceRequest) SetSid(v string) *GetInstanceRequest {
	s.Sid = &v
	return s
}

func (s *GetInstanceRequest) SetTid(v int64) *GetInstanceRequest {
	s.Tid = &v
	return s
}

type GetInstanceResponseBody struct {
	// The error code that is returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message that is returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The details of the database instance.
	Instance *GetInstanceResponseBodyInstance `json:"Instance,omitempty" xml:"Instance,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// - **true**: The request was successful.
	// - **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *GetInstanceResponseBody) SetErrorCode(v string) *GetInstanceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetInstanceResponseBody) SetErrorMessage(v string) *GetInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetInstanceResponseBody) SetInstance(v *GetInstanceResponseBodyInstance) *GetInstanceResponseBody {
	s.Instance = v
	return s
}

func (s *GetInstanceResponseBody) SetRequestId(v string) *GetInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetInstanceResponseBody) SetSuccess(v bool) *GetInstanceResponseBody {
	s.Success = &v
	return s
}

type GetInstanceResponseBodyInstance struct {
	// The name of the database link for the database instance.
	DataLinkName *string `json:"DataLinkName,omitempty" xml:"DataLinkName,omitempty"`
	// The password that is used to log on to the database.
	DatabasePassword *string `json:"DatabasePassword,omitempty" xml:"DatabasePassword,omitempty"`
	// The account that is used to log on to the database instance.
	DatabaseUser *string `json:"DatabaseUser,omitempty" xml:"DatabaseUser,omitempty"`
	// The ID of the database administrator (DBA) for the database instance.
	DbaId *string `json:"DbaId,omitempty" xml:"DbaId,omitempty"`
	// The nickname of the DBA for the database instance.
	DbaNickName *string `json:"DbaNickName,omitempty" xml:"DbaNickName,omitempty"`
	// Indicates whether the lock-free schema change feature is enabled for the database instance.
	DdlOnline *int32 `json:"DdlOnline,omitempty" xml:"DdlOnline,omitempty"`
	// The ID of the Elastic Compute Service (ECS) instance on which the database instance is deployed.
	EcsInstanceId *string `json:"EcsInstanceId,omitempty" xml:"EcsInstanceId,omitempty"`
	// The ID of the region in which the database instance resides.
	EcsRegion *string `json:"EcsRegion,omitempty" xml:"EcsRegion,omitempty"`
	// The type of the environment to which the database instance belongs. Valid values:
	//
	// *   **product**: production environment
	// *   **dev**: development environment
	// *   **pre**: staging environment
	// *   **test**: test environment
	// *   **sit**: system integration testing (SIT) environment
	// *   **uat**: user acceptance testing (UAT) environment
	// *   **pet**: stress testing environment
	// *   **stag**: STAG environment
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The timeout period for exporting data from the database instance.
	ExportTimeout *int32 `json:"ExportTimeout,omitempty" xml:"ExportTimeout,omitempty"`
	// The host address that is used to connect to the database instance.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The alias of the database instance.
	InstanceAlias *string `json:"InstanceAlias,omitempty" xml:"InstanceAlias,omitempty"`
	// The ID of the database instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The source of the database instance.
	InstanceSource *string `json:"InstanceSource,omitempty" xml:"InstanceSource,omitempty"`
	// The type of the database instance.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The IDs of the owners for the database instance.
	OwnerIdList *GetInstanceResponseBodyInstanceOwnerIdList `json:"OwnerIdList,omitempty" xml:"OwnerIdList,omitempty" type:"Struct"`
	// The nicknames of the owners for the database instance.
	OwnerNameList *GetInstanceResponseBodyInstanceOwnerNameList `json:"OwnerNameList,omitempty" xml:"OwnerNameList,omitempty" type:"Struct"`
	// The port number that is used to connect to the database instance.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The timeout period for querying data in the database instance.
	QueryTimeout *int32 `json:"QueryTimeout,omitempty" xml:"QueryTimeout,omitempty"`
	// The ID of the security rule set for the database instance.
	SafeRuleId *string `json:"SafeRuleId,omitempty" xml:"SafeRuleId,omitempty"`
	// Whether sensitive data protection is enabled.  Valid values:
	//
	// - **true**: Enable.
	//
	// - **false**: Close.
	SellSitd *string `json:"SellSitd,omitempty" xml:"SellSitd,omitempty"`
	// The SID of the database instance.
	Sid *string `json:"Sid,omitempty" xml:"Sid,omitempty"`
	// The control mode of the database instance.
	StandardGroup *GetInstanceResponseBodyInstanceStandardGroup `json:"StandardGroup,omitempty" xml:"StandardGroup,omitempty" type:"Struct"`
	// The status of the database instance. Valid values:
	//
	// *   **NORMAL**: normal
	// *   **DISABLE**: disabled
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// Indicates whether the cross-database query feature is enabled for the database instance. Valid values:
	//
	// *   **0**: disabled
	// *   **1**: enabled
	UseDsql *int32 `json:"UseDsql,omitempty" xml:"UseDsql,omitempty"`
	// The ID of the virtual private cloud (VPC) to which the database instance belongs.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s GetInstanceResponseBodyInstance) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceResponseBodyInstance) GoString() string {
	return s.String()
}

func (s *GetInstanceResponseBodyInstance) SetDataLinkName(v string) *GetInstanceResponseBodyInstance {
	s.DataLinkName = &v
	return s
}

func (s *GetInstanceResponseBodyInstance) SetDatabasePassword(v string) *GetInstanceResponseBodyInstance {
	s.DatabasePassword = &v
	return s
}

func (s *GetInstanceResponseBodyInstance) SetDatabaseUser(v string) *GetInstanceResponseBodyInstance {
	s.DatabaseUser = &v
	return s
}

func (s *GetInstanceResponseBodyInstance) SetDbaId(v string) *GetInstanceResponseBodyInstance {
	s.DbaId = &v
	return s
}

func (s *GetInstanceResponseBodyInstance) SetDbaNickName(v string) *GetInstanceResponseBodyInstance {
	s.DbaNickName = &v
	return s
}

func (s *GetInstanceResponseBodyInstance) SetDdlOnline(v int32) *GetInstanceResponseBodyInstance {
	s.DdlOnline = &v
	return s
}

func (s *GetInstanceResponseBodyInstance) SetEcsInstanceId(v string) *GetInstanceResponseBodyInstance {
	s.EcsInstanceId = &v
	return s
}

func (s *GetInstanceResponseBodyInstance) SetEcsRegion(v string) *GetInstanceResponseBodyInstance {
	s.EcsRegion = &v
	return s
}

func (s *GetInstanceResponseBodyInstance) SetEnvType(v string) *GetInstanceResponseBodyInstance {
	s.EnvType = &v
	return s
}

func (s *GetInstanceResponseBodyInstance) SetExportTimeout(v int32) *GetInstanceResponseBodyInstance {
	s.ExportTimeout = &v
	return s
}

func (s *GetInstanceResponseBodyInstance) SetHost(v string) *GetInstanceResponseBodyInstance {
	s.Host = &v
	return s
}

func (s *GetInstanceResponseBodyInstance) SetInstanceAlias(v string) *GetInstanceResponseBodyInstance {
	s.InstanceAlias = &v
	return s
}

func (s *GetInstanceResponseBodyInstance) SetInstanceId(v string) *GetInstanceResponseBodyInstance {
	s.InstanceId = &v
	return s
}

func (s *GetInstanceResponseBodyInstance) SetInstanceSource(v string) *GetInstanceResponseBodyInstance {
	s.InstanceSource = &v
	return s
}

func (s *GetInstanceResponseBodyInstance) SetInstanceType(v string) *GetInstanceResponseBodyInstance {
	s.InstanceType = &v
	return s
}

func (s *GetInstanceResponseBodyInstance) SetOwnerIdList(v *GetInstanceResponseBodyInstanceOwnerIdList) *GetInstanceResponseBodyInstance {
	s.OwnerIdList = v
	return s
}

func (s *GetInstanceResponseBodyInstance) SetOwnerNameList(v *GetInstanceResponseBodyInstanceOwnerNameList) *GetInstanceResponseBodyInstance {
	s.OwnerNameList = v
	return s
}

func (s *GetInstanceResponseBodyInstance) SetPort(v int32) *GetInstanceResponseBodyInstance {
	s.Port = &v
	return s
}

func (s *GetInstanceResponseBodyInstance) SetQueryTimeout(v int32) *GetInstanceResponseBodyInstance {
	s.QueryTimeout = &v
	return s
}

func (s *GetInstanceResponseBodyInstance) SetSafeRuleId(v string) *GetInstanceResponseBodyInstance {
	s.SafeRuleId = &v
	return s
}

func (s *GetInstanceResponseBodyInstance) SetSellSitd(v string) *GetInstanceResponseBodyInstance {
	s.SellSitd = &v
	return s
}

func (s *GetInstanceResponseBodyInstance) SetSid(v string) *GetInstanceResponseBodyInstance {
	s.Sid = &v
	return s
}

func (s *GetInstanceResponseBodyInstance) SetStandardGroup(v *GetInstanceResponseBodyInstanceStandardGroup) *GetInstanceResponseBodyInstance {
	s.StandardGroup = v
	return s
}

func (s *GetInstanceResponseBodyInstance) SetState(v string) *GetInstanceResponseBodyInstance {
	s.State = &v
	return s
}

func (s *GetInstanceResponseBodyInstance) SetUseDsql(v int32) *GetInstanceResponseBodyInstance {
	s.UseDsql = &v
	return s
}

func (s *GetInstanceResponseBodyInstance) SetVpcId(v string) *GetInstanceResponseBodyInstance {
	s.VpcId = &v
	return s
}

type GetInstanceResponseBodyInstanceOwnerIdList struct {
	OwnerIds []*string `json:"OwnerIds,omitempty" xml:"OwnerIds,omitempty" type:"Repeated"`
}

func (s GetInstanceResponseBodyInstanceOwnerIdList) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceResponseBodyInstanceOwnerIdList) GoString() string {
	return s.String()
}

func (s *GetInstanceResponseBodyInstanceOwnerIdList) SetOwnerIds(v []*string) *GetInstanceResponseBodyInstanceOwnerIdList {
	s.OwnerIds = v
	return s
}

type GetInstanceResponseBodyInstanceOwnerNameList struct {
	OwnerNames []*string `json:"OwnerNames,omitempty" xml:"OwnerNames,omitempty" type:"Repeated"`
}

func (s GetInstanceResponseBodyInstanceOwnerNameList) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceResponseBodyInstanceOwnerNameList) GoString() string {
	return s.String()
}

func (s *GetInstanceResponseBodyInstanceOwnerNameList) SetOwnerNames(v []*string) *GetInstanceResponseBodyInstanceOwnerNameList {
	s.OwnerNames = v
	return s
}

type GetInstanceResponseBodyInstanceStandardGroup struct {
	// The type of the control mode. Valid values:
	//
	// *   **COMMON**: Security Collaboration
	// *   **NONE_CONTROL**: Flexible Management
	// *   **STABLE**: Stable Change
	GroupMode *string `json:"GroupMode,omitempty" xml:"GroupMode,omitempty"`
	// The name of the security rule set corresponding to the control mode.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
}

func (s GetInstanceResponseBodyInstanceStandardGroup) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceResponseBodyInstanceStandardGroup) GoString() string {
	return s.String()
}

func (s *GetInstanceResponseBodyInstanceStandardGroup) SetGroupMode(v string) *GetInstanceResponseBodyInstanceStandardGroup {
	s.GroupMode = &v
	return s
}

func (s *GetInstanceResponseBodyInstanceStandardGroup) SetGroupName(v string) *GetInstanceResponseBodyInstanceStandardGroup {
	s.GroupName = &v
	return s
}

type GetInstanceResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceResponse) GoString() string {
	return s.String()
}

func (s *GetInstanceResponse) SetHeaders(v map[string]*string) *GetInstanceResponse {
	s.Headers = v
	return s
}

func (s *GetInstanceResponse) SetStatusCode(v int32) *GetInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *GetInstanceResponse) SetBody(v *GetInstanceResponseBody) *GetInstanceResponse {
	s.Body = v
	return s
}

type GetIntervalLimitOfSLARequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the tenant.
	//
	// > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetIntervalLimitOfSLARequest) String() string {
	return tea.Prettify(s)
}

func (s GetIntervalLimitOfSLARequest) GoString() string {
	return s.String()
}

func (s *GetIntervalLimitOfSLARequest) SetDagId(v int64) *GetIntervalLimitOfSLARequest {
	s.DagId = &v
	return s
}

func (s *GetIntervalLimitOfSLARequest) SetTid(v int64) *GetIntervalLimitOfSLARequest {
	s.Tid = &v
	return s
}

type GetIntervalLimitOfSLAResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The minimum scheduling cycle. Unit: minutes.
	IntervalLimit *int32 `json:"IntervalLimit,omitempty" xml:"IntervalLimit,omitempty"`
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetIntervalLimitOfSLAResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetIntervalLimitOfSLAResponseBody) GoString() string {
	return s.String()
}

func (s *GetIntervalLimitOfSLAResponseBody) SetErrorCode(v string) *GetIntervalLimitOfSLAResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetIntervalLimitOfSLAResponseBody) SetErrorMessage(v string) *GetIntervalLimitOfSLAResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetIntervalLimitOfSLAResponseBody) SetIntervalLimit(v int32) *GetIntervalLimitOfSLAResponseBody {
	s.IntervalLimit = &v
	return s
}

func (s *GetIntervalLimitOfSLAResponseBody) SetRequestId(v string) *GetIntervalLimitOfSLAResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetIntervalLimitOfSLAResponseBody) SetSuccess(v bool) *GetIntervalLimitOfSLAResponseBody {
	s.Success = &v
	return s
}

type GetIntervalLimitOfSLAResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetIntervalLimitOfSLAResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetIntervalLimitOfSLAResponse) String() string {
	return tea.Prettify(s)
}

func (s GetIntervalLimitOfSLAResponse) GoString() string {
	return s.String()
}

func (s *GetIntervalLimitOfSLAResponse) SetHeaders(v map[string]*string) *GetIntervalLimitOfSLAResponse {
	s.Headers = v
	return s
}

func (s *GetIntervalLimitOfSLAResponse) SetStatusCode(v int32) *GetIntervalLimitOfSLAResponse {
	s.StatusCode = &v
	return s
}

func (s *GetIntervalLimitOfSLAResponse) SetBody(v *GetIntervalLimitOfSLAResponseBody) *GetIntervalLimitOfSLAResponse {
	s.Body = v
	return s
}

type GetLhSpaceByNameRequest struct {
	// The name of the workspace.
	SpaceName *string `json:"SpaceName,omitempty" xml:"SpaceName,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetLhSpaceByNameRequest) String() string {
	return tea.Prettify(s)
}

func (s GetLhSpaceByNameRequest) GoString() string {
	return s.String()
}

func (s *GetLhSpaceByNameRequest) SetSpaceName(v string) *GetLhSpaceByNameRequest {
	s.SpaceName = &v
	return s
}

func (s *GetLhSpaceByNameRequest) SetTid(v int64) *GetLhSpaceByNameRequest {
	s.Tid = &v
	return s
}

type GetLhSpaceByNameResponseBody struct {
	// The error code returned if the request fails.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The workspace for data warehouse development.
	LakehouseSpace *GetLhSpaceByNameResponseBodyLakehouseSpace `json:"LakehouseSpace,omitempty" xml:"LakehouseSpace,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**: The request is successful.
	// *   **false**: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetLhSpaceByNameResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetLhSpaceByNameResponseBody) GoString() string {
	return s.String()
}

func (s *GetLhSpaceByNameResponseBody) SetErrorCode(v string) *GetLhSpaceByNameResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetLhSpaceByNameResponseBody) SetErrorMessage(v string) *GetLhSpaceByNameResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetLhSpaceByNameResponseBody) SetLakehouseSpace(v *GetLhSpaceByNameResponseBodyLakehouseSpace) *GetLhSpaceByNameResponseBody {
	s.LakehouseSpace = v
	return s
}

func (s *GetLhSpaceByNameResponseBody) SetRequestId(v string) *GetLhSpaceByNameResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetLhSpaceByNameResponseBody) SetSuccess(v bool) *GetLhSpaceByNameResponseBody {
	s.Success = &v
	return s
}

type GetLhSpaceByNameResponseBodyLakehouseSpace struct {
	// The ID of the user who creates the workspace.
	CreatorId *string `json:"CreatorId,omitempty" xml:"CreatorId,omitempty"`
	// The description of the workspace.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the development database.
	DevDbId *int32 `json:"DevDbId,omitempty" xml:"DevDbId,omitempty"`
	// The type of the database. Valid values:
	//
	// *   **14**: AnalyticDB for MySQL
	// *   **18**: AnalyticDB for PostgreSQL
	DwDbType *string `json:"DwDbType,omitempty" xml:"DwDbType,omitempty"`
	// The ID of the workspace.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// Indicates whether the workspace is deleted. Valid values:
	//
	// *   **true**: The workspace is deleted.
	// *   **false**: The workspace is not deleted.
	IsDeleted *bool `json:"IsDeleted,omitempty" xml:"IsDeleted,omitempty"`
	// The mode in which the workspace runs. Valid values:
	//
	// *   **0**: basic mode
	// *   **1**: standard mode
	Mode *int32 `json:"Mode,omitempty" xml:"Mode,omitempty"`
	// The ID of the production database.
	ProdDbId *int32 `json:"ProdDbId,omitempty" xml:"ProdDbId,omitempty"`
	// The configuration of the workspace. Valid values:
	//
	// *   **skipManualRunCheck**: No security rule check is required in the trial run phase.
	// *   **skipPublishApprove**: No approval is required for publishing and O\&M.
	SpaceConfig *string `json:"SpaceConfig,omitempty" xml:"SpaceConfig,omitempty"`
	// The name of the workspace.
	SpaceName *string `json:"SpaceName,omitempty" xml:"SpaceName,omitempty"`
	// The ID of the tenant to which the workspace belongs.
	TenantId *string `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s GetLhSpaceByNameResponseBodyLakehouseSpace) String() string {
	return tea.Prettify(s)
}

func (s GetLhSpaceByNameResponseBodyLakehouseSpace) GoString() string {
	return s.String()
}

func (s *GetLhSpaceByNameResponseBodyLakehouseSpace) SetCreatorId(v string) *GetLhSpaceByNameResponseBodyLakehouseSpace {
	s.CreatorId = &v
	return s
}

func (s *GetLhSpaceByNameResponseBodyLakehouseSpace) SetDescription(v string) *GetLhSpaceByNameResponseBodyLakehouseSpace {
	s.Description = &v
	return s
}

func (s *GetLhSpaceByNameResponseBodyLakehouseSpace) SetDevDbId(v int32) *GetLhSpaceByNameResponseBodyLakehouseSpace {
	s.DevDbId = &v
	return s
}

func (s *GetLhSpaceByNameResponseBodyLakehouseSpace) SetDwDbType(v string) *GetLhSpaceByNameResponseBodyLakehouseSpace {
	s.DwDbType = &v
	return s
}

func (s *GetLhSpaceByNameResponseBodyLakehouseSpace) SetId(v int64) *GetLhSpaceByNameResponseBodyLakehouseSpace {
	s.Id = &v
	return s
}

func (s *GetLhSpaceByNameResponseBodyLakehouseSpace) SetIsDeleted(v bool) *GetLhSpaceByNameResponseBodyLakehouseSpace {
	s.IsDeleted = &v
	return s
}

func (s *GetLhSpaceByNameResponseBodyLakehouseSpace) SetMode(v int32) *GetLhSpaceByNameResponseBodyLakehouseSpace {
	s.Mode = &v
	return s
}

func (s *GetLhSpaceByNameResponseBodyLakehouseSpace) SetProdDbId(v int32) *GetLhSpaceByNameResponseBodyLakehouseSpace {
	s.ProdDbId = &v
	return s
}

func (s *GetLhSpaceByNameResponseBodyLakehouseSpace) SetSpaceConfig(v string) *GetLhSpaceByNameResponseBodyLakehouseSpace {
	s.SpaceConfig = &v
	return s
}

func (s *GetLhSpaceByNameResponseBodyLakehouseSpace) SetSpaceName(v string) *GetLhSpaceByNameResponseBodyLakehouseSpace {
	s.SpaceName = &v
	return s
}

func (s *GetLhSpaceByNameResponseBodyLakehouseSpace) SetTenantId(v string) *GetLhSpaceByNameResponseBodyLakehouseSpace {
	s.TenantId = &v
	return s
}

type GetLhSpaceByNameResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetLhSpaceByNameResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetLhSpaceByNameResponse) String() string {
	return tea.Prettify(s)
}

func (s GetLhSpaceByNameResponse) GoString() string {
	return s.String()
}

func (s *GetLhSpaceByNameResponse) SetHeaders(v map[string]*string) *GetLhSpaceByNameResponse {
	s.Headers = v
	return s
}

func (s *GetLhSpaceByNameResponse) SetStatusCode(v int32) *GetLhSpaceByNameResponse {
	s.StatusCode = &v
	return s
}

func (s *GetLhSpaceByNameResponse) SetBody(v *GetLhSpaceByNameResponseBody) *GetLhSpaceByNameResponse {
	s.Body = v
	return s
}

type GetLogicDatabaseRequest struct {
	// The ID of the logical database. You can call the [ListLogicDatabases](~~141874~~) or [SearchDatabase](~~141876~~) operation to obtain the ID of the logical database.
	DbId *string `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The ID of the tenant.
	//
	// > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetLogicDatabaseRequest) String() string {
	return tea.Prettify(s)
}

func (s GetLogicDatabaseRequest) GoString() string {
	return s.String()
}

func (s *GetLogicDatabaseRequest) SetDbId(v string) *GetLogicDatabaseRequest {
	s.DbId = &v
	return s
}

func (s *GetLogicDatabaseRequest) SetTid(v int64) *GetLogicDatabaseRequest {
	s.Tid = &v
	return s
}

type GetLogicDatabaseResponseBody struct {
	// The status code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The details of the logical database.
	LogicDatabase *GetLogicDatabaseResponseBodyLogicDatabase `json:"LogicDatabase,omitempty" xml:"LogicDatabase,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetLogicDatabaseResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetLogicDatabaseResponseBody) GoString() string {
	return s.String()
}

func (s *GetLogicDatabaseResponseBody) SetErrorCode(v string) *GetLogicDatabaseResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetLogicDatabaseResponseBody) SetErrorMessage(v string) *GetLogicDatabaseResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetLogicDatabaseResponseBody) SetLogicDatabase(v *GetLogicDatabaseResponseBodyLogicDatabase) *GetLogicDatabaseResponseBody {
	s.LogicDatabase = v
	return s
}

func (s *GetLogicDatabaseResponseBody) SetRequestId(v string) *GetLogicDatabaseResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetLogicDatabaseResponseBody) SetSuccess(v bool) *GetLogicDatabaseResponseBody {
	s.Success = &v
	return s
}

type GetLogicDatabaseResponseBodyLogicDatabase struct {
	// The alias of the logical database.
	Alias *string `json:"Alias,omitempty" xml:"Alias,omitempty"`
	// The ID of the logical database.
	DatabaseId *string `json:"DatabaseId,omitempty" xml:"DatabaseId,omitempty"`
	// The IDs of database shards of the logical database.
	DatabaseIds *GetLogicDatabaseResponseBodyLogicDatabaseDatabaseIds `json:"DatabaseIds,omitempty" xml:"DatabaseIds,omitempty" type:"Struct"`
	// The database engine. For more information about the valid values of the DbType parameter, see [DbType parameter](~~198106~~).
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The type of the environment to which the database belongs. Valid values:
	//
	// *   product: production environment
	// *   dev: development environment
	// *   pre: pre-release environment
	// *   test: test environment
	// *   sit: system integration testing (SIT) environment
	// *   uat: user acceptance testing (UAT) environment
	// *   pet: stress testing environment
	// *   stag: staging environment
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// Indicates whether the database is a logical database. The return value is true.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The IDs of the owners of the logical database.
	OwnerIdList *GetLogicDatabaseResponseBodyLogicDatabaseOwnerIdList `json:"OwnerIdList,omitempty" xml:"OwnerIdList,omitempty" type:"Struct"`
	// The names of the owners of the logical database.
	OwnerNameList *GetLogicDatabaseResponseBodyLogicDatabaseOwnerNameList `json:"OwnerNameList,omitempty" xml:"OwnerNameList,omitempty" type:"Struct"`
	// The name of the logical database.
	SchemaName *string `json:"SchemaName,omitempty" xml:"SchemaName,omitempty"`
	// The name that is used to search for the logical database.
	SearchName *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
}

func (s GetLogicDatabaseResponseBodyLogicDatabase) String() string {
	return tea.Prettify(s)
}

func (s GetLogicDatabaseResponseBodyLogicDatabase) GoString() string {
	return s.String()
}

func (s *GetLogicDatabaseResponseBodyLogicDatabase) SetAlias(v string) *GetLogicDatabaseResponseBodyLogicDatabase {
	s.Alias = &v
	return s
}

func (s *GetLogicDatabaseResponseBodyLogicDatabase) SetDatabaseId(v string) *GetLogicDatabaseResponseBodyLogicDatabase {
	s.DatabaseId = &v
	return s
}

func (s *GetLogicDatabaseResponseBodyLogicDatabase) SetDatabaseIds(v *GetLogicDatabaseResponseBodyLogicDatabaseDatabaseIds) *GetLogicDatabaseResponseBodyLogicDatabase {
	s.DatabaseIds = v
	return s
}

func (s *GetLogicDatabaseResponseBodyLogicDatabase) SetDbType(v string) *GetLogicDatabaseResponseBodyLogicDatabase {
	s.DbType = &v
	return s
}

func (s *GetLogicDatabaseResponseBodyLogicDatabase) SetEnvType(v string) *GetLogicDatabaseResponseBodyLogicDatabase {
	s.EnvType = &v
	return s
}

func (s *GetLogicDatabaseResponseBodyLogicDatabase) SetLogic(v bool) *GetLogicDatabaseResponseBodyLogicDatabase {
	s.Logic = &v
	return s
}

func (s *GetLogicDatabaseResponseBodyLogicDatabase) SetOwnerIdList(v *GetLogicDatabaseResponseBodyLogicDatabaseOwnerIdList) *GetLogicDatabaseResponseBodyLogicDatabase {
	s.OwnerIdList = v
	return s
}

func (s *GetLogicDatabaseResponseBodyLogicDatabase) SetOwnerNameList(v *GetLogicDatabaseResponseBodyLogicDatabaseOwnerNameList) *GetLogicDatabaseResponseBodyLogicDatabase {
	s.OwnerNameList = v
	return s
}

func (s *GetLogicDatabaseResponseBodyLogicDatabase) SetSchemaName(v string) *GetLogicDatabaseResponseBodyLogicDatabase {
	s.SchemaName = &v
	return s
}

func (s *GetLogicDatabaseResponseBodyLogicDatabase) SetSearchName(v string) *GetLogicDatabaseResponseBodyLogicDatabase {
	s.SearchName = &v
	return s
}

type GetLogicDatabaseResponseBodyLogicDatabaseDatabaseIds struct {
	DatabaseIds []*int64 `json:"DatabaseIds,omitempty" xml:"DatabaseIds,omitempty" type:"Repeated"`
}

func (s GetLogicDatabaseResponseBodyLogicDatabaseDatabaseIds) String() string {
	return tea.Prettify(s)
}

func (s GetLogicDatabaseResponseBodyLogicDatabaseDatabaseIds) GoString() string {
	return s.String()
}

func (s *GetLogicDatabaseResponseBodyLogicDatabaseDatabaseIds) SetDatabaseIds(v []*int64) *GetLogicDatabaseResponseBodyLogicDatabaseDatabaseIds {
	s.DatabaseIds = v
	return s
}

type GetLogicDatabaseResponseBodyLogicDatabaseOwnerIdList struct {
	OwnerIds []*string `json:"OwnerIds,omitempty" xml:"OwnerIds,omitempty" type:"Repeated"`
}

func (s GetLogicDatabaseResponseBodyLogicDatabaseOwnerIdList) String() string {
	return tea.Prettify(s)
}

func (s GetLogicDatabaseResponseBodyLogicDatabaseOwnerIdList) GoString() string {
	return s.String()
}

func (s *GetLogicDatabaseResponseBodyLogicDatabaseOwnerIdList) SetOwnerIds(v []*string) *GetLogicDatabaseResponseBodyLogicDatabaseOwnerIdList {
	s.OwnerIds = v
	return s
}

type GetLogicDatabaseResponseBodyLogicDatabaseOwnerNameList struct {
	OwnerNames []*string `json:"OwnerNames,omitempty" xml:"OwnerNames,omitempty" type:"Repeated"`
}

func (s GetLogicDatabaseResponseBodyLogicDatabaseOwnerNameList) String() string {
	return tea.Prettify(s)
}

func (s GetLogicDatabaseResponseBodyLogicDatabaseOwnerNameList) GoString() string {
	return s.String()
}

func (s *GetLogicDatabaseResponseBodyLogicDatabaseOwnerNameList) SetOwnerNames(v []*string) *GetLogicDatabaseResponseBodyLogicDatabaseOwnerNameList {
	s.OwnerNames = v
	return s
}

type GetLogicDatabaseResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetLogicDatabaseResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetLogicDatabaseResponse) String() string {
	return tea.Prettify(s)
}

func (s GetLogicDatabaseResponse) GoString() string {
	return s.String()
}

func (s *GetLogicDatabaseResponse) SetHeaders(v map[string]*string) *GetLogicDatabaseResponse {
	s.Headers = v
	return s
}

func (s *GetLogicDatabaseResponse) SetStatusCode(v int32) *GetLogicDatabaseResponse {
	s.StatusCode = &v
	return s
}

func (s *GetLogicDatabaseResponse) SetBody(v *GetLogicDatabaseResponseBody) *GetLogicDatabaseResponse {
	s.Body = v
	return s
}

type GetMetaTableColumnRequest struct {
	// The globally unique identifier (GUID) of the table in Data Management (DMS).
	//
	// *   If the database to which the table belongs is a logical database, you can call the [ListLogicTables](~~141875~~) operation to obtain the value of this parameter.
	// *   If the database to which the table belongs is a physical database, you can call the [ListTables](~~141878~~) operation to obtain the value of this parameter.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetMetaTableColumnRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableColumnRequest) GoString() string {
	return s.String()
}

func (s *GetMetaTableColumnRequest) SetTableGuid(v string) *GetMetaTableColumnRequest {
	s.TableGuid = &v
	return s
}

func (s *GetMetaTableColumnRequest) SetTid(v int64) *GetMetaTableColumnRequest {
	s.Tid = &v
	return s
}

type GetMetaTableColumnResponseBody struct {
	// The details about fields in the table.
	ColumnList []*GetMetaTableColumnResponseBodyColumnList `json:"ColumnList,omitempty" xml:"ColumnList,omitempty" type:"Repeated"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetMetaTableColumnResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableColumnResponseBody) GoString() string {
	return s.String()
}

func (s *GetMetaTableColumnResponseBody) SetColumnList(v []*GetMetaTableColumnResponseBodyColumnList) *GetMetaTableColumnResponseBody {
	s.ColumnList = v
	return s
}

func (s *GetMetaTableColumnResponseBody) SetErrorCode(v string) *GetMetaTableColumnResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetMetaTableColumnResponseBody) SetErrorMessage(v string) *GetMetaTableColumnResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetMetaTableColumnResponseBody) SetRequestId(v string) *GetMetaTableColumnResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetMetaTableColumnResponseBody) SetSuccess(v bool) *GetMetaTableColumnResponseBody {
	s.Success = &v
	return s
}

type GetMetaTableColumnResponseBodyColumnList struct {
	// Indicates whether the column is an auto-increment column. Valid values:
	//
	// *   **true**: The column is an auto-increment column.
	// *   **false**: The column is not an auto-increment column.
	AutoIncrement *bool `json:"AutoIncrement,omitempty" xml:"AutoIncrement,omitempty"`
	// The ID of the column.
	ColumnId *string `json:"ColumnId,omitempty" xml:"ColumnId,omitempty"`
	// The name of the column.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The data type of the column.
	//
	// > The return value of a column is not unique, such as **bigint** or **int**.
	ColumnType *string `json:"ColumnType,omitempty" xml:"ColumnType,omitempty"`
	// The length of the field.
	DataLength *int64 `json:"DataLength,omitempty" xml:"DataLength,omitempty"`
	// The precision of the field.
	DataPrecision *int32 `json:"DataPrecision,omitempty" xml:"DataPrecision,omitempty"`
	// The number of decimal places for the field.
	DataScale *int32 `json:"DataScale,omitempty" xml:"DataScale,omitempty"`
	// The description of the column.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether the field can be empty. Valid values:
	//
	// *   **true**: The field can be empty.
	// *   **false**: The field cannot be empty.
	Nullable *bool `json:"Nullable,omitempty" xml:"Nullable,omitempty"`
	// The position of the field in the table.
	Position *int32 `json:"Position,omitempty" xml:"Position,omitempty"`
	// Indicates whether the field is the primary key. Valid values:
	//
	// *   **true**: The field is the primary key.
	// *   **false**: The field is not the primary key.
	PrimaryKey *string `json:"PrimaryKey,omitempty" xml:"PrimaryKey,omitempty"`
	// The sensitivity level of the column. Valid values:
	//
	// *   **INNER**: The column is not sensitive.
	// *   **SENSITIVE**: The column is sensitive.
	// *   **CONFIDENTIAL**: The column is confidential.
	//
	// > For more information, see [Sensitivity levels of columns](~~66091~~).
	SecurityLevel *string `json:"SecurityLevel,omitempty" xml:"SecurityLevel,omitempty"`
}

func (s GetMetaTableColumnResponseBodyColumnList) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableColumnResponseBodyColumnList) GoString() string {
	return s.String()
}

func (s *GetMetaTableColumnResponseBodyColumnList) SetAutoIncrement(v bool) *GetMetaTableColumnResponseBodyColumnList {
	s.AutoIncrement = &v
	return s
}

func (s *GetMetaTableColumnResponseBodyColumnList) SetColumnId(v string) *GetMetaTableColumnResponseBodyColumnList {
	s.ColumnId = &v
	return s
}

func (s *GetMetaTableColumnResponseBodyColumnList) SetColumnName(v string) *GetMetaTableColumnResponseBodyColumnList {
	s.ColumnName = &v
	return s
}

func (s *GetMetaTableColumnResponseBodyColumnList) SetColumnType(v string) *GetMetaTableColumnResponseBodyColumnList {
	s.ColumnType = &v
	return s
}

func (s *GetMetaTableColumnResponseBodyColumnList) SetDataLength(v int64) *GetMetaTableColumnResponseBodyColumnList {
	s.DataLength = &v
	return s
}

func (s *GetMetaTableColumnResponseBodyColumnList) SetDataPrecision(v int32) *GetMetaTableColumnResponseBodyColumnList {
	s.DataPrecision = &v
	return s
}

func (s *GetMetaTableColumnResponseBodyColumnList) SetDataScale(v int32) *GetMetaTableColumnResponseBodyColumnList {
	s.DataScale = &v
	return s
}

func (s *GetMetaTableColumnResponseBodyColumnList) SetDescription(v string) *GetMetaTableColumnResponseBodyColumnList {
	s.Description = &v
	return s
}

func (s *GetMetaTableColumnResponseBodyColumnList) SetNullable(v bool) *GetMetaTableColumnResponseBodyColumnList {
	s.Nullable = &v
	return s
}

func (s *GetMetaTableColumnResponseBodyColumnList) SetPosition(v int32) *GetMetaTableColumnResponseBodyColumnList {
	s.Position = &v
	return s
}

func (s *GetMetaTableColumnResponseBodyColumnList) SetPrimaryKey(v string) *GetMetaTableColumnResponseBodyColumnList {
	s.PrimaryKey = &v
	return s
}

func (s *GetMetaTableColumnResponseBodyColumnList) SetSecurityLevel(v string) *GetMetaTableColumnResponseBodyColumnList {
	s.SecurityLevel = &v
	return s
}

type GetMetaTableColumnResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetMetaTableColumnResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetMetaTableColumnResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableColumnResponse) GoString() string {
	return s.String()
}

func (s *GetMetaTableColumnResponse) SetHeaders(v map[string]*string) *GetMetaTableColumnResponse {
	s.Headers = v
	return s
}

func (s *GetMetaTableColumnResponse) SetStatusCode(v int32) *GetMetaTableColumnResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMetaTableColumnResponse) SetBody(v *GetMetaTableColumnResponseBody) *GetMetaTableColumnResponse {
	s.Body = v
	return s
}

type GetMetaTableDetailInfoRequest struct {
	// The GUID of the table in Data Management (DMS).
	//
	// >
	//
	// *   You can call the [ListLogicTables](~~141875~~) operation with ReturnGuid set to true to query the GUIDs of logical tables in a specific logical database.
	//
	// *   You can call the [ListTables](~~141878~~) operation with ReturnGuid set to true to query the GUIDs of tables in a specific physical database.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
	// The ID of the tenant.
	//
	// > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the [View information about the current tenant](~~181330~~) section of the Manage DMS tenants topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetMetaTableDetailInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableDetailInfoRequest) GoString() string {
	return s.String()
}

func (s *GetMetaTableDetailInfoRequest) SetTableGuid(v string) *GetMetaTableDetailInfoRequest {
	s.TableGuid = &v
	return s
}

func (s *GetMetaTableDetailInfoRequest) SetTid(v int64) *GetMetaTableDetailInfoRequest {
	s.Tid = &v
	return s
}

type GetMetaTableDetailInfoResponseBody struct {
	// The details of the table.
	DetailInfo *GetMetaTableDetailInfoResponseBodyDetailInfo `json:"DetailInfo,omitempty" xml:"DetailInfo,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetMetaTableDetailInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableDetailInfoResponseBody) GoString() string {
	return s.String()
}

func (s *GetMetaTableDetailInfoResponseBody) SetDetailInfo(v *GetMetaTableDetailInfoResponseBodyDetailInfo) *GetMetaTableDetailInfoResponseBody {
	s.DetailInfo = v
	return s
}

func (s *GetMetaTableDetailInfoResponseBody) SetErrorCode(v string) *GetMetaTableDetailInfoResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetMetaTableDetailInfoResponseBody) SetErrorMessage(v string) *GetMetaTableDetailInfoResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetMetaTableDetailInfoResponseBody) SetRequestId(v string) *GetMetaTableDetailInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetMetaTableDetailInfoResponseBody) SetSuccess(v bool) *GetMetaTableDetailInfoResponseBody {
	s.Success = &v
	return s
}

type GetMetaTableDetailInfoResponseBodyDetailInfo struct {
	// The columns in the table.
	ColumnList []*GetMetaTableDetailInfoResponseBodyDetailInfoColumnList `json:"ColumnList,omitempty" xml:"ColumnList,omitempty" type:"Repeated"`
	// The list of indexes.
	IndexList []*GetMetaTableDetailInfoResponseBodyDetailInfoIndexList `json:"IndexList,omitempty" xml:"IndexList,omitempty" type:"Repeated"`
}

func (s GetMetaTableDetailInfoResponseBodyDetailInfo) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableDetailInfoResponseBodyDetailInfo) GoString() string {
	return s.String()
}

func (s *GetMetaTableDetailInfoResponseBodyDetailInfo) SetColumnList(v []*GetMetaTableDetailInfoResponseBodyDetailInfoColumnList) *GetMetaTableDetailInfoResponseBodyDetailInfo {
	s.ColumnList = v
	return s
}

func (s *GetMetaTableDetailInfoResponseBodyDetailInfo) SetIndexList(v []*GetMetaTableDetailInfoResponseBodyDetailInfoIndexList) *GetMetaTableDetailInfoResponseBodyDetailInfo {
	s.IndexList = v
	return s
}

type GetMetaTableDetailInfoResponseBodyDetailInfoColumnList struct {
	// Indicates whether the column is an auto-increment column. Valid values:
	//
	// *   true: The column is an auto-increment column.
	// *   false: The column is not an auto-increment column.
	AutoIncrement *bool `json:"AutoIncrement,omitempty" xml:"AutoIncrement,omitempty"`
	// The ID of the column.
	ColumnId *string `json:"ColumnId,omitempty" xml:"ColumnId,omitempty"`
	// The name of the column.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The data type of the column. Examples: Bigint, Int, and Varchar.
	ColumnType *string `json:"ColumnType,omitempty" xml:"ColumnType,omitempty"`
	// The length of the field.
	DataLength *int64 `json:"DataLength,omitempty" xml:"DataLength,omitempty"`
	// The precision of the field.
	DataPrecision *int32 `json:"DataPrecision,omitempty" xml:"DataPrecision,omitempty"`
	// The scale of the column.
	DataScale *int32 `json:"DataScale,omitempty" xml:"DataScale,omitempty"`
	// The description of the column.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether the column is nullable. Valid values:
	//
	// *   true: The column is nullable.
	// *   false: The column is not nullable.
	Nullable *bool `json:"Nullable,omitempty" xml:"Nullable,omitempty"`
	// The position of the field in the table.
	Position *string `json:"Position,omitempty" xml:"Position,omitempty"`
}

func (s GetMetaTableDetailInfoResponseBodyDetailInfoColumnList) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableDetailInfoResponseBodyDetailInfoColumnList) GoString() string {
	return s.String()
}

func (s *GetMetaTableDetailInfoResponseBodyDetailInfoColumnList) SetAutoIncrement(v bool) *GetMetaTableDetailInfoResponseBodyDetailInfoColumnList {
	s.AutoIncrement = &v
	return s
}

func (s *GetMetaTableDetailInfoResponseBodyDetailInfoColumnList) SetColumnId(v string) *GetMetaTableDetailInfoResponseBodyDetailInfoColumnList {
	s.ColumnId = &v
	return s
}

func (s *GetMetaTableDetailInfoResponseBodyDetailInfoColumnList) SetColumnName(v string) *GetMetaTableDetailInfoResponseBodyDetailInfoColumnList {
	s.ColumnName = &v
	return s
}

func (s *GetMetaTableDetailInfoResponseBodyDetailInfoColumnList) SetColumnType(v string) *GetMetaTableDetailInfoResponseBodyDetailInfoColumnList {
	s.ColumnType = &v
	return s
}

func (s *GetMetaTableDetailInfoResponseBodyDetailInfoColumnList) SetDataLength(v int64) *GetMetaTableDetailInfoResponseBodyDetailInfoColumnList {
	s.DataLength = &v
	return s
}

func (s *GetMetaTableDetailInfoResponseBodyDetailInfoColumnList) SetDataPrecision(v int32) *GetMetaTableDetailInfoResponseBodyDetailInfoColumnList {
	s.DataPrecision = &v
	return s
}

func (s *GetMetaTableDetailInfoResponseBodyDetailInfoColumnList) SetDataScale(v int32) *GetMetaTableDetailInfoResponseBodyDetailInfoColumnList {
	s.DataScale = &v
	return s
}

func (s *GetMetaTableDetailInfoResponseBodyDetailInfoColumnList) SetDescription(v string) *GetMetaTableDetailInfoResponseBodyDetailInfoColumnList {
	s.Description = &v
	return s
}

func (s *GetMetaTableDetailInfoResponseBodyDetailInfoColumnList) SetNullable(v bool) *GetMetaTableDetailInfoResponseBodyDetailInfoColumnList {
	s.Nullable = &v
	return s
}

func (s *GetMetaTableDetailInfoResponseBodyDetailInfoColumnList) SetPosition(v string) *GetMetaTableDetailInfoResponseBodyDetailInfoColumnList {
	s.Position = &v
	return s
}

type GetMetaTableDetailInfoResponseBodyDetailInfoIndexList struct {
	// The index column.
	IndexColumns []*string `json:"IndexColumns,omitempty" xml:"IndexColumns,omitempty" type:"Repeated"`
	// The ID of the index.
	IndexId *string `json:"IndexId,omitempty" xml:"IndexId,omitempty"`
	// The name of the index.
	IndexName *string `json:"IndexName,omitempty" xml:"IndexName,omitempty"`
	// The type of the index. Examples: Primary, Unique, and Normal.
	IndexType *string `json:"IndexType,omitempty" xml:"IndexType,omitempty"`
	// Indicates whether the index is unique. Valid values:
	//
	// *   true: The index is unique.
	// *   false: The index is not unique.
	Unique *bool `json:"Unique,omitempty" xml:"Unique,omitempty"`
}

func (s GetMetaTableDetailInfoResponseBodyDetailInfoIndexList) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableDetailInfoResponseBodyDetailInfoIndexList) GoString() string {
	return s.String()
}

func (s *GetMetaTableDetailInfoResponseBodyDetailInfoIndexList) SetIndexColumns(v []*string) *GetMetaTableDetailInfoResponseBodyDetailInfoIndexList {
	s.IndexColumns = v
	return s
}

func (s *GetMetaTableDetailInfoResponseBodyDetailInfoIndexList) SetIndexId(v string) *GetMetaTableDetailInfoResponseBodyDetailInfoIndexList {
	s.IndexId = &v
	return s
}

func (s *GetMetaTableDetailInfoResponseBodyDetailInfoIndexList) SetIndexName(v string) *GetMetaTableDetailInfoResponseBodyDetailInfoIndexList {
	s.IndexName = &v
	return s
}

func (s *GetMetaTableDetailInfoResponseBodyDetailInfoIndexList) SetIndexType(v string) *GetMetaTableDetailInfoResponseBodyDetailInfoIndexList {
	s.IndexType = &v
	return s
}

func (s *GetMetaTableDetailInfoResponseBodyDetailInfoIndexList) SetUnique(v bool) *GetMetaTableDetailInfoResponseBodyDetailInfoIndexList {
	s.Unique = &v
	return s
}

type GetMetaTableDetailInfoResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetMetaTableDetailInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetMetaTableDetailInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableDetailInfoResponse) GoString() string {
	return s.String()
}

func (s *GetMetaTableDetailInfoResponse) SetHeaders(v map[string]*string) *GetMetaTableDetailInfoResponse {
	s.Headers = v
	return s
}

func (s *GetMetaTableDetailInfoResponse) SetStatusCode(v int32) *GetMetaTableDetailInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMetaTableDetailInfoResponse) SetBody(v *GetMetaTableDetailInfoResponseBody) *GetMetaTableDetailInfoResponse {
	s.Body = v
	return s
}

type GetOnlineDDLProgressRequest struct {
	// The ID of the OnlineDDL SQL task details. You can call the [ListDBTaskSQLJobDetail](~~207073~~) operation to obtain the task detail ID.
	JobDetailId *int64 `json:"JobDetailId,omitempty" xml:"JobDetailId,omitempty"`
	// The ID of the tenant.
	//
	// > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetOnlineDDLProgressRequest) String() string {
	return tea.Prettify(s)
}

func (s GetOnlineDDLProgressRequest) GoString() string {
	return s.String()
}

func (s *GetOnlineDDLProgressRequest) SetJobDetailId(v int64) *GetOnlineDDLProgressRequest {
	s.JobDetailId = &v
	return s
}

func (s *GetOnlineDDLProgressRequest) SetTid(v int64) *GetOnlineDDLProgressRequest {
	s.Tid = &v
	return s
}

type GetOnlineDDLProgressResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The details of the task.
	OnlineDDLTaskDetail *GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail `json:"OnlineDDLTaskDetail,omitempty" xml:"OnlineDDLTaskDetail,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetOnlineDDLProgressResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetOnlineDDLProgressResponseBody) GoString() string {
	return s.String()
}

func (s *GetOnlineDDLProgressResponseBody) SetErrorCode(v string) *GetOnlineDDLProgressResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetOnlineDDLProgressResponseBody) SetErrorMessage(v string) *GetOnlineDDLProgressResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetOnlineDDLProgressResponseBody) SetOnlineDDLTaskDetail(v *GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail) *GetOnlineDDLProgressResponseBody {
	s.OnlineDDLTaskDetail = v
	return s
}

func (s *GetOnlineDDLProgressResponseBody) SetRequestId(v string) *GetOnlineDDLProgressResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetOnlineDDLProgressResponseBody) SetSuccess(v bool) *GetOnlineDDLProgressResponseBody {
	s.Success = &v
	return s
}

type GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail struct {
	// The cleanup policy of the original table after the cut-over. Valid values:
	//
	// *   **DROP**: Invalid original tables are deleted.
	// *   **MOVE**: Invalid original tables are moved to the test database. You can delete the tables manually.
	// *   **NOTHING**: Invalid original tables are retained in the original database. You can delete the tables manually.
	CleanStrategy *string `json:"CleanStrategy,omitempty" xml:"CleanStrategy,omitempty"`
	// The policy of full replication. Valid values:
	//
	// *   **AUTO**: DMS dynamically adjusts the chunk size based on the performance of the database. Tables are locked for less than 1.5 seconds during a single replication operation.
	// *   **RUNNING**: DMS uses the specified value of the CopyChunkSize parameter. The valid value of the CopyChunkSize parameter ranges from 1 to 60000. If you set this parameter to RUNNING, you must specify the CopyChunkSize parameter.
	CopyChunkMode *string `json:"CopyChunkMode,omitempty" xml:"CopyChunkMode,omitempty"`
	// The size of each chunk that is used to replicate data. This parameter is used to specify the size of each chunk. A larger chunk size increases the replication efficiency and decreases the business performance.
	//
	// > During full replication, the original table is divided into N small chunks and each chunk is replicated to the temporary table one by one. By default, DMS dynamically adjusts the size of each chunk.
	CopyChunkSize *int64 `json:"CopyChunkSize,omitempty" xml:"CopyChunkSize,omitempty"`
	// The actual amount of data replicated from the original table in the lock-free change operation.
	CopyCount *int64 `json:"CopyCount,omitempty" xml:"CopyCount,omitempty"`
	// The estimated total number of rows of the data. The value is obtained from the statistical data in the information_schema database. In most cases, the estimated total number of rows is smaller than the actual number of rows in a table.
	CopyTotal *int64 `json:"CopyTotal,omitempty" xml:"CopyTotal,omitempty"`
	// The number of retries when the cut-over fails.
	CutoverFailRetryTimes *int64 `json:"CutoverFailRetryTimes,omitempty" xml:"CutoverFailRetryTimes,omitempty"`
	// The maximum period of time that a table can be locked during cut-over. Unit: seconds.
	CutoverLockTimeSeconds *int64 `json:"CutoverLockTimeSeconds,omitempty" xml:"CutoverLockTimeSeconds,omitempty"`
	// The end of the time window of the cut-over operation. This value is at least 30 minutes later than the CutoverWindowStartTime parameter. Default value: 23:59:59
	CutoverWindowEndTime *string `json:"CutoverWindowEndTime,omitempty" xml:"CutoverWindowEndTime,omitempty"`
	// The beginning of the time window of the cut-over operation. Default value: 00:00:00. This parameter controls the time window of the cut-over. Cut-over can be performed only when the cut-over conditions are met and the time is within the specified time window. If the time is not within the time window, the cut-over operation is not performed until the time reaches the beginning of the time window.
	CutoverWindowStartTime *string `json:"CutoverWindowStartTime,omitempty" xml:"CutoverWindowStartTime,omitempty"`
	// The replay latency of DMS. Unit: seconds. The replay latency is the period of time that is taken to replay the binary logs of the table to the temporary table. The latency does not indicate the data migration latency between a primary database and a secondary database.
	DelaySeconds *int64 `json:"DelaySeconds,omitempty" xml:"DelaySeconds,omitempty"`
	// The state of the task. Valid values:
	//
	// *   **INIT**: The task is being initialized.
	// *   **SUCCESS**: The task is complete.
	// *   **RUNNING**: The task is being executed.
	// *   **WAITING_CUTOVER**: The task is waiting for cut-over.
	// *   **RESTARTING**: The task is restarting.
	// *   **PAUSE**: The task is suspended.
	// *   **UNSUPPORTED**: The task is not supported.
	// *   **CANCELED**: The task is canceled.
	// *   **FAIL**: The task failed.
	// *   **INTERRUPT**: The task is interrupted.
	JobStatus *string `json:"JobStatus,omitempty" xml:"JobStatus,omitempty"`
	// The estimated execution progress. The actual progress is subject to the task status.
	ProgressRatio *string `json:"ProgressRatio,omitempty" xml:"ProgressRatio,omitempty"`
	// The description of the task status.
	StatusDesc *string `json:"StatusDesc,omitempty" xml:"StatusDesc,omitempty"`
}

func (s GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail) String() string {
	return tea.Prettify(s)
}

func (s GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail) GoString() string {
	return s.String()
}

func (s *GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail) SetCleanStrategy(v string) *GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail {
	s.CleanStrategy = &v
	return s
}

func (s *GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail) SetCopyChunkMode(v string) *GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail {
	s.CopyChunkMode = &v
	return s
}

func (s *GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail) SetCopyChunkSize(v int64) *GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail {
	s.CopyChunkSize = &v
	return s
}

func (s *GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail) SetCopyCount(v int64) *GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail {
	s.CopyCount = &v
	return s
}

func (s *GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail) SetCopyTotal(v int64) *GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail {
	s.CopyTotal = &v
	return s
}

func (s *GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail) SetCutoverFailRetryTimes(v int64) *GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail {
	s.CutoverFailRetryTimes = &v
	return s
}

func (s *GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail) SetCutoverLockTimeSeconds(v int64) *GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail {
	s.CutoverLockTimeSeconds = &v
	return s
}

func (s *GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail) SetCutoverWindowEndTime(v string) *GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail {
	s.CutoverWindowEndTime = &v
	return s
}

func (s *GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail) SetCutoverWindowStartTime(v string) *GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail {
	s.CutoverWindowStartTime = &v
	return s
}

func (s *GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail) SetDelaySeconds(v int64) *GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail {
	s.DelaySeconds = &v
	return s
}

func (s *GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail) SetJobStatus(v string) *GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail {
	s.JobStatus = &v
	return s
}

func (s *GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail) SetProgressRatio(v string) *GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail {
	s.ProgressRatio = &v
	return s
}

func (s *GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail) SetStatusDesc(v string) *GetOnlineDDLProgressResponseBodyOnlineDDLTaskDetail {
	s.StatusDesc = &v
	return s
}

type GetOnlineDDLProgressResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetOnlineDDLProgressResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetOnlineDDLProgressResponse) String() string {
	return tea.Prettify(s)
}

func (s GetOnlineDDLProgressResponse) GoString() string {
	return s.String()
}

func (s *GetOnlineDDLProgressResponse) SetHeaders(v map[string]*string) *GetOnlineDDLProgressResponse {
	s.Headers = v
	return s
}

func (s *GetOnlineDDLProgressResponse) SetStatusCode(v int32) *GetOnlineDDLProgressResponse {
	s.StatusCode = &v
	return s
}

func (s *GetOnlineDDLProgressResponse) SetBody(v *GetOnlineDDLProgressResponseBody) *GetOnlineDDLProgressResponse {
	s.Body = v
	return s
}

type GetOpLogRequest struct {
	// DatabaseName.
	DatabaseName *string `json:"DatabaseName,omitempty" xml:"DatabaseName,omitempty"`
	// The end of the time range to query. Specify the time in the yyyy-MM-DD HH:mm:ss format.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The functional module for which you want to query operation logs. If you do not specify this parameter, operation logs for all functional modules are returned. Valid values:
	//
	// *   **PERMISSION**: permissions
	// *   **OWNER**: data owner
	// *   **SQL_CONSOLE**: data query
	// *   **SQL_CONSOLE_EXPORT**: query result export
	// *   **DATA_CHANGE**: data change
	// *   **DATA_EXPORT**: data export
	// *   **SQL_REVIEW**: SQL review
	// *   **DT_SYNC**: database and table synchronization
	// *   **DT_DETAIL**: database and table details
	// *   **DB_TASK**: task management
	// *   **INSTANCE_MANAGE**: instance management
	// *   **USER_MANAGE**: user management
	// *   **SECURITY_RULE**: security rules
	// *   **CONFIG_MANAGE**: configuration management
	// *   **RESOURCE_AUTH**: resource authorization
	// *   **ACCESS_WHITE_IP**: access IP address whitelist
	// *   **NDDL**: schema design
	// *   **DSQL_CONSOLE**: cross-database data query
	// *   **DSQL_CONSOLE_EXPORT**: cross-database query result export
	// *   **DATA_TRACT**: data tracking
	// *   **DATA_QUALITY**: data quality
	// *   **DATALINK_MANAGE** :DBLink management
	// *   **DATASEC_MANAGE**: sensitive data management
	// *   **SELL**: sales
	Module *string `json:"Module,omitempty" xml:"Module,omitempty"`
	// The number of the page to return. Pages start from page 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid values:
	//
	// *   30
	// *   50
	// *   100
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The beginning of the time range to query. Specify the time in the yyyy-MM-DD HH:mm:ss format.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// UserNick.
	UserNick *string `json:"UserNick,omitempty" xml:"UserNick,omitempty"`
}

func (s GetOpLogRequest) String() string {
	return tea.Prettify(s)
}

func (s GetOpLogRequest) GoString() string {
	return s.String()
}

func (s *GetOpLogRequest) SetDatabaseName(v string) *GetOpLogRequest {
	s.DatabaseName = &v
	return s
}

func (s *GetOpLogRequest) SetEndTime(v string) *GetOpLogRequest {
	s.EndTime = &v
	return s
}

func (s *GetOpLogRequest) SetModule(v string) *GetOpLogRequest {
	s.Module = &v
	return s
}

func (s *GetOpLogRequest) SetPageNumber(v int32) *GetOpLogRequest {
	s.PageNumber = &v
	return s
}

func (s *GetOpLogRequest) SetPageSize(v int32) *GetOpLogRequest {
	s.PageSize = &v
	return s
}

func (s *GetOpLogRequest) SetStartTime(v string) *GetOpLogRequest {
	s.StartTime = &v
	return s
}

func (s *GetOpLogRequest) SetTid(v int64) *GetOpLogRequest {
	s.Tid = &v
	return s
}

func (s *GetOpLogRequest) SetUserNick(v string) *GetOpLogRequest {
	s.UserNick = &v
	return s
}

type GetOpLogResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The details of the operation log.
	OpLogDetails *GetOpLogResponseBodyOpLogDetails `json:"OpLogDetails,omitempty" xml:"OpLogDetails,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of operation logs that are returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s GetOpLogResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetOpLogResponseBody) GoString() string {
	return s.String()
}

func (s *GetOpLogResponseBody) SetErrorCode(v string) *GetOpLogResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetOpLogResponseBody) SetErrorMessage(v string) *GetOpLogResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetOpLogResponseBody) SetOpLogDetails(v *GetOpLogResponseBodyOpLogDetails) *GetOpLogResponseBody {
	s.OpLogDetails = v
	return s
}

func (s *GetOpLogResponseBody) SetRequestId(v string) *GetOpLogResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetOpLogResponseBody) SetSuccess(v bool) *GetOpLogResponseBody {
	s.Success = &v
	return s
}

func (s *GetOpLogResponseBody) SetTotalCount(v int64) *GetOpLogResponseBody {
	s.TotalCount = &v
	return s
}

type GetOpLogResponseBodyOpLogDetails struct {
	OpLogDetail []*GetOpLogResponseBodyOpLogDetailsOpLogDetail `json:"OpLogDetail,omitempty" xml:"OpLogDetail,omitempty" type:"Repeated"`
}

func (s GetOpLogResponseBodyOpLogDetails) String() string {
	return tea.Prettify(s)
}

func (s GetOpLogResponseBodyOpLogDetails) GoString() string {
	return s.String()
}

func (s *GetOpLogResponseBodyOpLogDetails) SetOpLogDetail(v []*GetOpLogResponseBodyOpLogDetailsOpLogDetail) *GetOpLogResponseBodyOpLogDetails {
	s.OpLogDetail = v
	return s
}

type GetOpLogResponseBodyOpLogDetailsOpLogDetail struct {
	// The endpoint of the database instance.
	//
	// >
	//
	// *   This parameter is valid only for database instances of the LocalInstance type.
	//
	// *   This parameter is valid only for operations on the functional modules related to tasks.
	Database *string `json:"Database,omitempty" xml:"Database,omitempty"`
	// The functional module for which the operation log is queried.
	Module *string `json:"Module,omitempty" xml:"Module,omitempty"`
	// The details of the operation.
	OpContent *string `json:"OpContent,omitempty" xml:"OpContent,omitempty"`
	// The time when the operation was performed.
	OpTime *string `json:"OpTime,omitempty" xml:"OpTime,omitempty"`
	// The ID of the user who performed the operation.
	OpUserId *int64 `json:"OpUserId,omitempty" xml:"OpUserId,omitempty"`
	// The ID of the ticket or task.
	//
	// >  This parameter is valid only for operations on the functional modules related to tasks and the task management module in system management.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the Alibaba Cloud account.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The display name of the user.
	UserNick *string `json:"UserNick,omitempty" xml:"UserNick,omitempty"`
}

func (s GetOpLogResponseBodyOpLogDetailsOpLogDetail) String() string {
	return tea.Prettify(s)
}

func (s GetOpLogResponseBodyOpLogDetailsOpLogDetail) GoString() string {
	return s.String()
}

func (s *GetOpLogResponseBodyOpLogDetailsOpLogDetail) SetDatabase(v string) *GetOpLogResponseBodyOpLogDetailsOpLogDetail {
	s.Database = &v
	return s
}

func (s *GetOpLogResponseBodyOpLogDetailsOpLogDetail) SetModule(v string) *GetOpLogResponseBodyOpLogDetailsOpLogDetail {
	s.Module = &v
	return s
}

func (s *GetOpLogResponseBodyOpLogDetailsOpLogDetail) SetOpContent(v string) *GetOpLogResponseBodyOpLogDetailsOpLogDetail {
	s.OpContent = &v
	return s
}

func (s *GetOpLogResponseBodyOpLogDetailsOpLogDetail) SetOpTime(v string) *GetOpLogResponseBodyOpLogDetailsOpLogDetail {
	s.OpTime = &v
	return s
}

func (s *GetOpLogResponseBodyOpLogDetailsOpLogDetail) SetOpUserId(v int64) *GetOpLogResponseBodyOpLogDetailsOpLogDetail {
	s.OpUserId = &v
	return s
}

func (s *GetOpLogResponseBodyOpLogDetailsOpLogDetail) SetOrderId(v int64) *GetOpLogResponseBodyOpLogDetailsOpLogDetail {
	s.OrderId = &v
	return s
}

func (s *GetOpLogResponseBodyOpLogDetailsOpLogDetail) SetUserId(v string) *GetOpLogResponseBodyOpLogDetailsOpLogDetail {
	s.UserId = &v
	return s
}

func (s *GetOpLogResponseBodyOpLogDetailsOpLogDetail) SetUserNick(v string) *GetOpLogResponseBodyOpLogDetailsOpLogDetail {
	s.UserNick = &v
	return s
}

type GetOpLogResponse struct {
	Headers    map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetOpLogResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetOpLogResponse) String() string {
	return tea.Prettify(s)
}

func (s GetOpLogResponse) GoString() string {
	return s.String()
}

func (s *GetOpLogResponse) SetHeaders(v map[string]*string) *GetOpLogResponse {
	s.Headers = v
	return s
}

func (s *GetOpLogResponse) SetStatusCode(v int32) *GetOpLogResponse {
	s.StatusCode = &v
	return s
}

func (s *GetOpLogResponse) SetBody(v *GetOpLogResponseBody) *GetOpLogResponse {
	s.Body = v
	return s
}

type GetOrderAttachmentFileRequest struct {
	// The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to query the ticket ID.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant.
	//
	// > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetOrderAttachmentFileRequest) String() string {
	return tea.Prettify(s)
}

func (s GetOrderAttachmentFileRequest) GoString() string {
	return s.String()
}

func (s *GetOrderAttachmentFileRequest) SetOrderId(v int64) *GetOrderAttachmentFileRequest {
	s.OrderId = &v
	return s
}

func (s *GetOrderAttachmentFileRequest) SetTid(v int64) *GetOrderAttachmentFileRequest {
	s.Tid = &v
	return s
}

type GetOrderAttachmentFileResponseBody struct {
	// The error code returned. Take note of the following rules:
	//
	// *   The **ErrorCode** parameter is not returned if the request is successful.
	// *   The **ErrorCode** parameter is returned if the request fails. For more information, see the **Error codes** section of this topic.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The download URL of the attachment.
	FileUrl *string `json:"FileUrl,omitempty" xml:"FileUrl,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetOrderAttachmentFileResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetOrderAttachmentFileResponseBody) GoString() string {
	return s.String()
}

func (s *GetOrderAttachmentFileResponseBody) SetErrorCode(v string) *GetOrderAttachmentFileResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetOrderAttachmentFileResponseBody) SetErrorMessage(v string) *GetOrderAttachmentFileResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetOrderAttachmentFileResponseBody) SetFileUrl(v string) *GetOrderAttachmentFileResponseBody {
	s.FileUrl = &v
	return s
}

func (s *GetOrderAttachmentFileResponseBody) SetRequestId(v string) *GetOrderAttachmentFileResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetOrderAttachmentFileResponseBody) SetSuccess(v bool) *GetOrderAttachmentFileResponseBody {
	s.Success = &v
	return s
}

type GetOrderAttachmentFileResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetOrderAttachmentFileResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetOrderAttachmentFileResponse) String() string {
	return tea.Prettify(s)
}

func (s GetOrderAttachmentFileResponse) GoString() string {
	return s.String()
}

func (s *GetOrderAttachmentFileResponse) SetHeaders(v map[string]*string) *GetOrderAttachmentFileResponse {
	s.Headers = v
	return s
}

func (s *GetOrderAttachmentFileResponse) SetStatusCode(v int32) *GetOrderAttachmentFileResponse {
	s.StatusCode = &v
	return s
}

func (s *GetOrderAttachmentFileResponse) SetBody(v *GetOrderAttachmentFileResponseBody) *GetOrderAttachmentFileResponse {
	s.Body = v
	return s
}

type GetOrderBaseInfoRequest struct {
	// The ID of the ticket.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant.
	//
	// > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetOrderBaseInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s GetOrderBaseInfoRequest) GoString() string {
	return s.String()
}

func (s *GetOrderBaseInfoRequest) SetOrderId(v int64) *GetOrderBaseInfoRequest {
	s.OrderId = &v
	return s
}

func (s *GetOrderBaseInfoRequest) SetTid(v int64) *GetOrderBaseInfoRequest {
	s.Tid = &v
	return s
}

type GetOrderBaseInfoResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The basic information about the ticket.
	OrderBaseInfo *GetOrderBaseInfoResponseBodyOrderBaseInfo `json:"OrderBaseInfo,omitempty" xml:"OrderBaseInfo,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetOrderBaseInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetOrderBaseInfoResponseBody) GoString() string {
	return s.String()
}

func (s *GetOrderBaseInfoResponseBody) SetErrorCode(v string) *GetOrderBaseInfoResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetOrderBaseInfoResponseBody) SetErrorMessage(v string) *GetOrderBaseInfoResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetOrderBaseInfoResponseBody) SetOrderBaseInfo(v *GetOrderBaseInfoResponseBodyOrderBaseInfo) *GetOrderBaseInfoResponseBody {
	s.OrderBaseInfo = v
	return s
}

func (s *GetOrderBaseInfoResponseBody) SetRequestId(v string) *GetOrderBaseInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetOrderBaseInfoResponseBody) SetSuccess(v bool) *GetOrderBaseInfoResponseBody {
	s.Success = &v
	return s
}

type GetOrderBaseInfoResponseBodyOrderBaseInfo struct {
	// The Key of the ticket attachment. This information is returned only when an attachment is uploaded when a ticket is created.
	AttachmentKey *string `json:"AttachmentKey,omitempty" xml:"AttachmentKey,omitempty"`
	// The remarks of the ticket.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The applicant.
	Committer *string `json:"Committer,omitempty" xml:"Committer,omitempty"`
	// The ID of the applicant. Note: The ID is different from the Alibaba Cloud account ID of the applicant.
	CommitterId *int64 `json:"CommitterId,omitempty" xml:"CommitterId,omitempty"`
	// The time when the ticket was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The time when the ticket was last modified.
	LastModifyTime *string `json:"LastModifyTime,omitempty" xml:"LastModifyTime,omitempty"`
	// The ID of the ticket.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The original file name of the ticket attachment. This information is returned only when an attachment is uploaded when a ticket is created.
	OriginAttachmentName *string `json:"OriginAttachmentName,omitempty" xml:"OriginAttachmentName,omitempty"`
	// The type of the ticket. For more information about the value of this parameter, see the request parameters of the [CreateOrder](~~465865~~) operation.
	PluginType *string `json:"PluginType,omitempty" xml:"PluginType,omitempty"`
	// The IDs of the operators that are related to the ticket.
	RelatedUserList *GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserList `json:"RelatedUserList,omitempty" xml:"RelatedUserList,omitempty" type:"Struct"`
	// The nicknames of the operators that are related to the ticket.
	RelatedUserNickList *GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserNickList `json:"RelatedUserNickList,omitempty" xml:"RelatedUserNickList,omitempty" type:"Struct"`
	// The status code of the ticket. Valid values:
	//
	// *   **new**: The ticket is created.
	// *   **toaudit**: The ticket is being reviewed.
	// *   **Approved**: The ticket is approved.
	// *   **reject**: The ticket is rejected.
	// *   **processing**: The ticket is being executed.
	// *   **success**: The ticket is executed.
	// *   **closed**: The ticket is closed.
	StatusCode *string `json:"StatusCode,omitempty" xml:"StatusCode,omitempty"`
	// The description of the status.
	StatusDesc *string `json:"StatusDesc,omitempty" xml:"StatusDesc,omitempty"`
	// The ID of the approval process.
	WorkflowInstanceId *int64 `json:"WorkflowInstanceId,omitempty" xml:"WorkflowInstanceId,omitempty"`
	// The description of the approval process.
	WorkflowStatusDesc *string `json:"WorkflowStatusDesc,omitempty" xml:"WorkflowStatusDesc,omitempty"`
}

func (s GetOrderBaseInfoResponseBodyOrderBaseInfo) String() string {
	return tea.Prettify(s)
}

func (s GetOrderBaseInfoResponseBodyOrderBaseInfo) GoString() string {
	return s.String()
}

func (s *GetOrderBaseInfoResponseBodyOrderBaseInfo) SetAttachmentKey(v string) *GetOrderBaseInfoResponseBodyOrderBaseInfo {
	s.AttachmentKey = &v
	return s
}

func (s *GetOrderBaseInfoResponseBodyOrderBaseInfo) SetComment(v string) *GetOrderBaseInfoResponseBodyOrderBaseInfo {
	s.Comment = &v
	return s
}

func (s *GetOrderBaseInfoResponseBodyOrderBaseInfo) SetCommitter(v string) *GetOrderBaseInfoResponseBodyOrderBaseInfo {
	s.Committer = &v
	return s
}

func (s *GetOrderBaseInfoResponseBodyOrderBaseInfo) SetCommitterId(v int64) *GetOrderBaseInfoResponseBodyOrderBaseInfo {
	s.CommitterId = &v
	return s
}

func (s *GetOrderBaseInfoResponseBodyOrderBaseInfo) SetCreateTime(v string) *GetOrderBaseInfoResponseBodyOrderBaseInfo {
	s.CreateTime = &v
	return s
}

func (s *GetOrderBaseInfoResponseBodyOrderBaseInfo) SetLastModifyTime(v string) *GetOrderBaseInfoResponseBodyOrderBaseInfo {
	s.LastModifyTime = &v
	return s
}

func (s *GetOrderBaseInfoResponseBodyOrderBaseInfo) SetOrderId(v int64) *GetOrderBaseInfoResponseBodyOrderBaseInfo {
	s.OrderId = &v
	return s
}

func (s *GetOrderBaseInfoResponseBodyOrderBaseInfo) SetOriginAttachmentName(v string) *GetOrderBaseInfoResponseBodyOrderBaseInfo {
	s.OriginAttachmentName = &v
	return s
}

func (s *GetOrderBaseInfoResponseBodyOrderBaseInfo) SetPluginType(v string) *GetOrderBaseInfoResponseBodyOrderBaseInfo {
	s.PluginType = &v
	return s
}

func (s *GetOrderBaseInfoResponseBodyOrderBaseInfo) SetRelatedUserList(v *GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserList) *GetOrderBaseInfoResponseBodyOrderBaseInfo {
	s.RelatedUserList = v
	return s
}

func (s *GetOrderBaseInfoResponseBodyOrderBaseInfo) SetRelatedUserNickList(v *GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserNickList) *GetOrderBaseInfoResponseBodyOrderBaseInfo {
	s.RelatedUserNickList = v
	return s
}

func (s *GetOrderBaseInfoResponseBodyOrderBaseInfo) SetStatusCode(v string) *GetOrderBaseInfoResponseBodyOrderBaseInfo {
	s.StatusCode = &v
	return s
}

func (s *GetOrderBaseInfoResponseBodyOrderBaseInfo) SetStatusDesc(v string) *GetOrderBaseInfoResponseBodyOrderBaseInfo {
	s.StatusDesc = &v
	return s
}

func (s *GetOrderBaseInfoResponseBodyOrderBaseInfo) SetWorkflowInstanceId(v int64) *GetOrderBaseInfoResponseBodyOrderBaseInfo {
	s.WorkflowInstanceId = &v
	return s
}

func (s *GetOrderBaseInfoResponseBodyOrderBaseInfo) SetWorkflowStatusDesc(v string) *GetOrderBaseInfoResponseBodyOrderBaseInfo {
	s.WorkflowStatusDesc = &v
	return s
}

type GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserList struct {
	UserIds []*string `json:"UserIds,omitempty" xml:"UserIds,omitempty" type:"Repeated"`
}

func (s GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserList) String() string {
	return tea.Prettify(s)
}

func (s GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserList) GoString() string {
	return s.String()
}

func (s *GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserList) SetUserIds(v []*string) *GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserList {
	s.UserIds = v
	return s
}

type GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserNickList struct {
	UserNicks []*string `json:"UserNicks,omitempty" xml:"UserNicks,omitempty" type:"Repeated"`
}

func (s GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserNickList) String() string {
	return tea.Prettify(s)
}

func (s GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserNickList) GoString() string {
	return s.String()
}

func (s *GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserNickList) SetUserNicks(v []*string) *GetOrderBaseInfoResponseBodyOrderBaseInfoRelatedUserNickList {
	s.UserNicks = v
	return s
}

type GetOrderBaseInfoResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetOrderBaseInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetOrderBaseInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s GetOrderBaseInfoResponse) GoString() string {
	return s.String()
}

func (s *GetOrderBaseInfoResponse) SetHeaders(v map[string]*string) *GetOrderBaseInfoResponse {
	s.Headers = v
	return s
}

func (s *GetOrderBaseInfoResponse) SetStatusCode(v int32) *GetOrderBaseInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *GetOrderBaseInfoResponse) SetBody(v *GetOrderBaseInfoResponseBody) *GetOrderBaseInfoResponse {
	s.Body = v
	return s
}

type GetOwnerApplyOrderDetailRequest struct {
	// The ID of the ticket.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant.
	//
	// > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetOwnerApplyOrderDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetOwnerApplyOrderDetailRequest) GoString() string {
	return s.String()
}

func (s *GetOwnerApplyOrderDetailRequest) SetOrderId(v int64) *GetOwnerApplyOrderDetailRequest {
	s.OrderId = &v
	return s
}

func (s *GetOwnerApplyOrderDetailRequest) SetTid(v int64) *GetOwnerApplyOrderDetailRequest {
	s.Tid = &v
	return s
}

type GetOwnerApplyOrderDetailResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The details of the ticket.
	OwnerApplyOrderDetail *GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail `json:"OwnerApplyOrderDetail,omitempty" xml:"OwnerApplyOrderDetail,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetOwnerApplyOrderDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetOwnerApplyOrderDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetOwnerApplyOrderDetailResponseBody) SetErrorCode(v string) *GetOwnerApplyOrderDetailResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetOwnerApplyOrderDetailResponseBody) SetErrorMessage(v string) *GetOwnerApplyOrderDetailResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetOwnerApplyOrderDetailResponseBody) SetOwnerApplyOrderDetail(v *GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail) *GetOwnerApplyOrderDetailResponseBody {
	s.OwnerApplyOrderDetail = v
	return s
}

func (s *GetOwnerApplyOrderDetailResponseBody) SetRequestId(v string) *GetOwnerApplyOrderDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetOwnerApplyOrderDetailResponseBody) SetSuccess(v bool) *GetOwnerApplyOrderDetailResponseBody {
	s.Success = &v
	return s
}

type GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail struct {
	// The type of the submitted ticket. Valid values:
	//
	// *   **INSTANCE**: the ticket that applies for the permissions to be an instance owner
	// *   **DB**: the ticket that applies for the permissions to be a database owner
	// *   **TABLE**: the ticket that applies for the permissions to be a table owner
	ApplyType *string `json:"ApplyType,omitempty" xml:"ApplyType,omitempty"`
	// The details of the requested resource.
	Resources []*GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources `json:"Resources,omitempty" xml:"Resources,omitempty" type:"Repeated"`
}

func (s GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail) String() string {
	return tea.Prettify(s)
}

func (s GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail) GoString() string {
	return s.String()
}

func (s *GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail) SetApplyType(v string) *GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail {
	s.ApplyType = &v
	return s
}

func (s *GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail) SetResources(v []*GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources) *GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetail {
	s.Resources = v
	return s
}

type GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources struct {
	// Indicates whether the database is a logical database. Valid values:
	//
	// *   **true**: The instance is a logical database.
	// *   **false**: The instance is not a logical database.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The details of the resource.
	ResourceDetail *GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail `json:"ResourceDetail,omitempty" xml:"ResourceDetail,omitempty" type:"Struct"`
	// The ID of the resource.
	TargetId *string `json:"TargetId,omitempty" xml:"TargetId,omitempty"`
}

func (s GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources) String() string {
	return tea.Prettify(s)
}

func (s GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources) GoString() string {
	return s.String()
}

func (s *GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources) SetLogic(v bool) *GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources {
	s.Logic = &v
	return s
}

func (s *GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources) SetResourceDetail(v *GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail) *GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources {
	s.ResourceDetail = v
	return s
}

func (s *GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources) SetTargetId(v string) *GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResources {
	s.TargetId = &v
	return s
}

type GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail struct {
	// The type of the database engine.
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The type of the environment to which the instance belongs. For more information, see [Change the environment type of an instance](~~163309~~).
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The IDs of the original owners.
	OwnerIds []*int64 `json:"OwnerIds,omitempty" xml:"OwnerIds,omitempty" type:"Repeated"`
	// The nicknames of the owners.
	OwnerNickNames []*string `json:"OwnerNickNames,omitempty" xml:"OwnerNickNames,omitempty" type:"Repeated"`
	// The search name of the resource.
	SearchName *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
	// The name of the table.
	//
	// > : This parameter is returned when you submit a Database-OWNER ticket.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail) String() string {
	return tea.Prettify(s)
}

func (s GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail) GoString() string {
	return s.String()
}

func (s *GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail) SetDbType(v string) *GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail {
	s.DbType = &v
	return s
}

func (s *GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail) SetEnvType(v string) *GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail {
	s.EnvType = &v
	return s
}

func (s *GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail) SetOwnerIds(v []*int64) *GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail {
	s.OwnerIds = v
	return s
}

func (s *GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail) SetOwnerNickNames(v []*string) *GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail {
	s.OwnerNickNames = v
	return s
}

func (s *GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail) SetSearchName(v string) *GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail {
	s.SearchName = &v
	return s
}

func (s *GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail) SetTableName(v string) *GetOwnerApplyOrderDetailResponseBodyOwnerApplyOrderDetailResourcesResourceDetail {
	s.TableName = &v
	return s
}

type GetOwnerApplyOrderDetailResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetOwnerApplyOrderDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetOwnerApplyOrderDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetOwnerApplyOrderDetailResponse) GoString() string {
	return s.String()
}

func (s *GetOwnerApplyOrderDetailResponse) SetHeaders(v map[string]*string) *GetOwnerApplyOrderDetailResponse {
	s.Headers = v
	return s
}

func (s *GetOwnerApplyOrderDetailResponse) SetStatusCode(v int32) *GetOwnerApplyOrderDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetOwnerApplyOrderDetailResponse) SetBody(v *GetOwnerApplyOrderDetailResponseBody) *GetOwnerApplyOrderDetailResponse {
	s.Body = v
	return s
}

type GetPagedInstanceRequest struct {
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	Tid     *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetPagedInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s GetPagedInstanceRequest) GoString() string {
	return s.String()
}

func (s *GetPagedInstanceRequest) SetOrderId(v int64) *GetPagedInstanceRequest {
	s.OrderId = &v
	return s
}

func (s *GetPagedInstanceRequest) SetTid(v int64) *GetPagedInstanceRequest {
	s.Tid = &v
	return s
}

type GetPagedInstanceResponseBody struct {
	Data         *GetPagedInstanceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorCode    *string                           `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage *string                           `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	PageIndex    *int64                            `json:"PageIndex,omitempty" xml:"PageIndex,omitempty"`
	PageSize     *int64                            `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RequestId    *string                           `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                             `json:"Success,omitempty" xml:"Success,omitempty"`
	Total        *int64                            `json:"Total,omitempty" xml:"Total,omitempty"`
	// Id of the request
	TraceId *string `json:"TraceId,omitempty" xml:"TraceId,omitempty"`
}

func (s GetPagedInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetPagedInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *GetPagedInstanceResponseBody) SetData(v *GetPagedInstanceResponseBodyData) *GetPagedInstanceResponseBody {
	s.Data = v
	return s
}

func (s *GetPagedInstanceResponseBody) SetErrorCode(v string) *GetPagedInstanceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetPagedInstanceResponseBody) SetErrorMessage(v string) *GetPagedInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetPagedInstanceResponseBody) SetPageIndex(v int64) *GetPagedInstanceResponseBody {
	s.PageIndex = &v
	return s
}

func (s *GetPagedInstanceResponseBody) SetPageSize(v int64) *GetPagedInstanceResponseBody {
	s.PageSize = &v
	return s
}

func (s *GetPagedInstanceResponseBody) SetRequestId(v string) *GetPagedInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetPagedInstanceResponseBody) SetSuccess(v bool) *GetPagedInstanceResponseBody {
	s.Success = &v
	return s
}

func (s *GetPagedInstanceResponseBody) SetTotal(v int64) *GetPagedInstanceResponseBody {
	s.Total = &v
	return s
}

func (s *GetPagedInstanceResponseBody) SetTraceId(v string) *GetPagedInstanceResponseBody {
	s.TraceId = &v
	return s
}

type GetPagedInstanceResponseBodyData struct {
	Instance []*GetPagedInstanceResponseBodyDataInstance `json:"Instance,omitempty" xml:"Instance,omitempty" type:"Repeated"`
}

func (s GetPagedInstanceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetPagedInstanceResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetPagedInstanceResponseBodyData) SetInstance(v []*GetPagedInstanceResponseBodyDataInstance) *GetPagedInstanceResponseBodyData {
	s.Instance = v
	return s
}

type GetPagedInstanceResponseBodyDataInstance struct {
	BusinessTime       *string `json:"BusinessTime,omitempty" xml:"BusinessTime,omitempty"`
	CheckStatus        *int64  `json:"CheckStatus,omitempty" xml:"CheckStatus,omitempty"`
	DagId              *int64  `json:"DagId,omitempty" xml:"DagId,omitempty"`
	Delete             *string `json:"Delete,omitempty" xml:"Delete,omitempty"`
	EndTime            *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	GmtCreate          *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	GmtModified        *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	HistoryDagId       *int64  `json:"HistoryDagId,omitempty" xml:"HistoryDagId,omitempty"`
	Id                 *int64  `json:"Id,omitempty" xml:"Id,omitempty"`
	LastRunningContext *string `json:"LastRunningContext,omitempty" xml:"LastRunningContext,omitempty"`
	Msg                *string `json:"Msg,omitempty" xml:"Msg,omitempty"`
	Status             *int64  `json:"Status,omitempty" xml:"Status,omitempty"`
	TaskType           *int64  `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
	TenantId           *string `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
	TriggerType        *int64  `json:"TriggerType,omitempty" xml:"TriggerType,omitempty"`
	Version            *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s GetPagedInstanceResponseBodyDataInstance) String() string {
	return tea.Prettify(s)
}

func (s GetPagedInstanceResponseBodyDataInstance) GoString() string {
	return s.String()
}

func (s *GetPagedInstanceResponseBodyDataInstance) SetBusinessTime(v string) *GetPagedInstanceResponseBodyDataInstance {
	s.BusinessTime = &v
	return s
}

func (s *GetPagedInstanceResponseBodyDataInstance) SetCheckStatus(v int64) *GetPagedInstanceResponseBodyDataInstance {
	s.CheckStatus = &v
	return s
}

func (s *GetPagedInstanceResponseBodyDataInstance) SetDagId(v int64) *GetPagedInstanceResponseBodyDataInstance {
	s.DagId = &v
	return s
}

func (s *GetPagedInstanceResponseBodyDataInstance) SetDelete(v string) *GetPagedInstanceResponseBodyDataInstance {
	s.Delete = &v
	return s
}

func (s *GetPagedInstanceResponseBodyDataInstance) SetEndTime(v string) *GetPagedInstanceResponseBodyDataInstance {
	s.EndTime = &v
	return s
}

func (s *GetPagedInstanceResponseBodyDataInstance) SetGmtCreate(v string) *GetPagedInstanceResponseBodyDataInstance {
	s.GmtCreate = &v
	return s
}

func (s *GetPagedInstanceResponseBodyDataInstance) SetGmtModified(v string) *GetPagedInstanceResponseBodyDataInstance {
	s.GmtModified = &v
	return s
}

func (s *GetPagedInstanceResponseBodyDataInstance) SetHistoryDagId(v int64) *GetPagedInstanceResponseBodyDataInstance {
	s.HistoryDagId = &v
	return s
}

func (s *GetPagedInstanceResponseBodyDataInstance) SetId(v int64) *GetPagedInstanceResponseBodyDataInstance {
	s.Id = &v
	return s
}

func (s *GetPagedInstanceResponseBodyDataInstance) SetLastRunningContext(v string) *GetPagedInstanceResponseBodyDataInstance {
	s.LastRunningContext = &v
	return s
}

func (s *GetPagedInstanceResponseBodyDataInstance) SetMsg(v string) *GetPagedInstanceResponseBodyDataInstance {
	s.Msg = &v
	return s
}

func (s *GetPagedInstanceResponseBodyDataInstance) SetStatus(v int64) *GetPagedInstanceResponseBodyDataInstance {
	s.Status = &v
	return s
}

func (s *GetPagedInstanceResponseBodyDataInstance) SetTaskType(v int64) *GetPagedInstanceResponseBodyDataInstance {
	s.TaskType = &v
	return s
}

func (s *GetPagedInstanceResponseBodyDataInstance) SetTenantId(v string) *GetPagedInstanceResponseBodyDataInstance {
	s.TenantId = &v
	return s
}

func (s *GetPagedInstanceResponseBodyDataInstance) SetTriggerType(v int64) *GetPagedInstanceResponseBodyDataInstance {
	s.TriggerType = &v
	return s
}

func (s *GetPagedInstanceResponseBodyDataInstance) SetVersion(v string) *GetPagedInstanceResponseBodyDataInstance {
	s.Version = &v
	return s
}

type GetPagedInstanceResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetPagedInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetPagedInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s GetPagedInstanceResponse) GoString() string {
	return s.String()
}

func (s *GetPagedInstanceResponse) SetHeaders(v map[string]*string) *GetPagedInstanceResponse {
	s.Headers = v
	return s
}

func (s *GetPagedInstanceResponse) SetStatusCode(v int32) *GetPagedInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *GetPagedInstanceResponse) SetBody(v *GetPagedInstanceResponseBody) *GetPagedInstanceResponse {
	s.Body = v
	return s
}

type GetPermApplyOrderDetailRequest struct {
	// The ticket ID. You can call the [ListOrders](~~465867~~) operation to query the ticket ID.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The tenant ID.
	//
	// > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the [View information about the current tenant](~~181330~~) section of the "Manage DMS tenants" topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetPermApplyOrderDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetPermApplyOrderDetailRequest) GoString() string {
	return s.String()
}

func (s *GetPermApplyOrderDetailRequest) SetOrderId(v int64) *GetPermApplyOrderDetailRequest {
	s.OrderId = &v
	return s
}

func (s *GetPermApplyOrderDetailRequest) SetTid(v int64) *GetPermApplyOrderDetailRequest {
	s.Tid = &v
	return s
}

type GetPermApplyOrderDetailResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The details of the permission application ticket.
	PermApplyOrderDetail *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail `json:"PermApplyOrderDetail,omitempty" xml:"PermApplyOrderDetail,omitempty" type:"Struct"`
	// The request ID. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true
	// *   false
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetPermApplyOrderDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetPermApplyOrderDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetPermApplyOrderDetailResponseBody) SetErrorCode(v string) *GetPermApplyOrderDetailResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetPermApplyOrderDetailResponseBody) SetErrorMessage(v string) *GetPermApplyOrderDetailResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetPermApplyOrderDetailResponseBody) SetPermApplyOrderDetail(v *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail) *GetPermApplyOrderDetailResponseBody {
	s.PermApplyOrderDetail = v
	return s
}

func (s *GetPermApplyOrderDetailResponseBody) SetRequestId(v string) *GetPermApplyOrderDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetPermApplyOrderDetailResponseBody) SetSuccess(v bool) *GetPermApplyOrderDetailResponseBody {
	s.Success = &v
	return s
}

type GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail struct {
	// The type of objects on which you apply for permissions. Valid values:
	//
	// *   **DB**: database
	// *   **TAB**: table
	// *   **COL**: column
	// *   **INSTANT**: instance
	ApplyType *string `json:"ApplyType,omitempty" xml:"ApplyType,omitempty"`
	// The type of the permissions that you apply for. Valid values:
	//
	// *   **1**: the permissions to query information.
	// *   **2**: the permissions to export information.
	// *   **3**: the permissions to query and export information.
	// *   **4**: the permissions to modify information.
	// *   **5**: the permissions to query and modify information.
	// *   **6**: the permissions to export and modify information.
	// *   **7**: the permissions to query, export, and modify information.
	// *   **8**: the permissions to log on to the database.
	PermType *int64 `json:"PermType,omitempty" xml:"PermType,omitempty"`
	// The list of resources.
	Resources []*GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources `json:"Resources,omitempty" xml:"Resources,omitempty" type:"Repeated"`
	// The validity duration of the permissions. Unit: seconds.
	Seconds *int64 `json:"Seconds,omitempty" xml:"Seconds,omitempty"`
}

func (s GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail) String() string {
	return tea.Prettify(s)
}

func (s GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail) GoString() string {
	return s.String()
}

func (s *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail) SetApplyType(v string) *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail {
	s.ApplyType = &v
	return s
}

func (s *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail) SetPermType(v int64) *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail {
	s.PermType = &v
	return s
}

func (s *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail) SetResources(v []*GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources) *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail {
	s.Resources = v
	return s
}

func (s *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail) SetSeconds(v int64) *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetail {
	s.Seconds = &v
	return s
}

type GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources struct {
	// The information about the column.
	ColumnInfo *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo `json:"ColumnInfo,omitempty" xml:"ColumnInfo,omitempty" type:"Struct"`
	// The information about the database.
	DatabaseInfo *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo `json:"DatabaseInfo,omitempty" xml:"DatabaseInfo,omitempty" type:"Struct"`
	// The information about the instance.
	InstanceInfo *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo `json:"InstanceInfo,omitempty" xml:"InstanceInfo,omitempty" type:"Struct"`
	// The information about the table.
	TableInfo *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesTableInfo `json:"TableInfo,omitempty" xml:"TableInfo,omitempty" type:"Struct"`
}

func (s GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources) String() string {
	return tea.Prettify(s)
}

func (s GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources) GoString() string {
	return s.String()
}

func (s *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources) SetColumnInfo(v *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo) *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources {
	s.ColumnInfo = v
	return s
}

func (s *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources) SetDatabaseInfo(v *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo) *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources {
	s.DatabaseInfo = v
	return s
}

func (s *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources) SetInstanceInfo(v *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo) *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources {
	s.InstanceInfo = v
	return s
}

func (s *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources) SetTableInfo(v *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesTableInfo) *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResources {
	s.TableInfo = v
	return s
}

type GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo struct {
	// The name of the column.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The name of the table.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo) String() string {
	return tea.Prettify(s)
}

func (s GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo) GoString() string {
	return s.String()
}

func (s *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo) SetColumnName(v string) *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo {
	s.ColumnName = &v
	return s
}

func (s *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo) SetTableName(v string) *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesColumnInfo {
	s.TableName = &v
	return s
}

type GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo struct {
	// The database ID.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The type of the database engine.
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The type of the environment to which the instance belongs. For more information, see [Change the environment type of an instance](~~163309~~).
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// Indicates whether the database is a logical database. Valid values:
	//
	// *   **true**
	// *   **false**
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The IDs of the owners of the database.
	OwnerIds []*int64 `json:"OwnerIds,omitempty" xml:"OwnerIds,omitempty" type:"Repeated"`
	// The nicknames of the owners of the database.
	OwnerNickNames []*string `json:"OwnerNickNames,omitempty" xml:"OwnerNickNames,omitempty" type:"Repeated"`
	// The name that is used to search for the database.
	SearchName *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
}

func (s GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo) String() string {
	return tea.Prettify(s)
}

func (s GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo) GoString() string {
	return s.String()
}

func (s *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo) SetDbId(v int64) *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo {
	s.DbId = &v
	return s
}

func (s *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo) SetDbType(v string) *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo {
	s.DbType = &v
	return s
}

func (s *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo) SetEnvType(v string) *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo {
	s.EnvType = &v
	return s
}

func (s *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo) SetLogic(v bool) *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo {
	s.Logic = &v
	return s
}

func (s *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo) SetOwnerIds(v []*int64) *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo {
	s.OwnerIds = v
	return s
}

func (s *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo) SetOwnerNickNames(v []*string) *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo {
	s.OwnerNickNames = v
	return s
}

func (s *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo) SetSearchName(v string) *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesDatabaseInfo {
	s.SearchName = &v
	return s
}

type GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo struct {
	// The type of the database engine.
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The ID of the database administrator (DBA) of the instance.
	DbaId *int64 `json:"DbaId,omitempty" xml:"DbaId,omitempty"`
	// The nickname of the DBA of the instance.
	DbaNickName *string `json:"DbaNickName,omitempty" xml:"DbaNickName,omitempty"`
	// The type of the environment to which the instance belongs. For more information, see [Change the environment type of an instance](~~163309~~).
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The endpoint of the instance.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The IDs of the owners of the instance.
	OwnerIds []*int64 `json:"OwnerIds,omitempty" xml:"OwnerIds,omitempty" type:"Repeated"`
	// The nicknames of the owners of the instance.
	OwnerNickName []*string `json:"OwnerNickName,omitempty" xml:"OwnerNickName,omitempty" type:"Repeated"`
	// The port that is used to connect to the instance.
	Port *int64 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The name that is used to search for the instance.
	SearchName *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
}

func (s GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo) String() string {
	return tea.Prettify(s)
}

func (s GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo) GoString() string {
	return s.String()
}

func (s *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo) SetDbType(v string) *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo {
	s.DbType = &v
	return s
}

func (s *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo) SetDbaId(v int64) *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo {
	s.DbaId = &v
	return s
}

func (s *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo) SetDbaNickName(v string) *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo {
	s.DbaNickName = &v
	return s
}

func (s *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo) SetEnvType(v string) *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo {
	s.EnvType = &v
	return s
}

func (s *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo) SetHost(v string) *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo {
	s.Host = &v
	return s
}

func (s *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo) SetInstanceId(v string) *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo {
	s.InstanceId = &v
	return s
}

func (s *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo) SetOwnerIds(v []*int64) *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo {
	s.OwnerIds = v
	return s
}

func (s *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo) SetOwnerNickName(v []*string) *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo {
	s.OwnerNickName = v
	return s
}

func (s *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo) SetPort(v int64) *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo {
	s.Port = &v
	return s
}

func (s *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo) SetSearchName(v string) *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesInstanceInfo {
	s.SearchName = &v
	return s
}

type GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesTableInfo struct {
	// The name of the table.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesTableInfo) String() string {
	return tea.Prettify(s)
}

func (s GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesTableInfo) GoString() string {
	return s.String()
}

func (s *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesTableInfo) SetTableName(v string) *GetPermApplyOrderDetailResponseBodyPermApplyOrderDetailResourcesTableInfo {
	s.TableName = &v
	return s
}

type GetPermApplyOrderDetailResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetPermApplyOrderDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetPermApplyOrderDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetPermApplyOrderDetailResponse) GoString() string {
	return s.String()
}

func (s *GetPermApplyOrderDetailResponse) SetHeaders(v map[string]*string) *GetPermApplyOrderDetailResponse {
	s.Headers = v
	return s
}

func (s *GetPermApplyOrderDetailResponse) SetStatusCode(v int32) *GetPermApplyOrderDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetPermApplyOrderDetailResponse) SetBody(v *GetPermApplyOrderDetailResponseBody) *GetPermApplyOrderDetailResponse {
	s.Body = v
	return s
}

type GetPhysicalDatabaseRequest struct {
	// The ID of the physical database. You can call the [SearchDatabase](~~141876~~) operation to obtain the ID.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the ID of the tenant.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetPhysicalDatabaseRequest) String() string {
	return tea.Prettify(s)
}

func (s GetPhysicalDatabaseRequest) GoString() string {
	return s.String()
}

func (s *GetPhysicalDatabaseRequest) SetDbId(v int64) *GetPhysicalDatabaseRequest {
	s.DbId = &v
	return s
}

func (s *GetPhysicalDatabaseRequest) SetTid(v int64) *GetPhysicalDatabaseRequest {
	s.Tid = &v
	return s
}

type GetPhysicalDatabaseResponseBody struct {
	// The information about the physical database.
	Database *GetPhysicalDatabaseResponseBodyDatabase `json:"Database,omitempty" xml:"Database,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetPhysicalDatabaseResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetPhysicalDatabaseResponseBody) GoString() string {
	return s.String()
}

func (s *GetPhysicalDatabaseResponseBody) SetDatabase(v *GetPhysicalDatabaseResponseBodyDatabase) *GetPhysicalDatabaseResponseBody {
	s.Database = v
	return s
}

func (s *GetPhysicalDatabaseResponseBody) SetErrorCode(v string) *GetPhysicalDatabaseResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetPhysicalDatabaseResponseBody) SetErrorMessage(v string) *GetPhysicalDatabaseResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetPhysicalDatabaseResponseBody) SetRequestId(v string) *GetPhysicalDatabaseResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetPhysicalDatabaseResponseBody) SetSuccess(v bool) *GetPhysicalDatabaseResponseBody {
	s.Success = &v
	return s
}

type GetPhysicalDatabaseResponseBodyDatabase struct {
	// The name of the catalog to which the database belongs.
	//
	// > : If the database is a PostgreSQL database, the name of the database is displayed.
	CatalogName *string `json:"CatalogName,omitempty" xml:"CatalogName,omitempty"`
	// The ID of the physical database.
	DatabaseId *string `json:"DatabaseId,omitempty" xml:"DatabaseId,omitempty"`
	// The type of the database engine.
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The user ID of the DBA in the destination database.
	DbaId *string `json:"DbaId,omitempty" xml:"DbaId,omitempty"`
	// The nickname of the database administrator (DBA) in the destination database.
	DbaName *string `json:"DbaName,omitempty" xml:"DbaName,omitempty"`
	// The encoding format of the database.
	Encoding *string `json:"Encoding,omitempty" xml:"Encoding,omitempty"`
	// The type of the environment to which the database belongs. For more information, see [Change the environment type of an instance](~~163309~~).
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The endpoint that is used to connect to the database.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The alias of the database instance.
	InstanceAlias *string `json:"InstanceAlias,omitempty" xml:"InstanceAlias,omitempty"`
	// The instance ID of the destination database.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The user IDs of the database owners.
	OwnerIdList *GetPhysicalDatabaseResponseBodyDatabaseOwnerIdList `json:"OwnerIdList,omitempty" xml:"OwnerIdList,omitempty" type:"Struct"`
	// The nicknames of the database owners.
	OwnerNameList *GetPhysicalDatabaseResponseBodyDatabaseOwnerNameList `json:"OwnerNameList,omitempty" xml:"OwnerNameList,omitempty" type:"Struct"`
	// The port that is used to connect to the database.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The name of the database.
	//
	// > : If the database is a PostgreSQL database, the name of the mode is displayed.
	SchemaName *string `json:"SchemaName,omitempty" xml:"SchemaName,omitempty"`
	// The name that is used for searching the database.
	SearchName *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
	// The system ID (SID) of the database.
	//
	// > : The value of the parameter is returned only for Oracle databases.
	Sid *string `json:"Sid,omitempty" xml:"Sid,omitempty"`
	// The state of the database. Valid values:
	//
	// *   **NORMAL**: The database is normal.
	// *   **DISABLE**: The database is disabled.
	// *   **OFFLINE**: The database is unpublished.
	// *   **NOT_EXIST**: The database does not exist.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s GetPhysicalDatabaseResponseBodyDatabase) String() string {
	return tea.Prettify(s)
}

func (s GetPhysicalDatabaseResponseBodyDatabase) GoString() string {
	return s.String()
}

func (s *GetPhysicalDatabaseResponseBodyDatabase) SetCatalogName(v string) *GetPhysicalDatabaseResponseBodyDatabase {
	s.CatalogName = &v
	return s
}

func (s *GetPhysicalDatabaseResponseBodyDatabase) SetDatabaseId(v string) *GetPhysicalDatabaseResponseBodyDatabase {
	s.DatabaseId = &v
	return s
}

func (s *GetPhysicalDatabaseResponseBodyDatabase) SetDbType(v string) *GetPhysicalDatabaseResponseBodyDatabase {
	s.DbType = &v
	return s
}

func (s *GetPhysicalDatabaseResponseBodyDatabase) SetDbaId(v string) *GetPhysicalDatabaseResponseBodyDatabase {
	s.DbaId = &v
	return s
}

func (s *GetPhysicalDatabaseResponseBodyDatabase) SetDbaName(v string) *GetPhysicalDatabaseResponseBodyDatabase {
	s.DbaName = &v
	return s
}

func (s *GetPhysicalDatabaseResponseBodyDatabase) SetEncoding(v string) *GetPhysicalDatabaseResponseBodyDatabase {
	s.Encoding = &v
	return s
}

func (s *GetPhysicalDatabaseResponseBodyDatabase) SetEnvType(v string) *GetPhysicalDatabaseResponseBodyDatabase {
	s.EnvType = &v
	return s
}

func (s *GetPhysicalDatabaseResponseBodyDatabase) SetHost(v string) *GetPhysicalDatabaseResponseBodyDatabase {
	s.Host = &v
	return s
}

func (s *GetPhysicalDatabaseResponseBodyDatabase) SetInstanceAlias(v string) *GetPhysicalDatabaseResponseBodyDatabase {
	s.InstanceAlias = &v
	return s
}

func (s *GetPhysicalDatabaseResponseBodyDatabase) SetInstanceId(v string) *GetPhysicalDatabaseResponseBodyDatabase {
	s.InstanceId = &v
	return s
}

func (s *GetPhysicalDatabaseResponseBodyDatabase) SetOwnerIdList(v *GetPhysicalDatabaseResponseBodyDatabaseOwnerIdList) *GetPhysicalDatabaseResponseBodyDatabase {
	s.OwnerIdList = v
	return s
}

func (s *GetPhysicalDatabaseResponseBodyDatabase) SetOwnerNameList(v *GetPhysicalDatabaseResponseBodyDatabaseOwnerNameList) *GetPhysicalDatabaseResponseBodyDatabase {
	s.OwnerNameList = v
	return s
}

func (s *GetPhysicalDatabaseResponseBodyDatabase) SetPort(v int32) *GetPhysicalDatabaseResponseBodyDatabase {
	s.Port = &v
	return s
}

func (s *GetPhysicalDatabaseResponseBodyDatabase) SetSchemaName(v string) *GetPhysicalDatabaseResponseBodyDatabase {
	s.SchemaName = &v
	return s
}

func (s *GetPhysicalDatabaseResponseBodyDatabase) SetSearchName(v string) *GetPhysicalDatabaseResponseBodyDatabase {
	s.SearchName = &v
	return s
}

func (s *GetPhysicalDatabaseResponseBodyDatabase) SetSid(v string) *GetPhysicalDatabaseResponseBodyDatabase {
	s.Sid = &v
	return s
}

func (s *GetPhysicalDatabaseResponseBodyDatabase) SetState(v string) *GetPhysicalDatabaseResponseBodyDatabase {
	s.State = &v
	return s
}

type GetPhysicalDatabaseResponseBodyDatabaseOwnerIdList struct {
	OwnerIds []*string `json:"OwnerIds,omitempty" xml:"OwnerIds,omitempty" type:"Repeated"`
}

func (s GetPhysicalDatabaseResponseBodyDatabaseOwnerIdList) String() string {
	return tea.Prettify(s)
}

func (s GetPhysicalDatabaseResponseBodyDatabaseOwnerIdList) GoString() string {
	return s.String()
}

func (s *GetPhysicalDatabaseResponseBodyDatabaseOwnerIdList) SetOwnerIds(v []*string) *GetPhysicalDatabaseResponseBodyDatabaseOwnerIdList {
	s.OwnerIds = v
	return s
}

type GetPhysicalDatabaseResponseBodyDatabaseOwnerNameList struct {
	OwnerNames []*string `json:"OwnerNames,omitempty" xml:"OwnerNames,omitempty" type:"Repeated"`
}

func (s GetPhysicalDatabaseResponseBodyDatabaseOwnerNameList) String() string {
	return tea.Prettify(s)
}

func (s GetPhysicalDatabaseResponseBodyDatabaseOwnerNameList) GoString() string {
	return s.String()
}

func (s *GetPhysicalDatabaseResponseBodyDatabaseOwnerNameList) SetOwnerNames(v []*string) *GetPhysicalDatabaseResponseBodyDatabaseOwnerNameList {
	s.OwnerNames = v
	return s
}

type GetPhysicalDatabaseResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetPhysicalDatabaseResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetPhysicalDatabaseResponse) String() string {
	return tea.Prettify(s)
}

func (s GetPhysicalDatabaseResponse) GoString() string {
	return s.String()
}

func (s *GetPhysicalDatabaseResponse) SetHeaders(v map[string]*string) *GetPhysicalDatabaseResponse {
	s.Headers = v
	return s
}

func (s *GetPhysicalDatabaseResponse) SetStatusCode(v int32) *GetPhysicalDatabaseResponse {
	s.StatusCode = &v
	return s
}

func (s *GetPhysicalDatabaseResponse) SetBody(v *GetPhysicalDatabaseResponseBody) *GetPhysicalDatabaseResponse {
	s.Body = v
	return s
}

type GetProxyRequest struct {
	// The ID of the secure access proxy. You can call the [ListProxies](~~295371~~) operation to query the ID of the secure access proxy.
	ProxyId *int64 `json:"ProxyId,omitempty" xml:"ProxyId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetProxyRequest) String() string {
	return tea.Prettify(s)
}

func (s GetProxyRequest) GoString() string {
	return s.String()
}

func (s *GetProxyRequest) SetProxyId(v int64) *GetProxyRequest {
	s.ProxyId = &v
	return s
}

func (s *GetProxyRequest) SetTid(v int64) *GetProxyRequest {
	s.Tid = &v
	return s
}

type GetProxyResponseBody struct {
	// The ID of the user who enabled the secure access proxy feature.
	CreatorId *int64 `json:"CreatorId,omitempty" xml:"CreatorId,omitempty"`
	// The nickname of the user who enabled the secure access proxy feature.
	CreatorName *string `json:"CreatorName,omitempty" xml:"CreatorName,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The port number used by the HTTPS protocol.
	HttpsPort *int32 `json:"HttpsPort,omitempty" xml:"HttpsPort,omitempty"`
	// The ID of the instance.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// Indicates whether the internal endpoint was enabled. Default value: **true**.
	PrivateEnable *bool `json:"PrivateEnable,omitempty" xml:"PrivateEnable,omitempty"`
	// The internal endpoint.
	PrivateHost *string `json:"PrivateHost,omitempty" xml:"PrivateHost,omitempty"`
	// The port number used by the protocol.
	ProtocolPort *int32 `json:"ProtocolPort,omitempty" xml:"ProtocolPort,omitempty"`
	// The protocol type of the database. Example: MYSQL.
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The ID of the secure access proxy.
	ProxyId *int64 `json:"ProxyId,omitempty" xml:"ProxyId,omitempty"`
	// Indicates whether the public endpoint was enabled. Valid values:
	//
	// *   **true**: The public endpoint was enabled.
	// *   **false**: The public endpoint was disabled.
	PublicEnable *bool `json:"PublicEnable,omitempty" xml:"PublicEnable,omitempty"`
	// The public endpoint. A public endpoint is returned no matter whether the public endpoint is enabled or disabled.
	//
	// >
	//
	// *   If the value of the PublicEnable parameter is **true**, a valid public endpoint that can be resolved by using Alibaba Cloud DNS is returned.
	//
	// *   If the value of the PublicEnable parameter is **false**, an invalid public endpoint that cannot be resolved by using Alibaba Cloud DNS is returned.
	PublicHost *string `json:"PublicHost,omitempty" xml:"PublicHost,omitempty"`
	// The ID of the region in which the instance resides.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetProxyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetProxyResponseBody) GoString() string {
	return s.String()
}

func (s *GetProxyResponseBody) SetCreatorId(v int64) *GetProxyResponseBody {
	s.CreatorId = &v
	return s
}

func (s *GetProxyResponseBody) SetCreatorName(v string) *GetProxyResponseBody {
	s.CreatorName = &v
	return s
}

func (s *GetProxyResponseBody) SetErrorCode(v string) *GetProxyResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetProxyResponseBody) SetErrorMessage(v string) *GetProxyResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetProxyResponseBody) SetHttpsPort(v int32) *GetProxyResponseBody {
	s.HttpsPort = &v
	return s
}

func (s *GetProxyResponseBody) SetInstanceId(v int64) *GetProxyResponseBody {
	s.InstanceId = &v
	return s
}

func (s *GetProxyResponseBody) SetPrivateEnable(v bool) *GetProxyResponseBody {
	s.PrivateEnable = &v
	return s
}

func (s *GetProxyResponseBody) SetPrivateHost(v string) *GetProxyResponseBody {
	s.PrivateHost = &v
	return s
}

func (s *GetProxyResponseBody) SetProtocolPort(v int32) *GetProxyResponseBody {
	s.ProtocolPort = &v
	return s
}

func (s *GetProxyResponseBody) SetProtocolType(v string) *GetProxyResponseBody {
	s.ProtocolType = &v
	return s
}

func (s *GetProxyResponseBody) SetProxyId(v int64) *GetProxyResponseBody {
	s.ProxyId = &v
	return s
}

func (s *GetProxyResponseBody) SetPublicEnable(v bool) *GetProxyResponseBody {
	s.PublicEnable = &v
	return s
}

func (s *GetProxyResponseBody) SetPublicHost(v string) *GetProxyResponseBody {
	s.PublicHost = &v
	return s
}

func (s *GetProxyResponseBody) SetRegionId(v string) *GetProxyResponseBody {
	s.RegionId = &v
	return s
}

func (s *GetProxyResponseBody) SetRequestId(v string) *GetProxyResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetProxyResponseBody) SetSuccess(v bool) *GetProxyResponseBody {
	s.Success = &v
	return s
}

type GetProxyResponse struct {
	Headers    map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetProxyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetProxyResponse) String() string {
	return tea.Prettify(s)
}

func (s GetProxyResponse) GoString() string {
	return s.String()
}

func (s *GetProxyResponse) SetHeaders(v map[string]*string) *GetProxyResponse {
	s.Headers = v
	return s
}

func (s *GetProxyResponse) SetStatusCode(v int32) *GetProxyResponse {
	s.StatusCode = &v
	return s
}

func (s *GetProxyResponse) SetBody(v *GetProxyResponseBody) *GetProxyResponse {
	s.Body = v
	return s
}

type GetProxyAccessRequest struct {
	// The ID that Data Management (DMS) generates after the user is authorized to enable the secure access proxy feature for an instance. The ID is unique in DMS. You can call the [ListProxyAccesses](~~295386~~) operation to query the ID.
	ProxyAccessId *int64 `json:"ProxyAccessId,omitempty" xml:"ProxyAccessId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetProxyAccessRequest) String() string {
	return tea.Prettify(s)
}

func (s GetProxyAccessRequest) GoString() string {
	return s.String()
}

func (s *GetProxyAccessRequest) SetProxyAccessId(v int64) *GetProxyAccessRequest {
	s.ProxyAccessId = &v
	return s
}

func (s *GetProxyAccessRequest) SetTid(v int64) *GetProxyAccessRequest {
	s.Tid = &v
	return s
}

type GetProxyAccessResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The authorization information about the secure access proxy feature.
	ProxyAccess *GetProxyAccessResponseBodyProxyAccess `json:"ProxyAccess,omitempty" xml:"ProxyAccess,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetProxyAccessResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetProxyAccessResponseBody) GoString() string {
	return s.String()
}

func (s *GetProxyAccessResponseBody) SetErrorCode(v string) *GetProxyAccessResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetProxyAccessResponseBody) SetErrorMessage(v string) *GetProxyAccessResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetProxyAccessResponseBody) SetProxyAccess(v *GetProxyAccessResponseBodyProxyAccess) *GetProxyAccessResponseBody {
	s.ProxyAccess = v
	return s
}

func (s *GetProxyAccessResponseBody) SetRequestId(v string) *GetProxyAccessResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetProxyAccessResponseBody) SetSuccess(v bool) *GetProxyAccessResponseBody {
	s.Success = &v
	return s
}

type GetProxyAccessResponseBodyProxyAccess struct {
	// The username of the database account that is authorized to enable the secure access proxy feature for an instance.
	AccessId *string `json:"AccessId,omitempty" xml:"AccessId,omitempty"`
	// The time when the user is authorized to enable the secure access proxy feature for an instance.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The username of the independent database account.
	IndepAccount *string `json:"IndepAccount,omitempty" xml:"IndepAccount,omitempty"`
	// The ID of the instance for which the secure access proxy feature is enabled.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The method that is used to authorize the user to enable the secure access proxy feature for an instance. Valid values:
	//
	// *   **Authorization by the Alibaba Cloud Account ()**: The information in the parentheses () indicates the ID of the Alibaba Cloud account.
	// *   **Authorization by submitting the ticket ()**:The information in the parentheses () indicates the number of the ticket that the user submits to apply for permissions.
	OriginInfo *string `json:"OriginInfo,omitempty" xml:"OriginInfo,omitempty"`
	// The ID that DMS generates after the user is authorized to enable the secure access proxy feature for an instance. The ID is unique in DMS. You can call the [ListProxyAccesses](~~295386~~) operation to query the ID.
	ProxyAccessId *int64 `json:"ProxyAccessId,omitempty" xml:"ProxyAccessId,omitempty"`
	// The ID of the secure access proxy.
	//
	// >  You can call the [ListProxies](~~295371~~) operation to query the ID of the secure access proxy.
	ProxyId *int64 `json:"ProxyId,omitempty" xml:"ProxyId,omitempty"`
	// The ID of the user.
	UserId *int64 `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The nickname of the user.
	UserName *string `json:"UserName,omitempty" xml:"UserName,omitempty"`
	// The ID of the Alibaba Cloud account.
	UserUid *string `json:"UserUid,omitempty" xml:"UserUid,omitempty"`
}

func (s GetProxyAccessResponseBodyProxyAccess) String() string {
	return tea.Prettify(s)
}

func (s GetProxyAccessResponseBodyProxyAccess) GoString() string {
	return s.String()
}

func (s *GetProxyAccessResponseBodyProxyAccess) SetAccessId(v string) *GetProxyAccessResponseBodyProxyAccess {
	s.AccessId = &v
	return s
}

func (s *GetProxyAccessResponseBodyProxyAccess) SetGmtCreate(v string) *GetProxyAccessResponseBodyProxyAccess {
	s.GmtCreate = &v
	return s
}

func (s *GetProxyAccessResponseBodyProxyAccess) SetIndepAccount(v string) *GetProxyAccessResponseBodyProxyAccess {
	s.IndepAccount = &v
	return s
}

func (s *GetProxyAccessResponseBodyProxyAccess) SetInstanceId(v int64) *GetProxyAccessResponseBodyProxyAccess {
	s.InstanceId = &v
	return s
}

func (s *GetProxyAccessResponseBodyProxyAccess) SetOriginInfo(v string) *GetProxyAccessResponseBodyProxyAccess {
	s.OriginInfo = &v
	return s
}

func (s *GetProxyAccessResponseBodyProxyAccess) SetProxyAccessId(v int64) *GetProxyAccessResponseBodyProxyAccess {
	s.ProxyAccessId = &v
	return s
}

func (s *GetProxyAccessResponseBodyProxyAccess) SetProxyId(v int64) *GetProxyAccessResponseBodyProxyAccess {
	s.ProxyId = &v
	return s
}

func (s *GetProxyAccessResponseBodyProxyAccess) SetUserId(v int64) *GetProxyAccessResponseBodyProxyAccess {
	s.UserId = &v
	return s
}

func (s *GetProxyAccessResponseBodyProxyAccess) SetUserName(v string) *GetProxyAccessResponseBodyProxyAccess {
	s.UserName = &v
	return s
}

func (s *GetProxyAccessResponseBodyProxyAccess) SetUserUid(v string) *GetProxyAccessResponseBodyProxyAccess {
	s.UserUid = &v
	return s
}

type GetProxyAccessResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetProxyAccessResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetProxyAccessResponse) String() string {
	return tea.Prettify(s)
}

func (s GetProxyAccessResponse) GoString() string {
	return s.String()
}

func (s *GetProxyAccessResponse) SetHeaders(v map[string]*string) *GetProxyAccessResponse {
	s.Headers = v
	return s
}

func (s *GetProxyAccessResponse) SetStatusCode(v int32) *GetProxyAccessResponse {
	s.StatusCode = &v
	return s
}

func (s *GetProxyAccessResponse) SetBody(v *GetProxyAccessResponseBody) *GetProxyAccessResponse {
	s.Body = v
	return s
}

type GetRuleNumLimitOfSLARequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the tenant.
	//
	// >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetRuleNumLimitOfSLARequest) String() string {
	return tea.Prettify(s)
}

func (s GetRuleNumLimitOfSLARequest) GoString() string {
	return s.String()
}

func (s *GetRuleNumLimitOfSLARequest) SetDagId(v int64) *GetRuleNumLimitOfSLARequest {
	s.DagId = &v
	return s
}

func (s *GetRuleNumLimitOfSLARequest) SetTid(v int64) *GetRuleNumLimitOfSLARequest {
	s.Tid = &v
	return s
}

type GetRuleNumLimitOfSLAResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can use the ID to locate logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The maximum number of SLA rules.
	RuleNumLimit *int32 `json:"RuleNumLimit,omitempty" xml:"RuleNumLimit,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetRuleNumLimitOfSLAResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetRuleNumLimitOfSLAResponseBody) GoString() string {
	return s.String()
}

func (s *GetRuleNumLimitOfSLAResponseBody) SetErrorCode(v string) *GetRuleNumLimitOfSLAResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetRuleNumLimitOfSLAResponseBody) SetErrorMessage(v string) *GetRuleNumLimitOfSLAResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetRuleNumLimitOfSLAResponseBody) SetRequestId(v string) *GetRuleNumLimitOfSLAResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetRuleNumLimitOfSLAResponseBody) SetRuleNumLimit(v int32) *GetRuleNumLimitOfSLAResponseBody {
	s.RuleNumLimit = &v
	return s
}

func (s *GetRuleNumLimitOfSLAResponseBody) SetSuccess(v bool) *GetRuleNumLimitOfSLAResponseBody {
	s.Success = &v
	return s
}

type GetRuleNumLimitOfSLAResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetRuleNumLimitOfSLAResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetRuleNumLimitOfSLAResponse) String() string {
	return tea.Prettify(s)
}

func (s GetRuleNumLimitOfSLAResponse) GoString() string {
	return s.String()
}

func (s *GetRuleNumLimitOfSLAResponse) SetHeaders(v map[string]*string) *GetRuleNumLimitOfSLAResponse {
	s.Headers = v
	return s
}

func (s *GetRuleNumLimitOfSLAResponse) SetStatusCode(v int32) *GetRuleNumLimitOfSLAResponse {
	s.StatusCode = &v
	return s
}

func (s *GetRuleNumLimitOfSLAResponse) SetBody(v *GetRuleNumLimitOfSLAResponseBody) *GetRuleNumLimitOfSLAResponse {
	s.Body = v
	return s
}

type GetSQLReviewCheckResultStatusRequest struct {
	// The ID of the ticket. You can obtain the ticket ID from the response parameters of the [CreateSQLReviewOrder](~~257777~~) operation.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the ID of the tenant.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetSQLReviewCheckResultStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s GetSQLReviewCheckResultStatusRequest) GoString() string {
	return s.String()
}

func (s *GetSQLReviewCheckResultStatusRequest) SetOrderId(v int64) *GetSQLReviewCheckResultStatusRequest {
	s.OrderId = &v
	return s
}

func (s *GetSQLReviewCheckResultStatusRequest) SetTid(v int64) *GetSQLReviewCheckResultStatusRequest {
	s.Tid = &v
	return s
}

type GetSQLReviewCheckResultStatusResponseBody struct {
	// The result of the SQL review.
	CheckResultStatus *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus `json:"CheckResultStatus,omitempty" xml:"CheckResultStatus,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetSQLReviewCheckResultStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetSQLReviewCheckResultStatusResponseBody) GoString() string {
	return s.String()
}

func (s *GetSQLReviewCheckResultStatusResponseBody) SetCheckResultStatus(v *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus) *GetSQLReviewCheckResultStatusResponseBody {
	s.CheckResultStatus = v
	return s
}

func (s *GetSQLReviewCheckResultStatusResponseBody) SetErrorCode(v string) *GetSQLReviewCheckResultStatusResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetSQLReviewCheckResultStatusResponseBody) SetErrorMessage(v string) *GetSQLReviewCheckResultStatusResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetSQLReviewCheckResultStatusResponseBody) SetRequestId(v string) *GetSQLReviewCheckResultStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetSQLReviewCheckResultStatusResponseBody) SetSuccess(v bool) *GetSQLReviewCheckResultStatusResponseBody {
	s.Success = &v
	return s
}

type GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus struct {
	// The result of the SQL status check.
	CheckStatusResult *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult `json:"CheckStatusResult,omitempty" xml:"CheckStatusResult,omitempty" type:"Struct"`
	// The number of SQL statements that were reviewed.
	CheckedCount *int64 `json:"CheckedCount,omitempty" xml:"CheckedCount,omitempty"`
	// The optimization suggestion for SQL statements.
	SQLReviewResult *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult `json:"SQLReviewResult,omitempty" xml:"SQLReviewResult,omitempty" type:"Struct"`
	// The total number of SQL statements.
	TotalSQLCount *int64 `json:"TotalSQLCount,omitempty" xml:"TotalSQLCount,omitempty"`
}

func (s GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus) String() string {
	return tea.Prettify(s)
}

func (s GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus) GoString() string {
	return s.String()
}

func (s *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus) SetCheckStatusResult(v *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult) *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus {
	s.CheckStatusResult = v
	return s
}

func (s *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus) SetCheckedCount(v int64) *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus {
	s.CheckedCount = &v
	return s
}

func (s *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus) SetSQLReviewResult(v *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult) *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus {
	s.SQLReviewResult = v
	return s
}

func (s *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus) SetTotalSQLCount(v int64) *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatus {
	s.TotalSQLCount = &v
	return s
}

type GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult struct {
	// The number of SQL statements that failed to pass the review.
	CheckNotPass *int64 `json:"CheckNotPass,omitempty" xml:"CheckNotPass,omitempty"`
	// The number of SQL statements that passed the review.
	CheckPass *int64 `json:"CheckPass,omitempty" xml:"CheckPass,omitempty"`
	// The number of SQL statements that failed to pass the manual review.
	ForceNotPass *int64 `json:"ForceNotPass,omitempty" xml:"ForceNotPass,omitempty"`
	// The number of SQL statements that passed the manual review.
	ForcePass *int64 `json:"ForcePass,omitempty" xml:"ForcePass,omitempty"`
	// The number of SQL statements to be reviewed.
	New *int64 `json:"New,omitempty" xml:"New,omitempty"`
	// The number of abnormal SQL statements.
	Unknown *int64 `json:"Unknown,omitempty" xml:"Unknown,omitempty"`
}

func (s GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult) String() string {
	return tea.Prettify(s)
}

func (s GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult) GoString() string {
	return s.String()
}

func (s *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult) SetCheckNotPass(v int64) *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult {
	s.CheckNotPass = &v
	return s
}

func (s *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult) SetCheckPass(v int64) *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult {
	s.CheckPass = &v
	return s
}

func (s *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult) SetForceNotPass(v int64) *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult {
	s.ForceNotPass = &v
	return s
}

func (s *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult) SetForcePass(v int64) *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult {
	s.ForcePass = &v
	return s
}

func (s *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult) SetNew(v int64) *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult {
	s.New = &v
	return s
}

func (s *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult) SetUnknown(v int64) *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusCheckStatusResult {
	s.Unknown = &v
	return s
}

type GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult struct {
	// The number of SQL statements that must be modified.
	MustImprove *int64 `json:"MustImprove,omitempty" xml:"MustImprove,omitempty"`
	// The number of SQL statements that have potential issues.
	PotentialIssue *int64 `json:"PotentialIssue,omitempty" xml:"PotentialIssue,omitempty"`
	// The number of SQL statements that can be modified.
	SuggestImprove *int64 `json:"SuggestImprove,omitempty" xml:"SuggestImprove,omitempty"`
	// The number of SQL statements that can use indexes.
	TableIndexSuggest *int64 `json:"TableIndexSuggest,omitempty" xml:"TableIndexSuggest,omitempty"`
	// The number of SQL statements that can be used for lock-free data changes.
	UseDmsDmlUnlock *int64 `json:"UseDmsDmlUnlock,omitempty" xml:"UseDmsDmlUnlock,omitempty"`
	// The number of SQL statements that can be used for lock-free schema changes.
	UseDmsToolkit *int64 `json:"UseDmsToolkit,omitempty" xml:"UseDmsToolkit,omitempty"`
}

func (s GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult) String() string {
	return tea.Prettify(s)
}

func (s GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult) GoString() string {
	return s.String()
}

func (s *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult) SetMustImprove(v int64) *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult {
	s.MustImprove = &v
	return s
}

func (s *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult) SetPotentialIssue(v int64) *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult {
	s.PotentialIssue = &v
	return s
}

func (s *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult) SetSuggestImprove(v int64) *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult {
	s.SuggestImprove = &v
	return s
}

func (s *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult) SetTableIndexSuggest(v int64) *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult {
	s.TableIndexSuggest = &v
	return s
}

func (s *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult) SetUseDmsDmlUnlock(v int64) *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult {
	s.UseDmsDmlUnlock = &v
	return s
}

func (s *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult) SetUseDmsToolkit(v int64) *GetSQLReviewCheckResultStatusResponseBodyCheckResultStatusSQLReviewResult {
	s.UseDmsToolkit = &v
	return s
}

type GetSQLReviewCheckResultStatusResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetSQLReviewCheckResultStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetSQLReviewCheckResultStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s GetSQLReviewCheckResultStatusResponse) GoString() string {
	return s.String()
}

func (s *GetSQLReviewCheckResultStatusResponse) SetHeaders(v map[string]*string) *GetSQLReviewCheckResultStatusResponse {
	s.Headers = v
	return s
}

func (s *GetSQLReviewCheckResultStatusResponse) SetStatusCode(v int32) *GetSQLReviewCheckResultStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *GetSQLReviewCheckResultStatusResponse) SetBody(v *GetSQLReviewCheckResultStatusResponseBody) *GetSQLReviewCheckResultStatusResponse {
	s.Body = v
	return s
}

type GetSQLReviewOptimizeDetailRequest struct {
	// The key that is used to query the details of optimization suggestions. You can call the [ListSQLReviewOriginSQL](~~257870~~) operation to query the key.
	SQLReviewQueryKey *string `json:"SQLReviewQueryKey,omitempty" xml:"SQLReviewQueryKey,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the ID of the tenant.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetSQLReviewOptimizeDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetSQLReviewOptimizeDetailRequest) GoString() string {
	return s.String()
}

func (s *GetSQLReviewOptimizeDetailRequest) SetSQLReviewQueryKey(v string) *GetSQLReviewOptimizeDetailRequest {
	s.SQLReviewQueryKey = &v
	return s
}

func (s *GetSQLReviewOptimizeDetailRequest) SetTid(v int64) *GetSQLReviewOptimizeDetailRequest {
	s.Tid = &v
	return s
}

type GetSQLReviewOptimizeDetailResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The details of optimization suggestions for SQL statements.
	OptimizeDetail *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail `json:"OptimizeDetail,omitempty" xml:"OptimizeDetail,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetSQLReviewOptimizeDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetSQLReviewOptimizeDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetSQLReviewOptimizeDetailResponseBody) SetErrorCode(v string) *GetSQLReviewOptimizeDetailResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetSQLReviewOptimizeDetailResponseBody) SetErrorMessage(v string) *GetSQLReviewOptimizeDetailResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetSQLReviewOptimizeDetailResponseBody) SetOptimizeDetail(v *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail) *GetSQLReviewOptimizeDetailResponseBody {
	s.OptimizeDetail = v
	return s
}

func (s *GetSQLReviewOptimizeDetailResponseBody) SetRequestId(v string) *GetSQLReviewOptimizeDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetSQLReviewOptimizeDetailResponseBody) SetSuccess(v bool) *GetSQLReviewOptimizeDetailResponseBody {
	s.Success = &v
	return s
}

type GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail struct {
	// The ID of the database.
	DbId *int32 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The ID of the instance to which the database belongs.
	InstanceId *int32 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The quality of the SQL statement.
	QualityResult *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult `json:"QualityResult,omitempty" xml:"QualityResult,omitempty" type:"Struct"`
	// The key that is used to query the details of optimization suggestions.
	QueryKey *string `json:"QueryKey,omitempty" xml:"QueryKey,omitempty"`
	// The type of the SQL statement. Valid values: DELETE, UPDATE, and ALTER_TABLE.
	SqlType *string `json:"SqlType,omitempty" xml:"SqlType,omitempty"`
}

func (s GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail) String() string {
	return tea.Prettify(s)
}

func (s GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail) GoString() string {
	return s.String()
}

func (s *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail) SetDbId(v int32) *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail {
	s.DbId = &v
	return s
}

func (s *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail) SetInstanceId(v int32) *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail {
	s.InstanceId = &v
	return s
}

func (s *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail) SetQualityResult(v *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult) *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail {
	s.QualityResult = v
	return s
}

func (s *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail) SetQueryKey(v string) *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail {
	s.QueryKey = &v
	return s
}

func (s *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail) SetSqlType(v string) *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetail {
	s.SqlType = &v
	return s
}

type GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult struct {
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// Indicates whether an error occurs. Valid values:
	//
	// *   **true**: An error occurs.
	// *   **false**: No error occurs.
	OccurError *bool `json:"OccurError,omitempty" xml:"OccurError,omitempty"`
	// The review results based on rules.
	Results []*GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults `json:"Results,omitempty" xml:"Results,omitempty" type:"Repeated"`
}

func (s GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult) String() string {
	return tea.Prettify(s)
}

func (s GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult) GoString() string {
	return s.String()
}

func (s *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult) SetErrorMessage(v string) *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult {
	s.ErrorMessage = &v
	return s
}

func (s *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult) SetOccurError(v bool) *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult {
	s.OccurError = &v
	return s
}

func (s *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult) SetResults(v []*GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults) *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResult {
	s.Results = v
	return s
}

type GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults struct {
	// The comment that is specified when you create the SQL review rule. For more information, see [SQL review optimization](~~194114~~).
	Comments *string `json:"Comments,omitempty" xml:"Comments,omitempty"`
	// The optimization suggestion for the SQL statement. Valid values:
	//
	// *   **MUST_IMPROVE**: The SQL statement must be improved.
	// *   **POTENTIAL_ISSUE**: The SQL statement contains potential issues.
	// *   **SUGGEST_IMPROVE**: We recommend that you improve the SQL statement.
	// *   **USEDMSTOOLKIT**: We recommend that you change schemas without locking tables.
	// *   **USEDMSDML_UNLOCK**: We recommend that you change data without locking tables.
	// *   **TABLEINDEXSUGGEST**: We recommend that you use SQL statements that use indexes.
	Feedback *string `json:"Feedback,omitempty" xml:"Feedback,omitempty"`
	// The review results.
	Messages []*string `json:"Messages,omitempty" xml:"Messages,omitempty" type:"Repeated"`
	// The name of the rule. For more information, see [SQL review optimization](~~194114~~).
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	// The type of the SQL review rule. Valid values:
	//
	// *   **REVIEW**: a rule that is used to review SQL statements based on standards.
	// *   **OPTIMIZE**: a rule that is used to provide optimization suggestions.
	RuleType *string `json:"RuleType,omitempty" xml:"RuleType,omitempty"`
	// The SQL script for data changes.
	Scripts []*GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts `json:"Scripts,omitempty" xml:"Scripts,omitempty" type:"Repeated"`
}

func (s GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults) String() string {
	return tea.Prettify(s)
}

func (s GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults) GoString() string {
	return s.String()
}

func (s *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults) SetComments(v string) *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults {
	s.Comments = &v
	return s
}

func (s *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults) SetFeedback(v string) *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults {
	s.Feedback = &v
	return s
}

func (s *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults) SetMessages(v []*string) *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults {
	s.Messages = v
	return s
}

func (s *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults) SetRuleName(v string) *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults {
	s.RuleName = &v
	return s
}

func (s *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults) SetRuleType(v string) *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults {
	s.RuleType = &v
	return s
}

func (s *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults) SetScripts(v []*GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts) *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResults {
	s.Scripts = v
	return s
}

type GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts struct {
	// The content of the SQL script.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The purpose of the SQL script. The value is set to AddIndex.
	OpType *string `json:"OpType,omitempty" xml:"OpType,omitempty"`
	// The name of the table.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts) String() string {
	return tea.Prettify(s)
}

func (s GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts) GoString() string {
	return s.String()
}

func (s *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts) SetContent(v string) *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts {
	s.Content = &v
	return s
}

func (s *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts) SetOpType(v string) *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts {
	s.OpType = &v
	return s
}

func (s *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts) SetTableName(v string) *GetSQLReviewOptimizeDetailResponseBodyOptimizeDetailQualityResultResultsScripts {
	s.TableName = &v
	return s
}

type GetSQLReviewOptimizeDetailResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetSQLReviewOptimizeDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetSQLReviewOptimizeDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetSQLReviewOptimizeDetailResponse) GoString() string {
	return s.String()
}

func (s *GetSQLReviewOptimizeDetailResponse) SetHeaders(v map[string]*string) *GetSQLReviewOptimizeDetailResponse {
	s.Headers = v
	return s
}

func (s *GetSQLReviewOptimizeDetailResponse) SetStatusCode(v int32) *GetSQLReviewOptimizeDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetSQLReviewOptimizeDetailResponse) SetBody(v *GetSQLReviewOptimizeDetailResponseBody) *GetSQLReviewOptimizeDetailResponse {
	s.Body = v
	return s
}

type GetStandardGroupRequest struct {
	GroupId *int64 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	Tid     *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetStandardGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s GetStandardGroupRequest) GoString() string {
	return s.String()
}

func (s *GetStandardGroupRequest) SetGroupId(v int64) *GetStandardGroupRequest {
	s.GroupId = &v
	return s
}

func (s *GetStandardGroupRequest) SetTid(v int64) *GetStandardGroupRequest {
	s.Tid = &v
	return s
}

type GetStandardGroupResponseBody struct {
	ErrorCode     *string                                    `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage  *string                                    `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId     *string                                    `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	StandardGroup *GetStandardGroupResponseBodyStandardGroup `json:"StandardGroup,omitempty" xml:"StandardGroup,omitempty" type:"Struct"`
	Success       *bool                                      `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetStandardGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetStandardGroupResponseBody) GoString() string {
	return s.String()
}

func (s *GetStandardGroupResponseBody) SetErrorCode(v string) *GetStandardGroupResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetStandardGroupResponseBody) SetErrorMessage(v string) *GetStandardGroupResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetStandardGroupResponseBody) SetRequestId(v string) *GetStandardGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetStandardGroupResponseBody) SetStandardGroup(v *GetStandardGroupResponseBodyStandardGroup) *GetStandardGroupResponseBody {
	s.StandardGroup = v
	return s
}

func (s *GetStandardGroupResponseBody) SetSuccess(v bool) *GetStandardGroupResponseBody {
	s.Success = &v
	return s
}

type GetStandardGroupResponseBodyStandardGroup struct {
	DbType       *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	Description  *string `json:"Description,omitempty" xml:"Description,omitempty"`
	GroupId      *int64  `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	GroupMode    *string `json:"GroupMode,omitempty" xml:"GroupMode,omitempty"`
	GroupName    *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	LastMenderId *int64  `json:"LastMenderId,omitempty" xml:"LastMenderId,omitempty"`
}

func (s GetStandardGroupResponseBodyStandardGroup) String() string {
	return tea.Prettify(s)
}

func (s GetStandardGroupResponseBodyStandardGroup) GoString() string {
	return s.String()
}

func (s *GetStandardGroupResponseBodyStandardGroup) SetDbType(v string) *GetStandardGroupResponseBodyStandardGroup {
	s.DbType = &v
	return s
}

func (s *GetStandardGroupResponseBodyStandardGroup) SetDescription(v string) *GetStandardGroupResponseBodyStandardGroup {
	s.Description = &v
	return s
}

func (s *GetStandardGroupResponseBodyStandardGroup) SetGroupId(v int64) *GetStandardGroupResponseBodyStandardGroup {
	s.GroupId = &v
	return s
}

func (s *GetStandardGroupResponseBodyStandardGroup) SetGroupMode(v string) *GetStandardGroupResponseBodyStandardGroup {
	s.GroupMode = &v
	return s
}

func (s *GetStandardGroupResponseBodyStandardGroup) SetGroupName(v string) *GetStandardGroupResponseBodyStandardGroup {
	s.GroupName = &v
	return s
}

func (s *GetStandardGroupResponseBodyStandardGroup) SetLastMenderId(v int64) *GetStandardGroupResponseBodyStandardGroup {
	s.LastMenderId = &v
	return s
}

type GetStandardGroupResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetStandardGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetStandardGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s GetStandardGroupResponse) GoString() string {
	return s.String()
}

func (s *GetStandardGroupResponse) SetHeaders(v map[string]*string) *GetStandardGroupResponse {
	s.Headers = v
	return s
}

func (s *GetStandardGroupResponse) SetStatusCode(v int32) *GetStandardGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *GetStandardGroupResponse) SetBody(v *GetStandardGroupResponseBody) *GetStandardGroupResponse {
	s.Body = v
	return s
}

type GetStructSyncExecSqlDetailRequest struct {
	// The ID of the ticket.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The number of the page to return.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the tenant.
	//
	// > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetStructSyncExecSqlDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetStructSyncExecSqlDetailRequest) GoString() string {
	return s.String()
}

func (s *GetStructSyncExecSqlDetailRequest) SetOrderId(v int64) *GetStructSyncExecSqlDetailRequest {
	s.OrderId = &v
	return s
}

func (s *GetStructSyncExecSqlDetailRequest) SetPageNumber(v int64) *GetStructSyncExecSqlDetailRequest {
	s.PageNumber = &v
	return s
}

func (s *GetStructSyncExecSqlDetailRequest) SetPageSize(v int64) *GetStructSyncExecSqlDetailRequest {
	s.PageSize = &v
	return s
}

func (s *GetStructSyncExecSqlDetailRequest) SetTid(v int64) *GetStructSyncExecSqlDetailRequest {
	s.Tid = &v
	return s
}

type GetStructSyncExecSqlDetailResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The details of the SQL statements.
	StructSyncExecSqlDetail *GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail `json:"StructSyncExecSqlDetail,omitempty" xml:"StructSyncExecSqlDetail,omitempty" type:"Struct"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetStructSyncExecSqlDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetStructSyncExecSqlDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetStructSyncExecSqlDetailResponseBody) SetErrorCode(v string) *GetStructSyncExecSqlDetailResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetStructSyncExecSqlDetailResponseBody) SetErrorMessage(v string) *GetStructSyncExecSqlDetailResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetStructSyncExecSqlDetailResponseBody) SetRequestId(v string) *GetStructSyncExecSqlDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetStructSyncExecSqlDetailResponseBody) SetStructSyncExecSqlDetail(v *GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail) *GetStructSyncExecSqlDetailResponseBody {
	s.StructSyncExecSqlDetail = v
	return s
}

func (s *GetStructSyncExecSqlDetailResponseBody) SetSuccess(v bool) *GetStructSyncExecSqlDetailResponseBody {
	s.Success = &v
	return s
}

type GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail struct {
	// The SQL statements that are executed.
	ExecSql *string `json:"ExecSql,omitempty" xml:"ExecSql,omitempty"`
	// The total number of SQL statements.
	TotalSqlCount *int64 `json:"TotalSqlCount,omitempty" xml:"TotalSqlCount,omitempty"`
}

func (s GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail) String() string {
	return tea.Prettify(s)
}

func (s GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail) GoString() string {
	return s.String()
}

func (s *GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail) SetExecSql(v string) *GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail {
	s.ExecSql = &v
	return s
}

func (s *GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail) SetTotalSqlCount(v int64) *GetStructSyncExecSqlDetailResponseBodyStructSyncExecSqlDetail {
	s.TotalSqlCount = &v
	return s
}

type GetStructSyncExecSqlDetailResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetStructSyncExecSqlDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetStructSyncExecSqlDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetStructSyncExecSqlDetailResponse) GoString() string {
	return s.String()
}

func (s *GetStructSyncExecSqlDetailResponse) SetHeaders(v map[string]*string) *GetStructSyncExecSqlDetailResponse {
	s.Headers = v
	return s
}

func (s *GetStructSyncExecSqlDetailResponse) SetStatusCode(v int32) *GetStructSyncExecSqlDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetStructSyncExecSqlDetailResponse) SetBody(v *GetStructSyncExecSqlDetailResponseBody) *GetStructSyncExecSqlDetailResponse {
	s.Body = v
	return s
}

type GetStructSyncJobAnalyzeResultRequest struct {
	// The type of the comparison. Valid values:
	//
	// *   **CREATE_TABLE**: compares the created tables.
	// *   **ALTER_TABLE**: compares the modified tables.
	// *   **EQUAL_TABLE**: compares the identical tables.
	// *   **PASS_TABLE**: compares the tables that are skipped during schema synchronization.
	// *   **NOT_COMPARE**: does not compare tables.
	CompareType *string `json:"CompareType,omitempty" xml:"CompareType,omitempty"`
	// The ID of the ticket.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The number of the page to return.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the tenant.
	//
	// > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetStructSyncJobAnalyzeResultRequest) String() string {
	return tea.Prettify(s)
}

func (s GetStructSyncJobAnalyzeResultRequest) GoString() string {
	return s.String()
}

func (s *GetStructSyncJobAnalyzeResultRequest) SetCompareType(v string) *GetStructSyncJobAnalyzeResultRequest {
	s.CompareType = &v
	return s
}

func (s *GetStructSyncJobAnalyzeResultRequest) SetOrderId(v int64) *GetStructSyncJobAnalyzeResultRequest {
	s.OrderId = &v
	return s
}

func (s *GetStructSyncJobAnalyzeResultRequest) SetPageNumber(v int64) *GetStructSyncJobAnalyzeResultRequest {
	s.PageNumber = &v
	return s
}

func (s *GetStructSyncJobAnalyzeResultRequest) SetPageSize(v int64) *GetStructSyncJobAnalyzeResultRequest {
	s.PageSize = &v
	return s
}

func (s *GetStructSyncJobAnalyzeResultRequest) SetTid(v int64) *GetStructSyncJobAnalyzeResultRequest {
	s.Tid = &v
	return s
}

type GetStructSyncJobAnalyzeResultResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The analysis result of the schema synchronization task.
	StructSyncJobAnalyzeResult *GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult `json:"StructSyncJobAnalyzeResult,omitempty" xml:"StructSyncJobAnalyzeResult,omitempty" type:"Struct"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetStructSyncJobAnalyzeResultResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetStructSyncJobAnalyzeResultResponseBody) GoString() string {
	return s.String()
}

func (s *GetStructSyncJobAnalyzeResultResponseBody) SetErrorCode(v string) *GetStructSyncJobAnalyzeResultResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetStructSyncJobAnalyzeResultResponseBody) SetErrorMessage(v string) *GetStructSyncJobAnalyzeResultResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetStructSyncJobAnalyzeResultResponseBody) SetRequestId(v string) *GetStructSyncJobAnalyzeResultResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetStructSyncJobAnalyzeResultResponseBody) SetStructSyncJobAnalyzeResult(v *GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult) *GetStructSyncJobAnalyzeResultResponseBody {
	s.StructSyncJobAnalyzeResult = v
	return s
}

func (s *GetStructSyncJobAnalyzeResultResponseBody) SetSuccess(v bool) *GetStructSyncJobAnalyzeResultResponseBody {
	s.Success = &v
	return s
}

type GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult struct {
	// The details of the analysis results.
	ResultList []*GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList `json:"ResultList,omitempty" xml:"ResultList,omitempty" type:"Repeated"`
	// The statistics on the analysis results.
	SummaryList []*GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList `json:"SummaryList,omitempty" xml:"SummaryList,omitempty" type:"Repeated"`
}

func (s GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult) String() string {
	return tea.Prettify(s)
}

func (s GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult) GoString() string {
	return s.String()
}

func (s *GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult) SetResultList(v []*GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList) *GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult {
	s.ResultList = v
	return s
}

func (s *GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult) SetSummaryList(v []*GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList) *GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResult {
	s.SummaryList = v
	return s
}

type GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList struct {
	// The SQL script.
	Script *string `json:"Script,omitempty" xml:"Script,omitempty"`
	// The name of the source table.
	SourceTableName *string `json:"SourceTableName,omitempty" xml:"SourceTableName,omitempty"`
	// The name of the destination table.
	TargetTableName *string `json:"TargetTableName,omitempty" xml:"TargetTableName,omitempty"`
}

func (s GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList) String() string {
	return tea.Prettify(s)
}

func (s GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList) GoString() string {
	return s.String()
}

func (s *GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList) SetScript(v string) *GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList {
	s.Script = &v
	return s
}

func (s *GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList) SetSourceTableName(v string) *GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList {
	s.SourceTableName = &v
	return s
}

func (s *GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList) SetTargetTableName(v string) *GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultResultList {
	s.TargetTableName = &v
	return s
}

type GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList struct {
	// The type of the comparison. Valid values:
	//
	// *   **CREATE_TABLE**: compares the created tables.
	// *   **ALTER_TABLE**: compares the modified tables.
	// *   **EQUAL_TABLE**: compares the identical tables.
	// *   **PASS_TABLE**: compares the tables that are skipped during schema synchronization.
	// *   **NOT_COMPARE**: does not compare tables.
	CompareType *string `json:"CompareType,omitempty" xml:"CompareType,omitempty"`
	// The number of tables.
	Count *int64 `json:"Count,omitempty" xml:"Count,omitempty"`
}

func (s GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList) String() string {
	return tea.Prettify(s)
}

func (s GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList) GoString() string {
	return s.String()
}

func (s *GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList) SetCompareType(v string) *GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList {
	s.CompareType = &v
	return s
}

func (s *GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList) SetCount(v int64) *GetStructSyncJobAnalyzeResultResponseBodyStructSyncJobAnalyzeResultSummaryList {
	s.Count = &v
	return s
}

type GetStructSyncJobAnalyzeResultResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetStructSyncJobAnalyzeResultResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetStructSyncJobAnalyzeResultResponse) String() string {
	return tea.Prettify(s)
}

func (s GetStructSyncJobAnalyzeResultResponse) GoString() string {
	return s.String()
}

func (s *GetStructSyncJobAnalyzeResultResponse) SetHeaders(v map[string]*string) *GetStructSyncJobAnalyzeResultResponse {
	s.Headers = v
	return s
}

func (s *GetStructSyncJobAnalyzeResultResponse) SetStatusCode(v int32) *GetStructSyncJobAnalyzeResultResponse {
	s.StatusCode = &v
	return s
}

func (s *GetStructSyncJobAnalyzeResultResponse) SetBody(v *GetStructSyncJobAnalyzeResultResponseBody) *GetStructSyncJobAnalyzeResultResponse {
	s.Body = v
	return s
}

type GetStructSyncJobDetailRequest struct {
	// The ticket ID.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The tenant ID.
	//
	// > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetStructSyncJobDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetStructSyncJobDetailRequest) GoString() string {
	return s.String()
}

func (s *GetStructSyncJobDetailRequest) SetOrderId(v int64) *GetStructSyncJobDetailRequest {
	s.OrderId = &v
	return s
}

func (s *GetStructSyncJobDetailRequest) SetTid(v int64) *GetStructSyncJobDetailRequest {
	s.Tid = &v
	return s
}

type GetStructSyncJobDetailResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The details of the schema synchronization task.
	StructSyncJobDetail *GetStructSyncJobDetailResponseBodyStructSyncJobDetail `json:"StructSyncJobDetail,omitempty" xml:"StructSyncJobDetail,omitempty" type:"Struct"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetStructSyncJobDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetStructSyncJobDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetStructSyncJobDetailResponseBody) SetErrorCode(v string) *GetStructSyncJobDetailResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetStructSyncJobDetailResponseBody) SetErrorMessage(v string) *GetStructSyncJobDetailResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetStructSyncJobDetailResponseBody) SetRequestId(v string) *GetStructSyncJobDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetStructSyncJobDetailResponseBody) SetStructSyncJobDetail(v *GetStructSyncJobDetailResponseBodyStructSyncJobDetail) *GetStructSyncJobDetailResponseBody {
	s.StructSyncJobDetail = v
	return s
}

func (s *GetStructSyncJobDetailResponseBody) SetSuccess(v bool) *GetStructSyncJobDetailResponseBody {
	s.Success = &v
	return s
}

type GetStructSyncJobDetailResponseBodyStructSyncJobDetail struct {
	// The ID of the SQL task group.
	DBTaskGroupId *int64 `json:"DBTaskGroupId,omitempty" xml:"DBTaskGroupId,omitempty"`
	// The number of SQL statements that have been executed.
	ExecuteCount *int64 `json:"ExecuteCount,omitempty" xml:"ExecuteCount,omitempty"`
	// The status of the task. Valid values:
	//
	// *   **NEW**: The task was created.
	// *   **COMPARING**: The schemas of tables were being compared.
	// *   **COMPARE_BREAK**: The schema comparison was interrupted.
	// *   **COMPARE_FINISH**: The comparison was finished.
	// *   **NOT_SCRIPTS**: The comparison was finished but no executable script was available.
	// *   **SUBMITED_DBTASK**: The task was submitted.
	// *   **DBTASK_SUCCESS**: The task was complete.
	// *   **SUBMITED_WORKFLOW**: The ticket was submitted.
	// *   **WORKFLOW_SUCCESS**: The ticket was approved.
	JobStatus *string `json:"JobStatus,omitempty" xml:"JobStatus,omitempty"`
	// The description of the task.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The type of security rule. Valid values:
	//
	// *   **CANNOT_SYNC**: Synchronization cannot be performed.
	// *   **WITH_APPROVE**: The schema synchronization can be performed after the ticket is approved. You can call the [SubmitStructSyncOrderApproval](~~206166~~) operation to submit the ticket for approval.
	// *   **WITHOUT_APPROVE**: The schema synchronization can be performed without approval.
	SecurityRule *string `json:"SecurityRule,omitempty" xml:"SecurityRule,omitempty"`
	// The total number of SQL statements.
	SqlCount *int64 `json:"SqlCount,omitempty" xml:"SqlCount,omitempty"`
	// The number of tables that have been analyzed.
	TableAnalyzed *int64 `json:"TableAnalyzed,omitempty" xml:"TableAnalyzed,omitempty"`
	// The total number of tables.
	TableCount *int64 `json:"TableCount,omitempty" xml:"TableCount,omitempty"`
}

func (s GetStructSyncJobDetailResponseBodyStructSyncJobDetail) String() string {
	return tea.Prettify(s)
}

func (s GetStructSyncJobDetailResponseBodyStructSyncJobDetail) GoString() string {
	return s.String()
}

func (s *GetStructSyncJobDetailResponseBodyStructSyncJobDetail) SetDBTaskGroupId(v int64) *GetStructSyncJobDetailResponseBodyStructSyncJobDetail {
	s.DBTaskGroupId = &v
	return s
}

func (s *GetStructSyncJobDetailResponseBodyStructSyncJobDetail) SetExecuteCount(v int64) *GetStructSyncJobDetailResponseBodyStructSyncJobDetail {
	s.ExecuteCount = &v
	return s
}

func (s *GetStructSyncJobDetailResponseBodyStructSyncJobDetail) SetJobStatus(v string) *GetStructSyncJobDetailResponseBodyStructSyncJobDetail {
	s.JobStatus = &v
	return s
}

func (s *GetStructSyncJobDetailResponseBodyStructSyncJobDetail) SetMessage(v string) *GetStructSyncJobDetailResponseBodyStructSyncJobDetail {
	s.Message = &v
	return s
}

func (s *GetStructSyncJobDetailResponseBodyStructSyncJobDetail) SetSecurityRule(v string) *GetStructSyncJobDetailResponseBodyStructSyncJobDetail {
	s.SecurityRule = &v
	return s
}

func (s *GetStructSyncJobDetailResponseBodyStructSyncJobDetail) SetSqlCount(v int64) *GetStructSyncJobDetailResponseBodyStructSyncJobDetail {
	s.SqlCount = &v
	return s
}

func (s *GetStructSyncJobDetailResponseBodyStructSyncJobDetail) SetTableAnalyzed(v int64) *GetStructSyncJobDetailResponseBodyStructSyncJobDetail {
	s.TableAnalyzed = &v
	return s
}

func (s *GetStructSyncJobDetailResponseBodyStructSyncJobDetail) SetTableCount(v int64) *GetStructSyncJobDetailResponseBodyStructSyncJobDetail {
	s.TableCount = &v
	return s
}

type GetStructSyncJobDetailResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetStructSyncJobDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetStructSyncJobDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetStructSyncJobDetailResponse) GoString() string {
	return s.String()
}

func (s *GetStructSyncJobDetailResponse) SetHeaders(v map[string]*string) *GetStructSyncJobDetailResponse {
	s.Headers = v
	return s
}

func (s *GetStructSyncJobDetailResponse) SetStatusCode(v int32) *GetStructSyncJobDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetStructSyncJobDetailResponse) SetBody(v *GetStructSyncJobDetailResponseBody) *GetStructSyncJobDetailResponse {
	s.Body = v
	return s
}

type GetStructSyncOrderDetailRequest struct {
	// The ID of the ticket.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant.
	//
	// > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetStructSyncOrderDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetStructSyncOrderDetailRequest) GoString() string {
	return s.String()
}

func (s *GetStructSyncOrderDetailRequest) SetOrderId(v int64) *GetStructSyncOrderDetailRequest {
	s.OrderId = &v
	return s
}

func (s *GetStructSyncOrderDetailRequest) SetTid(v int64) *GetStructSyncOrderDetailRequest {
	s.Tid = &v
	return s
}

type GetStructSyncOrderDetailResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The details of the schema synchronization ticket.
	StructSyncOrderDetail *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail `json:"StructSyncOrderDetail,omitempty" xml:"StructSyncOrderDetail,omitempty" type:"Struct"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetStructSyncOrderDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetStructSyncOrderDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetStructSyncOrderDetailResponseBody) SetErrorCode(v string) *GetStructSyncOrderDetailResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetStructSyncOrderDetailResponseBody) SetErrorMessage(v string) *GetStructSyncOrderDetailResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetStructSyncOrderDetailResponseBody) SetRequestId(v string) *GetStructSyncOrderDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetStructSyncOrderDetailResponseBody) SetStructSyncOrderDetail(v *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail) *GetStructSyncOrderDetailResponseBody {
	s.StructSyncOrderDetail = v
	return s
}

func (s *GetStructSyncOrderDetailResponseBody) SetSuccess(v bool) *GetStructSyncOrderDetailResponseBody {
	s.Success = &v
	return s
}

type GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail struct {
	// Indicates whether to skip errors. Valid values:
	//
	// *   **true**: skips the error and continues to execute SQL statements.
	// *   **false**: stops executing SQL statements.
	IgnoreError *bool `json:"IgnoreError,omitempty" xml:"IgnoreError,omitempty"`
	// The information about the source database.
	SourceDatabaseInfo *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo `json:"SourceDatabaseInfo,omitempty" xml:"SourceDatabaseInfo,omitempty" type:"Struct"`
	// The schema version of the source database. Valid values:
	//
	// *   **DATASOURCE**: the default latest version of the system
	// *   **VERSION**: a previous schema version that you manually specify
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The version information about the source instance.
	//
	// > This parameter is displayed only when the value of the **SourceType** parameter is **VERSION**.
	SourceVersionInfo *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceVersionInfo `json:"SourceVersionInfo,omitempty" xml:"SourceVersionInfo,omitempty" type:"Struct"`
	// The information about the table whose schema you want to synchronize.
	TableInfoList []*GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList `json:"TableInfoList,omitempty" xml:"TableInfoList,omitempty" type:"Repeated"`
	// The information about the destination database.
	TargetDatabaseInfo *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo `json:"TargetDatabaseInfo,omitempty" xml:"TargetDatabaseInfo,omitempty" type:"Struct"`
	// The schema version of the destination database. Valid values:
	//
	// *   **DATASOURCE**: the default latest version of the system
	// *   **VERSION**: a previous schema version that you manually specify
	TargetType *string `json:"TargetType,omitempty" xml:"TargetType,omitempty"`
	// The version information about the destination instance.
	//
	// > This parameter is displayed only when the value of the **SourceType** parameter is **VERSION**.
	TargetVersionInfo *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetVersionInfo `json:"TargetVersionInfo,omitempty" xml:"TargetVersionInfo,omitempty" type:"Struct"`
}

func (s GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail) String() string {
	return tea.Prettify(s)
}

func (s GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail) GoString() string {
	return s.String()
}

func (s *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail) SetIgnoreError(v bool) *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail {
	s.IgnoreError = &v
	return s
}

func (s *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail) SetSourceDatabaseInfo(v *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo) *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail {
	s.SourceDatabaseInfo = v
	return s
}

func (s *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail) SetSourceType(v string) *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail {
	s.SourceType = &v
	return s
}

func (s *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail) SetSourceVersionInfo(v *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceVersionInfo) *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail {
	s.SourceVersionInfo = v
	return s
}

func (s *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail) SetTableInfoList(v []*GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList) *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail {
	s.TableInfoList = v
	return s
}

func (s *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail) SetTargetDatabaseInfo(v *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo) *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail {
	s.TargetDatabaseInfo = v
	return s
}

func (s *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail) SetTargetType(v string) *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail {
	s.TargetType = &v
	return s
}

func (s *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail) SetTargetVersionInfo(v *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetVersionInfo) *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetail {
	s.TargetVersionInfo = v
	return s
}

type GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo struct {
	// The ID of the source database.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The type of the database engine.
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The type of the environment to which the database instance belongs. For more information, see [Change the environment type of an instance](~~163309~~).
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// Indicates whether the database is a logical database. Valid values:
	//
	// *   **true**: The database is a logical database.
	// *   **false**: The database is not a logical database
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The name that is used to search for the database.
	SearchName *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
}

func (s GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo) String() string {
	return tea.Prettify(s)
}

func (s GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo) GoString() string {
	return s.String()
}

func (s *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo) SetDbId(v int64) *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo {
	s.DbId = &v
	return s
}

func (s *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo) SetDbType(v string) *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo {
	s.DbType = &v
	return s
}

func (s *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo) SetEnvType(v string) *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo {
	s.EnvType = &v
	return s
}

func (s *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo) SetLogic(v bool) *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo {
	s.Logic = &v
	return s
}

func (s *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo) SetSearchName(v string) *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceDatabaseInfo {
	s.SearchName = &v
	return s
}

type GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceVersionInfo struct {
	// The version number.
	VersionId *string `json:"VersionId,omitempty" xml:"VersionId,omitempty"`
}

func (s GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceVersionInfo) String() string {
	return tea.Prettify(s)
}

func (s GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceVersionInfo) GoString() string {
	return s.String()
}

func (s *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceVersionInfo) SetVersionId(v string) *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailSourceVersionInfo {
	s.VersionId = &v
	return s
}

type GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList struct {
	// The name of the table whose schema you want to synchronize.
	SourceTableName *string `json:"SourceTableName,omitempty" xml:"SourceTableName,omitempty"`
	// The name of the table to which you want to synchronize the schema of a table.
	TargetTableName *string `json:"TargetTableName,omitempty" xml:"TargetTableName,omitempty"`
}

func (s GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList) String() string {
	return tea.Prettify(s)
}

func (s GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList) GoString() string {
	return s.String()
}

func (s *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList) SetSourceTableName(v string) *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList {
	s.SourceTableName = &v
	return s
}

func (s *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList) SetTargetTableName(v string) *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTableInfoList {
	s.TargetTableName = &v
	return s
}

type GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo struct {
	// The ID of the destination database.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The type of the database engine.
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The type of the environment to which the database instance belongs. For more information, see [Change the environment type of an instance](~~163309~~).
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// Indicates whether the database is a logical database. Valid values:
	//
	// *   **true**: The database is a logical database.
	// *   **false**: The database is not a logical database
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The name that is used to search for the database.
	SearchName *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
}

func (s GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo) String() string {
	return tea.Prettify(s)
}

func (s GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo) GoString() string {
	return s.String()
}

func (s *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo) SetDbId(v int64) *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo {
	s.DbId = &v
	return s
}

func (s *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo) SetDbType(v string) *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo {
	s.DbType = &v
	return s
}

func (s *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo) SetEnvType(v string) *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo {
	s.EnvType = &v
	return s
}

func (s *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo) SetLogic(v bool) *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo {
	s.Logic = &v
	return s
}

func (s *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo) SetSearchName(v string) *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetDatabaseInfo {
	s.SearchName = &v
	return s
}

type GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetVersionInfo struct {
	// The version number.
	VersionId *string `json:"VersionId,omitempty" xml:"VersionId,omitempty"`
}

func (s GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetVersionInfo) String() string {
	return tea.Prettify(s)
}

func (s GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetVersionInfo) GoString() string {
	return s.String()
}

func (s *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetVersionInfo) SetVersionId(v string) *GetStructSyncOrderDetailResponseBodyStructSyncOrderDetailTargetVersionInfo {
	s.VersionId = &v
	return s
}

type GetStructSyncOrderDetailResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetStructSyncOrderDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetStructSyncOrderDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetStructSyncOrderDetailResponse) GoString() string {
	return s.String()
}

func (s *GetStructSyncOrderDetailResponse) SetHeaders(v map[string]*string) *GetStructSyncOrderDetailResponse {
	s.Headers = v
	return s
}

func (s *GetStructSyncOrderDetailResponse) SetStatusCode(v int32) *GetStructSyncOrderDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetStructSyncOrderDetailResponse) SetBody(v *GetStructSyncOrderDetailResponseBody) *GetStructSyncOrderDetailResponse {
	s.Body = v
	return s
}

type GetTableDBTopologyRequest struct {
	// The GUID of the table in DMS.
	//
	// >
	//
	// *   If the database to which the table belongs is a logical database, you can call the [ListLogicTables](~~141875~~) operation to obtain the GUID. The value of the ReturnGuid parameter must be set to true.
	//
	// *   If the database to which the table belongs is a physical database, you can call the [ListTables](~~141878~~) operation to obtain the GUID. The value of the ReturnGuid parameter must be set to true.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
	// The ID of the tenant.
	//
	// > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetTableDBTopologyRequest) String() string {
	return tea.Prettify(s)
}

func (s GetTableDBTopologyRequest) GoString() string {
	return s.String()
}

func (s *GetTableDBTopologyRequest) SetTableGuid(v string) *GetTableDBTopologyRequest {
	s.TableGuid = &v
	return s
}

func (s *GetTableDBTopologyRequest) SetTid(v int64) *GetTableDBTopologyRequest {
	s.Tid = &v
	return s
}

type GetTableDBTopologyResponseBody struct {
	// The topology of the data table.
	DBTopology *GetTableDBTopologyResponseBodyDBTopology `json:"DBTopology,omitempty" xml:"DBTopology,omitempty" type:"Struct"`
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetTableDBTopologyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetTableDBTopologyResponseBody) GoString() string {
	return s.String()
}

func (s *GetTableDBTopologyResponseBody) SetDBTopology(v *GetTableDBTopologyResponseBodyDBTopology) *GetTableDBTopologyResponseBody {
	s.DBTopology = v
	return s
}

func (s *GetTableDBTopologyResponseBody) SetErrorCode(v string) *GetTableDBTopologyResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetTableDBTopologyResponseBody) SetErrorMessage(v string) *GetTableDBTopologyResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetTableDBTopologyResponseBody) SetRequestId(v string) *GetTableDBTopologyResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetTableDBTopologyResponseBody) SetSuccess(v bool) *GetTableDBTopologyResponseBody {
	s.Success = &v
	return s
}

type GetTableDBTopologyResponseBodyDBTopology struct {
	// The data sources.
	DataSourceList []*GetTableDBTopologyResponseBodyDBTopologyDataSourceList `json:"DataSourceList,omitempty" xml:"DataSourceList,omitempty" type:"Repeated"`
	// The GUID of the table in DMS.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
	// The name of the table.
	//
	// >
	//
	// *   If a logical table is queried, the name of the logical table is returned.
	//
	// *   If a physical table is queried, the name of the physical table is returned.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s GetTableDBTopologyResponseBodyDBTopology) String() string {
	return tea.Prettify(s)
}

func (s GetTableDBTopologyResponseBodyDBTopology) GoString() string {
	return s.String()
}

func (s *GetTableDBTopologyResponseBodyDBTopology) SetDataSourceList(v []*GetTableDBTopologyResponseBodyDBTopologyDataSourceList) *GetTableDBTopologyResponseBodyDBTopology {
	s.DataSourceList = v
	return s
}

func (s *GetTableDBTopologyResponseBodyDBTopology) SetTableGuid(v string) *GetTableDBTopologyResponseBodyDBTopology {
	s.TableGuid = &v
	return s
}

func (s *GetTableDBTopologyResponseBodyDBTopology) SetTableName(v string) *GetTableDBTopologyResponseBodyDBTopology {
	s.TableName = &v
	return s
}

type GetTableDBTopologyResponseBodyDBTopologyDataSourceList struct {
	// The physical databases.
	DatabaseList []*GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList `json:"DatabaseList,omitempty" xml:"DatabaseList,omitempty" type:"Repeated"`
	// The type of the database. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The endpoint of the data source.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The port that is used to connect to the data source.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The system ID (SID) of the data source.
	Sid *string `json:"Sid,omitempty" xml:"Sid,omitempty"`
}

func (s GetTableDBTopologyResponseBodyDBTopologyDataSourceList) String() string {
	return tea.Prettify(s)
}

func (s GetTableDBTopologyResponseBodyDBTopologyDataSourceList) GoString() string {
	return s.String()
}

func (s *GetTableDBTopologyResponseBodyDBTopologyDataSourceList) SetDatabaseList(v []*GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList) *GetTableDBTopologyResponseBodyDBTopologyDataSourceList {
	s.DatabaseList = v
	return s
}

func (s *GetTableDBTopologyResponseBodyDBTopologyDataSourceList) SetDbType(v string) *GetTableDBTopologyResponseBodyDBTopologyDataSourceList {
	s.DbType = &v
	return s
}

func (s *GetTableDBTopologyResponseBodyDBTopologyDataSourceList) SetHost(v string) *GetTableDBTopologyResponseBodyDBTopologyDataSourceList {
	s.Host = &v
	return s
}

func (s *GetTableDBTopologyResponseBodyDBTopologyDataSourceList) SetPort(v int32) *GetTableDBTopologyResponseBodyDBTopologyDataSourceList {
	s.Port = &v
	return s
}

func (s *GetTableDBTopologyResponseBodyDBTopologyDataSourceList) SetSid(v string) *GetTableDBTopologyResponseBodyDBTopologyDataSourceList {
	s.Sid = &v
	return s
}

type GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList struct {
	// The ID of the database.
	DbId *string `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The name of the database.
	DbName *string `json:"DbName,omitempty" xml:"DbName,omitempty"`
	// The type of the database. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The type of the environment to which the database belongs. Valid values:
	//
	// *   **product**: production environment
	// *   **dev**: development environment
	// *   **pre**: pre-release environment
	// *   **test**: test environment
	// *   **sit**: system integration testing (SIT) environment
	// *   **uat**: user acceptance testing (UAT) environment
	// *   **pet**: stress testing environment
	// *   **stag**: staging environment
	//
	// > For more information, see [Change the environment type of an instance](~~163309~~).
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The physical tables.
	TableList []*GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList `json:"TableList,omitempty" xml:"TableList,omitempty" type:"Repeated"`
}

func (s GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList) String() string {
	return tea.Prettify(s)
}

func (s GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList) GoString() string {
	return s.String()
}

func (s *GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList) SetDbId(v string) *GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList {
	s.DbId = &v
	return s
}

func (s *GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList) SetDbName(v string) *GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList {
	s.DbName = &v
	return s
}

func (s *GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList) SetDbType(v string) *GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList {
	s.DbType = &v
	return s
}

func (s *GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList) SetEnvType(v string) *GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList {
	s.EnvType = &v
	return s
}

func (s *GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList) SetTableList(v []*GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList) *GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseList {
	s.TableList = v
	return s
}

type GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList struct {
	// The ID of the table.
	TableId *string `json:"TableId,omitempty" xml:"TableId,omitempty"`
	// The name of the physical table.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	// The type of the table. This is a reserved parameter.
	TableType *string `json:"TableType,omitempty" xml:"TableType,omitempty"`
}

func (s GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList) String() string {
	return tea.Prettify(s)
}

func (s GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList) GoString() string {
	return s.String()
}

func (s *GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList) SetTableId(v string) *GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList {
	s.TableId = &v
	return s
}

func (s *GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList) SetTableName(v string) *GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList {
	s.TableName = &v
	return s
}

func (s *GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList) SetTableType(v string) *GetTableDBTopologyResponseBodyDBTopologyDataSourceListDatabaseListTableList {
	s.TableType = &v
	return s
}

type GetTableDBTopologyResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetTableDBTopologyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetTableDBTopologyResponse) String() string {
	return tea.Prettify(s)
}

func (s GetTableDBTopologyResponse) GoString() string {
	return s.String()
}

func (s *GetTableDBTopologyResponse) SetHeaders(v map[string]*string) *GetTableDBTopologyResponse {
	s.Headers = v
	return s
}

func (s *GetTableDBTopologyResponse) SetStatusCode(v int32) *GetTableDBTopologyResponse {
	s.StatusCode = &v
	return s
}

func (s *GetTableDBTopologyResponse) SetBody(v *GetTableDBTopologyResponseBody) *GetTableDBTopologyResponse {
	s.Body = v
	return s
}

type GetTableTopologyRequest struct {
	// The GUID of the table in Data Management (DMS).
	//
	// >
	// > - You can call the [ListLogicTables](~~141875~~) operation with ReturnGuid set to true to query the GUIDs of logical tables in a specific logical database.
	// > - You can call the [ListTables](~~141878~~) operation with ReturnGuid set to true to query the GUIDs of tables in a specific physical database.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
	// The ID of the tenant.
	//
	// > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the "View information about the current tenant" section of the [Tenant information](~~181330~~) topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetTableTopologyRequest) String() string {
	return tea.Prettify(s)
}

func (s GetTableTopologyRequest) GoString() string {
	return s.String()
}

func (s *GetTableTopologyRequest) SetTableGuid(v string) *GetTableTopologyRequest {
	s.TableGuid = &v
	return s
}

func (s *GetTableTopologyRequest) SetTid(v int64) *GetTableTopologyRequest {
	s.Tid = &v
	return s
}

type GetTableTopologyResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The topology information.
	TableTopology *GetTableTopologyResponseBodyTableTopology `json:"TableTopology,omitempty" xml:"TableTopology,omitempty" type:"Struct"`
}

func (s GetTableTopologyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetTableTopologyResponseBody) GoString() string {
	return s.String()
}

func (s *GetTableTopologyResponseBody) SetErrorCode(v string) *GetTableTopologyResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetTableTopologyResponseBody) SetErrorMessage(v string) *GetTableTopologyResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetTableTopologyResponseBody) SetRequestId(v string) *GetTableTopologyResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetTableTopologyResponseBody) SetSuccess(v bool) *GetTableTopologyResponseBody {
	s.Success = &v
	return s
}

func (s *GetTableTopologyResponseBody) SetTableTopology(v *GetTableTopologyResponseBodyTableTopology) *GetTableTopologyResponseBody {
	s.TableTopology = v
	return s
}

type GetTableTopologyResponseBodyTableTopology struct {
	// Indicates whether the table is a logical table. Valid values:
	//
	// *   **true**
	// *   **false**
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The GUID of the table in DMS.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
	// The name of the table.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	// Information of the topology of the table.
	TableTopologyInfoList []*GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList `json:"TableTopologyInfoList,omitempty" xml:"TableTopologyInfoList,omitempty" type:"Repeated"`
}

func (s GetTableTopologyResponseBodyTableTopology) String() string {
	return tea.Prettify(s)
}

func (s GetTableTopologyResponseBodyTableTopology) GoString() string {
	return s.String()
}

func (s *GetTableTopologyResponseBodyTableTopology) SetLogic(v bool) *GetTableTopologyResponseBodyTableTopology {
	s.Logic = &v
	return s
}

func (s *GetTableTopologyResponseBodyTableTopology) SetTableGuid(v string) *GetTableTopologyResponseBodyTableTopology {
	s.TableGuid = &v
	return s
}

func (s *GetTableTopologyResponseBodyTableTopology) SetTableName(v string) *GetTableTopologyResponseBodyTableTopology {
	s.TableName = &v
	return s
}

func (s *GetTableTopologyResponseBodyTableTopology) SetTableTopologyInfoList(v []*GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList) *GetTableTopologyResponseBodyTableTopology {
	s.TableTopologyInfoList = v
	return s
}

type GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList struct {
	// The ID of the physical database.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The name of the database.
	DbName *string `json:"DbName,omitempty" xml:"DbName,omitempty"`
	// The name that is used to search for the database.
	// > We recommend that you do not use this parameter for business development. The format of the parameter value may be modified in later versions.
	DbSearchName *string `json:"DbSearchName,omitempty" xml:"DbSearchName,omitempty"`
	// The database engine.
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The ID of the instance to which the physical database belongs.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the resource related to the instance. The resource corresponds with the database instance type returned in the InstanceSource parameter.
	//
	// *   **RDS**:The ID of the ApsaraDB RDS instance.
	// *   **ECS_OWN**: The ID of the Elastic Compute Service (ECS) instance.
	// *   **PUBLIC_OWN**: This parameter is left empty for self-managed database instances that are connected over the Internet.
	// *   **VPC_ID**:The ID of the virtual private cloud (VPC).
	// *   **GATEWAY**: The ID of the database gateway.
	InstanceResourceId *string `json:"InstanceResourceId,omitempty" xml:"InstanceResourceId,omitempty"`
	// The type of the database instance. Valid values:
	//
	// *   **RDS**: an ApsaraDB RDS instance.
	// *   **ECS_OWN**: a self-managed database that is deployed on an ECS instance
	// *   **PUBLIC_OWN**: a self-managed database instance that is connected over the Internet.
	// *   **VPC_ID**: a self-managed database instance in a VPC that is connected over Express Connect circuits.
	// *   **GATEWAY**: a database instance connected by using a database gateway.
	InstanceSource *string `json:"InstanceSource,omitempty" xml:"InstanceSource,omitempty"`
	// The region ID of the instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The number of tables.
	TableCount *int64 `json:"TableCount,omitempty" xml:"TableCount,omitempty"`
	// The expression of the names of logical tables.
	//
	// **
	//
	// **Description** This parameter is not returned for physical tables.
	TableNameExpr *string `json:"TableNameExpr,omitempty" xml:"TableNameExpr,omitempty"`
	// The names of tables.
	//
	// > The table names are separated by commas (,).
	TableNameList *string `json:"TableNameList,omitempty" xml:"TableNameList,omitempty"`
}

func (s GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList) String() string {
	return tea.Prettify(s)
}

func (s GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList) GoString() string {
	return s.String()
}

func (s *GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList) SetDbId(v int64) *GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList {
	s.DbId = &v
	return s
}

func (s *GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList) SetDbName(v string) *GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList {
	s.DbName = &v
	return s
}

func (s *GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList) SetDbSearchName(v string) *GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList {
	s.DbSearchName = &v
	return s
}

func (s *GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList) SetDbType(v string) *GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList {
	s.DbType = &v
	return s
}

func (s *GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList) SetInstanceId(v int64) *GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList {
	s.InstanceId = &v
	return s
}

func (s *GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList) SetInstanceResourceId(v string) *GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList {
	s.InstanceResourceId = &v
	return s
}

func (s *GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList) SetInstanceSource(v string) *GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList {
	s.InstanceSource = &v
	return s
}

func (s *GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList) SetRegionId(v string) *GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList {
	s.RegionId = &v
	return s
}

func (s *GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList) SetTableCount(v int64) *GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList {
	s.TableCount = &v
	return s
}

func (s *GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList) SetTableNameExpr(v string) *GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList {
	s.TableNameExpr = &v
	return s
}

func (s *GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList) SetTableNameList(v string) *GetTableTopologyResponseBodyTableTopologyTableTopologyInfoList {
	s.TableNameList = &v
	return s
}

type GetTableTopologyResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetTableTopologyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetTableTopologyResponse) String() string {
	return tea.Prettify(s)
}

func (s GetTableTopologyResponse) GoString() string {
	return s.String()
}

func (s *GetTableTopologyResponse) SetHeaders(v map[string]*string) *GetTableTopologyResponse {
	s.Headers = v
	return s
}

func (s *GetTableTopologyResponse) SetStatusCode(v int32) *GetTableTopologyResponse {
	s.StatusCode = &v
	return s
}

func (s *GetTableTopologyResponse) SetBody(v *GetTableTopologyResponseBody) *GetTableTopologyResponse {
	s.Body = v
	return s
}

type GetTaskRequest struct {
	// The ID of the task node. You can call the [GetTaskInstanceRelation](~~424711~~) operation to query the node ID.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The ID of the tenant.
	//
	// > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s GetTaskRequest) GoString() string {
	return s.String()
}

func (s *GetTaskRequest) SetNodeId(v int64) *GetTaskRequest {
	s.NodeId = &v
	return s
}

func (s *GetTaskRequest) SetTid(v int64) *GetTaskRequest {
	s.Tid = &v
	return s
}

type GetTaskResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The task node.
	Task *GetTaskResponseBodyTask `json:"Task,omitempty" xml:"Task,omitempty" type:"Struct"`
}

func (s GetTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetTaskResponseBody) GoString() string {
	return s.String()
}

func (s *GetTaskResponseBody) SetErrorCode(v string) *GetTaskResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetTaskResponseBody) SetErrorMessage(v string) *GetTaskResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetTaskResponseBody) SetRequestId(v string) *GetTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetTaskResponseBody) SetSuccess(v bool) *GetTaskResponseBody {
	s.Success = &v
	return s
}

func (s *GetTaskResponseBody) SetTask(v *GetTaskResponseBodyTask) *GetTaskResponseBody {
	s.Task = v
	return s
}

type GetTaskResponseBodyTask struct {
	// The ID of the task flow to which the node belongs.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The position of the node on the Directed Acyclic Graph (DAG).
	GraphParam *string `json:"GraphParam,omitempty" xml:"GraphParam,omitempty"`
	// The advanced configuration for the node.
	NodeConfig *string `json:"NodeConfig,omitempty" xml:"NodeConfig,omitempty"`
	// The configuration for the node.
	NodeContent *string `json:"NodeContent,omitempty" xml:"NodeContent,omitempty"`
	// The name of the node.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The output variables for the node. This parameter is available only for some types of nodes.
	NodeOutput *string `json:"NodeOutput,omitempty" xml:"NodeOutput,omitempty"`
	// The type of the node. For more information about the valid values for this parameter, see [NodeType parameter](~~424705~~).
	NodeType *string `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
	// The time variables configured for the node.
	TimeVariables *string `json:"TimeVariables,omitempty" xml:"TimeVariables,omitempty"`
}

func (s GetTaskResponseBodyTask) String() string {
	return tea.Prettify(s)
}

func (s GetTaskResponseBodyTask) GoString() string {
	return s.String()
}

func (s *GetTaskResponseBodyTask) SetDagId(v int64) *GetTaskResponseBodyTask {
	s.DagId = &v
	return s
}

func (s *GetTaskResponseBodyTask) SetGraphParam(v string) *GetTaskResponseBodyTask {
	s.GraphParam = &v
	return s
}

func (s *GetTaskResponseBodyTask) SetNodeConfig(v string) *GetTaskResponseBodyTask {
	s.NodeConfig = &v
	return s
}

func (s *GetTaskResponseBodyTask) SetNodeContent(v string) *GetTaskResponseBodyTask {
	s.NodeContent = &v
	return s
}

func (s *GetTaskResponseBodyTask) SetNodeName(v string) *GetTaskResponseBodyTask {
	s.NodeName = &v
	return s
}

func (s *GetTaskResponseBodyTask) SetNodeOutput(v string) *GetTaskResponseBodyTask {
	s.NodeOutput = &v
	return s
}

func (s *GetTaskResponseBodyTask) SetNodeType(v string) *GetTaskResponseBodyTask {
	s.NodeType = &v
	return s
}

func (s *GetTaskResponseBodyTask) SetTimeVariables(v string) *GetTaskResponseBodyTask {
	s.TimeVariables = &v
	return s
}

type GetTaskResponse struct {
	Headers    map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s GetTaskResponse) GoString() string {
	return s.String()
}

func (s *GetTaskResponse) SetHeaders(v map[string]*string) *GetTaskResponse {
	s.Headers = v
	return s
}

func (s *GetTaskResponse) SetStatusCode(v int32) *GetTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *GetTaskResponse) SetBody(v *GetTaskResponseBody) *GetTaskResponse {
	s.Body = v
	return s
}

type GetTaskFlowGraphRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the tenant.
	//
	// >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetTaskFlowGraphRequest) String() string {
	return tea.Prettify(s)
}

func (s GetTaskFlowGraphRequest) GoString() string {
	return s.String()
}

func (s *GetTaskFlowGraphRequest) SetDagId(v int64) *GetTaskFlowGraphRequest {
	s.DagId = &v
	return s
}

func (s *GetTaskFlowGraphRequest) SetTid(v int64) *GetTaskFlowGraphRequest {
	s.Tid = &v
	return s
}

type GetTaskFlowGraphResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The list of DAG variables of the task flow.
	TaskFlowGraph *GetTaskFlowGraphResponseBodyTaskFlowGraph `json:"TaskFlowGraph,omitempty" xml:"TaskFlowGraph,omitempty" type:"Struct"`
}

func (s GetTaskFlowGraphResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetTaskFlowGraphResponseBody) GoString() string {
	return s.String()
}

func (s *GetTaskFlowGraphResponseBody) SetErrorCode(v string) *GetTaskFlowGraphResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetTaskFlowGraphResponseBody) SetErrorMessage(v string) *GetTaskFlowGraphResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetTaskFlowGraphResponseBody) SetRequestId(v string) *GetTaskFlowGraphResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetTaskFlowGraphResponseBody) SetSuccess(v bool) *GetTaskFlowGraphResponseBody {
	s.Success = &v
	return s
}

func (s *GetTaskFlowGraphResponseBody) SetTaskFlowGraph(v *GetTaskFlowGraphResponseBodyTaskFlowGraph) *GetTaskFlowGraphResponseBody {
	s.TaskFlowGraph = v
	return s
}

type GetTaskFlowGraphResponseBodyTaskFlowGraph struct {
	// Indicates whether the task flow is editable. Valid values:
	//
	// - **true**: editable
	// - **false**: non-editable
	CanEdit *bool `json:"CanEdit,omitempty" xml:"CanEdit,omitempty"`
	// The name of the task flow.
	DagName *string `json:"DagName,omitempty" xml:"DagName,omitempty"`
	// The list of task flow edges.
	Edges *GetTaskFlowGraphResponseBodyTaskFlowGraphEdges `json:"Edges,omitempty" xml:"Edges,omitempty" type:"Struct"`
	// The node list of the task flow.
	Nodes *GetTaskFlowGraphResponseBodyTaskFlowGraphNodes `json:"Nodes,omitempty" xml:"Nodes,omitempty" type:"Struct"`
	// The status of the task flow. Valid values:
	//
	// - **0**: invalid
	// - **1**: not scheduled
	// - **2**: to be scheduled
	Status *int64 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetTaskFlowGraphResponseBodyTaskFlowGraph) String() string {
	return tea.Prettify(s)
}

func (s GetTaskFlowGraphResponseBodyTaskFlowGraph) GoString() string {
	return s.String()
}

func (s *GetTaskFlowGraphResponseBodyTaskFlowGraph) SetCanEdit(v bool) *GetTaskFlowGraphResponseBodyTaskFlowGraph {
	s.CanEdit = &v
	return s
}

func (s *GetTaskFlowGraphResponseBodyTaskFlowGraph) SetDagName(v string) *GetTaskFlowGraphResponseBodyTaskFlowGraph {
	s.DagName = &v
	return s
}

func (s *GetTaskFlowGraphResponseBodyTaskFlowGraph) SetEdges(v *GetTaskFlowGraphResponseBodyTaskFlowGraphEdges) *GetTaskFlowGraphResponseBodyTaskFlowGraph {
	s.Edges = v
	return s
}

func (s *GetTaskFlowGraphResponseBodyTaskFlowGraph) SetNodes(v *GetTaskFlowGraphResponseBodyTaskFlowGraphNodes) *GetTaskFlowGraphResponseBodyTaskFlowGraph {
	s.Nodes = v
	return s
}

func (s *GetTaskFlowGraphResponseBodyTaskFlowGraph) SetStatus(v int64) *GetTaskFlowGraphResponseBodyTaskFlowGraph {
	s.Status = &v
	return s
}

type GetTaskFlowGraphResponseBodyTaskFlowGraphEdges struct {
	Edge []*GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge `json:"Edge,omitempty" xml:"Edge,omitempty" type:"Repeated"`
}

func (s GetTaskFlowGraphResponseBodyTaskFlowGraphEdges) String() string {
	return tea.Prettify(s)
}

func (s GetTaskFlowGraphResponseBodyTaskFlowGraphEdges) GoString() string {
	return s.String()
}

func (s *GetTaskFlowGraphResponseBodyTaskFlowGraphEdges) SetEdge(v []*GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge) *GetTaskFlowGraphResponseBodyTaskFlowGraphEdges {
	s.Edge = v
	return s
}

type GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge struct {
	// The ID of the task flow.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the task flow edge.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the end node on the edge.
	NodeEnd *int64 `json:"NodeEnd,omitempty" xml:"NodeEnd,omitempty"`
	// The ID of the start node on the edge.
	NodeFrom *int64 `json:"NodeFrom,omitempty" xml:"NodeFrom,omitempty"`
}

func (s GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge) String() string {
	return tea.Prettify(s)
}

func (s GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge) GoString() string {
	return s.String()
}

func (s *GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge) SetDagId(v int64) *GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge {
	s.DagId = &v
	return s
}

func (s *GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge) SetId(v int64) *GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge {
	s.Id = &v
	return s
}

func (s *GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge) SetNodeEnd(v int64) *GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge {
	s.NodeEnd = &v
	return s
}

func (s *GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge) SetNodeFrom(v int64) *GetTaskFlowGraphResponseBodyTaskFlowGraphEdgesEdge {
	s.NodeFrom = &v
	return s
}

type GetTaskFlowGraphResponseBodyTaskFlowGraphNodes struct {
	Node []*GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode `json:"Node,omitempty" xml:"Node,omitempty" type:"Repeated"`
}

func (s GetTaskFlowGraphResponseBodyTaskFlowGraphNodes) String() string {
	return tea.Prettify(s)
}

func (s GetTaskFlowGraphResponseBodyTaskFlowGraphNodes) GoString() string {
	return s.String()
}

func (s *GetTaskFlowGraphResponseBodyTaskFlowGraphNodes) SetNode(v []*GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode) *GetTaskFlowGraphResponseBodyTaskFlowGraphNodes {
	s.Node = v
	return s
}

type GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode struct {
	// The ID of the task flow.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The position of the node in the DAG.
	GraphParam *string `json:"GraphParam,omitempty" xml:"GraphParam,omitempty"`
	// The advanced configuration of the node.
	NodeConfig *string `json:"NodeConfig,omitempty" xml:"NodeConfig,omitempty"`
	// The configuration of the node.
	NodeContent *string `json:"NodeContent,omitempty" xml:"NodeContent,omitempty"`
	// The ID of the node.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The name of the node.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The type of the node. For more information about the valid values for this parameter, see [NodeType parameter](~~424705~~).
	NodeType *int64 `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
	// The time variables for the node.
	TimeVariables *string `json:"TimeVariables,omitempty" xml:"TimeVariables,omitempty"`
}

func (s GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode) String() string {
	return tea.Prettify(s)
}

func (s GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode) GoString() string {
	return s.String()
}

func (s *GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode) SetDagId(v int64) *GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode {
	s.DagId = &v
	return s
}

func (s *GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode) SetGraphParam(v string) *GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode {
	s.GraphParam = &v
	return s
}

func (s *GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode) SetNodeConfig(v string) *GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode {
	s.NodeConfig = &v
	return s
}

func (s *GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode) SetNodeContent(v string) *GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode {
	s.NodeContent = &v
	return s
}

func (s *GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode) SetNodeId(v int64) *GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode {
	s.NodeId = &v
	return s
}

func (s *GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode) SetNodeName(v string) *GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode {
	s.NodeName = &v
	return s
}

func (s *GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode) SetNodeType(v int64) *GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode {
	s.NodeType = &v
	return s
}

func (s *GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode) SetTimeVariables(v string) *GetTaskFlowGraphResponseBodyTaskFlowGraphNodesNode {
	s.TimeVariables = &v
	return s
}

type GetTaskFlowGraphResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetTaskFlowGraphResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetTaskFlowGraphResponse) String() string {
	return tea.Prettify(s)
}

func (s GetTaskFlowGraphResponse) GoString() string {
	return s.String()
}

func (s *GetTaskFlowGraphResponse) SetHeaders(v map[string]*string) *GetTaskFlowGraphResponse {
	s.Headers = v
	return s
}

func (s *GetTaskFlowGraphResponse) SetStatusCode(v int32) *GetTaskFlowGraphResponse {
	s.StatusCode = &v
	return s
}

func (s *GetTaskFlowGraphResponse) SetBody(v *GetTaskFlowGraphResponseBody) *GetTaskFlowGraphResponse {
	s.Body = v
	return s
}

type GetTaskFlowNotificationRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the tenant.
	//
	// > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetTaskFlowNotificationRequest) String() string {
	return tea.Prettify(s)
}

func (s GetTaskFlowNotificationRequest) GoString() string {
	return s.String()
}

func (s *GetTaskFlowNotificationRequest) SetDagId(v int64) *GetTaskFlowNotificationRequest {
	s.DagId = &v
	return s
}

func (s *GetTaskFlowNotificationRequest) SetTid(v int64) *GetTaskFlowNotificationRequest {
	s.Tid = &v
	return s
}

type GetTaskFlowNotificationResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The notification settings specified by the user.
	Notification *GetTaskFlowNotificationResponseBodyNotification `json:"Notification,omitempty" xml:"Notification,omitempty" type:"Struct"`
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetTaskFlowNotificationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetTaskFlowNotificationResponseBody) GoString() string {
	return s.String()
}

func (s *GetTaskFlowNotificationResponseBody) SetErrorCode(v string) *GetTaskFlowNotificationResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetTaskFlowNotificationResponseBody) SetErrorMessage(v string) *GetTaskFlowNotificationResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetTaskFlowNotificationResponseBody) SetNotification(v *GetTaskFlowNotificationResponseBodyNotification) *GetTaskFlowNotificationResponseBody {
	s.Notification = v
	return s
}

func (s *GetTaskFlowNotificationResponseBody) SetRequestId(v string) *GetTaskFlowNotificationResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetTaskFlowNotificationResponseBody) SetSuccess(v bool) *GetTaskFlowNotificationResponseBody {
	s.Success = &v
	return s
}

type GetTaskFlowNotificationResponseBodyNotification struct {
	// Indicates whether notifications for failed task flows are enabled. Valid values:
	//
	// *   **true**: enabled
	// *   **false**: disabled
	DagNotificationFail *bool `json:"DagNotificationFail,omitempty" xml:"DagNotificationFail,omitempty"`
	// Indicates whether service level agreement (SLA) global notifications for task flows are enabled. Valid values:
	//
	// *   **true**: enabled
	// *   **false**: disabled
	DagNotificationSla *bool `json:"DagNotificationSla,omitempty" xml:"DagNotificationSla,omitempty"`
	// Indicates whether notifications for successful task flows are enabled. Valid values:
	//
	// *   **true**: enabled
	// *   **false**: disabled
	DagNotificationSuccess *bool `json:"DagNotificationSuccess,omitempty" xml:"DagNotificationSuccess,omitempty"`
}

func (s GetTaskFlowNotificationResponseBodyNotification) String() string {
	return tea.Prettify(s)
}

func (s GetTaskFlowNotificationResponseBodyNotification) GoString() string {
	return s.String()
}

func (s *GetTaskFlowNotificationResponseBodyNotification) SetDagNotificationFail(v bool) *GetTaskFlowNotificationResponseBodyNotification {
	s.DagNotificationFail = &v
	return s
}

func (s *GetTaskFlowNotificationResponseBodyNotification) SetDagNotificationSla(v bool) *GetTaskFlowNotificationResponseBodyNotification {
	s.DagNotificationSla = &v
	return s
}

func (s *GetTaskFlowNotificationResponseBodyNotification) SetDagNotificationSuccess(v bool) *GetTaskFlowNotificationResponseBodyNotification {
	s.DagNotificationSuccess = &v
	return s
}

type GetTaskFlowNotificationResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetTaskFlowNotificationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetTaskFlowNotificationResponse) String() string {
	return tea.Prettify(s)
}

func (s GetTaskFlowNotificationResponse) GoString() string {
	return s.String()
}

func (s *GetTaskFlowNotificationResponse) SetHeaders(v map[string]*string) *GetTaskFlowNotificationResponse {
	s.Headers = v
	return s
}

func (s *GetTaskFlowNotificationResponse) SetStatusCode(v int32) *GetTaskFlowNotificationResponse {
	s.StatusCode = &v
	return s
}

func (s *GetTaskFlowNotificationResponse) SetBody(v *GetTaskFlowNotificationResponseBody) *GetTaskFlowNotificationResponse {
	s.Body = v
	return s
}

type GetTaskInstanceRelationRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the ID of the task flow.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the execution record of the task flow. You can call the [ListTaskFlowInstance](~~424689~~) operation to obtain the execution record ID.
	DagInstanceId *int64 `json:"DagInstanceId,omitempty" xml:"DagInstanceId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetTaskInstanceRelationRequest) String() string {
	return tea.Prettify(s)
}

func (s GetTaskInstanceRelationRequest) GoString() string {
	return s.String()
}

func (s *GetTaskInstanceRelationRequest) SetDagId(v int64) *GetTaskInstanceRelationRequest {
	s.DagId = &v
	return s
}

func (s *GetTaskInstanceRelationRequest) SetDagInstanceId(v int64) *GetTaskInstanceRelationRequest {
	s.DagInstanceId = &v
	return s
}

func (s *GetTaskInstanceRelationRequest) SetTid(v int64) *GetTaskInstanceRelationRequest {
	s.Tid = &v
	return s
}

type GetTaskInstanceRelationResponseBody struct {
	// The error code returned if the request fails.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The information about the nodes in the execution record of the task flow.
	NodeList *GetTaskInstanceRelationResponseBodyNodeList `json:"NodeList,omitempty" xml:"NodeList,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**: The request is successful.
	// *   **false**: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetTaskInstanceRelationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetTaskInstanceRelationResponseBody) GoString() string {
	return s.String()
}

func (s *GetTaskInstanceRelationResponseBody) SetErrorCode(v string) *GetTaskInstanceRelationResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetTaskInstanceRelationResponseBody) SetErrorMessage(v string) *GetTaskInstanceRelationResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetTaskInstanceRelationResponseBody) SetNodeList(v *GetTaskInstanceRelationResponseBodyNodeList) *GetTaskInstanceRelationResponseBody {
	s.NodeList = v
	return s
}

func (s *GetTaskInstanceRelationResponseBody) SetRequestId(v string) *GetTaskInstanceRelationResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetTaskInstanceRelationResponseBody) SetSuccess(v bool) *GetTaskInstanceRelationResponseBody {
	s.Success = &v
	return s
}

type GetTaskInstanceRelationResponseBodyNodeList struct {
	Node []*GetTaskInstanceRelationResponseBodyNodeListNode `json:"Node,omitempty" xml:"Node,omitempty" type:"Repeated"`
}

func (s GetTaskInstanceRelationResponseBodyNodeList) String() string {
	return tea.Prettify(s)
}

func (s GetTaskInstanceRelationResponseBodyNodeList) GoString() string {
	return s.String()
}

func (s *GetTaskInstanceRelationResponseBodyNodeList) SetNode(v []*GetTaskInstanceRelationResponseBodyNodeListNode) *GetTaskInstanceRelationResponseBodyNodeList {
	s.Node = v
	return s
}

type GetTaskInstanceRelationResponseBodyNodeListNode struct {
	// The business time of the node.
	BusinessTime *string `json:"BusinessTime,omitempty" xml:"BusinessTime,omitempty"`
	// The time when the execution of the task flow was complete. The time is displayed in the yyyy-MM-DD HH:mm:ss format.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The amount of time consumed for running the node. Unit: milliseconds.
	ExecuteTime *int64 `json:"ExecuteTime,omitempty" xml:"ExecuteTime,omitempty"`
	// The ID of the execution record of the task flow.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The description of the task.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the node.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The name of the node.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The type of the node. For more information about the valid values for this parameter, see [NodeType parameter](~~424705~~).
	NodeType *int32 `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
	// The status of the node. Valid values:
	//
	// *   **0**: The node is waiting to be scheduled.
	// *   **1**: The node is running.
	// *   **2**: The node is suspended.
	// *   **3**: The node failed to run.
	// *   **4**: The node is run.
	// *   **5**: The node is complete.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetTaskInstanceRelationResponseBodyNodeListNode) String() string {
	return tea.Prettify(s)
}

func (s GetTaskInstanceRelationResponseBodyNodeListNode) GoString() string {
	return s.String()
}

func (s *GetTaskInstanceRelationResponseBodyNodeListNode) SetBusinessTime(v string) *GetTaskInstanceRelationResponseBodyNodeListNode {
	s.BusinessTime = &v
	return s
}

func (s *GetTaskInstanceRelationResponseBodyNodeListNode) SetEndTime(v string) *GetTaskInstanceRelationResponseBodyNodeListNode {
	s.EndTime = &v
	return s
}

func (s *GetTaskInstanceRelationResponseBodyNodeListNode) SetExecuteTime(v int64) *GetTaskInstanceRelationResponseBodyNodeListNode {
	s.ExecuteTime = &v
	return s
}

func (s *GetTaskInstanceRelationResponseBodyNodeListNode) SetId(v int64) *GetTaskInstanceRelationResponseBodyNodeListNode {
	s.Id = &v
	return s
}

func (s *GetTaskInstanceRelationResponseBodyNodeListNode) SetMessage(v string) *GetTaskInstanceRelationResponseBodyNodeListNode {
	s.Message = &v
	return s
}

func (s *GetTaskInstanceRelationResponseBodyNodeListNode) SetNodeId(v int64) *GetTaskInstanceRelationResponseBodyNodeListNode {
	s.NodeId = &v
	return s
}

func (s *GetTaskInstanceRelationResponseBodyNodeListNode) SetNodeName(v string) *GetTaskInstanceRelationResponseBodyNodeListNode {
	s.NodeName = &v
	return s
}

func (s *GetTaskInstanceRelationResponseBodyNodeListNode) SetNodeType(v int32) *GetTaskInstanceRelationResponseBodyNodeListNode {
	s.NodeType = &v
	return s
}

func (s *GetTaskInstanceRelationResponseBodyNodeListNode) SetStatus(v int32) *GetTaskInstanceRelationResponseBodyNodeListNode {
	s.Status = &v
	return s
}

type GetTaskInstanceRelationResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetTaskInstanceRelationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetTaskInstanceRelationResponse) String() string {
	return tea.Prettify(s)
}

func (s GetTaskInstanceRelationResponse) GoString() string {
	return s.String()
}

func (s *GetTaskInstanceRelationResponse) SetHeaders(v map[string]*string) *GetTaskInstanceRelationResponse {
	s.Headers = v
	return s
}

func (s *GetTaskInstanceRelationResponse) SetStatusCode(v int32) *GetTaskInstanceRelationResponse {
	s.StatusCode = &v
	return s
}

func (s *GetTaskInstanceRelationResponse) SetBody(v *GetTaskInstanceRelationResponseBody) *GetTaskInstanceRelationResponse {
	s.Body = v
	return s
}

type GetUserRequest struct {
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The UID of the Alibaba Cloud account. You can view your UID by moving the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console.
	Uid *string `json:"Uid,omitempty" xml:"Uid,omitempty"`
	// The ID of the user. You can call the [ListUsers](~~141938~~) operation to query the ID of the user.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s GetUserRequest) String() string {
	return tea.Prettify(s)
}

func (s GetUserRequest) GoString() string {
	return s.String()
}

func (s *GetUserRequest) SetTid(v int64) *GetUserRequest {
	s.Tid = &v
	return s
}

func (s *GetUserRequest) SetUid(v string) *GetUserRequest {
	s.Uid = &v
	return s
}

func (s *GetUserRequest) SetUserId(v string) *GetUserRequest {
	s.UserId = &v
	return s
}

type GetUserResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The information about the user.
	User *GetUserResponseBodyUser `json:"User,omitempty" xml:"User,omitempty" type:"Struct"`
}

func (s GetUserResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetUserResponseBody) GoString() string {
	return s.String()
}

func (s *GetUserResponseBody) SetErrorCode(v string) *GetUserResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetUserResponseBody) SetErrorMessage(v string) *GetUserResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetUserResponseBody) SetRequestId(v string) *GetUserResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetUserResponseBody) SetSuccess(v bool) *GetUserResponseBody {
	s.Success = &v
	return s
}

func (s *GetUserResponseBody) SetUser(v *GetUserResponseBodyUser) *GetUserResponseBody {
	s.User = v
	return s
}

type GetUserResponseBodyUser struct {
	// The number of queries that are performed on the current day.
	CurExecuteCount *int64 `json:"CurExecuteCount,omitempty" xml:"CurExecuteCount,omitempty"`
	// The number of rows that are queried on the current day.
	CurResultCount *int64 `json:"CurResultCount,omitempty" xml:"CurResultCount,omitempty"`
	// The DingTalk chatbot URL that is used to receive notifications.
	//
	// >
	//
	// *   The system returns this parameter if the user has set a DingTalk chatbot URL in the console. To set a DingTalk chatbot URL in the console, move the pointer over the profile picture in the upper-right corner and click the Edit icon next to **Notice**.
	//
	// *   The system does not return this parameter if the user has not set a DingTalk chatbot URL.
	DingRobot *string `json:"DingRobot,omitempty" xml:"DingRobot,omitempty"`
	// The email address that is used to receive notifications.
	//
	// >
	//
	// *   The system returns this parameter if the user has set an email address in the console. To set an email address in the console, move the pointer over the profile picture in the upper-right corner and click the Edit icon next to **Notice**.
	//
	// *   The system does not return this parameter if the user has not set an email address.
	Email *string `json:"Email,omitempty" xml:"Email,omitempty"`
	// The last point in time when the user logged on to the console.
	LastLoginTime *string `json:"LastLoginTime,omitempty" xml:"LastLoginTime,omitempty"`
	// The maximum number of queries that can be performed on the current day.
	MaxExecuteCount *int64 `json:"MaxExecuteCount,omitempty" xml:"MaxExecuteCount,omitempty"`
	// The maximum number of rows that can be queried on the current day.
	MaxResultCount *int64 `json:"MaxResultCount,omitempty" xml:"MaxResultCount,omitempty"`
	// The mobile number of the user.
	//
	// >
	//
	// *   The system returns this parameter if the user has set a mobile phone number in the console. To set a mobile phone number in the console, move the pointer over the profile picture in the upper-right corner and click the Edit icon next to **Notice**.
	//
	// *   The system does not return this parameter if the user has not set a mobile phone number.
	Mobile *string `json:"Mobile,omitempty" xml:"Mobile,omitempty"`
	// The nickname of the user.
	NickName *string `json:"NickName,omitempty" xml:"NickName,omitempty"`
	// The notification method. The system returns one or more values. Valid values:
	//
	// *   **SMS**: text message
	// *   **EMAIL**: email.
	// *   **DINGDING**: DingTalk.
	// *   **DINGROBOT**: DingTalk chatbot.
	// *   **WEBHOOK**: webhook.
	NotificationMode *string `json:"NotificationMode,omitempty" xml:"NotificationMode,omitempty"`
	// The UID of the Alibaba Cloud account of the user.
	//
	// > An Alibaba Cloud account can contain one or more RAM users.
	ParentUid *int64 `json:"ParentUid,omitempty" xml:"ParentUid,omitempty"`
	// The list of role IDs.
	RoleIdList *GetUserResponseBodyUserRoleIdList `json:"RoleIdList,omitempty" xml:"RoleIdList,omitempty" type:"Struct"`
	// The list of role names.
	RoleNameList *GetUserResponseBodyUserRoleNameList `json:"RoleNameList,omitempty" xml:"RoleNameList,omitempty" type:"Struct"`
	// The signature method that is used to secure connections when a webhook URL is used. Valid values:
	//
	// *   **NONE**: no signature.
	// *   **HMAC_SHA1**: HMAC_SHA1.
	SignatureMethod *string `json:"SignatureMethod,omitempty" xml:"SignatureMethod,omitempty"`
	// The status of the user. Valid values:
	//
	// *   **NORMAL**: The user is normal.
	// *   **DISABLE**: The user is disabled.
	// *   **DELETE**: The user is deleted.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// The UID of the user.
	Uid *string `json:"Uid,omitempty" xml:"Uid,omitempty"`
	// The ID of the user.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The webhook URL that is used to receive notifications.
	//
	// >
	//
	// *   If the user has set a webhook URL, DMS sends notifications to the specified URL.
	//
	// *   The system does not return this parameter if the user has not set a webhook URL.
	Webhook *string `json:"Webhook,omitempty" xml:"Webhook,omitempty"`
}

func (s GetUserResponseBodyUser) String() string {
	return tea.Prettify(s)
}

func (s GetUserResponseBodyUser) GoString() string {
	return s.String()
}

func (s *GetUserResponseBodyUser) SetCurExecuteCount(v int64) *GetUserResponseBodyUser {
	s.CurExecuteCount = &v
	return s
}

func (s *GetUserResponseBodyUser) SetCurResultCount(v int64) *GetUserResponseBodyUser {
	s.CurResultCount = &v
	return s
}

func (s *GetUserResponseBodyUser) SetDingRobot(v string) *GetUserResponseBodyUser {
	s.DingRobot = &v
	return s
}

func (s *GetUserResponseBodyUser) SetEmail(v string) *GetUserResponseBodyUser {
	s.Email = &v
	return s
}

func (s *GetUserResponseBodyUser) SetLastLoginTime(v string) *GetUserResponseBodyUser {
	s.LastLoginTime = &v
	return s
}

func (s *GetUserResponseBodyUser) SetMaxExecuteCount(v int64) *GetUserResponseBodyUser {
	s.MaxExecuteCount = &v
	return s
}

func (s *GetUserResponseBodyUser) SetMaxResultCount(v int64) *GetUserResponseBodyUser {
	s.MaxResultCount = &v
	return s
}

func (s *GetUserResponseBodyUser) SetMobile(v string) *GetUserResponseBodyUser {
	s.Mobile = &v
	return s
}

func (s *GetUserResponseBodyUser) SetNickName(v string) *GetUserResponseBodyUser {
	s.NickName = &v
	return s
}

func (s *GetUserResponseBodyUser) SetNotificationMode(v string) *GetUserResponseBodyUser {
	s.NotificationMode = &v
	return s
}

func (s *GetUserResponseBodyUser) SetParentUid(v int64) *GetUserResponseBodyUser {
	s.ParentUid = &v
	return s
}

func (s *GetUserResponseBodyUser) SetRoleIdList(v *GetUserResponseBodyUserRoleIdList) *GetUserResponseBodyUser {
	s.RoleIdList = v
	return s
}

func (s *GetUserResponseBodyUser) SetRoleNameList(v *GetUserResponseBodyUserRoleNameList) *GetUserResponseBodyUser {
	s.RoleNameList = v
	return s
}

func (s *GetUserResponseBodyUser) SetSignatureMethod(v string) *GetUserResponseBodyUser {
	s.SignatureMethod = &v
	return s
}

func (s *GetUserResponseBodyUser) SetState(v string) *GetUserResponseBodyUser {
	s.State = &v
	return s
}

func (s *GetUserResponseBodyUser) SetUid(v string) *GetUserResponseBodyUser {
	s.Uid = &v
	return s
}

func (s *GetUserResponseBodyUser) SetUserId(v string) *GetUserResponseBodyUser {
	s.UserId = &v
	return s
}

func (s *GetUserResponseBodyUser) SetWebhook(v string) *GetUserResponseBodyUser {
	s.Webhook = &v
	return s
}

type GetUserResponseBodyUserRoleIdList struct {
	RoleIds []*int32 `json:"RoleIds,omitempty" xml:"RoleIds,omitempty" type:"Repeated"`
}

func (s GetUserResponseBodyUserRoleIdList) String() string {
	return tea.Prettify(s)
}

func (s GetUserResponseBodyUserRoleIdList) GoString() string {
	return s.String()
}

func (s *GetUserResponseBodyUserRoleIdList) SetRoleIds(v []*int32) *GetUserResponseBodyUserRoleIdList {
	s.RoleIds = v
	return s
}

type GetUserResponseBodyUserRoleNameList struct {
	RoleNames []*string `json:"RoleNames,omitempty" xml:"RoleNames,omitempty" type:"Repeated"`
}

func (s GetUserResponseBodyUserRoleNameList) String() string {
	return tea.Prettify(s)
}

func (s GetUserResponseBodyUserRoleNameList) GoString() string {
	return s.String()
}

func (s *GetUserResponseBodyUserRoleNameList) SetRoleNames(v []*string) *GetUserResponseBodyUserRoleNameList {
	s.RoleNames = v
	return s
}

type GetUserResponse struct {
	Headers    map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetUserResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetUserResponse) String() string {
	return tea.Prettify(s)
}

func (s GetUserResponse) GoString() string {
	return s.String()
}

func (s *GetUserResponse) SetHeaders(v map[string]*string) *GetUserResponse {
	s.Headers = v
	return s
}

func (s *GetUserResponse) SetStatusCode(v int32) *GetUserResponse {
	s.StatusCode = &v
	return s
}

func (s *GetUserResponse) SetBody(v *GetUserResponseBody) *GetUserResponse {
	s.Body = v
	return s
}

type GetUserActiveTenantRequest struct {
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetUserActiveTenantRequest) String() string {
	return tea.Prettify(s)
}

func (s GetUserActiveTenantRequest) GoString() string {
	return s.String()
}

func (s *GetUserActiveTenantRequest) SetTid(v int64) *GetUserActiveTenantRequest {
	s.Tid = &v
	return s
}

type GetUserActiveTenantResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**: The request is successful.
	// *   **false**: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The details of the tenant.
	Tenant *GetUserActiveTenantResponseBodyTenant `json:"Tenant,omitempty" xml:"Tenant,omitempty" type:"Struct"`
}

func (s GetUserActiveTenantResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetUserActiveTenantResponseBody) GoString() string {
	return s.String()
}

func (s *GetUserActiveTenantResponseBody) SetErrorCode(v string) *GetUserActiveTenantResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetUserActiveTenantResponseBody) SetErrorMessage(v string) *GetUserActiveTenantResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetUserActiveTenantResponseBody) SetRequestId(v string) *GetUserActiveTenantResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetUserActiveTenantResponseBody) SetSuccess(v bool) *GetUserActiveTenantResponseBody {
	s.Success = &v
	return s
}

func (s *GetUserActiveTenantResponseBody) SetTenant(v *GetUserActiveTenantResponseBodyTenant) *GetUserActiveTenantResponseBody {
	s.Tenant = v
	return s
}

type GetUserActiveTenantResponseBodyTenant struct {
	// The status of the tenant. Valid values:
	//
	// *   **ACTIVE**: The tenant is used to access DMS.
	// *   **IN_ACTIVE**: The tenant is not used.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The name of the tenant.
	TenantName *string `json:"TenantName,omitempty" xml:"TenantName,omitempty"`
	// The ID of the tenant.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetUserActiveTenantResponseBodyTenant) String() string {
	return tea.Prettify(s)
}

func (s GetUserActiveTenantResponseBodyTenant) GoString() string {
	return s.String()
}

func (s *GetUserActiveTenantResponseBodyTenant) SetStatus(v string) *GetUserActiveTenantResponseBodyTenant {
	s.Status = &v
	return s
}

func (s *GetUserActiveTenantResponseBodyTenant) SetTenantName(v string) *GetUserActiveTenantResponseBodyTenant {
	s.TenantName = &v
	return s
}

func (s *GetUserActiveTenantResponseBodyTenant) SetTid(v int64) *GetUserActiveTenantResponseBodyTenant {
	s.Tid = &v
	return s
}

type GetUserActiveTenantResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetUserActiveTenantResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetUserActiveTenantResponse) String() string {
	return tea.Prettify(s)
}

func (s GetUserActiveTenantResponse) GoString() string {
	return s.String()
}

func (s *GetUserActiveTenantResponse) SetHeaders(v map[string]*string) *GetUserActiveTenantResponse {
	s.Headers = v
	return s
}

func (s *GetUserActiveTenantResponse) SetStatusCode(v int32) *GetUserActiveTenantResponse {
	s.StatusCode = &v
	return s
}

func (s *GetUserActiveTenantResponse) SetBody(v *GetUserActiveTenantResponseBody) *GetUserActiveTenantResponse {
	s.Body = v
	return s
}

type GetUserUploadFileJobRequest struct {
	// The key of the file upload task. The key is returned when you call the [CreateUploadFileJob](~~206059~~) or [CreateUploadOSSFileJob](~~206060~~) operation.
	JobKey *string `json:"JobKey,omitempty" xml:"JobKey,omitempty"`
	// The tenant ID.
	//
	// > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s GetUserUploadFileJobRequest) String() string {
	return tea.Prettify(s)
}

func (s GetUserUploadFileJobRequest) GoString() string {
	return s.String()
}

func (s *GetUserUploadFileJobRequest) SetJobKey(v string) *GetUserUploadFileJobRequest {
	s.JobKey = &v
	return s
}

func (s *GetUserUploadFileJobRequest) SetTid(v int64) *GetUserUploadFileJobRequest {
	s.Tid = &v
	return s
}

type GetUserUploadFileJobResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The details of the file upload task.
	UploadFileJobDetail *GetUserUploadFileJobResponseBodyUploadFileJobDetail `json:"UploadFileJobDetail,omitempty" xml:"UploadFileJobDetail,omitempty" type:"Struct"`
}

func (s GetUserUploadFileJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetUserUploadFileJobResponseBody) GoString() string {
	return s.String()
}

func (s *GetUserUploadFileJobResponseBody) SetErrorCode(v string) *GetUserUploadFileJobResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetUserUploadFileJobResponseBody) SetErrorMessage(v string) *GetUserUploadFileJobResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetUserUploadFileJobResponseBody) SetRequestId(v string) *GetUserUploadFileJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetUserUploadFileJobResponseBody) SetSuccess(v bool) *GetUserUploadFileJobResponseBody {
	s.Success = &v
	return s
}

func (s *GetUserUploadFileJobResponseBody) SetUploadFileJobDetail(v *GetUserUploadFileJobResponseBodyUploadFileJobDetail) *GetUserUploadFileJobResponseBody {
	s.UploadFileJobDetail = v
	return s
}

type GetUserUploadFileJobResponseBodyUploadFileJobDetail struct {
	// The key of the file that is returned after the file is uploaded. You can use this key when you upload the file as an attachment in a ticket.
	AttachmentKey *string `json:"AttachmentKey,omitempty" xml:"AttachmentKey,omitempty"`
	// The name of the file.
	FileName *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	// The size of the file. Unit: byte.
	FileSize *int64 `json:"FileSize,omitempty" xml:"FileSize,omitempty"`
	// The purpose of the uploaded file. Valid values:
	//
	// *   **datacorrect**: The file is uploaded to change data.
	// *   **order_info_attachment**: The file is uploaded as an attachment in a ticket.
	// *   **big-file**: The file is uploaded to import multiple data records at a time.
	// *   **sqlreview**: The file is uploaded for SQL review.
	FileSource *string `json:"FileSource,omitempty" xml:"FileSource,omitempty"`
	// The key of the file upload task.
	JobKey *string `json:"JobKey,omitempty" xml:"JobKey,omitempty"`
	// The status of the file upload task. Valid values:
	//
	// *   **INIT**: The file upload task was initialized.
	// *   **PENDING**: The file upload task waited to be run.
	// *   **BE_SCHEDULED**: The file upload task waited to be scheduled.
	// *   **FAIL**: The file upload task failed.
	// *   **SUCCESS**: The file upload task was successful.
	// *   **RUNNING**: The file upload task was being run.
	JobStatus *string `json:"JobStatus,omitempty" xml:"JobStatus,omitempty"`
	// The information about the status of the file upload task.
	JobStatusDesc *string `json:"JobStatusDesc,omitempty" xml:"JobStatusDesc,omitempty"`
	// The information about the Object Storage Service (OSS) bucket from which the file is uploaded.
	//
	// > This parameter is returned if the value of **UploadType** is **OSS**.
	UploadOSSParam *GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam `json:"UploadOSSParam,omitempty" xml:"UploadOSSParam,omitempty" type:"Struct"`
	// The method used to upload the file. Valid values:
	//
	// *   **URL**
	// *   **OSS**
	UploadType *string `json:"UploadType,omitempty" xml:"UploadType,omitempty"`
	// The URL of the file.
	//
	// > This parameter is returned if the value of **UploadType** is **URL**.
	UploadURL *string `json:"UploadURL,omitempty" xml:"UploadURL,omitempty"`
	// The size of the uploaded file. Unit: byte.
	UploadedSize *int64 `json:"UploadedSize,omitempty" xml:"UploadedSize,omitempty"`
}

func (s GetUserUploadFileJobResponseBodyUploadFileJobDetail) String() string {
	return tea.Prettify(s)
}

func (s GetUserUploadFileJobResponseBodyUploadFileJobDetail) GoString() string {
	return s.String()
}

func (s *GetUserUploadFileJobResponseBodyUploadFileJobDetail) SetAttachmentKey(v string) *GetUserUploadFileJobResponseBodyUploadFileJobDetail {
	s.AttachmentKey = &v
	return s
}

func (s *GetUserUploadFileJobResponseBodyUploadFileJobDetail) SetFileName(v string) *GetUserUploadFileJobResponseBodyUploadFileJobDetail {
	s.FileName = &v
	return s
}

func (s *GetUserUploadFileJobResponseBodyUploadFileJobDetail) SetFileSize(v int64) *GetUserUploadFileJobResponseBodyUploadFileJobDetail {
	s.FileSize = &v
	return s
}

func (s *GetUserUploadFileJobResponseBodyUploadFileJobDetail) SetFileSource(v string) *GetUserUploadFileJobResponseBodyUploadFileJobDetail {
	s.FileSource = &v
	return s
}

func (s *GetUserUploadFileJobResponseBodyUploadFileJobDetail) SetJobKey(v string) *GetUserUploadFileJobResponseBodyUploadFileJobDetail {
	s.JobKey = &v
	return s
}

func (s *GetUserUploadFileJobResponseBodyUploadFileJobDetail) SetJobStatus(v string) *GetUserUploadFileJobResponseBodyUploadFileJobDetail {
	s.JobStatus = &v
	return s
}

func (s *GetUserUploadFileJobResponseBodyUploadFileJobDetail) SetJobStatusDesc(v string) *GetUserUploadFileJobResponseBodyUploadFileJobDetail {
	s.JobStatusDesc = &v
	return s
}

func (s *GetUserUploadFileJobResponseBodyUploadFileJobDetail) SetUploadOSSParam(v *GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam) *GetUserUploadFileJobResponseBodyUploadFileJobDetail {
	s.UploadOSSParam = v
	return s
}

func (s *GetUserUploadFileJobResponseBodyUploadFileJobDetail) SetUploadType(v string) *GetUserUploadFileJobResponseBodyUploadFileJobDetail {
	s.UploadType = &v
	return s
}

func (s *GetUserUploadFileJobResponseBodyUploadFileJobDetail) SetUploadURL(v string) *GetUserUploadFileJobResponseBodyUploadFileJobDetail {
	s.UploadURL = &v
	return s
}

func (s *GetUserUploadFileJobResponseBodyUploadFileJobDetail) SetUploadedSize(v int64) *GetUserUploadFileJobResponseBodyUploadFileJobDetail {
	s.UploadedSize = &v
	return s
}

type GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam struct {
	// The name of the OSS bucket.
	BucketName *string `json:"BucketName,omitempty" xml:"BucketName,omitempty"`
	// The endpoint of the OSS bucket.
	Endpoint *string `json:"Endpoint,omitempty" xml:"Endpoint,omitempty"`
	// The name of the OSS object.
	ObjectName *string `json:"ObjectName,omitempty" xml:"ObjectName,omitempty"`
}

func (s GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam) String() string {
	return tea.Prettify(s)
}

func (s GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam) GoString() string {
	return s.String()
}

func (s *GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam) SetBucketName(v string) *GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam {
	s.BucketName = &v
	return s
}

func (s *GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam) SetEndpoint(v string) *GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam {
	s.Endpoint = &v
	return s
}

func (s *GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam) SetObjectName(v string) *GetUserUploadFileJobResponseBodyUploadFileJobDetailUploadOSSParam {
	s.ObjectName = &v
	return s
}

type GetUserUploadFileJobResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetUserUploadFileJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetUserUploadFileJobResponse) String() string {
	return tea.Prettify(s)
}

func (s GetUserUploadFileJobResponse) GoString() string {
	return s.String()
}

func (s *GetUserUploadFileJobResponse) SetHeaders(v map[string]*string) *GetUserUploadFileJobResponse {
	s.Headers = v
	return s
}

func (s *GetUserUploadFileJobResponse) SetStatusCode(v int32) *GetUserUploadFileJobResponse {
	s.StatusCode = &v
	return s
}

func (s *GetUserUploadFileJobResponse) SetBody(v *GetUserUploadFileJobResponseBody) *GetUserUploadFileJobResponse {
	s.Body = v
	return s
}

type GrantTemplateAuthorityRequest struct {
	// The reason why you want to grant permissions on resources to the users by using the permission template.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The time when the permission expires. Specify the time in the yyyy-MM-DD HH:mm:ss format.
	ExpireDate *string `json:"ExpireDate,omitempty" xml:"ExpireDate,omitempty"`
	// The ID of the permission template.
	TemplateId *int64 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The IDs of users to which you want to grant permissions on resources by using the permission template.
	UserIds *string `json:"UserIds,omitempty" xml:"UserIds,omitempty"`
}

func (s GrantTemplateAuthorityRequest) String() string {
	return tea.Prettify(s)
}

func (s GrantTemplateAuthorityRequest) GoString() string {
	return s.String()
}

func (s *GrantTemplateAuthorityRequest) SetComment(v string) *GrantTemplateAuthorityRequest {
	s.Comment = &v
	return s
}

func (s *GrantTemplateAuthorityRequest) SetExpireDate(v string) *GrantTemplateAuthorityRequest {
	s.ExpireDate = &v
	return s
}

func (s *GrantTemplateAuthorityRequest) SetTemplateId(v int64) *GrantTemplateAuthorityRequest {
	s.TemplateId = &v
	return s
}

func (s *GrantTemplateAuthorityRequest) SetTid(v int64) *GrantTemplateAuthorityRequest {
	s.Tid = &v
	return s
}

func (s *GrantTemplateAuthorityRequest) SetUserIds(v string) *GrantTemplateAuthorityRequest {
	s.UserIds = &v
	return s
}

type GrantTemplateAuthorityResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the permissions on resources were granted to the users by using the permission template.
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GrantTemplateAuthorityResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GrantTemplateAuthorityResponseBody) GoString() string {
	return s.String()
}

func (s *GrantTemplateAuthorityResponseBody) SetErrorCode(v string) *GrantTemplateAuthorityResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GrantTemplateAuthorityResponseBody) SetErrorMessage(v string) *GrantTemplateAuthorityResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GrantTemplateAuthorityResponseBody) SetRequestId(v string) *GrantTemplateAuthorityResponseBody {
	s.RequestId = &v
	return s
}

func (s *GrantTemplateAuthorityResponseBody) SetResult(v bool) *GrantTemplateAuthorityResponseBody {
	s.Result = &v
	return s
}

func (s *GrantTemplateAuthorityResponseBody) SetSuccess(v bool) *GrantTemplateAuthorityResponseBody {
	s.Success = &v
	return s
}

type GrantTemplateAuthorityResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GrantTemplateAuthorityResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GrantTemplateAuthorityResponse) String() string {
	return tea.Prettify(s)
}

func (s GrantTemplateAuthorityResponse) GoString() string {
	return s.String()
}

func (s *GrantTemplateAuthorityResponse) SetHeaders(v map[string]*string) *GrantTemplateAuthorityResponse {
	s.Headers = v
	return s
}

func (s *GrantTemplateAuthorityResponse) SetStatusCode(v int32) *GrantTemplateAuthorityResponse {
	s.StatusCode = &v
	return s
}

func (s *GrantTemplateAuthorityResponse) SetBody(v *GrantTemplateAuthorityResponseBody) *GrantTemplateAuthorityResponse {
	s.Body = v
	return s
}

type GrantUserPermissionRequest struct {
	// The ID of the database. You can call the [ListDatabases](~~141873~~) operation to query the ID of a physical database and the [ListLogicDatabases](~~141874~~) operation to query the ID of a logical database.
	//
	// >  The value of the DatabaseId parameter is that of the DbId parameter.
	DbId *string `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The permissions on a specific type of object that you want to grant to the user. Valid values:
	//
	// *   INSTANCE: permissions on instances
	// *   DATABASE: permissions on physical databases
	// *   LOGIC_DATABASE: permissions on logical databases
	// *   TABLE: permissions on physical tables
	// *   LOGIC_TABLE: permissions on logical tables
	DsType *string `json:"DsType,omitempty" xml:"DsType,omitempty"`
	// The time when the permissions expire.
	ExpireDate *string `json:"ExpireDate,omitempty" xml:"ExpireDate,omitempty"`
	// The ID of the instance. You must specify this parameter if you grant permissions on an instance to the user. You can call the [ListInstances](~~141936~~) or [GetInstance](~~141567~~) operation to query the ID of the instance.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// Specifies whether the database is a logical database. You must specify this parameter if you grant permissions on a database to the user. Valid values:
	//
	// *   true: The database is a logical database.
	// *   false: The database is a physical database.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The permission type. Separate multiple permission types with commas (,). Valid values:
	//
	// *   **QUERY**: the query permissions
	// *   **EXPORT**: the export permissions
	// *   **CORRECT**: the change permissions
	// *   **LOGIN**: the logon permissions
	// *   **PERF**: the query permissions on the performance details of the instance
	PermTypes *string `json:"PermTypes,omitempty" xml:"PermTypes,omitempty"`
	// The ID of the table. You must specify this parameter if you grant permissions on a table to the user. You can call the [ListTables](~~141878~~) operation to query the table ID.
	TableId *string `json:"TableId,omitempty" xml:"TableId,omitempty"`
	// The name of the table. You must specify this parameter if you grant permissions on a table to the user.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	// The ID of the tenant.
	//
	// >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The ID of the user. You can call the [GetUser](~~147098~~) or [ListUsers](~~141938~~) operation to query the ID of the user.
	//
	// >  The user ID is different from the ID of your Alibaba Cloud account.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s GrantUserPermissionRequest) String() string {
	return tea.Prettify(s)
}

func (s GrantUserPermissionRequest) GoString() string {
	return s.String()
}

func (s *GrantUserPermissionRequest) SetDbId(v string) *GrantUserPermissionRequest {
	s.DbId = &v
	return s
}

func (s *GrantUserPermissionRequest) SetDsType(v string) *GrantUserPermissionRequest {
	s.DsType = &v
	return s
}

func (s *GrantUserPermissionRequest) SetExpireDate(v string) *GrantUserPermissionRequest {
	s.ExpireDate = &v
	return s
}

func (s *GrantUserPermissionRequest) SetInstanceId(v int64) *GrantUserPermissionRequest {
	s.InstanceId = &v
	return s
}

func (s *GrantUserPermissionRequest) SetLogic(v bool) *GrantUserPermissionRequest {
	s.Logic = &v
	return s
}

func (s *GrantUserPermissionRequest) SetPermTypes(v string) *GrantUserPermissionRequest {
	s.PermTypes = &v
	return s
}

func (s *GrantUserPermissionRequest) SetTableId(v string) *GrantUserPermissionRequest {
	s.TableId = &v
	return s
}

func (s *GrantUserPermissionRequest) SetTableName(v string) *GrantUserPermissionRequest {
	s.TableName = &v
	return s
}

func (s *GrantUserPermissionRequest) SetTid(v int64) *GrantUserPermissionRequest {
	s.Tid = &v
	return s
}

func (s *GrantUserPermissionRequest) SetUserId(v string) *GrantUserPermissionRequest {
	s.UserId = &v
	return s
}

type GrantUserPermissionResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GrantUserPermissionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GrantUserPermissionResponseBody) GoString() string {
	return s.String()
}

func (s *GrantUserPermissionResponseBody) SetErrorCode(v string) *GrantUserPermissionResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GrantUserPermissionResponseBody) SetErrorMessage(v string) *GrantUserPermissionResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GrantUserPermissionResponseBody) SetRequestId(v string) *GrantUserPermissionResponseBody {
	s.RequestId = &v
	return s
}

func (s *GrantUserPermissionResponseBody) SetSuccess(v bool) *GrantUserPermissionResponseBody {
	s.Success = &v
	return s
}

type GrantUserPermissionResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GrantUserPermissionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GrantUserPermissionResponse) String() string {
	return tea.Prettify(s)
}

func (s GrantUserPermissionResponse) GoString() string {
	return s.String()
}

func (s *GrantUserPermissionResponse) SetHeaders(v map[string]*string) *GrantUserPermissionResponse {
	s.Headers = v
	return s
}

func (s *GrantUserPermissionResponse) SetStatusCode(v int32) *GrantUserPermissionResponse {
	s.StatusCode = &v
	return s
}

func (s *GrantUserPermissionResponse) SetBody(v *GrantUserPermissionResponseBody) *GrantUserPermissionResponse {
	s.Body = v
	return s
}

type InspectProxyAccessSecretRequest struct {
	// The ID of the security protection authorization. After the security protection agent authorizes the target user, the system automatically generates a security protection authorization ID. The ID is globally unique. You can call the [ListProxyAccesses](https://www.alibabacloud.com/help/en/data-management-service/latest/listproxyaccesses) operation to obtain this parameter.
	ProxyAccessId *int64 `json:"ProxyAccessId,omitempty" xml:"ProxyAccessId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) or [ListUserTenants](https://www.alibabacloud.com/help/en/data-management-service/latest/listusertenants) operation to obtain this parameter.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s InspectProxyAccessSecretRequest) String() string {
	return tea.Prettify(s)
}

func (s InspectProxyAccessSecretRequest) GoString() string {
	return s.String()
}

func (s *InspectProxyAccessSecretRequest) SetProxyAccessId(v int64) *InspectProxyAccessSecretRequest {
	s.ProxyAccessId = &v
	return s
}

func (s *InspectProxyAccessSecretRequest) SetTid(v int64) *InspectProxyAccessSecretRequest {
	s.Tid = &v
	return s
}

type InspectProxyAccessSecretResponseBody struct {
	// The authorization password of the security protection agent.
	AccessSecret *string `json:"AccessSecret,omitempty" xml:"AccessSecret,omitempty"`
	// The error code returned to the query task.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message that is returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s InspectProxyAccessSecretResponseBody) String() string {
	return tea.Prettify(s)
}

func (s InspectProxyAccessSecretResponseBody) GoString() string {
	return s.String()
}

func (s *InspectProxyAccessSecretResponseBody) SetAccessSecret(v string) *InspectProxyAccessSecretResponseBody {
	s.AccessSecret = &v
	return s
}

func (s *InspectProxyAccessSecretResponseBody) SetErrorCode(v string) *InspectProxyAccessSecretResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *InspectProxyAccessSecretResponseBody) SetErrorMessage(v string) *InspectProxyAccessSecretResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *InspectProxyAccessSecretResponseBody) SetRequestId(v string) *InspectProxyAccessSecretResponseBody {
	s.RequestId = &v
	return s
}

func (s *InspectProxyAccessSecretResponseBody) SetSuccess(v bool) *InspectProxyAccessSecretResponseBody {
	s.Success = &v
	return s
}

type InspectProxyAccessSecretResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *InspectProxyAccessSecretResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s InspectProxyAccessSecretResponse) String() string {
	return tea.Prettify(s)
}

func (s InspectProxyAccessSecretResponse) GoString() string {
	return s.String()
}

func (s *InspectProxyAccessSecretResponse) SetHeaders(v map[string]*string) *InspectProxyAccessSecretResponse {
	s.Headers = v
	return s
}

func (s *InspectProxyAccessSecretResponse) SetStatusCode(v int32) *InspectProxyAccessSecretResponse {
	s.StatusCode = &v
	return s
}

func (s *InspectProxyAccessSecretResponse) SetBody(v *InspectProxyAccessSecretResponseBody) *InspectProxyAccessSecretResponse {
	s.Body = v
	return s
}

type ListAuthorityTemplateRequest struct {
	PageNumber *int32  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	SearchKey  *string `json:"SearchKey,omitempty" xml:"SearchKey,omitempty"`
	Tid        *int64  `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListAuthorityTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAuthorityTemplateRequest) GoString() string {
	return s.String()
}

func (s *ListAuthorityTemplateRequest) SetPageNumber(v int32) *ListAuthorityTemplateRequest {
	s.PageNumber = &v
	return s
}

func (s *ListAuthorityTemplateRequest) SetPageSize(v int32) *ListAuthorityTemplateRequest {
	s.PageSize = &v
	return s
}

func (s *ListAuthorityTemplateRequest) SetSearchKey(v string) *ListAuthorityTemplateRequest {
	s.SearchKey = &v
	return s
}

func (s *ListAuthorityTemplateRequest) SetTid(v int64) *ListAuthorityTemplateRequest {
	s.Tid = &v
	return s
}

type ListAuthorityTemplateResponseBody struct {
	AuthorityTemplateViewList *ListAuthorityTemplateResponseBodyAuthorityTemplateViewList `json:"AuthorityTemplateViewList,omitempty" xml:"AuthorityTemplateViewList,omitempty" type:"Struct"`
	ErrorCode                 *string                                                     `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage              *string                                                     `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId                 *string                                                     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success                   *bool                                                       `json:"Success,omitempty" xml:"Success,omitempty"`
	Tid                       *int64                                                      `json:"Tid,omitempty" xml:"Tid,omitempty"`
	TotalCount                *int64                                                      `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListAuthorityTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAuthorityTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *ListAuthorityTemplateResponseBody) SetAuthorityTemplateViewList(v *ListAuthorityTemplateResponseBodyAuthorityTemplateViewList) *ListAuthorityTemplateResponseBody {
	s.AuthorityTemplateViewList = v
	return s
}

func (s *ListAuthorityTemplateResponseBody) SetErrorCode(v string) *ListAuthorityTemplateResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListAuthorityTemplateResponseBody) SetErrorMessage(v string) *ListAuthorityTemplateResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListAuthorityTemplateResponseBody) SetRequestId(v string) *ListAuthorityTemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListAuthorityTemplateResponseBody) SetSuccess(v bool) *ListAuthorityTemplateResponseBody {
	s.Success = &v
	return s
}

func (s *ListAuthorityTemplateResponseBody) SetTid(v int64) *ListAuthorityTemplateResponseBody {
	s.Tid = &v
	return s
}

func (s *ListAuthorityTemplateResponseBody) SetTotalCount(v int64) *ListAuthorityTemplateResponseBody {
	s.TotalCount = &v
	return s
}

type ListAuthorityTemplateResponseBodyAuthorityTemplateViewList struct {
	AuthorityTemplateView []*ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView `json:"AuthorityTemplateView,omitempty" xml:"AuthorityTemplateView,omitempty" type:"Repeated"`
}

func (s ListAuthorityTemplateResponseBodyAuthorityTemplateViewList) String() string {
	return tea.Prettify(s)
}

func (s ListAuthorityTemplateResponseBodyAuthorityTemplateViewList) GoString() string {
	return s.String()
}

func (s *ListAuthorityTemplateResponseBodyAuthorityTemplateViewList) SetAuthorityTemplateView(v []*ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView) *ListAuthorityTemplateResponseBodyAuthorityTemplateViewList {
	s.AuthorityTemplateView = v
	return s
}

type ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView struct {
	CreateTime  *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	CreatorId   *int64  `json:"CreatorId,omitempty" xml:"CreatorId,omitempty"`
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	Name        *string `json:"Name,omitempty" xml:"Name,omitempty"`
	TemplateId  *int64  `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
}

func (s ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView) String() string {
	return tea.Prettify(s)
}

func (s ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView) GoString() string {
	return s.String()
}

func (s *ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView) SetCreateTime(v string) *ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView {
	s.CreateTime = &v
	return s
}

func (s *ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView) SetCreatorId(v int64) *ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView {
	s.CreatorId = &v
	return s
}

func (s *ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView) SetDescription(v string) *ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView {
	s.Description = &v
	return s
}

func (s *ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView) SetName(v string) *ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView {
	s.Name = &v
	return s
}

func (s *ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView) SetTemplateId(v int64) *ListAuthorityTemplateResponseBodyAuthorityTemplateViewListAuthorityTemplateView {
	s.TemplateId = &v
	return s
}

type ListAuthorityTemplateResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAuthorityTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAuthorityTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAuthorityTemplateResponse) GoString() string {
	return s.String()
}

func (s *ListAuthorityTemplateResponse) SetHeaders(v map[string]*string) *ListAuthorityTemplateResponse {
	s.Headers = v
	return s
}

func (s *ListAuthorityTemplateResponse) SetStatusCode(v int32) *ListAuthorityTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAuthorityTemplateResponse) SetBody(v *ListAuthorityTemplateResponseBody) *ListAuthorityTemplateResponse {
	s.Body = v
	return s
}

type ListClassificationTemplatesRequest struct {
	// The ID of the tenant.
	//
	// > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListClassificationTemplatesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListClassificationTemplatesRequest) GoString() string {
	return s.String()
}

func (s *ListClassificationTemplatesRequest) SetTid(v int64) *ListClassificationTemplatesRequest {
	s.Tid = &v
	return s
}

type ListClassificationTemplatesResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The list of templates.
	TemplateList []*ListClassificationTemplatesResponseBodyTemplateList `json:"TemplateList,omitempty" xml:"TemplateList,omitempty" type:"Repeated"`
}

func (s ListClassificationTemplatesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListClassificationTemplatesResponseBody) GoString() string {
	return s.String()
}

func (s *ListClassificationTemplatesResponseBody) SetErrorCode(v string) *ListClassificationTemplatesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListClassificationTemplatesResponseBody) SetErrorMessage(v string) *ListClassificationTemplatesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListClassificationTemplatesResponseBody) SetRequestId(v string) *ListClassificationTemplatesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListClassificationTemplatesResponseBody) SetSuccess(v bool) *ListClassificationTemplatesResponseBody {
	s.Success = &v
	return s
}

func (s *ListClassificationTemplatesResponseBody) SetTemplateList(v []*ListClassificationTemplatesResponseBodyTemplateList) *ListClassificationTemplatesResponseBody {
	s.TemplateList = v
	return s
}

type ListClassificationTemplatesResponseBodyTemplateList struct {
	// The name of the classification template.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The remarks.
	Remark *string `json:"Remark,omitempty" xml:"Remark,omitempty"`
	// The ID of the classification template.
	TemplateId *int64 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The type of the classification template. Valid values:
	//
	// *   **INNER**: built-in template
	// *   **USER_DEFINE**: custom template
	TemplateType *string `json:"TemplateType,omitempty" xml:"TemplateType,omitempty"`
}

func (s ListClassificationTemplatesResponseBodyTemplateList) String() string {
	return tea.Prettify(s)
}

func (s ListClassificationTemplatesResponseBodyTemplateList) GoString() string {
	return s.String()
}

func (s *ListClassificationTemplatesResponseBodyTemplateList) SetName(v string) *ListClassificationTemplatesResponseBodyTemplateList {
	s.Name = &v
	return s
}

func (s *ListClassificationTemplatesResponseBodyTemplateList) SetRemark(v string) *ListClassificationTemplatesResponseBodyTemplateList {
	s.Remark = &v
	return s
}

func (s *ListClassificationTemplatesResponseBodyTemplateList) SetTemplateId(v int64) *ListClassificationTemplatesResponseBodyTemplateList {
	s.TemplateId = &v
	return s
}

func (s *ListClassificationTemplatesResponseBodyTemplateList) SetTemplateType(v string) *ListClassificationTemplatesResponseBodyTemplateList {
	s.TemplateType = &v
	return s
}

type ListClassificationTemplatesResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListClassificationTemplatesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListClassificationTemplatesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListClassificationTemplatesResponse) GoString() string {
	return s.String()
}

func (s *ListClassificationTemplatesResponse) SetHeaders(v map[string]*string) *ListClassificationTemplatesResponse {
	s.Headers = v
	return s
}

func (s *ListClassificationTemplatesResponse) SetStatusCode(v int32) *ListClassificationTemplatesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListClassificationTemplatesResponse) SetBody(v *ListClassificationTemplatesResponseBody) *ListClassificationTemplatesResponse {
	s.Body = v
	return s
}

type ListColumnsRequest struct {
	// Specifies whether the database is a logical database. Valid values:
	//
	// *   **true**: The database is a logical database.
	// *   **false**: The database is a physical database.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The ID of the table. You can call the [ListTables](~~141878~~) operation to obtain the table ID.
	TableId *string `json:"TableId,omitempty" xml:"TableId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListColumnsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListColumnsRequest) GoString() string {
	return s.String()
}

func (s *ListColumnsRequest) SetLogic(v bool) *ListColumnsRequest {
	s.Logic = &v
	return s
}

func (s *ListColumnsRequest) SetTableId(v string) *ListColumnsRequest {
	s.TableId = &v
	return s
}

func (s *ListColumnsRequest) SetTid(v int64) *ListColumnsRequest {
	s.Tid = &v
	return s
}

type ListColumnsResponseBody struct {
	// The details about columns.
	ColumnList *ListColumnsResponseBodyColumnList `json:"ColumnList,omitempty" xml:"ColumnList,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListColumnsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListColumnsResponseBody) GoString() string {
	return s.String()
}

func (s *ListColumnsResponseBody) SetColumnList(v *ListColumnsResponseBodyColumnList) *ListColumnsResponseBody {
	s.ColumnList = v
	return s
}

func (s *ListColumnsResponseBody) SetErrorCode(v string) *ListColumnsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListColumnsResponseBody) SetErrorMessage(v string) *ListColumnsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListColumnsResponseBody) SetRequestId(v string) *ListColumnsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListColumnsResponseBody) SetSuccess(v bool) *ListColumnsResponseBody {
	s.Success = &v
	return s
}

type ListColumnsResponseBodyColumnList struct {
	Column []*ListColumnsResponseBodyColumnListColumn `json:"Column,omitempty" xml:"Column,omitempty" type:"Repeated"`
}

func (s ListColumnsResponseBodyColumnList) String() string {
	return tea.Prettify(s)
}

func (s ListColumnsResponseBodyColumnList) GoString() string {
	return s.String()
}

func (s *ListColumnsResponseBodyColumnList) SetColumn(v []*ListColumnsResponseBodyColumnListColumn) *ListColumnsResponseBodyColumnList {
	s.Column = v
	return s
}

type ListColumnsResponseBodyColumnListColumn struct {
	// Indicates whether the column is an auto-increment column. Valid values:
	//
	// *   true: The column is an auto-increment column.
	// *   false: The column is not an auto-increment column.
	AutoIncrement *bool `json:"AutoIncrement,omitempty" xml:"AutoIncrement,omitempty"`
	// The ID of the column.
	ColumnId *string `json:"ColumnId,omitempty" xml:"ColumnId,omitempty"`
	// The name of the column.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The data type of the column.
	ColumnType *string `json:"ColumnType,omitempty" xml:"ColumnType,omitempty"`
	// The length of the field.
	DataLength *int64 `json:"DataLength,omitempty" xml:"DataLength,omitempty"`
	// The number of valid digits for the field.
	DataPrecision *int32 `json:"DataPrecision,omitempty" xml:"DataPrecision,omitempty"`
	// The number of decimal places for the field.
	DataScale *int32 `json:"DataScale,omitempty" xml:"DataScale,omitempty"`
	// The default value of the column.
	DefaultValue *string `json:"DefaultValue,omitempty" xml:"DefaultValue,omitempty"`
	// The description of the column.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The type of the masking algorithm that is used for the field. Valid values:
	//
	// *   null: No masking algorithm is used.
	// *   DEFAULT: A full masking algorithm is used.
	// *   FIX_POS: The fixed position is masked.
	// *   FIX_CHAR: The fixed characters are replaced.
	FunctionType *string `json:"FunctionType,omitempty" xml:"FunctionType,omitempty"`
	// Indicates whether the column can be empty. Valid values:
	//
	// *   **true**: The column can be empty.
	// *   **false**: The column cannot be empty.
	Nullable *bool `json:"Nullable,omitempty" xml:"Nullable,omitempty"`
	// The security level of the column. Valid values:
	//
	// *   INNER: The column is an internal column but not sensitive.
	// *   SENSITIVE: The column is a sensitive column.
	// *   CONFIDENTIAL: The column is a confidential column.
	//
	// > For more information, see [Sensitivity levels of fields](~~66091~~).
	SecurityLevel *string `json:"SecurityLevel,omitempty" xml:"SecurityLevel,omitempty"`
	// Indicates whether the column is a sensitive column. Valid values:
	//
	// *   **true**: The column is a sensitive column.
	// *   **false**: The column is not a sensitive column.
	Sensitive *bool `json:"Sensitive,omitempty" xml:"Sensitive,omitempty"`
}

func (s ListColumnsResponseBodyColumnListColumn) String() string {
	return tea.Prettify(s)
}

func (s ListColumnsResponseBodyColumnListColumn) GoString() string {
	return s.String()
}

func (s *ListColumnsResponseBodyColumnListColumn) SetAutoIncrement(v bool) *ListColumnsResponseBodyColumnListColumn {
	s.AutoIncrement = &v
	return s
}

func (s *ListColumnsResponseBodyColumnListColumn) SetColumnId(v string) *ListColumnsResponseBodyColumnListColumn {
	s.ColumnId = &v
	return s
}

func (s *ListColumnsResponseBodyColumnListColumn) SetColumnName(v string) *ListColumnsResponseBodyColumnListColumn {
	s.ColumnName = &v
	return s
}

func (s *ListColumnsResponseBodyColumnListColumn) SetColumnType(v string) *ListColumnsResponseBodyColumnListColumn {
	s.ColumnType = &v
	return s
}

func (s *ListColumnsResponseBodyColumnListColumn) SetDataLength(v int64) *ListColumnsResponseBodyColumnListColumn {
	s.DataLength = &v
	return s
}

func (s *ListColumnsResponseBodyColumnListColumn) SetDataPrecision(v int32) *ListColumnsResponseBodyColumnListColumn {
	s.DataPrecision = &v
	return s
}

func (s *ListColumnsResponseBodyColumnListColumn) SetDataScale(v int32) *ListColumnsResponseBodyColumnListColumn {
	s.DataScale = &v
	return s
}

func (s *ListColumnsResponseBodyColumnListColumn) SetDefaultValue(v string) *ListColumnsResponseBodyColumnListColumn {
	s.DefaultValue = &v
	return s
}

func (s *ListColumnsResponseBodyColumnListColumn) SetDescription(v string) *ListColumnsResponseBodyColumnListColumn {
	s.Description = &v
	return s
}

func (s *ListColumnsResponseBodyColumnListColumn) SetFunctionType(v string) *ListColumnsResponseBodyColumnListColumn {
	s.FunctionType = &v
	return s
}

func (s *ListColumnsResponseBodyColumnListColumn) SetNullable(v bool) *ListColumnsResponseBodyColumnListColumn {
	s.Nullable = &v
	return s
}

func (s *ListColumnsResponseBodyColumnListColumn) SetSecurityLevel(v string) *ListColumnsResponseBodyColumnListColumn {
	s.SecurityLevel = &v
	return s
}

func (s *ListColumnsResponseBodyColumnListColumn) SetSensitive(v bool) *ListColumnsResponseBodyColumnListColumn {
	s.Sensitive = &v
	return s
}

type ListColumnsResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListColumnsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListColumnsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListColumnsResponse) GoString() string {
	return s.String()
}

func (s *ListColumnsResponse) SetHeaders(v map[string]*string) *ListColumnsResponse {
	s.Headers = v
	return s
}

func (s *ListColumnsResponse) SetStatusCode(v int32) *ListColumnsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListColumnsResponse) SetBody(v *ListColumnsResponseBody) *ListColumnsResponse {
	s.Body = v
	return s
}

type ListDAGVersionsRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the ID of the task flow.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The number of the page to return.
	PageIndex *int32 `json:"PageIndex,omitempty" xml:"PageIndex,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListDAGVersionsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDAGVersionsRequest) GoString() string {
	return s.String()
}

func (s *ListDAGVersionsRequest) SetDagId(v int64) *ListDAGVersionsRequest {
	s.DagId = &v
	return s
}

func (s *ListDAGVersionsRequest) SetPageIndex(v int32) *ListDAGVersionsRequest {
	s.PageIndex = &v
	return s
}

func (s *ListDAGVersionsRequest) SetPageSize(v int32) *ListDAGVersionsRequest {
	s.PageSize = &v
	return s
}

func (s *ListDAGVersionsRequest) SetTid(v int64) *ListDAGVersionsRequest {
	s.Tid = &v
	return s
}

type ListDAGVersionsResponseBody struct {
	// The information about the published versions.
	DagVersionList *ListDAGVersionsResponseBodyDagVersionList `json:"DagVersionList,omitempty" xml:"DagVersionList,omitempty" type:"Struct"`
	// The error code returned if the request fails.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**: The request is successful.
	// *   **false**: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListDAGVersionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDAGVersionsResponseBody) GoString() string {
	return s.String()
}

func (s *ListDAGVersionsResponseBody) SetDagVersionList(v *ListDAGVersionsResponseBodyDagVersionList) *ListDAGVersionsResponseBody {
	s.DagVersionList = v
	return s
}

func (s *ListDAGVersionsResponseBody) SetErrorCode(v string) *ListDAGVersionsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListDAGVersionsResponseBody) SetErrorMessage(v string) *ListDAGVersionsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListDAGVersionsResponseBody) SetRequestId(v string) *ListDAGVersionsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDAGVersionsResponseBody) SetSuccess(v bool) *ListDAGVersionsResponseBody {
	s.Success = &v
	return s
}

func (s *ListDAGVersionsResponseBody) SetTotalCount(v int32) *ListDAGVersionsResponseBody {
	s.TotalCount = &v
	return s
}

type ListDAGVersionsResponseBodyDagVersionList struct {
	DagVersion []*ListDAGVersionsResponseBodyDagVersionListDagVersion `json:"DagVersion,omitempty" xml:"DagVersion,omitempty" type:"Repeated"`
}

func (s ListDAGVersionsResponseBodyDagVersionList) String() string {
	return tea.Prettify(s)
}

func (s ListDAGVersionsResponseBodyDagVersionList) GoString() string {
	return s.String()
}

func (s *ListDAGVersionsResponseBodyDagVersionList) SetDagVersion(v []*ListDAGVersionsResponseBodyDagVersionListDagVersion) *ListDAGVersionsResponseBodyDagVersionList {
	s.DagVersion = v
	return s
}

type ListDAGVersionsResponseBodyDagVersionListDagVersion struct {
	// The name of the task flow.
	DagName *string `json:"DagName,omitempty" xml:"DagName,omitempty"`
	// The ID of the task flow owner.
	DagOwnerId *string `json:"DagOwnerId,omitempty" xml:"DagOwnerId,omitempty"`
	// The name of the task flow owner.
	DagOwnerNickName *string `json:"DagOwnerNickName,omitempty" xml:"DagOwnerNickName,omitempty"`
	// The ID of the previously published version.
	LastVersionId *int64 `json:"LastVersionId,omitempty" xml:"LastVersionId,omitempty"`
	// The description of the version.
	VersionComments *string `json:"VersionComments,omitempty" xml:"VersionComments,omitempty"`
	// The ID of the version.
	VersionId *int64 `json:"VersionId,omitempty" xml:"VersionId,omitempty"`
}

func (s ListDAGVersionsResponseBodyDagVersionListDagVersion) String() string {
	return tea.Prettify(s)
}

func (s ListDAGVersionsResponseBodyDagVersionListDagVersion) GoString() string {
	return s.String()
}

func (s *ListDAGVersionsResponseBodyDagVersionListDagVersion) SetDagName(v string) *ListDAGVersionsResponseBodyDagVersionListDagVersion {
	s.DagName = &v
	return s
}

func (s *ListDAGVersionsResponseBodyDagVersionListDagVersion) SetDagOwnerId(v string) *ListDAGVersionsResponseBodyDagVersionListDagVersion {
	s.DagOwnerId = &v
	return s
}

func (s *ListDAGVersionsResponseBodyDagVersionListDagVersion) SetDagOwnerNickName(v string) *ListDAGVersionsResponseBodyDagVersionListDagVersion {
	s.DagOwnerNickName = &v
	return s
}

func (s *ListDAGVersionsResponseBodyDagVersionListDagVersion) SetLastVersionId(v int64) *ListDAGVersionsResponseBodyDagVersionListDagVersion {
	s.LastVersionId = &v
	return s
}

func (s *ListDAGVersionsResponseBodyDagVersionListDagVersion) SetVersionComments(v string) *ListDAGVersionsResponseBodyDagVersionListDagVersion {
	s.VersionComments = &v
	return s
}

func (s *ListDAGVersionsResponseBodyDagVersionListDagVersion) SetVersionId(v int64) *ListDAGVersionsResponseBodyDagVersionListDagVersion {
	s.VersionId = &v
	return s
}

type ListDAGVersionsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListDAGVersionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDAGVersionsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDAGVersionsResponse) GoString() string {
	return s.String()
}

func (s *ListDAGVersionsResponse) SetHeaders(v map[string]*string) *ListDAGVersionsResponse {
	s.Headers = v
	return s
}

func (s *ListDAGVersionsResponse) SetStatusCode(v int32) *ListDAGVersionsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDAGVersionsResponse) SetBody(v *ListDAGVersionsResponseBody) *ListDAGVersionsResponse {
	s.Body = v
	return s
}

type ListDBTaskSQLJobRequest struct {
	// The ID of the SQL task group. You can call the [GetStructSyncJobDetail](~~206160~~) operation to obtain this parameter.
	DBTaskGroupId *int64 `json:"DBTaskGroupId,omitempty" xml:"DBTaskGroupId,omitempty"`
	// The number of the page to return.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the tenant.
	//
	// > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListDBTaskSQLJobRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDBTaskSQLJobRequest) GoString() string {
	return s.String()
}

func (s *ListDBTaskSQLJobRequest) SetDBTaskGroupId(v int64) *ListDBTaskSQLJobRequest {
	s.DBTaskGroupId = &v
	return s
}

func (s *ListDBTaskSQLJobRequest) SetPageNumber(v int64) *ListDBTaskSQLJobRequest {
	s.PageNumber = &v
	return s
}

func (s *ListDBTaskSQLJobRequest) SetPageSize(v int64) *ListDBTaskSQLJobRequest {
	s.PageSize = &v
	return s
}

func (s *ListDBTaskSQLJobRequest) SetTid(v int64) *ListDBTaskSQLJobRequest {
	s.Tid = &v
	return s
}

type ListDBTaskSQLJobResponseBody struct {
	// The list of the SQL tasks.
	DBTaskSQLJobList []*ListDBTaskSQLJobResponseBodyDBTaskSQLJobList `json:"DBTaskSQLJobList,omitempty" xml:"DBTaskSQLJobList,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of the SQL tasks.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListDBTaskSQLJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDBTaskSQLJobResponseBody) GoString() string {
	return s.String()
}

func (s *ListDBTaskSQLJobResponseBody) SetDBTaskSQLJobList(v []*ListDBTaskSQLJobResponseBodyDBTaskSQLJobList) *ListDBTaskSQLJobResponseBody {
	s.DBTaskSQLJobList = v
	return s
}

func (s *ListDBTaskSQLJobResponseBody) SetErrorCode(v string) *ListDBTaskSQLJobResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListDBTaskSQLJobResponseBody) SetErrorMessage(v string) *ListDBTaskSQLJobResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListDBTaskSQLJobResponseBody) SetRequestId(v string) *ListDBTaskSQLJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDBTaskSQLJobResponseBody) SetSuccess(v bool) *ListDBTaskSQLJobResponseBody {
	s.Success = &v
	return s
}

func (s *ListDBTaskSQLJobResponseBody) SetTotalCount(v int64) *ListDBTaskSQLJobResponseBody {
	s.TotalCount = &v
	return s
}

type ListDBTaskSQLJobResponseBodyDBTaskSQLJobList struct {
	// The description of the SQL task.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The time when the SQL task was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the database.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The name that is used to search for the database.
	DbSearchName *string `json:"DbSearchName,omitempty" xml:"DbSearchName,omitempty"`
	// The ID of the SQL task group.
	DbTaskGroupId *int64 `json:"DbTaskGroupId,omitempty" xml:"DbTaskGroupId,omitempty"`
	// The ID of the SQL task.
	JobId *int64 `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The type of the SQL task.
	JobType *string `json:"JobType,omitempty" xml:"JobType,omitempty"`
	// The time when the SQL task was last executed.
	LastExecTime *string `json:"LastExecTime,omitempty" xml:"LastExecTime,omitempty"`
	// Indicates whether the database is a logical database. Valid values:
	//
	// *   **true**: The database is a logical database.
	// *   **false**: The database is a logical database.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The state of the SQL task. Valid values:
	//
	// *   **INIT**: The SQL task was initialized.
	// *   **PENDING**: The SQL task waited to be run.
	// *   **BE_SCHEDULED**: The SQL task waited to be scheduled.
	// *   **FAIL**: The SQL task failed.
	// *   **SUCCESS**: The SQL task was successful.
	// *   **PAUSE**: The SQL task was paused.
	// *   **DELETE**: The SQL task was deleted.
	// *   **RUNNING**: The SQL task was being run.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// Indicates whether the SQL task is executed as a transaction. Valid values:
	//
	// *   **true**: The SQL task is executed as a transaction.
	// *   **false**: The SQL task is not executed as a transaction.
	Transactional *bool `json:"Transactional,omitempty" xml:"Transactional,omitempty"`
}

func (s ListDBTaskSQLJobResponseBodyDBTaskSQLJobList) String() string {
	return tea.Prettify(s)
}

func (s ListDBTaskSQLJobResponseBodyDBTaskSQLJobList) GoString() string {
	return s.String()
}

func (s *ListDBTaskSQLJobResponseBodyDBTaskSQLJobList) SetComment(v string) *ListDBTaskSQLJobResponseBodyDBTaskSQLJobList {
	s.Comment = &v
	return s
}

func (s *ListDBTaskSQLJobResponseBodyDBTaskSQLJobList) SetCreateTime(v string) *ListDBTaskSQLJobResponseBodyDBTaskSQLJobList {
	s.CreateTime = &v
	return s
}

func (s *ListDBTaskSQLJobResponseBodyDBTaskSQLJobList) SetDbId(v int64) *ListDBTaskSQLJobResponseBodyDBTaskSQLJobList {
	s.DbId = &v
	return s
}

func (s *ListDBTaskSQLJobResponseBodyDBTaskSQLJobList) SetDbSearchName(v string) *ListDBTaskSQLJobResponseBodyDBTaskSQLJobList {
	s.DbSearchName = &v
	return s
}

func (s *ListDBTaskSQLJobResponseBodyDBTaskSQLJobList) SetDbTaskGroupId(v int64) *ListDBTaskSQLJobResponseBodyDBTaskSQLJobList {
	s.DbTaskGroupId = &v
	return s
}

func (s *ListDBTaskSQLJobResponseBodyDBTaskSQLJobList) SetJobId(v int64) *ListDBTaskSQLJobResponseBodyDBTaskSQLJobList {
	s.JobId = &v
	return s
}

func (s *ListDBTaskSQLJobResponseBodyDBTaskSQLJobList) SetJobType(v string) *ListDBTaskSQLJobResponseBodyDBTaskSQLJobList {
	s.JobType = &v
	return s
}

func (s *ListDBTaskSQLJobResponseBodyDBTaskSQLJobList) SetLastExecTime(v string) *ListDBTaskSQLJobResponseBodyDBTaskSQLJobList {
	s.LastExecTime = &v
	return s
}

func (s *ListDBTaskSQLJobResponseBodyDBTaskSQLJobList) SetLogic(v bool) *ListDBTaskSQLJobResponseBodyDBTaskSQLJobList {
	s.Logic = &v
	return s
}

func (s *ListDBTaskSQLJobResponseBodyDBTaskSQLJobList) SetStatus(v string) *ListDBTaskSQLJobResponseBodyDBTaskSQLJobList {
	s.Status = &v
	return s
}

func (s *ListDBTaskSQLJobResponseBodyDBTaskSQLJobList) SetTransactional(v bool) *ListDBTaskSQLJobResponseBodyDBTaskSQLJobList {
	s.Transactional = &v
	return s
}

type ListDBTaskSQLJobResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListDBTaskSQLJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDBTaskSQLJobResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDBTaskSQLJobResponse) GoString() string {
	return s.String()
}

func (s *ListDBTaskSQLJobResponse) SetHeaders(v map[string]*string) *ListDBTaskSQLJobResponse {
	s.Headers = v
	return s
}

func (s *ListDBTaskSQLJobResponse) SetStatusCode(v int32) *ListDBTaskSQLJobResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDBTaskSQLJobResponse) SetBody(v *ListDBTaskSQLJobResponseBody) *ListDBTaskSQLJobResponse {
	s.Body = v
	return s
}

type ListDBTaskSQLJobDetailRequest struct {
	// The ID of the SQL task. You can call the [ListDBTaskSQLJob](~~207049~~) operation to query the SQL task ID.
	JobId *int64 `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The number of the page to return.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListDBTaskSQLJobDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDBTaskSQLJobDetailRequest) GoString() string {
	return s.String()
}

func (s *ListDBTaskSQLJobDetailRequest) SetJobId(v int64) *ListDBTaskSQLJobDetailRequest {
	s.JobId = &v
	return s
}

func (s *ListDBTaskSQLJobDetailRequest) SetPageNumber(v int64) *ListDBTaskSQLJobDetailRequest {
	s.PageNumber = &v
	return s
}

func (s *ListDBTaskSQLJobDetailRequest) SetPageSize(v int64) *ListDBTaskSQLJobDetailRequest {
	s.PageSize = &v
	return s
}

func (s *ListDBTaskSQLJobDetailRequest) SetTid(v int64) *ListDBTaskSQLJobDetailRequest {
	s.Tid = &v
	return s
}

type ListDBTaskSQLJobDetailResponseBody struct {
	// The details of SQL tasks.
	DBTaskSQLJobDetailList []*ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList `json:"DBTaskSQLJobDetailList,omitempty" xml:"DBTaskSQLJobDetailList,omitempty" type:"Repeated"`
	// The error code that is returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message that is returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**: The request is successful.
	// *   **false**: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of SQL tasks.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListDBTaskSQLJobDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDBTaskSQLJobDetailResponseBody) GoString() string {
	return s.String()
}

func (s *ListDBTaskSQLJobDetailResponseBody) SetDBTaskSQLJobDetailList(v []*ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList) *ListDBTaskSQLJobDetailResponseBody {
	s.DBTaskSQLJobDetailList = v
	return s
}

func (s *ListDBTaskSQLJobDetailResponseBody) SetErrorCode(v string) *ListDBTaskSQLJobDetailResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListDBTaskSQLJobDetailResponseBody) SetErrorMessage(v string) *ListDBTaskSQLJobDetailResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListDBTaskSQLJobDetailResponseBody) SetRequestId(v string) *ListDBTaskSQLJobDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDBTaskSQLJobDetailResponseBody) SetSuccess(v bool) *ListDBTaskSQLJobDetailResponseBody {
	s.Success = &v
	return s
}

func (s *ListDBTaskSQLJobDetailResponseBody) SetTotalCount(v int64) *ListDBTaskSQLJobDetailResponseBody {
	s.TotalCount = &v
	return s
}

type ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList struct {
	// The number of rows affected by the SQL task.
	AffectRows *int64 `json:"AffectRows,omitempty" xml:"AffectRows,omitempty"`
	// The SQL statement that was executed in the SQL task.
	CurrentSql *string `json:"CurrentSql,omitempty" xml:"CurrentSql,omitempty"`
	// The ID of the physical database.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The point in time when the SQL task ended.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The number of times that the SQL statement was executed.
	ExecuteCount *int64 `json:"ExecuteCount,omitempty" xml:"ExecuteCount,omitempty"`
	// The ID of the details of the SQL task.
	JobDetailId *int64 `json:"JobDetailId,omitempty" xml:"JobDetailId,omitempty"`
	// The ID of the SQL task.
	JobId *int64 `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The details of the operational log.
	Log *string `json:"Log,omitempty" xml:"Log,omitempty"`
	// Indicates whether the database is a logical database. Valid values:
	//
	// *   **true**: The database is a logical database.
	// *   **false**: The database is a physical database.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// Indicates whether the SQL statement was skipped. Valid values:
	//
	// *   **true**: The SQL statement was skipped.
	// *   **false**: The SQL statement was not skipped.
	Skip *bool `json:"Skip,omitempty" xml:"Skip,omitempty"`
	// The type of the SQL statement, such as DELETE, UPDATE, or ALTER_TABLE.
	SqlType *string `json:"SqlType,omitempty" xml:"SqlType,omitempty"`
	// The point in time when the SQL task started.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The status of the SQL task. Valid values:
	//
	// *   **INIT**: The SQL task was initialized.
	// *   **PENDING**: The SQL task waited to be run.
	// *   **BE_SCHEDULED**: The SQL task waited to be scheduled.
	// *   **FAIL**: The SQL task failed.
	// *   **SUCCESS**: The SQL task was successful.
	// *   **PAUSE**: The SQL task was paused.
	// *   **DELETE**: The SQL task was deleted.
	// *   **RUNNING**: The SQL task was being run.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The duration of the SQL task. Unit: milliseconds.
	TimeDelay *int64 `json:"TimeDelay,omitempty" xml:"TimeDelay,omitempty"`
}

func (s ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList) String() string {
	return tea.Prettify(s)
}

func (s ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList) GoString() string {
	return s.String()
}

func (s *ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList) SetAffectRows(v int64) *ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList {
	s.AffectRows = &v
	return s
}

func (s *ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList) SetCurrentSql(v string) *ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList {
	s.CurrentSql = &v
	return s
}

func (s *ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList) SetDbId(v int64) *ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList {
	s.DbId = &v
	return s
}

func (s *ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList) SetEndTime(v string) *ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList {
	s.EndTime = &v
	return s
}

func (s *ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList) SetExecuteCount(v int64) *ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList {
	s.ExecuteCount = &v
	return s
}

func (s *ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList) SetJobDetailId(v int64) *ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList {
	s.JobDetailId = &v
	return s
}

func (s *ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList) SetJobId(v int64) *ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList {
	s.JobId = &v
	return s
}

func (s *ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList) SetLog(v string) *ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList {
	s.Log = &v
	return s
}

func (s *ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList) SetLogic(v bool) *ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList {
	s.Logic = &v
	return s
}

func (s *ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList) SetSkip(v bool) *ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList {
	s.Skip = &v
	return s
}

func (s *ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList) SetSqlType(v string) *ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList {
	s.SqlType = &v
	return s
}

func (s *ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList) SetStartTime(v string) *ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList {
	s.StartTime = &v
	return s
}

func (s *ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList) SetStatus(v string) *ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList {
	s.Status = &v
	return s
}

func (s *ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList) SetTimeDelay(v int64) *ListDBTaskSQLJobDetailResponseBodyDBTaskSQLJobDetailList {
	s.TimeDelay = &v
	return s
}

type ListDBTaskSQLJobDetailResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListDBTaskSQLJobDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDBTaskSQLJobDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDBTaskSQLJobDetailResponse) GoString() string {
	return s.String()
}

func (s *ListDBTaskSQLJobDetailResponse) SetHeaders(v map[string]*string) *ListDBTaskSQLJobDetailResponse {
	s.Headers = v
	return s
}

func (s *ListDBTaskSQLJobDetailResponse) SetStatusCode(v int32) *ListDBTaskSQLJobDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDBTaskSQLJobDetailResponse) SetBody(v *ListDBTaskSQLJobDetailResponseBody) *ListDBTaskSQLJobDetailResponse {
	s.Body = v
	return s
}

type ListDDLPublishRecordsRequest struct {
	// The ID of the ticket.
	//
	// > You can create a schema design ticket in the Data Management (DMS) console. For more information, see [Design schemas](~~69711~~). You can also call the [CreateOrder](~~144649~~) operation to create a schema design ticket and obtain the ID of the ticket.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant.
	//
	// > To view the ID of the tenant, log on to the DMS console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListDDLPublishRecordsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDDLPublishRecordsRequest) GoString() string {
	return s.String()
}

func (s *ListDDLPublishRecordsRequest) SetOrderId(v int64) *ListDDLPublishRecordsRequest {
	s.OrderId = &v
	return s
}

func (s *ListDDLPublishRecordsRequest) SetTid(v int64) *ListDDLPublishRecordsRequest {
	s.Tid = &v
	return s
}

type ListDDLPublishRecordsResponseBody struct {
	// The details of the publishing records.
	DDLPublishRecordList []*ListDDLPublishRecordsResponseBodyDDLPublishRecordList `json:"DDLPublishRecordList,omitempty" xml:"DDLPublishRecordList,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListDDLPublishRecordsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDDLPublishRecordsResponseBody) GoString() string {
	return s.String()
}

func (s *ListDDLPublishRecordsResponseBody) SetDDLPublishRecordList(v []*ListDDLPublishRecordsResponseBodyDDLPublishRecordList) *ListDDLPublishRecordsResponseBody {
	s.DDLPublishRecordList = v
	return s
}

func (s *ListDDLPublishRecordsResponseBody) SetErrorCode(v string) *ListDDLPublishRecordsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListDDLPublishRecordsResponseBody) SetErrorMessage(v string) *ListDDLPublishRecordsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListDDLPublishRecordsResponseBody) SetRequestId(v string) *ListDDLPublishRecordsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDDLPublishRecordsResponseBody) SetSuccess(v bool) *ListDDLPublishRecordsResponseBody {
	s.Success = &v
	return s
}

type ListDDLPublishRecordsResponseBodyDDLPublishRecordList struct {
	// The time when the approval expires.
	AuditExpireTime *string `json:"AuditExpireTime,omitempty" xml:"AuditExpireTime,omitempty"`
	// The approval state of the ticket. Valid values:
	//
	// *   **EXEMPT_PASS**: The ticket passes without approval.
	// *   **TO_AUDIT**: The ticket is pending for approval.
	// *   **CANCEL**: The ticket is canceled.
	// *   **SUCCESS**: The ticket is approved.
	// *   **FAIL**: The ticket fails to pass the approval.
	AuditStatus *string `json:"AuditStatus,omitempty" xml:"AuditStatus,omitempty"`
	Comment     *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The ID of the user who creates the ticket. You can obtain the user ID by calling the [GetUser](~~147098~~) operation and querying the value of the UserId parameter. The value is not the unique ID (UID) of the Alibaba Cloud account.
	CreatorId *int64 `json:"CreatorId,omitempty" xml:"CreatorId,omitempty"`
	// Indicates whether the approval is terminated. Valid values:
	//
	// *   **true**: The approval is terminated.
	// *   **false**: The approval is not terminated.
	//
	// > Multiple reasons can terminate the approval. For example, you withdraw the application or your ticket is not approved before the specified time.
	Finality *bool `json:"Finality,omitempty" xml:"Finality,omitempty"`
	// The reason for the termination.
	FinalityReason *string `json:"FinalityReason,omitempty" xml:"FinalityReason,omitempty"`
	// The publishing state of the ticket. Valid values:
	//
	// *   **START**: The ticket is created.
	// *   **ANALYZE**: The ticket is under analysis.
	// *   **AUDIT**: The ticket is under approval.
	// *   **DISPATCH**: A task is generated for the ticket.
	// *   **SUCCESS**: The task is successful.
	PublishStatus *string `json:"PublishStatus,omitempty" xml:"PublishStatus,omitempty"`
	// The list of publishing tasks.
	PublishTaskInfoList []*ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList `json:"PublishTaskInfoList,omitempty" xml:"PublishTaskInfoList,omitempty" type:"Repeated"`
	// The risk level of the operation. Valid values:
	//
	// *   **NONE_RISK**: The operation does not have risks.
	// *   **LOW_RISK**: The operation is at low risk.
	// *   **MIDDLE_RISK**: The operation is at medium risk.
	// *   **HIGH_RISK**: The operation is at high risk.
	RiskLevel *string `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
	// The description of the publishing state.
	StatusDesc *string `json:"StatusDesc,omitempty" xml:"StatusDesc,omitempty"`
	// The ID of the approval process.
	WorkflowInstanceId *int64 `json:"WorkflowInstanceId,omitempty" xml:"WorkflowInstanceId,omitempty"`
}

func (s ListDDLPublishRecordsResponseBodyDDLPublishRecordList) String() string {
	return tea.Prettify(s)
}

func (s ListDDLPublishRecordsResponseBodyDDLPublishRecordList) GoString() string {
	return s.String()
}

func (s *ListDDLPublishRecordsResponseBodyDDLPublishRecordList) SetAuditExpireTime(v string) *ListDDLPublishRecordsResponseBodyDDLPublishRecordList {
	s.AuditExpireTime = &v
	return s
}

func (s *ListDDLPublishRecordsResponseBodyDDLPublishRecordList) SetAuditStatus(v string) *ListDDLPublishRecordsResponseBodyDDLPublishRecordList {
	s.AuditStatus = &v
	return s
}

func (s *ListDDLPublishRecordsResponseBodyDDLPublishRecordList) SetComment(v string) *ListDDLPublishRecordsResponseBodyDDLPublishRecordList {
	s.Comment = &v
	return s
}

func (s *ListDDLPublishRecordsResponseBodyDDLPublishRecordList) SetCreatorId(v int64) *ListDDLPublishRecordsResponseBodyDDLPublishRecordList {
	s.CreatorId = &v
	return s
}

func (s *ListDDLPublishRecordsResponseBodyDDLPublishRecordList) SetFinality(v bool) *ListDDLPublishRecordsResponseBodyDDLPublishRecordList {
	s.Finality = &v
	return s
}

func (s *ListDDLPublishRecordsResponseBodyDDLPublishRecordList) SetFinalityReason(v string) *ListDDLPublishRecordsResponseBodyDDLPublishRecordList {
	s.FinalityReason = &v
	return s
}

func (s *ListDDLPublishRecordsResponseBodyDDLPublishRecordList) SetPublishStatus(v string) *ListDDLPublishRecordsResponseBodyDDLPublishRecordList {
	s.PublishStatus = &v
	return s
}

func (s *ListDDLPublishRecordsResponseBodyDDLPublishRecordList) SetPublishTaskInfoList(v []*ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList) *ListDDLPublishRecordsResponseBodyDDLPublishRecordList {
	s.PublishTaskInfoList = v
	return s
}

func (s *ListDDLPublishRecordsResponseBodyDDLPublishRecordList) SetRiskLevel(v string) *ListDDLPublishRecordsResponseBodyDDLPublishRecordList {
	s.RiskLevel = &v
	return s
}

func (s *ListDDLPublishRecordsResponseBodyDDLPublishRecordList) SetStatusDesc(v string) *ListDDLPublishRecordsResponseBodyDDLPublishRecordList {
	s.StatusDesc = &v
	return s
}

func (s *ListDDLPublishRecordsResponseBodyDDLPublishRecordList) SetWorkflowInstanceId(v int64) *ListDDLPublishRecordsResponseBodyDDLPublishRecordList {
	s.WorkflowInstanceId = &v
	return s
}

type ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList struct {
	// The ID of the database.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// Indicates whether the database is a logical database. Valid values:
	//
	// *   **true**: The database is a logical database.
	// *   **false**: the database is not a logical database.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The time to publish the ticket.
	PlanTime *string `json:"PlanTime,omitempty" xml:"PlanTime,omitempty"`
	// The list of the publishing tasks.
	PublishJobList []*ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList `json:"PublishJobList,omitempty" xml:"PublishJobList,omitempty" type:"Repeated"`
	// The publishing policy. Valid values:
	//
	// *   **IMMEDIATELY**: immediately publishes the ticket.
	// *   **REGULARLY**: publishes the ticket at a scheduled time.
	PublishStrategy *string `json:"PublishStrategy,omitempty" xml:"PublishStrategy,omitempty"`
	// The description of the state.
	StatusDesc *string `json:"StatusDesc,omitempty" xml:"StatusDesc,omitempty"`
	// The state of the task.
	TaskJobStatus *string `json:"TaskJobStatus,omitempty" xml:"TaskJobStatus,omitempty"`
}

func (s ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList) String() string {
	return tea.Prettify(s)
}

func (s ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList) GoString() string {
	return s.String()
}

func (s *ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList) SetDbId(v int64) *ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList {
	s.DbId = &v
	return s
}

func (s *ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList) SetLogic(v bool) *ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList {
	s.Logic = &v
	return s
}

func (s *ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList) SetPlanTime(v string) *ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList {
	s.PlanTime = &v
	return s
}

func (s *ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList) SetPublishJobList(v []*ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList) *ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList {
	s.PublishJobList = v
	return s
}

func (s *ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList) SetPublishStrategy(v string) *ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList {
	s.PublishStrategy = &v
	return s
}

func (s *ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList) SetStatusDesc(v string) *ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList {
	s.StatusDesc = &v
	return s
}

func (s *ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList) SetTaskJobStatus(v string) *ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoList {
	s.TaskJobStatus = &v
	return s
}

type ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList struct {
	// The ID of the SQL task group.
	DBTaskGroupId *int64 `json:"DBTaskGroupId,omitempty" xml:"DBTaskGroupId,omitempty"`
	// The number of SQL statements that are executed.
	ExecuteCount *int64 `json:"ExecuteCount,omitempty" xml:"ExecuteCount,omitempty"`
	// The script for data changes.
	Scripts *string `json:"Scripts,omitempty" xml:"Scripts,omitempty"`
	// The description of the state.
	StatusDesc *string `json:"StatusDesc,omitempty" xml:"StatusDesc,omitempty"`
	// The name of the table after the change.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	// The state of the publishing task. Valid values:
	//
	// *   **NONE**: The state of the task is unknown.
	// *   **SUCCESS**: The task is successful.
	// *   **FAIL**: The task fails.
	TaskJobStatus *string `json:"TaskJobStatus,omitempty" xml:"TaskJobStatus,omitempty"`
}

func (s ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList) String() string {
	return tea.Prettify(s)
}

func (s ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList) GoString() string {
	return s.String()
}

func (s *ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList) SetDBTaskGroupId(v int64) *ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList {
	s.DBTaskGroupId = &v
	return s
}

func (s *ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList) SetExecuteCount(v int64) *ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList {
	s.ExecuteCount = &v
	return s
}

func (s *ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList) SetScripts(v string) *ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList {
	s.Scripts = &v
	return s
}

func (s *ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList) SetStatusDesc(v string) *ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList {
	s.StatusDesc = &v
	return s
}

func (s *ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList) SetTableName(v string) *ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList {
	s.TableName = &v
	return s
}

func (s *ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList) SetTaskJobStatus(v string) *ListDDLPublishRecordsResponseBodyDDLPublishRecordListPublishTaskInfoListPublishJobList {
	s.TaskJobStatus = &v
	return s
}

type ListDDLPublishRecordsResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListDDLPublishRecordsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDDLPublishRecordsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDDLPublishRecordsResponse) GoString() string {
	return s.String()
}

func (s *ListDDLPublishRecordsResponse) SetHeaders(v map[string]*string) *ListDDLPublishRecordsResponse {
	s.Headers = v
	return s
}

func (s *ListDDLPublishRecordsResponse) SetStatusCode(v int32) *ListDDLPublishRecordsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDDLPublishRecordsResponse) SetBody(v *ListDDLPublishRecordsResponseBody) *ListDDLPublishRecordsResponse {
	s.Body = v
	return s
}

type ListDataCorrectPreCheckDBRequest struct {
	// The ID of the ticket for the data change.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The number of the page to return.
	//
	// Valid values: an integer that is greater than 0.
	//
	// Default value: 1.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the ID of the tenant.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListDataCorrectPreCheckDBRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDataCorrectPreCheckDBRequest) GoString() string {
	return s.String()
}

func (s *ListDataCorrectPreCheckDBRequest) SetOrderId(v int64) *ListDataCorrectPreCheckDBRequest {
	s.OrderId = &v
	return s
}

func (s *ListDataCorrectPreCheckDBRequest) SetPageNumber(v int64) *ListDataCorrectPreCheckDBRequest {
	s.PageNumber = &v
	return s
}

func (s *ListDataCorrectPreCheckDBRequest) SetPageSize(v int64) *ListDataCorrectPreCheckDBRequest {
	s.PageSize = &v
	return s
}

func (s *ListDataCorrectPreCheckDBRequest) SetTid(v int64) *ListDataCorrectPreCheckDBRequest {
	s.Tid = &v
	return s
}

type ListDataCorrectPreCheckDBResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The information about the databases that are involved in the precheck.
	PreCheckDBList []*ListDataCorrectPreCheckDBResponseBodyPreCheckDBList `json:"PreCheckDBList,omitempty" xml:"PreCheckDBList,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListDataCorrectPreCheckDBResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDataCorrectPreCheckDBResponseBody) GoString() string {
	return s.String()
}

func (s *ListDataCorrectPreCheckDBResponseBody) SetErrorCode(v string) *ListDataCorrectPreCheckDBResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListDataCorrectPreCheckDBResponseBody) SetErrorMessage(v string) *ListDataCorrectPreCheckDBResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListDataCorrectPreCheckDBResponseBody) SetPreCheckDBList(v []*ListDataCorrectPreCheckDBResponseBodyPreCheckDBList) *ListDataCorrectPreCheckDBResponseBody {
	s.PreCheckDBList = v
	return s
}

func (s *ListDataCorrectPreCheckDBResponseBody) SetRequestId(v string) *ListDataCorrectPreCheckDBResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDataCorrectPreCheckDBResponseBody) SetSuccess(v bool) *ListDataCorrectPreCheckDBResponseBody {
	s.Success = &v
	return s
}

type ListDataCorrectPreCheckDBResponseBodyPreCheckDBList struct {
	// The ID of the database.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The name of the database.
	SearchName *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
	// The number of SQL statements.
	SqlNum *int64 `json:"SqlNum,omitempty" xml:"SqlNum,omitempty"`
}

func (s ListDataCorrectPreCheckDBResponseBodyPreCheckDBList) String() string {
	return tea.Prettify(s)
}

func (s ListDataCorrectPreCheckDBResponseBodyPreCheckDBList) GoString() string {
	return s.String()
}

func (s *ListDataCorrectPreCheckDBResponseBodyPreCheckDBList) SetDbId(v int64) *ListDataCorrectPreCheckDBResponseBodyPreCheckDBList {
	s.DbId = &v
	return s
}

func (s *ListDataCorrectPreCheckDBResponseBodyPreCheckDBList) SetSearchName(v string) *ListDataCorrectPreCheckDBResponseBodyPreCheckDBList {
	s.SearchName = &v
	return s
}

func (s *ListDataCorrectPreCheckDBResponseBodyPreCheckDBList) SetSqlNum(v int64) *ListDataCorrectPreCheckDBResponseBodyPreCheckDBList {
	s.SqlNum = &v
	return s
}

type ListDataCorrectPreCheckDBResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListDataCorrectPreCheckDBResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDataCorrectPreCheckDBResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDataCorrectPreCheckDBResponse) GoString() string {
	return s.String()
}

func (s *ListDataCorrectPreCheckDBResponse) SetHeaders(v map[string]*string) *ListDataCorrectPreCheckDBResponse {
	s.Headers = v
	return s
}

func (s *ListDataCorrectPreCheckDBResponse) SetStatusCode(v int32) *ListDataCorrectPreCheckDBResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDataCorrectPreCheckDBResponse) SetBody(v *ListDataCorrectPreCheckDBResponseBody) *ListDataCorrectPreCheckDBResponse {
	s.Body = v
	return s
}

type ListDataCorrectPreCheckSQLRequest struct {
	// The ID of the database. The database can be a physical database or a logical database.
	//
	// *   To query the ID of a physical database, call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation.
	// *   To query the ID of a logical database, call the [ListLogicDatabases](~~141874~~) or [SearchDatabase](~~141876~~) operation.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The ID of the data change ticket. You can call the [ListOrders](~~144643~~) operation to query the ID of the data change ticket.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The number of the page to return.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListDataCorrectPreCheckSQLRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDataCorrectPreCheckSQLRequest) GoString() string {
	return s.String()
}

func (s *ListDataCorrectPreCheckSQLRequest) SetDbId(v int64) *ListDataCorrectPreCheckSQLRequest {
	s.DbId = &v
	return s
}

func (s *ListDataCorrectPreCheckSQLRequest) SetOrderId(v int64) *ListDataCorrectPreCheckSQLRequest {
	s.OrderId = &v
	return s
}

func (s *ListDataCorrectPreCheckSQLRequest) SetPageNumber(v int64) *ListDataCorrectPreCheckSQLRequest {
	s.PageNumber = &v
	return s
}

func (s *ListDataCorrectPreCheckSQLRequest) SetPageSize(v int64) *ListDataCorrectPreCheckSQLRequest {
	s.PageSize = &v
	return s
}

func (s *ListDataCorrectPreCheckSQLRequest) SetTid(v int64) *ListDataCorrectPreCheckSQLRequest {
	s.Tid = &v
	return s
}

type ListDataCorrectPreCheckSQLResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The precheck information about SQL statements.
	PreCheckSQLList []*ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList `json:"PreCheckSQLList,omitempty" xml:"PreCheckSQLList,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**: The request is successful.
	// *   **false**: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListDataCorrectPreCheckSQLResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDataCorrectPreCheckSQLResponseBody) GoString() string {
	return s.String()
}

func (s *ListDataCorrectPreCheckSQLResponseBody) SetErrorCode(v string) *ListDataCorrectPreCheckSQLResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListDataCorrectPreCheckSQLResponseBody) SetErrorMessage(v string) *ListDataCorrectPreCheckSQLResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListDataCorrectPreCheckSQLResponseBody) SetPreCheckSQLList(v []*ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList) *ListDataCorrectPreCheckSQLResponseBody {
	s.PreCheckSQLList = v
	return s
}

func (s *ListDataCorrectPreCheckSQLResponseBody) SetRequestId(v string) *ListDataCorrectPreCheckSQLResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDataCorrectPreCheckSQLResponseBody) SetSuccess(v bool) *ListDataCorrectPreCheckSQLResponseBody {
	s.Success = &v
	return s
}

type ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList struct {
	// The estimated number of affected rows.
	AffectRows *int64 `json:"AffectRows,omitempty" xml:"AffectRows,omitempty"`
	// The SQL statement.
	CheckSQL *string `json:"CheckSQL,omitempty" xml:"CheckSQL,omitempty"`
	// The ID of the database.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The key that is used to query the details of optimization suggestions. You can call the [GetSQLReviewOptimizeDetail](~~265977~~) operation to query the details of optimization suggestions based on the key.
	SQLReviewQueryKey *string `json:"SQLReviewQueryKey,omitempty" xml:"SQLReviewQueryKey,omitempty"`
	// The review status of the SQL statement. Valid values:
	//
	// *   **WAITING**: The SQL statement is pending for review.
	// *   **RUNNING**: The SQL statement is being reviewed.
	// *   **IGNORE**: The SQL statement review is skipped.
	// *   **PASS**: The SQL statement passed the review.
	// *   **BLOCK**: The SQL statement failed the review.
	SqlReviewStatus *string `json:"SqlReviewStatus,omitempty" xml:"SqlReviewStatus,omitempty"`
	// The type of the SQL statement, such as DELETE, UPDATE, or ALTER_TABLE.
	SqlType *string `json:"SqlType,omitempty" xml:"SqlType,omitempty"`
	// The name of the table whose data is changed.
	TableNames *string `json:"TableNames,omitempty" xml:"TableNames,omitempty"`
}

func (s ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList) String() string {
	return tea.Prettify(s)
}

func (s ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList) GoString() string {
	return s.String()
}

func (s *ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList) SetAffectRows(v int64) *ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList {
	s.AffectRows = &v
	return s
}

func (s *ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList) SetCheckSQL(v string) *ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList {
	s.CheckSQL = &v
	return s
}

func (s *ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList) SetDbId(v int64) *ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList {
	s.DbId = &v
	return s
}

func (s *ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList) SetSQLReviewQueryKey(v string) *ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList {
	s.SQLReviewQueryKey = &v
	return s
}

func (s *ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList) SetSqlReviewStatus(v string) *ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList {
	s.SqlReviewStatus = &v
	return s
}

func (s *ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList) SetSqlType(v string) *ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList {
	s.SqlType = &v
	return s
}

func (s *ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList) SetTableNames(v string) *ListDataCorrectPreCheckSQLResponseBodyPreCheckSQLList {
	s.TableNames = &v
	return s
}

type ListDataCorrectPreCheckSQLResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListDataCorrectPreCheckSQLResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDataCorrectPreCheckSQLResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDataCorrectPreCheckSQLResponse) GoString() string {
	return s.String()
}

func (s *ListDataCorrectPreCheckSQLResponse) SetHeaders(v map[string]*string) *ListDataCorrectPreCheckSQLResponse {
	s.Headers = v
	return s
}

func (s *ListDataCorrectPreCheckSQLResponse) SetStatusCode(v int32) *ListDataCorrectPreCheckSQLResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDataCorrectPreCheckSQLResponse) SetBody(v *ListDataCorrectPreCheckSQLResponseBody) *ListDataCorrectPreCheckSQLResponse {
	s.Body = v
	return s
}

type ListDataImportSQLPreCheckDetailRequest struct {
	// The ticket ID. You can call the [ListOrders](~~144643~~) operation to query the ticket ID.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The page number. Pages start from page 1.
	PageNumer *int64 `json:"PageNumer,omitempty" xml:"PageNumer,omitempty"`
	// The number of entries per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The type of the SQL statement. Valid values:
	//
	// *   **SELECT**
	// *   **INSERT**
	// *   **DELETE**
	// *   **CREATE_TABLE**
	//
	// > You can log on to the Data Management (DMS) console and choose **Security and Specifications** > **Operation Audit** in the top navigation bar to view more types of SQL statements.
	SqlType *string `json:"SqlType,omitempty" xml:"SqlType,omitempty"`
	// The state of the ticket. If you leave this parameter empty, all the states are queried by default. Valid values:
	//
	// *   **INIT**: The ticket is being initialized.
	// *   **RUNNING**: The ticket is in progress.
	// *   **SUCCESS**: The ticket is complete.
	// *   **TIMEOUT**: The ticket is skipped due to timeout.
	// *   **FAIL**: The ticket fails.
	StatusCode *string `json:"StatusCode,omitempty" xml:"StatusCode,omitempty"`
	// The tenant ID. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListDataImportSQLPreCheckDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDataImportSQLPreCheckDetailRequest) GoString() string {
	return s.String()
}

func (s *ListDataImportSQLPreCheckDetailRequest) SetOrderId(v int64) *ListDataImportSQLPreCheckDetailRequest {
	s.OrderId = &v
	return s
}

func (s *ListDataImportSQLPreCheckDetailRequest) SetPageNumer(v int64) *ListDataImportSQLPreCheckDetailRequest {
	s.PageNumer = &v
	return s
}

func (s *ListDataImportSQLPreCheckDetailRequest) SetPageSize(v int64) *ListDataImportSQLPreCheckDetailRequest {
	s.PageSize = &v
	return s
}

func (s *ListDataImportSQLPreCheckDetailRequest) SetSqlType(v string) *ListDataImportSQLPreCheckDetailRequest {
	s.SqlType = &v
	return s
}

func (s *ListDataImportSQLPreCheckDetailRequest) SetStatusCode(v string) *ListDataImportSQLPreCheckDetailRequest {
	s.StatusCode = &v
	return s
}

func (s *ListDataImportSQLPreCheckDetailRequest) SetTid(v int64) *ListDataImportSQLPreCheckDetailRequest {
	s.Tid = &v
	return s
}

type ListDataImportSQLPreCheckDetailResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The precheck information of SQL statements.
	PreCheckSQLDetailList []*ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList `json:"PreCheckSQLDetailList,omitempty" xml:"PreCheckSQLDetailList,omitempty" type:"Repeated"`
	// The request ID. You can use the ID to locate logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The number of SQL statements.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListDataImportSQLPreCheckDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDataImportSQLPreCheckDetailResponseBody) GoString() string {
	return s.String()
}

func (s *ListDataImportSQLPreCheckDetailResponseBody) SetErrorCode(v string) *ListDataImportSQLPreCheckDetailResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListDataImportSQLPreCheckDetailResponseBody) SetErrorMessage(v string) *ListDataImportSQLPreCheckDetailResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListDataImportSQLPreCheckDetailResponseBody) SetPreCheckSQLDetailList(v []*ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList) *ListDataImportSQLPreCheckDetailResponseBody {
	s.PreCheckSQLDetailList = v
	return s
}

func (s *ListDataImportSQLPreCheckDetailResponseBody) SetRequestId(v string) *ListDataImportSQLPreCheckDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDataImportSQLPreCheckDetailResponseBody) SetSuccess(v bool) *ListDataImportSQLPreCheckDetailResponseBody {
	s.Success = &v
	return s
}

func (s *ListDataImportSQLPreCheckDetailResponseBody) SetTotalCount(v int64) *ListDataImportSQLPreCheckDetailResponseBody {
	s.TotalCount = &v
	return s
}

type ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList struct {
	// Indicates whether the precheck of the SQL statement was skipped. Valid values:
	//
	// *   **true**
	// *   **false**
	Skip *bool `json:"Skip,omitempty" xml:"Skip,omitempty"`
	// The SQL ID, which indicates the sequence number of the SQL statement. The number starts with 1.
	SqlId *int64 `json:"SqlId,omitempty" xml:"SqlId,omitempty"`
	// The type of the SQL statement, such as DELETE, UPDATE, or ALTER_TABLE.
	SqlType *string `json:"SqlType,omitempty" xml:"SqlType,omitempty"`
	// The state of the ticket. Valid values:
	//
	// *   **INIT**: The ticket was being initialized.
	// *   **RUNNING**: The ticket was in progress.
	// *   **SUCCESS**: The ticket was complete.
	// *   **TIMEOUT**: The ticket was skipped due to timeout.
	// *   **FAIL**: The ticket failed.
	StatusCode *string `json:"StatusCode,omitempty" xml:"StatusCode,omitempty"`
}

func (s ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList) String() string {
	return tea.Prettify(s)
}

func (s ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList) GoString() string {
	return s.String()
}

func (s *ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList) SetSkip(v bool) *ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList {
	s.Skip = &v
	return s
}

func (s *ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList) SetSqlId(v int64) *ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList {
	s.SqlId = &v
	return s
}

func (s *ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList) SetSqlType(v string) *ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList {
	s.SqlType = &v
	return s
}

func (s *ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList) SetStatusCode(v string) *ListDataImportSQLPreCheckDetailResponseBodyPreCheckSQLDetailList {
	s.StatusCode = &v
	return s
}

type ListDataImportSQLPreCheckDetailResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListDataImportSQLPreCheckDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDataImportSQLPreCheckDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDataImportSQLPreCheckDetailResponse) GoString() string {
	return s.String()
}

func (s *ListDataImportSQLPreCheckDetailResponse) SetHeaders(v map[string]*string) *ListDataImportSQLPreCheckDetailResponse {
	s.Headers = v
	return s
}

func (s *ListDataImportSQLPreCheckDetailResponse) SetStatusCode(v int32) *ListDataImportSQLPreCheckDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDataImportSQLPreCheckDetailResponse) SetBody(v *ListDataImportSQLPreCheckDetailResponseBody) *ListDataImportSQLPreCheckDetailResponse {
	s.Body = v
	return s
}

type ListDataImportSQLTypeRequest struct {
	// The ticket ID. You can call the [ListOrders](~~144643~~) operation to query the ticket ID.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The tenant ID. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListDataImportSQLTypeRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDataImportSQLTypeRequest) GoString() string {
	return s.String()
}

func (s *ListDataImportSQLTypeRequest) SetOrderId(v int64) *ListDataImportSQLTypeRequest {
	s.OrderId = &v
	return s
}

func (s *ListDataImportSQLTypeRequest) SetTid(v int64) *ListDataImportSQLTypeRequest {
	s.Tid = &v
	return s
}

type ListDataImportSQLTypeResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID. You can use the ID to locate logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The types of SQL statements.
	SqlTypeResult []*string `json:"SqlTypeResult,omitempty" xml:"SqlTypeResult,omitempty" type:"Repeated"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListDataImportSQLTypeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDataImportSQLTypeResponseBody) GoString() string {
	return s.String()
}

func (s *ListDataImportSQLTypeResponseBody) SetErrorCode(v string) *ListDataImportSQLTypeResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListDataImportSQLTypeResponseBody) SetErrorMessage(v string) *ListDataImportSQLTypeResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListDataImportSQLTypeResponseBody) SetRequestId(v string) *ListDataImportSQLTypeResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDataImportSQLTypeResponseBody) SetSqlTypeResult(v []*string) *ListDataImportSQLTypeResponseBody {
	s.SqlTypeResult = v
	return s
}

func (s *ListDataImportSQLTypeResponseBody) SetSuccess(v bool) *ListDataImportSQLTypeResponseBody {
	s.Success = &v
	return s
}

type ListDataImportSQLTypeResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListDataImportSQLTypeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDataImportSQLTypeResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDataImportSQLTypeResponse) GoString() string {
	return s.String()
}

func (s *ListDataImportSQLTypeResponse) SetHeaders(v map[string]*string) *ListDataImportSQLTypeResponse {
	s.Headers = v
	return s
}

func (s *ListDataImportSQLTypeResponse) SetStatusCode(v int32) *ListDataImportSQLTypeResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDataImportSQLTypeResponse) SetBody(v *ListDataImportSQLTypeResponseBody) *ListDataImportSQLTypeResponse {
	s.Body = v
	return s
}

type ListDatabaseUserPermssionsRequest struct {
	// The ID of the database.
	DbId *string `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// Specifies whether the database is a logical database.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The type of the permission. Valid values:
	//
	// *   DATABASE: permissions on databases
	// *   TABLE: permissions on tables
	// *   COLUMN: permissions on fields
	PermType *string `json:"PermType,omitempty" xml:"PermType,omitempty"`
	// The ID of the tenant.
	//
	// > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The nickname of the user.
	UserName *string `json:"UserName,omitempty" xml:"UserName,omitempty"`
}

func (s ListDatabaseUserPermssionsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDatabaseUserPermssionsRequest) GoString() string {
	return s.String()
}

func (s *ListDatabaseUserPermssionsRequest) SetDbId(v string) *ListDatabaseUserPermssionsRequest {
	s.DbId = &v
	return s
}

func (s *ListDatabaseUserPermssionsRequest) SetLogic(v bool) *ListDatabaseUserPermssionsRequest {
	s.Logic = &v
	return s
}

func (s *ListDatabaseUserPermssionsRequest) SetPageNumber(v int32) *ListDatabaseUserPermssionsRequest {
	s.PageNumber = &v
	return s
}

func (s *ListDatabaseUserPermssionsRequest) SetPageSize(v int32) *ListDatabaseUserPermssionsRequest {
	s.PageSize = &v
	return s
}

func (s *ListDatabaseUserPermssionsRequest) SetPermType(v string) *ListDatabaseUserPermssionsRequest {
	s.PermType = &v
	return s
}

func (s *ListDatabaseUserPermssionsRequest) SetTid(v int64) *ListDatabaseUserPermssionsRequest {
	s.Tid = &v
	return s
}

func (s *ListDatabaseUserPermssionsRequest) SetUserName(v string) *ListDatabaseUserPermssionsRequest {
	s.UserName = &v
	return s
}

type ListDatabaseUserPermssionsResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of entries returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The details of user permissions.
	UserPermissions *ListDatabaseUserPermssionsResponseBodyUserPermissions `json:"UserPermissions,omitempty" xml:"UserPermissions,omitempty" type:"Struct"`
}

func (s ListDatabaseUserPermssionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDatabaseUserPermssionsResponseBody) GoString() string {
	return s.String()
}

func (s *ListDatabaseUserPermssionsResponseBody) SetErrorCode(v string) *ListDatabaseUserPermssionsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListDatabaseUserPermssionsResponseBody) SetErrorMessage(v string) *ListDatabaseUserPermssionsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListDatabaseUserPermssionsResponseBody) SetRequestId(v string) *ListDatabaseUserPermssionsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDatabaseUserPermssionsResponseBody) SetSuccess(v bool) *ListDatabaseUserPermssionsResponseBody {
	s.Success = &v
	return s
}

func (s *ListDatabaseUserPermssionsResponseBody) SetTotalCount(v int64) *ListDatabaseUserPermssionsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListDatabaseUserPermssionsResponseBody) SetUserPermissions(v *ListDatabaseUserPermssionsResponseBodyUserPermissions) *ListDatabaseUserPermssionsResponseBody {
	s.UserPermissions = v
	return s
}

type ListDatabaseUserPermssionsResponseBodyUserPermissions struct {
	UserPermission []*ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission `json:"UserPermission,omitempty" xml:"UserPermission,omitempty" type:"Repeated"`
}

func (s ListDatabaseUserPermssionsResponseBodyUserPermissions) String() string {
	return tea.Prettify(s)
}

func (s ListDatabaseUserPermssionsResponseBodyUserPermissions) GoString() string {
	return s.String()
}

func (s *ListDatabaseUserPermssionsResponseBodyUserPermissions) SetUserPermission(v []*ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission) *ListDatabaseUserPermssionsResponseBodyUserPermissions {
	s.UserPermission = v
	return s
}

type ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission struct {
	// The alias of the database instance.
	Alias *string `json:"Alias,omitempty" xml:"Alias,omitempty"`
	// The name of a column.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The ID of the database.
	DbId *string `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The type of the database engine.
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The type of resources on which the user has permissions.
	DsType *string `json:"DsType,omitempty" xml:"DsType,omitempty"`
	// The type of the environment to which the database belongs.
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// Indicates whether the database is a logical database.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The details of user permissions.
	PermDetails *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetails `json:"PermDetails,omitempty" xml:"PermDetails,omitempty" type:"Struct"`
	// The name of the database.
	SchemaName *string `json:"SchemaName,omitempty" xml:"SchemaName,omitempty"`
	// The name that is used to search for the database.
	SearchName *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
	// The ID of the table.
	TableId *string `json:"TableId,omitempty" xml:"TableId,omitempty"`
	// The name of the table.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	// The ID of the user.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The nickname of the user.
	UserNickName *string `json:"UserNickName,omitempty" xml:"UserNickName,omitempty"`
}

func (s ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission) String() string {
	return tea.Prettify(s)
}

func (s ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission) GoString() string {
	return s.String()
}

func (s *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission) SetAlias(v string) *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission {
	s.Alias = &v
	return s
}

func (s *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission) SetColumnName(v string) *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission {
	s.ColumnName = &v
	return s
}

func (s *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission) SetDbId(v string) *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission {
	s.DbId = &v
	return s
}

func (s *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission) SetDbType(v string) *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission {
	s.DbType = &v
	return s
}

func (s *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission) SetDsType(v string) *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission {
	s.DsType = &v
	return s
}

func (s *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission) SetEnvType(v string) *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission {
	s.EnvType = &v
	return s
}

func (s *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission) SetInstanceId(v string) *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission {
	s.InstanceId = &v
	return s
}

func (s *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission) SetLogic(v bool) *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission {
	s.Logic = &v
	return s
}

func (s *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission) SetPermDetails(v *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetails) *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission {
	s.PermDetails = v
	return s
}

func (s *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission) SetSchemaName(v string) *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission {
	s.SchemaName = &v
	return s
}

func (s *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission) SetSearchName(v string) *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission {
	s.SearchName = &v
	return s
}

func (s *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission) SetTableId(v string) *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission {
	s.TableId = &v
	return s
}

func (s *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission) SetTableName(v string) *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission {
	s.TableName = &v
	return s
}

func (s *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission) SetUserId(v string) *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission {
	s.UserId = &v
	return s
}

func (s *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission) SetUserNickName(v string) *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermission {
	s.UserNickName = &v
	return s
}

type ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetails struct {
	PermDetail []*ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail `json:"PermDetail,omitempty" xml:"PermDetail,omitempty" type:"Repeated"`
}

func (s ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetails) String() string {
	return tea.Prettify(s)
}

func (s ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetails) GoString() string {
	return s.String()
}

func (s *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetails) SetPermDetail(v []*ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail) *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetails {
	s.PermDetail = v
	return s
}

type ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail struct {
	// The time when the permission was created.
	CreateDate *string `json:"CreateDate,omitempty" xml:"CreateDate,omitempty"`
	// The time when the permissions expire.
	ExpireDate *string `json:"ExpireDate,omitempty" xml:"ExpireDate,omitempty"`
	// The extra information. This parameter is reserved.
	ExtraData *string `json:"ExtraData,omitempty" xml:"ExtraData,omitempty"`
	// The description of the entity that authorizes the permission.
	OriginFrom *string `json:"OriginFrom,omitempty" xml:"OriginFrom,omitempty"`
	// The type of the permission. Valid values:
	//
	// *   QUERY: the query permissions
	// *   EXPORT: the export permissions
	// *   CORRECT: the change permissions
	PermType *string `json:"PermType,omitempty" xml:"PermType,omitempty"`
	// The ID of the authorization record.
	UserAccessId *string `json:"UserAccessId,omitempty" xml:"UserAccessId,omitempty"`
}

func (s ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail) String() string {
	return tea.Prettify(s)
}

func (s ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail) GoString() string {
	return s.String()
}

func (s *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail) SetCreateDate(v string) *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail {
	s.CreateDate = &v
	return s
}

func (s *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail) SetExpireDate(v string) *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail {
	s.ExpireDate = &v
	return s
}

func (s *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail) SetExtraData(v string) *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail {
	s.ExtraData = &v
	return s
}

func (s *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail) SetOriginFrom(v string) *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail {
	s.OriginFrom = &v
	return s
}

func (s *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail) SetPermType(v string) *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail {
	s.PermType = &v
	return s
}

func (s *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail) SetUserAccessId(v string) *ListDatabaseUserPermssionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail {
	s.UserAccessId = &v
	return s
}

type ListDatabaseUserPermssionsResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListDatabaseUserPermssionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDatabaseUserPermssionsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDatabaseUserPermssionsResponse) GoString() string {
	return s.String()
}

func (s *ListDatabaseUserPermssionsResponse) SetHeaders(v map[string]*string) *ListDatabaseUserPermssionsResponse {
	s.Headers = v
	return s
}

func (s *ListDatabaseUserPermssionsResponse) SetStatusCode(v int32) *ListDatabaseUserPermssionsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDatabaseUserPermssionsResponse) SetBody(v *ListDatabaseUserPermssionsResponseBody) *ListDatabaseUserPermssionsResponse {
	s.Body = v
	return s
}

type ListDatabasesRequest struct {
	// The ID of the instance. The valid value is returned if you call the ListInstances operation. The instance ID is not the ID of the RDS instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the tenant.
	//
	// > : To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListDatabasesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDatabasesRequest) GoString() string {
	return s.String()
}

func (s *ListDatabasesRequest) SetInstanceId(v string) *ListDatabasesRequest {
	s.InstanceId = &v
	return s
}

func (s *ListDatabasesRequest) SetPageNumber(v int32) *ListDatabasesRequest {
	s.PageNumber = &v
	return s
}

func (s *ListDatabasesRequest) SetPageSize(v int32) *ListDatabasesRequest {
	s.PageSize = &v
	return s
}

func (s *ListDatabasesRequest) SetTid(v int64) *ListDatabasesRequest {
	s.Tid = &v
	return s
}

type ListDatabasesResponseBody struct {
	// The details of the databases.
	DatabaseList *ListDatabasesResponseBodyDatabaseList `json:"DatabaseList,omitempty" xml:"DatabaseList,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The number of databases that belong to an instance.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListDatabasesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDatabasesResponseBody) GoString() string {
	return s.String()
}

func (s *ListDatabasesResponseBody) SetDatabaseList(v *ListDatabasesResponseBodyDatabaseList) *ListDatabasesResponseBody {
	s.DatabaseList = v
	return s
}

func (s *ListDatabasesResponseBody) SetErrorCode(v string) *ListDatabasesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListDatabasesResponseBody) SetErrorMessage(v string) *ListDatabasesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListDatabasesResponseBody) SetRequestId(v string) *ListDatabasesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDatabasesResponseBody) SetSuccess(v bool) *ListDatabasesResponseBody {
	s.Success = &v
	return s
}

func (s *ListDatabasesResponseBody) SetTotalCount(v int64) *ListDatabasesResponseBody {
	s.TotalCount = &v
	return s
}

type ListDatabasesResponseBodyDatabaseList struct {
	Database []*ListDatabasesResponseBodyDatabaseListDatabase `json:"Database,omitempty" xml:"Database,omitempty" type:"Repeated"`
}

func (s ListDatabasesResponseBodyDatabaseList) String() string {
	return tea.Prettify(s)
}

func (s ListDatabasesResponseBodyDatabaseList) GoString() string {
	return s.String()
}

func (s *ListDatabasesResponseBodyDatabaseList) SetDatabase(v []*ListDatabasesResponseBodyDatabaseListDatabase) *ListDatabasesResponseBodyDatabaseList {
	s.Database = v
	return s
}

type ListDatabasesResponseBodyDatabaseListDatabase struct {
	// The name of the catalog to which the database belongs.
	CatalogName *string `json:"CatalogName,omitempty" xml:"CatalogName,omitempty"`
	// The ID of the database.
	DatabaseId *string `json:"DatabaseId,omitempty" xml:"DatabaseId,omitempty"`
	// The type of the database engine.
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The ID of the DBA.
	DbaId *string `json:"DbaId,omitempty" xml:"DbaId,omitempty"`
	// The nickname of the Database administrator (DBA) to which the database belongs.
	DbaName *string `json:"DbaName,omitempty" xml:"DbaName,omitempty"`
	// The encoding format of the database.
	Encoding *string `json:"Encoding,omitempty" xml:"Encoding,omitempty"`
	// The type of the environment to which the database belongs.
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The endpoint of the instance to which the database belongs.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The ID of the instance to which the database belongs.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The IDs of the owners of the database.
	OwnerIdList *ListDatabasesResponseBodyDatabaseListDatabaseOwnerIdList `json:"OwnerIdList,omitempty" xml:"OwnerIdList,omitempty" type:"Struct"`
	// The nicknames of the database owners.
	OwnerNameList *ListDatabasesResponseBodyDatabaseListDatabaseOwnerNameList `json:"OwnerNameList,omitempty" xml:"OwnerNameList,omitempty" type:"Struct"`
	// The connection port of the instance to which the database belongs.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The name of the database.
	SchemaName *string `json:"SchemaName,omitempty" xml:"SchemaName,omitempty"`
	// The name that is used for searching the database.
	SearchName *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
	// The system ID (SID) of the instance to which the database belongs.
	Sid *string `json:"Sid,omitempty" xml:"Sid,omitempty"`
	// The state of the database. Valid values:
	//
	// *   NORMAL: The database is normal.
	// *   DISABLE: The database is disabled.
	// *   OFFLINE: The database is unpublished.
	// *   NOT_EXIST: The database does not exist.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s ListDatabasesResponseBodyDatabaseListDatabase) String() string {
	return tea.Prettify(s)
}

func (s ListDatabasesResponseBodyDatabaseListDatabase) GoString() string {
	return s.String()
}

func (s *ListDatabasesResponseBodyDatabaseListDatabase) SetCatalogName(v string) *ListDatabasesResponseBodyDatabaseListDatabase {
	s.CatalogName = &v
	return s
}

func (s *ListDatabasesResponseBodyDatabaseListDatabase) SetDatabaseId(v string) *ListDatabasesResponseBodyDatabaseListDatabase {
	s.DatabaseId = &v
	return s
}

func (s *ListDatabasesResponseBodyDatabaseListDatabase) SetDbType(v string) *ListDatabasesResponseBodyDatabaseListDatabase {
	s.DbType = &v
	return s
}

func (s *ListDatabasesResponseBodyDatabaseListDatabase) SetDbaId(v string) *ListDatabasesResponseBodyDatabaseListDatabase {
	s.DbaId = &v
	return s
}

func (s *ListDatabasesResponseBodyDatabaseListDatabase) SetDbaName(v string) *ListDatabasesResponseBodyDatabaseListDatabase {
	s.DbaName = &v
	return s
}

func (s *ListDatabasesResponseBodyDatabaseListDatabase) SetEncoding(v string) *ListDatabasesResponseBodyDatabaseListDatabase {
	s.Encoding = &v
	return s
}

func (s *ListDatabasesResponseBodyDatabaseListDatabase) SetEnvType(v string) *ListDatabasesResponseBodyDatabaseListDatabase {
	s.EnvType = &v
	return s
}

func (s *ListDatabasesResponseBodyDatabaseListDatabase) SetHost(v string) *ListDatabasesResponseBodyDatabaseListDatabase {
	s.Host = &v
	return s
}

func (s *ListDatabasesResponseBodyDatabaseListDatabase) SetInstanceId(v string) *ListDatabasesResponseBodyDatabaseListDatabase {
	s.InstanceId = &v
	return s
}

func (s *ListDatabasesResponseBodyDatabaseListDatabase) SetOwnerIdList(v *ListDatabasesResponseBodyDatabaseListDatabaseOwnerIdList) *ListDatabasesResponseBodyDatabaseListDatabase {
	s.OwnerIdList = v
	return s
}

func (s *ListDatabasesResponseBodyDatabaseListDatabase) SetOwnerNameList(v *ListDatabasesResponseBodyDatabaseListDatabaseOwnerNameList) *ListDatabasesResponseBodyDatabaseListDatabase {
	s.OwnerNameList = v
	return s
}

func (s *ListDatabasesResponseBodyDatabaseListDatabase) SetPort(v int32) *ListDatabasesResponseBodyDatabaseListDatabase {
	s.Port = &v
	return s
}

func (s *ListDatabasesResponseBodyDatabaseListDatabase) SetSchemaName(v string) *ListDatabasesResponseBodyDatabaseListDatabase {
	s.SchemaName = &v
	return s
}

func (s *ListDatabasesResponseBodyDatabaseListDatabase) SetSearchName(v string) *ListDatabasesResponseBodyDatabaseListDatabase {
	s.SearchName = &v
	return s
}

func (s *ListDatabasesResponseBodyDatabaseListDatabase) SetSid(v string) *ListDatabasesResponseBodyDatabaseListDatabase {
	s.Sid = &v
	return s
}

func (s *ListDatabasesResponseBodyDatabaseListDatabase) SetState(v string) *ListDatabasesResponseBodyDatabaseListDatabase {
	s.State = &v
	return s
}

type ListDatabasesResponseBodyDatabaseListDatabaseOwnerIdList struct {
	OwnerIds []*string `json:"OwnerIds,omitempty" xml:"OwnerIds,omitempty" type:"Repeated"`
}

func (s ListDatabasesResponseBodyDatabaseListDatabaseOwnerIdList) String() string {
	return tea.Prettify(s)
}

func (s ListDatabasesResponseBodyDatabaseListDatabaseOwnerIdList) GoString() string {
	return s.String()
}

func (s *ListDatabasesResponseBodyDatabaseListDatabaseOwnerIdList) SetOwnerIds(v []*string) *ListDatabasesResponseBodyDatabaseListDatabaseOwnerIdList {
	s.OwnerIds = v
	return s
}

type ListDatabasesResponseBodyDatabaseListDatabaseOwnerNameList struct {
	OwnerNames []*string `json:"OwnerNames,omitempty" xml:"OwnerNames,omitempty" type:"Repeated"`
}

func (s ListDatabasesResponseBodyDatabaseListDatabaseOwnerNameList) String() string {
	return tea.Prettify(s)
}

func (s ListDatabasesResponseBodyDatabaseListDatabaseOwnerNameList) GoString() string {
	return s.String()
}

func (s *ListDatabasesResponseBodyDatabaseListDatabaseOwnerNameList) SetOwnerNames(v []*string) *ListDatabasesResponseBodyDatabaseListDatabaseOwnerNameList {
	s.OwnerNames = v
	return s
}

type ListDatabasesResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListDatabasesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDatabasesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDatabasesResponse) GoString() string {
	return s.String()
}

func (s *ListDatabasesResponse) SetHeaders(v map[string]*string) *ListDatabasesResponse {
	s.Headers = v
	return s
}

func (s *ListDatabasesResponse) SetStatusCode(v int32) *ListDatabasesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDatabasesResponse) SetBody(v *ListDatabasesResponseBody) *ListDatabasesResponse {
	s.Body = v
	return s
}

type ListDefaultSLARulesRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the tenant.
	//
	// > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListDefaultSLARulesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDefaultSLARulesRequest) GoString() string {
	return s.String()
}

func (s *ListDefaultSLARulesRequest) SetDagId(v int64) *ListDefaultSLARulesRequest {
	s.DagId = &v
	return s
}

func (s *ListDefaultSLARulesRequest) SetTid(v int64) *ListDefaultSLARulesRequest {
	s.Tid = &v
	return s
}

type ListDefaultSLARulesResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of SLA rules.
	SLARuleList *ListDefaultSLARulesResponseBodySLARuleList `json:"SLARuleList,omitempty" xml:"SLARuleList,omitempty" type:"Struct"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListDefaultSLARulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDefaultSLARulesResponseBody) GoString() string {
	return s.String()
}

func (s *ListDefaultSLARulesResponseBody) SetErrorCode(v string) *ListDefaultSLARulesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListDefaultSLARulesResponseBody) SetErrorMessage(v string) *ListDefaultSLARulesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListDefaultSLARulesResponseBody) SetRequestId(v string) *ListDefaultSLARulesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDefaultSLARulesResponseBody) SetSLARuleList(v *ListDefaultSLARulesResponseBodySLARuleList) *ListDefaultSLARulesResponseBody {
	s.SLARuleList = v
	return s
}

func (s *ListDefaultSLARulesResponseBody) SetSuccess(v bool) *ListDefaultSLARulesResponseBody {
	s.Success = &v
	return s
}

type ListDefaultSLARulesResponseBodySLARuleList struct {
	SLARule []*ListDefaultSLARulesResponseBodySLARuleListSLARule `json:"SLARule,omitempty" xml:"SLARule,omitempty" type:"Repeated"`
}

func (s ListDefaultSLARulesResponseBodySLARuleList) String() string {
	return tea.Prettify(s)
}

func (s ListDefaultSLARulesResponseBodySLARuleList) GoString() string {
	return s.String()
}

func (s *ListDefaultSLARulesResponseBodySLARuleList) SetSLARule(v []*ListDefaultSLARulesResponseBodySLARuleListSLARule) *ListDefaultSLARulesResponseBodySLARuleList {
	s.SLARule = v
	return s
}

type ListDefaultSLARulesResponseBodySLARuleListSLARule struct {
	// The ID of the task flow.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the SLA rule.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The timeout period. Unit: minutes.
	IntervalMinutes *int32 `json:"IntervalMinutes,omitempty" xml:"IntervalMinutes,omitempty"`
	// The ID of the task node.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The type of the rule. Valid values:
	//
	// *   **0**: an SLA rule for a task flow
	// *   **1**: an SLA rule for a task node
	RuleType *int32 `json:"RuleType,omitempty" xml:"RuleType,omitempty"`
}

func (s ListDefaultSLARulesResponseBodySLARuleListSLARule) String() string {
	return tea.Prettify(s)
}

func (s ListDefaultSLARulesResponseBodySLARuleListSLARule) GoString() string {
	return s.String()
}

func (s *ListDefaultSLARulesResponseBodySLARuleListSLARule) SetDagId(v int64) *ListDefaultSLARulesResponseBodySLARuleListSLARule {
	s.DagId = &v
	return s
}

func (s *ListDefaultSLARulesResponseBodySLARuleListSLARule) SetId(v int64) *ListDefaultSLARulesResponseBodySLARuleListSLARule {
	s.Id = &v
	return s
}

func (s *ListDefaultSLARulesResponseBodySLARuleListSLARule) SetIntervalMinutes(v int32) *ListDefaultSLARulesResponseBodySLARuleListSLARule {
	s.IntervalMinutes = &v
	return s
}

func (s *ListDefaultSLARulesResponseBodySLARuleListSLARule) SetNodeId(v int64) *ListDefaultSLARulesResponseBodySLARuleListSLARule {
	s.NodeId = &v
	return s
}

func (s *ListDefaultSLARulesResponseBodySLARuleListSLARule) SetRuleType(v int32) *ListDefaultSLARulesResponseBodySLARuleListSLARule {
	s.RuleType = &v
	return s
}

type ListDefaultSLARulesResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListDefaultSLARulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDefaultSLARulesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDefaultSLARulesResponse) GoString() string {
	return s.String()
}

func (s *ListDefaultSLARulesResponse) SetHeaders(v map[string]*string) *ListDefaultSLARulesResponse {
	s.Headers = v
	return s
}

func (s *ListDefaultSLARulesResponse) SetStatusCode(v int32) *ListDefaultSLARulesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDefaultSLARulesResponse) SetBody(v *ListDefaultSLARulesResponseBody) *ListDefaultSLARulesResponse {
	s.Body = v
	return s
}

type ListDesensitizationRuleRequest struct {
	// The type of the masking algorithm.
	FuncType *string `json:"FuncType,omitempty" xml:"FuncType,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. The maximum value is 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the masking rule.
	RuleId *int32 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	// The name of the masking rule.
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	// The algorithm used for masking.
	RuleType *string `json:"RuleType,omitempty" xml:"RuleType,omitempty"`
	// The ID of the tenant.
	//
	// >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListDesensitizationRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDesensitizationRuleRequest) GoString() string {
	return s.String()
}

func (s *ListDesensitizationRuleRequest) SetFuncType(v string) *ListDesensitizationRuleRequest {
	s.FuncType = &v
	return s
}

func (s *ListDesensitizationRuleRequest) SetPageNumber(v int32) *ListDesensitizationRuleRequest {
	s.PageNumber = &v
	return s
}

func (s *ListDesensitizationRuleRequest) SetPageSize(v int32) *ListDesensitizationRuleRequest {
	s.PageSize = &v
	return s
}

func (s *ListDesensitizationRuleRequest) SetRuleId(v int32) *ListDesensitizationRuleRequest {
	s.RuleId = &v
	return s
}

func (s *ListDesensitizationRuleRequest) SetRuleName(v string) *ListDesensitizationRuleRequest {
	s.RuleName = &v
	return s
}

func (s *ListDesensitizationRuleRequest) SetRuleType(v string) *ListDesensitizationRuleRequest {
	s.RuleType = &v
	return s
}

func (s *ListDesensitizationRuleRequest) SetTid(v int64) *ListDesensitizationRuleRequest {
	s.Tid = &v
	return s
}

type ListDesensitizationRuleResponseBody struct {
	// The list of masking rules.
	DesensitizationRuleList []*ListDesensitizationRuleResponseBodyDesensitizationRuleList `json:"DesensitizationRuleList,omitempty" xml:"DesensitizationRuleList,omitempty" type:"Repeated"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of entries returned. By default, this parameter is not returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListDesensitizationRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDesensitizationRuleResponseBody) GoString() string {
	return s.String()
}

func (s *ListDesensitizationRuleResponseBody) SetDesensitizationRuleList(v []*ListDesensitizationRuleResponseBodyDesensitizationRuleList) *ListDesensitizationRuleResponseBody {
	s.DesensitizationRuleList = v
	return s
}

func (s *ListDesensitizationRuleResponseBody) SetErrorCode(v string) *ListDesensitizationRuleResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListDesensitizationRuleResponseBody) SetErrorMessage(v string) *ListDesensitizationRuleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListDesensitizationRuleResponseBody) SetRequestId(v string) *ListDesensitizationRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDesensitizationRuleResponseBody) SetSuccess(v bool) *ListDesensitizationRuleResponseBody {
	s.Success = &v
	return s
}

func (s *ListDesensitizationRuleResponseBody) SetTotalCount(v int32) *ListDesensitizationRuleResponseBody {
	s.TotalCount = &v
	return s
}

type ListDesensitizationRuleResponseBodyDesensitizationRuleList struct {
	// The parameter.
	FuncParams *string `json:"FuncParams,omitempty" xml:"FuncParams,omitempty"`
	// The example.
	FuncSample *string `json:"FuncSample,omitempty" xml:"FuncSample,omitempty"`
	// The algorithm type.
	FunctionType *string `json:"FunctionType,omitempty" xml:"FunctionType,omitempty"`
	// The ID of the user who last modified the masking rule.
	LastModifierId *string `json:"LastModifierId,omitempty" xml:"LastModifierId,omitempty"`
	// The name of the user who last modified the masking rule.
	LastModifierName *string `json:"LastModifierName,omitempty" xml:"LastModifierName,omitempty"`
	// The number of times that the masking was used.
	ReferenceCount *int32 `json:"ReferenceCount,omitempty" xml:"ReferenceCount,omitempty"`
	// The description of the rule.
	RuleDesc *string `json:"RuleDesc,omitempty" xml:"RuleDesc,omitempty"`
	// The ID of the masking rule.
	RuleId *int32 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	// The name of the masking rule.
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	// The algorithm used for masking.
	RuleType *string `json:"RuleType,omitempty" xml:"RuleType,omitempty"`
}

func (s ListDesensitizationRuleResponseBodyDesensitizationRuleList) String() string {
	return tea.Prettify(s)
}

func (s ListDesensitizationRuleResponseBodyDesensitizationRuleList) GoString() string {
	return s.String()
}

func (s *ListDesensitizationRuleResponseBodyDesensitizationRuleList) SetFuncParams(v string) *ListDesensitizationRuleResponseBodyDesensitizationRuleList {
	s.FuncParams = &v
	return s
}

func (s *ListDesensitizationRuleResponseBodyDesensitizationRuleList) SetFuncSample(v string) *ListDesensitizationRuleResponseBodyDesensitizationRuleList {
	s.FuncSample = &v
	return s
}

func (s *ListDesensitizationRuleResponseBodyDesensitizationRuleList) SetFunctionType(v string) *ListDesensitizationRuleResponseBodyDesensitizationRuleList {
	s.FunctionType = &v
	return s
}

func (s *ListDesensitizationRuleResponseBodyDesensitizationRuleList) SetLastModifierId(v string) *ListDesensitizationRuleResponseBodyDesensitizationRuleList {
	s.LastModifierId = &v
	return s
}

func (s *ListDesensitizationRuleResponseBodyDesensitizationRuleList) SetLastModifierName(v string) *ListDesensitizationRuleResponseBodyDesensitizationRuleList {
	s.LastModifierName = &v
	return s
}

func (s *ListDesensitizationRuleResponseBodyDesensitizationRuleList) SetReferenceCount(v int32) *ListDesensitizationRuleResponseBodyDesensitizationRuleList {
	s.ReferenceCount = &v
	return s
}

func (s *ListDesensitizationRuleResponseBodyDesensitizationRuleList) SetRuleDesc(v string) *ListDesensitizationRuleResponseBodyDesensitizationRuleList {
	s.RuleDesc = &v
	return s
}

func (s *ListDesensitizationRuleResponseBodyDesensitizationRuleList) SetRuleId(v int32) *ListDesensitizationRuleResponseBodyDesensitizationRuleList {
	s.RuleId = &v
	return s
}

func (s *ListDesensitizationRuleResponseBodyDesensitizationRuleList) SetRuleName(v string) *ListDesensitizationRuleResponseBodyDesensitizationRuleList {
	s.RuleName = &v
	return s
}

func (s *ListDesensitizationRuleResponseBodyDesensitizationRuleList) SetRuleType(v string) *ListDesensitizationRuleResponseBodyDesensitizationRuleList {
	s.RuleType = &v
	return s
}

type ListDesensitizationRuleResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListDesensitizationRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDesensitizationRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDesensitizationRuleResponse) GoString() string {
	return s.String()
}

func (s *ListDesensitizationRuleResponse) SetHeaders(v map[string]*string) *ListDesensitizationRuleResponse {
	s.Headers = v
	return s
}

func (s *ListDesensitizationRuleResponse) SetStatusCode(v int32) *ListDesensitizationRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDesensitizationRuleResponse) SetBody(v *ListDesensitizationRuleResponseBody) *ListDesensitizationRuleResponse {
	s.Body = v
	return s
}

type ListEffectiveOrdersRequest struct {
	// The ID of the tenant.
	//
	// > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListEffectiveOrdersRequest) String() string {
	return tea.Prettify(s)
}

func (s ListEffectiveOrdersRequest) GoString() string {
	return s.String()
}

func (s *ListEffectiveOrdersRequest) SetTid(v int64) *ListEffectiveOrdersRequest {
	s.Tid = &v
	return s
}

type ListEffectiveOrdersResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The information about orders.
	OrderSummary []*ListEffectiveOrdersResponseBodyOrderSummary `json:"OrderSummary,omitempty" xml:"OrderSummary,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListEffectiveOrdersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListEffectiveOrdersResponseBody) GoString() string {
	return s.String()
}

func (s *ListEffectiveOrdersResponseBody) SetErrorCode(v string) *ListEffectiveOrdersResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListEffectiveOrdersResponseBody) SetErrorMessage(v string) *ListEffectiveOrdersResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListEffectiveOrdersResponseBody) SetOrderSummary(v []*ListEffectiveOrdersResponseBodyOrderSummary) *ListEffectiveOrdersResponseBody {
	s.OrderSummary = v
	return s
}

func (s *ListEffectiveOrdersResponseBody) SetRequestId(v string) *ListEffectiveOrdersResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListEffectiveOrdersResponseBody) SetSuccess(v bool) *ListEffectiveOrdersResponseBody {
	s.Success = &v
	return s
}

type ListEffectiveOrdersResponseBodyOrderSummary struct {
	// The commodity code of DMS.
	//
	// *   dms_pre_public_cn: DMS that uses the subscription billing method
	// *   dms_post_public_cn: DMS that uses the pay-as-you-go billing method
	CommodityCode *string `json:"CommodityCode,omitempty" xml:"CommodityCode,omitempty"`
	// The type of the service.
	//
	// *   **VersionType**: DMS that supports control modes
	// *   **SensitiveDataProtection**: DMS that supports sensitive data protection
	CommodityType *string `json:"CommodityType,omitempty" xml:"CommodityType,omitempty"`
	// Details about the orders.
	OrderList []*ListEffectiveOrdersResponseBodyOrderSummaryOrderList `json:"OrderList,omitempty" xml:"OrderList,omitempty" type:"Repeated"`
	// The sum of the number of instances that you can use DMS to manage in all orders.
	TotalQuota *int32 `json:"TotalQuota,omitempty" xml:"TotalQuota,omitempty"`
	// The control mode of DMS. Valid values:
	//
	// *   **stand**: Stable Change
	// *   **safety**: Security Collaboration
	VersionType *string `json:"VersionType,omitempty" xml:"VersionType,omitempty"`
}

func (s ListEffectiveOrdersResponseBodyOrderSummary) String() string {
	return tea.Prettify(s)
}

func (s ListEffectiveOrdersResponseBodyOrderSummary) GoString() string {
	return s.String()
}

func (s *ListEffectiveOrdersResponseBodyOrderSummary) SetCommodityCode(v string) *ListEffectiveOrdersResponseBodyOrderSummary {
	s.CommodityCode = &v
	return s
}

func (s *ListEffectiveOrdersResponseBodyOrderSummary) SetCommodityType(v string) *ListEffectiveOrdersResponseBodyOrderSummary {
	s.CommodityType = &v
	return s
}

func (s *ListEffectiveOrdersResponseBodyOrderSummary) SetOrderList(v []*ListEffectiveOrdersResponseBodyOrderSummaryOrderList) *ListEffectiveOrdersResponseBodyOrderSummary {
	s.OrderList = v
	return s
}

func (s *ListEffectiveOrdersResponseBodyOrderSummary) SetTotalQuota(v int32) *ListEffectiveOrdersResponseBodyOrderSummary {
	s.TotalQuota = &v
	return s
}

func (s *ListEffectiveOrdersResponseBodyOrderSummary) SetVersionType(v string) *ListEffectiveOrdersResponseBodyOrderSummary {
	s.VersionType = &v
	return s
}

type ListEffectiveOrdersResponseBodyOrderSummaryOrderList struct {
	// The UID of the user who placed the order.
	BuyerId *string `json:"BuyerId,omitempty" xml:"BuyerId,omitempty"`
	// The time when the instance expires.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The maximum number of database instances that you can use DMS to manage.
	InsNum *string `json:"InsNum,omitempty" xml:"InsNum,omitempty"`
	// The ID of the instance for the purchased service.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the order.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The time when the instance is started.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s ListEffectiveOrdersResponseBodyOrderSummaryOrderList) String() string {
	return tea.Prettify(s)
}

func (s ListEffectiveOrdersResponseBodyOrderSummaryOrderList) GoString() string {
	return s.String()
}

func (s *ListEffectiveOrdersResponseBodyOrderSummaryOrderList) SetBuyerId(v string) *ListEffectiveOrdersResponseBodyOrderSummaryOrderList {
	s.BuyerId = &v
	return s
}

func (s *ListEffectiveOrdersResponseBodyOrderSummaryOrderList) SetEndTime(v string) *ListEffectiveOrdersResponseBodyOrderSummaryOrderList {
	s.EndTime = &v
	return s
}

func (s *ListEffectiveOrdersResponseBodyOrderSummaryOrderList) SetInsNum(v string) *ListEffectiveOrdersResponseBodyOrderSummaryOrderList {
	s.InsNum = &v
	return s
}

func (s *ListEffectiveOrdersResponseBodyOrderSummaryOrderList) SetInstanceId(v string) *ListEffectiveOrdersResponseBodyOrderSummaryOrderList {
	s.InstanceId = &v
	return s
}

func (s *ListEffectiveOrdersResponseBodyOrderSummaryOrderList) SetOrderId(v string) *ListEffectiveOrdersResponseBodyOrderSummaryOrderList {
	s.OrderId = &v
	return s
}

func (s *ListEffectiveOrdersResponseBodyOrderSummaryOrderList) SetStartTime(v string) *ListEffectiveOrdersResponseBodyOrderSummaryOrderList {
	s.StartTime = &v
	return s
}

type ListEffectiveOrdersResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListEffectiveOrdersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListEffectiveOrdersResponse) String() string {
	return tea.Prettify(s)
}

func (s ListEffectiveOrdersResponse) GoString() string {
	return s.String()
}

func (s *ListEffectiveOrdersResponse) SetHeaders(v map[string]*string) *ListEffectiveOrdersResponse {
	s.Headers = v
	return s
}

func (s *ListEffectiveOrdersResponse) SetStatusCode(v int32) *ListEffectiveOrdersResponse {
	s.StatusCode = &v
	return s
}

func (s *ListEffectiveOrdersResponse) SetBody(v *ListEffectiveOrdersResponseBody) *ListEffectiveOrdersResponse {
	s.Body = v
	return s
}

type ListIndexesRequest struct {
	// Specifies whether the table is a logical table.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The ID of the table.
	TableId *string `json:"TableId,omitempty" xml:"TableId,omitempty"`
	// The ID of the tenant.
	//
	// > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListIndexesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListIndexesRequest) GoString() string {
	return s.String()
}

func (s *ListIndexesRequest) SetLogic(v bool) *ListIndexesRequest {
	s.Logic = &v
	return s
}

func (s *ListIndexesRequest) SetTableId(v string) *ListIndexesRequest {
	s.TableId = &v
	return s
}

func (s *ListIndexesRequest) SetTid(v int64) *ListIndexesRequest {
	s.Tid = &v
	return s
}

type ListIndexesResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The details of indexes.
	IndexList *ListIndexesResponseBodyIndexList `json:"IndexList,omitempty" xml:"IndexList,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListIndexesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListIndexesResponseBody) GoString() string {
	return s.String()
}

func (s *ListIndexesResponseBody) SetErrorCode(v string) *ListIndexesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListIndexesResponseBody) SetErrorMessage(v string) *ListIndexesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListIndexesResponseBody) SetIndexList(v *ListIndexesResponseBodyIndexList) *ListIndexesResponseBody {
	s.IndexList = v
	return s
}

func (s *ListIndexesResponseBody) SetRequestId(v string) *ListIndexesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListIndexesResponseBody) SetSuccess(v bool) *ListIndexesResponseBody {
	s.Success = &v
	return s
}

type ListIndexesResponseBodyIndexList struct {
	Index []*ListIndexesResponseBodyIndexListIndex `json:"Index,omitempty" xml:"Index,omitempty" type:"Repeated"`
}

func (s ListIndexesResponseBodyIndexList) String() string {
	return tea.Prettify(s)
}

func (s ListIndexesResponseBodyIndexList) GoString() string {
	return s.String()
}

func (s *ListIndexesResponseBodyIndexList) SetIndex(v []*ListIndexesResponseBodyIndexListIndex) *ListIndexesResponseBodyIndexList {
	s.Index = v
	return s
}

type ListIndexesResponseBodyIndexListIndex struct {
	// The description of the index.
	IndexComment *string `json:"IndexComment,omitempty" xml:"IndexComment,omitempty"`
	// The ID of the index.
	IndexId *string `json:"IndexId,omitempty" xml:"IndexId,omitempty"`
	// The name of the index.
	IndexName *string `json:"IndexName,omitempty" xml:"IndexName,omitempty"`
	// The type of the index. Valid values:
	//
	// *   Primary
	// *   Unique
	// *   Normal
	// *   FullText
	// *   Spatial
	IndexType *string `json:"IndexType,omitempty" xml:"IndexType,omitempty"`
	// The ID of the table.
	TableId *string `json:"TableId,omitempty" xml:"TableId,omitempty"`
}

func (s ListIndexesResponseBodyIndexListIndex) String() string {
	return tea.Prettify(s)
}

func (s ListIndexesResponseBodyIndexListIndex) GoString() string {
	return s.String()
}

func (s *ListIndexesResponseBodyIndexListIndex) SetIndexComment(v string) *ListIndexesResponseBodyIndexListIndex {
	s.IndexComment = &v
	return s
}

func (s *ListIndexesResponseBodyIndexListIndex) SetIndexId(v string) *ListIndexesResponseBodyIndexListIndex {
	s.IndexId = &v
	return s
}

func (s *ListIndexesResponseBodyIndexListIndex) SetIndexName(v string) *ListIndexesResponseBodyIndexListIndex {
	s.IndexName = &v
	return s
}

func (s *ListIndexesResponseBodyIndexListIndex) SetIndexType(v string) *ListIndexesResponseBodyIndexListIndex {
	s.IndexType = &v
	return s
}

func (s *ListIndexesResponseBodyIndexListIndex) SetTableId(v string) *ListIndexesResponseBodyIndexListIndex {
	s.TableId = &v
	return s
}

type ListIndexesResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListIndexesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListIndexesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListIndexesResponse) GoString() string {
	return s.String()
}

func (s *ListIndexesResponse) SetHeaders(v map[string]*string) *ListIndexesResponse {
	s.Headers = v
	return s
}

func (s *ListIndexesResponse) SetStatusCode(v int32) *ListIndexesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListIndexesResponse) SetBody(v *ListIndexesResponseBody) *ListIndexesResponse {
	s.Body = v
	return s
}

type ListInstanceLoginAuditLogRequest struct {
	// The end of the time range to query.
	//
	// >  The end time supports fuzzy match. Specify the time in the YYYY-MM-DD hh:mm:ss format. We recommend that you use the StartTime and EndTime parameters to specify a time range that does not exceed one day. This way, the returned entries can be displayed by page to increase query efficiency.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The alias of the user.
	OpUserName *string `json:"OpUserName,omitempty" xml:"OpUserName,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The name of the database or instance whose logon records you want to query.
	//
	// >  If SQL statements are executed at the instance level, you can set this parameter to an instance name. If SQL statements are executed at the database level, you can set this parameter to a database name.
	SearchName *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
	// The beginning of the time range to query.
	//
	// >  The start time supports fuzzy match. Specify the time in the YYYY-MM-DD hh:mm:ss format.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListInstanceLoginAuditLogRequest) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceLoginAuditLogRequest) GoString() string {
	return s.String()
}

func (s *ListInstanceLoginAuditLogRequest) SetEndTime(v string) *ListInstanceLoginAuditLogRequest {
	s.EndTime = &v
	return s
}

func (s *ListInstanceLoginAuditLogRequest) SetOpUserName(v string) *ListInstanceLoginAuditLogRequest {
	s.OpUserName = &v
	return s
}

func (s *ListInstanceLoginAuditLogRequest) SetPageNumber(v int32) *ListInstanceLoginAuditLogRequest {
	s.PageNumber = &v
	return s
}

func (s *ListInstanceLoginAuditLogRequest) SetPageSize(v int32) *ListInstanceLoginAuditLogRequest {
	s.PageSize = &v
	return s
}

func (s *ListInstanceLoginAuditLogRequest) SetSearchName(v string) *ListInstanceLoginAuditLogRequest {
	s.SearchName = &v
	return s
}

func (s *ListInstanceLoginAuditLogRequest) SetStartTime(v string) *ListInstanceLoginAuditLogRequest {
	s.StartTime = &v
	return s
}

func (s *ListInstanceLoginAuditLogRequest) SetTid(v int64) *ListInstanceLoginAuditLogRequest {
	s.Tid = &v
	return s
}

type ListInstanceLoginAuditLogResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The logon records of the instance.
	InstanceLoginAuditLogList *ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogList `json:"InstanceLoginAuditLogList,omitempty" xml:"InstanceLoginAuditLogList,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The number of entries returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListInstanceLoginAuditLogResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceLoginAuditLogResponseBody) GoString() string {
	return s.String()
}

func (s *ListInstanceLoginAuditLogResponseBody) SetErrorCode(v string) *ListInstanceLoginAuditLogResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListInstanceLoginAuditLogResponseBody) SetErrorMessage(v string) *ListInstanceLoginAuditLogResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListInstanceLoginAuditLogResponseBody) SetInstanceLoginAuditLogList(v *ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogList) *ListInstanceLoginAuditLogResponseBody {
	s.InstanceLoginAuditLogList = v
	return s
}

func (s *ListInstanceLoginAuditLogResponseBody) SetRequestId(v string) *ListInstanceLoginAuditLogResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListInstanceLoginAuditLogResponseBody) SetSuccess(v bool) *ListInstanceLoginAuditLogResponseBody {
	s.Success = &v
	return s
}

func (s *ListInstanceLoginAuditLogResponseBody) SetTotalCount(v int64) *ListInstanceLoginAuditLogResponseBody {
	s.TotalCount = &v
	return s
}

type ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogList struct {
	InstanceLoginAuditLog []*ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog `json:"InstanceLoginAuditLog,omitempty" xml:"InstanceLoginAuditLog,omitempty" type:"Repeated"`
}

func (s ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogList) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogList) GoString() string {
	return s.String()
}

func (s *ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogList) SetInstanceLoginAuditLog(v []*ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog) *ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogList {
	s.InstanceLoginAuditLog = v
	return s
}

type ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog struct {
	// The database account that is used to log on to the instance.
	DbUser *string `json:"DbUser,omitempty" xml:"DbUser,omitempty"`
	// The ID of the instance.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The name of the instance.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// The time when the user performed an operation on the instance.
	OpTime *string `json:"OpTime,omitempty" xml:"OpTime,omitempty"`
	// The source IP address of the request.
	RequestIp *string `json:"RequestIp,omitempty" xml:"RequestIp,omitempty"`
	// The ID of the user.
	UserId *int64 `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The alias of the user.
	UserName *string `json:"UserName,omitempty" xml:"UserName,omitempty"`
}

func (s ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog) GoString() string {
	return s.String()
}

func (s *ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog) SetDbUser(v string) *ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog {
	s.DbUser = &v
	return s
}

func (s *ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog) SetInstanceId(v int64) *ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog {
	s.InstanceId = &v
	return s
}

func (s *ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog) SetInstanceName(v string) *ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog {
	s.InstanceName = &v
	return s
}

func (s *ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog) SetOpTime(v string) *ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog {
	s.OpTime = &v
	return s
}

func (s *ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog) SetRequestIp(v string) *ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog {
	s.RequestIp = &v
	return s
}

func (s *ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog) SetUserId(v int64) *ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog {
	s.UserId = &v
	return s
}

func (s *ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog) SetUserName(v string) *ListInstanceLoginAuditLogResponseBodyInstanceLoginAuditLogListInstanceLoginAuditLog {
	s.UserName = &v
	return s
}

type ListInstanceLoginAuditLogResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListInstanceLoginAuditLogResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListInstanceLoginAuditLogResponse) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceLoginAuditLogResponse) GoString() string {
	return s.String()
}

func (s *ListInstanceLoginAuditLogResponse) SetHeaders(v map[string]*string) *ListInstanceLoginAuditLogResponse {
	s.Headers = v
	return s
}

func (s *ListInstanceLoginAuditLogResponse) SetStatusCode(v int32) *ListInstanceLoginAuditLogResponse {
	s.StatusCode = &v
	return s
}

func (s *ListInstanceLoginAuditLogResponse) SetBody(v *ListInstanceLoginAuditLogResponseBody) *ListInstanceLoginAuditLogResponse {
	s.Body = v
	return s
}

type ListInstanceUserPermissionsRequest struct {
	// The ID of the instance. You can call the [ListInstances](~~141936~~) or [GetInstance](~~141567~~) operation to query the ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the tenant.
	//
	// >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The nickname of the user. You can call the [ListUsers](~~141938~~) or [GetUser](~~147098~~) operation to query the nickname of the user.
	//
	// >  The value of the NickName parameter is that of the UserName parameter.
	UserName *string `json:"UserName,omitempty" xml:"UserName,omitempty"`
}

func (s ListInstanceUserPermissionsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceUserPermissionsRequest) GoString() string {
	return s.String()
}

func (s *ListInstanceUserPermissionsRequest) SetInstanceId(v string) *ListInstanceUserPermissionsRequest {
	s.InstanceId = &v
	return s
}

func (s *ListInstanceUserPermissionsRequest) SetPageNumber(v int32) *ListInstanceUserPermissionsRequest {
	s.PageNumber = &v
	return s
}

func (s *ListInstanceUserPermissionsRequest) SetPageSize(v int32) *ListInstanceUserPermissionsRequest {
	s.PageSize = &v
	return s
}

func (s *ListInstanceUserPermissionsRequest) SetTid(v int64) *ListInstanceUserPermissionsRequest {
	s.Tid = &v
	return s
}

func (s *ListInstanceUserPermissionsRequest) SetUserName(v string) *ListInstanceUserPermissionsRequest {
	s.UserName = &v
	return s
}

type ListInstanceUserPermissionsResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// - true: The request is successful.
	// - false: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of returned entries.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The permissions of the user on the instance.
	UserPermissions *ListInstanceUserPermissionsResponseBodyUserPermissions `json:"UserPermissions,omitempty" xml:"UserPermissions,omitempty" type:"Struct"`
}

func (s ListInstanceUserPermissionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceUserPermissionsResponseBody) GoString() string {
	return s.String()
}

func (s *ListInstanceUserPermissionsResponseBody) SetErrorCode(v string) *ListInstanceUserPermissionsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListInstanceUserPermissionsResponseBody) SetErrorMessage(v string) *ListInstanceUserPermissionsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListInstanceUserPermissionsResponseBody) SetRequestId(v string) *ListInstanceUserPermissionsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListInstanceUserPermissionsResponseBody) SetSuccess(v bool) *ListInstanceUserPermissionsResponseBody {
	s.Success = &v
	return s
}

func (s *ListInstanceUserPermissionsResponseBody) SetTotalCount(v int64) *ListInstanceUserPermissionsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListInstanceUserPermissionsResponseBody) SetUserPermissions(v *ListInstanceUserPermissionsResponseBodyUserPermissions) *ListInstanceUserPermissionsResponseBody {
	s.UserPermissions = v
	return s
}

type ListInstanceUserPermissionsResponseBodyUserPermissions struct {
	UserPermission []*ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission `json:"UserPermission,omitempty" xml:"UserPermission,omitempty" type:"Repeated"`
}

func (s ListInstanceUserPermissionsResponseBodyUserPermissions) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceUserPermissionsResponseBodyUserPermissions) GoString() string {
	return s.String()
}

func (s *ListInstanceUserPermissionsResponseBodyUserPermissions) SetUserPermission(v []*ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission) *ListInstanceUserPermissionsResponseBodyUserPermissions {
	s.UserPermission = v
	return s
}

type ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission struct {
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The details of permissions.
	PermDetails *ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails `json:"PermDetails,omitempty" xml:"PermDetails,omitempty" type:"Struct"`
	// The ID of the user.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The nickname of the user.
	UserNickName *string `json:"UserNickName,omitempty" xml:"UserNickName,omitempty"`
}

func (s ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission) GoString() string {
	return s.String()
}

func (s *ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission) SetInstanceId(v string) *ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission {
	s.InstanceId = &v
	return s
}

func (s *ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission) SetPermDetails(v *ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails) *ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission {
	s.PermDetails = v
	return s
}

func (s *ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission) SetUserId(v string) *ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission {
	s.UserId = &v
	return s
}

func (s *ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission) SetUserNickName(v string) *ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermission {
	s.UserNickName = &v
	return s
}

type ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails struct {
	PermDetail []*ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail `json:"PermDetail,omitempty" xml:"PermDetail,omitempty" type:"Repeated"`
}

func (s ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails) GoString() string {
	return s.String()
}

func (s *ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails) SetPermDetail(v []*ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail) *ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails {
	s.PermDetail = v
	return s
}

type ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail struct {
	// The time when the permissions were granted.
	CreateDate *string `json:"CreateDate,omitempty" xml:"CreateDate,omitempty"`
	// The time when the permissions expire.
	ExpireDate *string `json:"ExpireDate,omitempty" xml:"ExpireDate,omitempty"`
	// This parameter is reserved.
	ExtraData *string `json:"ExtraData,omitempty" xml:"ExtraData,omitempty"`
	// The user who grants the permissions.
	OriginFrom *string `json:"OriginFrom,omitempty" xml:"OriginFrom,omitempty"`
	// The type of the permissions. Valid values:
	//
	// *   LOGIN: the logon permissions
	// *   PERF: the query permissions on the instance
	PermType *string `json:"PermType,omitempty" xml:"PermType,omitempty"`
	// The ID of the authorization record.
	UserAccessId *string `json:"UserAccessId,omitempty" xml:"UserAccessId,omitempty"`
}

func (s ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail) GoString() string {
	return s.String()
}

func (s *ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail) SetCreateDate(v string) *ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail {
	s.CreateDate = &v
	return s
}

func (s *ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail) SetExpireDate(v string) *ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail {
	s.ExpireDate = &v
	return s
}

func (s *ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail) SetExtraData(v string) *ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail {
	s.ExtraData = &v
	return s
}

func (s *ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail) SetOriginFrom(v string) *ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail {
	s.OriginFrom = &v
	return s
}

func (s *ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail) SetPermType(v string) *ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail {
	s.PermType = &v
	return s
}

func (s *ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail) SetUserAccessId(v string) *ListInstanceUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail {
	s.UserAccessId = &v
	return s
}

type ListInstanceUserPermissionsResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListInstanceUserPermissionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListInstanceUserPermissionsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceUserPermissionsResponse) GoString() string {
	return s.String()
}

func (s *ListInstanceUserPermissionsResponse) SetHeaders(v map[string]*string) *ListInstanceUserPermissionsResponse {
	s.Headers = v
	return s
}

func (s *ListInstanceUserPermissionsResponse) SetStatusCode(v int32) *ListInstanceUserPermissionsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListInstanceUserPermissionsResponse) SetBody(v *ListInstanceUserPermissionsResponseBody) *ListInstanceUserPermissionsResponse {
	s.Body = v
	return s
}

type ListInstancesRequest struct {
	// The type of the database. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The type of the environment to which the database instance belongs. Valid values:
	//
	// *   **product:** production environment
	// *   **dev**: development environment
	// *   **pre**: pre-release environment
	// *   **test**: test environment
	// *   **sit**: system integration testing (SIT) environment
	// *   **uat**: user acceptance testing (UAT) environment
	// *   **pet**: stress testing environment
	// *   **stag:** staging environment
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The source of the database instance. Valid values:
	//
	// *   **PUBLIC_OWN**: a self-managed database instance that is deployed on the Internet
	// *   **RDS**: an ApsaraDB RDS instance
	// *   **ECS_OWN**: a self-managed database that is deployed on an Elastic Compute Service (ECS) instance
	// *   **VPC_IDC**: a self-managed database instance that is deployed in a data center connected over a virtual private cloud (VPC)
	InstanceSource *string `json:"InstanceSource,omitempty" xml:"InstanceSource,omitempty"`
	// The status of the database instance. Valid values:
	//
	// *   **NORMAL**
	// *   **DISABLE**
	InstanceState *string `json:"InstanceState,omitempty" xml:"InstanceState,omitempty"`
	// The network type of the database instance. Valid values:
	//
	// *   **CLASSIC:** classic network
	// *   **VPC:** VPC
	NetType *string `json:"NetType,omitempty" xml:"NetType,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. The number cannot exceed 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The keyword that is used to search for database instances.
	SearchKey *string `json:"SearchKey,omitempty" xml:"SearchKey,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListInstancesRequest) GoString() string {
	return s.String()
}

func (s *ListInstancesRequest) SetDbType(v string) *ListInstancesRequest {
	s.DbType = &v
	return s
}

func (s *ListInstancesRequest) SetEnvType(v string) *ListInstancesRequest {
	s.EnvType = &v
	return s
}

func (s *ListInstancesRequest) SetInstanceSource(v string) *ListInstancesRequest {
	s.InstanceSource = &v
	return s
}

func (s *ListInstancesRequest) SetInstanceState(v string) *ListInstancesRequest {
	s.InstanceState = &v
	return s
}

func (s *ListInstancesRequest) SetNetType(v string) *ListInstancesRequest {
	s.NetType = &v
	return s
}

func (s *ListInstancesRequest) SetPageNumber(v int32) *ListInstancesRequest {
	s.PageNumber = &v
	return s
}

func (s *ListInstancesRequest) SetPageSize(v int32) *ListInstancesRequest {
	s.PageSize = &v
	return s
}

func (s *ListInstancesRequest) SetSearchKey(v string) *ListInstancesRequest {
	s.SearchKey = &v
	return s
}

func (s *ListInstancesRequest) SetTid(v int64) *ListInstancesRequest {
	s.Tid = &v
	return s
}

type ListInstancesResponseBody struct {
	// The error code that is returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message that is returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The information about the database instances that are returned.
	InstanceList *ListInstancesResponseBodyInstanceList `json:"InstanceList,omitempty" xml:"InstanceList,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of database instances that are returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *ListInstancesResponseBody) SetErrorCode(v string) *ListInstancesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListInstancesResponseBody) SetErrorMessage(v string) *ListInstancesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListInstancesResponseBody) SetInstanceList(v *ListInstancesResponseBodyInstanceList) *ListInstancesResponseBody {
	s.InstanceList = v
	return s
}

func (s *ListInstancesResponseBody) SetRequestId(v string) *ListInstancesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListInstancesResponseBody) SetSuccess(v bool) *ListInstancesResponseBody {
	s.Success = &v
	return s
}

func (s *ListInstancesResponseBody) SetTotalCount(v int64) *ListInstancesResponseBody {
	s.TotalCount = &v
	return s
}

type ListInstancesResponseBodyInstanceList struct {
	Instance []*ListInstancesResponseBodyInstanceListInstance `json:"Instance,omitempty" xml:"Instance,omitempty" type:"Repeated"`
}

func (s ListInstancesResponseBodyInstanceList) String() string {
	return tea.Prettify(s)
}

func (s ListInstancesResponseBodyInstanceList) GoString() string {
	return s.String()
}

func (s *ListInstancesResponseBodyInstanceList) SetInstance(v []*ListInstancesResponseBodyInstanceListInstance) *ListInstancesResponseBodyInstanceList {
	s.Instance = v
	return s
}

type ListInstancesResponseBodyInstanceListInstance struct {
	// The name of the database link for the database instance.
	DataLinkName *string `json:"DataLinkName,omitempty" xml:"DataLinkName,omitempty"`
	// The password that is used to log on to the database instance.
	DatabasePassword *string `json:"DatabasePassword,omitempty" xml:"DatabasePassword,omitempty"`
	// The account that is used to log on to the database.
	DatabaseUser *string `json:"DatabaseUser,omitempty" xml:"DatabaseUser,omitempty"`
	// The ID of the database administrator (DBA) of the database instance.
	DbaId *string `json:"DbaId,omitempty" xml:"DbaId,omitempty"`
	// The nickname of the DBA of the instance.
	DbaNickName *string `json:"DbaNickName,omitempty" xml:"DbaNickName,omitempty"`
	// Indicates whether the lock-free schema change feature is enabled for the database instance.
	DdlOnline *int32 `json:"DdlOnline,omitempty" xml:"DdlOnline,omitempty"`
	// The ID of the ECS instance on which the database instance is deployed.
	EcsInstanceId *string `json:"EcsInstanceId,omitempty" xml:"EcsInstanceId,omitempty"`
	// The ID of the region in which the database instance resides.
	EcsRegion *string `json:"EcsRegion,omitempty" xml:"EcsRegion,omitempty"`
	// The type of the environment to which the database instance belongs. Valid values:
	//
	// *   **product:** production environment
	// *   **dev**: development environment
	// *   **pre**: pre-release environment
	// *   **test**: test environment
	// *   **sit**: SIT environment
	// *   **uat**: UAT environment
	// *   **pet**: stress testing environment
	// *   **stag:** staging environment
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The timeout period for exporting data from the database instance.
	ExportTimeout *int32 `json:"ExportTimeout,omitempty" xml:"ExportTimeout,omitempty"`
	// The host address that is used to connect to the database instance.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The alias of the database instance.
	InstanceAlias *string `json:"InstanceAlias,omitempty" xml:"InstanceAlias,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The source of the database instance.
	InstanceSource *string `json:"InstanceSource,omitempty" xml:"InstanceSource,omitempty"`
	// The type of the database instance.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The IDs of the owners of the database instance.
	OwnerIdList *ListInstancesResponseBodyInstanceListInstanceOwnerIdList `json:"OwnerIdList,omitempty" xml:"OwnerIdList,omitempty" type:"Struct"`
	// The nicknames of the owners of the database instance.
	OwnerNameList *ListInstancesResponseBodyInstanceListInstanceOwnerNameList `json:"OwnerNameList,omitempty" xml:"OwnerNameList,omitempty" type:"Struct"`
	// The port number that is used to connect to the database instance.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The timeout period for querying data in the database instance.
	QueryTimeout *int32 `json:"QueryTimeout,omitempty" xml:"QueryTimeout,omitempty"`
	// The ID of the security rule set of the database instance.
	SafeRuleId *string `json:"SafeRuleId,omitempty" xml:"SafeRuleId,omitempty"`
	// Indicates whether the sensitive data protection feature is enabled. Valid values:
	//
	// *   **true**
	// *   **false**
	SellSitd *bool `json:"SellSitd,omitempty" xml:"SellSitd,omitempty"`
	// The system ID (SID) of the database instance.
	Sid *string `json:"Sid,omitempty" xml:"Sid,omitempty"`
	// The control mode of the database instance.
	StandardGroup *ListInstancesResponseBodyInstanceListInstanceStandardGroup `json:"StandardGroup,omitempty" xml:"StandardGroup,omitempty" type:"Struct"`
	// The status of the database instance.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// Indicates whether the cross-database query feature is enabled for the database instance. Valid values:
	//
	// *   **0**: disabled
	// *   **1:**: enabled
	UseDsql *int32 `json:"UseDsql,omitempty" xml:"UseDsql,omitempty"`
	// The ID of the VPC to which the database instance belongs.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s ListInstancesResponseBodyInstanceListInstance) String() string {
	return tea.Prettify(s)
}

func (s ListInstancesResponseBodyInstanceListInstance) GoString() string {
	return s.String()
}

func (s *ListInstancesResponseBodyInstanceListInstance) SetDataLinkName(v string) *ListInstancesResponseBodyInstanceListInstance {
	s.DataLinkName = &v
	return s
}

func (s *ListInstancesResponseBodyInstanceListInstance) SetDatabasePassword(v string) *ListInstancesResponseBodyInstanceListInstance {
	s.DatabasePassword = &v
	return s
}

func (s *ListInstancesResponseBodyInstanceListInstance) SetDatabaseUser(v string) *ListInstancesResponseBodyInstanceListInstance {
	s.DatabaseUser = &v
	return s
}

func (s *ListInstancesResponseBodyInstanceListInstance) SetDbaId(v string) *ListInstancesResponseBodyInstanceListInstance {
	s.DbaId = &v
	return s
}

func (s *ListInstancesResponseBodyInstanceListInstance) SetDbaNickName(v string) *ListInstancesResponseBodyInstanceListInstance {
	s.DbaNickName = &v
	return s
}

func (s *ListInstancesResponseBodyInstanceListInstance) SetDdlOnline(v int32) *ListInstancesResponseBodyInstanceListInstance {
	s.DdlOnline = &v
	return s
}

func (s *ListInstancesResponseBodyInstanceListInstance) SetEcsInstanceId(v string) *ListInstancesResponseBodyInstanceListInstance {
	s.EcsInstanceId = &v
	return s
}

func (s *ListInstancesResponseBodyInstanceListInstance) SetEcsRegion(v string) *ListInstancesResponseBodyInstanceListInstance {
	s.EcsRegion = &v
	return s
}

func (s *ListInstancesResponseBodyInstanceListInstance) SetEnvType(v string) *ListInstancesResponseBodyInstanceListInstance {
	s.EnvType = &v
	return s
}

func (s *ListInstancesResponseBodyInstanceListInstance) SetExportTimeout(v int32) *ListInstancesResponseBodyInstanceListInstance {
	s.ExportTimeout = &v
	return s
}

func (s *ListInstancesResponseBodyInstanceListInstance) SetHost(v string) *ListInstancesResponseBodyInstanceListInstance {
	s.Host = &v
	return s
}

func (s *ListInstancesResponseBodyInstanceListInstance) SetInstanceAlias(v string) *ListInstancesResponseBodyInstanceListInstance {
	s.InstanceAlias = &v
	return s
}

func (s *ListInstancesResponseBodyInstanceListInstance) SetInstanceId(v string) *ListInstancesResponseBodyInstanceListInstance {
	s.InstanceId = &v
	return s
}

func (s *ListInstancesResponseBodyInstanceListInstance) SetInstanceSource(v string) *ListInstancesResponseBodyInstanceListInstance {
	s.InstanceSource = &v
	return s
}

func (s *ListInstancesResponseBodyInstanceListInstance) SetInstanceType(v string) *ListInstancesResponseBodyInstanceListInstance {
	s.InstanceType = &v
	return s
}

func (s *ListInstancesResponseBodyInstanceListInstance) SetOwnerIdList(v *ListInstancesResponseBodyInstanceListInstanceOwnerIdList) *ListInstancesResponseBodyInstanceListInstance {
	s.OwnerIdList = v
	return s
}

func (s *ListInstancesResponseBodyInstanceListInstance) SetOwnerNameList(v *ListInstancesResponseBodyInstanceListInstanceOwnerNameList) *ListInstancesResponseBodyInstanceListInstance {
	s.OwnerNameList = v
	return s
}

func (s *ListInstancesResponseBodyInstanceListInstance) SetPort(v int32) *ListInstancesResponseBodyInstanceListInstance {
	s.Port = &v
	return s
}

func (s *ListInstancesResponseBodyInstanceListInstance) SetQueryTimeout(v int32) *ListInstancesResponseBodyInstanceListInstance {
	s.QueryTimeout = &v
	return s
}

func (s *ListInstancesResponseBodyInstanceListInstance) SetSafeRuleId(v string) *ListInstancesResponseBodyInstanceListInstance {
	s.SafeRuleId = &v
	return s
}

func (s *ListInstancesResponseBodyInstanceListInstance) SetSellSitd(v bool) *ListInstancesResponseBodyInstanceListInstance {
	s.SellSitd = &v
	return s
}

func (s *ListInstancesResponseBodyInstanceListInstance) SetSid(v string) *ListInstancesResponseBodyInstanceListInstance {
	s.Sid = &v
	return s
}

func (s *ListInstancesResponseBodyInstanceListInstance) SetStandardGroup(v *ListInstancesResponseBodyInstanceListInstanceStandardGroup) *ListInstancesResponseBodyInstanceListInstance {
	s.StandardGroup = v
	return s
}

func (s *ListInstancesResponseBodyInstanceListInstance) SetState(v string) *ListInstancesResponseBodyInstanceListInstance {
	s.State = &v
	return s
}

func (s *ListInstancesResponseBodyInstanceListInstance) SetUseDsql(v int32) *ListInstancesResponseBodyInstanceListInstance {
	s.UseDsql = &v
	return s
}

func (s *ListInstancesResponseBodyInstanceListInstance) SetVpcId(v string) *ListInstancesResponseBodyInstanceListInstance {
	s.VpcId = &v
	return s
}

type ListInstancesResponseBodyInstanceListInstanceOwnerIdList struct {
	OwnerIds []*string `json:"OwnerIds,omitempty" xml:"OwnerIds,omitempty" type:"Repeated"`
}

func (s ListInstancesResponseBodyInstanceListInstanceOwnerIdList) String() string {
	return tea.Prettify(s)
}

func (s ListInstancesResponseBodyInstanceListInstanceOwnerIdList) GoString() string {
	return s.String()
}

func (s *ListInstancesResponseBodyInstanceListInstanceOwnerIdList) SetOwnerIds(v []*string) *ListInstancesResponseBodyInstanceListInstanceOwnerIdList {
	s.OwnerIds = v
	return s
}

type ListInstancesResponseBodyInstanceListInstanceOwnerNameList struct {
	OwnerNames []*string `json:"OwnerNames,omitempty" xml:"OwnerNames,omitempty" type:"Repeated"`
}

func (s ListInstancesResponseBodyInstanceListInstanceOwnerNameList) String() string {
	return tea.Prettify(s)
}

func (s ListInstancesResponseBodyInstanceListInstanceOwnerNameList) GoString() string {
	return s.String()
}

func (s *ListInstancesResponseBodyInstanceListInstanceOwnerNameList) SetOwnerNames(v []*string) *ListInstancesResponseBodyInstanceListInstanceOwnerNameList {
	s.OwnerNames = v
	return s
}

type ListInstancesResponseBodyInstanceListInstanceStandardGroup struct {
	// The type of the control mode. Valid values:
	//
	// *   **COMMON**: Security Collaboration
	// *   **NONE_CONTROL**: Flexible Management
	// *   **STABLE**: Stable Change
	GroupMode *string `json:"GroupMode,omitempty" xml:"GroupMode,omitempty"`
	// The name of the security rule corresponding to the control mode.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
}

func (s ListInstancesResponseBodyInstanceListInstanceStandardGroup) String() string {
	return tea.Prettify(s)
}

func (s ListInstancesResponseBodyInstanceListInstanceStandardGroup) GoString() string {
	return s.String()
}

func (s *ListInstancesResponseBodyInstanceListInstanceStandardGroup) SetGroupMode(v string) *ListInstancesResponseBodyInstanceListInstanceStandardGroup {
	s.GroupMode = &v
	return s
}

func (s *ListInstancesResponseBodyInstanceListInstanceStandardGroup) SetGroupName(v string) *ListInstancesResponseBodyInstanceListInstanceStandardGroup {
	s.GroupName = &v
	return s
}

type ListInstancesResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListInstancesResponse) GoString() string {
	return s.String()
}

func (s *ListInstancesResponse) SetHeaders(v map[string]*string) *ListInstancesResponse {
	s.Headers = v
	return s
}

func (s *ListInstancesResponse) SetStatusCode(v int32) *ListInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListInstancesResponse) SetBody(v *ListInstancesResponseBody) *ListInstancesResponse {
	s.Body = v
	return s
}

type ListLhTaskFlowAndScenarioRequest struct {
	// The ID of the workspace. You can call the [GetLhSpaceByName](~~424379~~) operation to obtain the workspace ID.
	SpaceId *int64 `json:"SpaceId,omitempty" xml:"SpaceId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The ID of the user. You can call the [ListUsers](~~141938~~) or [GetUser](~~147098~~) operation to obtain the user ID.
	UserId *int64 `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s ListLhTaskFlowAndScenarioRequest) String() string {
	return tea.Prettify(s)
}

func (s ListLhTaskFlowAndScenarioRequest) GoString() string {
	return s.String()
}

func (s *ListLhTaskFlowAndScenarioRequest) SetSpaceId(v int64) *ListLhTaskFlowAndScenarioRequest {
	s.SpaceId = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioRequest) SetTid(v int64) *ListLhTaskFlowAndScenarioRequest {
	s.Tid = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioRequest) SetUserId(v int64) *ListLhTaskFlowAndScenarioRequest {
	s.UserId = &v
	return s
}

type ListLhTaskFlowAndScenarioResponseBody struct {
	// The error code returned if the request fails.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The task flows in the default business scenario.
	RawDAGList *ListLhTaskFlowAndScenarioResponseBodyRawDAGList `json:"RawDAGList,omitempty" xml:"RawDAGList,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The task flows in other business scenarios.
	ScenarioDAGList *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGList `json:"ScenarioDAGList,omitempty" xml:"ScenarioDAGList,omitempty" type:"Struct"`
	// Indicates whether the request is successful. Valid values:
	//
	// - **true**: The request is successful.
	// - **false**: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListLhTaskFlowAndScenarioResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListLhTaskFlowAndScenarioResponseBody) GoString() string {
	return s.String()
}

func (s *ListLhTaskFlowAndScenarioResponseBody) SetErrorCode(v string) *ListLhTaskFlowAndScenarioResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBody) SetErrorMessage(v string) *ListLhTaskFlowAndScenarioResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBody) SetRawDAGList(v *ListLhTaskFlowAndScenarioResponseBodyRawDAGList) *ListLhTaskFlowAndScenarioResponseBody {
	s.RawDAGList = v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBody) SetRequestId(v string) *ListLhTaskFlowAndScenarioResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBody) SetScenarioDAGList(v *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGList) *ListLhTaskFlowAndScenarioResponseBody {
	s.ScenarioDAGList = v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBody) SetSuccess(v bool) *ListLhTaskFlowAndScenarioResponseBody {
	s.Success = &v
	return s
}

type ListLhTaskFlowAndScenarioResponseBodyRawDAGList struct {
	Dag []*ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag `json:"Dag,omitempty" xml:"Dag,omitempty" type:"Repeated"`
}

func (s ListLhTaskFlowAndScenarioResponseBodyRawDAGList) String() string {
	return tea.Prettify(s)
}

func (s ListLhTaskFlowAndScenarioResponseBodyRawDAGList) GoString() string {
	return s.String()
}

func (s *ListLhTaskFlowAndScenarioResponseBodyRawDAGList) SetDag(v []*ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag) *ListLhTaskFlowAndScenarioResponseBodyRawDAGList {
	s.Dag = v
	return s
}

type ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag struct {
	// Indicates whether the task flow can be modified. Valid values:
	//
	// *   **true**: The task flow can be modified.
	// *   **false**: The task flow cannot be modified.
	CanEdit *bool `json:"CanEdit,omitempty" xml:"CanEdit,omitempty"`
	// The ID of the user who creates the task flow.
	CreatorId *string `json:"CreatorId,omitempty" xml:"CreatorId,omitempty"`
	// The name of the user who creates the workspace.
	CreatorNickName *string `json:"CreatorNickName,omitempty" xml:"CreatorNickName,omitempty"`
	// The name of the task flow.
	DagName *string `json:"DagName,omitempty" xml:"DagName,omitempty"`
	// The user ID of the task flow owner.
	DagOwnerId *string `json:"DagOwnerId,omitempty" xml:"DagOwnerId,omitempty"`
	// The name of the task flow owner.
	DagOwnerNickName *string `json:"DagOwnerNickName,omitempty" xml:"DagOwnerNickName,omitempty"`
	// The extended field. No meaning is specified for this field.
	DataFlowId *int64 `json:"DataFlowId,omitempty" xml:"DataFlowId,omitempty"`
	// The extended field. No meaning is specified for this field.
	DemoId *string `json:"DemoId,omitempty" xml:"DemoId,omitempty"`
	// The ID of the latest deployment record.
	DeployId *int64 `json:"DeployId,omitempty" xml:"DeployId,omitempty"`
	// The ID of the task flow.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// Indicates whether the task flow is deleted. Valid values:
	//
	// *   **true**: deleted
	// *   **false**: not deleted
	IsDeleted *bool `json:"IsDeleted,omitempty" xml:"IsDeleted,omitempty"`
	// The status of the latest execution. Valid values:
	//
	// *   **0**: invalid
	// *   **1**: scheduling disabled
	// *   **2**: waiting to be scheduled
	LatestInstanceStatus *int32 `json:"LatestInstanceStatus,omitempty" xml:"LatestInstanceStatus,omitempty"`
	// The time when the latest execution record was generated.
	LatestInstanceTime *int32 `json:"LatestInstanceTime,omitempty" xml:"LatestInstanceTime,omitempty"`
	// The ID of the business scenario.
	ScenarioId *int64 `json:"ScenarioId,omitempty" xml:"ScenarioId,omitempty"`
	// The ID of the workspace.
	SpaceId *int64 `json:"SpaceId,omitempty" xml:"SpaceId,omitempty"`
	// The status of the task flow. Valid values:
	//
	// *   **0**: invalid
	// *   **1**: scheduling disabled
	// *   **2**: waiting to be scheduled
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag) String() string {
	return tea.Prettify(s)
}

func (s ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag) GoString() string {
	return s.String()
}

func (s *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag) SetCanEdit(v bool) *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag {
	s.CanEdit = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag) SetCreatorId(v string) *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag {
	s.CreatorId = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag) SetCreatorNickName(v string) *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag {
	s.CreatorNickName = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag) SetDagName(v string) *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag {
	s.DagName = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag) SetDagOwnerId(v string) *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag {
	s.DagOwnerId = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag) SetDagOwnerNickName(v string) *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag {
	s.DagOwnerNickName = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag) SetDataFlowId(v int64) *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag {
	s.DataFlowId = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag) SetDemoId(v string) *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag {
	s.DemoId = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag) SetDeployId(v int64) *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag {
	s.DeployId = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag) SetId(v int64) *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag {
	s.Id = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag) SetIsDeleted(v bool) *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag {
	s.IsDeleted = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag) SetLatestInstanceStatus(v int32) *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag {
	s.LatestInstanceStatus = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag) SetLatestInstanceTime(v int32) *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag {
	s.LatestInstanceTime = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag) SetScenarioId(v int64) *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag {
	s.ScenarioId = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag) SetSpaceId(v int64) *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag {
	s.SpaceId = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag) SetStatus(v int32) *ListLhTaskFlowAndScenarioResponseBodyRawDAGListDag {
	s.Status = &v
	return s
}

type ListLhTaskFlowAndScenarioResponseBodyScenarioDAGList struct {
	ScenarioDAG []*ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG `json:"ScenarioDAG,omitempty" xml:"ScenarioDAG,omitempty" type:"Repeated"`
}

func (s ListLhTaskFlowAndScenarioResponseBodyScenarioDAGList) String() string {
	return tea.Prettify(s)
}

func (s ListLhTaskFlowAndScenarioResponseBodyScenarioDAGList) GoString() string {
	return s.String()
}

func (s *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGList) SetScenarioDAG(v []*ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG) *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGList {
	s.ScenarioDAG = v
	return s
}

type ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG struct {
	// The list of task flows.
	DagList *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagList `json:"DagList,omitempty" xml:"DagList,omitempty" type:"Struct"`
	// The information about the business scenario.
	Scenario *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario `json:"Scenario,omitempty" xml:"Scenario,omitempty" type:"Struct"`
}

func (s ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG) String() string {
	return tea.Prettify(s)
}

func (s ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG) GoString() string {
	return s.String()
}

func (s *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG) SetDagList(v *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagList) *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG {
	s.DagList = v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG) SetScenario(v *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario) *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAG {
	s.Scenario = v
	return s
}

type ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagList struct {
	Dag []*ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag `json:"Dag,omitempty" xml:"Dag,omitempty" type:"Repeated"`
}

func (s ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagList) String() string {
	return tea.Prettify(s)
}

func (s ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagList) GoString() string {
	return s.String()
}

func (s *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagList) SetDag(v []*ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag) *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagList {
	s.Dag = v
	return s
}

type ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag struct {
	// Indicates whether the task flow can be modified. Valid values:
	//
	// - **true**: The task flow can be modified.
	// - **false**: The task flow cannot be modified.
	CanEdit *bool `json:"CanEdit,omitempty" xml:"CanEdit,omitempty"`
	// The ID of the user who creates the task flow.
	CreatorId *string `json:"CreatorId,omitempty" xml:"CreatorId,omitempty"`
	// The name of the user who creates the workspace.
	CreatorNickName *string `json:"CreatorNickName,omitempty" xml:"CreatorNickName,omitempty"`
	// The name of the task flow.
	DagName *string `json:"DagName,omitempty" xml:"DagName,omitempty"`
	// The user ID of the task flow owner.
	DagOwnerId *string `json:"DagOwnerId,omitempty" xml:"DagOwnerId,omitempty"`
	// The name of the task flow owner.
	DagOwnerNickName *string `json:"DagOwnerNickName,omitempty" xml:"DagOwnerNickName,omitempty"`
	// The extended field. No meaning is specified for this field.
	DataFlowId *int64 `json:"DataFlowId,omitempty" xml:"DataFlowId,omitempty"`
	// The extended field. No meaning is specified for this field.
	DemoId *string `json:"DemoId,omitempty" xml:"DemoId,omitempty"`
	// The ID of the latest deployment record.
	DeployId *int64 `json:"DeployId,omitempty" xml:"DeployId,omitempty"`
	// The ID of the task flow.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// Indicates whether the task flow is deleted. Valid values:
	//
	// - **true**: deleted
	// - **false**: not deleted
	IsDeleted *bool `json:"IsDeleted,omitempty" xml:"IsDeleted,omitempty"`
	// The status of the latest execution. Valid values:
	//
	// - 0: invalid
	// - 1: scheduling disabled
	// - 2: waiting to be scheduled
	LatestInstanceStatus *int32 `json:"LatestInstanceStatus,omitempty" xml:"LatestInstanceStatus,omitempty"`
	// The time when the latest execution record was generated.
	LatestInstanceTime *int32 `json:"LatestInstanceTime,omitempty" xml:"LatestInstanceTime,omitempty"`
	// The ID of the business scenario.
	ScenarioId *int64 `json:"ScenarioId,omitempty" xml:"ScenarioId,omitempty"`
	// The ID of the workspace.
	SpaceId *int64 `json:"SpaceId,omitempty" xml:"SpaceId,omitempty"`
	// The status of the task flow. Valid values:
	//
	// - **0**: invalid
	// - **1**: scheduling disabled
	// - **2**: waiting to be scheduled
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag) String() string {
	return tea.Prettify(s)
}

func (s ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag) GoString() string {
	return s.String()
}

func (s *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag) SetCanEdit(v bool) *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag {
	s.CanEdit = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag) SetCreatorId(v string) *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag {
	s.CreatorId = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag) SetCreatorNickName(v string) *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag {
	s.CreatorNickName = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag) SetDagName(v string) *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag {
	s.DagName = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag) SetDagOwnerId(v string) *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag {
	s.DagOwnerId = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag) SetDagOwnerNickName(v string) *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag {
	s.DagOwnerNickName = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag) SetDataFlowId(v int64) *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag {
	s.DataFlowId = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag) SetDemoId(v string) *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag {
	s.DemoId = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag) SetDeployId(v int64) *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag {
	s.DeployId = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag) SetId(v int64) *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag {
	s.Id = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag) SetIsDeleted(v bool) *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag {
	s.IsDeleted = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag) SetLatestInstanceStatus(v int32) *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag {
	s.LatestInstanceStatus = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag) SetLatestInstanceTime(v int32) *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag {
	s.LatestInstanceTime = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag) SetScenarioId(v int64) *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag {
	s.ScenarioId = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag) SetSpaceId(v int64) *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag {
	s.SpaceId = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag) SetStatus(v int32) *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGDagListDag {
	s.Status = &v
	return s
}

type ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario struct {
	// The ID of the user who creates the business scenario.
	CreatorId *string `json:"CreatorId,omitempty" xml:"CreatorId,omitempty"`
	// The description of the business scenario.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the business scenario.
	ScenarioName *string `json:"ScenarioName,omitempty" xml:"ScenarioName,omitempty"`
}

func (s ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario) String() string {
	return tea.Prettify(s)
}

func (s ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario) GoString() string {
	return s.String()
}

func (s *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario) SetCreatorId(v string) *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario {
	s.CreatorId = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario) SetDescription(v string) *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario {
	s.Description = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario) SetScenarioName(v string) *ListLhTaskFlowAndScenarioResponseBodyScenarioDAGListScenarioDAGScenario {
	s.ScenarioName = &v
	return s
}

type ListLhTaskFlowAndScenarioResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListLhTaskFlowAndScenarioResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListLhTaskFlowAndScenarioResponse) String() string {
	return tea.Prettify(s)
}

func (s ListLhTaskFlowAndScenarioResponse) GoString() string {
	return s.String()
}

func (s *ListLhTaskFlowAndScenarioResponse) SetHeaders(v map[string]*string) *ListLhTaskFlowAndScenarioResponse {
	s.Headers = v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponse) SetStatusCode(v int32) *ListLhTaskFlowAndScenarioResponse {
	s.StatusCode = &v
	return s
}

func (s *ListLhTaskFlowAndScenarioResponse) SetBody(v *ListLhTaskFlowAndScenarioResponseBody) *ListLhTaskFlowAndScenarioResponse {
	s.Body = v
	return s
}

type ListLogicDatabasesRequest struct {
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListLogicDatabasesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListLogicDatabasesRequest) GoString() string {
	return s.String()
}

func (s *ListLogicDatabasesRequest) SetPageNumber(v int32) *ListLogicDatabasesRequest {
	s.PageNumber = &v
	return s
}

func (s *ListLogicDatabasesRequest) SetPageSize(v int32) *ListLogicDatabasesRequest {
	s.PageSize = &v
	return s
}

func (s *ListLogicDatabasesRequest) SetTid(v int64) *ListLogicDatabasesRequest {
	s.Tid = &v
	return s
}

type ListLogicDatabasesResponseBody struct {
	// The error code that is returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message that is returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The details of logical databases.
	LogicDatabaseList *ListLogicDatabasesResponseBodyLogicDatabaseList `json:"LogicDatabaseList,omitempty" xml:"LogicDatabaseList,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// - **true**: The request is successful.
	// - **false**: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of logical databases.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListLogicDatabasesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListLogicDatabasesResponseBody) GoString() string {
	return s.String()
}

func (s *ListLogicDatabasesResponseBody) SetErrorCode(v string) *ListLogicDatabasesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListLogicDatabasesResponseBody) SetErrorMessage(v string) *ListLogicDatabasesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListLogicDatabasesResponseBody) SetLogicDatabaseList(v *ListLogicDatabasesResponseBodyLogicDatabaseList) *ListLogicDatabasesResponseBody {
	s.LogicDatabaseList = v
	return s
}

func (s *ListLogicDatabasesResponseBody) SetRequestId(v string) *ListLogicDatabasesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListLogicDatabasesResponseBody) SetSuccess(v bool) *ListLogicDatabasesResponseBody {
	s.Success = &v
	return s
}

func (s *ListLogicDatabasesResponseBody) SetTotalCount(v int64) *ListLogicDatabasesResponseBody {
	s.TotalCount = &v
	return s
}

type ListLogicDatabasesResponseBodyLogicDatabaseList struct {
	LogicDatabase []*ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase `json:"LogicDatabase,omitempty" xml:"LogicDatabase,omitempty" type:"Repeated"`
}

func (s ListLogicDatabasesResponseBodyLogicDatabaseList) String() string {
	return tea.Prettify(s)
}

func (s ListLogicDatabasesResponseBodyLogicDatabaseList) GoString() string {
	return s.String()
}

func (s *ListLogicDatabasesResponseBodyLogicDatabaseList) SetLogicDatabase(v []*ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase) *ListLogicDatabasesResponseBodyLogicDatabaseList {
	s.LogicDatabase = v
	return s
}

type ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase struct {
	// The alias of the logical database.
	Alias *string `json:"Alias,omitempty" xml:"Alias,omitempty"`
	// The ID of the logical database.
	DatabaseId *string `json:"DatabaseId,omitempty" xml:"DatabaseId,omitempty"`
	// Logical database sub-ID list.
	DatabaseIds *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseDatabaseIds `json:"DatabaseIds,omitempty" xml:"DatabaseIds,omitempty" type:"Struct"`
	// The type of the logical database. For more information about the valid values of this parameter, see [DbType parameter](https://www.alibabacloud.com/help/en/data-management-service/latest/dbtype-parameter).
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The type of the environment to which the logical database belongs. Valid values:
	//
	// - **product**: production environment
	// - **dev**: development environment
	// - **pre**: staging environment
	// - **test**: test environment
	// - **sit**: system integration testing (SIT) environment
	// - **uat**: user acceptance testing (UAT) environment
	// - **pet**: stress testing environment
	// - **stag**: STAG environment
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// Indicates whether the database is a logical database. The return value is true.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The IDs of the owners of the logical database.
	OwnerIdList *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerIdList `json:"OwnerIdList,omitempty" xml:"OwnerIdList,omitempty" type:"Struct"`
	// The names of the owners of the logical database.
	OwnerNameList *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerNameList `json:"OwnerNameList,omitempty" xml:"OwnerNameList,omitempty" type:"Struct"`
	// The name of the logical database.
	SchemaName *string `json:"SchemaName,omitempty" xml:"SchemaName,omitempty"`
	// The name that is used to search for the logical database.
	//
	// > We recommend that you do not use this parameter for business development. The format of the parameter value may be modified in later versions.
	SearchName *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
}

func (s ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase) String() string {
	return tea.Prettify(s)
}

func (s ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase) GoString() string {
	return s.String()
}

func (s *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase) SetAlias(v string) *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase {
	s.Alias = &v
	return s
}

func (s *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase) SetDatabaseId(v string) *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase {
	s.DatabaseId = &v
	return s
}

func (s *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase) SetDatabaseIds(v *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseDatabaseIds) *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase {
	s.DatabaseIds = v
	return s
}

func (s *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase) SetDbType(v string) *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase {
	s.DbType = &v
	return s
}

func (s *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase) SetEnvType(v string) *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase {
	s.EnvType = &v
	return s
}

func (s *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase) SetLogic(v bool) *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase {
	s.Logic = &v
	return s
}

func (s *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase) SetOwnerIdList(v *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerIdList) *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase {
	s.OwnerIdList = v
	return s
}

func (s *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase) SetOwnerNameList(v *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerNameList) *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase {
	s.OwnerNameList = v
	return s
}

func (s *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase) SetSchemaName(v string) *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase {
	s.SchemaName = &v
	return s
}

func (s *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase) SetSearchName(v string) *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabase {
	s.SearchName = &v
	return s
}

type ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseDatabaseIds struct {
	DatabaseIds []*int64 `json:"DatabaseIds,omitempty" xml:"DatabaseIds,omitempty" type:"Repeated"`
}

func (s ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseDatabaseIds) String() string {
	return tea.Prettify(s)
}

func (s ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseDatabaseIds) GoString() string {
	return s.String()
}

func (s *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseDatabaseIds) SetDatabaseIds(v []*int64) *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseDatabaseIds {
	s.DatabaseIds = v
	return s
}

type ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerIdList struct {
	OwnerIds []*string `json:"OwnerIds,omitempty" xml:"OwnerIds,omitempty" type:"Repeated"`
}

func (s ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerIdList) String() string {
	return tea.Prettify(s)
}

func (s ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerIdList) GoString() string {
	return s.String()
}

func (s *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerIdList) SetOwnerIds(v []*string) *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerIdList {
	s.OwnerIds = v
	return s
}

type ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerNameList struct {
	OwnerNames []*string `json:"OwnerNames,omitempty" xml:"OwnerNames,omitempty" type:"Repeated"`
}

func (s ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerNameList) String() string {
	return tea.Prettify(s)
}

func (s ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerNameList) GoString() string {
	return s.String()
}

func (s *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerNameList) SetOwnerNames(v []*string) *ListLogicDatabasesResponseBodyLogicDatabaseListLogicDatabaseOwnerNameList {
	s.OwnerNames = v
	return s
}

type ListLogicDatabasesResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListLogicDatabasesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListLogicDatabasesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListLogicDatabasesResponse) GoString() string {
	return s.String()
}

func (s *ListLogicDatabasesResponse) SetHeaders(v map[string]*string) *ListLogicDatabasesResponse {
	s.Headers = v
	return s
}

func (s *ListLogicDatabasesResponse) SetStatusCode(v int32) *ListLogicDatabasesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListLogicDatabasesResponse) SetBody(v *ListLogicDatabasesResponseBody) *ListLogicDatabasesResponse {
	s.Body = v
	return s
}

type ListLogicTableRouteConfigRequest struct {
	// The ID of the logical table. You can call the [ListLogicTables](https://www.alibabacloud.com/help/en/data-management-service/latest/listlogictables) operation to query the ID of the logical table.
	TableId *int64 `json:"TableId,omitempty" xml:"TableId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListLogicTableRouteConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s ListLogicTableRouteConfigRequest) GoString() string {
	return s.String()
}

func (s *ListLogicTableRouteConfigRequest) SetTableId(v int64) *ListLogicTableRouteConfigRequest {
	s.TableId = &v
	return s
}

func (s *ListLogicTableRouteConfigRequest) SetTid(v int64) *ListLogicTableRouteConfigRequest {
	s.Tid = &v
	return s
}

type ListLogicTableRouteConfigResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The routing algorithms.
	LogicTableRouteConfigList *ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigList `json:"LogicTableRouteConfigList,omitempty" xml:"LogicTableRouteConfigList,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// - **true**: The request was successful.
	// - **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListLogicTableRouteConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListLogicTableRouteConfigResponseBody) GoString() string {
	return s.String()
}

func (s *ListLogicTableRouteConfigResponseBody) SetErrorCode(v string) *ListLogicTableRouteConfigResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListLogicTableRouteConfigResponseBody) SetErrorMessage(v string) *ListLogicTableRouteConfigResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListLogicTableRouteConfigResponseBody) SetLogicTableRouteConfigList(v *ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigList) *ListLogicTableRouteConfigResponseBody {
	s.LogicTableRouteConfigList = v
	return s
}

func (s *ListLogicTableRouteConfigResponseBody) SetRequestId(v string) *ListLogicTableRouteConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListLogicTableRouteConfigResponseBody) SetSuccess(v bool) *ListLogicTableRouteConfigResponseBody {
	s.Success = &v
	return s
}

type ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigList struct {
	LogicTableRouteConfig []*ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig `json:"LogicTableRouteConfig,omitempty" xml:"LogicTableRouteConfig,omitempty" type:"Repeated"`
}

func (s ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigList) String() string {
	return tea.Prettify(s)
}

func (s ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigList) GoString() string {
	return s.String()
}

func (s *ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigList) SetLogicTableRouteConfig(v []*ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig) *ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigList {
	s.LogicTableRouteConfig = v
	return s
}

type ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig struct {
	// The routing algorithm expression.
	RouteExpr *string `json:"RouteExpr,omitempty" xml:"RouteExpr,omitempty"`
	// The unique key of the routing algorithm.
	RouteKey *string `json:"RouteKey,omitempty" xml:"RouteKey,omitempty"`
	// The ID of the logical table.
	TableId *int64 `json:"TableId,omitempty" xml:"TableId,omitempty"`
}

func (s ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig) String() string {
	return tea.Prettify(s)
}

func (s ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig) GoString() string {
	return s.String()
}

func (s *ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig) SetRouteExpr(v string) *ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig {
	s.RouteExpr = &v
	return s
}

func (s *ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig) SetRouteKey(v string) *ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig {
	s.RouteKey = &v
	return s
}

func (s *ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig) SetTableId(v int64) *ListLogicTableRouteConfigResponseBodyLogicTableRouteConfigListLogicTableRouteConfig {
	s.TableId = &v
	return s
}

type ListLogicTableRouteConfigResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListLogicTableRouteConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListLogicTableRouteConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s ListLogicTableRouteConfigResponse) GoString() string {
	return s.String()
}

func (s *ListLogicTableRouteConfigResponse) SetHeaders(v map[string]*string) *ListLogicTableRouteConfigResponse {
	s.Headers = v
	return s
}

func (s *ListLogicTableRouteConfigResponse) SetStatusCode(v int32) *ListLogicTableRouteConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *ListLogicTableRouteConfigResponse) SetBody(v *ListLogicTableRouteConfigResponseBody) *ListLogicTableRouteConfigResponse {
	s.Body = v
	return s
}

type ListLogicTablesRequest struct {
	// The ID of the logical database.
	DatabaseId *string `json:"DatabaseId,omitempty" xml:"DatabaseId,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// Specifies whether to return the GUID of the table.
	ReturnGuid *bool `json:"ReturnGuid,omitempty" xml:"ReturnGuid,omitempty"`
	// The keyword that is used to search for the logical tables. Prefix match is supported.
	SearchName *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
	// The ID of the tenant.
	//
	// > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListLogicTablesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListLogicTablesRequest) GoString() string {
	return s.String()
}

func (s *ListLogicTablesRequest) SetDatabaseId(v string) *ListLogicTablesRequest {
	s.DatabaseId = &v
	return s
}

func (s *ListLogicTablesRequest) SetPageNumber(v int32) *ListLogicTablesRequest {
	s.PageNumber = &v
	return s
}

func (s *ListLogicTablesRequest) SetPageSize(v int32) *ListLogicTablesRequest {
	s.PageSize = &v
	return s
}

func (s *ListLogicTablesRequest) SetReturnGuid(v bool) *ListLogicTablesRequest {
	s.ReturnGuid = &v
	return s
}

func (s *ListLogicTablesRequest) SetSearchName(v string) *ListLogicTablesRequest {
	s.SearchName = &v
	return s
}

func (s *ListLogicTablesRequest) SetTid(v int64) *ListLogicTablesRequest {
	s.Tid = &v
	return s
}

type ListLogicTablesResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The details of the logical tables.
	LogicTableList *ListLogicTablesResponseBodyLogicTableList `json:"LogicTableList,omitempty" xml:"LogicTableList,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of logical tables that meet the query conditions.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListLogicTablesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListLogicTablesResponseBody) GoString() string {
	return s.String()
}

func (s *ListLogicTablesResponseBody) SetErrorCode(v string) *ListLogicTablesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListLogicTablesResponseBody) SetErrorMessage(v string) *ListLogicTablesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListLogicTablesResponseBody) SetLogicTableList(v *ListLogicTablesResponseBodyLogicTableList) *ListLogicTablesResponseBody {
	s.LogicTableList = v
	return s
}

func (s *ListLogicTablesResponseBody) SetRequestId(v string) *ListLogicTablesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListLogicTablesResponseBody) SetSuccess(v bool) *ListLogicTablesResponseBody {
	s.Success = &v
	return s
}

func (s *ListLogicTablesResponseBody) SetTotalCount(v int64) *ListLogicTablesResponseBody {
	s.TotalCount = &v
	return s
}

type ListLogicTablesResponseBodyLogicTableList struct {
	LogicTable []*ListLogicTablesResponseBodyLogicTableListLogicTable `json:"LogicTable,omitempty" xml:"LogicTable,omitempty" type:"Repeated"`
}

func (s ListLogicTablesResponseBodyLogicTableList) String() string {
	return tea.Prettify(s)
}

func (s ListLogicTablesResponseBodyLogicTableList) GoString() string {
	return s.String()
}

func (s *ListLogicTablesResponseBodyLogicTableList) SetLogicTable(v []*ListLogicTablesResponseBodyLogicTableListLogicTable) *ListLogicTablesResponseBodyLogicTableList {
	s.LogicTable = v
	return s
}

type ListLogicTablesResponseBodyLogicTableListLogicTable struct {
	// The ID of the logical database.
	DatabaseId *string `json:"DatabaseId,omitempty" xml:"DatabaseId,omitempty"`
	// Indicates whether the table is a logical table. The value is fixed to true.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The IDs of the owners of the logical tables.
	OwnerIdList *ListLogicTablesResponseBodyLogicTableListLogicTableOwnerIdList `json:"OwnerIdList,omitempty" xml:"OwnerIdList,omitempty" type:"Struct"`
	// The nicknames of the owners of the logical tables.
	OwnerNameList *ListLogicTablesResponseBodyLogicTableListLogicTableOwnerNameList `json:"OwnerNameList,omitempty" xml:"OwnerNameList,omitempty" type:"Struct"`
	// The logical database to which the logical table belongs.
	SchemaName *string `json:"SchemaName,omitempty" xml:"SchemaName,omitempty"`
	// The number of logical tables.
	TableCount *string `json:"TableCount,omitempty" xml:"TableCount,omitempty"`
	// The expression of the logical table.
	TableExpr *string `json:"TableExpr,omitempty" xml:"TableExpr,omitempty"`
	// The GUID of the logical table.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
	// The ID of the logical table.
	TableId *string `json:"TableId,omitempty" xml:"TableId,omitempty"`
	// The name of the logical table.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s ListLogicTablesResponseBodyLogicTableListLogicTable) String() string {
	return tea.Prettify(s)
}

func (s ListLogicTablesResponseBodyLogicTableListLogicTable) GoString() string {
	return s.String()
}

func (s *ListLogicTablesResponseBodyLogicTableListLogicTable) SetDatabaseId(v string) *ListLogicTablesResponseBodyLogicTableListLogicTable {
	s.DatabaseId = &v
	return s
}

func (s *ListLogicTablesResponseBodyLogicTableListLogicTable) SetLogic(v bool) *ListLogicTablesResponseBodyLogicTableListLogicTable {
	s.Logic = &v
	return s
}

func (s *ListLogicTablesResponseBodyLogicTableListLogicTable) SetOwnerIdList(v *ListLogicTablesResponseBodyLogicTableListLogicTableOwnerIdList) *ListLogicTablesResponseBodyLogicTableListLogicTable {
	s.OwnerIdList = v
	return s
}

func (s *ListLogicTablesResponseBodyLogicTableListLogicTable) SetOwnerNameList(v *ListLogicTablesResponseBodyLogicTableListLogicTableOwnerNameList) *ListLogicTablesResponseBodyLogicTableListLogicTable {
	s.OwnerNameList = v
	return s
}

func (s *ListLogicTablesResponseBodyLogicTableListLogicTable) SetSchemaName(v string) *ListLogicTablesResponseBodyLogicTableListLogicTable {
	s.SchemaName = &v
	return s
}

func (s *ListLogicTablesResponseBodyLogicTableListLogicTable) SetTableCount(v string) *ListLogicTablesResponseBodyLogicTableListLogicTable {
	s.TableCount = &v
	return s
}

func (s *ListLogicTablesResponseBodyLogicTableListLogicTable) SetTableExpr(v string) *ListLogicTablesResponseBodyLogicTableListLogicTable {
	s.TableExpr = &v
	return s
}

func (s *ListLogicTablesResponseBodyLogicTableListLogicTable) SetTableGuid(v string) *ListLogicTablesResponseBodyLogicTableListLogicTable {
	s.TableGuid = &v
	return s
}

func (s *ListLogicTablesResponseBodyLogicTableListLogicTable) SetTableId(v string) *ListLogicTablesResponseBodyLogicTableListLogicTable {
	s.TableId = &v
	return s
}

func (s *ListLogicTablesResponseBodyLogicTableListLogicTable) SetTableName(v string) *ListLogicTablesResponseBodyLogicTableListLogicTable {
	s.TableName = &v
	return s
}

type ListLogicTablesResponseBodyLogicTableListLogicTableOwnerIdList struct {
	OwnerIds []*string `json:"OwnerIds,omitempty" xml:"OwnerIds,omitempty" type:"Repeated"`
}

func (s ListLogicTablesResponseBodyLogicTableListLogicTableOwnerIdList) String() string {
	return tea.Prettify(s)
}

func (s ListLogicTablesResponseBodyLogicTableListLogicTableOwnerIdList) GoString() string {
	return s.String()
}

func (s *ListLogicTablesResponseBodyLogicTableListLogicTableOwnerIdList) SetOwnerIds(v []*string) *ListLogicTablesResponseBodyLogicTableListLogicTableOwnerIdList {
	s.OwnerIds = v
	return s
}

type ListLogicTablesResponseBodyLogicTableListLogicTableOwnerNameList struct {
	OwnerNames []*string `json:"OwnerNames,omitempty" xml:"OwnerNames,omitempty" type:"Repeated"`
}

func (s ListLogicTablesResponseBodyLogicTableListLogicTableOwnerNameList) String() string {
	return tea.Prettify(s)
}

func (s ListLogicTablesResponseBodyLogicTableListLogicTableOwnerNameList) GoString() string {
	return s.String()
}

func (s *ListLogicTablesResponseBodyLogicTableListLogicTableOwnerNameList) SetOwnerNames(v []*string) *ListLogicTablesResponseBodyLogicTableListLogicTableOwnerNameList {
	s.OwnerNames = v
	return s
}

type ListLogicTablesResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListLogicTablesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListLogicTablesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListLogicTablesResponse) GoString() string {
	return s.String()
}

func (s *ListLogicTablesResponse) SetHeaders(v map[string]*string) *ListLogicTablesResponse {
	s.Headers = v
	return s
}

func (s *ListLogicTablesResponse) SetStatusCode(v int32) *ListLogicTablesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListLogicTablesResponse) SetBody(v *ListLogicTablesResponseBody) *ListLogicTablesResponse {
	s.Body = v
	return s
}

type ListOrdersRequest struct {
	// The end of the time range to query.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The scope of the tickets that you want to query. Valid values:
	//
	// *   **AS_ADMIN**: all tickets.
	// *   **AS_COMMITTER**: the tickets that are submitted by the current user.
	// *   **AS_HANDLER**: the tickets to be processed by the current user.
	// *   **AS_OWNER**: the tickets that are processed by the current user.
	// *   **AS_Related**: the tickets that are related to the current user.
	OrderResultType *string `json:"OrderResultType,omitempty" xml:"OrderResultType,omitempty"`
	// The status of the tickets that you want to query. Valid values:
	//
	// *   **ALL**: queries the tickets of all statuses.
	// *   **FINISHED**: queries the tickets that are completed.
	// *   **RUNNING**: queries the tickets that are being processed.
	OrderStatus *string `json:"OrderStatus,omitempty" xml:"OrderStatus,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The type of the tickets that you want to query. For more information, see [PluginType parameter](~~429109~~).
	PluginType *string `json:"PluginType,omitempty" xml:"PluginType,omitempty"`
	// The keyword that is used to query tickets.
	SearchContent *string `json:"SearchContent,omitempty" xml:"SearchContent,omitempty"`
	// The time condition based on which you want to query tickets. Valid values:
	//
	// *   **CREATE_TIME**: the time when a ticket was created.
	// *   **MODIFY_TIME**: the time when a ticket was last modified.
	SearchDateType *string `json:"SearchDateType,omitempty" xml:"SearchDateType,omitempty"`
	// The beginning of the time range to query.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListOrdersRequest) String() string {
	return tea.Prettify(s)
}

func (s ListOrdersRequest) GoString() string {
	return s.String()
}

func (s *ListOrdersRequest) SetEndTime(v string) *ListOrdersRequest {
	s.EndTime = &v
	return s
}

func (s *ListOrdersRequest) SetOrderResultType(v string) *ListOrdersRequest {
	s.OrderResultType = &v
	return s
}

func (s *ListOrdersRequest) SetOrderStatus(v string) *ListOrdersRequest {
	s.OrderStatus = &v
	return s
}

func (s *ListOrdersRequest) SetPageNumber(v int32) *ListOrdersRequest {
	s.PageNumber = &v
	return s
}

func (s *ListOrdersRequest) SetPageSize(v int32) *ListOrdersRequest {
	s.PageSize = &v
	return s
}

func (s *ListOrdersRequest) SetPluginType(v string) *ListOrdersRequest {
	s.PluginType = &v
	return s
}

func (s *ListOrdersRequest) SetSearchContent(v string) *ListOrdersRequest {
	s.SearchContent = &v
	return s
}

func (s *ListOrdersRequest) SetSearchDateType(v string) *ListOrdersRequest {
	s.SearchDateType = &v
	return s
}

func (s *ListOrdersRequest) SetStartTime(v string) *ListOrdersRequest {
	s.StartTime = &v
	return s
}

func (s *ListOrdersRequest) SetTid(v int64) *ListOrdersRequest {
	s.Tid = &v
	return s
}

type ListOrdersResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The details about the tickets.
	Orders *ListOrdersResponseBodyOrders `json:"Orders,omitempty" xml:"Orders,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// - **true**: The request was successful.
	// - **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of entries that are returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListOrdersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListOrdersResponseBody) GoString() string {
	return s.String()
}

func (s *ListOrdersResponseBody) SetErrorCode(v string) *ListOrdersResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListOrdersResponseBody) SetErrorMessage(v string) *ListOrdersResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListOrdersResponseBody) SetOrders(v *ListOrdersResponseBodyOrders) *ListOrdersResponseBody {
	s.Orders = v
	return s
}

func (s *ListOrdersResponseBody) SetRequestId(v string) *ListOrdersResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListOrdersResponseBody) SetSuccess(v bool) *ListOrdersResponseBody {
	s.Success = &v
	return s
}

func (s *ListOrdersResponseBody) SetTotalCount(v int64) *ListOrdersResponseBody {
	s.TotalCount = &v
	return s
}

type ListOrdersResponseBodyOrders struct {
	Order []*ListOrdersResponseBodyOrdersOrder `json:"Order,omitempty" xml:"Order,omitempty" type:"Repeated"`
}

func (s ListOrdersResponseBodyOrders) String() string {
	return tea.Prettify(s)
}

func (s ListOrdersResponseBodyOrders) GoString() string {
	return s.String()
}

func (s *ListOrdersResponseBodyOrders) SetOrder(v []*ListOrdersResponseBodyOrdersOrder) *ListOrdersResponseBodyOrders {
	s.Order = v
	return s
}

type ListOrdersResponseBodyOrdersOrder struct {
	// The remarks of the ticket.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The user who submitted the ticket.
	Committer *string `json:"Committer,omitempty" xml:"Committer,omitempty"`
	// The ID of the user who submitted the ticket.
	CommitterId *int64 `json:"CommitterId,omitempty" xml:"CommitterId,omitempty"`
	// The time when the ticket was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The time when the ticket was last modified.
	LastModifyTime *string `json:"LastModifyTime,omitempty" xml:"LastModifyTime,omitempty"`
	// The ID of the ticket.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The type of the ticket.
	PluginType *string `json:"PluginType,omitempty" xml:"PluginType,omitempty"`
	// The status code of the ticket. Valid values:
	//
	// *   **fail**: The ticket fails to be executed.
	// *   **toaudit**: The ticket is waiting for approval.
	// *   **cancel**: The ticket is cancelled.
	// *   **processing**: The ticket is being executed.
	// *   **approved**: The ticket is approved.
	// *   **reject**: The ticket is rejected.
	// *   **success**: The ticket is executed.
	// *   **closed**: The ticket is closed.
	StatusCode *string `json:"StatusCode,omitempty" xml:"StatusCode,omitempty"`
	// The status description of the ticket.
	StatusDesc *string `json:"StatusDesc,omitempty" xml:"StatusDesc,omitempty"`
}

func (s ListOrdersResponseBodyOrdersOrder) String() string {
	return tea.Prettify(s)
}

func (s ListOrdersResponseBodyOrdersOrder) GoString() string {
	return s.String()
}

func (s *ListOrdersResponseBodyOrdersOrder) SetComment(v string) *ListOrdersResponseBodyOrdersOrder {
	s.Comment = &v
	return s
}

func (s *ListOrdersResponseBodyOrdersOrder) SetCommitter(v string) *ListOrdersResponseBodyOrdersOrder {
	s.Committer = &v
	return s
}

func (s *ListOrdersResponseBodyOrdersOrder) SetCommitterId(v int64) *ListOrdersResponseBodyOrdersOrder {
	s.CommitterId = &v
	return s
}

func (s *ListOrdersResponseBodyOrdersOrder) SetCreateTime(v string) *ListOrdersResponseBodyOrdersOrder {
	s.CreateTime = &v
	return s
}

func (s *ListOrdersResponseBodyOrdersOrder) SetLastModifyTime(v string) *ListOrdersResponseBodyOrdersOrder {
	s.LastModifyTime = &v
	return s
}

func (s *ListOrdersResponseBodyOrdersOrder) SetOrderId(v int64) *ListOrdersResponseBodyOrdersOrder {
	s.OrderId = &v
	return s
}

func (s *ListOrdersResponseBodyOrdersOrder) SetPluginType(v string) *ListOrdersResponseBodyOrdersOrder {
	s.PluginType = &v
	return s
}

func (s *ListOrdersResponseBodyOrdersOrder) SetStatusCode(v string) *ListOrdersResponseBodyOrdersOrder {
	s.StatusCode = &v
	return s
}

func (s *ListOrdersResponseBodyOrdersOrder) SetStatusDesc(v string) *ListOrdersResponseBodyOrdersOrder {
	s.StatusDesc = &v
	return s
}

type ListOrdersResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListOrdersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListOrdersResponse) String() string {
	return tea.Prettify(s)
}

func (s ListOrdersResponse) GoString() string {
	return s.String()
}

func (s *ListOrdersResponse) SetHeaders(v map[string]*string) *ListOrdersResponse {
	s.Headers = v
	return s
}

func (s *ListOrdersResponse) SetStatusCode(v int32) *ListOrdersResponse {
	s.StatusCode = &v
	return s
}

func (s *ListOrdersResponse) SetBody(v *ListOrdersResponseBody) *ListOrdersResponse {
	s.Body = v
	return s
}

type ListProxiesRequest struct {
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListProxiesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListProxiesRequest) GoString() string {
	return s.String()
}

func (s *ListProxiesRequest) SetTid(v int64) *ListProxiesRequest {
	s.Tid = &v
	return s
}

type ListProxiesResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The proxies that are generated by the secure access proxy feature.
	ProxyList []*ListProxiesResponseBodyProxyList `json:"ProxyList,omitempty" xml:"ProxyList,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListProxiesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListProxiesResponseBody) GoString() string {
	return s.String()
}

func (s *ListProxiesResponseBody) SetErrorCode(v string) *ListProxiesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListProxiesResponseBody) SetErrorMessage(v string) *ListProxiesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListProxiesResponseBody) SetProxyList(v []*ListProxiesResponseBodyProxyList) *ListProxiesResponseBody {
	s.ProxyList = v
	return s
}

func (s *ListProxiesResponseBody) SetRequestId(v string) *ListProxiesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListProxiesResponseBody) SetSuccess(v bool) *ListProxiesResponseBody {
	s.Success = &v
	return s
}

type ListProxiesResponseBodyProxyList struct {
	// The ID of the user who enabled the secure access proxy feature.
	CreatorId *int64 `json:"CreatorId,omitempty" xml:"CreatorId,omitempty"`
	// The nickname of the user who enabled the secure access proxy feature.
	CreatorName *string `json:"CreatorName,omitempty" xml:"CreatorName,omitempty"`
	// The number of the port that was used by HTTPS clients to connect to the database instance.
	HttpsPort *int32 `json:"HttpsPort,omitempty" xml:"HttpsPort,omitempty"`
	// The ID of the instance.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// Indicates whether the internal endpoint is enabled. Default value: **true**.
	PrivateEnable *bool `json:"PrivateEnable,omitempty" xml:"PrivateEnable,omitempty"`
	// The internal endpoint.
	PrivateHost *string `json:"PrivateHost,omitempty" xml:"PrivateHost,omitempty"`
	// The number of the port that is used to connect the database instance.
	ProtocolPort *int32 `json:"ProtocolPort,omitempty" xml:"ProtocolPort,omitempty"`
	// The type of the database. Example: MYSQL.
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The ID of the secure access proxy.
	ProxyId *int64 `json:"ProxyId,omitempty" xml:"ProxyId,omitempty"`
	// Indicates whether the public endpoint is enabled. Valid values:
	//
	// *   **true**: The public endpoint is enabled.
	// *   **false**: The public endpoint is disabled.
	PublicEnable *bool `json:"PublicEnable,omitempty" xml:"PublicEnable,omitempty"`
	// The public endpoint. A public endpoint is returned no matter whether the public endpoint is enabled or disabled.
	//
	// >
	//
	// *   If the value of the PublicEnable parameter is **true**, a valid public endpoint that can be resolved by using Alibaba Cloud DNS (DNS) is returned.
	//
	// *   If the value of the PublicEnable parameter is **false**, an invalid public endpoint that cannot be resolved by using DNS is returned.
	PublicHost *string `json:"PublicHost,omitempty" xml:"PublicHost,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListProxiesResponseBodyProxyList) String() string {
	return tea.Prettify(s)
}

func (s ListProxiesResponseBodyProxyList) GoString() string {
	return s.String()
}

func (s *ListProxiesResponseBodyProxyList) SetCreatorId(v int64) *ListProxiesResponseBodyProxyList {
	s.CreatorId = &v
	return s
}

func (s *ListProxiesResponseBodyProxyList) SetCreatorName(v string) *ListProxiesResponseBodyProxyList {
	s.CreatorName = &v
	return s
}

func (s *ListProxiesResponseBodyProxyList) SetHttpsPort(v int32) *ListProxiesResponseBodyProxyList {
	s.HttpsPort = &v
	return s
}

func (s *ListProxiesResponseBodyProxyList) SetInstanceId(v int64) *ListProxiesResponseBodyProxyList {
	s.InstanceId = &v
	return s
}

func (s *ListProxiesResponseBodyProxyList) SetPrivateEnable(v bool) *ListProxiesResponseBodyProxyList {
	s.PrivateEnable = &v
	return s
}

func (s *ListProxiesResponseBodyProxyList) SetPrivateHost(v string) *ListProxiesResponseBodyProxyList {
	s.PrivateHost = &v
	return s
}

func (s *ListProxiesResponseBodyProxyList) SetProtocolPort(v int32) *ListProxiesResponseBodyProxyList {
	s.ProtocolPort = &v
	return s
}

func (s *ListProxiesResponseBodyProxyList) SetProtocolType(v string) *ListProxiesResponseBodyProxyList {
	s.ProtocolType = &v
	return s
}

func (s *ListProxiesResponseBodyProxyList) SetProxyId(v int64) *ListProxiesResponseBodyProxyList {
	s.ProxyId = &v
	return s
}

func (s *ListProxiesResponseBodyProxyList) SetPublicEnable(v bool) *ListProxiesResponseBodyProxyList {
	s.PublicEnable = &v
	return s
}

func (s *ListProxiesResponseBodyProxyList) SetPublicHost(v string) *ListProxiesResponseBodyProxyList {
	s.PublicHost = &v
	return s
}

func (s *ListProxiesResponseBodyProxyList) SetRegionId(v string) *ListProxiesResponseBodyProxyList {
	s.RegionId = &v
	return s
}

type ListProxiesResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListProxiesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListProxiesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListProxiesResponse) GoString() string {
	return s.String()
}

func (s *ListProxiesResponse) SetHeaders(v map[string]*string) *ListProxiesResponse {
	s.Headers = v
	return s
}

func (s *ListProxiesResponse) SetStatusCode(v int32) *ListProxiesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListProxiesResponse) SetBody(v *ListProxiesResponseBody) *ListProxiesResponse {
	s.Body = v
	return s
}

type ListProxyAccessesRequest struct {
	// The ID of the secure access proxy.
	//
	// >  You can call the [ListProxies](https://www.alibabacloud.com/help/en/data-management-service/latest/listproxies) operation to query the ID of the secure access proxy.
	ProxyId *int64 `json:"ProxyId,omitempty" xml:"ProxyId,omitempty"`
	// The ID of the tenant.
	//
	// >  You can call the [GetUserActiveTenant](https://www.alibabacloud.com/help/en/data-management-service/latest/getuseractivetenant) operation to query the ID of the tenant.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListProxyAccessesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListProxyAccessesRequest) GoString() string {
	return s.String()
}

func (s *ListProxyAccessesRequest) SetProxyId(v int64) *ListProxyAccessesRequest {
	s.ProxyId = &v
	return s
}

func (s *ListProxyAccessesRequest) SetTid(v int64) *ListProxyAccessesRequest {
	s.Tid = &v
	return s
}

type ListProxyAccessesResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The information about the users that are authorized to access the database instance by using the secure access proxy feature.
	ProxyAccessList []*ListProxyAccessesResponseBodyProxyAccessList `json:"ProxyAccessList,omitempty" xml:"ProxyAccessList,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// - **true**: The request was successful.
	// - **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListProxyAccessesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListProxyAccessesResponseBody) GoString() string {
	return s.String()
}

func (s *ListProxyAccessesResponseBody) SetErrorCode(v string) *ListProxyAccessesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListProxyAccessesResponseBody) SetErrorMessage(v string) *ListProxyAccessesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListProxyAccessesResponseBody) SetProxyAccessList(v []*ListProxyAccessesResponseBodyProxyAccessList) *ListProxyAccessesResponseBody {
	s.ProxyAccessList = v
	return s
}

func (s *ListProxyAccessesResponseBody) SetRequestId(v string) *ListProxyAccessesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListProxyAccessesResponseBody) SetSuccess(v bool) *ListProxyAccessesResponseBody {
	s.Success = &v
	return s
}

type ListProxyAccessesResponseBodyProxyAccessList struct {
	// The username of the database account that is authorized to access the database instance by using the secure access proxy feature.
	AccessId *string `json:"AccessId,omitempty" xml:"AccessId,omitempty"`
	// The time when the user is authorized to access the database instance by using the secure access proxy feature.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The username of the independent database account.
	IndepAccount *string `json:"IndepAccount,omitempty" xml:"IndepAccount,omitempty"`
	// The ID of the database instance.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The method that is used to authorize the user to access the database instance by using the secure access proxy feature. Valid values:
	//
	// - **Authorization by the Alibaba Cloud Account ()**: The information in the parentheses () indicates the user ID (UID) of the Alibaba Cloud account.
	// - **Authorization by submitting the ticket ()**:The information in the parentheses () indicates the number of the ticket that the user submits to apply for permissions.
	OriginInfo *string `json:"OriginInfo,omitempty" xml:"OriginInfo,omitempty"`
	// The ID that DMS generates after the user is authorized to access the database instance by using the secure access proxy feature. The ID is unique in DMS.
	ProxyAccessId *int64 `json:"ProxyAccessId,omitempty" xml:"ProxyAccessId,omitempty"`
	// The ID of the secure access proxy.
	ProxyId *int64 `json:"ProxyId,omitempty" xml:"ProxyId,omitempty"`
	// The ID of the user.
	UserId *int64 `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The nickname of the user.
	UserName *string `json:"UserName,omitempty" xml:"UserName,omitempty"`
	// The UID of the Alibaba Cloud account.
	UserUid *string `json:"UserUid,omitempty" xml:"UserUid,omitempty"`
}

func (s ListProxyAccessesResponseBodyProxyAccessList) String() string {
	return tea.Prettify(s)
}

func (s ListProxyAccessesResponseBodyProxyAccessList) GoString() string {
	return s.String()
}

func (s *ListProxyAccessesResponseBodyProxyAccessList) SetAccessId(v string) *ListProxyAccessesResponseBodyProxyAccessList {
	s.AccessId = &v
	return s
}

func (s *ListProxyAccessesResponseBodyProxyAccessList) SetGmtCreate(v string) *ListProxyAccessesResponseBodyProxyAccessList {
	s.GmtCreate = &v
	return s
}

func (s *ListProxyAccessesResponseBodyProxyAccessList) SetIndepAccount(v string) *ListProxyAccessesResponseBodyProxyAccessList {
	s.IndepAccount = &v
	return s
}

func (s *ListProxyAccessesResponseBodyProxyAccessList) SetInstanceId(v int64) *ListProxyAccessesResponseBodyProxyAccessList {
	s.InstanceId = &v
	return s
}

func (s *ListProxyAccessesResponseBodyProxyAccessList) SetOriginInfo(v string) *ListProxyAccessesResponseBodyProxyAccessList {
	s.OriginInfo = &v
	return s
}

func (s *ListProxyAccessesResponseBodyProxyAccessList) SetProxyAccessId(v int64) *ListProxyAccessesResponseBodyProxyAccessList {
	s.ProxyAccessId = &v
	return s
}

func (s *ListProxyAccessesResponseBodyProxyAccessList) SetProxyId(v int64) *ListProxyAccessesResponseBodyProxyAccessList {
	s.ProxyId = &v
	return s
}

func (s *ListProxyAccessesResponseBodyProxyAccessList) SetUserId(v int64) *ListProxyAccessesResponseBodyProxyAccessList {
	s.UserId = &v
	return s
}

func (s *ListProxyAccessesResponseBodyProxyAccessList) SetUserName(v string) *ListProxyAccessesResponseBodyProxyAccessList {
	s.UserName = &v
	return s
}

func (s *ListProxyAccessesResponseBodyProxyAccessList) SetUserUid(v string) *ListProxyAccessesResponseBodyProxyAccessList {
	s.UserUid = &v
	return s
}

type ListProxyAccessesResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListProxyAccessesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListProxyAccessesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListProxyAccessesResponse) GoString() string {
	return s.String()
}

func (s *ListProxyAccessesResponse) SetHeaders(v map[string]*string) *ListProxyAccessesResponse {
	s.Headers = v
	return s
}

func (s *ListProxyAccessesResponse) SetStatusCode(v int32) *ListProxyAccessesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListProxyAccessesResponse) SetBody(v *ListProxyAccessesResponseBody) *ListProxyAccessesResponse {
	s.Body = v
	return s
}

type ListProxySQLExecAuditLogRequest struct {
	// The end of the time range to query. The value of this parameter must be a timestamp that follows the UNIX time format.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The execution status of the SQL statement. Valid values:
	//
	// *   **FAIL**: The execution of the SQL statement fails.
	// *   **CANCEL**: The execution of the SQL statement is canceled.
	// *   **SUCCESS**: The SQL statement is executed.
	ExecState *string `json:"ExecState,omitempty" xml:"ExecState,omitempty"`
	// The alias of the user.
	OpUserName *string `json:"OpUserName,omitempty" xml:"OpUserName,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum values: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The type of SQL statement. Valid values:
	//
	// *   **SELECT**
	// *   **INSERT**
	// *   **DELETE**
	// *   **CREATE_TABLE**
	//
	// >  You can choose Operation Audit > Secure Access Proxy in the top navigation bar of the DMS console to view more types of SQL statements.
	SQLType *string `json:"SQLType,omitempty" xml:"SQLType,omitempty"`
	// The name of the database instance.
	SearchName *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
	// The beginning of the time range to query. The value of this parameter must be a timestamp that follows the UNIX time format.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListProxySQLExecAuditLogRequest) String() string {
	return tea.Prettify(s)
}

func (s ListProxySQLExecAuditLogRequest) GoString() string {
	return s.String()
}

func (s *ListProxySQLExecAuditLogRequest) SetEndTime(v int64) *ListProxySQLExecAuditLogRequest {
	s.EndTime = &v
	return s
}

func (s *ListProxySQLExecAuditLogRequest) SetExecState(v string) *ListProxySQLExecAuditLogRequest {
	s.ExecState = &v
	return s
}

func (s *ListProxySQLExecAuditLogRequest) SetOpUserName(v string) *ListProxySQLExecAuditLogRequest {
	s.OpUserName = &v
	return s
}

func (s *ListProxySQLExecAuditLogRequest) SetPageNumber(v int32) *ListProxySQLExecAuditLogRequest {
	s.PageNumber = &v
	return s
}

func (s *ListProxySQLExecAuditLogRequest) SetPageSize(v int32) *ListProxySQLExecAuditLogRequest {
	s.PageSize = &v
	return s
}

func (s *ListProxySQLExecAuditLogRequest) SetSQLType(v string) *ListProxySQLExecAuditLogRequest {
	s.SQLType = &v
	return s
}

func (s *ListProxySQLExecAuditLogRequest) SetSearchName(v string) *ListProxySQLExecAuditLogRequest {
	s.SearchName = &v
	return s
}

func (s *ListProxySQLExecAuditLogRequest) SetStartTime(v int64) *ListProxySQLExecAuditLogRequest {
	s.StartTime = &v
	return s
}

func (s *ListProxySQLExecAuditLogRequest) SetTid(v int64) *ListProxySQLExecAuditLogRequest {
	s.Tid = &v
	return s
}

type ListProxySQLExecAuditLogResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The audit information about the database instance that is provided by the secure access proxy feature.
	ProxySQLExecAuditLogList *ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogList `json:"ProxySQLExecAuditLogList,omitempty" xml:"ProxySQLExecAuditLogList,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The number of entries returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListProxySQLExecAuditLogResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListProxySQLExecAuditLogResponseBody) GoString() string {
	return s.String()
}

func (s *ListProxySQLExecAuditLogResponseBody) SetErrorCode(v string) *ListProxySQLExecAuditLogResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListProxySQLExecAuditLogResponseBody) SetErrorMessage(v string) *ListProxySQLExecAuditLogResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListProxySQLExecAuditLogResponseBody) SetProxySQLExecAuditLogList(v *ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogList) *ListProxySQLExecAuditLogResponseBody {
	s.ProxySQLExecAuditLogList = v
	return s
}

func (s *ListProxySQLExecAuditLogResponseBody) SetRequestId(v string) *ListProxySQLExecAuditLogResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListProxySQLExecAuditLogResponseBody) SetSuccess(v bool) *ListProxySQLExecAuditLogResponseBody {
	s.Success = &v
	return s
}

func (s *ListProxySQLExecAuditLogResponseBody) SetTotalCount(v int64) *ListProxySQLExecAuditLogResponseBody {
	s.TotalCount = &v
	return s
}

type ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogList struct {
	ProxySQLExecAuditLog []*ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog `json:"ProxySQLExecAuditLog,omitempty" xml:"ProxySQLExecAuditLog,omitempty" type:"Repeated"`
}

func (s ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogList) String() string {
	return tea.Prettify(s)
}

func (s ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogList) GoString() string {
	return s.String()
}

func (s *ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogList) SetProxySQLExecAuditLog(v []*ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog) *ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogList {
	s.ProxySQLExecAuditLog = v
	return s
}

type ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog struct {
	// Indicates the total number of rows returned after the SQL statement was executed. If an SELECT SQL statement is executed, the return value of this parameter indicates the total number of the queried data rows.
	AffectRows *int64 `json:"AffectRows,omitempty" xml:"AffectRows,omitempty"`
	// The amount of time that is consumed to execute the SQL statement. Unit: milliseconds.
	ElapsedTime *int64 `json:"ElapsedTime,omitempty" xml:"ElapsedTime,omitempty"`
	// The execution status of the SQL statement. Valid values:
	//
	// *   **FAIL**: The execution of the SQL statement fails.
	// *   **CANCEL**: The execution of the SQL statement is canceled.
	// *   **SUCCESS**: The SQL statement is executed.
	ExecState *string `json:"ExecState,omitempty" xml:"ExecState,omitempty"`
	// The ID of the database instance.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The name of the database instance.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// The time at which the user executes the SQL statement on the database instance. The value of this parameter must be a timestamp that follows the UNIX time format.
	OpTime *string `json:"OpTime,omitempty" xml:"OpTime,omitempty"`
	// The description.
	Remark *string `json:"Remark,omitempty" xml:"Remark,omitempty"`
	// The SQL statement that was executed.
	SQL *string `json:"SQL,omitempty" xml:"SQL,omitempty"`
	// The type of the SQL statement. Valid values:
	//
	// *   **SELECT**
	// *   **INSERT**
	// *   **DELETE**
	// *   **CREATE_TABLE**
	//
	// >  You can choose Operation Audit > Secure Access Proxy in the top navigation bar of the DMS console to view more types of SQL statements.
	SQLType *string `json:"SQLType,omitempty" xml:"SQLType,omitempty"`
	// The name of the database.
	SchemaName *string `json:"SchemaName,omitempty" xml:"SchemaName,omitempty"`
	// The ID of the user.
	UserId *int64 `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The nickname of the user.
	UserName *string `json:"UserName,omitempty" xml:"UserName,omitempty"`
}

func (s ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog) String() string {
	return tea.Prettify(s)
}

func (s ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog) GoString() string {
	return s.String()
}

func (s *ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog) SetAffectRows(v int64) *ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog {
	s.AffectRows = &v
	return s
}

func (s *ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog) SetElapsedTime(v int64) *ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog {
	s.ElapsedTime = &v
	return s
}

func (s *ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog) SetExecState(v string) *ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog {
	s.ExecState = &v
	return s
}

func (s *ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog) SetInstanceId(v int64) *ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog {
	s.InstanceId = &v
	return s
}

func (s *ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog) SetInstanceName(v string) *ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog {
	s.InstanceName = &v
	return s
}

func (s *ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog) SetOpTime(v string) *ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog {
	s.OpTime = &v
	return s
}

func (s *ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog) SetRemark(v string) *ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog {
	s.Remark = &v
	return s
}

func (s *ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog) SetSQL(v string) *ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog {
	s.SQL = &v
	return s
}

func (s *ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog) SetSQLType(v string) *ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog {
	s.SQLType = &v
	return s
}

func (s *ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog) SetSchemaName(v string) *ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog {
	s.SchemaName = &v
	return s
}

func (s *ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog) SetUserId(v int64) *ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog {
	s.UserId = &v
	return s
}

func (s *ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog) SetUserName(v string) *ListProxySQLExecAuditLogResponseBodyProxySQLExecAuditLogListProxySQLExecAuditLog {
	s.UserName = &v
	return s
}

type ListProxySQLExecAuditLogResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListProxySQLExecAuditLogResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListProxySQLExecAuditLogResponse) String() string {
	return tea.Prettify(s)
}

func (s ListProxySQLExecAuditLogResponse) GoString() string {
	return s.String()
}

func (s *ListProxySQLExecAuditLogResponse) SetHeaders(v map[string]*string) *ListProxySQLExecAuditLogResponse {
	s.Headers = v
	return s
}

func (s *ListProxySQLExecAuditLogResponse) SetStatusCode(v int32) *ListProxySQLExecAuditLogResponse {
	s.StatusCode = &v
	return s
}

func (s *ListProxySQLExecAuditLogResponse) SetBody(v *ListProxySQLExecAuditLogResponseBody) *ListProxySQLExecAuditLogResponse {
	s.Body = v
	return s
}

type ListSLARulesRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the tenant.
	//
	// > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListSLARulesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListSLARulesRequest) GoString() string {
	return s.String()
}

func (s *ListSLARulesRequest) SetDagId(v int64) *ListSLARulesRequest {
	s.DagId = &v
	return s
}

func (s *ListSLARulesRequest) SetTid(v int64) *ListSLARulesRequest {
	s.Tid = &v
	return s
}

type ListSLARulesResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of SLA rules.
	SLARuleList *ListSLARulesResponseBodySLARuleList `json:"SLARuleList,omitempty" xml:"SLARuleList,omitempty" type:"Struct"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListSLARulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListSLARulesResponseBody) GoString() string {
	return s.String()
}

func (s *ListSLARulesResponseBody) SetErrorCode(v string) *ListSLARulesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListSLARulesResponseBody) SetErrorMessage(v string) *ListSLARulesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListSLARulesResponseBody) SetRequestId(v string) *ListSLARulesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListSLARulesResponseBody) SetSLARuleList(v *ListSLARulesResponseBodySLARuleList) *ListSLARulesResponseBody {
	s.SLARuleList = v
	return s
}

func (s *ListSLARulesResponseBody) SetSuccess(v bool) *ListSLARulesResponseBody {
	s.Success = &v
	return s
}

type ListSLARulesResponseBodySLARuleList struct {
	SLARule []*ListSLARulesResponseBodySLARuleListSLARule `json:"SLARule,omitempty" xml:"SLARule,omitempty" type:"Repeated"`
}

func (s ListSLARulesResponseBodySLARuleList) String() string {
	return tea.Prettify(s)
}

func (s ListSLARulesResponseBodySLARuleList) GoString() string {
	return s.String()
}

func (s *ListSLARulesResponseBodySLARuleList) SetSLARule(v []*ListSLARulesResponseBodySLARuleListSLARule) *ListSLARulesResponseBodySLARuleList {
	s.SLARule = v
	return s
}

type ListSLARulesResponseBodySLARuleListSLARule struct {
	// The ID of the task flow.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the SLA rule.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The timeout period. Unit: minutes.
	IntervalMinutes *int32 `json:"IntervalMinutes,omitempty" xml:"IntervalMinutes,omitempty"`
	// The ID of the task node.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The type of the rule. Valid values:
	//
	// *   **0**: an SLA rule for a task flow
	// *   **1**: an SLA rule for a task node
	RuleType *int32 `json:"RuleType,omitempty" xml:"RuleType,omitempty"`
}

func (s ListSLARulesResponseBodySLARuleListSLARule) String() string {
	return tea.Prettify(s)
}

func (s ListSLARulesResponseBodySLARuleListSLARule) GoString() string {
	return s.String()
}

func (s *ListSLARulesResponseBodySLARuleListSLARule) SetDagId(v int64) *ListSLARulesResponseBodySLARuleListSLARule {
	s.DagId = &v
	return s
}

func (s *ListSLARulesResponseBodySLARuleListSLARule) SetId(v int64) *ListSLARulesResponseBodySLARuleListSLARule {
	s.Id = &v
	return s
}

func (s *ListSLARulesResponseBodySLARuleListSLARule) SetIntervalMinutes(v int32) *ListSLARulesResponseBodySLARuleListSLARule {
	s.IntervalMinutes = &v
	return s
}

func (s *ListSLARulesResponseBodySLARuleListSLARule) SetNodeId(v int64) *ListSLARulesResponseBodySLARuleListSLARule {
	s.NodeId = &v
	return s
}

func (s *ListSLARulesResponseBodySLARuleListSLARule) SetRuleType(v int32) *ListSLARulesResponseBodySLARuleListSLARule {
	s.RuleType = &v
	return s
}

type ListSLARulesResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListSLARulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListSLARulesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListSLARulesResponse) GoString() string {
	return s.String()
}

func (s *ListSLARulesResponse) SetHeaders(v map[string]*string) *ListSLARulesResponse {
	s.Headers = v
	return s
}

func (s *ListSLARulesResponse) SetStatusCode(v int32) *ListSLARulesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListSLARulesResponse) SetBody(v *ListSLARulesResponseBody) *ListSLARulesResponse {
	s.Body = v
	return s
}

type ListSQLExecAuditLogRequest struct {
	// The end of the time range to query.
	//
	// >  The end time supports fuzzy match. Specify the time in the YYYY-MM-DD hh:mm:ss format. We recommend that you use the StartTime and EndTime parameters to specify a time range that does not exceed one day. The returned entries can be displayed by page to improve query efficiency.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The execution status of the SQL statement. Valid values:
	//
	// *   **FAIL**: The SQL statement fails to be executed.
	// *   **NOEXE**: The SQL statement has not been executed.
	// *   **RUNNING**: The SQL statement is being executed.
	// *   **CANCEL**: The execution of the SQL statement is canceled.
	// *   **SUCCESS**: The SQL statement is executed.
	ExecState *string `json:"ExecState,omitempty" xml:"ExecState,omitempty"`
	// The nickname of the user who wrote the SQL statement.
	OpUserName *string `json:"OpUserName,omitempty" xml:"OpUserName,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. The value cannot exceed 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The name of the database or instance based on which you want to query SQL statements.
	//
	// >  If the SQL statements to be queried are at the instance level, you can set this parameter to an instance name. If the SQL statements to be queried are at the database level, you can set this parameter to a database name.
	SearchName *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
	// The type of the SQL statement. Valid values:
	//
	// *   **SELECT**: the SQL statement that is used to query data.
	// *   **INSERT**: the SQL statement that is used to insert data.
	// *   **DELETE**: the SQL statement that is used to delete data.
	// *   **CREATE_TABLE**: the SQL statement that is used to create tables.
	//
	// >  To view more types of SQL statements, log on to the DMS console and click Security and Specifications. In the left-side navigation pane, click **Operation Audit**. Then, you can view all supported types of SQL statements from the **SQL type** drop-down list.
	SqlType *string `json:"SqlType,omitempty" xml:"SqlType,omitempty"`
	// The beginning of the time range to query.
	//
	// >  The start time supports fuzzy match. Specify the time in the YYYY-MM-DD hh:mm:ss format.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListSQLExecAuditLogRequest) String() string {
	return tea.Prettify(s)
}

func (s ListSQLExecAuditLogRequest) GoString() string {
	return s.String()
}

func (s *ListSQLExecAuditLogRequest) SetEndTime(v string) *ListSQLExecAuditLogRequest {
	s.EndTime = &v
	return s
}

func (s *ListSQLExecAuditLogRequest) SetExecState(v string) *ListSQLExecAuditLogRequest {
	s.ExecState = &v
	return s
}

func (s *ListSQLExecAuditLogRequest) SetOpUserName(v string) *ListSQLExecAuditLogRequest {
	s.OpUserName = &v
	return s
}

func (s *ListSQLExecAuditLogRequest) SetPageNumber(v int32) *ListSQLExecAuditLogRequest {
	s.PageNumber = &v
	return s
}

func (s *ListSQLExecAuditLogRequest) SetPageSize(v int32) *ListSQLExecAuditLogRequest {
	s.PageSize = &v
	return s
}

func (s *ListSQLExecAuditLogRequest) SetSearchName(v string) *ListSQLExecAuditLogRequest {
	s.SearchName = &v
	return s
}

func (s *ListSQLExecAuditLogRequest) SetSqlType(v string) *ListSQLExecAuditLogRequest {
	s.SqlType = &v
	return s
}

func (s *ListSQLExecAuditLogRequest) SetStartTime(v string) *ListSQLExecAuditLogRequest {
	s.StartTime = &v
	return s
}

func (s *ListSQLExecAuditLogRequest) SetTid(v int64) *ListSQLExecAuditLogRequest {
	s.Tid = &v
	return s
}

type ListSQLExecAuditLogResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The entries returned.
	SQLExecAuditLogList *ListSQLExecAuditLogResponseBodySQLExecAuditLogList `json:"SQLExecAuditLogList,omitempty" xml:"SQLExecAuditLogList,omitempty" type:"Struct"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The number of entries returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListSQLExecAuditLogResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListSQLExecAuditLogResponseBody) GoString() string {
	return s.String()
}

func (s *ListSQLExecAuditLogResponseBody) SetErrorCode(v string) *ListSQLExecAuditLogResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListSQLExecAuditLogResponseBody) SetErrorMessage(v string) *ListSQLExecAuditLogResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListSQLExecAuditLogResponseBody) SetRequestId(v string) *ListSQLExecAuditLogResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListSQLExecAuditLogResponseBody) SetSQLExecAuditLogList(v *ListSQLExecAuditLogResponseBodySQLExecAuditLogList) *ListSQLExecAuditLogResponseBody {
	s.SQLExecAuditLogList = v
	return s
}

func (s *ListSQLExecAuditLogResponseBody) SetSuccess(v bool) *ListSQLExecAuditLogResponseBody {
	s.Success = &v
	return s
}

func (s *ListSQLExecAuditLogResponseBody) SetTotalCount(v int64) *ListSQLExecAuditLogResponseBody {
	s.TotalCount = &v
	return s
}

type ListSQLExecAuditLogResponseBodySQLExecAuditLogList struct {
	SQLExecAuditLog []*ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog `json:"SQLExecAuditLog,omitempty" xml:"SQLExecAuditLog,omitempty" type:"Repeated"`
}

func (s ListSQLExecAuditLogResponseBodySQLExecAuditLogList) String() string {
	return tea.Prettify(s)
}

func (s ListSQLExecAuditLogResponseBodySQLExecAuditLogList) GoString() string {
	return s.String()
}

func (s *ListSQLExecAuditLogResponseBodySQLExecAuditLogList) SetSQLExecAuditLog(v []*ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog) *ListSQLExecAuditLogResponseBodySQLExecAuditLogList {
	s.SQLExecAuditLog = v
	return s
}

type ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog struct {
	// The number of rows affected by the SQL statement. For example, if you execute an SQL statement to query data, the number of retrieved rows is returned.
	AffectRows *int64 `json:"AffectRows,omitempty" xml:"AffectRows,omitempty"`
	// The ID of the database.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The amount of time consumed by the execution of the SQL statement. Unit: milliseconds.
	ElapsedTime *int64 `json:"ElapsedTime,omitempty" xml:"ElapsedTime,omitempty"`
	// The execution status of the SQL statement. Valid values:
	//
	// *   **FAIL**: The SQL statement fails to be executed.
	// *   **NOEXE**: The SQL statement has not been executed.
	// *   **RUNNING**: The SQL statement is being executed.
	// *   **CANCEL**: The execution of the SQL statement is canceled.
	// *   **SUCCESS**: The SQL statement is executed.
	ExecState *string `json:"ExecState,omitempty" xml:"ExecState,omitempty"`
	// The ID of the instance.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The name of the database.
	//
	// >  If the SQL statement takes effect on an instance, the name of the instance is returned.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// Indicates whether the database is a logical database. Valid values:
	//
	// *   **true**: The database is a logical database.
	// *   **false**: The database is a physical database.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The time when the operation specified by the SQL statement was performed on the instance or database.
	OpTime *string `json:"OpTime,omitempty" xml:"OpTime,omitempty"`
	// The comment on the SQL statement.
	Remark *string `json:"Remark,omitempty" xml:"Remark,omitempty"`
	// The SQL statement that was written.
	SQL *string `json:"SQL,omitempty" xml:"SQL,omitempty"`
	// The type of the SQL statement. Valid values:
	//
	// *   **SELECT**: the SQL statement that is used to query data.
	// *   **INSERT**: the SQL statement that is used to insert data.
	// *   **DELETE**: the SQL statement that is used to delete data.
	// *   **CREATE_TABLE**: the SQL statement that is used to create tables.
	//
	// >  To view more types of SQL statements, log on to the DMS console and click Security and Specifications. In the left-side navigation pane, click **Operation Audit**. Then, you can view all supported types of SQL statements from the **SQL type** drop-down list.
	SQLType *string `json:"SQLType,omitempty" xml:"SQLType,omitempty"`
	// The name of the database.
	SchemaName *string `json:"SchemaName,omitempty" xml:"SchemaName,omitempty"`
	// The ID of the user who wrote the SQL statement.
	UserId *int64 `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The nickname of the user who wrote the SQL statement.
	UserName *string `json:"UserName,omitempty" xml:"UserName,omitempty"`
}

func (s ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog) String() string {
	return tea.Prettify(s)
}

func (s ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog) GoString() string {
	return s.String()
}

func (s *ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog) SetAffectRows(v int64) *ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog {
	s.AffectRows = &v
	return s
}

func (s *ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog) SetDbId(v int64) *ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog {
	s.DbId = &v
	return s
}

func (s *ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog) SetElapsedTime(v int64) *ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog {
	s.ElapsedTime = &v
	return s
}

func (s *ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog) SetExecState(v string) *ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog {
	s.ExecState = &v
	return s
}

func (s *ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog) SetInstanceId(v int64) *ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog {
	s.InstanceId = &v
	return s
}

func (s *ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog) SetInstanceName(v string) *ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog {
	s.InstanceName = &v
	return s
}

func (s *ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog) SetLogic(v bool) *ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog {
	s.Logic = &v
	return s
}

func (s *ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog) SetOpTime(v string) *ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog {
	s.OpTime = &v
	return s
}

func (s *ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog) SetRemark(v string) *ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog {
	s.Remark = &v
	return s
}

func (s *ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog) SetSQL(v string) *ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog {
	s.SQL = &v
	return s
}

func (s *ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog) SetSQLType(v string) *ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog {
	s.SQLType = &v
	return s
}

func (s *ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog) SetSchemaName(v string) *ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog {
	s.SchemaName = &v
	return s
}

func (s *ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog) SetUserId(v int64) *ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog {
	s.UserId = &v
	return s
}

func (s *ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog) SetUserName(v string) *ListSQLExecAuditLogResponseBodySQLExecAuditLogListSQLExecAuditLog {
	s.UserName = &v
	return s
}

type ListSQLExecAuditLogResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListSQLExecAuditLogResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListSQLExecAuditLogResponse) String() string {
	return tea.Prettify(s)
}

func (s ListSQLExecAuditLogResponse) GoString() string {
	return s.String()
}

func (s *ListSQLExecAuditLogResponse) SetHeaders(v map[string]*string) *ListSQLExecAuditLogResponse {
	s.Headers = v
	return s
}

func (s *ListSQLExecAuditLogResponse) SetStatusCode(v int32) *ListSQLExecAuditLogResponse {
	s.StatusCode = &v
	return s
}

func (s *ListSQLExecAuditLogResponse) SetBody(v *ListSQLExecAuditLogResponseBody) *ListSQLExecAuditLogResponse {
	s.Body = v
	return s
}

type ListSQLReviewOriginSQLRequest struct {
	// The parameters that are used to filter SQL statements involved in the ticket.
	OrderActionDetail *ListSQLReviewOriginSQLRequestOrderActionDetail `json:"OrderActionDetail,omitempty" xml:"OrderActionDetail,omitempty" type:"Struct"`
	// The ID of the ticket for the SQL review. You can call the [CreateSQLReviewOrder](~~257777~~) operation to query the ID of the ticket.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~465818~~) operation to query the ID of the tenant.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListSQLReviewOriginSQLRequest) String() string {
	return tea.Prettify(s)
}

func (s ListSQLReviewOriginSQLRequest) GoString() string {
	return s.String()
}

func (s *ListSQLReviewOriginSQLRequest) SetOrderActionDetail(v *ListSQLReviewOriginSQLRequestOrderActionDetail) *ListSQLReviewOriginSQLRequest {
	s.OrderActionDetail = v
	return s
}

func (s *ListSQLReviewOriginSQLRequest) SetOrderId(v int64) *ListSQLReviewOriginSQLRequest {
	s.OrderId = &v
	return s
}

func (s *ListSQLReviewOriginSQLRequest) SetTid(v int64) *ListSQLReviewOriginSQLRequest {
	s.Tid = &v
	return s
}

type ListSQLReviewOriginSQLRequestOrderActionDetail struct {
	// The review status of the SQL statement. Valid values:
	//
	// *   **new**: The SQL statement is pending for analysis.
	// *   **unknown**: The SQL statement failed to be parsed.
	// *   **check_not_pass**: The SQL statement failed the review.
	// *   **check_pass**: The SQL statement passed the review.
	// *   **force_pass**: The SQL statement passed the review by manual effort.
	// *   **force_not_pass**: The SQL statement failed the review by manual effort.
	CheckStatusResult *string `json:"CheckStatusResult,omitempty" xml:"CheckStatusResult,omitempty"`
	// The ID of the file.
	FileId *int64 `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The paging settings.
	Page *ListSQLReviewOriginSQLRequestOrderActionDetailPage `json:"Page,omitempty" xml:"Page,omitempty" type:"Struct"`
	// The optimization suggestion for the SQL statement. Valid values:
	//
	// *   **MUST_IMPROVE**: The SQL statement must be improved.
	// *   **POTENTIAL_ISSUE**: The SQL statement contains potential issues.
	// *   **SUGGEST_IMPROVE**: We recommend that you improve the SQL statement.
	// *   **USE_DMS_TOOLKIT**: We recommend that you change schemas without locking tables.
	// *   **USE_DMS_DML_UNLOCK**: We recommend that you change data without locking tables.
	// *   **TABLE_INDEX_SUGGEST**: We recommend that you use SQL statements that use indexes.
	SQLReviewResult *string `json:"SQLReviewResult,omitempty" xml:"SQLReviewResult,omitempty"`
}

func (s ListSQLReviewOriginSQLRequestOrderActionDetail) String() string {
	return tea.Prettify(s)
}

func (s ListSQLReviewOriginSQLRequestOrderActionDetail) GoString() string {
	return s.String()
}

func (s *ListSQLReviewOriginSQLRequestOrderActionDetail) SetCheckStatusResult(v string) *ListSQLReviewOriginSQLRequestOrderActionDetail {
	s.CheckStatusResult = &v
	return s
}

func (s *ListSQLReviewOriginSQLRequestOrderActionDetail) SetFileId(v int64) *ListSQLReviewOriginSQLRequestOrderActionDetail {
	s.FileId = &v
	return s
}

func (s *ListSQLReviewOriginSQLRequestOrderActionDetail) SetPage(v *ListSQLReviewOriginSQLRequestOrderActionDetailPage) *ListSQLReviewOriginSQLRequestOrderActionDetail {
	s.Page = v
	return s
}

func (s *ListSQLReviewOriginSQLRequestOrderActionDetail) SetSQLReviewResult(v string) *ListSQLReviewOriginSQLRequestOrderActionDetail {
	s.SQLReviewResult = &v
	return s
}

type ListSQLReviewOriginSQLRequestOrderActionDetailPage struct {
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s ListSQLReviewOriginSQLRequestOrderActionDetailPage) String() string {
	return tea.Prettify(s)
}

func (s ListSQLReviewOriginSQLRequestOrderActionDetailPage) GoString() string {
	return s.String()
}

func (s *ListSQLReviewOriginSQLRequestOrderActionDetailPage) SetPageNumber(v int32) *ListSQLReviewOriginSQLRequestOrderActionDetailPage {
	s.PageNumber = &v
	return s
}

func (s *ListSQLReviewOriginSQLRequestOrderActionDetailPage) SetPageSize(v int32) *ListSQLReviewOriginSQLRequestOrderActionDetailPage {
	s.PageSize = &v
	return s
}

type ListSQLReviewOriginSQLShrinkRequest struct {
	// The parameters that are used to filter SQL statements involved in the ticket.
	OrderActionDetailShrink *string `json:"OrderActionDetail,omitempty" xml:"OrderActionDetail,omitempty"`
	// The ID of the ticket for the SQL review. You can call the [CreateSQLReviewOrder](~~257777~~) operation to query the ID of the ticket.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~465818~~) operation to query the ID of the tenant.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListSQLReviewOriginSQLShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ListSQLReviewOriginSQLShrinkRequest) GoString() string {
	return s.String()
}

func (s *ListSQLReviewOriginSQLShrinkRequest) SetOrderActionDetailShrink(v string) *ListSQLReviewOriginSQLShrinkRequest {
	s.OrderActionDetailShrink = &v
	return s
}

func (s *ListSQLReviewOriginSQLShrinkRequest) SetOrderId(v int64) *ListSQLReviewOriginSQLShrinkRequest {
	s.OrderId = &v
	return s
}

func (s *ListSQLReviewOriginSQLShrinkRequest) SetTid(v int64) *ListSQLReviewOriginSQLShrinkRequest {
	s.Tid = &v
	return s
}

type ListSQLReviewOriginSQLResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The information about the parsed SQL statements.
	OriginSQLList []*ListSQLReviewOriginSQLResponseBodyOriginSQLList `json:"OriginSQLList,omitempty" xml:"OriginSQLList,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of the SQL statements.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListSQLReviewOriginSQLResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListSQLReviewOriginSQLResponseBody) GoString() string {
	return s.String()
}

func (s *ListSQLReviewOriginSQLResponseBody) SetErrorCode(v string) *ListSQLReviewOriginSQLResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListSQLReviewOriginSQLResponseBody) SetErrorMessage(v string) *ListSQLReviewOriginSQLResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListSQLReviewOriginSQLResponseBody) SetOriginSQLList(v []*ListSQLReviewOriginSQLResponseBodyOriginSQLList) *ListSQLReviewOriginSQLResponseBody {
	s.OriginSQLList = v
	return s
}

func (s *ListSQLReviewOriginSQLResponseBody) SetRequestId(v string) *ListSQLReviewOriginSQLResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListSQLReviewOriginSQLResponseBody) SetSuccess(v bool) *ListSQLReviewOriginSQLResponseBody {
	s.Success = &v
	return s
}

func (s *ListSQLReviewOriginSQLResponseBody) SetTotalCount(v int32) *ListSQLReviewOriginSQLResponseBody {
	s.TotalCount = &v
	return s
}

type ListSQLReviewOriginSQLResponseBodyOriginSQLList struct {
	// The review status of the SQL statement. Valid values:
	//
	// *   **new**: The SQL statement is pending for analysis.
	// *   **unknown**: The SQL statement failed to be parsed.
	// *   **check_not_pass**: The SQL statement failed the review.
	// *   **check_pass**: The SQL statement passed the review.
	// *   **force_pass**: The SQL statement passed the review by manual effort.
	// *   **force_not_pass**: The SQL statement failed the review by manual effort.
	CheckStatus *string `json:"CheckStatus,omitempty" xml:"CheckStatus,omitempty"`
	// The time when the SQL statement is reviewed.
	CheckedTime *string `json:"CheckedTime,omitempty" xml:"CheckedTime,omitempty"`
	// The ID of the file.
	FileId *int64 `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The name of the file.
	FileName *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	// The statistics of optimization suggestions for SQL statements. The value is a JSON string. The following optimization suggestions are involved:
	//
	// *   **MUST_IMPROVE**: The SQL statement must be improved.
	// *   **POTENTIAL_ISSUE**: The SQL statement contains potential issues.
	// *   **SUGGEST_IMPROVE**: We recommend that you improve the SQL statement.
	// *   **USEDMSTOOLKIT**: We recommend that you change schemas without locking tables.
	// *   **USEDMSDML_UNLOCK**: We recommend that you change data without locking tables.
	// *   **TABLEINDEXSUGGEST**: We recommend that you use SQL statements that use indexes.
	ReviewSummary *string `json:"ReviewSummary,omitempty" xml:"ReviewSummary,omitempty"`
	// The SQL statement.
	SQLContent *string `json:"SQLContent,omitempty" xml:"SQLContent,omitempty"`
	// The ID of the SQL statement.
	SQLId *int64 `json:"SQLId,omitempty" xml:"SQLId,omitempty"`
	// SQLName.
	SQLName *string `json:"SQLName,omitempty" xml:"SQLName,omitempty"`
	// The key that is used to query the details of optimization suggestions. You can call the [GetSQLReviewOptimizeDetail](https://icms.alibaba-inc.com/content/dms/doc?l=1\&m=61777\&n=2712723\&spm) operation to query the details of optimization suggestions based on the key.
	SQLReviewQueryKey *string `json:"SQLReviewQueryKey,omitempty" xml:"SQLReviewQueryKey,omitempty"`
	// The MD5 hash value of the SQL statement.
	SqlHash *string `json:"SqlHash,omitempty" xml:"SqlHash,omitempty"`
	// The description of the review status.
	StatusDesc *string `json:"StatusDesc,omitempty" xml:"StatusDesc,omitempty"`
}

func (s ListSQLReviewOriginSQLResponseBodyOriginSQLList) String() string {
	return tea.Prettify(s)
}

func (s ListSQLReviewOriginSQLResponseBodyOriginSQLList) GoString() string {
	return s.String()
}

func (s *ListSQLReviewOriginSQLResponseBodyOriginSQLList) SetCheckStatus(v string) *ListSQLReviewOriginSQLResponseBodyOriginSQLList {
	s.CheckStatus = &v
	return s
}

func (s *ListSQLReviewOriginSQLResponseBodyOriginSQLList) SetCheckedTime(v string) *ListSQLReviewOriginSQLResponseBodyOriginSQLList {
	s.CheckedTime = &v
	return s
}

func (s *ListSQLReviewOriginSQLResponseBodyOriginSQLList) SetFileId(v int64) *ListSQLReviewOriginSQLResponseBodyOriginSQLList {
	s.FileId = &v
	return s
}

func (s *ListSQLReviewOriginSQLResponseBodyOriginSQLList) SetFileName(v string) *ListSQLReviewOriginSQLResponseBodyOriginSQLList {
	s.FileName = &v
	return s
}

func (s *ListSQLReviewOriginSQLResponseBodyOriginSQLList) SetReviewSummary(v string) *ListSQLReviewOriginSQLResponseBodyOriginSQLList {
	s.ReviewSummary = &v
	return s
}

func (s *ListSQLReviewOriginSQLResponseBodyOriginSQLList) SetSQLContent(v string) *ListSQLReviewOriginSQLResponseBodyOriginSQLList {
	s.SQLContent = &v
	return s
}

func (s *ListSQLReviewOriginSQLResponseBodyOriginSQLList) SetSQLId(v int64) *ListSQLReviewOriginSQLResponseBodyOriginSQLList {
	s.SQLId = &v
	return s
}

func (s *ListSQLReviewOriginSQLResponseBodyOriginSQLList) SetSQLName(v string) *ListSQLReviewOriginSQLResponseBodyOriginSQLList {
	s.SQLName = &v
	return s
}

func (s *ListSQLReviewOriginSQLResponseBodyOriginSQLList) SetSQLReviewQueryKey(v string) *ListSQLReviewOriginSQLResponseBodyOriginSQLList {
	s.SQLReviewQueryKey = &v
	return s
}

func (s *ListSQLReviewOriginSQLResponseBodyOriginSQLList) SetSqlHash(v string) *ListSQLReviewOriginSQLResponseBodyOriginSQLList {
	s.SqlHash = &v
	return s
}

func (s *ListSQLReviewOriginSQLResponseBodyOriginSQLList) SetStatusDesc(v string) *ListSQLReviewOriginSQLResponseBodyOriginSQLList {
	s.StatusDesc = &v
	return s
}

type ListSQLReviewOriginSQLResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListSQLReviewOriginSQLResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListSQLReviewOriginSQLResponse) String() string {
	return tea.Prettify(s)
}

func (s ListSQLReviewOriginSQLResponse) GoString() string {
	return s.String()
}

func (s *ListSQLReviewOriginSQLResponse) SetHeaders(v map[string]*string) *ListSQLReviewOriginSQLResponse {
	s.Headers = v
	return s
}

func (s *ListSQLReviewOriginSQLResponse) SetStatusCode(v int32) *ListSQLReviewOriginSQLResponse {
	s.StatusCode = &v
	return s
}

func (s *ListSQLReviewOriginSQLResponse) SetBody(v *ListSQLReviewOriginSQLResponseBody) *ListSQLReviewOriginSQLResponse {
	s.Body = v
	return s
}

type ListScenariosRequest struct {
	// The ID of the tenant.
	//
	// > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListScenariosRequest) String() string {
	return tea.Prettify(s)
}

func (s ListScenariosRequest) GoString() string {
	return s.String()
}

func (s *ListScenariosRequest) SetTid(v int64) *ListScenariosRequest {
	s.Tid = &v
	return s
}

type ListScenariosResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The details of the returned business scenarios.
	ScenarioList []*ListScenariosResponseBodyScenarioList `json:"ScenarioList,omitempty" xml:"ScenarioList,omitempty" type:"Repeated"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListScenariosResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListScenariosResponseBody) GoString() string {
	return s.String()
}

func (s *ListScenariosResponseBody) SetErrorCode(v string) *ListScenariosResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListScenariosResponseBody) SetErrorMessage(v string) *ListScenariosResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListScenariosResponseBody) SetRequestId(v string) *ListScenariosResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListScenariosResponseBody) SetScenarioList(v []*ListScenariosResponseBodyScenarioList) *ListScenariosResponseBody {
	s.ScenarioList = v
	return s
}

func (s *ListScenariosResponseBody) SetSuccess(v bool) *ListScenariosResponseBody {
	s.Success = &v
	return s
}

type ListScenariosResponseBodyScenarioList struct {
	// The ID of the user who created the business scenario.
	CreatorId *string `json:"CreatorId,omitempty" xml:"CreatorId,omitempty"`
	// The description of the business scenario.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the business scenario.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the business scenario.
	ScenarioName *string `json:"ScenarioName,omitempty" xml:"ScenarioName,omitempty"`
}

func (s ListScenariosResponseBodyScenarioList) String() string {
	return tea.Prettify(s)
}

func (s ListScenariosResponseBodyScenarioList) GoString() string {
	return s.String()
}

func (s *ListScenariosResponseBodyScenarioList) SetCreatorId(v string) *ListScenariosResponseBodyScenarioList {
	s.CreatorId = &v
	return s
}

func (s *ListScenariosResponseBodyScenarioList) SetDescription(v string) *ListScenariosResponseBodyScenarioList {
	s.Description = &v
	return s
}

func (s *ListScenariosResponseBodyScenarioList) SetId(v int64) *ListScenariosResponseBodyScenarioList {
	s.Id = &v
	return s
}

func (s *ListScenariosResponseBodyScenarioList) SetScenarioName(v string) *ListScenariosResponseBodyScenarioList {
	s.ScenarioName = &v
	return s
}

type ListScenariosResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListScenariosResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListScenariosResponse) String() string {
	return tea.Prettify(s)
}

func (s ListScenariosResponse) GoString() string {
	return s.String()
}

func (s *ListScenariosResponse) SetHeaders(v map[string]*string) *ListScenariosResponse {
	s.Headers = v
	return s
}

func (s *ListScenariosResponse) SetStatusCode(v int32) *ListScenariosResponse {
	s.StatusCode = &v
	return s
}

func (s *ListScenariosResponse) SetBody(v *ListScenariosResponseBody) *ListScenariosResponse {
	s.Body = v
	return s
}

type ListSensitiveColumnsRequest struct {
	// The name of the field. You can call the [ListColumns](~~141870~~) operation to query the name of the field.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The ID of the database. You can call the [SearchDatabase](~~141876~~) operation to query the ID of the database.
	//
	// >  You can also call the [ListDatabases](~~141873~~) operation to query the ID of the physical database and the [ListLogicDatabases](~~141874~~) operation to query the ID of a logical database.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// Specifies whether the database is a logical database. Valid values:
	//
	// *   true: The database is a logical database.
	// *   false: The database is a physical database.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The name of the database. You can call the [SearchDatabase](~~141876~~) operation to query the name of the database.
	//
	// >  You can also call the [ListDatabases](~~141873~~) operation to query the name of a physical database and the [ListLogicDatabases](~~141874~~) operation to query the name of a logical database.
	SchemaName *string `json:"SchemaName,omitempty" xml:"SchemaName,omitempty"`
	// The sensitivity level of the field. Valid values:
	//
	// *   SENSITIVE: medium sensitivity level
	// *   CONFIDENTIAL: high sensitivity level
	SecurityLevel *string `json:"SecurityLevel,omitempty" xml:"SecurityLevel,omitempty"`
	// The name of the table. You can call the [ListTables](~~141878~~) operation to query the ID of the table.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	// The ID of the tenant.
	//
	// >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListSensitiveColumnsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListSensitiveColumnsRequest) GoString() string {
	return s.String()
}

func (s *ListSensitiveColumnsRequest) SetColumnName(v string) *ListSensitiveColumnsRequest {
	s.ColumnName = &v
	return s
}

func (s *ListSensitiveColumnsRequest) SetDbId(v int64) *ListSensitiveColumnsRequest {
	s.DbId = &v
	return s
}

func (s *ListSensitiveColumnsRequest) SetLogic(v bool) *ListSensitiveColumnsRequest {
	s.Logic = &v
	return s
}

func (s *ListSensitiveColumnsRequest) SetPageNumber(v int32) *ListSensitiveColumnsRequest {
	s.PageNumber = &v
	return s
}

func (s *ListSensitiveColumnsRequest) SetPageSize(v int32) *ListSensitiveColumnsRequest {
	s.PageSize = &v
	return s
}

func (s *ListSensitiveColumnsRequest) SetSchemaName(v string) *ListSensitiveColumnsRequest {
	s.SchemaName = &v
	return s
}

func (s *ListSensitiveColumnsRequest) SetSecurityLevel(v string) *ListSensitiveColumnsRequest {
	s.SecurityLevel = &v
	return s
}

func (s *ListSensitiveColumnsRequest) SetTableName(v string) *ListSensitiveColumnsRequest {
	s.TableName = &v
	return s
}

func (s *ListSensitiveColumnsRequest) SetTid(v int64) *ListSensitiveColumnsRequest {
	s.Tid = &v
	return s
}

type ListSensitiveColumnsResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The sensitive fields.
	SensitiveColumnList *ListSensitiveColumnsResponseBodySensitiveColumnList `json:"SensitiveColumnList,omitempty" xml:"SensitiveColumnList,omitempty" type:"Struct"`
	// Indicates whether the request is successful. Valid values:
	//
	// - true: The request is successful.
	// - false: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of returned entries.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListSensitiveColumnsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListSensitiveColumnsResponseBody) GoString() string {
	return s.String()
}

func (s *ListSensitiveColumnsResponseBody) SetErrorCode(v string) *ListSensitiveColumnsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListSensitiveColumnsResponseBody) SetErrorMessage(v string) *ListSensitiveColumnsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListSensitiveColumnsResponseBody) SetRequestId(v string) *ListSensitiveColumnsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListSensitiveColumnsResponseBody) SetSensitiveColumnList(v *ListSensitiveColumnsResponseBodySensitiveColumnList) *ListSensitiveColumnsResponseBody {
	s.SensitiveColumnList = v
	return s
}

func (s *ListSensitiveColumnsResponseBody) SetSuccess(v bool) *ListSensitiveColumnsResponseBody {
	s.Success = &v
	return s
}

func (s *ListSensitiveColumnsResponseBody) SetTotalCount(v int64) *ListSensitiveColumnsResponseBody {
	s.TotalCount = &v
	return s
}

type ListSensitiveColumnsResponseBodySensitiveColumnList struct {
	SensitiveColumn []*ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn `json:"SensitiveColumn,omitempty" xml:"SensitiveColumn,omitempty" type:"Repeated"`
}

func (s ListSensitiveColumnsResponseBodySensitiveColumnList) String() string {
	return tea.Prettify(s)
}

func (s ListSensitiveColumnsResponseBodySensitiveColumnList) GoString() string {
	return s.String()
}

func (s *ListSensitiveColumnsResponseBodySensitiveColumnList) SetSensitiveColumn(v []*ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn) *ListSensitiveColumnsResponseBodySensitiveColumnList {
	s.SensitiveColumn = v
	return s
}

type ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn struct {
	// The number of sensitive fields.
	ColumnCount *int64 `json:"ColumnCount,omitempty" xml:"ColumnCount,omitempty"`
	// The name of the field.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The type of the de-identification algorithm. Valid values:
	//
	// *   DEFAULT: All characters are masked. This is the default value.
	// *   FIX_POS: The characters at specific positions are masked.
	// *   FIX_CHAR: Specific characters are masked.
	FunctionType *string `json:"FunctionType,omitempty" xml:"FunctionType,omitempty"`
	// The name of the database.
	SchemaName *string `json:"SchemaName,omitempty" xml:"SchemaName,omitempty"`
	// The sensitivity level of the field. Valid values:
	//
	// *   SENSITIVE
	// *   CONFIDENTIAL
	SecurityLevel *string `json:"SecurityLevel,omitempty" xml:"SecurityLevel,omitempty"`
	// The name of the table.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn) String() string {
	return tea.Prettify(s)
}

func (s ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn) GoString() string {
	return s.String()
}

func (s *ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn) SetColumnCount(v int64) *ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn {
	s.ColumnCount = &v
	return s
}

func (s *ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn) SetColumnName(v string) *ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn {
	s.ColumnName = &v
	return s
}

func (s *ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn) SetFunctionType(v string) *ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn {
	s.FunctionType = &v
	return s
}

func (s *ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn) SetSchemaName(v string) *ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn {
	s.SchemaName = &v
	return s
}

func (s *ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn) SetSecurityLevel(v string) *ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn {
	s.SecurityLevel = &v
	return s
}

func (s *ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn) SetTableName(v string) *ListSensitiveColumnsResponseBodySensitiveColumnListSensitiveColumn {
	s.TableName = &v
	return s
}

type ListSensitiveColumnsResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListSensitiveColumnsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListSensitiveColumnsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListSensitiveColumnsResponse) GoString() string {
	return s.String()
}

func (s *ListSensitiveColumnsResponse) SetHeaders(v map[string]*string) *ListSensitiveColumnsResponse {
	s.Headers = v
	return s
}

func (s *ListSensitiveColumnsResponse) SetStatusCode(v int32) *ListSensitiveColumnsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListSensitiveColumnsResponse) SetBody(v *ListSensitiveColumnsResponseBody) *ListSensitiveColumnsResponse {
	s.Body = v
	return s
}

type ListSensitiveColumnsDetailRequest struct {
	// The name of the field. You can call the [ListSensitiveColumns](~~188103~~) operation to obtain the name of the field.
	//
	// >  You can also call the [ListColumns](~~141870~~) operation to obtain the name of the field.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The ID of the database. The database can be a physical database or a logical database.
	//
	// *   To obtain the ID of a physical database, call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation.
	// *   To obtain the ID of a logical database, call the [ListLogicDatabases](~~141874~~) or [SearchDatabase](~~141876~~) operation.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// Specifies whether the database is a logical database. Valid values:
	//
	// *   **true**: The database is a logical database.
	// *   **false**: The database is a physical database.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The name of the database. You can call the [ListSensitiveColumns](~~188103~~) operation to obtain the name of the database.
	//
	// > * You can also call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation to obtain the name of a physical database.
	// > * You can also call the [ListLogicDatabases](~~141874~~) or [SearchDatabase](~~141876~~) operation to obtain the name of a logical database.
	SchemaName *string `json:"SchemaName,omitempty" xml:"SchemaName,omitempty"`
	// The name of the table. You can call the [ListSensitiveColumns](~~188103~~) operation to obtain the name of the table.
	//
	// >  You can also call the [ListTables](~~141878~~) operation to obtain the name of the table.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListSensitiveColumnsDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s ListSensitiveColumnsDetailRequest) GoString() string {
	return s.String()
}

func (s *ListSensitiveColumnsDetailRequest) SetColumnName(v string) *ListSensitiveColumnsDetailRequest {
	s.ColumnName = &v
	return s
}

func (s *ListSensitiveColumnsDetailRequest) SetDbId(v int64) *ListSensitiveColumnsDetailRequest {
	s.DbId = &v
	return s
}

func (s *ListSensitiveColumnsDetailRequest) SetLogic(v bool) *ListSensitiveColumnsDetailRequest {
	s.Logic = &v
	return s
}

func (s *ListSensitiveColumnsDetailRequest) SetSchemaName(v string) *ListSensitiveColumnsDetailRequest {
	s.SchemaName = &v
	return s
}

func (s *ListSensitiveColumnsDetailRequest) SetTableName(v string) *ListSensitiveColumnsDetailRequest {
	s.TableName = &v
	return s
}

func (s *ListSensitiveColumnsDetailRequest) SetTid(v int64) *ListSensitiveColumnsDetailRequest {
	s.Tid = &v
	return s
}

type ListSensitiveColumnsDetailResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The details of the sensitive field.
	SensitiveColumnsDetailList *ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailList `json:"SensitiveColumnsDetailList,omitempty" xml:"SensitiveColumnsDetailList,omitempty" type:"Struct"`
	// Indicates whether the request was successful. Valid values:
	//
	// - **true**: The request was successful.
	// - **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListSensitiveColumnsDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListSensitiveColumnsDetailResponseBody) GoString() string {
	return s.String()
}

func (s *ListSensitiveColumnsDetailResponseBody) SetErrorCode(v string) *ListSensitiveColumnsDetailResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListSensitiveColumnsDetailResponseBody) SetErrorMessage(v string) *ListSensitiveColumnsDetailResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListSensitiveColumnsDetailResponseBody) SetRequestId(v string) *ListSensitiveColumnsDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListSensitiveColumnsDetailResponseBody) SetSensitiveColumnsDetailList(v *ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailList) *ListSensitiveColumnsDetailResponseBody {
	s.SensitiveColumnsDetailList = v
	return s
}

func (s *ListSensitiveColumnsDetailResponseBody) SetSuccess(v bool) *ListSensitiveColumnsDetailResponseBody {
	s.Success = &v
	return s
}

type ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailList struct {
	SensitiveColumnsDetail []*ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail `json:"SensitiveColumnsDetail,omitempty" xml:"SensitiveColumnsDetail,omitempty" type:"Repeated"`
}

func (s ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailList) String() string {
	return tea.Prettify(s)
}

func (s ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailList) GoString() string {
	return s.String()
}

func (s *ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailList) SetSensitiveColumnsDetail(v []*ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail) *ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailList {
	s.SensitiveColumnsDetail = v
	return s
}

type ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail struct {
	// The description of the field.
	ColumnDescription *string `json:"ColumnDescription,omitempty" xml:"ColumnDescription,omitempty"`
	// The name of the field.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The data type of the field.
	ColumnType *string `json:"ColumnType,omitempty" xml:"ColumnType,omitempty"`
	// The ID of the database.
	DbId *int64 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The type of the database.
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The type of the environment to which the database belongs.
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// Indicates whether the database is a logical database. Valid values:
	//
	// *   **true**: The database is a logical database.
	// *   **false**: The database is not a logical database.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The name of the database.
	SchemaName *string `json:"SchemaName,omitempty" xml:"SchemaName,omitempty"`
	// The name that is used to search for the database.
	SearchName *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
	// The name of the table.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail) String() string {
	return tea.Prettify(s)
}

func (s ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail) GoString() string {
	return s.String()
}

func (s *ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail) SetColumnDescription(v string) *ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail {
	s.ColumnDescription = &v
	return s
}

func (s *ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail) SetColumnName(v string) *ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail {
	s.ColumnName = &v
	return s
}

func (s *ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail) SetColumnType(v string) *ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail {
	s.ColumnType = &v
	return s
}

func (s *ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail) SetDbId(v int64) *ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail {
	s.DbId = &v
	return s
}

func (s *ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail) SetDbType(v string) *ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail {
	s.DbType = &v
	return s
}

func (s *ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail) SetEnvType(v string) *ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail {
	s.EnvType = &v
	return s
}

func (s *ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail) SetLogic(v bool) *ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail {
	s.Logic = &v
	return s
}

func (s *ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail) SetSchemaName(v string) *ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail {
	s.SchemaName = &v
	return s
}

func (s *ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail) SetSearchName(v string) *ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail {
	s.SearchName = &v
	return s
}

func (s *ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail) SetTableName(v string) *ListSensitiveColumnsDetailResponseBodySensitiveColumnsDetailListSensitiveColumnsDetail {
	s.TableName = &v
	return s
}

type ListSensitiveColumnsDetailResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListSensitiveColumnsDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListSensitiveColumnsDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s ListSensitiveColumnsDetailResponse) GoString() string {
	return s.String()
}

func (s *ListSensitiveColumnsDetailResponse) SetHeaders(v map[string]*string) *ListSensitiveColumnsDetailResponse {
	s.Headers = v
	return s
}

func (s *ListSensitiveColumnsDetailResponse) SetStatusCode(v int32) *ListSensitiveColumnsDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *ListSensitiveColumnsDetailResponse) SetBody(v *ListSensitiveColumnsDetailResponseBody) *ListSensitiveColumnsDetailResponse {
	s.Body = v
	return s
}

type ListSensitiveDataAuditLogRequest struct {
	// The name of the column that contains sensitive data.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The name of the database that stores the sensitive data.
	DbName *string `json:"DbName,omitempty" xml:"DbName,omitempty"`
	// The end of the time range for which you want to query the audit logs for sensitive information. Specify the time in the yyyy-MM-DD HH:mm:ss format.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The function module whose audit logs you want to query for sensitive data. If you do not specify this parameter, all audit logs are queried. Valid values:
	//
	// *   **SQL_CONSOLE**: data query
	// *   **SQL_CONSOLE_EXPORT**: query result export
	// *   **DATA_CHANGE**: data change
	// *   **DATA_EXPORT**: data export
	ModuleName *string `json:"ModuleName,omitempty" xml:"ModuleName,omitempty"`
	// The username of the requester.
	OpUserName *string `json:"OpUserName,omitempty" xml:"OpUserName,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Example: 100
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The beginning of the time range for which you want to query the audit logs for sensitive information. Specify the time in the yyyy-MM-DD HH:mm:ss format.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The name of the table that stores the sensitive data.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	// The ID of the tenant.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListSensitiveDataAuditLogRequest) String() string {
	return tea.Prettify(s)
}

func (s ListSensitiveDataAuditLogRequest) GoString() string {
	return s.String()
}

func (s *ListSensitiveDataAuditLogRequest) SetColumnName(v string) *ListSensitiveDataAuditLogRequest {
	s.ColumnName = &v
	return s
}

func (s *ListSensitiveDataAuditLogRequest) SetDbName(v string) *ListSensitiveDataAuditLogRequest {
	s.DbName = &v
	return s
}

func (s *ListSensitiveDataAuditLogRequest) SetEndTime(v string) *ListSensitiveDataAuditLogRequest {
	s.EndTime = &v
	return s
}

func (s *ListSensitiveDataAuditLogRequest) SetModuleName(v string) *ListSensitiveDataAuditLogRequest {
	s.ModuleName = &v
	return s
}

func (s *ListSensitiveDataAuditLogRequest) SetOpUserName(v string) *ListSensitiveDataAuditLogRequest {
	s.OpUserName = &v
	return s
}

func (s *ListSensitiveDataAuditLogRequest) SetPageNumber(v int32) *ListSensitiveDataAuditLogRequest {
	s.PageNumber = &v
	return s
}

func (s *ListSensitiveDataAuditLogRequest) SetPageSize(v int32) *ListSensitiveDataAuditLogRequest {
	s.PageSize = &v
	return s
}

func (s *ListSensitiveDataAuditLogRequest) SetStartTime(v string) *ListSensitiveDataAuditLogRequest {
	s.StartTime = &v
	return s
}

func (s *ListSensitiveDataAuditLogRequest) SetTableName(v string) *ListSensitiveDataAuditLogRequest {
	s.TableName = &v
	return s
}

func (s *ListSensitiveDataAuditLogRequest) SetTid(v int64) *ListSensitiveDataAuditLogRequest {
	s.Tid = &v
	return s
}

type ListSensitiveDataAuditLogResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The audit logs for sensitive data.
	SensitiveDataAuditLogList []*ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList `json:"SensitiveDataAuditLogList,omitempty" xml:"SensitiveDataAuditLogList,omitempty" type:"Repeated"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of entries returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListSensitiveDataAuditLogResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListSensitiveDataAuditLogResponseBody) GoString() string {
	return s.String()
}

func (s *ListSensitiveDataAuditLogResponseBody) SetErrorCode(v string) *ListSensitiveDataAuditLogResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListSensitiveDataAuditLogResponseBody) SetErrorMessage(v string) *ListSensitiveDataAuditLogResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListSensitiveDataAuditLogResponseBody) SetRequestId(v string) *ListSensitiveDataAuditLogResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListSensitiveDataAuditLogResponseBody) SetSensitiveDataAuditLogList(v []*ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList) *ListSensitiveDataAuditLogResponseBody {
	s.SensitiveDataAuditLogList = v
	return s
}

func (s *ListSensitiveDataAuditLogResponseBody) SetSuccess(v bool) *ListSensitiveDataAuditLogResponseBody {
	s.Success = &v
	return s
}

func (s *ListSensitiveDataAuditLogResponseBody) SetTotalCount(v int64) *ListSensitiveDataAuditLogResponseBody {
	s.TotalCount = &v
	return s
}

type ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList struct {
	// The name of the database that stores the sensitive data.
	DbDisplayName *string `json:"DbDisplayName,omitempty" xml:"DbDisplayName,omitempty"`
	// The ID of the instance.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The name of the function module whose audit logs were queried.
	ModuleName *string `json:"ModuleName,omitempty" xml:"ModuleName,omitempty"`
	// The time when the operation was performed. The time is in the yyyy-MM-DD HH:mm:ss format.
	OpTime *string `json:"OpTime,omitempty" xml:"OpTime,omitempty"`
	// The logs for sensitive data.
	SensitiveDataLog []*ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog `json:"SensitiveDataLog,omitempty" xml:"SensitiveDataLog,omitempty" type:"Repeated"`
	// The details of the object on which the operation was performed. The value of this parameter is in one of the following formats:
	//
	// *   Object name - object ID
	// *   Object name (object ID)
	TargetName *string `json:"TargetName,omitempty" xml:"TargetName,omitempty"`
	// The user ID of the requester.
	UserId *int64 `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The username of the requester.
	UserName *string `json:"UserName,omitempty" xml:"UserName,omitempty"`
}

func (s ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList) String() string {
	return tea.Prettify(s)
}

func (s ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList) GoString() string {
	return s.String()
}

func (s *ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList) SetDbDisplayName(v string) *ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList {
	s.DbDisplayName = &v
	return s
}

func (s *ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList) SetInstanceId(v int64) *ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList {
	s.InstanceId = &v
	return s
}

func (s *ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList) SetModuleName(v string) *ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList {
	s.ModuleName = &v
	return s
}

func (s *ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList) SetOpTime(v string) *ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList {
	s.OpTime = &v
	return s
}

func (s *ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList) SetSensitiveDataLog(v []*ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog) *ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList {
	s.SensitiveDataLog = v
	return s
}

func (s *ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList) SetTargetName(v string) *ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList {
	s.TargetName = &v
	return s
}

func (s *ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList) SetUserId(v int64) *ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList {
	s.UserId = &v
	return s
}

func (s *ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList) SetUserName(v string) *ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogList {
	s.UserName = &v
	return s
}

type ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog struct {
	// The name of the column that contains sensitive data.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The permission that the user has on the column. Valid values:
	//
	// *   **No permission**
	// *   **Partial redaction**
	// *   **Plaintext**
	// *   **Change**
	// *   **Enable data masking**
	// *   **Disable data masking**
	ColumnPermissionType *string `json:"ColumnPermissionType,omitempty" xml:"ColumnPermissionType,omitempty"`
	// The algorithm used for data masking.
	DesensitizationRule *string `json:"DesensitizationRule,omitempty" xml:"DesensitizationRule,omitempty"`
	// The sensitivity level of the data. Valid values:
	//
	// *   **Low**
	// *   **Medium**
	// *   **High**
	SecurityLevel *string `json:"SecurityLevel,omitempty" xml:"SecurityLevel,omitempty"`
	// The name of the table that stores the sensitive data.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog) String() string {
	return tea.Prettify(s)
}

func (s ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog) GoString() string {
	return s.String()
}

func (s *ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog) SetColumnName(v string) *ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog {
	s.ColumnName = &v
	return s
}

func (s *ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog) SetColumnPermissionType(v string) *ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog {
	s.ColumnPermissionType = &v
	return s
}

func (s *ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog) SetDesensitizationRule(v string) *ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog {
	s.DesensitizationRule = &v
	return s
}

func (s *ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog) SetSecurityLevel(v string) *ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog {
	s.SecurityLevel = &v
	return s
}

func (s *ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog) SetTableName(v string) *ListSensitiveDataAuditLogResponseBodySensitiveDataAuditLogListSensitiveDataLog {
	s.TableName = &v
	return s
}

type ListSensitiveDataAuditLogResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListSensitiveDataAuditLogResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListSensitiveDataAuditLogResponse) String() string {
	return tea.Prettify(s)
}

func (s ListSensitiveDataAuditLogResponse) GoString() string {
	return s.String()
}

func (s *ListSensitiveDataAuditLogResponse) SetHeaders(v map[string]*string) *ListSensitiveDataAuditLogResponse {
	s.Headers = v
	return s
}

func (s *ListSensitiveDataAuditLogResponse) SetStatusCode(v int32) *ListSensitiveDataAuditLogResponse {
	s.StatusCode = &v
	return s
}

func (s *ListSensitiveDataAuditLogResponse) SetBody(v *ListSensitiveDataAuditLogResponseBody) *ListSensitiveDataAuditLogResponse {
	s.Body = v
	return s
}

type ListSensitivityLevelRequest struct {
	TemplateId   *int64  `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	TemplateType *string `json:"TemplateType,omitempty" xml:"TemplateType,omitempty"`
	Tid          *int64  `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListSensitivityLevelRequest) String() string {
	return tea.Prettify(s)
}

func (s ListSensitivityLevelRequest) GoString() string {
	return s.String()
}

func (s *ListSensitivityLevelRequest) SetTemplateId(v int64) *ListSensitivityLevelRequest {
	s.TemplateId = &v
	return s
}

func (s *ListSensitivityLevelRequest) SetTemplateType(v string) *ListSensitivityLevelRequest {
	s.TemplateType = &v
	return s
}

func (s *ListSensitivityLevelRequest) SetTid(v int64) *ListSensitivityLevelRequest {
	s.Tid = &v
	return s
}

type ListSensitivityLevelResponseBody struct {
	ErrorCode            *string                                                 `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage         *string                                                 `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId            *string                                                 `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	SensitivityLevelList []*ListSensitivityLevelResponseBodySensitivityLevelList `json:"SensitivityLevelList,omitempty" xml:"SensitivityLevelList,omitempty" type:"Repeated"`
	Success              *bool                                                   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListSensitivityLevelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListSensitivityLevelResponseBody) GoString() string {
	return s.String()
}

func (s *ListSensitivityLevelResponseBody) SetErrorCode(v string) *ListSensitivityLevelResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListSensitivityLevelResponseBody) SetErrorMessage(v string) *ListSensitivityLevelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListSensitivityLevelResponseBody) SetRequestId(v string) *ListSensitivityLevelResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListSensitivityLevelResponseBody) SetSensitivityLevelList(v []*ListSensitivityLevelResponseBodySensitivityLevelList) *ListSensitivityLevelResponseBody {
	s.SensitivityLevelList = v
	return s
}

func (s *ListSensitivityLevelResponseBody) SetSuccess(v bool) *ListSensitivityLevelResponseBody {
	s.Success = &v
	return s
}

type ListSensitivityLevelResponseBodySensitivityLevelList struct {
	IsPlain      *bool   `json:"IsPlain,omitempty" xml:"IsPlain,omitempty"`
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	TemplateId   *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	TemplateType *string `json:"TemplateType,omitempty" xml:"TemplateType,omitempty"`
}

func (s ListSensitivityLevelResponseBodySensitivityLevelList) String() string {
	return tea.Prettify(s)
}

func (s ListSensitivityLevelResponseBodySensitivityLevelList) GoString() string {
	return s.String()
}

func (s *ListSensitivityLevelResponseBodySensitivityLevelList) SetIsPlain(v bool) *ListSensitivityLevelResponseBodySensitivityLevelList {
	s.IsPlain = &v
	return s
}

func (s *ListSensitivityLevelResponseBodySensitivityLevelList) SetName(v string) *ListSensitivityLevelResponseBodySensitivityLevelList {
	s.Name = &v
	return s
}

func (s *ListSensitivityLevelResponseBodySensitivityLevelList) SetTemplateId(v string) *ListSensitivityLevelResponseBodySensitivityLevelList {
	s.TemplateId = &v
	return s
}

func (s *ListSensitivityLevelResponseBodySensitivityLevelList) SetTemplateType(v string) *ListSensitivityLevelResponseBodySensitivityLevelList {
	s.TemplateType = &v
	return s
}

type ListSensitivityLevelResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListSensitivityLevelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListSensitivityLevelResponse) String() string {
	return tea.Prettify(s)
}

func (s ListSensitivityLevelResponse) GoString() string {
	return s.String()
}

func (s *ListSensitivityLevelResponse) SetHeaders(v map[string]*string) *ListSensitivityLevelResponse {
	s.Headers = v
	return s
}

func (s *ListSensitivityLevelResponse) SetStatusCode(v int32) *ListSensitivityLevelResponse {
	s.StatusCode = &v
	return s
}

func (s *ListSensitivityLevelResponse) SetBody(v *ListSensitivityLevelResponseBody) *ListSensitivityLevelResponse {
	s.Body = v
	return s
}

type ListStandardGroupsRequest struct {
	// The ID of the tenant.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListStandardGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListStandardGroupsRequest) GoString() string {
	return s.String()
}

func (s *ListStandardGroupsRequest) SetTid(v int64) *ListStandardGroupsRequest {
	s.Tid = &v
	return s
}

type ListStandardGroupsResponseBody struct {
	// The error code returned if the request fails.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The security rule sets returned.
	StandardGroupList []*ListStandardGroupsResponseBodyStandardGroupList `json:"StandardGroupList,omitempty" xml:"StandardGroupList,omitempty" type:"Repeated"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListStandardGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListStandardGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *ListStandardGroupsResponseBody) SetErrorCode(v string) *ListStandardGroupsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListStandardGroupsResponseBody) SetErrorMessage(v string) *ListStandardGroupsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListStandardGroupsResponseBody) SetRequestId(v string) *ListStandardGroupsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListStandardGroupsResponseBody) SetStandardGroupList(v []*ListStandardGroupsResponseBodyStandardGroupList) *ListStandardGroupsResponseBody {
	s.StandardGroupList = v
	return s
}

func (s *ListStandardGroupsResponseBody) SetSuccess(v bool) *ListStandardGroupsResponseBody {
	s.Success = &v
	return s
}

type ListStandardGroupsResponseBodyStandardGroupList struct {
	// The type of the database engine. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The description of the security rule set.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the security rule set.
	GroupId *int64 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The control mode. Valid values:
	//
	// *   **NONE_CONTROL**: Flexible Management
	// *   **STABLE**: Stable Change
	// *   **COMMON**: Security Collaboration
	GroupMode *string `json:"GroupMode,omitempty" xml:"GroupMode,omitempty"`
	// The name of the security rule set.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the user who queries the security sets.
	LastMenderId *int64 `json:"LastMenderId,omitempty" xml:"LastMenderId,omitempty"`
}

func (s ListStandardGroupsResponseBodyStandardGroupList) String() string {
	return tea.Prettify(s)
}

func (s ListStandardGroupsResponseBodyStandardGroupList) GoString() string {
	return s.String()
}

func (s *ListStandardGroupsResponseBodyStandardGroupList) SetDbType(v string) *ListStandardGroupsResponseBodyStandardGroupList {
	s.DbType = &v
	return s
}

func (s *ListStandardGroupsResponseBodyStandardGroupList) SetDescription(v string) *ListStandardGroupsResponseBodyStandardGroupList {
	s.Description = &v
	return s
}

func (s *ListStandardGroupsResponseBodyStandardGroupList) SetGroupId(v int64) *ListStandardGroupsResponseBodyStandardGroupList {
	s.GroupId = &v
	return s
}

func (s *ListStandardGroupsResponseBodyStandardGroupList) SetGroupMode(v string) *ListStandardGroupsResponseBodyStandardGroupList {
	s.GroupMode = &v
	return s
}

func (s *ListStandardGroupsResponseBodyStandardGroupList) SetGroupName(v string) *ListStandardGroupsResponseBodyStandardGroupList {
	s.GroupName = &v
	return s
}

func (s *ListStandardGroupsResponseBodyStandardGroupList) SetLastMenderId(v int64) *ListStandardGroupsResponseBodyStandardGroupList {
	s.LastMenderId = &v
	return s
}

type ListStandardGroupsResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListStandardGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListStandardGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListStandardGroupsResponse) GoString() string {
	return s.String()
}

func (s *ListStandardGroupsResponse) SetHeaders(v map[string]*string) *ListStandardGroupsResponse {
	s.Headers = v
	return s
}

func (s *ListStandardGroupsResponse) SetStatusCode(v int32) *ListStandardGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListStandardGroupsResponse) SetBody(v *ListStandardGroupsResponseBody) *ListStandardGroupsResponse {
	s.Body = v
	return s
}

type ListTablesRequest struct {
	// The ID of the physical database. You can call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation to obtain the ID of the physical database.
	DatabaseId *string `json:"DatabaseId,omitempty" xml:"DatabaseId,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// Specifies whether to return the GUID of a table. Valid values:
	//
	// *   **true**: returns the GUID of a table.
	// *   **false**: does not return the GUID of a table.
	ReturnGuid *bool `json:"ReturnGuid,omitempty" xml:"ReturnGuid,omitempty"`
	// The name used to search for tables. Fuzzy search is supported.
	SearchName *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListTablesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTablesRequest) GoString() string {
	return s.String()
}

func (s *ListTablesRequest) SetDatabaseId(v string) *ListTablesRequest {
	s.DatabaseId = &v
	return s
}

func (s *ListTablesRequest) SetPageNumber(v int32) *ListTablesRequest {
	s.PageNumber = &v
	return s
}

func (s *ListTablesRequest) SetPageSize(v int32) *ListTablesRequest {
	s.PageSize = &v
	return s
}

func (s *ListTablesRequest) SetReturnGuid(v bool) *ListTablesRequest {
	s.ReturnGuid = &v
	return s
}

func (s *ListTablesRequest) SetSearchName(v string) *ListTablesRequest {
	s.SearchName = &v
	return s
}

func (s *ListTablesRequest) SetTid(v int64) *ListTablesRequest {
	s.Tid = &v
	return s
}

type ListTablesResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The details of the tables.
	TableList *ListTablesResponseBodyTableList `json:"TableList,omitempty" xml:"TableList,omitempty" type:"Struct"`
	// The total number of tables that meet the query conditions.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListTablesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTablesResponseBody) GoString() string {
	return s.String()
}

func (s *ListTablesResponseBody) SetErrorCode(v string) *ListTablesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListTablesResponseBody) SetErrorMessage(v string) *ListTablesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListTablesResponseBody) SetRequestId(v string) *ListTablesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTablesResponseBody) SetSuccess(v bool) *ListTablesResponseBody {
	s.Success = &v
	return s
}

func (s *ListTablesResponseBody) SetTableList(v *ListTablesResponseBodyTableList) *ListTablesResponseBody {
	s.TableList = v
	return s
}

func (s *ListTablesResponseBody) SetTotalCount(v int64) *ListTablesResponseBody {
	s.TotalCount = &v
	return s
}

type ListTablesResponseBodyTableList struct {
	Table []*ListTablesResponseBodyTableListTable `json:"Table,omitempty" xml:"Table,omitempty" type:"Repeated"`
}

func (s ListTablesResponseBodyTableList) String() string {
	return tea.Prettify(s)
}

func (s ListTablesResponseBodyTableList) GoString() string {
	return s.String()
}

func (s *ListTablesResponseBodyTableList) SetTable(v []*ListTablesResponseBodyTableListTable) *ListTablesResponseBodyTableList {
	s.Table = v
	return s
}

type ListTablesResponseBodyTableListTable struct {
	// The ID of the physical database.
	DatabaseId *string `json:"DatabaseId,omitempty" xml:"DatabaseId,omitempty"`
	// The description of the table.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The encoding format of the table.
	Encoding *string `json:"Encoding,omitempty" xml:"Encoding,omitempty"`
	// The engine of the table.
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The number of rows in the table. This is a statistical value and does not indicate the actual number of rows.
	NumRows *int64 `json:"NumRows,omitempty" xml:"NumRows,omitempty"`
	// The ID list of the table owners.
	OwnerIdList *ListTablesResponseBodyTableListTableOwnerIdList `json:"OwnerIdList,omitempty" xml:"OwnerIdList,omitempty" type:"Struct"`
	// The nickname list of the table owners.
	OwnerNameList *ListTablesResponseBodyTableListTableOwnerNameList `json:"OwnerNameList,omitempty" xml:"OwnerNameList,omitempty" type:"Struct"`
	// The storage space that is occupied by the table. This is a statistical value and does not indicate the accurate storage space. Unit: MB.
	StoreCapacity *int64 `json:"StoreCapacity,omitempty" xml:"StoreCapacity,omitempty"`
	// The GUID of the table in DMS.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
	// The ID of the table.
	TableId *string `json:"TableId,omitempty" xml:"TableId,omitempty"`
	// The table name.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	// The database in which the table resides.
	TableSchemaName *string `json:"TableSchemaName,omitempty" xml:"TableSchemaName,omitempty"`
	// The type of the table. Default value: NORMAL.
	TableType *string `json:"TableType,omitempty" xml:"TableType,omitempty"`
}

func (s ListTablesResponseBodyTableListTable) String() string {
	return tea.Prettify(s)
}

func (s ListTablesResponseBodyTableListTable) GoString() string {
	return s.String()
}

func (s *ListTablesResponseBodyTableListTable) SetDatabaseId(v string) *ListTablesResponseBodyTableListTable {
	s.DatabaseId = &v
	return s
}

func (s *ListTablesResponseBodyTableListTable) SetDescription(v string) *ListTablesResponseBodyTableListTable {
	s.Description = &v
	return s
}

func (s *ListTablesResponseBodyTableListTable) SetEncoding(v string) *ListTablesResponseBodyTableListTable {
	s.Encoding = &v
	return s
}

func (s *ListTablesResponseBodyTableListTable) SetEngine(v string) *ListTablesResponseBodyTableListTable {
	s.Engine = &v
	return s
}

func (s *ListTablesResponseBodyTableListTable) SetNumRows(v int64) *ListTablesResponseBodyTableListTable {
	s.NumRows = &v
	return s
}

func (s *ListTablesResponseBodyTableListTable) SetOwnerIdList(v *ListTablesResponseBodyTableListTableOwnerIdList) *ListTablesResponseBodyTableListTable {
	s.OwnerIdList = v
	return s
}

func (s *ListTablesResponseBodyTableListTable) SetOwnerNameList(v *ListTablesResponseBodyTableListTableOwnerNameList) *ListTablesResponseBodyTableListTable {
	s.OwnerNameList = v
	return s
}

func (s *ListTablesResponseBodyTableListTable) SetStoreCapacity(v int64) *ListTablesResponseBodyTableListTable {
	s.StoreCapacity = &v
	return s
}

func (s *ListTablesResponseBodyTableListTable) SetTableGuid(v string) *ListTablesResponseBodyTableListTable {
	s.TableGuid = &v
	return s
}

func (s *ListTablesResponseBodyTableListTable) SetTableId(v string) *ListTablesResponseBodyTableListTable {
	s.TableId = &v
	return s
}

func (s *ListTablesResponseBodyTableListTable) SetTableName(v string) *ListTablesResponseBodyTableListTable {
	s.TableName = &v
	return s
}

func (s *ListTablesResponseBodyTableListTable) SetTableSchemaName(v string) *ListTablesResponseBodyTableListTable {
	s.TableSchemaName = &v
	return s
}

func (s *ListTablesResponseBodyTableListTable) SetTableType(v string) *ListTablesResponseBodyTableListTable {
	s.TableType = &v
	return s
}

type ListTablesResponseBodyTableListTableOwnerIdList struct {
	OwnerIds []*string `json:"OwnerIds,omitempty" xml:"OwnerIds,omitempty" type:"Repeated"`
}

func (s ListTablesResponseBodyTableListTableOwnerIdList) String() string {
	return tea.Prettify(s)
}

func (s ListTablesResponseBodyTableListTableOwnerIdList) GoString() string {
	return s.String()
}

func (s *ListTablesResponseBodyTableListTableOwnerIdList) SetOwnerIds(v []*string) *ListTablesResponseBodyTableListTableOwnerIdList {
	s.OwnerIds = v
	return s
}

type ListTablesResponseBodyTableListTableOwnerNameList struct {
	OwnerNames []*string `json:"OwnerNames,omitempty" xml:"OwnerNames,omitempty" type:"Repeated"`
}

func (s ListTablesResponseBodyTableListTableOwnerNameList) String() string {
	return tea.Prettify(s)
}

func (s ListTablesResponseBodyTableListTableOwnerNameList) GoString() string {
	return s.String()
}

func (s *ListTablesResponseBodyTableListTableOwnerNameList) SetOwnerNames(v []*string) *ListTablesResponseBodyTableListTableOwnerNameList {
	s.OwnerNames = v
	return s
}

type ListTablesResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTablesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTablesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTablesResponse) GoString() string {
	return s.String()
}

func (s *ListTablesResponse) SetHeaders(v map[string]*string) *ListTablesResponse {
	s.Headers = v
	return s
}

func (s *ListTablesResponse) SetStatusCode(v int32) *ListTablesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTablesResponse) SetBody(v *ListTablesResponseBody) *ListTablesResponse {
	s.Body = v
	return s
}

type ListTaskFlowRequest struct {
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListTaskFlowRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowRequest) GoString() string {
	return s.String()
}

func (s *ListTaskFlowRequest) SetTid(v int64) *ListTaskFlowRequest {
	s.Tid = &v
	return s
}

type ListTaskFlowResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The information about the task flows returned.
	TaskFlowList *ListTaskFlowResponseBodyTaskFlowList `json:"TaskFlowList,omitempty" xml:"TaskFlowList,omitempty" type:"Struct"`
}

func (s ListTaskFlowResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowResponseBody) GoString() string {
	return s.String()
}

func (s *ListTaskFlowResponseBody) SetErrorCode(v string) *ListTaskFlowResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListTaskFlowResponseBody) SetErrorMessage(v string) *ListTaskFlowResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListTaskFlowResponseBody) SetRequestId(v string) *ListTaskFlowResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTaskFlowResponseBody) SetSuccess(v bool) *ListTaskFlowResponseBody {
	s.Success = &v
	return s
}

func (s *ListTaskFlowResponseBody) SetTaskFlowList(v *ListTaskFlowResponseBodyTaskFlowList) *ListTaskFlowResponseBody {
	s.TaskFlowList = v
	return s
}

type ListTaskFlowResponseBodyTaskFlowList struct {
	TaskFlow []*ListTaskFlowResponseBodyTaskFlowListTaskFlow `json:"TaskFlow,omitempty" xml:"TaskFlow,omitempty" type:"Repeated"`
}

func (s ListTaskFlowResponseBodyTaskFlowList) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowResponseBodyTaskFlowList) GoString() string {
	return s.String()
}

func (s *ListTaskFlowResponseBodyTaskFlowList) SetTaskFlow(v []*ListTaskFlowResponseBodyTaskFlowListTaskFlow) *ListTaskFlowResponseBodyTaskFlowList {
	s.TaskFlow = v
	return s
}

type ListTaskFlowResponseBodyTaskFlowListTaskFlow struct {
	// The ID of the user who creates the task flow.
	CreatorId *string `json:"CreatorId,omitempty" xml:"CreatorId,omitempty"`
	// The name of the user who creates the task flow.
	CreatorNickName *string `json:"CreatorNickName,omitempty" xml:"CreatorNickName,omitempty"`
	// The name of the task flow owner.
	DagOwnerNickName *string `json:"DagOwnerNickName,omitempty" xml:"DagOwnerNickName,omitempty"`
	// The ID of the latest deployment record.
	DeployId *int64 `json:"DeployId,omitempty" xml:"DeployId,omitempty"`
	// The ID of the task flow.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The status of the latest execution. Valid values:
	//
	// *   **0**: invalid.
	// *   **1**: scheduling disabled.
	// *   **2**: waiting to be scheduled.
	LatestInstanceStatus *int32 `json:"LatestInstanceStatus,omitempty" xml:"LatestInstanceStatus,omitempty"`
	// The time when the latest execution record was generated.
	LatestInstanceTime *string `json:"LatestInstanceTime,omitempty" xml:"LatestInstanceTime,omitempty"`
	// The status of the task flow. Valid values:
	//
	// *   **0**: The task flow is invalid.
	// *   **1**: Scheduling is disabled for the task flow.
	// *   **2**: The task flow is waiting to be scheduled.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListTaskFlowResponseBodyTaskFlowListTaskFlow) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowResponseBodyTaskFlowListTaskFlow) GoString() string {
	return s.String()
}

func (s *ListTaskFlowResponseBodyTaskFlowListTaskFlow) SetCreatorId(v string) *ListTaskFlowResponseBodyTaskFlowListTaskFlow {
	s.CreatorId = &v
	return s
}

func (s *ListTaskFlowResponseBodyTaskFlowListTaskFlow) SetCreatorNickName(v string) *ListTaskFlowResponseBodyTaskFlowListTaskFlow {
	s.CreatorNickName = &v
	return s
}

func (s *ListTaskFlowResponseBodyTaskFlowListTaskFlow) SetDagOwnerNickName(v string) *ListTaskFlowResponseBodyTaskFlowListTaskFlow {
	s.DagOwnerNickName = &v
	return s
}

func (s *ListTaskFlowResponseBodyTaskFlowListTaskFlow) SetDeployId(v int64) *ListTaskFlowResponseBodyTaskFlowListTaskFlow {
	s.DeployId = &v
	return s
}

func (s *ListTaskFlowResponseBodyTaskFlowListTaskFlow) SetId(v int64) *ListTaskFlowResponseBodyTaskFlowListTaskFlow {
	s.Id = &v
	return s
}

func (s *ListTaskFlowResponseBodyTaskFlowListTaskFlow) SetLatestInstanceStatus(v int32) *ListTaskFlowResponseBodyTaskFlowListTaskFlow {
	s.LatestInstanceStatus = &v
	return s
}

func (s *ListTaskFlowResponseBodyTaskFlowListTaskFlow) SetLatestInstanceTime(v string) *ListTaskFlowResponseBodyTaskFlowListTaskFlow {
	s.LatestInstanceTime = &v
	return s
}

func (s *ListTaskFlowResponseBodyTaskFlowListTaskFlow) SetStatus(v int32) *ListTaskFlowResponseBodyTaskFlowListTaskFlow {
	s.Status = &v
	return s
}

type ListTaskFlowResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTaskFlowResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTaskFlowResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowResponse) GoString() string {
	return s.String()
}

func (s *ListTaskFlowResponse) SetHeaders(v map[string]*string) *ListTaskFlowResponse {
	s.Headers = v
	return s
}

func (s *ListTaskFlowResponse) SetStatusCode(v int32) *ListTaskFlowResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTaskFlowResponse) SetBody(v *ListTaskFlowResponseBody) *ListTaskFlowResponse {
	s.Body = v
	return s
}

type ListTaskFlowConstantsRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the tenant.
	//
	// > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListTaskFlowConstantsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowConstantsRequest) GoString() string {
	return s.String()
}

func (s *ListTaskFlowConstantsRequest) SetDagId(v int64) *ListTaskFlowConstantsRequest {
	s.DagId = &v
	return s
}

func (s *ListTaskFlowConstantsRequest) SetTid(v int64) *ListTaskFlowConstantsRequest {
	s.Tid = &v
	return s
}

type ListTaskFlowConstantsResponseBody struct {
	// A list of constant key-value pairs for the task flow.
	DagConstants *ListTaskFlowConstantsResponseBodyDagConstants `json:"DagConstants,omitempty" xml:"DagConstants,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can use the ID to locate logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListTaskFlowConstantsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowConstantsResponseBody) GoString() string {
	return s.String()
}

func (s *ListTaskFlowConstantsResponseBody) SetDagConstants(v *ListTaskFlowConstantsResponseBodyDagConstants) *ListTaskFlowConstantsResponseBody {
	s.DagConstants = v
	return s
}

func (s *ListTaskFlowConstantsResponseBody) SetErrorCode(v string) *ListTaskFlowConstantsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListTaskFlowConstantsResponseBody) SetErrorMessage(v string) *ListTaskFlowConstantsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListTaskFlowConstantsResponseBody) SetRequestId(v string) *ListTaskFlowConstantsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTaskFlowConstantsResponseBody) SetSuccess(v bool) *ListTaskFlowConstantsResponseBody {
	s.Success = &v
	return s
}

type ListTaskFlowConstantsResponseBodyDagConstants struct {
	DagConstant []*ListTaskFlowConstantsResponseBodyDagConstantsDagConstant `json:"DagConstant,omitempty" xml:"DagConstant,omitempty" type:"Repeated"`
}

func (s ListTaskFlowConstantsResponseBodyDagConstants) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowConstantsResponseBodyDagConstants) GoString() string {
	return s.String()
}

func (s *ListTaskFlowConstantsResponseBodyDagConstants) SetDagConstant(v []*ListTaskFlowConstantsResponseBodyDagConstantsDagConstant) *ListTaskFlowConstantsResponseBodyDagConstants {
	s.DagConstant = v
	return s
}

type ListTaskFlowConstantsResponseBodyDagConstantsDagConstant struct {
	// The constant key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The constant value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTaskFlowConstantsResponseBodyDagConstantsDagConstant) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowConstantsResponseBodyDagConstantsDagConstant) GoString() string {
	return s.String()
}

func (s *ListTaskFlowConstantsResponseBodyDagConstantsDagConstant) SetKey(v string) *ListTaskFlowConstantsResponseBodyDagConstantsDagConstant {
	s.Key = &v
	return s
}

func (s *ListTaskFlowConstantsResponseBodyDagConstantsDagConstant) SetValue(v string) *ListTaskFlowConstantsResponseBodyDagConstantsDagConstant {
	s.Value = &v
	return s
}

type ListTaskFlowConstantsResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTaskFlowConstantsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTaskFlowConstantsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowConstantsResponse) GoString() string {
	return s.String()
}

func (s *ListTaskFlowConstantsResponse) SetHeaders(v map[string]*string) *ListTaskFlowConstantsResponse {
	s.Headers = v
	return s
}

func (s *ListTaskFlowConstantsResponse) SetStatusCode(v int32) *ListTaskFlowConstantsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTaskFlowConstantsResponse) SetBody(v *ListTaskFlowConstantsResponseBody) *ListTaskFlowConstantsResponse {
	s.Body = v
	return s
}

type ListTaskFlowCooperatorsRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the tenant.
	//
	// >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListTaskFlowCooperatorsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowCooperatorsRequest) GoString() string {
	return s.String()
}

func (s *ListTaskFlowCooperatorsRequest) SetDagId(v int64) *ListTaskFlowCooperatorsRequest {
	s.DagId = &v
	return s
}

func (s *ListTaskFlowCooperatorsRequest) SetTid(v int64) *ListTaskFlowCooperatorsRequest {
	s.Tid = &v
	return s
}

type ListTaskFlowCooperatorsResponseBody struct {
	// The users that are involved in the task flow.
	CooperatorList *ListTaskFlowCooperatorsResponseBodyCooperatorList `json:"CooperatorList,omitempty" xml:"CooperatorList,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can use the ID to locate logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListTaskFlowCooperatorsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowCooperatorsResponseBody) GoString() string {
	return s.String()
}

func (s *ListTaskFlowCooperatorsResponseBody) SetCooperatorList(v *ListTaskFlowCooperatorsResponseBodyCooperatorList) *ListTaskFlowCooperatorsResponseBody {
	s.CooperatorList = v
	return s
}

func (s *ListTaskFlowCooperatorsResponseBody) SetErrorCode(v string) *ListTaskFlowCooperatorsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListTaskFlowCooperatorsResponseBody) SetErrorMessage(v string) *ListTaskFlowCooperatorsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListTaskFlowCooperatorsResponseBody) SetRequestId(v string) *ListTaskFlowCooperatorsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTaskFlowCooperatorsResponseBody) SetSuccess(v bool) *ListTaskFlowCooperatorsResponseBody {
	s.Success = &v
	return s
}

type ListTaskFlowCooperatorsResponseBodyCooperatorList struct {
	Cooperator []*ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator `json:"Cooperator,omitempty" xml:"Cooperator,omitempty" type:"Repeated"`
}

func (s ListTaskFlowCooperatorsResponseBodyCooperatorList) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowCooperatorsResponseBodyCooperatorList) GoString() string {
	return s.String()
}

func (s *ListTaskFlowCooperatorsResponseBodyCooperatorList) SetCooperator(v []*ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator) *ListTaskFlowCooperatorsResponseBodyCooperatorList {
	s.Cooperator = v
	return s
}

type ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator struct {
	// The email address of the user.
	Email *string `json:"Email,omitempty" xml:"Email,omitempty"`
	// The username.
	LoginName *string `json:"LoginName,omitempty" xml:"LoginName,omitempty"`
	// The alias of the user.
	NickName *string `json:"NickName,omitempty" xml:"NickName,omitempty"`
	// userId.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator) GoString() string {
	return s.String()
}

func (s *ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator) SetEmail(v string) *ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator {
	s.Email = &v
	return s
}

func (s *ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator) SetLoginName(v string) *ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator {
	s.LoginName = &v
	return s
}

func (s *ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator) SetNickName(v string) *ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator {
	s.NickName = &v
	return s
}

func (s *ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator) SetUserId(v string) *ListTaskFlowCooperatorsResponseBodyCooperatorListCooperator {
	s.UserId = &v
	return s
}

type ListTaskFlowCooperatorsResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTaskFlowCooperatorsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTaskFlowCooperatorsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowCooperatorsResponse) GoString() string {
	return s.String()
}

func (s *ListTaskFlowCooperatorsResponse) SetHeaders(v map[string]*string) *ListTaskFlowCooperatorsResponse {
	s.Headers = v
	return s
}

func (s *ListTaskFlowCooperatorsResponse) SetStatusCode(v int32) *ListTaskFlowCooperatorsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTaskFlowCooperatorsResponse) SetBody(v *ListTaskFlowCooperatorsResponseBody) *ListTaskFlowCooperatorsResponse {
	s.Body = v
	return s
}

type ListTaskFlowEdgesByConditionRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the task flow edge.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the end node on the edge.
	NodeEnd *int64 `json:"NodeEnd,omitempty" xml:"NodeEnd,omitempty"`
	// The ID of the start node on the edge.
	NodeFrom *int64 `json:"NodeFrom,omitempty" xml:"NodeFrom,omitempty"`
	// The ID of the tenant.
	//
	// >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListTaskFlowEdgesByConditionRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowEdgesByConditionRequest) GoString() string {
	return s.String()
}

func (s *ListTaskFlowEdgesByConditionRequest) SetDagId(v int64) *ListTaskFlowEdgesByConditionRequest {
	s.DagId = &v
	return s
}

func (s *ListTaskFlowEdgesByConditionRequest) SetId(v int64) *ListTaskFlowEdgesByConditionRequest {
	s.Id = &v
	return s
}

func (s *ListTaskFlowEdgesByConditionRequest) SetNodeEnd(v int64) *ListTaskFlowEdgesByConditionRequest {
	s.NodeEnd = &v
	return s
}

func (s *ListTaskFlowEdgesByConditionRequest) SetNodeFrom(v int64) *ListTaskFlowEdgesByConditionRequest {
	s.NodeFrom = &v
	return s
}

func (s *ListTaskFlowEdgesByConditionRequest) SetTid(v int64) *ListTaskFlowEdgesByConditionRequest {
	s.Tid = &v
	return s
}

type ListTaskFlowEdgesByConditionResponseBody struct {
	// The list of task flow edges.
	Edges *ListTaskFlowEdgesByConditionResponseBodyEdges `json:"Edges,omitempty" xml:"Edges,omitempty" type:"Struct"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can use the ID to locate logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListTaskFlowEdgesByConditionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowEdgesByConditionResponseBody) GoString() string {
	return s.String()
}

func (s *ListTaskFlowEdgesByConditionResponseBody) SetEdges(v *ListTaskFlowEdgesByConditionResponseBodyEdges) *ListTaskFlowEdgesByConditionResponseBody {
	s.Edges = v
	return s
}

func (s *ListTaskFlowEdgesByConditionResponseBody) SetErrorCode(v string) *ListTaskFlowEdgesByConditionResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListTaskFlowEdgesByConditionResponseBody) SetErrorMessage(v string) *ListTaskFlowEdgesByConditionResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListTaskFlowEdgesByConditionResponseBody) SetRequestId(v string) *ListTaskFlowEdgesByConditionResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTaskFlowEdgesByConditionResponseBody) SetSuccess(v bool) *ListTaskFlowEdgesByConditionResponseBody {
	s.Success = &v
	return s
}

type ListTaskFlowEdgesByConditionResponseBodyEdges struct {
	Edge []*ListTaskFlowEdgesByConditionResponseBodyEdgesEdge `json:"Edge,omitempty" xml:"Edge,omitempty" type:"Repeated"`
}

func (s ListTaskFlowEdgesByConditionResponseBodyEdges) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowEdgesByConditionResponseBodyEdges) GoString() string {
	return s.String()
}

func (s *ListTaskFlowEdgesByConditionResponseBodyEdges) SetEdge(v []*ListTaskFlowEdgesByConditionResponseBodyEdgesEdge) *ListTaskFlowEdgesByConditionResponseBodyEdges {
	s.Edge = v
	return s
}

type ListTaskFlowEdgesByConditionResponseBodyEdgesEdge struct {
	// The ID of the task flow edge.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the end node on the edge.
	NodeEnd *int64 `json:"NodeEnd,omitempty" xml:"NodeEnd,omitempty"`
	// The ID of the start node on the edge.
	NodeFrom *int64 `json:"NodeFrom,omitempty" xml:"NodeFrom,omitempty"`
}

func (s ListTaskFlowEdgesByConditionResponseBodyEdgesEdge) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowEdgesByConditionResponseBodyEdgesEdge) GoString() string {
	return s.String()
}

func (s *ListTaskFlowEdgesByConditionResponseBodyEdgesEdge) SetId(v int64) *ListTaskFlowEdgesByConditionResponseBodyEdgesEdge {
	s.Id = &v
	return s
}

func (s *ListTaskFlowEdgesByConditionResponseBodyEdgesEdge) SetNodeEnd(v int64) *ListTaskFlowEdgesByConditionResponseBodyEdgesEdge {
	s.NodeEnd = &v
	return s
}

func (s *ListTaskFlowEdgesByConditionResponseBodyEdgesEdge) SetNodeFrom(v int64) *ListTaskFlowEdgesByConditionResponseBodyEdgesEdge {
	s.NodeFrom = &v
	return s
}

type ListTaskFlowEdgesByConditionResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTaskFlowEdgesByConditionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTaskFlowEdgesByConditionResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowEdgesByConditionResponse) GoString() string {
	return s.String()
}

func (s *ListTaskFlowEdgesByConditionResponse) SetHeaders(v map[string]*string) *ListTaskFlowEdgesByConditionResponse {
	s.Headers = v
	return s
}

func (s *ListTaskFlowEdgesByConditionResponse) SetStatusCode(v int32) *ListTaskFlowEdgesByConditionResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTaskFlowEdgesByConditionResponse) SetBody(v *ListTaskFlowEdgesByConditionResponseBody) *ListTaskFlowEdgesByConditionResponse {
	s.Body = v
	return s
}

type ListTaskFlowInstanceRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the ID of the task flow.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The number of the page to return.
	PageIndex *int32 `json:"PageIndex,omitempty" xml:"PageIndex,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The beginning of the time range to query the execution records of the task flow. Specify the time in the yyyy-MM-DD format.
	StartTimeBegin *string `json:"StartTimeBegin,omitempty" xml:"StartTimeBegin,omitempty"`
	// The end of the time range to query the execution records of the task flow. Specify the time in the yyyy-MM-DD format.
	StartTimeEnd *string `json:"StartTimeEnd,omitempty" xml:"StartTimeEnd,omitempty"`
	// The running status of the task node. Valid values:
	//
	// - **0**: Waiting for scheduling
	//
	// - **1**: Running
	//
	// - **2**: Suspend
	//
	// - **3**: Failed to run
	//
	// - **4**: Run successfully
	//
	// - **5**: Completed
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The mode in which the task flow is triggered. Valid values:
	//
	// *   **0**: The task flow is automatically triggered based on periodic scheduling.
	// *   **1**: The task flow is manually triggered.
	TriggerType *int32 `json:"TriggerType,omitempty" xml:"TriggerType,omitempty"`
	// Adjust filter conditions:
	//
	// - true: StartTimeBegin and StartTimeEnd are the time range for filtering services.
	//
	// - false: StartTimeBegin and StartTimeEnd are the time range for the task to run.
	UseBizDate *bool `json:"UseBizDate,omitempty" xml:"UseBizDate,omitempty"`
}

func (s ListTaskFlowInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowInstanceRequest) GoString() string {
	return s.String()
}

func (s *ListTaskFlowInstanceRequest) SetDagId(v int64) *ListTaskFlowInstanceRequest {
	s.DagId = &v
	return s
}

func (s *ListTaskFlowInstanceRequest) SetPageIndex(v int32) *ListTaskFlowInstanceRequest {
	s.PageIndex = &v
	return s
}

func (s *ListTaskFlowInstanceRequest) SetPageSize(v int32) *ListTaskFlowInstanceRequest {
	s.PageSize = &v
	return s
}

func (s *ListTaskFlowInstanceRequest) SetStartTimeBegin(v string) *ListTaskFlowInstanceRequest {
	s.StartTimeBegin = &v
	return s
}

func (s *ListTaskFlowInstanceRequest) SetStartTimeEnd(v string) *ListTaskFlowInstanceRequest {
	s.StartTimeEnd = &v
	return s
}

func (s *ListTaskFlowInstanceRequest) SetStatus(v int32) *ListTaskFlowInstanceRequest {
	s.Status = &v
	return s
}

func (s *ListTaskFlowInstanceRequest) SetTid(v int64) *ListTaskFlowInstanceRequest {
	s.Tid = &v
	return s
}

func (s *ListTaskFlowInstanceRequest) SetTriggerType(v int32) *ListTaskFlowInstanceRequest {
	s.TriggerType = &v
	return s
}

func (s *ListTaskFlowInstanceRequest) SetUseBizDate(v bool) *ListTaskFlowInstanceRequest {
	s.UseBizDate = &v
	return s
}

type ListTaskFlowInstanceResponseBody struct {
	// The information about the execution records returned.
	DAGInstanceList *ListTaskFlowInstanceResponseBodyDAGInstanceList `json:"DAGInstanceList,omitempty" xml:"DAGInstanceList,omitempty" type:"Struct"`
	// The error code returned if the request fails.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**: The request is successful.
	// *   **false**: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of execution records returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListTaskFlowInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *ListTaskFlowInstanceResponseBody) SetDAGInstanceList(v *ListTaskFlowInstanceResponseBodyDAGInstanceList) *ListTaskFlowInstanceResponseBody {
	s.DAGInstanceList = v
	return s
}

func (s *ListTaskFlowInstanceResponseBody) SetErrorCode(v string) *ListTaskFlowInstanceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListTaskFlowInstanceResponseBody) SetErrorMessage(v string) *ListTaskFlowInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListTaskFlowInstanceResponseBody) SetRequestId(v string) *ListTaskFlowInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTaskFlowInstanceResponseBody) SetSuccess(v bool) *ListTaskFlowInstanceResponseBody {
	s.Success = &v
	return s
}

func (s *ListTaskFlowInstanceResponseBody) SetTotalCount(v int32) *ListTaskFlowInstanceResponseBody {
	s.TotalCount = &v
	return s
}

type ListTaskFlowInstanceResponseBodyDAGInstanceList struct {
	DAGInstance []*ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance `json:"DAGInstance,omitempty" xml:"DAGInstance,omitempty" type:"Repeated"`
}

func (s ListTaskFlowInstanceResponseBodyDAGInstanceList) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowInstanceResponseBodyDAGInstanceList) GoString() string {
	return s.String()
}

func (s *ListTaskFlowInstanceResponseBodyDAGInstanceList) SetDAGInstance(v []*ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance) *ListTaskFlowInstanceResponseBodyDAGInstanceList {
	s.DAGInstance = v
	return s
}

type ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance struct {
	// The business time of the task flow. The time is displayed in the yyyy-MM-DD HH:mm:ss format.
	BusinessTime *string `json:"BusinessTime,omitempty" xml:"BusinessTime,omitempty"`
	// The ID of the task flow.
	DagId *string `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The name of the task flow.
	DagName *string `json:"DagName,omitempty" xml:"DagName,omitempty"`
	// The version of the task flow.
	DagVersion *string `json:"DagVersion,omitempty" xml:"DagVersion,omitempty"`
	// The time when the execution of the task flow was complete. The time is displayed in the yyyy-MM-DD HH:mm:ss format.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the previously published version of the task flow.
	HistoryDagId *int64 `json:"HistoryDagId,omitempty" xml:"HistoryDagId,omitempty"`
	// The ID of the execution record.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The description of the task.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The name of the task flow owner.
	OwnerName *string `json:"OwnerName,omitempty" xml:"OwnerName,omitempty"`
	// The status of the task flow. Valid values:
	//
	// *   **0**: The task flow is waiting to be scheduled.
	// *   **1**: The task flow is being executed.
	// *   **2**: The task flow is paused.
	// *   **3**: The task flow failed.
	// *   **4**: The task flow is executed.
	// *   **5**: The task flow is complete.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The mode in which the task flow is triggered. Valid values:
	//
	// *   **0**: The task flow is automatically triggered based on periodic scheduling.
	// *   **1**: The task flow is manually triggered.
	TriggerType *int32 `json:"TriggerType,omitempty" xml:"TriggerType,omitempty"`
	// The time when the execution of the task flow was start. The time is displayed in the yyyy-MM-DD HH:mm:ss format.
	StartTime *string `json:"startTime,omitempty" xml:"startTime,omitempty"`
}

func (s ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance) GoString() string {
	return s.String()
}

func (s *ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance) SetBusinessTime(v string) *ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance {
	s.BusinessTime = &v
	return s
}

func (s *ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance) SetDagId(v string) *ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance {
	s.DagId = &v
	return s
}

func (s *ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance) SetDagName(v string) *ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance {
	s.DagName = &v
	return s
}

func (s *ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance) SetDagVersion(v string) *ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance {
	s.DagVersion = &v
	return s
}

func (s *ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance) SetEndTime(v string) *ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance {
	s.EndTime = &v
	return s
}

func (s *ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance) SetHistoryDagId(v int64) *ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance {
	s.HistoryDagId = &v
	return s
}

func (s *ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance) SetId(v int64) *ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance {
	s.Id = &v
	return s
}

func (s *ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance) SetMessage(v string) *ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance {
	s.Message = &v
	return s
}

func (s *ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance) SetOwnerName(v string) *ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance {
	s.OwnerName = &v
	return s
}

func (s *ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance) SetStatus(v int32) *ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance {
	s.Status = &v
	return s
}

func (s *ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance) SetTriggerType(v int32) *ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance {
	s.TriggerType = &v
	return s
}

func (s *ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance) SetStartTime(v string) *ListTaskFlowInstanceResponseBodyDAGInstanceListDAGInstance {
	s.StartTime = &v
	return s
}

type ListTaskFlowInstanceResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTaskFlowInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTaskFlowInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowInstanceResponse) GoString() string {
	return s.String()
}

func (s *ListTaskFlowInstanceResponse) SetHeaders(v map[string]*string) *ListTaskFlowInstanceResponse {
	s.Headers = v
	return s
}

func (s *ListTaskFlowInstanceResponse) SetStatusCode(v int32) *ListTaskFlowInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTaskFlowInstanceResponse) SetBody(v *ListTaskFlowInstanceResponseBody) *ListTaskFlowInstanceResponse {
	s.Body = v
	return s
}

type ListTaskFlowTimeVariablesRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the tenant.
	//
	// > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListTaskFlowTimeVariablesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowTimeVariablesRequest) GoString() string {
	return s.String()
}

func (s *ListTaskFlowTimeVariablesRequest) SetDagId(v int64) *ListTaskFlowTimeVariablesRequest {
	s.DagId = &v
	return s
}

func (s *ListTaskFlowTimeVariablesRequest) SetTid(v int64) *ListTaskFlowTimeVariablesRequest {
	s.Tid = &v
	return s
}

type ListTaskFlowTimeVariablesResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The time variables for the task flow.
	TimeVariables *ListTaskFlowTimeVariablesResponseBodyTimeVariables `json:"TimeVariables,omitempty" xml:"TimeVariables,omitempty" type:"Struct"`
}

func (s ListTaskFlowTimeVariablesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowTimeVariablesResponseBody) GoString() string {
	return s.String()
}

func (s *ListTaskFlowTimeVariablesResponseBody) SetErrorCode(v string) *ListTaskFlowTimeVariablesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListTaskFlowTimeVariablesResponseBody) SetErrorMessage(v string) *ListTaskFlowTimeVariablesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListTaskFlowTimeVariablesResponseBody) SetRequestId(v string) *ListTaskFlowTimeVariablesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTaskFlowTimeVariablesResponseBody) SetSuccess(v bool) *ListTaskFlowTimeVariablesResponseBody {
	s.Success = &v
	return s
}

func (s *ListTaskFlowTimeVariablesResponseBody) SetTimeVariables(v *ListTaskFlowTimeVariablesResponseBodyTimeVariables) *ListTaskFlowTimeVariablesResponseBody {
	s.TimeVariables = v
	return s
}

type ListTaskFlowTimeVariablesResponseBodyTimeVariables struct {
	TimeVariable []*ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable `json:"TimeVariable,omitempty" xml:"TimeVariable,omitempty" type:"Repeated"`
}

func (s ListTaskFlowTimeVariablesResponseBodyTimeVariables) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowTimeVariablesResponseBodyTimeVariables) GoString() string {
	return s.String()
}

func (s *ListTaskFlowTimeVariablesResponseBodyTimeVariables) SetTimeVariable(v []*ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable) *ListTaskFlowTimeVariablesResponseBodyTimeVariables {
	s.TimeVariable = v
	return s
}

type ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable struct {
	// The name of the time variable.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The format of the time variable.
	Pattern *string `json:"Pattern,omitempty" xml:"Pattern,omitempty"`
}

func (s ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable) GoString() string {
	return s.String()
}

func (s *ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable) SetName(v string) *ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable {
	s.Name = &v
	return s
}

func (s *ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable) SetPattern(v string) *ListTaskFlowTimeVariablesResponseBodyTimeVariablesTimeVariable {
	s.Pattern = &v
	return s
}

type ListTaskFlowTimeVariablesResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTaskFlowTimeVariablesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTaskFlowTimeVariablesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowTimeVariablesResponse) GoString() string {
	return s.String()
}

func (s *ListTaskFlowTimeVariablesResponse) SetHeaders(v map[string]*string) *ListTaskFlowTimeVariablesResponse {
	s.Headers = v
	return s
}

func (s *ListTaskFlowTimeVariablesResponse) SetStatusCode(v int32) *ListTaskFlowTimeVariablesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTaskFlowTimeVariablesResponse) SetBody(v *ListTaskFlowTimeVariablesResponseBody) *ListTaskFlowTimeVariablesResponse {
	s.Body = v
	return s
}

type ListTaskFlowsByPageRequest struct {
	// Filter condition, task flow ID list.
	DagIdList []*int64 `json:"DagIdList,omitempty" xml:"DagIdList,omitempty" type:"Repeated"`
	// The number of the page to return.
	PageIndex *int32 `json:"PageIndex,omitempty" xml:"PageIndex,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// Filter condition, application scenario ID.
	ScenarioId *int64 `json:"ScenarioId,omitempty" xml:"ScenarioId,omitempty"`
	// The keyword that is used to search for task flow names.
	SearchKey *string `json:"SearchKey,omitempty" xml:"SearchKey,omitempty"`
	// The ID of the tenant.
	//
	// > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListTaskFlowsByPageRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowsByPageRequest) GoString() string {
	return s.String()
}

func (s *ListTaskFlowsByPageRequest) SetDagIdList(v []*int64) *ListTaskFlowsByPageRequest {
	s.DagIdList = v
	return s
}

func (s *ListTaskFlowsByPageRequest) SetPageIndex(v int32) *ListTaskFlowsByPageRequest {
	s.PageIndex = &v
	return s
}

func (s *ListTaskFlowsByPageRequest) SetPageSize(v int32) *ListTaskFlowsByPageRequest {
	s.PageSize = &v
	return s
}

func (s *ListTaskFlowsByPageRequest) SetScenarioId(v int64) *ListTaskFlowsByPageRequest {
	s.ScenarioId = &v
	return s
}

func (s *ListTaskFlowsByPageRequest) SetSearchKey(v string) *ListTaskFlowsByPageRequest {
	s.SearchKey = &v
	return s
}

func (s *ListTaskFlowsByPageRequest) SetTid(v int64) *ListTaskFlowsByPageRequest {
	s.Tid = &v
	return s
}

type ListTaskFlowsByPageShrinkRequest struct {
	// Filter condition, task flow ID list.
	DagIdListShrink *string `json:"DagIdList,omitempty" xml:"DagIdList,omitempty"`
	// The number of the page to return.
	PageIndex *int32 `json:"PageIndex,omitempty" xml:"PageIndex,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// Filter condition, application scenario ID.
	ScenarioId *int64 `json:"ScenarioId,omitempty" xml:"ScenarioId,omitempty"`
	// The keyword that is used to search for task flow names.
	SearchKey *string `json:"SearchKey,omitempty" xml:"SearchKey,omitempty"`
	// The ID of the tenant.
	//
	// > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListTaskFlowsByPageShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowsByPageShrinkRequest) GoString() string {
	return s.String()
}

func (s *ListTaskFlowsByPageShrinkRequest) SetDagIdListShrink(v string) *ListTaskFlowsByPageShrinkRequest {
	s.DagIdListShrink = &v
	return s
}

func (s *ListTaskFlowsByPageShrinkRequest) SetPageIndex(v int32) *ListTaskFlowsByPageShrinkRequest {
	s.PageIndex = &v
	return s
}

func (s *ListTaskFlowsByPageShrinkRequest) SetPageSize(v int32) *ListTaskFlowsByPageShrinkRequest {
	s.PageSize = &v
	return s
}

func (s *ListTaskFlowsByPageShrinkRequest) SetScenarioId(v int64) *ListTaskFlowsByPageShrinkRequest {
	s.ScenarioId = &v
	return s
}

func (s *ListTaskFlowsByPageShrinkRequest) SetSearchKey(v string) *ListTaskFlowsByPageShrinkRequest {
	s.SearchKey = &v
	return s
}

func (s *ListTaskFlowsByPageShrinkRequest) SetTid(v int64) *ListTaskFlowsByPageShrinkRequest {
	s.Tid = &v
	return s
}

type ListTaskFlowsByPageResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The details of the returned task flows.
	TaskFlowList *ListTaskFlowsByPageResponseBodyTaskFlowList `json:"TaskFlowList,omitempty" xml:"TaskFlowList,omitempty" type:"Struct"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListTaskFlowsByPageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowsByPageResponseBody) GoString() string {
	return s.String()
}

func (s *ListTaskFlowsByPageResponseBody) SetErrorCode(v string) *ListTaskFlowsByPageResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListTaskFlowsByPageResponseBody) SetErrorMessage(v string) *ListTaskFlowsByPageResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListTaskFlowsByPageResponseBody) SetRequestId(v string) *ListTaskFlowsByPageResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTaskFlowsByPageResponseBody) SetSuccess(v bool) *ListTaskFlowsByPageResponseBody {
	s.Success = &v
	return s
}

func (s *ListTaskFlowsByPageResponseBody) SetTaskFlowList(v *ListTaskFlowsByPageResponseBodyTaskFlowList) *ListTaskFlowsByPageResponseBody {
	s.TaskFlowList = v
	return s
}

func (s *ListTaskFlowsByPageResponseBody) SetTotalCount(v int32) *ListTaskFlowsByPageResponseBody {
	s.TotalCount = &v
	return s
}

type ListTaskFlowsByPageResponseBodyTaskFlowList struct {
	TaskFlow []*ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow `json:"TaskFlow,omitempty" xml:"TaskFlow,omitempty" type:"Repeated"`
}

func (s ListTaskFlowsByPageResponseBodyTaskFlowList) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowsByPageResponseBodyTaskFlowList) GoString() string {
	return s.String()
}

func (s *ListTaskFlowsByPageResponseBodyTaskFlowList) SetTaskFlow(v []*ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow) *ListTaskFlowsByPageResponseBodyTaskFlowList {
	s.TaskFlow = v
	return s
}

type ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow struct {
	// The ID of the user who created the task flow.
	CreatorId *string `json:"CreatorId,omitempty" xml:"CreatorId,omitempty"`
	// The username of the user who created the task flow.
	CreatorNickName *string `json:"CreatorNickName,omitempty" xml:"CreatorNickName,omitempty"`
	// The start time of scheduled scheduling. The task flow is not scheduled before this point in time.
	CronBeginDate *string `json:"CronBeginDate,omitempty" xml:"CronBeginDate,omitempty"`
	// The end time of scheduled scheduling. The task flow is not scheduled after this point in time.
	CronEndDate *string `json:"CronEndDate,omitempty" xml:"CronEndDate,omitempty"`
	// Scheduled Cron.
	CronStr *string `json:"CronStr,omitempty" xml:"CronStr,omitempty"`
	// Whether to enable scheduled scheduling.
	CronSwitch *bool `json:"CronSwitch,omitempty" xml:"CronSwitch,omitempty"`
	// Scheduling cycle type. Valid values:
	// - **2**: Hourly scheduling
	// - **3**: Daily scheduling
	// - **4**: Weekly scheduling
	// - **5**: Monthly scheduling
	CronType *int32 `json:"CronType,omitempty" xml:"CronType,omitempty"`
	// The name of the task flow.
	DagName *string `json:"DagName,omitempty" xml:"DagName,omitempty"`
	// The user ID of the task flow owner.
	DagOwnerId *string `json:"DagOwnerId,omitempty" xml:"DagOwnerId,omitempty"`
	// The username of the owner of the task flow.
	DagOwnerNickName *string `json:"DagOwnerNickName,omitempty" xml:"DagOwnerNickName,omitempty"`
	// The ID of the last deployment record of the task flow.
	DeployId *int64 `json:"DeployId,omitempty" xml:"DeployId,omitempty"`
	// The description of the task flow.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the task flow.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The status of the last execution of the task flow. Valid values:
	//
	// *   **0**: invalid
	// *   **1**: scheduling disabled
	// *   **2**: waiting to be scheduled
	LatestInstanceStatus *int32 `json:"LatestInstanceStatus,omitempty" xml:"LatestInstanceStatus,omitempty"`
	// The time when the last execution record was created.
	LatestInstanceTime *string `json:"LatestInstanceTime,omitempty" xml:"LatestInstanceTime,omitempty"`
	// The ID of the application scenario.
	ScenarioId *string `json:"ScenarioId,omitempty" xml:"ScenarioId,omitempty"`
	// Event scheduling configuration, JSON string format.
	ScheduleParam *string `json:"ScheduleParam,omitempty" xml:"ScheduleParam,omitempty"`
	// The status of the task flow. Valid values:
	//
	// *   **0**: invalid
	// *   **1**: scheduling disabled
	// *   **2**: waiting to be scheduled
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// Time zone setting. Default value: East 8(Asia/Shanghai).
	TimeZoneId *string `json:"TimeZoneId,omitempty" xml:"TimeZoneId,omitempty"`
	// The trigger type. Valid values:
	// - **0**: Periodic scheduling
	// - **1**: Run manually
	TriggerType *int32 `json:"TriggerType,omitempty" xml:"TriggerType,omitempty"`
}

func (s ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow) GoString() string {
	return s.String()
}

func (s *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow) SetCreatorId(v string) *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow {
	s.CreatorId = &v
	return s
}

func (s *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow) SetCreatorNickName(v string) *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow {
	s.CreatorNickName = &v
	return s
}

func (s *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow) SetCronBeginDate(v string) *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow {
	s.CronBeginDate = &v
	return s
}

func (s *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow) SetCronEndDate(v string) *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow {
	s.CronEndDate = &v
	return s
}

func (s *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow) SetCronStr(v string) *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow {
	s.CronStr = &v
	return s
}

func (s *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow) SetCronSwitch(v bool) *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow {
	s.CronSwitch = &v
	return s
}

func (s *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow) SetCronType(v int32) *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow {
	s.CronType = &v
	return s
}

func (s *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow) SetDagName(v string) *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow {
	s.DagName = &v
	return s
}

func (s *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow) SetDagOwnerId(v string) *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow {
	s.DagOwnerId = &v
	return s
}

func (s *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow) SetDagOwnerNickName(v string) *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow {
	s.DagOwnerNickName = &v
	return s
}

func (s *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow) SetDeployId(v int64) *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow {
	s.DeployId = &v
	return s
}

func (s *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow) SetDescription(v string) *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow {
	s.Description = &v
	return s
}

func (s *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow) SetId(v int64) *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow {
	s.Id = &v
	return s
}

func (s *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow) SetLatestInstanceStatus(v int32) *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow {
	s.LatestInstanceStatus = &v
	return s
}

func (s *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow) SetLatestInstanceTime(v string) *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow {
	s.LatestInstanceTime = &v
	return s
}

func (s *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow) SetScenarioId(v string) *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow {
	s.ScenarioId = &v
	return s
}

func (s *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow) SetScheduleParam(v string) *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow {
	s.ScheduleParam = &v
	return s
}

func (s *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow) SetStatus(v int32) *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow {
	s.Status = &v
	return s
}

func (s *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow) SetTimeZoneId(v string) *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow {
	s.TimeZoneId = &v
	return s
}

func (s *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow) SetTriggerType(v int32) *ListTaskFlowsByPageResponseBodyTaskFlowListTaskFlow {
	s.TriggerType = &v
	return s
}

type ListTaskFlowsByPageResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTaskFlowsByPageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTaskFlowsByPageResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTaskFlowsByPageResponse) GoString() string {
	return s.String()
}

func (s *ListTaskFlowsByPageResponse) SetHeaders(v map[string]*string) *ListTaskFlowsByPageResponse {
	s.Headers = v
	return s
}

func (s *ListTaskFlowsByPageResponse) SetStatusCode(v int32) *ListTaskFlowsByPageResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTaskFlowsByPageResponse) SetBody(v *ListTaskFlowsByPageResponseBody) *ListTaskFlowsByPageResponse {
	s.Body = v
	return s
}

type ListTasksInTaskFlowRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the tenant.
	//
	// >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListTasksInTaskFlowRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTasksInTaskFlowRequest) GoString() string {
	return s.String()
}

func (s *ListTasksInTaskFlowRequest) SetDagId(v int64) *ListTasksInTaskFlowRequest {
	s.DagId = &v
	return s
}

func (s *ListTasksInTaskFlowRequest) SetTid(v int64) *ListTasksInTaskFlowRequest {
	s.Tid = &v
	return s
}

type ListTasksInTaskFlowResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can use the ID to locate logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The tasks in the task flow.
	Tasks *ListTasksInTaskFlowResponseBodyTasks `json:"Tasks,omitempty" xml:"Tasks,omitempty" type:"Struct"`
}

func (s ListTasksInTaskFlowResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTasksInTaskFlowResponseBody) GoString() string {
	return s.String()
}

func (s *ListTasksInTaskFlowResponseBody) SetErrorCode(v string) *ListTasksInTaskFlowResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListTasksInTaskFlowResponseBody) SetErrorMessage(v string) *ListTasksInTaskFlowResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListTasksInTaskFlowResponseBody) SetRequestId(v string) *ListTasksInTaskFlowResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTasksInTaskFlowResponseBody) SetSuccess(v bool) *ListTasksInTaskFlowResponseBody {
	s.Success = &v
	return s
}

func (s *ListTasksInTaskFlowResponseBody) SetTasks(v *ListTasksInTaskFlowResponseBodyTasks) *ListTasksInTaskFlowResponseBody {
	s.Tasks = v
	return s
}

type ListTasksInTaskFlowResponseBodyTasks struct {
	Task []*ListTasksInTaskFlowResponseBodyTasksTask `json:"Task,omitempty" xml:"Task,omitempty" type:"Repeated"`
}

func (s ListTasksInTaskFlowResponseBodyTasks) String() string {
	return tea.Prettify(s)
}

func (s ListTasksInTaskFlowResponseBodyTasks) GoString() string {
	return s.String()
}

func (s *ListTasksInTaskFlowResponseBodyTasks) SetTask(v []*ListTasksInTaskFlowResponseBodyTasksTask) *ListTasksInTaskFlowResponseBodyTasks {
	s.Task = v
	return s
}

type ListTasksInTaskFlowResponseBodyTasksTask struct {
	// The position of the node on the Directed Acyclic Graph (DAG).
	GraphParam *string `json:"GraphParam,omitempty" xml:"GraphParam,omitempty"`
	// The advanced configuration for the node.
	NodeConfig *string `json:"NodeConfig,omitempty" xml:"NodeConfig,omitempty"`
	// The configuration for the node.
	NodeContent *string `json:"NodeContent,omitempty" xml:"NodeContent,omitempty"`
	// The ID of the node.
	NodeId *string `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The name of the node.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The output variables for the task.
	NodeOutput *string `json:"NodeOutput,omitempty" xml:"NodeOutput,omitempty"`
	// The type of the node. For more information about the valid values for this parameter, see [NodeType parameter](~~424705~~).
	NodeType *string `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
	// The time variables configured for the node.
	TimeVariables *string `json:"TimeVariables,omitempty" xml:"TimeVariables,omitempty"`
}

func (s ListTasksInTaskFlowResponseBodyTasksTask) String() string {
	return tea.Prettify(s)
}

func (s ListTasksInTaskFlowResponseBodyTasksTask) GoString() string {
	return s.String()
}

func (s *ListTasksInTaskFlowResponseBodyTasksTask) SetGraphParam(v string) *ListTasksInTaskFlowResponseBodyTasksTask {
	s.GraphParam = &v
	return s
}

func (s *ListTasksInTaskFlowResponseBodyTasksTask) SetNodeConfig(v string) *ListTasksInTaskFlowResponseBodyTasksTask {
	s.NodeConfig = &v
	return s
}

func (s *ListTasksInTaskFlowResponseBodyTasksTask) SetNodeContent(v string) *ListTasksInTaskFlowResponseBodyTasksTask {
	s.NodeContent = &v
	return s
}

func (s *ListTasksInTaskFlowResponseBodyTasksTask) SetNodeId(v string) *ListTasksInTaskFlowResponseBodyTasksTask {
	s.NodeId = &v
	return s
}

func (s *ListTasksInTaskFlowResponseBodyTasksTask) SetNodeName(v string) *ListTasksInTaskFlowResponseBodyTasksTask {
	s.NodeName = &v
	return s
}

func (s *ListTasksInTaskFlowResponseBodyTasksTask) SetNodeOutput(v string) *ListTasksInTaskFlowResponseBodyTasksTask {
	s.NodeOutput = &v
	return s
}

func (s *ListTasksInTaskFlowResponseBodyTasksTask) SetNodeType(v string) *ListTasksInTaskFlowResponseBodyTasksTask {
	s.NodeType = &v
	return s
}

func (s *ListTasksInTaskFlowResponseBodyTasksTask) SetTimeVariables(v string) *ListTasksInTaskFlowResponseBodyTasksTask {
	s.TimeVariables = &v
	return s
}

type ListTasksInTaskFlowResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTasksInTaskFlowResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTasksInTaskFlowResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTasksInTaskFlowResponse) GoString() string {
	return s.String()
}

func (s *ListTasksInTaskFlowResponse) SetHeaders(v map[string]*string) *ListTasksInTaskFlowResponse {
	s.Headers = v
	return s
}

func (s *ListTasksInTaskFlowResponse) SetStatusCode(v int32) *ListTasksInTaskFlowResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTasksInTaskFlowResponse) SetBody(v *ListTasksInTaskFlowResponseBody) *ListTasksInTaskFlowResponse {
	s.Body = v
	return s
}

type ListUserPermissionsRequest struct {
	// The name of the database.
	DatabaseName *string `json:"DatabaseName,omitempty" xml:"DatabaseName,omitempty"`
	// The type of the database. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The type of the environment to which the database belongs. Valid values:
	//
	// *   product: production environment
	// *   dev: development environment
	// *   pre: staging environment
	// *   test: test environment
	// *   sit: SIT environment
	// *   uat: user acceptance testing (UAT) environment
	// *   pet: stress testing environment
	// *   stag: STAG environment
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// Specifies whether the database is a logical database. Valid values:
	//
	// *   true: The database is a logical database.
	// *   false: The database is a physical database.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The permissions on a specific type of resources that you want to query. Valid values:
	//
	// *   DATABASE: permissions on databases
	// *   TABLE: permissions on tables
	// *   COLUMN: permissions on fields
	// *   INSTANCE: permissions on instances
	PermType *string `json:"PermType,omitempty" xml:"PermType,omitempty"`
	// The keyword used in the query. For example, if you want to query permissions on an instance, you can specify the endpoint of the instance, such as rm-bp144d5ky4l4r****.
	SearchKey *string `json:"SearchKey,omitempty" xml:"SearchKey,omitempty"`
	// The ID of the tenant.
	//
	// >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The ID of the user. You can call the [GetUser](~~147098~~) or [ListUsers](~~141938~~) operation to query the ID of the user.
	//
	// >  The user ID is different from the ID of your Alibaba Cloud account.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s ListUserPermissionsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListUserPermissionsRequest) GoString() string {
	return s.String()
}

func (s *ListUserPermissionsRequest) SetDatabaseName(v string) *ListUserPermissionsRequest {
	s.DatabaseName = &v
	return s
}

func (s *ListUserPermissionsRequest) SetDbType(v string) *ListUserPermissionsRequest {
	s.DbType = &v
	return s
}

func (s *ListUserPermissionsRequest) SetEnvType(v string) *ListUserPermissionsRequest {
	s.EnvType = &v
	return s
}

func (s *ListUserPermissionsRequest) SetLogic(v bool) *ListUserPermissionsRequest {
	s.Logic = &v
	return s
}

func (s *ListUserPermissionsRequest) SetPageNumber(v int32) *ListUserPermissionsRequest {
	s.PageNumber = &v
	return s
}

func (s *ListUserPermissionsRequest) SetPageSize(v int32) *ListUserPermissionsRequest {
	s.PageSize = &v
	return s
}

func (s *ListUserPermissionsRequest) SetPermType(v string) *ListUserPermissionsRequest {
	s.PermType = &v
	return s
}

func (s *ListUserPermissionsRequest) SetSearchKey(v string) *ListUserPermissionsRequest {
	s.SearchKey = &v
	return s
}

func (s *ListUserPermissionsRequest) SetTid(v int64) *ListUserPermissionsRequest {
	s.Tid = &v
	return s
}

func (s *ListUserPermissionsRequest) SetUserId(v string) *ListUserPermissionsRequest {
	s.UserId = &v
	return s
}

type ListUserPermissionsResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// - true: The request is successful.
	// - false: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of entries that meet the query conditions.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The details of the permissions that the user has.
	UserPermissions *ListUserPermissionsResponseBodyUserPermissions `json:"UserPermissions,omitempty" xml:"UserPermissions,omitempty" type:"Struct"`
}

func (s ListUserPermissionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListUserPermissionsResponseBody) GoString() string {
	return s.String()
}

func (s *ListUserPermissionsResponseBody) SetErrorCode(v string) *ListUserPermissionsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListUserPermissionsResponseBody) SetErrorMessage(v string) *ListUserPermissionsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListUserPermissionsResponseBody) SetRequestId(v string) *ListUserPermissionsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListUserPermissionsResponseBody) SetSuccess(v bool) *ListUserPermissionsResponseBody {
	s.Success = &v
	return s
}

func (s *ListUserPermissionsResponseBody) SetTotalCount(v int64) *ListUserPermissionsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListUserPermissionsResponseBody) SetUserPermissions(v *ListUserPermissionsResponseBodyUserPermissions) *ListUserPermissionsResponseBody {
	s.UserPermissions = v
	return s
}

type ListUserPermissionsResponseBodyUserPermissions struct {
	UserPermission []*ListUserPermissionsResponseBodyUserPermissionsUserPermission `json:"UserPermission,omitempty" xml:"UserPermission,omitempty" type:"Repeated"`
}

func (s ListUserPermissionsResponseBodyUserPermissions) String() string {
	return tea.Prettify(s)
}

func (s ListUserPermissionsResponseBodyUserPermissions) GoString() string {
	return s.String()
}

func (s *ListUserPermissionsResponseBodyUserPermissions) SetUserPermission(v []*ListUserPermissionsResponseBodyUserPermissionsUserPermission) *ListUserPermissionsResponseBodyUserPermissions {
	s.UserPermission = v
	return s
}

type ListUserPermissionsResponseBodyUserPermissionsUserPermission struct {
	// The alias of the instance.
	Alias *string `json:"Alias,omitempty" xml:"Alias,omitempty"`
	// The name of the field.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The ID of the database.
	DbId *string `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The type of the database. For more information about the valid values of this parameter, see [DbType parameter](https://www.alibabacloud.com/help/en/data-management-service/latest/dbtype-parameter).
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The permissions on a specific type of objects that are granted to the user. Valid values:
	//
	// - DATABASE: permissions on physical databases
	// - LOGIC_DATABASE: permissions on logical databases
	// - TABLE: permissions on physical tables
	// - LOGIC_TABLE: permissions on logical tables
	DsType *string `json:"DsType,omitempty" xml:"DsType,omitempty"`
	// The type of the environment to which the database belongs. Valid values:
	//
	// - product: production environment
	// - dev: development environment
	// - pre: staging environment
	// - test: test environment
	// - sit: SIT environment
	// - uat: UAT environment
	// - pet: stress testing environment
	// - stag: STAG environment
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The endpoint that is used to connect the database.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// Indicates whether the database is a logical database. Valid values:
	//
	// *   true: The database is a logical database.
	// *   false: The database is a physical database.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The details of permissions.
	PermDetails *ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails `json:"PermDetails,omitempty" xml:"PermDetails,omitempty" type:"Struct"`
	// The port that is used to connect to the instance.
	Port *int64 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The name of the database.
	SchemaName *string `json:"SchemaName,omitempty" xml:"SchemaName,omitempty"`
	// The name that is used to search for the database.
	SearchName *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
	// The ID of the table.
	TableId *string `json:"TableId,omitempty" xml:"TableId,omitempty"`
	// The name of the table.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	// The ID of the user.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The nickname of the user.
	UserNickName *string `json:"UserNickName,omitempty" xml:"UserNickName,omitempty"`
}

func (s ListUserPermissionsResponseBodyUserPermissionsUserPermission) String() string {
	return tea.Prettify(s)
}

func (s ListUserPermissionsResponseBodyUserPermissionsUserPermission) GoString() string {
	return s.String()
}

func (s *ListUserPermissionsResponseBodyUserPermissionsUserPermission) SetAlias(v string) *ListUserPermissionsResponseBodyUserPermissionsUserPermission {
	s.Alias = &v
	return s
}

func (s *ListUserPermissionsResponseBodyUserPermissionsUserPermission) SetColumnName(v string) *ListUserPermissionsResponseBodyUserPermissionsUserPermission {
	s.ColumnName = &v
	return s
}

func (s *ListUserPermissionsResponseBodyUserPermissionsUserPermission) SetDbId(v string) *ListUserPermissionsResponseBodyUserPermissionsUserPermission {
	s.DbId = &v
	return s
}

func (s *ListUserPermissionsResponseBodyUserPermissionsUserPermission) SetDbType(v string) *ListUserPermissionsResponseBodyUserPermissionsUserPermission {
	s.DbType = &v
	return s
}

func (s *ListUserPermissionsResponseBodyUserPermissionsUserPermission) SetDsType(v string) *ListUserPermissionsResponseBodyUserPermissionsUserPermission {
	s.DsType = &v
	return s
}

func (s *ListUserPermissionsResponseBodyUserPermissionsUserPermission) SetEnvType(v string) *ListUserPermissionsResponseBodyUserPermissionsUserPermission {
	s.EnvType = &v
	return s
}

func (s *ListUserPermissionsResponseBodyUserPermissionsUserPermission) SetHost(v string) *ListUserPermissionsResponseBodyUserPermissionsUserPermission {
	s.Host = &v
	return s
}

func (s *ListUserPermissionsResponseBodyUserPermissionsUserPermission) SetInstanceId(v string) *ListUserPermissionsResponseBodyUserPermissionsUserPermission {
	s.InstanceId = &v
	return s
}

func (s *ListUserPermissionsResponseBodyUserPermissionsUserPermission) SetLogic(v bool) *ListUserPermissionsResponseBodyUserPermissionsUserPermission {
	s.Logic = &v
	return s
}

func (s *ListUserPermissionsResponseBodyUserPermissionsUserPermission) SetPermDetails(v *ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails) *ListUserPermissionsResponseBodyUserPermissionsUserPermission {
	s.PermDetails = v
	return s
}

func (s *ListUserPermissionsResponseBodyUserPermissionsUserPermission) SetPort(v int64) *ListUserPermissionsResponseBodyUserPermissionsUserPermission {
	s.Port = &v
	return s
}

func (s *ListUserPermissionsResponseBodyUserPermissionsUserPermission) SetSchemaName(v string) *ListUserPermissionsResponseBodyUserPermissionsUserPermission {
	s.SchemaName = &v
	return s
}

func (s *ListUserPermissionsResponseBodyUserPermissionsUserPermission) SetSearchName(v string) *ListUserPermissionsResponseBodyUserPermissionsUserPermission {
	s.SearchName = &v
	return s
}

func (s *ListUserPermissionsResponseBodyUserPermissionsUserPermission) SetTableId(v string) *ListUserPermissionsResponseBodyUserPermissionsUserPermission {
	s.TableId = &v
	return s
}

func (s *ListUserPermissionsResponseBodyUserPermissionsUserPermission) SetTableName(v string) *ListUserPermissionsResponseBodyUserPermissionsUserPermission {
	s.TableName = &v
	return s
}

func (s *ListUserPermissionsResponseBodyUserPermissionsUserPermission) SetUserId(v string) *ListUserPermissionsResponseBodyUserPermissionsUserPermission {
	s.UserId = &v
	return s
}

func (s *ListUserPermissionsResponseBodyUserPermissionsUserPermission) SetUserNickName(v string) *ListUserPermissionsResponseBodyUserPermissionsUserPermission {
	s.UserNickName = &v
	return s
}

type ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails struct {
	PermDetail []*ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail `json:"PermDetail,omitempty" xml:"PermDetail,omitempty" type:"Repeated"`
}

func (s ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails) String() string {
	return tea.Prettify(s)
}

func (s ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails) GoString() string {
	return s.String()
}

func (s *ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails) SetPermDetail(v []*ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail) *ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetails {
	s.PermDetail = v
	return s
}

type ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail struct {
	// The time when the permissions were granted.
	CreateDate *string `json:"CreateDate,omitempty" xml:"CreateDate,omitempty"`
	// The time when the permissions expire.
	ExpireDate *string `json:"ExpireDate,omitempty" xml:"ExpireDate,omitempty"`
	// This parameter is reserved.
	ExtraData *string `json:"ExtraData,omitempty" xml:"ExtraData,omitempty"`
	// The user who grants the permissions.
	OriginFrom *string `json:"OriginFrom,omitempty" xml:"OriginFrom,omitempty"`
	// The type of the permissions. Valid values:
	//
	// *   QUERY: the query permissions
	// *   EXPORT: the export permissions
	// *   CORRECT: the change permissions
	PermType *string `json:"PermType,omitempty" xml:"PermType,omitempty"`
	// The ID of the authorization record.
	UserAccessId *string `json:"UserAccessId,omitempty" xml:"UserAccessId,omitempty"`
}

func (s ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail) String() string {
	return tea.Prettify(s)
}

func (s ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail) GoString() string {
	return s.String()
}

func (s *ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail) SetCreateDate(v string) *ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail {
	s.CreateDate = &v
	return s
}

func (s *ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail) SetExpireDate(v string) *ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail {
	s.ExpireDate = &v
	return s
}

func (s *ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail) SetExtraData(v string) *ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail {
	s.ExtraData = &v
	return s
}

func (s *ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail) SetOriginFrom(v string) *ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail {
	s.OriginFrom = &v
	return s
}

func (s *ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail) SetPermType(v string) *ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail {
	s.PermType = &v
	return s
}

func (s *ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail) SetUserAccessId(v string) *ListUserPermissionsResponseBodyUserPermissionsUserPermissionPermDetailsPermDetail {
	s.UserAccessId = &v
	return s
}

type ListUserPermissionsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListUserPermissionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListUserPermissionsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListUserPermissionsResponse) GoString() string {
	return s.String()
}

func (s *ListUserPermissionsResponse) SetHeaders(v map[string]*string) *ListUserPermissionsResponse {
	s.Headers = v
	return s
}

func (s *ListUserPermissionsResponse) SetStatusCode(v int32) *ListUserPermissionsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListUserPermissionsResponse) SetBody(v *ListUserPermissionsResponseBody) *ListUserPermissionsResponse {
	s.Body = v
	return s
}

type ListUserTenantsRequest struct {
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListUserTenantsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListUserTenantsRequest) GoString() string {
	return s.String()
}

func (s *ListUserTenantsRequest) SetTid(v int64) *ListUserTenantsRequest {
	s.Tid = &v
	return s
}

type ListUserTenantsResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**: The request is successful.
	// *   **false**: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The details of the tenants that were returned.
	TenantList []*ListUserTenantsResponseBodyTenantList `json:"TenantList,omitempty" xml:"TenantList,omitempty" type:"Repeated"`
}

func (s ListUserTenantsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListUserTenantsResponseBody) GoString() string {
	return s.String()
}

func (s *ListUserTenantsResponseBody) SetErrorCode(v string) *ListUserTenantsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListUserTenantsResponseBody) SetErrorMessage(v string) *ListUserTenantsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListUserTenantsResponseBody) SetRequestId(v string) *ListUserTenantsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListUserTenantsResponseBody) SetSuccess(v bool) *ListUserTenantsResponseBody {
	s.Success = &v
	return s
}

func (s *ListUserTenantsResponseBody) SetTenantList(v []*ListUserTenantsResponseBodyTenantList) *ListUserTenantsResponseBody {
	s.TenantList = v
	return s
}

type ListUserTenantsResponseBodyTenantList struct {
	// The status of the tenant. Valid values:
	//
	// *   **ACTIVE**: The tenant is used to access DMS.
	// *   **IN_ACTIVE**: The tenant is not used.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The name of the tenant.
	TenantName *string `json:"TenantName,omitempty" xml:"TenantName,omitempty"`
	// The ID of the tenant.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListUserTenantsResponseBodyTenantList) String() string {
	return tea.Prettify(s)
}

func (s ListUserTenantsResponseBodyTenantList) GoString() string {
	return s.String()
}

func (s *ListUserTenantsResponseBodyTenantList) SetStatus(v string) *ListUserTenantsResponseBodyTenantList {
	s.Status = &v
	return s
}

func (s *ListUserTenantsResponseBodyTenantList) SetTenantName(v string) *ListUserTenantsResponseBodyTenantList {
	s.TenantName = &v
	return s
}

func (s *ListUserTenantsResponseBodyTenantList) SetTid(v int64) *ListUserTenantsResponseBodyTenantList {
	s.Tid = &v
	return s
}

type ListUserTenantsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListUserTenantsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListUserTenantsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListUserTenantsResponse) GoString() string {
	return s.String()
}

func (s *ListUserTenantsResponse) SetHeaders(v map[string]*string) *ListUserTenantsResponse {
	s.Headers = v
	return s
}

func (s *ListUserTenantsResponse) SetStatusCode(v int32) *ListUserTenantsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListUserTenantsResponse) SetBody(v *ListUserTenantsResponseBody) *ListUserTenantsResponse {
	s.Body = v
	return s
}

type ListUsersRequest struct {
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	//
	// **
	//
	// Valid values: 10, 20, 50, and 100.**** Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The role that is assigned to the user. Valid values:
	//
	// *   **USER**: a regular user.
	// *   **DBA** : a database administrator (DBA).
	// *   **ADMIN**: a Data Management (DMS) administrator.
	// *   **SECURITY_ADMIN**: a security administrator.
	// *   **STRUCT_READ_ONLY**: a schema read-only user.
	//
	// >  To check your role, move the pointer over the profile picture in the upper-right corner of the DMS console.
	Role *string `json:"Role,omitempty" xml:"Role,omitempty"`
	// The search keyword. Fuzzy match is supported.
	SearchKey *string `json:"SearchKey,omitempty" xml:"SearchKey,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The status of the user. Valid values:
	//
	// *   **NORMAL**: The user is normal.
	// *   **DISABLE**: The user is disabled.
	// *   **DELETE**: The user is deleted.
	UserState *string `json:"UserState,omitempty" xml:"UserState,omitempty"`
}

func (s ListUsersRequest) String() string {
	return tea.Prettify(s)
}

func (s ListUsersRequest) GoString() string {
	return s.String()
}

func (s *ListUsersRequest) SetPageNumber(v int32) *ListUsersRequest {
	s.PageNumber = &v
	return s
}

func (s *ListUsersRequest) SetPageSize(v int32) *ListUsersRequest {
	s.PageSize = &v
	return s
}

func (s *ListUsersRequest) SetRole(v string) *ListUsersRequest {
	s.Role = &v
	return s
}

func (s *ListUsersRequest) SetSearchKey(v string) *ListUsersRequest {
	s.SearchKey = &v
	return s
}

func (s *ListUsersRequest) SetTid(v int64) *ListUsersRequest {
	s.Tid = &v
	return s
}

func (s *ListUsersRequest) SetUserState(v string) *ListUsersRequest {
	s.UserState = &v
	return s
}

type ListUsersResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of entries returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The details of users.
	UserList *ListUsersResponseBodyUserList `json:"UserList,omitempty" xml:"UserList,omitempty" type:"Struct"`
}

func (s ListUsersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListUsersResponseBody) GoString() string {
	return s.String()
}

func (s *ListUsersResponseBody) SetErrorCode(v string) *ListUsersResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListUsersResponseBody) SetErrorMessage(v string) *ListUsersResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListUsersResponseBody) SetRequestId(v string) *ListUsersResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListUsersResponseBody) SetSuccess(v bool) *ListUsersResponseBody {
	s.Success = &v
	return s
}

func (s *ListUsersResponseBody) SetTotalCount(v int64) *ListUsersResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListUsersResponseBody) SetUserList(v *ListUsersResponseBodyUserList) *ListUsersResponseBody {
	s.UserList = v
	return s
}

type ListUsersResponseBodyUserList struct {
	User []*ListUsersResponseBodyUserListUser `json:"User,omitempty" xml:"User,omitempty" type:"Repeated"`
}

func (s ListUsersResponseBodyUserList) String() string {
	return tea.Prettify(s)
}

func (s ListUsersResponseBodyUserList) GoString() string {
	return s.String()
}

func (s *ListUsersResponseBodyUserList) SetUser(v []*ListUsersResponseBodyUserListUser) *ListUsersResponseBodyUserList {
	s.User = v
	return s
}

type ListUsersResponseBodyUserListUser struct {
	// The number of queries that were performed on the current day.
	CurExecuteCount *int64 `json:"CurExecuteCount,omitempty" xml:"CurExecuteCount,omitempty"`
	// The number of rows that were queried on the current day.
	CurResultCount *int64 `json:"CurResultCount,omitempty" xml:"CurResultCount,omitempty"`
	// The DingTalk chatbot URL that is used to receive notifications.
	//
	// >
	//
	// *   The system returns this parameter if you have set a DingTalk chatbot URL in the console. To set a DingTalk chatbot URL in the console, move the pointer over the profile picture in the upper-right corner and click the Edit icon next to **Notice**.
	//
	// *   The system does not return this parameter if you have not set a DingTalk chatbot URL.
	DingRobot *string `json:"DingRobot,omitempty" xml:"DingRobot,omitempty"`
	// The email address that is used to receive notifications.
	//
	// >
	//
	// *   The system returns this parameter if you have set an email address in the console. To set an email address in the console, move the pointer over the profile picture in the upper-right corner and click the Edit icon next to **Notice**.
	//
	// *   The system does not return this parameter if you have not set an email address.
	Email *string `json:"Email,omitempty" xml:"Email,omitempty"`
	// The time when the user last logged on to the console.
	LastLoginTime *string `json:"LastLoginTime,omitempty" xml:"LastLoginTime,omitempty"`
	// The maximum number of queries that can be performed on the current day.
	MaxExecuteCount *int64 `json:"MaxExecuteCount,omitempty" xml:"MaxExecuteCount,omitempty"`
	// The maximum number of rows that can be queried on the current day.
	MaxResultCount *int64 `json:"MaxResultCount,omitempty" xml:"MaxResultCount,omitempty"`
	// The mobile phone number of the user.
	//
	// >
	//
	// *   The system returns this parameter if you have set a mobile phone number in the console. To set a mobile phone number in the console, move the pointer over the profile picture in the upper-right corner and click the Edit icon next to **Notice**.
	//
	// *   The system does not return this parameter if you have not set a mobile phone number.
	Mobile *string `json:"Mobile,omitempty" xml:"Mobile,omitempty"`
	// The nickname of the user.
	NickName *string `json:"NickName,omitempty" xml:"NickName,omitempty"`
	// The notification method. The system returns one or more values. Valid values:
	//
	// *   **SMS**: text message
	// *   **EMAIL**: email.
	// *   **DINGDING**: DingTalk.
	// *   **DINGROBOT**: DingTalk chatbot.
	// *   **WEBHOOK**: webhook.
	NotificationMode *string `json:"NotificationMode,omitempty" xml:"NotificationMode,omitempty"`
	// The ID of the Alibaba Cloud account of the user.
	ParentUid *string `json:"ParentUid,omitempty" xml:"ParentUid,omitempty"`
	// The IDs of the roles.
	RoleIdList *ListUsersResponseBodyUserListUserRoleIdList `json:"RoleIdList,omitempty" xml:"RoleIdList,omitempty" type:"Struct"`
	// The names of roles.
	RoleNameList *ListUsersResponseBodyUserListUserRoleNameList `json:"RoleNameList,omitempty" xml:"RoleNameList,omitempty" type:"Struct"`
	// The signature method that is used to secure connections when a webhook URL is used. Valid values:
	//
	// *   **NONE**: no signature.
	// *   **HMAC_SHA1**: HMAC_SHA1.
	SignatureMethod *string `json:"SignatureMethod,omitempty" xml:"SignatureMethod,omitempty"`
	// The status of the user. Valid values:
	//
	// *   **NORMAL**: The user is normal.
	// *   **DISABLE**: The user is disabled.
	// *   **DELETE**: The user is deleted.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
	// The ID of the Alibaba Cloud account.
	Uid *string `json:"Uid,omitempty" xml:"Uid,omitempty"`
	// The ID of the user.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The webhook URL that is used to receive notifications.
	//
	// >
	//
	// *   If you have set a webhook URL, DMS sends notifications to the specified URL.
	//
	// *   The system does not return this parameter if you have not set a webhook URL.
	Webhook *string `json:"Webhook,omitempty" xml:"Webhook,omitempty"`
}

func (s ListUsersResponseBodyUserListUser) String() string {
	return tea.Prettify(s)
}

func (s ListUsersResponseBodyUserListUser) GoString() string {
	return s.String()
}

func (s *ListUsersResponseBodyUserListUser) SetCurExecuteCount(v int64) *ListUsersResponseBodyUserListUser {
	s.CurExecuteCount = &v
	return s
}

func (s *ListUsersResponseBodyUserListUser) SetCurResultCount(v int64) *ListUsersResponseBodyUserListUser {
	s.CurResultCount = &v
	return s
}

func (s *ListUsersResponseBodyUserListUser) SetDingRobot(v string) *ListUsersResponseBodyUserListUser {
	s.DingRobot = &v
	return s
}

func (s *ListUsersResponseBodyUserListUser) SetEmail(v string) *ListUsersResponseBodyUserListUser {
	s.Email = &v
	return s
}

func (s *ListUsersResponseBodyUserListUser) SetLastLoginTime(v string) *ListUsersResponseBodyUserListUser {
	s.LastLoginTime = &v
	return s
}

func (s *ListUsersResponseBodyUserListUser) SetMaxExecuteCount(v int64) *ListUsersResponseBodyUserListUser {
	s.MaxExecuteCount = &v
	return s
}

func (s *ListUsersResponseBodyUserListUser) SetMaxResultCount(v int64) *ListUsersResponseBodyUserListUser {
	s.MaxResultCount = &v
	return s
}

func (s *ListUsersResponseBodyUserListUser) SetMobile(v string) *ListUsersResponseBodyUserListUser {
	s.Mobile = &v
	return s
}

func (s *ListUsersResponseBodyUserListUser) SetNickName(v string) *ListUsersResponseBodyUserListUser {
	s.NickName = &v
	return s
}

func (s *ListUsersResponseBodyUserListUser) SetNotificationMode(v string) *ListUsersResponseBodyUserListUser {
	s.NotificationMode = &v
	return s
}

func (s *ListUsersResponseBodyUserListUser) SetParentUid(v string) *ListUsersResponseBodyUserListUser {
	s.ParentUid = &v
	return s
}

func (s *ListUsersResponseBodyUserListUser) SetRoleIdList(v *ListUsersResponseBodyUserListUserRoleIdList) *ListUsersResponseBodyUserListUser {
	s.RoleIdList = v
	return s
}

func (s *ListUsersResponseBodyUserListUser) SetRoleNameList(v *ListUsersResponseBodyUserListUserRoleNameList) *ListUsersResponseBodyUserListUser {
	s.RoleNameList = v
	return s
}

func (s *ListUsersResponseBodyUserListUser) SetSignatureMethod(v string) *ListUsersResponseBodyUserListUser {
	s.SignatureMethod = &v
	return s
}

func (s *ListUsersResponseBodyUserListUser) SetState(v string) *ListUsersResponseBodyUserListUser {
	s.State = &v
	return s
}

func (s *ListUsersResponseBodyUserListUser) SetUid(v string) *ListUsersResponseBodyUserListUser {
	s.Uid = &v
	return s
}

func (s *ListUsersResponseBodyUserListUser) SetUserId(v string) *ListUsersResponseBodyUserListUser {
	s.UserId = &v
	return s
}

func (s *ListUsersResponseBodyUserListUser) SetWebhook(v string) *ListUsersResponseBodyUserListUser {
	s.Webhook = &v
	return s
}

type ListUsersResponseBodyUserListUserRoleIdList struct {
	RoleIds []*int32 `json:"RoleIds,omitempty" xml:"RoleIds,omitempty" type:"Repeated"`
}

func (s ListUsersResponseBodyUserListUserRoleIdList) String() string {
	return tea.Prettify(s)
}

func (s ListUsersResponseBodyUserListUserRoleIdList) GoString() string {
	return s.String()
}

func (s *ListUsersResponseBodyUserListUserRoleIdList) SetRoleIds(v []*int32) *ListUsersResponseBodyUserListUserRoleIdList {
	s.RoleIds = v
	return s
}

type ListUsersResponseBodyUserListUserRoleNameList struct {
	RoleNames []*string `json:"RoleNames,omitempty" xml:"RoleNames,omitempty" type:"Repeated"`
}

func (s ListUsersResponseBodyUserListUserRoleNameList) String() string {
	return tea.Prettify(s)
}

func (s ListUsersResponseBodyUserListUserRoleNameList) GoString() string {
	return s.String()
}

func (s *ListUsersResponseBodyUserListUserRoleNameList) SetRoleNames(v []*string) *ListUsersResponseBodyUserListUserRoleNameList {
	s.RoleNames = v
	return s
}

type ListUsersResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListUsersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListUsersResponse) String() string {
	return tea.Prettify(s)
}

func (s ListUsersResponse) GoString() string {
	return s.String()
}

func (s *ListUsersResponse) SetHeaders(v map[string]*string) *ListUsersResponse {
	s.Headers = v
	return s
}

func (s *ListUsersResponse) SetStatusCode(v int32) *ListUsersResponse {
	s.StatusCode = &v
	return s
}

func (s *ListUsersResponse) SetBody(v *ListUsersResponseBody) *ListUsersResponse {
	s.Body = v
	return s
}

type ListWorkFlowNodesRequest struct {
	// The name that is used to search for approval nodes.
	SearchName *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
	// The ID of the tenant.
	//
	// > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListWorkFlowNodesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListWorkFlowNodesRequest) GoString() string {
	return s.String()
}

func (s *ListWorkFlowNodesRequest) SetSearchName(v string) *ListWorkFlowNodesRequest {
	s.SearchName = &v
	return s
}

func (s *ListWorkFlowNodesRequest) SetTid(v int64) *ListWorkFlowNodesRequest {
	s.Tid = &v
	return s
}

type ListWorkFlowNodesResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The details of approval nodes.
	WorkflowNodes *ListWorkFlowNodesResponseBodyWorkflowNodes `json:"WorkflowNodes,omitempty" xml:"WorkflowNodes,omitempty" type:"Struct"`
}

func (s ListWorkFlowNodesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListWorkFlowNodesResponseBody) GoString() string {
	return s.String()
}

func (s *ListWorkFlowNodesResponseBody) SetErrorCode(v string) *ListWorkFlowNodesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListWorkFlowNodesResponseBody) SetErrorMessage(v string) *ListWorkFlowNodesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListWorkFlowNodesResponseBody) SetRequestId(v string) *ListWorkFlowNodesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListWorkFlowNodesResponseBody) SetSuccess(v bool) *ListWorkFlowNodesResponseBody {
	s.Success = &v
	return s
}

func (s *ListWorkFlowNodesResponseBody) SetWorkflowNodes(v *ListWorkFlowNodesResponseBodyWorkflowNodes) *ListWorkFlowNodesResponseBody {
	s.WorkflowNodes = v
	return s
}

type ListWorkFlowNodesResponseBodyWorkflowNodes struct {
	WorkflowNode []*ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode `json:"WorkflowNode,omitempty" xml:"WorkflowNode,omitempty" type:"Repeated"`
}

func (s ListWorkFlowNodesResponseBodyWorkflowNodes) String() string {
	return tea.Prettify(s)
}

func (s ListWorkFlowNodesResponseBodyWorkflowNodes) GoString() string {
	return s.String()
}

func (s *ListWorkFlowNodesResponseBodyWorkflowNodes) SetWorkflowNode(v []*ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode) *ListWorkFlowNodesResponseBodyWorkflowNodes {
	s.WorkflowNode = v
	return s
}

type ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode struct {
	// The details about approvers.
	AuditUsers *ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsers `json:"AuditUsers,omitempty" xml:"AuditUsers,omitempty" type:"Struct"`
	// The description of the approval template.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The ID of the creator. This ID is different from the ID of the Alibaba Cloud account of the creator.
	CreateUserId *int64 `json:"CreateUserId,omitempty" xml:"CreateUserId,omitempty"`
	// The name of the user who creates the approval node.
	CreateUserNickName *string `json:"CreateUserNickName,omitempty" xml:"CreateUserNickName,omitempty"`
	// The ID of the approval node.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The name of the approval node.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The type of the approval node. Valid values:
	//
	// *   SYS: The approval node is predefined by the system.
	// *   USER_LIST: The approval node is created by a user.
	NodeType *string `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
}

func (s ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode) String() string {
	return tea.Prettify(s)
}

func (s ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode) GoString() string {
	return s.String()
}

func (s *ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode) SetAuditUsers(v *ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsers) *ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode {
	s.AuditUsers = v
	return s
}

func (s *ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode) SetComment(v string) *ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode {
	s.Comment = &v
	return s
}

func (s *ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode) SetCreateUserId(v int64) *ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode {
	s.CreateUserId = &v
	return s
}

func (s *ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode) SetCreateUserNickName(v string) *ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode {
	s.CreateUserNickName = &v
	return s
}

func (s *ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode) SetNodeId(v int64) *ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode {
	s.NodeId = &v
	return s
}

func (s *ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode) SetNodeName(v string) *ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode {
	s.NodeName = &v
	return s
}

func (s *ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode) SetNodeType(v string) *ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNode {
	s.NodeType = &v
	return s
}

type ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsers struct {
	AuditUser []*ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser `json:"AuditUser,omitempty" xml:"AuditUser,omitempty" type:"Repeated"`
}

func (s ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsers) String() string {
	return tea.Prettify(s)
}

func (s ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsers) GoString() string {
	return s.String()
}

func (s *ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsers) SetAuditUser(v []*ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser) *ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsers {
	s.AuditUser = v
	return s
}

type ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser struct {
	// The nickname of the approver.
	NickName *string `json:"NickName,omitempty" xml:"NickName,omitempty"`
	// The real name of the approver.
	RealName *string `json:"RealName,omitempty" xml:"RealName,omitempty"`
	// The ID of the approver. The ID is different from the ID of the Alibaba Cloud account of the approver.
	UserId *int64 `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser) String() string {
	return tea.Prettify(s)
}

func (s ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser) GoString() string {
	return s.String()
}

func (s *ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser) SetNickName(v string) *ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser {
	s.NickName = &v
	return s
}

func (s *ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser) SetRealName(v string) *ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser {
	s.RealName = &v
	return s
}

func (s *ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser) SetUserId(v int64) *ListWorkFlowNodesResponseBodyWorkflowNodesWorkflowNodeAuditUsersAuditUser {
	s.UserId = &v
	return s
}

type ListWorkFlowNodesResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListWorkFlowNodesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListWorkFlowNodesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListWorkFlowNodesResponse) GoString() string {
	return s.String()
}

func (s *ListWorkFlowNodesResponse) SetHeaders(v map[string]*string) *ListWorkFlowNodesResponse {
	s.Headers = v
	return s
}

func (s *ListWorkFlowNodesResponse) SetStatusCode(v int32) *ListWorkFlowNodesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListWorkFlowNodesResponse) SetBody(v *ListWorkFlowNodesResponseBody) *ListWorkFlowNodesResponse {
	s.Body = v
	return s
}

type ListWorkFlowTemplatesRequest struct {
	// The name that is used to query approval templates.
	SearchName *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
	// The ID of the tenant.
	//
	// > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ListWorkFlowTemplatesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListWorkFlowTemplatesRequest) GoString() string {
	return s.String()
}

func (s *ListWorkFlowTemplatesRequest) SetSearchName(v string) *ListWorkFlowTemplatesRequest {
	s.SearchName = &v
	return s
}

func (s *ListWorkFlowTemplatesRequest) SetTid(v int64) *ListWorkFlowTemplatesRequest {
	s.Tid = &v
	return s
}

type ListWorkFlowTemplatesResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The approval templates.
	WorkFlowTemplates *ListWorkFlowTemplatesResponseBodyWorkFlowTemplates `json:"WorkFlowTemplates,omitempty" xml:"WorkFlowTemplates,omitempty" type:"Struct"`
}

func (s ListWorkFlowTemplatesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListWorkFlowTemplatesResponseBody) GoString() string {
	return s.String()
}

func (s *ListWorkFlowTemplatesResponseBody) SetErrorCode(v string) *ListWorkFlowTemplatesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListWorkFlowTemplatesResponseBody) SetErrorMessage(v string) *ListWorkFlowTemplatesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListWorkFlowTemplatesResponseBody) SetRequestId(v string) *ListWorkFlowTemplatesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListWorkFlowTemplatesResponseBody) SetSuccess(v bool) *ListWorkFlowTemplatesResponseBody {
	s.Success = &v
	return s
}

func (s *ListWorkFlowTemplatesResponseBody) SetWorkFlowTemplates(v *ListWorkFlowTemplatesResponseBodyWorkFlowTemplates) *ListWorkFlowTemplatesResponseBody {
	s.WorkFlowTemplates = v
	return s
}

type ListWorkFlowTemplatesResponseBodyWorkFlowTemplates struct {
	WorkFlowTemplate []*ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate `json:"WorkFlowTemplate,omitempty" xml:"WorkFlowTemplate,omitempty" type:"Repeated"`
}

func (s ListWorkFlowTemplatesResponseBodyWorkFlowTemplates) String() string {
	return tea.Prettify(s)
}

func (s ListWorkFlowTemplatesResponseBodyWorkFlowTemplates) GoString() string {
	return s.String()
}

func (s *ListWorkFlowTemplatesResponseBodyWorkFlowTemplates) SetWorkFlowTemplate(v []*ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate) *ListWorkFlowTemplatesResponseBodyWorkFlowTemplates {
	s.WorkFlowTemplate = v
	return s
}

type ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate struct {
	// The description of the approval template.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The ID of the creator.
	CreateUserId *int64 `json:"CreateUserId,omitempty" xml:"CreateUserId,omitempty"`
	// Indicates whether the approval template is enabled. Valid values:
	//
	// *   Y: The approval template is enabled.
	// *   N: The approval template is disabled.
	Enabled *string `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	// Indicates whether the approval template is predefined by the system. Valid values:
	//
	// *   1: The approval template is predefined by the system.
	// *   0: The approval template is not predefined by the system.
	IsSystem *int32 `json:"IsSystem,omitempty" xml:"IsSystem,omitempty"`
	// The ID of the approval template.
	TemplateId *int64 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The name of the approval template.
	TemplateName *string `json:"TemplateName,omitempty" xml:"TemplateName,omitempty"`
	// The details of approval nodes.
	WorkflowNodes *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodes `json:"WorkflowNodes,omitempty" xml:"WorkflowNodes,omitempty" type:"Struct"`
}

func (s ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate) String() string {
	return tea.Prettify(s)
}

func (s ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate) GoString() string {
	return s.String()
}

func (s *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate) SetComment(v string) *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate {
	s.Comment = &v
	return s
}

func (s *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate) SetCreateUserId(v int64) *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate {
	s.CreateUserId = &v
	return s
}

func (s *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate) SetEnabled(v string) *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate {
	s.Enabled = &v
	return s
}

func (s *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate) SetIsSystem(v int32) *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate {
	s.IsSystem = &v
	return s
}

func (s *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate) SetTemplateId(v int64) *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate {
	s.TemplateId = &v
	return s
}

func (s *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate) SetTemplateName(v string) *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate {
	s.TemplateName = &v
	return s
}

func (s *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate) SetWorkflowNodes(v *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodes) *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplate {
	s.WorkflowNodes = v
	return s
}

type ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodes struct {
	WorkflowNode []*ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode `json:"WorkflowNode,omitempty" xml:"WorkflowNode,omitempty" type:"Repeated"`
}

func (s ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodes) String() string {
	return tea.Prettify(s)
}

func (s ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodes) GoString() string {
	return s.String()
}

func (s *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodes) SetWorkflowNode(v []*ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode) *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodes {
	s.WorkflowNode = v
	return s
}

type ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode struct {
	// The description of the approval node.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The ID of the creator.
	CreateUserId *int64 `json:"CreateUserId,omitempty" xml:"CreateUserId,omitempty"`
	// The ID of the approval node.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The name of the approval node.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The type of the approval node. Valid values:
	//
	// *   SYS: The approval node is predefined by the system.
	// *   USER_LIST: The approval node is created by a user.
	NodeType *string `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
	// The position of the approval node.
	Position *int32 `json:"Position,omitempty" xml:"Position,omitempty"`
	// The ID of the template.
	TemplateId *int64 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
}

func (s ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode) String() string {
	return tea.Prettify(s)
}

func (s ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode) GoString() string {
	return s.String()
}

func (s *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode) SetComment(v string) *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode {
	s.Comment = &v
	return s
}

func (s *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode) SetCreateUserId(v int64) *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode {
	s.CreateUserId = &v
	return s
}

func (s *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode) SetNodeId(v int64) *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode {
	s.NodeId = &v
	return s
}

func (s *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode) SetNodeName(v string) *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode {
	s.NodeName = &v
	return s
}

func (s *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode) SetNodeType(v string) *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode {
	s.NodeType = &v
	return s
}

func (s *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode) SetPosition(v int32) *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode {
	s.Position = &v
	return s
}

func (s *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode) SetTemplateId(v int64) *ListWorkFlowTemplatesResponseBodyWorkFlowTemplatesWorkFlowTemplateWorkflowNodesWorkflowNode {
	s.TemplateId = &v
	return s
}

type ListWorkFlowTemplatesResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListWorkFlowTemplatesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListWorkFlowTemplatesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListWorkFlowTemplatesResponse) GoString() string {
	return s.String()
}

func (s *ListWorkFlowTemplatesResponse) SetHeaders(v map[string]*string) *ListWorkFlowTemplatesResponse {
	s.Headers = v
	return s
}

func (s *ListWorkFlowTemplatesResponse) SetStatusCode(v int32) *ListWorkFlowTemplatesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListWorkFlowTemplatesResponse) SetBody(v *ListWorkFlowTemplatesResponseBody) *ListWorkFlowTemplatesResponse {
	s.Body = v
	return s
}

type MakeTaskFlowInstanceSuccessRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the execution record of the task flow. You can call the [ListTaskFlowInstance](~~424689~~) operation to query the execution record ID.
	DagInstanceId *int64 `json:"DagInstanceId,omitempty" xml:"DagInstanceId,omitempty"`
	// The ID of the tenant.
	//
	// > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s MakeTaskFlowInstanceSuccessRequest) String() string {
	return tea.Prettify(s)
}

func (s MakeTaskFlowInstanceSuccessRequest) GoString() string {
	return s.String()
}

func (s *MakeTaskFlowInstanceSuccessRequest) SetDagId(v int64) *MakeTaskFlowInstanceSuccessRequest {
	s.DagId = &v
	return s
}

func (s *MakeTaskFlowInstanceSuccessRequest) SetDagInstanceId(v int64) *MakeTaskFlowInstanceSuccessRequest {
	s.DagInstanceId = &v
	return s
}

func (s *MakeTaskFlowInstanceSuccessRequest) SetTid(v int64) *MakeTaskFlowInstanceSuccessRequest {
	s.Tid = &v
	return s
}

type MakeTaskFlowInstanceSuccessResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s MakeTaskFlowInstanceSuccessResponseBody) String() string {
	return tea.Prettify(s)
}

func (s MakeTaskFlowInstanceSuccessResponseBody) GoString() string {
	return s.String()
}

func (s *MakeTaskFlowInstanceSuccessResponseBody) SetErrorCode(v string) *MakeTaskFlowInstanceSuccessResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *MakeTaskFlowInstanceSuccessResponseBody) SetErrorMessage(v string) *MakeTaskFlowInstanceSuccessResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *MakeTaskFlowInstanceSuccessResponseBody) SetRequestId(v string) *MakeTaskFlowInstanceSuccessResponseBody {
	s.RequestId = &v
	return s
}

func (s *MakeTaskFlowInstanceSuccessResponseBody) SetSuccess(v bool) *MakeTaskFlowInstanceSuccessResponseBody {
	s.Success = &v
	return s
}

type MakeTaskFlowInstanceSuccessResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *MakeTaskFlowInstanceSuccessResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s MakeTaskFlowInstanceSuccessResponse) String() string {
	return tea.Prettify(s)
}

func (s MakeTaskFlowInstanceSuccessResponse) GoString() string {
	return s.String()
}

func (s *MakeTaskFlowInstanceSuccessResponse) SetHeaders(v map[string]*string) *MakeTaskFlowInstanceSuccessResponse {
	s.Headers = v
	return s
}

func (s *MakeTaskFlowInstanceSuccessResponse) SetStatusCode(v int32) *MakeTaskFlowInstanceSuccessResponse {
	s.StatusCode = &v
	return s
}

func (s *MakeTaskFlowInstanceSuccessResponse) SetBody(v *MakeTaskFlowInstanceSuccessResponseBody) *MakeTaskFlowInstanceSuccessResponse {
	s.Body = v
	return s
}

type ModifyDataCorrectExecSQLRequest struct {
	// The new SQL script.
	ExecSQL *string `json:"ExecSQL,omitempty" xml:"ExecSQL,omitempty"`
	// The ID of the data change ticket.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ModifyDataCorrectExecSQLRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDataCorrectExecSQLRequest) GoString() string {
	return s.String()
}

func (s *ModifyDataCorrectExecSQLRequest) SetExecSQL(v string) *ModifyDataCorrectExecSQLRequest {
	s.ExecSQL = &v
	return s
}

func (s *ModifyDataCorrectExecSQLRequest) SetOrderId(v int64) *ModifyDataCorrectExecSQLRequest {
	s.OrderId = &v
	return s
}

func (s *ModifyDataCorrectExecSQLRequest) SetTid(v int64) *ModifyDataCorrectExecSQLRequest {
	s.Tid = &v
	return s
}

type ModifyDataCorrectExecSQLResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ModifyDataCorrectExecSQLResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDataCorrectExecSQLResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDataCorrectExecSQLResponseBody) SetErrorCode(v string) *ModifyDataCorrectExecSQLResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ModifyDataCorrectExecSQLResponseBody) SetErrorMessage(v string) *ModifyDataCorrectExecSQLResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ModifyDataCorrectExecSQLResponseBody) SetRequestId(v string) *ModifyDataCorrectExecSQLResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyDataCorrectExecSQLResponseBody) SetSuccess(v bool) *ModifyDataCorrectExecSQLResponseBody {
	s.Success = &v
	return s
}

type ModifyDataCorrectExecSQLResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDataCorrectExecSQLResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDataCorrectExecSQLResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDataCorrectExecSQLResponse) GoString() string {
	return s.String()
}

func (s *ModifyDataCorrectExecSQLResponse) SetHeaders(v map[string]*string) *ModifyDataCorrectExecSQLResponse {
	s.Headers = v
	return s
}

func (s *ModifyDataCorrectExecSQLResponse) SetStatusCode(v int32) *ModifyDataCorrectExecSQLResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDataCorrectExecSQLResponse) SetBody(v *ModifyDataCorrectExecSQLResponseBody) *ModifyDataCorrectExecSQLResponse {
	s.Body = v
	return s
}

type ModifyDesensitizationStrategyRequest struct {
	// The name of the field. You can call the [ListSensitiveColumns](~~188103~~) operation to obtain the field name.
	//
	// >  You can also call the [ListColumns](~~141870~~) operation to obtain the field name.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The ID of the database. You can call the [ListDatabases](~~141873~~) operation to obtain the ID.
	DbId *int32 `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The desensitization algorithm of the field setting. The default value is false. The values are as follows:
	//
	// - **true**: default desensitization algorithm.
	//
	// - **false** :semi-desensitization algorithm.
	IsDefault *bool `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	// Specifies whether the database is a logical database. Valid values:
	//
	// *   **true**: The database is a physical database.
	// *   **false**: The database is a logical database.
	IsLogic *bool `json:"IsLogic,omitempty" xml:"IsLogic,omitempty"`
	// Specifies whether to reset the masking rule. Valid value:
	//
	// *   **true**: Reset the masking rule.
	// *   **false**: Do not reset the masking rule. This is the default value.
	IsReset *bool `json:"IsReset,omitempty" xml:"IsReset,omitempty"`
	// The ID of the masking rule.
	RuleId *int32 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	// The name of the database. You can call the [ListSensitiveColumns](~~188103~~) operation to obtain the database name.
	//
	// >
	//
	// *   If the database is a physical database, you can call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation to obtain the database name.
	//
	// *   If the database is a logical database, you can call the [ListLogicDatabases](~~141874~~) or [SearchDatabase](~~141876~~) operation to obtain the name of the database.
	SchemaName *string `json:"SchemaName,omitempty" xml:"SchemaName,omitempty"`
	// The name of the table. You can call the [ListSensitiveColumns](~~188103~~) operation to obtain the table name.
	//
	// >  You can also call the [ListTables](~~141878~~) operation to obtain the table name.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	// The ID of the tenant.
	//
	// >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~) in the topic "Manage DMS tenants."
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ModifyDesensitizationStrategyRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesensitizationStrategyRequest) GoString() string {
	return s.String()
}

func (s *ModifyDesensitizationStrategyRequest) SetColumnName(v string) *ModifyDesensitizationStrategyRequest {
	s.ColumnName = &v
	return s
}

func (s *ModifyDesensitizationStrategyRequest) SetDbId(v int32) *ModifyDesensitizationStrategyRequest {
	s.DbId = &v
	return s
}

func (s *ModifyDesensitizationStrategyRequest) SetIsDefault(v bool) *ModifyDesensitizationStrategyRequest {
	s.IsDefault = &v
	return s
}

func (s *ModifyDesensitizationStrategyRequest) SetIsLogic(v bool) *ModifyDesensitizationStrategyRequest {
	s.IsLogic = &v
	return s
}

func (s *ModifyDesensitizationStrategyRequest) SetIsReset(v bool) *ModifyDesensitizationStrategyRequest {
	s.IsReset = &v
	return s
}

func (s *ModifyDesensitizationStrategyRequest) SetRuleId(v int32) *ModifyDesensitizationStrategyRequest {
	s.RuleId = &v
	return s
}

func (s *ModifyDesensitizationStrategyRequest) SetSchemaName(v string) *ModifyDesensitizationStrategyRequest {
	s.SchemaName = &v
	return s
}

func (s *ModifyDesensitizationStrategyRequest) SetTableName(v string) *ModifyDesensitizationStrategyRequest {
	s.TableName = &v
	return s
}

func (s *ModifyDesensitizationStrategyRequest) SetTid(v int64) *ModifyDesensitizationStrategyRequest {
	s.Tid = &v
	return s
}

type ModifyDesensitizationStrategyResponseBody struct {
	// The status code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result.
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ModifyDesensitizationStrategyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesensitizationStrategyResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDesensitizationStrategyResponseBody) SetErrorCode(v string) *ModifyDesensitizationStrategyResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ModifyDesensitizationStrategyResponseBody) SetErrorMessage(v string) *ModifyDesensitizationStrategyResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ModifyDesensitizationStrategyResponseBody) SetRequestId(v string) *ModifyDesensitizationStrategyResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyDesensitizationStrategyResponseBody) SetResult(v bool) *ModifyDesensitizationStrategyResponseBody {
	s.Result = &v
	return s
}

func (s *ModifyDesensitizationStrategyResponseBody) SetSuccess(v bool) *ModifyDesensitizationStrategyResponseBody {
	s.Success = &v
	return s
}

type ModifyDesensitizationStrategyResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyDesensitizationStrategyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyDesensitizationStrategyResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDesensitizationStrategyResponse) GoString() string {
	return s.String()
}

func (s *ModifyDesensitizationStrategyResponse) SetHeaders(v map[string]*string) *ModifyDesensitizationStrategyResponse {
	s.Headers = v
	return s
}

func (s *ModifyDesensitizationStrategyResponse) SetStatusCode(v int32) *ModifyDesensitizationStrategyResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDesensitizationStrategyResponse) SetBody(v *ModifyDesensitizationStrategyResponseBody) *ModifyDesensitizationStrategyResponse {
	s.Body = v
	return s
}

type ModifyInstanceRequest struct {
	DataLinkName     *string `json:"DataLinkName,omitempty" xml:"DataLinkName,omitempty"`
	DatabasePassword *string `json:"DatabasePassword,omitempty" xml:"DatabasePassword,omitempty"`
	DatabaseUser     *string `json:"DatabaseUser,omitempty" xml:"DatabaseUser,omitempty"`
	DbaId            *int64  `json:"DbaId,omitempty" xml:"DbaId,omitempty"`
	DdlOnline        *int32  `json:"DdlOnline,omitempty" xml:"DdlOnline,omitempty"`
	EcsInstanceId    *string `json:"EcsInstanceId,omitempty" xml:"EcsInstanceId,omitempty"`
	EcsRegion        *string `json:"EcsRegion,omitempty" xml:"EcsRegion,omitempty"`
	EnableSellCommon *string `json:"EnableSellCommon,omitempty" xml:"EnableSellCommon,omitempty"`
	EnableSellSitd   *string `json:"EnableSellSitd,omitempty" xml:"EnableSellSitd,omitempty"`
	EnableSellStable *string `json:"EnableSellStable,omitempty" xml:"EnableSellStable,omitempty"`
	EnableSellTrust  *string `json:"EnableSellTrust,omitempty" xml:"EnableSellTrust,omitempty"`
	EnvType          *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	ExportTimeout    *int32  `json:"ExportTimeout,omitempty" xml:"ExportTimeout,omitempty"`
	Host             *string `json:"Host,omitempty" xml:"Host,omitempty"`
	InstanceAlias    *string `json:"InstanceAlias,omitempty" xml:"InstanceAlias,omitempty"`
	InstanceId       *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	InstanceSource   *string `json:"InstanceSource,omitempty" xml:"InstanceSource,omitempty"`
	InstanceType     *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	NetworkType      *string `json:"NetworkType,omitempty" xml:"NetworkType,omitempty"`
	Port             *int32  `json:"Port,omitempty" xml:"Port,omitempty"`
	QueryTimeout     *int32  `json:"QueryTimeout,omitempty" xml:"QueryTimeout,omitempty"`
	SafeRule         *string `json:"SafeRule,omitempty" xml:"SafeRule,omitempty"`
	Sid              *string `json:"Sid,omitempty" xml:"Sid,omitempty"`
	SkipTest         *bool   `json:"SkipTest,omitempty" xml:"SkipTest,omitempty"`
	TemplateId       *int64  `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	TemplateType     *string `json:"TemplateType,omitempty" xml:"TemplateType,omitempty"`
	Tid              *int64  `json:"Tid,omitempty" xml:"Tid,omitempty"`
	UseDsql          *int32  `json:"UseDsql,omitempty" xml:"UseDsql,omitempty"`
	VpcId            *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s ModifyInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyInstanceRequest) GoString() string {
	return s.String()
}

func (s *ModifyInstanceRequest) SetDataLinkName(v string) *ModifyInstanceRequest {
	s.DataLinkName = &v
	return s
}

func (s *ModifyInstanceRequest) SetDatabasePassword(v string) *ModifyInstanceRequest {
	s.DatabasePassword = &v
	return s
}

func (s *ModifyInstanceRequest) SetDatabaseUser(v string) *ModifyInstanceRequest {
	s.DatabaseUser = &v
	return s
}

func (s *ModifyInstanceRequest) SetDbaId(v int64) *ModifyInstanceRequest {
	s.DbaId = &v
	return s
}

func (s *ModifyInstanceRequest) SetDdlOnline(v int32) *ModifyInstanceRequest {
	s.DdlOnline = &v
	return s
}

func (s *ModifyInstanceRequest) SetEcsInstanceId(v string) *ModifyInstanceRequest {
	s.EcsInstanceId = &v
	return s
}

func (s *ModifyInstanceRequest) SetEcsRegion(v string) *ModifyInstanceRequest {
	s.EcsRegion = &v
	return s
}

func (s *ModifyInstanceRequest) SetEnableSellCommon(v string) *ModifyInstanceRequest {
	s.EnableSellCommon = &v
	return s
}

func (s *ModifyInstanceRequest) SetEnableSellSitd(v string) *ModifyInstanceRequest {
	s.EnableSellSitd = &v
	return s
}

func (s *ModifyInstanceRequest) SetEnableSellStable(v string) *ModifyInstanceRequest {
	s.EnableSellStable = &v
	return s
}

func (s *ModifyInstanceRequest) SetEnableSellTrust(v string) *ModifyInstanceRequest {
	s.EnableSellTrust = &v
	return s
}

func (s *ModifyInstanceRequest) SetEnvType(v string) *ModifyInstanceRequest {
	s.EnvType = &v
	return s
}

func (s *ModifyInstanceRequest) SetExportTimeout(v int32) *ModifyInstanceRequest {
	s.ExportTimeout = &v
	return s
}

func (s *ModifyInstanceRequest) SetHost(v string) *ModifyInstanceRequest {
	s.Host = &v
	return s
}

func (s *ModifyInstanceRequest) SetInstanceAlias(v string) *ModifyInstanceRequest {
	s.InstanceAlias = &v
	return s
}

func (s *ModifyInstanceRequest) SetInstanceId(v string) *ModifyInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *ModifyInstanceRequest) SetInstanceSource(v string) *ModifyInstanceRequest {
	s.InstanceSource = &v
	return s
}

func (s *ModifyInstanceRequest) SetInstanceType(v string) *ModifyInstanceRequest {
	s.InstanceType = &v
	return s
}

func (s *ModifyInstanceRequest) SetNetworkType(v string) *ModifyInstanceRequest {
	s.NetworkType = &v
	return s
}

func (s *ModifyInstanceRequest) SetPort(v int32) *ModifyInstanceRequest {
	s.Port = &v
	return s
}

func (s *ModifyInstanceRequest) SetQueryTimeout(v int32) *ModifyInstanceRequest {
	s.QueryTimeout = &v
	return s
}

func (s *ModifyInstanceRequest) SetSafeRule(v string) *ModifyInstanceRequest {
	s.SafeRule = &v
	return s
}

func (s *ModifyInstanceRequest) SetSid(v string) *ModifyInstanceRequest {
	s.Sid = &v
	return s
}

func (s *ModifyInstanceRequest) SetSkipTest(v bool) *ModifyInstanceRequest {
	s.SkipTest = &v
	return s
}

func (s *ModifyInstanceRequest) SetTemplateId(v int64) *ModifyInstanceRequest {
	s.TemplateId = &v
	return s
}

func (s *ModifyInstanceRequest) SetTemplateType(v string) *ModifyInstanceRequest {
	s.TemplateType = &v
	return s
}

func (s *ModifyInstanceRequest) SetTid(v int64) *ModifyInstanceRequest {
	s.Tid = &v
	return s
}

func (s *ModifyInstanceRequest) SetUseDsql(v int32) *ModifyInstanceRequest {
	s.UseDsql = &v
	return s
}

func (s *ModifyInstanceRequest) SetVpcId(v string) *ModifyInstanceRequest {
	s.VpcId = &v
	return s
}

type ModifyInstanceResponseBody struct {
	ErrorCode    *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ModifyInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyInstanceResponseBody) SetErrorCode(v string) *ModifyInstanceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ModifyInstanceResponseBody) SetErrorMessage(v string) *ModifyInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ModifyInstanceResponseBody) SetRequestId(v string) *ModifyInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyInstanceResponseBody) SetSuccess(v bool) *ModifyInstanceResponseBody {
	s.Success = &v
	return s
}

type ModifyInstanceResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyInstanceResponse) GoString() string {
	return s.String()
}

func (s *ModifyInstanceResponse) SetHeaders(v map[string]*string) *ModifyInstanceResponse {
	s.Headers = v
	return s
}

func (s *ModifyInstanceResponse) SetStatusCode(v int32) *ModifyInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyInstanceResponse) SetBody(v *ModifyInstanceResponseBody) *ModifyInstanceResponse {
	s.Body = v
	return s
}

type MoveTaskFlowToScenarioRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the business scenario to which you want to migrate your task flow. If this parameter is set to the default value or a value that is less than or equal to 0, the task flow is migrated to the default business scenario.
	ScenarioId *int64 `json:"ScenarioId,omitempty" xml:"ScenarioId,omitempty"`
	// The ID of the tenant.
	//
	// > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s MoveTaskFlowToScenarioRequest) String() string {
	return tea.Prettify(s)
}

func (s MoveTaskFlowToScenarioRequest) GoString() string {
	return s.String()
}

func (s *MoveTaskFlowToScenarioRequest) SetDagId(v int64) *MoveTaskFlowToScenarioRequest {
	s.DagId = &v
	return s
}

func (s *MoveTaskFlowToScenarioRequest) SetScenarioId(v int64) *MoveTaskFlowToScenarioRequest {
	s.ScenarioId = &v
	return s
}

func (s *MoveTaskFlowToScenarioRequest) SetTid(v int64) *MoveTaskFlowToScenarioRequest {
	s.Tid = &v
	return s
}

type MoveTaskFlowToScenarioResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s MoveTaskFlowToScenarioResponseBody) String() string {
	return tea.Prettify(s)
}

func (s MoveTaskFlowToScenarioResponseBody) GoString() string {
	return s.String()
}

func (s *MoveTaskFlowToScenarioResponseBody) SetErrorCode(v string) *MoveTaskFlowToScenarioResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *MoveTaskFlowToScenarioResponseBody) SetErrorMessage(v string) *MoveTaskFlowToScenarioResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *MoveTaskFlowToScenarioResponseBody) SetRequestId(v string) *MoveTaskFlowToScenarioResponseBody {
	s.RequestId = &v
	return s
}

func (s *MoveTaskFlowToScenarioResponseBody) SetSuccess(v bool) *MoveTaskFlowToScenarioResponseBody {
	s.Success = &v
	return s
}

type MoveTaskFlowToScenarioResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *MoveTaskFlowToScenarioResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s MoveTaskFlowToScenarioResponse) String() string {
	return tea.Prettify(s)
}

func (s MoveTaskFlowToScenarioResponse) GoString() string {
	return s.String()
}

func (s *MoveTaskFlowToScenarioResponse) SetHeaders(v map[string]*string) *MoveTaskFlowToScenarioResponse {
	s.Headers = v
	return s
}

func (s *MoveTaskFlowToScenarioResponse) SetStatusCode(v int32) *MoveTaskFlowToScenarioResponse {
	s.StatusCode = &v
	return s
}

func (s *MoveTaskFlowToScenarioResponse) SetBody(v *MoveTaskFlowToScenarioResponseBody) *MoveTaskFlowToScenarioResponse {
	s.Body = v
	return s
}

type OfflineTaskFlowRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s OfflineTaskFlowRequest) String() string {
	return tea.Prettify(s)
}

func (s OfflineTaskFlowRequest) GoString() string {
	return s.String()
}

func (s *OfflineTaskFlowRequest) SetDagId(v int64) *OfflineTaskFlowRequest {
	s.DagId = &v
	return s
}

func (s *OfflineTaskFlowRequest) SetTid(v int64) *OfflineTaskFlowRequest {
	s.Tid = &v
	return s
}

type OfflineTaskFlowResponseBody struct {
	// The error code returned if the request fails.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**: The request is successful.
	// *   **false**: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s OfflineTaskFlowResponseBody) String() string {
	return tea.Prettify(s)
}

func (s OfflineTaskFlowResponseBody) GoString() string {
	return s.String()
}

func (s *OfflineTaskFlowResponseBody) SetErrorCode(v string) *OfflineTaskFlowResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *OfflineTaskFlowResponseBody) SetErrorMessage(v string) *OfflineTaskFlowResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *OfflineTaskFlowResponseBody) SetRequestId(v string) *OfflineTaskFlowResponseBody {
	s.RequestId = &v
	return s
}

func (s *OfflineTaskFlowResponseBody) SetSuccess(v bool) *OfflineTaskFlowResponseBody {
	s.Success = &v
	return s
}

type OfflineTaskFlowResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *OfflineTaskFlowResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s OfflineTaskFlowResponse) String() string {
	return tea.Prettify(s)
}

func (s OfflineTaskFlowResponse) GoString() string {
	return s.String()
}

func (s *OfflineTaskFlowResponse) SetHeaders(v map[string]*string) *OfflineTaskFlowResponse {
	s.Headers = v
	return s
}

func (s *OfflineTaskFlowResponse) SetStatusCode(v int32) *OfflineTaskFlowResponse {
	s.StatusCode = &v
	return s
}

func (s *OfflineTaskFlowResponse) SetBody(v *OfflineTaskFlowResponseBody) *OfflineTaskFlowResponse {
	s.Body = v
	return s
}

type PauseDataCorrectSQLJobRequest struct {
	// The ID of the SQL task. You can call the [GetDataCorrectTaskDetail](~~208481~~) and [ListDBTaskSQLJob](~~207049~~) operations to obtain the value of this parameter.
	//
	// >  If the Type parameter is set to SINGLE, you must pass the value of the JobId parameter to confirm the ID of the SQL task that you want to rerun.
	JobId *int64 `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The ID of the data change ticket. You can call the [ListOrders](~~144643~~) operation to query the ID of the data change ticket.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The type of the pause operation. Valid values:
	//
	// *   ALL: pauses all SQL tasks.
	// *   SINGLE: pauses a single SQL task.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s PauseDataCorrectSQLJobRequest) String() string {
	return tea.Prettify(s)
}

func (s PauseDataCorrectSQLJobRequest) GoString() string {
	return s.String()
}

func (s *PauseDataCorrectSQLJobRequest) SetJobId(v int64) *PauseDataCorrectSQLJobRequest {
	s.JobId = &v
	return s
}

func (s *PauseDataCorrectSQLJobRequest) SetOrderId(v int64) *PauseDataCorrectSQLJobRequest {
	s.OrderId = &v
	return s
}

func (s *PauseDataCorrectSQLJobRequest) SetTid(v int64) *PauseDataCorrectSQLJobRequest {
	s.Tid = &v
	return s
}

func (s *PauseDataCorrectSQLJobRequest) SetType(v string) *PauseDataCorrectSQLJobRequest {
	s.Type = &v
	return s
}

type PauseDataCorrectSQLJobResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**: The request is successful.
	// *   **false**: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s PauseDataCorrectSQLJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PauseDataCorrectSQLJobResponseBody) GoString() string {
	return s.String()
}

func (s *PauseDataCorrectSQLJobResponseBody) SetErrorCode(v string) *PauseDataCorrectSQLJobResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *PauseDataCorrectSQLJobResponseBody) SetErrorMessage(v string) *PauseDataCorrectSQLJobResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *PauseDataCorrectSQLJobResponseBody) SetRequestId(v string) *PauseDataCorrectSQLJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *PauseDataCorrectSQLJobResponseBody) SetSuccess(v bool) *PauseDataCorrectSQLJobResponseBody {
	s.Success = &v
	return s
}

type PauseDataCorrectSQLJobResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PauseDataCorrectSQLJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PauseDataCorrectSQLJobResponse) String() string {
	return tea.Prettify(s)
}

func (s PauseDataCorrectSQLJobResponse) GoString() string {
	return s.String()
}

func (s *PauseDataCorrectSQLJobResponse) SetHeaders(v map[string]*string) *PauseDataCorrectSQLJobResponse {
	s.Headers = v
	return s
}

func (s *PauseDataCorrectSQLJobResponse) SetStatusCode(v int32) *PauseDataCorrectSQLJobResponse {
	s.StatusCode = &v
	return s
}

func (s *PauseDataCorrectSQLJobResponse) SetBody(v *PauseDataCorrectSQLJobResponseBody) *PauseDataCorrectSQLJobResponse {
	s.Body = v
	return s
}

type PreviewWorkflowRequest struct {
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	Tid     *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s PreviewWorkflowRequest) String() string {
	return tea.Prettify(s)
}

func (s PreviewWorkflowRequest) GoString() string {
	return s.String()
}

func (s *PreviewWorkflowRequest) SetOrderId(v int64) *PreviewWorkflowRequest {
	s.OrderId = &v
	return s
}

func (s *PreviewWorkflowRequest) SetTid(v int64) *PreviewWorkflowRequest {
	s.Tid = &v
	return s
}

type PreviewWorkflowResponseBody struct {
	ErrorCode      *string                                    `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string                                    `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId      *string                                    `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool                                      `json:"Success,omitempty" xml:"Success,omitempty"`
	WorkflowDetail *PreviewWorkflowResponseBodyWorkflowDetail `json:"WorkflowDetail,omitempty" xml:"WorkflowDetail,omitempty" type:"Struct"`
}

func (s PreviewWorkflowResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PreviewWorkflowResponseBody) GoString() string {
	return s.String()
}

func (s *PreviewWorkflowResponseBody) SetErrorCode(v string) *PreviewWorkflowResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *PreviewWorkflowResponseBody) SetErrorMessage(v string) *PreviewWorkflowResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *PreviewWorkflowResponseBody) SetRequestId(v string) *PreviewWorkflowResponseBody {
	s.RequestId = &v
	return s
}

func (s *PreviewWorkflowResponseBody) SetSuccess(v bool) *PreviewWorkflowResponseBody {
	s.Success = &v
	return s
}

func (s *PreviewWorkflowResponseBody) SetWorkflowDetail(v *PreviewWorkflowResponseBodyWorkflowDetail) *PreviewWorkflowResponseBody {
	s.WorkflowDetail = v
	return s
}

type PreviewWorkflowResponseBodyWorkflowDetail struct {
	Comment          *string                                                    `json:"Comment,omitempty" xml:"Comment,omitempty"`
	WfCateName       *string                                                    `json:"WfCateName,omitempty" xml:"WfCateName,omitempty"`
	WorkflowNodeList *PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeList `json:"WorkflowNodeList,omitempty" xml:"WorkflowNodeList,omitempty" type:"Struct"`
}

func (s PreviewWorkflowResponseBodyWorkflowDetail) String() string {
	return tea.Prettify(s)
}

func (s PreviewWorkflowResponseBodyWorkflowDetail) GoString() string {
	return s.String()
}

func (s *PreviewWorkflowResponseBodyWorkflowDetail) SetComment(v string) *PreviewWorkflowResponseBodyWorkflowDetail {
	s.Comment = &v
	return s
}

func (s *PreviewWorkflowResponseBodyWorkflowDetail) SetWfCateName(v string) *PreviewWorkflowResponseBodyWorkflowDetail {
	s.WfCateName = &v
	return s
}

func (s *PreviewWorkflowResponseBodyWorkflowDetail) SetWorkflowNodeList(v *PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeList) *PreviewWorkflowResponseBodyWorkflowDetail {
	s.WorkflowNodeList = v
	return s
}

type PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeList struct {
	WorkflowNode []*PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNode `json:"WorkflowNode,omitempty" xml:"WorkflowNode,omitempty" type:"Repeated"`
}

func (s PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeList) String() string {
	return tea.Prettify(s)
}

func (s PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeList) GoString() string {
	return s.String()
}

func (s *PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeList) SetWorkflowNode(v []*PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNode) *PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeList {
	s.WorkflowNode = v
	return s
}

type PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNode struct {
	AuditUserList *PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserList `json:"AuditUserList,omitempty" xml:"AuditUserList,omitempty" type:"Struct"`
	Comment       *string                                                                             `json:"Comment,omitempty" xml:"Comment,omitempty"`
	NodeName      *string                                                                             `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	NodeType      *string                                                                             `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
}

func (s PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNode) String() string {
	return tea.Prettify(s)
}

func (s PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNode) GoString() string {
	return s.String()
}

func (s *PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNode) SetAuditUserList(v *PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserList) *PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNode {
	s.AuditUserList = v
	return s
}

func (s *PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNode) SetComment(v string) *PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNode {
	s.Comment = &v
	return s
}

func (s *PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNode) SetNodeName(v string) *PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNode {
	s.NodeName = &v
	return s
}

func (s *PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNode) SetNodeType(v string) *PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNode {
	s.NodeType = &v
	return s
}

type PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserList struct {
	AuditUser []*PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserListAuditUser `json:"AuditUser,omitempty" xml:"AuditUser,omitempty" type:"Repeated"`
}

func (s PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserList) String() string {
	return tea.Prettify(s)
}

func (s PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserList) GoString() string {
	return s.String()
}

func (s *PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserList) SetAuditUser(v []*PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserListAuditUser) *PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserList {
	s.AuditUser = v
	return s
}

type PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserListAuditUser struct {
	NickName *string `json:"NickName,omitempty" xml:"NickName,omitempty"`
	RealName *string `json:"RealName,omitempty" xml:"RealName,omitempty"`
	UserId   *int64  `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserListAuditUser) String() string {
	return tea.Prettify(s)
}

func (s PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserListAuditUser) GoString() string {
	return s.String()
}

func (s *PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserListAuditUser) SetNickName(v string) *PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserListAuditUser {
	s.NickName = &v
	return s
}

func (s *PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserListAuditUser) SetRealName(v string) *PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserListAuditUser {
	s.RealName = &v
	return s
}

func (s *PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserListAuditUser) SetUserId(v int64) *PreviewWorkflowResponseBodyWorkflowDetailWorkflowNodeListWorkflowNodeAuditUserListAuditUser {
	s.UserId = &v
	return s
}

type PreviewWorkflowResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PreviewWorkflowResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PreviewWorkflowResponse) String() string {
	return tea.Prettify(s)
}

func (s PreviewWorkflowResponse) GoString() string {
	return s.String()
}

func (s *PreviewWorkflowResponse) SetHeaders(v map[string]*string) *PreviewWorkflowResponse {
	s.Headers = v
	return s
}

func (s *PreviewWorkflowResponse) SetStatusCode(v int32) *PreviewWorkflowResponse {
	s.StatusCode = &v
	return s
}

func (s *PreviewWorkflowResponse) SetBody(v *PreviewWorkflowResponseBody) *PreviewWorkflowResponse {
	s.Body = v
	return s
}

type PublishAndDeployTaskFlowRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the tenant.
	//
	// > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The description of the version.
	VersionComments *string `json:"VersionComments,omitempty" xml:"VersionComments,omitempty"`
}

func (s PublishAndDeployTaskFlowRequest) String() string {
	return tea.Prettify(s)
}

func (s PublishAndDeployTaskFlowRequest) GoString() string {
	return s.String()
}

func (s *PublishAndDeployTaskFlowRequest) SetDagId(v int64) *PublishAndDeployTaskFlowRequest {
	s.DagId = &v
	return s
}

func (s *PublishAndDeployTaskFlowRequest) SetTid(v int64) *PublishAndDeployTaskFlowRequest {
	s.Tid = &v
	return s
}

func (s *PublishAndDeployTaskFlowRequest) SetVersionComments(v string) *PublishAndDeployTaskFlowRequest {
	s.VersionComments = &v
	return s
}

type PublishAndDeployTaskFlowResponseBody struct {
	// The ID of the deployment record.
	DeployId *int64 `json:"DeployId,omitempty" xml:"DeployId,omitempty"`
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s PublishAndDeployTaskFlowResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PublishAndDeployTaskFlowResponseBody) GoString() string {
	return s.String()
}

func (s *PublishAndDeployTaskFlowResponseBody) SetDeployId(v int64) *PublishAndDeployTaskFlowResponseBody {
	s.DeployId = &v
	return s
}

func (s *PublishAndDeployTaskFlowResponseBody) SetErrorCode(v string) *PublishAndDeployTaskFlowResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *PublishAndDeployTaskFlowResponseBody) SetErrorMessage(v string) *PublishAndDeployTaskFlowResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *PublishAndDeployTaskFlowResponseBody) SetRequestId(v string) *PublishAndDeployTaskFlowResponseBody {
	s.RequestId = &v
	return s
}

func (s *PublishAndDeployTaskFlowResponseBody) SetSuccess(v bool) *PublishAndDeployTaskFlowResponseBody {
	s.Success = &v
	return s
}

type PublishAndDeployTaskFlowResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PublishAndDeployTaskFlowResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PublishAndDeployTaskFlowResponse) String() string {
	return tea.Prettify(s)
}

func (s PublishAndDeployTaskFlowResponse) GoString() string {
	return s.String()
}

func (s *PublishAndDeployTaskFlowResponse) SetHeaders(v map[string]*string) *PublishAndDeployTaskFlowResponse {
	s.Headers = v
	return s
}

func (s *PublishAndDeployTaskFlowResponse) SetStatusCode(v int32) *PublishAndDeployTaskFlowResponse {
	s.StatusCode = &v
	return s
}

func (s *PublishAndDeployTaskFlowResponse) SetBody(v *PublishAndDeployTaskFlowResponseBody) *PublishAndDeployTaskFlowResponse {
	s.Body = v
	return s
}

type QueryDataTrackResultDownloadStatusRequest struct {
	// The ID of the download key, which is used to identify the parsing progress of data tracking logs. You can call the DownloadDataTrackResult operation to query the ID of the key.
	DownloadKeyId *string `json:"DownloadKeyId,omitempty" xml:"DownloadKeyId,omitempty"`
	// The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to query the ID of the ticket.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the ID of the tenant.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s QueryDataTrackResultDownloadStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDataTrackResultDownloadStatusRequest) GoString() string {
	return s.String()
}

func (s *QueryDataTrackResultDownloadStatusRequest) SetDownloadKeyId(v string) *QueryDataTrackResultDownloadStatusRequest {
	s.DownloadKeyId = &v
	return s
}

func (s *QueryDataTrackResultDownloadStatusRequest) SetOrderId(v int64) *QueryDataTrackResultDownloadStatusRequest {
	s.OrderId = &v
	return s
}

func (s *QueryDataTrackResultDownloadStatusRequest) SetTid(v int64) *QueryDataTrackResultDownloadStatusRequest {
	s.Tid = &v
	return s
}

type QueryDataTrackResultDownloadStatusResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the download progress.
	StatusResult *QueryDataTrackResultDownloadStatusResponseBodyStatusResult `json:"StatusResult,omitempty" xml:"StatusResult,omitempty" type:"Struct"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryDataTrackResultDownloadStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDataTrackResultDownloadStatusResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDataTrackResultDownloadStatusResponseBody) SetErrorCode(v string) *QueryDataTrackResultDownloadStatusResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QueryDataTrackResultDownloadStatusResponseBody) SetErrorMessage(v string) *QueryDataTrackResultDownloadStatusResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDataTrackResultDownloadStatusResponseBody) SetRequestId(v string) *QueryDataTrackResultDownloadStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDataTrackResultDownloadStatusResponseBody) SetStatusResult(v *QueryDataTrackResultDownloadStatusResponseBodyStatusResult) *QueryDataTrackResultDownloadStatusResponseBody {
	s.StatusResult = v
	return s
}

func (s *QueryDataTrackResultDownloadStatusResponseBody) SetSuccess(v bool) *QueryDataTrackResultDownloadStatusResponseBody {
	s.Success = &v
	return s
}

type QueryDataTrackResultDownloadStatusResponseBodyStatusResult struct {
	// The status of the download task. Valid values:
	//
	// *   **INIT**: The download task is being initialized.
	// *   **LISTING**: The download task is in a transient intermediate state during the initialization.
	// *   **DOWNLOADING**: The download task is being processed.
	// *   **DOWNLOAD_SUCCESS**: The download task was successfully processed.
	// *   **DOWNLOAD_FAIL**: The download task failed.
	DownloadStatus *string `json:"DownloadStatus,omitempty" xml:"DownloadStatus,omitempty"`
	// The URL that is used to download data tracking logs. This parameter is returned only when the value of DownloadStatus is DOWNLOAD_SUCCESS.
	DownloadUrl *string `json:"DownloadUrl,omitempty" xml:"DownloadUrl,omitempty"`
	// The description of the state.
	StatusDesc *string `json:"StatusDesc,omitempty" xml:"StatusDesc,omitempty"`
	// The total number of entries returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s QueryDataTrackResultDownloadStatusResponseBodyStatusResult) String() string {
	return tea.Prettify(s)
}

func (s QueryDataTrackResultDownloadStatusResponseBodyStatusResult) GoString() string {
	return s.String()
}

func (s *QueryDataTrackResultDownloadStatusResponseBodyStatusResult) SetDownloadStatus(v string) *QueryDataTrackResultDownloadStatusResponseBodyStatusResult {
	s.DownloadStatus = &v
	return s
}

func (s *QueryDataTrackResultDownloadStatusResponseBodyStatusResult) SetDownloadUrl(v string) *QueryDataTrackResultDownloadStatusResponseBodyStatusResult {
	s.DownloadUrl = &v
	return s
}

func (s *QueryDataTrackResultDownloadStatusResponseBodyStatusResult) SetStatusDesc(v string) *QueryDataTrackResultDownloadStatusResponseBodyStatusResult {
	s.StatusDesc = &v
	return s
}

func (s *QueryDataTrackResultDownloadStatusResponseBodyStatusResult) SetTotalCount(v int64) *QueryDataTrackResultDownloadStatusResponseBodyStatusResult {
	s.TotalCount = &v
	return s
}

type QueryDataTrackResultDownloadStatusResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDataTrackResultDownloadStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDataTrackResultDownloadStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDataTrackResultDownloadStatusResponse) GoString() string {
	return s.String()
}

func (s *QueryDataTrackResultDownloadStatusResponse) SetHeaders(v map[string]*string) *QueryDataTrackResultDownloadStatusResponse {
	s.Headers = v
	return s
}

func (s *QueryDataTrackResultDownloadStatusResponse) SetStatusCode(v int32) *QueryDataTrackResultDownloadStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDataTrackResultDownloadStatusResponse) SetBody(v *QueryDataTrackResultDownloadStatusResponseBody) *QueryDataTrackResultDownloadStatusResponse {
	s.Body = v
	return s
}

type ReDeployLhDagVersionRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to obtain the ID of the task flow.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the task flow version. You can call the [ListDAGVersions](~~424682~~) operation to obtain the ID of the task flow version.
	DagVersion *int64 `json:"DagVersion,omitempty" xml:"DagVersion,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the ID of the tenant.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ReDeployLhDagVersionRequest) String() string {
	return tea.Prettify(s)
}

func (s ReDeployLhDagVersionRequest) GoString() string {
	return s.String()
}

func (s *ReDeployLhDagVersionRequest) SetDagId(v int64) *ReDeployLhDagVersionRequest {
	s.DagId = &v
	return s
}

func (s *ReDeployLhDagVersionRequest) SetDagVersion(v int64) *ReDeployLhDagVersionRequest {
	s.DagVersion = &v
	return s
}

func (s *ReDeployLhDagVersionRequest) SetTid(v int64) *ReDeployLhDagVersionRequest {
	s.Tid = &v
	return s
}

type ReDeployLhDagVersionResponseBody struct {
	// The ID of the deployment record.
	DeployId *int64 `json:"DeployId,omitempty" xml:"DeployId,omitempty"`
	// The error code returned if the request fails.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**: The request is successful.
	// *   **false**: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ReDeployLhDagVersionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ReDeployLhDagVersionResponseBody) GoString() string {
	return s.String()
}

func (s *ReDeployLhDagVersionResponseBody) SetDeployId(v int64) *ReDeployLhDagVersionResponseBody {
	s.DeployId = &v
	return s
}

func (s *ReDeployLhDagVersionResponseBody) SetErrorCode(v string) *ReDeployLhDagVersionResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ReDeployLhDagVersionResponseBody) SetErrorMessage(v string) *ReDeployLhDagVersionResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ReDeployLhDagVersionResponseBody) SetRequestId(v string) *ReDeployLhDagVersionResponseBody {
	s.RequestId = &v
	return s
}

func (s *ReDeployLhDagVersionResponseBody) SetSuccess(v bool) *ReDeployLhDagVersionResponseBody {
	s.Success = &v
	return s
}

type ReDeployLhDagVersionResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ReDeployLhDagVersionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ReDeployLhDagVersionResponse) String() string {
	return tea.Prettify(s)
}

func (s ReDeployLhDagVersionResponse) GoString() string {
	return s.String()
}

func (s *ReDeployLhDagVersionResponse) SetHeaders(v map[string]*string) *ReDeployLhDagVersionResponse {
	s.Headers = v
	return s
}

func (s *ReDeployLhDagVersionResponse) SetStatusCode(v int32) *ReDeployLhDagVersionResponse {
	s.StatusCode = &v
	return s
}

func (s *ReDeployLhDagVersionResponse) SetBody(v *ReDeployLhDagVersionResponseBody) *ReDeployLhDagVersionResponse {
	s.Body = v
	return s
}

type ReRunTaskFlowInstanceRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the execution record of the task flow. You can call the [ListTaskFlowInstance](~~424689~~) operation to query the execution record ID.
	DagInstanceId *int64 `json:"DagInstanceId,omitempty" xml:"DagInstanceId,omitempty"`
	// The version number of the task flow. You can call the ListTaskFlowVersions operation to query the version number of the task flow.
	DagVersion *string `json:"DagVersion,omitempty" xml:"DagVersion,omitempty"`
	// The ID of the tenant.
	//
	// > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ReRunTaskFlowInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s ReRunTaskFlowInstanceRequest) GoString() string {
	return s.String()
}

func (s *ReRunTaskFlowInstanceRequest) SetDagId(v int64) *ReRunTaskFlowInstanceRequest {
	s.DagId = &v
	return s
}

func (s *ReRunTaskFlowInstanceRequest) SetDagInstanceId(v int64) *ReRunTaskFlowInstanceRequest {
	s.DagInstanceId = &v
	return s
}

func (s *ReRunTaskFlowInstanceRequest) SetDagVersion(v string) *ReRunTaskFlowInstanceRequest {
	s.DagVersion = &v
	return s
}

func (s *ReRunTaskFlowInstanceRequest) SetTid(v int64) *ReRunTaskFlowInstanceRequest {
	s.Tid = &v
	return s
}

type ReRunTaskFlowInstanceResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ReRunTaskFlowInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ReRunTaskFlowInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *ReRunTaskFlowInstanceResponseBody) SetErrorCode(v string) *ReRunTaskFlowInstanceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ReRunTaskFlowInstanceResponseBody) SetErrorMessage(v string) *ReRunTaskFlowInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ReRunTaskFlowInstanceResponseBody) SetRequestId(v string) *ReRunTaskFlowInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *ReRunTaskFlowInstanceResponseBody) SetSuccess(v bool) *ReRunTaskFlowInstanceResponseBody {
	s.Success = &v
	return s
}

type ReRunTaskFlowInstanceResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ReRunTaskFlowInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ReRunTaskFlowInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s ReRunTaskFlowInstanceResponse) GoString() string {
	return s.String()
}

func (s *ReRunTaskFlowInstanceResponse) SetHeaders(v map[string]*string) *ReRunTaskFlowInstanceResponse {
	s.Headers = v
	return s
}

func (s *ReRunTaskFlowInstanceResponse) SetStatusCode(v int32) *ReRunTaskFlowInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *ReRunTaskFlowInstanceResponse) SetBody(v *ReRunTaskFlowInstanceResponseBody) *ReRunTaskFlowInstanceResponse {
	s.Body = v
	return s
}

type RefundPayAsYouGoOrderRequest struct {
	// The ID of the sales order instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The order ID of the order for the pay-as-you-go resource. You can call the ListEffectiveOrders operation to query the order ID.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant.
	//
	// > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s RefundPayAsYouGoOrderRequest) String() string {
	return tea.Prettify(s)
}

func (s RefundPayAsYouGoOrderRequest) GoString() string {
	return s.String()
}

func (s *RefundPayAsYouGoOrderRequest) SetInstanceId(v string) *RefundPayAsYouGoOrderRequest {
	s.InstanceId = &v
	return s
}

func (s *RefundPayAsYouGoOrderRequest) SetOrderId(v string) *RefundPayAsYouGoOrderRequest {
	s.OrderId = &v
	return s
}

func (s *RefundPayAsYouGoOrderRequest) SetTid(v int64) *RefundPayAsYouGoOrderRequest {
	s.Tid = &v
	return s
}

type RefundPayAsYouGoOrderResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RefundPayAsYouGoOrderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RefundPayAsYouGoOrderResponseBody) GoString() string {
	return s.String()
}

func (s *RefundPayAsYouGoOrderResponseBody) SetErrorCode(v string) *RefundPayAsYouGoOrderResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *RefundPayAsYouGoOrderResponseBody) SetErrorMessage(v string) *RefundPayAsYouGoOrderResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *RefundPayAsYouGoOrderResponseBody) SetRequestId(v string) *RefundPayAsYouGoOrderResponseBody {
	s.RequestId = &v
	return s
}

func (s *RefundPayAsYouGoOrderResponseBody) SetSuccess(v bool) *RefundPayAsYouGoOrderResponseBody {
	s.Success = &v
	return s
}

type RefundPayAsYouGoOrderResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RefundPayAsYouGoOrderResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RefundPayAsYouGoOrderResponse) String() string {
	return tea.Prettify(s)
}

func (s RefundPayAsYouGoOrderResponse) GoString() string {
	return s.String()
}

func (s *RefundPayAsYouGoOrderResponse) SetHeaders(v map[string]*string) *RefundPayAsYouGoOrderResponse {
	s.Headers = v
	return s
}

func (s *RefundPayAsYouGoOrderResponse) SetStatusCode(v int32) *RefundPayAsYouGoOrderResponse {
	s.StatusCode = &v
	return s
}

func (s *RefundPayAsYouGoOrderResponse) SetBody(v *RefundPayAsYouGoOrderResponseBody) *RefundPayAsYouGoOrderResponse {
	s.Body = v
	return s
}

type RegisterInstanceRequest struct {
	// The name of the database link for cross-database queries.
	//
	// >
	//
	// *   This parameter is required if UseDsql is set to 1.
	//
	// *   The name can contain only lowercase letters and underscores (\_).
	//
	// *   The name must be unique within a tenant.
	DataLinkName *string `json:"DataLinkName,omitempty" xml:"DataLinkName,omitempty"`
	// The password that is used to log on to the database.
	DatabasePassword *string `json:"DatabasePassword,omitempty" xml:"DatabasePassword,omitempty"`
	// The account that is used to log on to the database.
	DatabaseUser *string `json:"DatabaseUser,omitempty" xml:"DatabaseUser,omitempty"`
	// The ID of the user who assumes the DBA role of the database instance. You can call the [ListUsers](~~141938~~) or [GetInstance](~~141567~~) operation to query the user ID.
	DbaUid *int64 `json:"DbaUid,omitempty" xml:"DbaUid,omitempty"`
	// The ID of the user who assumes the DBA role of the database instance. If the user ID is a non-numeric value such as a role or an account, you can use this parameter to replace DbaUid.
	DbaUidByString *string `json:"DbaUidByString,omitempty" xml:"DbaUidByString,omitempty"`
	// Specifies whether to enable the lock-free schema change feature for the database instance. Valid values:
	//
	// *   **0**: disables the lock-free schema change feature.
	// *   **1**: uses the online DDL of MySQL first.
	// *   **2**: uses the lock-free schema change feature of DMS first.
	//
	// > Supported database types: ApsaraDB RDS for MySQL, PolarDB for MySQL, ApsaraDB MyBase for MySQL, and third-party MySQL databases.
	DdlOnline *int32 `json:"DdlOnline,omitempty" xml:"DdlOnline,omitempty"`
	// The ID of the ECS instance on which the database instance is deployed.
	//
	// > This parameter is required if the InstanceSource parameter is set to ECS_OWN.
	EcsInstanceId *string `json:"EcsInstanceId,omitempty" xml:"EcsInstanceId,omitempty"`
	// The ID of the region in which the database instance resides.
	//
	// > This parameter is required if the InstanceSource parameter is set to RDS, ECS_OWN, or VPC_IDC.
	EcsRegion *string `json:"EcsRegion,omitempty" xml:"EcsRegion,omitempty"`
	// *   **Y:** enables the sensitive data protection feature
	// *   **NULL or other:** disables the sensitive data protection feature
	EnableSellSitd *string `json:"EnableSellSitd,omitempty" xml:"EnableSellSitd,omitempty"`
	// The type of the environment in which the database instance is deployed. Valid values:
	//
	// *   product: production environment
	// *   dev: development environment
	// *   pre: pre-release environment
	// *   test: test environment
	// *   sit: system integration testing (SIT) environment
	// *   uat: user acceptance testing (UAT) environment
	// *   pet: stress testing environment
	// *   stag: staging environment
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The timeout period for exporting data from the database instance. Unit: seconds.
	ExportTimeout *int32 `json:"ExportTimeout,omitempty" xml:"ExportTimeout,omitempty"`
	// The host address that is used to connect to the database instance.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The alias of the database instance. Specify an alias that can help you identify the database instance in DMS.
	InstanceAlias *string `json:"InstanceAlias,omitempty" xml:"InstanceAlias,omitempty"`
	// The source of the database instance. Valid values:
	//
	// *   **PUBLIC_OWN:** a self-managed database instance that is deployed on the Internet
	// *   **RDS:** an ApsaraDB RDS instance
	// *   **ECS_OWN:** a self-managed database that is deployed on an Elastic Compute Service (ECS) instance
	// *   **VPC_IDC:** a self-managed database instance that is deployed in a data center connected over a virtual private cloud (VPC)
	InstanceSource *string `json:"InstanceSource,omitempty" xml:"InstanceSource,omitempty"`
	// The type of the database. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The network type of the database instance. Valid values:
	//
	// *   **CLASSIC:** classic network
	// *   **VPC:** VPC
	NetworkType *string `json:"NetworkType,omitempty" xml:"NetworkType,omitempty"`
	// The port that is used to connect to the database instance.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The timeout period for querying data in the database instance. Unit: seconds.
	QueryTimeout *int32 `json:"QueryTimeout,omitempty" xml:"QueryTimeout,omitempty"`
	// The name of the security rule set (GroupName) for the database instance. You can call the [ListStandardGroups](~~417891~~) or [GetInstance](~~141567~~) operation to query the name of the security rule set.
	SafeRule *string `json:"SafeRule,omitempty" xml:"SafeRule,omitempty"`
	// The system ID (SID) of the database.
	//
	// > This parameter is required if the InstanceType parameter is set to ORACLE.
	Sid *string `json:"Sid,omitempty" xml:"Sid,omitempty"`
	// Specifies whether to skip the connectivity test. Valid values:
	//
	// *   **true:** skips the connectivity test
	// *   **false:** does not skip the connectivity test
	SkipTest *bool `json:"SkipTest,omitempty" xml:"SkipTest,omitempty"`
	// The ID of the classification template. You can call the [ListClassificationTemplates](~~460613~~) operation to query the template ID.
	TemplateId *int64 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The type of the classification template. You can call the [ListClassificationTemplates](~~460613~~) operation to query the template type.
	TemplateType *string `json:"TemplateType,omitempty" xml:"TemplateType,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// Specifies whether to enable the cross-database query feature for the database instance. Valid values:
	//
	// *   **0**: disables the cross-database query feature.
	// *   **1**: enables the cross-database query feature.
	//
	// > Supported database types: MySQL, SQL Server, PostgreSQL, PolarDB for PostgreSQL (compatible with Oracle), and ApsaraDB for Redis.
	UseDsql *int32 `json:"UseDsql,omitempty" xml:"UseDsql,omitempty"`
	// The ID of the VPC to which the database instance belongs.
	//
	// > This parameter is required if the InstanceSource parameter is set to VPC_IDC.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s RegisterInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s RegisterInstanceRequest) GoString() string {
	return s.String()
}

func (s *RegisterInstanceRequest) SetDataLinkName(v string) *RegisterInstanceRequest {
	s.DataLinkName = &v
	return s
}

func (s *RegisterInstanceRequest) SetDatabasePassword(v string) *RegisterInstanceRequest {
	s.DatabasePassword = &v
	return s
}

func (s *RegisterInstanceRequest) SetDatabaseUser(v string) *RegisterInstanceRequest {
	s.DatabaseUser = &v
	return s
}

func (s *RegisterInstanceRequest) SetDbaUid(v int64) *RegisterInstanceRequest {
	s.DbaUid = &v
	return s
}

func (s *RegisterInstanceRequest) SetDbaUidByString(v string) *RegisterInstanceRequest {
	s.DbaUidByString = &v
	return s
}

func (s *RegisterInstanceRequest) SetDdlOnline(v int32) *RegisterInstanceRequest {
	s.DdlOnline = &v
	return s
}

func (s *RegisterInstanceRequest) SetEcsInstanceId(v string) *RegisterInstanceRequest {
	s.EcsInstanceId = &v
	return s
}

func (s *RegisterInstanceRequest) SetEcsRegion(v string) *RegisterInstanceRequest {
	s.EcsRegion = &v
	return s
}

func (s *RegisterInstanceRequest) SetEnableSellSitd(v string) *RegisterInstanceRequest {
	s.EnableSellSitd = &v
	return s
}

func (s *RegisterInstanceRequest) SetEnvType(v string) *RegisterInstanceRequest {
	s.EnvType = &v
	return s
}

func (s *RegisterInstanceRequest) SetExportTimeout(v int32) *RegisterInstanceRequest {
	s.ExportTimeout = &v
	return s
}

func (s *RegisterInstanceRequest) SetHost(v string) *RegisterInstanceRequest {
	s.Host = &v
	return s
}

func (s *RegisterInstanceRequest) SetInstanceAlias(v string) *RegisterInstanceRequest {
	s.InstanceAlias = &v
	return s
}

func (s *RegisterInstanceRequest) SetInstanceSource(v string) *RegisterInstanceRequest {
	s.InstanceSource = &v
	return s
}

func (s *RegisterInstanceRequest) SetInstanceType(v string) *RegisterInstanceRequest {
	s.InstanceType = &v
	return s
}

func (s *RegisterInstanceRequest) SetNetworkType(v string) *RegisterInstanceRequest {
	s.NetworkType = &v
	return s
}

func (s *RegisterInstanceRequest) SetPort(v int32) *RegisterInstanceRequest {
	s.Port = &v
	return s
}

func (s *RegisterInstanceRequest) SetQueryTimeout(v int32) *RegisterInstanceRequest {
	s.QueryTimeout = &v
	return s
}

func (s *RegisterInstanceRequest) SetSafeRule(v string) *RegisterInstanceRequest {
	s.SafeRule = &v
	return s
}

func (s *RegisterInstanceRequest) SetSid(v string) *RegisterInstanceRequest {
	s.Sid = &v
	return s
}

func (s *RegisterInstanceRequest) SetSkipTest(v bool) *RegisterInstanceRequest {
	s.SkipTest = &v
	return s
}

func (s *RegisterInstanceRequest) SetTemplateId(v int64) *RegisterInstanceRequest {
	s.TemplateId = &v
	return s
}

func (s *RegisterInstanceRequest) SetTemplateType(v string) *RegisterInstanceRequest {
	s.TemplateType = &v
	return s
}

func (s *RegisterInstanceRequest) SetTid(v int64) *RegisterInstanceRequest {
	s.Tid = &v
	return s
}

func (s *RegisterInstanceRequest) SetUseDsql(v int32) *RegisterInstanceRequest {
	s.UseDsql = &v
	return s
}

func (s *RegisterInstanceRequest) SetVpcId(v string) *RegisterInstanceRequest {
	s.VpcId = &v
	return s
}

type RegisterInstanceResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true:** The request was successful.
	// *   **false:** The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RegisterInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RegisterInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *RegisterInstanceResponseBody) SetErrorCode(v string) *RegisterInstanceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *RegisterInstanceResponseBody) SetErrorMessage(v string) *RegisterInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *RegisterInstanceResponseBody) SetRequestId(v string) *RegisterInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *RegisterInstanceResponseBody) SetSuccess(v bool) *RegisterInstanceResponseBody {
	s.Success = &v
	return s
}

type RegisterInstanceResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RegisterInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RegisterInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s RegisterInstanceResponse) GoString() string {
	return s.String()
}

func (s *RegisterInstanceResponse) SetHeaders(v map[string]*string) *RegisterInstanceResponse {
	s.Headers = v
	return s
}

func (s *RegisterInstanceResponse) SetStatusCode(v int32) *RegisterInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *RegisterInstanceResponse) SetBody(v *RegisterInstanceResponseBody) *RegisterInstanceResponse {
	s.Body = v
	return s
}

type RegisterUserRequest struct {
	// The mobile number of the user.
	Mobile *string `json:"Mobile,omitempty" xml:"Mobile,omitempty"`
	// The role that you want to assign to the user. Valid values:
	//
	// *   **USER**: a regular user role
	// *   **DBA**: a database administrator (DBA) role
	// *   **ADMIN**: a DMS administrator role
	// *   **SECURITY_ADMIN**: a security administrator role
	//
	// >  If you do not specify this parameter, the regular user role is assigned to the user by default. You can assign one or more roles to the user. Separate multiple roles with commas (,).
	RoleNames *string `json:"RoleNames,omitempty" xml:"RoleNames,omitempty"`
	// The ID of the tenant.
	//
	// >  To query ID of the tenant, move the pointer over the profile picture in the upper-right corner of the DMS console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The UID of the Alibaba Cloud account of the user that you want to register.
	Uid *string `json:"Uid,omitempty" xml:"Uid,omitempty"`
	// The nickname of the user.
	UserNick *string `json:"UserNick,omitempty" xml:"UserNick,omitempty"`
}

func (s RegisterUserRequest) String() string {
	return tea.Prettify(s)
}

func (s RegisterUserRequest) GoString() string {
	return s.String()
}

func (s *RegisterUserRequest) SetMobile(v string) *RegisterUserRequest {
	s.Mobile = &v
	return s
}

func (s *RegisterUserRequest) SetRoleNames(v string) *RegisterUserRequest {
	s.RoleNames = &v
	return s
}

func (s *RegisterUserRequest) SetTid(v int64) *RegisterUserRequest {
	s.Tid = &v
	return s
}

func (s *RegisterUserRequest) SetUid(v string) *RegisterUserRequest {
	s.Uid = &v
	return s
}

func (s *RegisterUserRequest) SetUserNick(v string) *RegisterUserRequest {
	s.UserNick = &v
	return s
}

type RegisterUserResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RegisterUserResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RegisterUserResponseBody) GoString() string {
	return s.String()
}

func (s *RegisterUserResponseBody) SetErrorCode(v string) *RegisterUserResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *RegisterUserResponseBody) SetErrorMessage(v string) *RegisterUserResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *RegisterUserResponseBody) SetRequestId(v string) *RegisterUserResponseBody {
	s.RequestId = &v
	return s
}

func (s *RegisterUserResponseBody) SetSuccess(v bool) *RegisterUserResponseBody {
	s.Success = &v
	return s
}

type RegisterUserResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RegisterUserResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RegisterUserResponse) String() string {
	return tea.Prettify(s)
}

func (s RegisterUserResponse) GoString() string {
	return s.String()
}

func (s *RegisterUserResponse) SetHeaders(v map[string]*string) *RegisterUserResponse {
	s.Headers = v
	return s
}

func (s *RegisterUserResponse) SetStatusCode(v int32) *RegisterUserResponse {
	s.StatusCode = &v
	return s
}

func (s *RegisterUserResponse) SetBody(v *RegisterUserResponseBody) *RegisterUserResponse {
	s.Body = v
	return s
}

type RestartDataCorrectSQLJobRequest struct {
	// The ID of the SQL task. You can call the [GetDataCorrectTaskDetail](~~208481~~) and [ListDBTaskSQLJob](~~207049~~) operations to obtain the value of this parameter.
	//
	// If the Type parameter is set to SINGLE, you must pass the value of the JobId parameter to confirm the ID of the SQL task that you want to rerun.
	JobId *int64 `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The ID of the data change ticket. You can call the [ListOrders](~~144643~~) operation to query the ID of the data change ticket.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The type of the rerun operation. Valid values:
	//
	// *   **ALL**: reruns all SQL tasks.
	// *   **SINGLE**: reruns a single SQL task.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s RestartDataCorrectSQLJobRequest) String() string {
	return tea.Prettify(s)
}

func (s RestartDataCorrectSQLJobRequest) GoString() string {
	return s.String()
}

func (s *RestartDataCorrectSQLJobRequest) SetJobId(v int64) *RestartDataCorrectSQLJobRequest {
	s.JobId = &v
	return s
}

func (s *RestartDataCorrectSQLJobRequest) SetOrderId(v int64) *RestartDataCorrectSQLJobRequest {
	s.OrderId = &v
	return s
}

func (s *RestartDataCorrectSQLJobRequest) SetTid(v int64) *RestartDataCorrectSQLJobRequest {
	s.Tid = &v
	return s
}

func (s *RestartDataCorrectSQLJobRequest) SetType(v string) *RestartDataCorrectSQLJobRequest {
	s.Type = &v
	return s
}

type RestartDataCorrectSQLJobResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**: The request is successful.
	// *   **false**: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RestartDataCorrectSQLJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RestartDataCorrectSQLJobResponseBody) GoString() string {
	return s.String()
}

func (s *RestartDataCorrectSQLJobResponseBody) SetErrorCode(v string) *RestartDataCorrectSQLJobResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *RestartDataCorrectSQLJobResponseBody) SetErrorMessage(v string) *RestartDataCorrectSQLJobResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *RestartDataCorrectSQLJobResponseBody) SetRequestId(v string) *RestartDataCorrectSQLJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *RestartDataCorrectSQLJobResponseBody) SetSuccess(v bool) *RestartDataCorrectSQLJobResponseBody {
	s.Success = &v
	return s
}

type RestartDataCorrectSQLJobResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RestartDataCorrectSQLJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RestartDataCorrectSQLJobResponse) String() string {
	return tea.Prettify(s)
}

func (s RestartDataCorrectSQLJobResponse) GoString() string {
	return s.String()
}

func (s *RestartDataCorrectSQLJobResponse) SetHeaders(v map[string]*string) *RestartDataCorrectSQLJobResponse {
	s.Headers = v
	return s
}

func (s *RestartDataCorrectSQLJobResponse) SetStatusCode(v int32) *RestartDataCorrectSQLJobResponse {
	s.StatusCode = &v
	return s
}

func (s *RestartDataCorrectSQLJobResponse) SetBody(v *RestartDataCorrectSQLJobResponseBody) *RestartDataCorrectSQLJobResponse {
	s.Body = v
	return s
}

type ResumeTaskFlowInstanceRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the execution record of the task flow. You can call the [ListTaskFlowInstance](~~424689~~) operation to query the execution record ID.
	DagInstanceId *int64 `json:"DagInstanceId,omitempty" xml:"DagInstanceId,omitempty"`
	// The version number of the task flow. You can call the [ListDAGVersions](~~424682~~) operation to query the version number.
	DagVersion *string `json:"DagVersion,omitempty" xml:"DagVersion,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s ResumeTaskFlowInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s ResumeTaskFlowInstanceRequest) GoString() string {
	return s.String()
}

func (s *ResumeTaskFlowInstanceRequest) SetDagId(v int64) *ResumeTaskFlowInstanceRequest {
	s.DagId = &v
	return s
}

func (s *ResumeTaskFlowInstanceRequest) SetDagInstanceId(v int64) *ResumeTaskFlowInstanceRequest {
	s.DagInstanceId = &v
	return s
}

func (s *ResumeTaskFlowInstanceRequest) SetDagVersion(v string) *ResumeTaskFlowInstanceRequest {
	s.DagVersion = &v
	return s
}

func (s *ResumeTaskFlowInstanceRequest) SetTid(v int64) *ResumeTaskFlowInstanceRequest {
	s.Tid = &v
	return s
}

type ResumeTaskFlowInstanceResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ResumeTaskFlowInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ResumeTaskFlowInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *ResumeTaskFlowInstanceResponseBody) SetErrorCode(v string) *ResumeTaskFlowInstanceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ResumeTaskFlowInstanceResponseBody) SetErrorMessage(v string) *ResumeTaskFlowInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ResumeTaskFlowInstanceResponseBody) SetRequestId(v string) *ResumeTaskFlowInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *ResumeTaskFlowInstanceResponseBody) SetSuccess(v bool) *ResumeTaskFlowInstanceResponseBody {
	s.Success = &v
	return s
}

type ResumeTaskFlowInstanceResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ResumeTaskFlowInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ResumeTaskFlowInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s ResumeTaskFlowInstanceResponse) GoString() string {
	return s.String()
}

func (s *ResumeTaskFlowInstanceResponse) SetHeaders(v map[string]*string) *ResumeTaskFlowInstanceResponse {
	s.Headers = v
	return s
}

func (s *ResumeTaskFlowInstanceResponse) SetStatusCode(v int32) *ResumeTaskFlowInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *ResumeTaskFlowInstanceResponse) SetBody(v *ResumeTaskFlowInstanceResponseBody) *ResumeTaskFlowInstanceResponse {
	s.Body = v
	return s
}

type RetryDataCorrectPreCheckRequest struct {
	// The ID of the data change ticket. You can call the [ListOrders](~~144643~~) operation to query the ID of the data change ticket.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s RetryDataCorrectPreCheckRequest) String() string {
	return tea.Prettify(s)
}

func (s RetryDataCorrectPreCheckRequest) GoString() string {
	return s.String()
}

func (s *RetryDataCorrectPreCheckRequest) SetOrderId(v int64) *RetryDataCorrectPreCheckRequest {
	s.OrderId = &v
	return s
}

func (s *RetryDataCorrectPreCheckRequest) SetTid(v int64) *RetryDataCorrectPreCheckRequest {
	s.Tid = &v
	return s
}

type RetryDataCorrectPreCheckResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RetryDataCorrectPreCheckResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RetryDataCorrectPreCheckResponseBody) GoString() string {
	return s.String()
}

func (s *RetryDataCorrectPreCheckResponseBody) SetErrorCode(v string) *RetryDataCorrectPreCheckResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *RetryDataCorrectPreCheckResponseBody) SetErrorMessage(v string) *RetryDataCorrectPreCheckResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *RetryDataCorrectPreCheckResponseBody) SetRequestId(v string) *RetryDataCorrectPreCheckResponseBody {
	s.RequestId = &v
	return s
}

func (s *RetryDataCorrectPreCheckResponseBody) SetSuccess(v bool) *RetryDataCorrectPreCheckResponseBody {
	s.Success = &v
	return s
}

type RetryDataCorrectPreCheckResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RetryDataCorrectPreCheckResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RetryDataCorrectPreCheckResponse) String() string {
	return tea.Prettify(s)
}

func (s RetryDataCorrectPreCheckResponse) GoString() string {
	return s.String()
}

func (s *RetryDataCorrectPreCheckResponse) SetHeaders(v map[string]*string) *RetryDataCorrectPreCheckResponse {
	s.Headers = v
	return s
}

func (s *RetryDataCorrectPreCheckResponse) SetStatusCode(v int32) *RetryDataCorrectPreCheckResponse {
	s.StatusCode = &v
	return s
}

func (s *RetryDataCorrectPreCheckResponse) SetBody(v *RetryDataCorrectPreCheckResponseBody) *RetryDataCorrectPreCheckResponse {
	s.Body = v
	return s
}

type RevokeTemplateAuthorityRequest struct {
	// The ID of the permission template.
	TemplateId *int64 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The IDs of users from whom you want to revoke permissions by using a permission template.
	UserIds *string `json:"UserIds,omitempty" xml:"UserIds,omitempty"`
}

func (s RevokeTemplateAuthorityRequest) String() string {
	return tea.Prettify(s)
}

func (s RevokeTemplateAuthorityRequest) GoString() string {
	return s.String()
}

func (s *RevokeTemplateAuthorityRequest) SetTemplateId(v int64) *RevokeTemplateAuthorityRequest {
	s.TemplateId = &v
	return s
}

func (s *RevokeTemplateAuthorityRequest) SetTid(v int64) *RevokeTemplateAuthorityRequest {
	s.Tid = &v
	return s
}

func (s *RevokeTemplateAuthorityRequest) SetUserIds(v string) *RevokeTemplateAuthorityRequest {
	s.UserIds = &v
	return s
}

type RevokeTemplateAuthorityResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the permissions were revoked from the users.
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RevokeTemplateAuthorityResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RevokeTemplateAuthorityResponseBody) GoString() string {
	return s.String()
}

func (s *RevokeTemplateAuthorityResponseBody) SetErrorCode(v string) *RevokeTemplateAuthorityResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *RevokeTemplateAuthorityResponseBody) SetErrorMessage(v string) *RevokeTemplateAuthorityResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *RevokeTemplateAuthorityResponseBody) SetRequestId(v string) *RevokeTemplateAuthorityResponseBody {
	s.RequestId = &v
	return s
}

func (s *RevokeTemplateAuthorityResponseBody) SetResult(v bool) *RevokeTemplateAuthorityResponseBody {
	s.Result = &v
	return s
}

func (s *RevokeTemplateAuthorityResponseBody) SetSuccess(v bool) *RevokeTemplateAuthorityResponseBody {
	s.Success = &v
	return s
}

type RevokeTemplateAuthorityResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RevokeTemplateAuthorityResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RevokeTemplateAuthorityResponse) String() string {
	return tea.Prettify(s)
}

func (s RevokeTemplateAuthorityResponse) GoString() string {
	return s.String()
}

func (s *RevokeTemplateAuthorityResponse) SetHeaders(v map[string]*string) *RevokeTemplateAuthorityResponse {
	s.Headers = v
	return s
}

func (s *RevokeTemplateAuthorityResponse) SetStatusCode(v int32) *RevokeTemplateAuthorityResponse {
	s.StatusCode = &v
	return s
}

func (s *RevokeTemplateAuthorityResponse) SetBody(v *RevokeTemplateAuthorityResponseBody) *RevokeTemplateAuthorityResponse {
	s.Body = v
	return s
}

type RevokeUserPermissionRequest struct {
	// The ID of the database. The database can be a physical database or a logical database.
	//
	// *   To query the ID of a physical database, call the [ListDatabases](~~141873~~) or [SearchDatabase](~~141876~~) operation.
	// *   To query the ID of a logical database, call the [ListLogicDatabases](~~141874~~) or [SearchDatabase](~~141876~~) operation.
	DbId *string `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// The object type on which the permission you want to revoke from the user. Valid values:
	//
	// *   **INSTANCE**: database instances
	// *   **DATABASE**: physical databases
	// *   **LOGIC_DATABASE**: logical databases
	// *   **TABLE**: physical tables
	// *   **LOGIC_TABLE**: logical tables
	DsType *string `json:"DsType,omitempty" xml:"DsType,omitempty"`
	// The ID of the database instance. You must specify this parameter when you revoke a permission from the database instance. You can call the [ListInstances](~~141936~~) or [GetInstance](~~141567~~) operation to query the database instance ID.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// Specifies whether the database is a logical database. Valid values:
	//
	// * **true**: The database is a logical database.
	// * **false**: The database is a physical database.
	//
	// > * If the database is a logical database, set this parameter to **true**.
	// > * If the database is a physical database, set this parameter to **false**.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The type of the permission. Valid values:
	//
	// *   **QUERY**: the data query permission
	// *   **EXPORT**: the data export permission
	// *   **CORRECT**: the data change permission
	PermTypes *string `json:"PermTypes,omitempty" xml:"PermTypes,omitempty"`
	// The ID of the table. You must specify this parameter when you revoke a permission from the table. You can call the [ListTables](~~141878~~) operation to query the table ID.
	TableId *string `json:"TableId,omitempty" xml:"TableId,omitempty"`
	// The name of the table. You can call the [ListTables](~~141878~~) operation to query the table name.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The ID of the permission. You can call the [ListUserPermission](~~146957~~) operation to query the permission ID.
	UserAccessId *string `json:"UserAccessId,omitempty" xml:"UserAccessId,omitempty"`
	// The ID of the user. You can call the [ListUsers](~~141938~~) or [GetUser](~~147098~~) operation to query the user ID.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s RevokeUserPermissionRequest) String() string {
	return tea.Prettify(s)
}

func (s RevokeUserPermissionRequest) GoString() string {
	return s.String()
}

func (s *RevokeUserPermissionRequest) SetDbId(v string) *RevokeUserPermissionRequest {
	s.DbId = &v
	return s
}

func (s *RevokeUserPermissionRequest) SetDsType(v string) *RevokeUserPermissionRequest {
	s.DsType = &v
	return s
}

func (s *RevokeUserPermissionRequest) SetInstanceId(v int64) *RevokeUserPermissionRequest {
	s.InstanceId = &v
	return s
}

func (s *RevokeUserPermissionRequest) SetLogic(v bool) *RevokeUserPermissionRequest {
	s.Logic = &v
	return s
}

func (s *RevokeUserPermissionRequest) SetPermTypes(v string) *RevokeUserPermissionRequest {
	s.PermTypes = &v
	return s
}

func (s *RevokeUserPermissionRequest) SetTableId(v string) *RevokeUserPermissionRequest {
	s.TableId = &v
	return s
}

func (s *RevokeUserPermissionRequest) SetTableName(v string) *RevokeUserPermissionRequest {
	s.TableName = &v
	return s
}

func (s *RevokeUserPermissionRequest) SetTid(v int64) *RevokeUserPermissionRequest {
	s.Tid = &v
	return s
}

func (s *RevokeUserPermissionRequest) SetUserAccessId(v string) *RevokeUserPermissionRequest {
	s.UserAccessId = &v
	return s
}

func (s *RevokeUserPermissionRequest) SetUserId(v string) *RevokeUserPermissionRequest {
	s.UserId = &v
	return s
}

type RevokeUserPermissionResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RevokeUserPermissionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RevokeUserPermissionResponseBody) GoString() string {
	return s.String()
}

func (s *RevokeUserPermissionResponseBody) SetErrorCode(v string) *RevokeUserPermissionResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *RevokeUserPermissionResponseBody) SetErrorMessage(v string) *RevokeUserPermissionResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *RevokeUserPermissionResponseBody) SetRequestId(v string) *RevokeUserPermissionResponseBody {
	s.RequestId = &v
	return s
}

func (s *RevokeUserPermissionResponseBody) SetSuccess(v bool) *RevokeUserPermissionResponseBody {
	s.Success = &v
	return s
}

type RevokeUserPermissionResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RevokeUserPermissionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RevokeUserPermissionResponse) String() string {
	return tea.Prettify(s)
}

func (s RevokeUserPermissionResponse) GoString() string {
	return s.String()
}

func (s *RevokeUserPermissionResponse) SetHeaders(v map[string]*string) *RevokeUserPermissionResponse {
	s.Headers = v
	return s
}

func (s *RevokeUserPermissionResponse) SetStatusCode(v int32) *RevokeUserPermissionResponse {
	s.StatusCode = &v
	return s
}

func (s *RevokeUserPermissionResponse) SetBody(v *RevokeUserPermissionResponseBody) *RevokeUserPermissionResponse {
	s.Body = v
	return s
}

type SearchDataTrackResultRequest struct {
	// The condition to filter columns.
	ColumnFilter *SearchDataTrackResultRequestColumnFilter `json:"ColumnFilter,omitempty" xml:"ColumnFilter,omitempty" type:"Struct"`
	// The end time of the time range in which you want to track data operations. The time must be in the yyyy-MM-dd HH:mm:ss format.
	FilterEndTime *string `json:"FilterEndTime,omitempty" xml:"FilterEndTime,omitempty"`
	// The start time of the time range in which you want to track data operations. The time must be in the yyyy-MM-dd HH:mm:ss format.
	FilterStartTime *string `json:"FilterStartTime,omitempty" xml:"FilterStartTime,omitempty"`
	// The names of the tables for which you want to track data operations.
	FilterTableList []*string `json:"FilterTableList,omitempty" xml:"FilterTableList,omitempty" type:"Repeated"`
	// The types of data operations that you want to track.
	FilterTypeList []*string `json:"FilterTypeList,omitempty" xml:"FilterTypeList,omitempty" type:"Repeated"`
	// The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to query the ticket ID.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s SearchDataTrackResultRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchDataTrackResultRequest) GoString() string {
	return s.String()
}

func (s *SearchDataTrackResultRequest) SetColumnFilter(v *SearchDataTrackResultRequestColumnFilter) *SearchDataTrackResultRequest {
	s.ColumnFilter = v
	return s
}

func (s *SearchDataTrackResultRequest) SetFilterEndTime(v string) *SearchDataTrackResultRequest {
	s.FilterEndTime = &v
	return s
}

func (s *SearchDataTrackResultRequest) SetFilterStartTime(v string) *SearchDataTrackResultRequest {
	s.FilterStartTime = &v
	return s
}

func (s *SearchDataTrackResultRequest) SetFilterTableList(v []*string) *SearchDataTrackResultRequest {
	s.FilterTableList = v
	return s
}

func (s *SearchDataTrackResultRequest) SetFilterTypeList(v []*string) *SearchDataTrackResultRequest {
	s.FilterTypeList = v
	return s
}

func (s *SearchDataTrackResultRequest) SetOrderId(v int64) *SearchDataTrackResultRequest {
	s.OrderId = &v
	return s
}

func (s *SearchDataTrackResultRequest) SetTid(v int64) *SearchDataTrackResultRequest {
	s.Tid = &v
	return s
}

type SearchDataTrackResultRequestColumnFilter struct {
	// The end value of the range used in the filter condition. This parameter takes effect only when Operator is set to BETWEEN.
	BetweenEnd *string `json:"BetweenEnd,omitempty" xml:"BetweenEnd,omitempty"`
	// The start value of the range used in the filter condition. This parameter takes effect only when Operator is set to BETWEEN.
	BetweenStart *string `json:"BetweenStart,omitempty" xml:"BetweenStart,omitempty"`
	// The name of the column.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The IN list used in the filter condition. This parameter takes effect only when Operator is set to IN or NOT_IN.
	InList []*string `json:"InList,omitempty" xml:"InList,omitempty" type:"Repeated"`
	// The type of the operator used to configure the filter condition. Valid values:
	//
	// *   **EQUAL**: retrieves the column whose value is equal to the specified value.
	// *   **NOT_EQUAL**: retrieves the column whose value is not equal to the specified value.
	// *   **IN**: retrieves the column whose value is in the IN list.
	// *   **BETWEEN**: retrieves the column whose value is in the specified range.
	// *   **LESS**: retrieves the column whose value is less than the specified value.
	// *   **MORE**: retrieves the column whose value is greater than the specified value.
	// *   **NOT_IN**: retrieves the column whose value is not in the IN list.
	Operator *string `json:"Operator,omitempty" xml:"Operator,omitempty"`
	// The value used in the filter condition.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s SearchDataTrackResultRequestColumnFilter) String() string {
	return tea.Prettify(s)
}

func (s SearchDataTrackResultRequestColumnFilter) GoString() string {
	return s.String()
}

func (s *SearchDataTrackResultRequestColumnFilter) SetBetweenEnd(v string) *SearchDataTrackResultRequestColumnFilter {
	s.BetweenEnd = &v
	return s
}

func (s *SearchDataTrackResultRequestColumnFilter) SetBetweenStart(v string) *SearchDataTrackResultRequestColumnFilter {
	s.BetweenStart = &v
	return s
}

func (s *SearchDataTrackResultRequestColumnFilter) SetColumnName(v string) *SearchDataTrackResultRequestColumnFilter {
	s.ColumnName = &v
	return s
}

func (s *SearchDataTrackResultRequestColumnFilter) SetInList(v []*string) *SearchDataTrackResultRequestColumnFilter {
	s.InList = v
	return s
}

func (s *SearchDataTrackResultRequestColumnFilter) SetOperator(v string) *SearchDataTrackResultRequestColumnFilter {
	s.Operator = &v
	return s
}

func (s *SearchDataTrackResultRequestColumnFilter) SetValue(v string) *SearchDataTrackResultRequestColumnFilter {
	s.Value = &v
	return s
}

type SearchDataTrackResultShrinkRequest struct {
	// The condition to filter columns.
	ColumnFilterShrink *string `json:"ColumnFilter,omitempty" xml:"ColumnFilter,omitempty"`
	// The end time of the time range in which you want to track data operations. The time must be in the yyyy-MM-dd HH:mm:ss format.
	FilterEndTime *string `json:"FilterEndTime,omitempty" xml:"FilterEndTime,omitempty"`
	// The start time of the time range in which you want to track data operations. The time must be in the yyyy-MM-dd HH:mm:ss format.
	FilterStartTime *string `json:"FilterStartTime,omitempty" xml:"FilterStartTime,omitempty"`
	// The names of the tables for which you want to track data operations.
	FilterTableListShrink *string `json:"FilterTableList,omitempty" xml:"FilterTableList,omitempty"`
	// The types of data operations that you want to track.
	FilterTypeListShrink *string `json:"FilterTypeList,omitempty" xml:"FilterTypeList,omitempty"`
	// The ID of the ticket. You can call the [ListOrders](~~144643~~) operation to query the ticket ID.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s SearchDataTrackResultShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchDataTrackResultShrinkRequest) GoString() string {
	return s.String()
}

func (s *SearchDataTrackResultShrinkRequest) SetColumnFilterShrink(v string) *SearchDataTrackResultShrinkRequest {
	s.ColumnFilterShrink = &v
	return s
}

func (s *SearchDataTrackResultShrinkRequest) SetFilterEndTime(v string) *SearchDataTrackResultShrinkRequest {
	s.FilterEndTime = &v
	return s
}

func (s *SearchDataTrackResultShrinkRequest) SetFilterStartTime(v string) *SearchDataTrackResultShrinkRequest {
	s.FilterStartTime = &v
	return s
}

func (s *SearchDataTrackResultShrinkRequest) SetFilterTableListShrink(v string) *SearchDataTrackResultShrinkRequest {
	s.FilterTableListShrink = &v
	return s
}

func (s *SearchDataTrackResultShrinkRequest) SetFilterTypeListShrink(v string) *SearchDataTrackResultShrinkRequest {
	s.FilterTypeListShrink = &v
	return s
}

func (s *SearchDataTrackResultShrinkRequest) SetOrderId(v int64) *SearchDataTrackResultShrinkRequest {
	s.OrderId = &v
	return s
}

func (s *SearchDataTrackResultShrinkRequest) SetTid(v int64) *SearchDataTrackResultShrinkRequest {
	s.Tid = &v
	return s
}

type SearchDataTrackResultResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The parsing result of the data tracking task.
	TrackResult *SearchDataTrackResultResponseBodyTrackResult `json:"TrackResult,omitempty" xml:"TrackResult,omitempty" type:"Struct"`
}

func (s SearchDataTrackResultResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SearchDataTrackResultResponseBody) GoString() string {
	return s.String()
}

func (s *SearchDataTrackResultResponseBody) SetErrorCode(v string) *SearchDataTrackResultResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *SearchDataTrackResultResponseBody) SetErrorMessage(v string) *SearchDataTrackResultResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *SearchDataTrackResultResponseBody) SetRequestId(v string) *SearchDataTrackResultResponseBody {
	s.RequestId = &v
	return s
}

func (s *SearchDataTrackResultResponseBody) SetSuccess(v bool) *SearchDataTrackResultResponseBody {
	s.Success = &v
	return s
}

func (s *SearchDataTrackResultResponseBody) SetTrackResult(v *SearchDataTrackResultResponseBodyTrackResult) *SearchDataTrackResultResponseBody {
	s.TrackResult = v
	return s
}

type SearchDataTrackResultResponseBodyTrackResult struct {
	// The details of the event logs.
	EventList []*SearchDataTrackResultResponseBodyTrackResultEventList `json:"EventList,omitempty" xml:"EventList,omitempty" type:"Repeated"`
	// The metadata of tables for which you track data operations.
	TableInfoList []*SearchDataTrackResultResponseBodyTrackResultTableInfoList `json:"TableInfoList,omitempty" xml:"TableInfoList,omitempty" type:"Repeated"`
	// The total number of entries returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s SearchDataTrackResultResponseBodyTrackResult) String() string {
	return tea.Prettify(s)
}

func (s SearchDataTrackResultResponseBodyTrackResult) GoString() string {
	return s.String()
}

func (s *SearchDataTrackResultResponseBodyTrackResult) SetEventList(v []*SearchDataTrackResultResponseBodyTrackResultEventList) *SearchDataTrackResultResponseBodyTrackResult {
	s.EventList = v
	return s
}

func (s *SearchDataTrackResultResponseBodyTrackResult) SetTableInfoList(v []*SearchDataTrackResultResponseBodyTrackResultTableInfoList) *SearchDataTrackResultResponseBodyTrackResult {
	s.TableInfoList = v
	return s
}

func (s *SearchDataTrackResultResponseBodyTrackResult) SetTotalCount(v int64) *SearchDataTrackResultResponseBodyTrackResult {
	s.TotalCount = &v
	return s
}

type SearchDataTrackResultResponseBodyTrackResultEventList struct {
	// The data records after you perform data operations in the database.
	DataAfter []*string `json:"DataAfter,omitempty" xml:"DataAfter,omitempty" type:"Repeated"`
	// The data records before you perform data operations in the database.
	DataBefore []*string `json:"DataBefore,omitempty" xml:"DataBefore,omitempty" type:"Repeated"`
	// The ID of the event.
	EventId *int64 `json:"EventId,omitempty" xml:"EventId,omitempty"`
	// The length of the event content. Unit: bytes.
	EventLength *int64 `json:"EventLength,omitempty" xml:"EventLength,omitempty"`
	// The event time.
	EventTimestamp *string `json:"EventTimestamp,omitempty" xml:"EventTimestamp,omitempty"`
	// The type of the event. Valid values:
	//
	// *   **WRITE_ROWS**: indicates an INSERT operation.
	// *   **UPDATE_ROWS**: indicates an UPDATE operation.
	// *   **DELETE_ROWS**: indicates a DELETE operation.
	// *   **EXT_WRITE_ROWS**: indicates an INSERT operation, which is equivalent to WRITE_ROWS.
	// *   **EXT_UPDATE_ROWS**: indicates an UPDATE operation, which is equivalent to UPDATE_ROWS.
	// *   **EXT_DELETE_ROWS**: indicates a DELETE operation, which is equivalent to DELETE_ROWS.
	EventType *string `json:"EventType,omitempty" xml:"EventType,omitempty"`
	// The SQL statements used to roll back the data change.
	RollSQL *string `json:"RollSQL,omitempty" xml:"RollSQL,omitempty"`
}

func (s SearchDataTrackResultResponseBodyTrackResultEventList) String() string {
	return tea.Prettify(s)
}

func (s SearchDataTrackResultResponseBodyTrackResultEventList) GoString() string {
	return s.String()
}

func (s *SearchDataTrackResultResponseBodyTrackResultEventList) SetDataAfter(v []*string) *SearchDataTrackResultResponseBodyTrackResultEventList {
	s.DataAfter = v
	return s
}

func (s *SearchDataTrackResultResponseBodyTrackResultEventList) SetDataBefore(v []*string) *SearchDataTrackResultResponseBodyTrackResultEventList {
	s.DataBefore = v
	return s
}

func (s *SearchDataTrackResultResponseBodyTrackResultEventList) SetEventId(v int64) *SearchDataTrackResultResponseBodyTrackResultEventList {
	s.EventId = &v
	return s
}

func (s *SearchDataTrackResultResponseBodyTrackResultEventList) SetEventLength(v int64) *SearchDataTrackResultResponseBodyTrackResultEventList {
	s.EventLength = &v
	return s
}

func (s *SearchDataTrackResultResponseBodyTrackResultEventList) SetEventTimestamp(v string) *SearchDataTrackResultResponseBodyTrackResultEventList {
	s.EventTimestamp = &v
	return s
}

func (s *SearchDataTrackResultResponseBodyTrackResultEventList) SetEventType(v string) *SearchDataTrackResultResponseBodyTrackResultEventList {
	s.EventType = &v
	return s
}

func (s *SearchDataTrackResultResponseBodyTrackResultEventList) SetRollSQL(v string) *SearchDataTrackResultResponseBodyTrackResultEventList {
	s.RollSQL = &v
	return s
}

type SearchDataTrackResultResponseBodyTrackResultTableInfoList struct {
	// The information about columns.
	Columns []*SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns `json:"Columns,omitempty" xml:"Columns,omitempty" type:"Repeated"`
	// The description of the column.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the database.
	SchemaName *string `json:"SchemaName,omitempty" xml:"SchemaName,omitempty"`
	// The name of the table.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s SearchDataTrackResultResponseBodyTrackResultTableInfoList) String() string {
	return tea.Prettify(s)
}

func (s SearchDataTrackResultResponseBodyTrackResultTableInfoList) GoString() string {
	return s.String()
}

func (s *SearchDataTrackResultResponseBodyTrackResultTableInfoList) SetColumns(v []*SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns) *SearchDataTrackResultResponseBodyTrackResultTableInfoList {
	s.Columns = v
	return s
}

func (s *SearchDataTrackResultResponseBodyTrackResultTableInfoList) SetDescription(v string) *SearchDataTrackResultResponseBodyTrackResultTableInfoList {
	s.Description = &v
	return s
}

func (s *SearchDataTrackResultResponseBodyTrackResultTableInfoList) SetSchemaName(v string) *SearchDataTrackResultResponseBodyTrackResultTableInfoList {
	s.SchemaName = &v
	return s
}

func (s *SearchDataTrackResultResponseBodyTrackResultTableInfoList) SetTableName(v string) *SearchDataTrackResultResponseBodyTrackResultTableInfoList {
	s.TableName = &v
	return s
}

type SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns struct {
	// The name of the column.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The position of the column.
	ColumnPosition *int32 `json:"ColumnPosition,omitempty" xml:"ColumnPosition,omitempty"`
	// The data type of the column. Examples: BIGINT, INT, and VARCHAR.
	ColumnType *string `json:"ColumnType,omitempty" xml:"ColumnType,omitempty"`
	// Indicates whether the column is a virtual column. Valid values:
	//
	// *   **true**
	// *   **false**
	Fictive *bool `json:"Fictive,omitempty" xml:"Fictive,omitempty"`
}

func (s SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns) String() string {
	return tea.Prettify(s)
}

func (s SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns) GoString() string {
	return s.String()
}

func (s *SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns) SetColumnName(v string) *SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns {
	s.ColumnName = &v
	return s
}

func (s *SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns) SetColumnPosition(v int32) *SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns {
	s.ColumnPosition = &v
	return s
}

func (s *SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns) SetColumnType(v string) *SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns {
	s.ColumnType = &v
	return s
}

func (s *SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns) SetFictive(v bool) *SearchDataTrackResultResponseBodyTrackResultTableInfoListColumns {
	s.Fictive = &v
	return s
}

type SearchDataTrackResultResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SearchDataTrackResultResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SearchDataTrackResultResponse) String() string {
	return tea.Prettify(s)
}

func (s SearchDataTrackResultResponse) GoString() string {
	return s.String()
}

func (s *SearchDataTrackResultResponse) SetHeaders(v map[string]*string) *SearchDataTrackResultResponse {
	s.Headers = v
	return s
}

func (s *SearchDataTrackResultResponse) SetStatusCode(v int32) *SearchDataTrackResultResponse {
	s.StatusCode = &v
	return s
}

func (s *SearchDataTrackResultResponse) SetBody(v *SearchDataTrackResultResponseBody) *SearchDataTrackResultResponse {
	s.Body = v
	return s
}

type SearchDatabaseRequest struct {
	// The type of the database. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The environment type of the database. For more information, see [Change the environment type of an instance](~~163309~~).
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The keyword that is used to search for databases.
	SearchKey *string `json:"SearchKey,omitempty" xml:"SearchKey,omitempty"`
	// The query range based on permissions. Valid values:
	//
	// *   **HAS_PERMSSION**: searches for databases on which the current user has permissions.
	// *   **OWNER**: searches for databases owned by the current user.
	// *   **MY_FOCUS**: searches for databases that the current user follows.
	// *   **UNKNOWN**: searches for all databases.
	SearchRange *string `json:"SearchRange,omitempty" xml:"SearchRange,omitempty"`
	// The category of the database. Valid values:
	//
	// *   **DB**: single database or logical database.
	// *   **SINGLE_DB**: single database.
	// *   **LOGIC_DB**: logical database.
	SearchTarget *string `json:"SearchTarget,omitempty" xml:"SearchTarget,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s SearchDatabaseRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchDatabaseRequest) GoString() string {
	return s.String()
}

func (s *SearchDatabaseRequest) SetDbType(v string) *SearchDatabaseRequest {
	s.DbType = &v
	return s
}

func (s *SearchDatabaseRequest) SetEnvType(v string) *SearchDatabaseRequest {
	s.EnvType = &v
	return s
}

func (s *SearchDatabaseRequest) SetPageNumber(v int32) *SearchDatabaseRequest {
	s.PageNumber = &v
	return s
}

func (s *SearchDatabaseRequest) SetPageSize(v int32) *SearchDatabaseRequest {
	s.PageSize = &v
	return s
}

func (s *SearchDatabaseRequest) SetSearchKey(v string) *SearchDatabaseRequest {
	s.SearchKey = &v
	return s
}

func (s *SearchDatabaseRequest) SetSearchRange(v string) *SearchDatabaseRequest {
	s.SearchRange = &v
	return s
}

func (s *SearchDatabaseRequest) SetSearchTarget(v string) *SearchDatabaseRequest {
	s.SearchTarget = &v
	return s
}

func (s *SearchDatabaseRequest) SetTid(v int64) *SearchDatabaseRequest {
	s.Tid = &v
	return s
}

type SearchDatabaseResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the databases.
	SearchDatabaseList *SearchDatabaseResponseBodySearchDatabaseList `json:"SearchDatabaseList,omitempty" xml:"SearchDatabaseList,omitempty" type:"Struct"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**: The request is successful.
	// *   **false**: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of entries returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s SearchDatabaseResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SearchDatabaseResponseBody) GoString() string {
	return s.String()
}

func (s *SearchDatabaseResponseBody) SetErrorCode(v string) *SearchDatabaseResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *SearchDatabaseResponseBody) SetErrorMessage(v string) *SearchDatabaseResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *SearchDatabaseResponseBody) SetRequestId(v string) *SearchDatabaseResponseBody {
	s.RequestId = &v
	return s
}

func (s *SearchDatabaseResponseBody) SetSearchDatabaseList(v *SearchDatabaseResponseBodySearchDatabaseList) *SearchDatabaseResponseBody {
	s.SearchDatabaseList = v
	return s
}

func (s *SearchDatabaseResponseBody) SetSuccess(v bool) *SearchDatabaseResponseBody {
	s.Success = &v
	return s
}

func (s *SearchDatabaseResponseBody) SetTotalCount(v int64) *SearchDatabaseResponseBody {
	s.TotalCount = &v
	return s
}

type SearchDatabaseResponseBodySearchDatabaseList struct {
	SearchDatabase []*SearchDatabaseResponseBodySearchDatabaseListSearchDatabase `json:"SearchDatabase,omitempty" xml:"SearchDatabase,omitempty" type:"Repeated"`
}

func (s SearchDatabaseResponseBodySearchDatabaseList) String() string {
	return tea.Prettify(s)
}

func (s SearchDatabaseResponseBodySearchDatabaseList) GoString() string {
	return s.String()
}

func (s *SearchDatabaseResponseBodySearchDatabaseList) SetSearchDatabase(v []*SearchDatabaseResponseBodySearchDatabaseListSearchDatabase) *SearchDatabaseResponseBodySearchDatabaseList {
	s.SearchDatabase = v
	return s
}

type SearchDatabaseResponseBodySearchDatabaseListSearchDatabase struct {
	// The alias of the database.
	Alias *string `json:"Alias,omitempty" xml:"Alias,omitempty"`
	// The name of the catalog to which the database belongs.
	//
	// > If the type of the database engine is PostgreSQL, the name of the database is displayed.
	CatalogName *string `json:"CatalogName,omitempty" xml:"CatalogName,omitempty"`
	// The ID of the database.
	DatabaseId *string `json:"DatabaseId,omitempty" xml:"DatabaseId,omitempty"`
	// The name of the data link for cross-database queries.
	DatalinkName *string `json:"DatalinkName,omitempty" xml:"DatalinkName,omitempty"`
	// The type of the database engine.
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The ID of the user who assumes the database administrator (DBA) role.
	DbaId *string `json:"DbaId,omitempty" xml:"DbaId,omitempty"`
	// The encoding method of the database.
	Encoding *string `json:"Encoding,omitempty" xml:"Encoding,omitempty"`
	// The environment type of the database. For more information, see [Change the environment type of an instance](~~163309~~).
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The endpoint of the instance in which the database resides.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// Indicates whether the database is a logical database. Valid values:
	//
	// *   **true**: The database is a logical database.
	// *   **false**: The database is not a logical database.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The IDs of the owners of the databases.
	OwnerIdList *SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerIdList `json:"OwnerIdList,omitempty" xml:"OwnerIdList,omitempty" type:"Struct"`
	// The nicknames of the database owners.
	OwnerNameList *SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerNameList `json:"OwnerNameList,omitempty" xml:"OwnerNameList,omitempty" type:"Struct"`
	// The port of the instance in which the database resides.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The name of the database.
	SchemaName *string `json:"SchemaName,omitempty" xml:"SchemaName,omitempty"`
	// The name that is used to search for the database.
	SearchName *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
	// The system ID (SID) of the instance in which the database resides.
	Sid *string `json:"Sid,omitempty" xml:"Sid,omitempty"`
}

func (s SearchDatabaseResponseBodySearchDatabaseListSearchDatabase) String() string {
	return tea.Prettify(s)
}

func (s SearchDatabaseResponseBodySearchDatabaseListSearchDatabase) GoString() string {
	return s.String()
}

func (s *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase) SetAlias(v string) *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase {
	s.Alias = &v
	return s
}

func (s *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase) SetCatalogName(v string) *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase {
	s.CatalogName = &v
	return s
}

func (s *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase) SetDatabaseId(v string) *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase {
	s.DatabaseId = &v
	return s
}

func (s *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase) SetDatalinkName(v string) *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase {
	s.DatalinkName = &v
	return s
}

func (s *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase) SetDbType(v string) *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase {
	s.DbType = &v
	return s
}

func (s *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase) SetDbaId(v string) *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase {
	s.DbaId = &v
	return s
}

func (s *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase) SetEncoding(v string) *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase {
	s.Encoding = &v
	return s
}

func (s *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase) SetEnvType(v string) *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase {
	s.EnvType = &v
	return s
}

func (s *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase) SetHost(v string) *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase {
	s.Host = &v
	return s
}

func (s *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase) SetLogic(v bool) *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase {
	s.Logic = &v
	return s
}

func (s *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase) SetOwnerIdList(v *SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerIdList) *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase {
	s.OwnerIdList = v
	return s
}

func (s *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase) SetOwnerNameList(v *SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerNameList) *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase {
	s.OwnerNameList = v
	return s
}

func (s *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase) SetPort(v int32) *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase {
	s.Port = &v
	return s
}

func (s *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase) SetSchemaName(v string) *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase {
	s.SchemaName = &v
	return s
}

func (s *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase) SetSearchName(v string) *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase {
	s.SearchName = &v
	return s
}

func (s *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase) SetSid(v string) *SearchDatabaseResponseBodySearchDatabaseListSearchDatabase {
	s.Sid = &v
	return s
}

type SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerIdList struct {
	OwnerIds []*string `json:"OwnerIds,omitempty" xml:"OwnerIds,omitempty" type:"Repeated"`
}

func (s SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerIdList) String() string {
	return tea.Prettify(s)
}

func (s SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerIdList) GoString() string {
	return s.String()
}

func (s *SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerIdList) SetOwnerIds(v []*string) *SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerIdList {
	s.OwnerIds = v
	return s
}

type SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerNameList struct {
	OwnerNames []*string `json:"OwnerNames,omitempty" xml:"OwnerNames,omitempty" type:"Repeated"`
}

func (s SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerNameList) String() string {
	return tea.Prettify(s)
}

func (s SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerNameList) GoString() string {
	return s.String()
}

func (s *SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerNameList) SetOwnerNames(v []*string) *SearchDatabaseResponseBodySearchDatabaseListSearchDatabaseOwnerNameList {
	s.OwnerNames = v
	return s
}

type SearchDatabaseResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SearchDatabaseResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SearchDatabaseResponse) String() string {
	return tea.Prettify(s)
}

func (s SearchDatabaseResponse) GoString() string {
	return s.String()
}

func (s *SearchDatabaseResponse) SetHeaders(v map[string]*string) *SearchDatabaseResponse {
	s.Headers = v
	return s
}

func (s *SearchDatabaseResponse) SetStatusCode(v int32) *SearchDatabaseResponse {
	s.StatusCode = &v
	return s
}

func (s *SearchDatabaseResponse) SetBody(v *SearchDatabaseResponseBody) *SearchDatabaseResponse {
	s.Body = v
	return s
}

type SearchTableRequest struct {
	// The type of database. Valid values:
	//
	// *   **MySQL**
	// *   **SQLServer**
	// *   **PostgreSQL**
	// *   **Oracle**
	// *   **DRDS**
	// *   **OceanBase**
	// *   **Mongo**
	// *   **Redis**
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The type of the environment to which databases belong. For more information, see [Change the environment type of an instance](~~163309~~).
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// Specifies whether to return the GUID of each table.
	ReturnGuid *bool `json:"ReturnGuid,omitempty" xml:"ReturnGuid,omitempty"`
	// The keyword that is used to query tables.
	SearchKey *string `json:"SearchKey,omitempty" xml:"SearchKey,omitempty"`
	// The scope of tables that you want to query. Valid values:
	//
	// *   **HAS_PERMSSION**: the tables on which the current account has permissions.
	// *   **OWNER**: the tables owned by the current account.
	// *   **MY_FOCUS**: the tables that the current account follows.
	// *   **UNKNOWN**: all tables.
	SearchRange *string `json:"SearchRange,omitempty" xml:"SearchRange,omitempty"`
	// The type of table that you want to query. Valid values:
	//
	// *   **TABLE**: physical and logical tables
	// *   **SINGLE_TABLE**: physical tables
	// *   **LOGIC_TABLE**: logical tables
	SearchTarget *string `json:"SearchTarget,omitempty" xml:"SearchTarget,omitempty"`
	// The ID of the tenant.
	//
	// > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the [View information about the current tenant](~~181330~~) section of the "Manage DMS tenants" topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s SearchTableRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchTableRequest) GoString() string {
	return s.String()
}

func (s *SearchTableRequest) SetDbType(v string) *SearchTableRequest {
	s.DbType = &v
	return s
}

func (s *SearchTableRequest) SetEnvType(v string) *SearchTableRequest {
	s.EnvType = &v
	return s
}

func (s *SearchTableRequest) SetPageNumber(v int32) *SearchTableRequest {
	s.PageNumber = &v
	return s
}

func (s *SearchTableRequest) SetPageSize(v int32) *SearchTableRequest {
	s.PageSize = &v
	return s
}

func (s *SearchTableRequest) SetReturnGuid(v bool) *SearchTableRequest {
	s.ReturnGuid = &v
	return s
}

func (s *SearchTableRequest) SetSearchKey(v string) *SearchTableRequest {
	s.SearchKey = &v
	return s
}

func (s *SearchTableRequest) SetSearchRange(v string) *SearchTableRequest {
	s.SearchRange = &v
	return s
}

func (s *SearchTableRequest) SetSearchTarget(v string) *SearchTableRequest {
	s.SearchTarget = &v
	return s
}

func (s *SearchTableRequest) SetTid(v int64) *SearchTableRequest {
	s.Tid = &v
	return s
}

type SearchTableResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The details of the tables.
	SearchTableList *SearchTableResponseBodySearchTableList `json:"SearchTableList,omitempty" xml:"SearchTableList,omitempty" type:"Struct"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of entries that are returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s SearchTableResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SearchTableResponseBody) GoString() string {
	return s.String()
}

func (s *SearchTableResponseBody) SetErrorCode(v string) *SearchTableResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *SearchTableResponseBody) SetErrorMessage(v string) *SearchTableResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *SearchTableResponseBody) SetRequestId(v string) *SearchTableResponseBody {
	s.RequestId = &v
	return s
}

func (s *SearchTableResponseBody) SetSearchTableList(v *SearchTableResponseBodySearchTableList) *SearchTableResponseBody {
	s.SearchTableList = v
	return s
}

func (s *SearchTableResponseBody) SetSuccess(v bool) *SearchTableResponseBody {
	s.Success = &v
	return s
}

func (s *SearchTableResponseBody) SetTotalCount(v int64) *SearchTableResponseBody {
	s.TotalCount = &v
	return s
}

type SearchTableResponseBodySearchTableList struct {
	SearchTable []*SearchTableResponseBodySearchTableListSearchTable `json:"SearchTable,omitempty" xml:"SearchTable,omitempty" type:"Repeated"`
}

func (s SearchTableResponseBodySearchTableList) String() string {
	return tea.Prettify(s)
}

func (s SearchTableResponseBodySearchTableList) GoString() string {
	return s.String()
}

func (s *SearchTableResponseBodySearchTableList) SetSearchTable(v []*SearchTableResponseBodySearchTableListSearchTable) *SearchTableResponseBodySearchTableList {
	s.SearchTable = v
	return s
}

type SearchTableResponseBodySearchTableListSearchTable struct {
	// The name that is used to search for the database to which the table belongs.
	DBSearchName *string `json:"DBSearchName,omitempty" xml:"DBSearchName,omitempty"`
	// The ID of the database to which the table belongs.
	DatabaseId *string `json:"DatabaseId,omitempty" xml:"DatabaseId,omitempty"`
	// The name of the database.
	DbName *string `json:"DbName,omitempty" xml:"DbName,omitempty"`
	// The type of the database. Valid values:
	//
	// *   **MySQL**
	// *   **SQLServer**
	// *   **PostgreSQL**
	// *   **Oracle**
	// *   **DRDS**
	// *   **OceanBase**
	// *   **Mongo**
	// *   **Redis**
	DbType *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	// The description of the table.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The encoding format of the table.
	Encoding *string `json:"Encoding,omitempty" xml:"Encoding,omitempty"`
	// The engine of the table.
	Engine *string `json:"Engine,omitempty" xml:"Engine,omitempty"`
	// The type of the environment to which the database belongs.
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// Indicates whether the table is a logical table. Valid values:
	//
	// *   **true**: The table is a logical table.
	// *   **false**: The table is not a logical table.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The IDs of the table owners.
	OwnerIdList *SearchTableResponseBodySearchTableListSearchTableOwnerIdList `json:"OwnerIdList,omitempty" xml:"OwnerIdList,omitempty" type:"Struct"`
	// The nicknames of the table owners.
	OwnerNameList *SearchTableResponseBodySearchTableListSearchTableOwnerNameList `json:"OwnerNameList,omitempty" xml:"OwnerNameList,omitempty" type:"Struct"`
	// The GUID of the table.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
	// The ID of the table.
	TableId *string `json:"TableId,omitempty" xml:"TableId,omitempty"`
	// The name of the table.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	// The name of the database to which the table belongs.
	TableSchemaName *string `json:"TableSchemaName,omitempty" xml:"TableSchemaName,omitempty"`
}

func (s SearchTableResponseBodySearchTableListSearchTable) String() string {
	return tea.Prettify(s)
}

func (s SearchTableResponseBodySearchTableListSearchTable) GoString() string {
	return s.String()
}

func (s *SearchTableResponseBodySearchTableListSearchTable) SetDBSearchName(v string) *SearchTableResponseBodySearchTableListSearchTable {
	s.DBSearchName = &v
	return s
}

func (s *SearchTableResponseBodySearchTableListSearchTable) SetDatabaseId(v string) *SearchTableResponseBodySearchTableListSearchTable {
	s.DatabaseId = &v
	return s
}

func (s *SearchTableResponseBodySearchTableListSearchTable) SetDbName(v string) *SearchTableResponseBodySearchTableListSearchTable {
	s.DbName = &v
	return s
}

func (s *SearchTableResponseBodySearchTableListSearchTable) SetDbType(v string) *SearchTableResponseBodySearchTableListSearchTable {
	s.DbType = &v
	return s
}

func (s *SearchTableResponseBodySearchTableListSearchTable) SetDescription(v string) *SearchTableResponseBodySearchTableListSearchTable {
	s.Description = &v
	return s
}

func (s *SearchTableResponseBodySearchTableListSearchTable) SetEncoding(v string) *SearchTableResponseBodySearchTableListSearchTable {
	s.Encoding = &v
	return s
}

func (s *SearchTableResponseBodySearchTableListSearchTable) SetEngine(v string) *SearchTableResponseBodySearchTableListSearchTable {
	s.Engine = &v
	return s
}

func (s *SearchTableResponseBodySearchTableListSearchTable) SetEnvType(v string) *SearchTableResponseBodySearchTableListSearchTable {
	s.EnvType = &v
	return s
}

func (s *SearchTableResponseBodySearchTableListSearchTable) SetLogic(v bool) *SearchTableResponseBodySearchTableListSearchTable {
	s.Logic = &v
	return s
}

func (s *SearchTableResponseBodySearchTableListSearchTable) SetOwnerIdList(v *SearchTableResponseBodySearchTableListSearchTableOwnerIdList) *SearchTableResponseBodySearchTableListSearchTable {
	s.OwnerIdList = v
	return s
}

func (s *SearchTableResponseBodySearchTableListSearchTable) SetOwnerNameList(v *SearchTableResponseBodySearchTableListSearchTableOwnerNameList) *SearchTableResponseBodySearchTableListSearchTable {
	s.OwnerNameList = v
	return s
}

func (s *SearchTableResponseBodySearchTableListSearchTable) SetTableGuid(v string) *SearchTableResponseBodySearchTableListSearchTable {
	s.TableGuid = &v
	return s
}

func (s *SearchTableResponseBodySearchTableListSearchTable) SetTableId(v string) *SearchTableResponseBodySearchTableListSearchTable {
	s.TableId = &v
	return s
}

func (s *SearchTableResponseBodySearchTableListSearchTable) SetTableName(v string) *SearchTableResponseBodySearchTableListSearchTable {
	s.TableName = &v
	return s
}

func (s *SearchTableResponseBodySearchTableListSearchTable) SetTableSchemaName(v string) *SearchTableResponseBodySearchTableListSearchTable {
	s.TableSchemaName = &v
	return s
}

type SearchTableResponseBodySearchTableListSearchTableOwnerIdList struct {
	OwnerIds []*string `json:"OwnerIds,omitempty" xml:"OwnerIds,omitempty" type:"Repeated"`
}

func (s SearchTableResponseBodySearchTableListSearchTableOwnerIdList) String() string {
	return tea.Prettify(s)
}

func (s SearchTableResponseBodySearchTableListSearchTableOwnerIdList) GoString() string {
	return s.String()
}

func (s *SearchTableResponseBodySearchTableListSearchTableOwnerIdList) SetOwnerIds(v []*string) *SearchTableResponseBodySearchTableListSearchTableOwnerIdList {
	s.OwnerIds = v
	return s
}

type SearchTableResponseBodySearchTableListSearchTableOwnerNameList struct {
	OwnerNames []*string `json:"OwnerNames,omitempty" xml:"OwnerNames,omitempty" type:"Repeated"`
}

func (s SearchTableResponseBodySearchTableListSearchTableOwnerNameList) String() string {
	return tea.Prettify(s)
}

func (s SearchTableResponseBodySearchTableListSearchTableOwnerNameList) GoString() string {
	return s.String()
}

func (s *SearchTableResponseBodySearchTableListSearchTableOwnerNameList) SetOwnerNames(v []*string) *SearchTableResponseBodySearchTableListSearchTableOwnerNameList {
	s.OwnerNames = v
	return s
}

type SearchTableResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SearchTableResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SearchTableResponse) String() string {
	return tea.Prettify(s)
}

func (s SearchTableResponse) GoString() string {
	return s.String()
}

func (s *SearchTableResponse) SetHeaders(v map[string]*string) *SearchTableResponse {
	s.Headers = v
	return s
}

func (s *SearchTableResponse) SetStatusCode(v int32) *SearchTableResponse {
	s.StatusCode = &v
	return s
}

func (s *SearchTableResponse) SetBody(v *SearchTableResponseBody) *SearchTableResponse {
	s.Body = v
	return s
}

type SetOwnersRequest struct {
	// The ID of the user whom you want to specify as an owner. Separate multiple IDs with commas (,). You can call the [GetUser](~~147098~~) or [ListUsers](~~141938~~) operation to query the ID of the user.
	//
	// >  The value of the OwnerIds parameter is that of the UserId parameter.
	OwnerIds *string `json:"OwnerIds,omitempty" xml:"OwnerIds,omitempty"`
	// The type of the owner. Valid values:
	//
	// *   INSTANCE: an owner of an instance.
	// *   DATABASE: an owner of a physical database.
	// *   LOGIC_DATABASE: an owner of a logical database.
	// *   TABLE: an owner of a physical table.
	// *   LOGIC_TABLE: an owner of a logical table.
	OwnerType *string `json:"OwnerType,omitempty" xml:"OwnerType,omitempty"`
	// The ID of the resource. The ID of the resource varies with the owner type. The owner types and resource IDs have the following mappings:
	//
	// *   INSTANCE: the ID of an instance. You can call the [ListInstances](~~141936~~) operation to query the ID of the instance.
	// *   DATABASE: the ID of a physical database. You can call the [ListDatabases](~~141873~~) operation to query the ID of the physical database.
	// *   LOGIC_DATABASE: the ID of a logical database. You can call the [ListLogicDatabases](~~141874~~) operation to query the ID of the logical database.
	// *   TABLE: the ID of a physical table. You can call the [ListTables](~~141878~~) operation to query the ID of the physical table.
	// *   LOGIC_DATABASE: the ID of a logical table. You can call the [ListLogicTables](~~141875~~) operation to query the ID of the logical table.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The ID of the tenant.
	//
	// >  To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the "View information about the current tenant" section of the [Manage DMS tenants](~~181330~~) topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s SetOwnersRequest) String() string {
	return tea.Prettify(s)
}

func (s SetOwnersRequest) GoString() string {
	return s.String()
}

func (s *SetOwnersRequest) SetOwnerIds(v string) *SetOwnersRequest {
	s.OwnerIds = &v
	return s
}

func (s *SetOwnersRequest) SetOwnerType(v string) *SetOwnersRequest {
	s.OwnerType = &v
	return s
}

func (s *SetOwnersRequest) SetResourceId(v string) *SetOwnersRequest {
	s.ResourceId = &v
	return s
}

func (s *SetOwnersRequest) SetTid(v int64) *SetOwnersRequest {
	s.Tid = &v
	return s
}

type SetOwnersResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   true: The request is successful.
	// *   false: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SetOwnersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetOwnersResponseBody) GoString() string {
	return s.String()
}

func (s *SetOwnersResponseBody) SetErrorCode(v string) *SetOwnersResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *SetOwnersResponseBody) SetErrorMessage(v string) *SetOwnersResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *SetOwnersResponseBody) SetRequestId(v string) *SetOwnersResponseBody {
	s.RequestId = &v
	return s
}

func (s *SetOwnersResponseBody) SetSuccess(v bool) *SetOwnersResponseBody {
	s.Success = &v
	return s
}

type SetOwnersResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetOwnersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetOwnersResponse) String() string {
	return tea.Prettify(s)
}

func (s SetOwnersResponse) GoString() string {
	return s.String()
}

func (s *SetOwnersResponse) SetHeaders(v map[string]*string) *SetOwnersResponse {
	s.Headers = v
	return s
}

func (s *SetOwnersResponse) SetStatusCode(v int32) *SetOwnersResponse {
	s.StatusCode = &v
	return s
}

func (s *SetOwnersResponse) SetBody(v *SetOwnersResponseBody) *SetOwnersResponse {
	s.Body = v
	return s
}

type SkipDataCorrectRowCheckRequest struct {
	// The ticket ID. You can call the [ListOrders](~~144643~~) operation to obtain the ticket ID.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The reason for skipping the verification on the number of rows in the precheck for data change.
	Reason *string `json:"Reason,omitempty" xml:"Reason,omitempty"`
	// The tenant ID. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to obtain the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s SkipDataCorrectRowCheckRequest) String() string {
	return tea.Prettify(s)
}

func (s SkipDataCorrectRowCheckRequest) GoString() string {
	return s.String()
}

func (s *SkipDataCorrectRowCheckRequest) SetOrderId(v int64) *SkipDataCorrectRowCheckRequest {
	s.OrderId = &v
	return s
}

func (s *SkipDataCorrectRowCheckRequest) SetReason(v string) *SkipDataCorrectRowCheckRequest {
	s.Reason = &v
	return s
}

func (s *SkipDataCorrectRowCheckRequest) SetTid(v int64) *SkipDataCorrectRowCheckRequest {
	s.Tid = &v
	return s
}

type SkipDataCorrectRowCheckResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SkipDataCorrectRowCheckResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SkipDataCorrectRowCheckResponseBody) GoString() string {
	return s.String()
}

func (s *SkipDataCorrectRowCheckResponseBody) SetErrorCode(v string) *SkipDataCorrectRowCheckResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *SkipDataCorrectRowCheckResponseBody) SetErrorMessage(v string) *SkipDataCorrectRowCheckResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *SkipDataCorrectRowCheckResponseBody) SetRequestId(v string) *SkipDataCorrectRowCheckResponseBody {
	s.RequestId = &v
	return s
}

func (s *SkipDataCorrectRowCheckResponseBody) SetSuccess(v bool) *SkipDataCorrectRowCheckResponseBody {
	s.Success = &v
	return s
}

type SkipDataCorrectRowCheckResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SkipDataCorrectRowCheckResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SkipDataCorrectRowCheckResponse) String() string {
	return tea.Prettify(s)
}

func (s SkipDataCorrectRowCheckResponse) GoString() string {
	return s.String()
}

func (s *SkipDataCorrectRowCheckResponse) SetHeaders(v map[string]*string) *SkipDataCorrectRowCheckResponse {
	s.Headers = v
	return s
}

func (s *SkipDataCorrectRowCheckResponse) SetStatusCode(v int32) *SkipDataCorrectRowCheckResponse {
	s.StatusCode = &v
	return s
}

func (s *SkipDataCorrectRowCheckResponse) SetBody(v *SkipDataCorrectRowCheckResponseBody) *SkipDataCorrectRowCheckResponse {
	s.Body = v
	return s
}

type StopTaskFlowInstanceRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the execution record of the task flow. You can call the [ListTaskFlowInstance](~~424689~~) operation to query the execution record ID.
	DagInstanceId *int64 `json:"DagInstanceId,omitempty" xml:"DagInstanceId,omitempty"`
	// The ID of the tenant.
	//
	// > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s StopTaskFlowInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s StopTaskFlowInstanceRequest) GoString() string {
	return s.String()
}

func (s *StopTaskFlowInstanceRequest) SetDagId(v int64) *StopTaskFlowInstanceRequest {
	s.DagId = &v
	return s
}

func (s *StopTaskFlowInstanceRequest) SetDagInstanceId(v int64) *StopTaskFlowInstanceRequest {
	s.DagInstanceId = &v
	return s
}

func (s *StopTaskFlowInstanceRequest) SetTid(v int64) *StopTaskFlowInstanceRequest {
	s.Tid = &v
	return s
}

type StopTaskFlowInstanceResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s StopTaskFlowInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StopTaskFlowInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *StopTaskFlowInstanceResponseBody) SetErrorCode(v string) *StopTaskFlowInstanceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *StopTaskFlowInstanceResponseBody) SetErrorMessage(v string) *StopTaskFlowInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *StopTaskFlowInstanceResponseBody) SetRequestId(v string) *StopTaskFlowInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *StopTaskFlowInstanceResponseBody) SetSuccess(v bool) *StopTaskFlowInstanceResponseBody {
	s.Success = &v
	return s
}

type StopTaskFlowInstanceResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *StopTaskFlowInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s StopTaskFlowInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s StopTaskFlowInstanceResponse) GoString() string {
	return s.String()
}

func (s *StopTaskFlowInstanceResponse) SetHeaders(v map[string]*string) *StopTaskFlowInstanceResponse {
	s.Headers = v
	return s
}

func (s *StopTaskFlowInstanceResponse) SetStatusCode(v int32) *StopTaskFlowInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *StopTaskFlowInstanceResponse) SetBody(v *StopTaskFlowInstanceResponseBody) *StopTaskFlowInstanceResponse {
	s.Body = v
	return s
}

type SubmitOrderApprovalRequest struct {
	// The ID of the ticket.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant.
	//
	// > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s SubmitOrderApprovalRequest) String() string {
	return tea.Prettify(s)
}

func (s SubmitOrderApprovalRequest) GoString() string {
	return s.String()
}

func (s *SubmitOrderApprovalRequest) SetOrderId(v int64) *SubmitOrderApprovalRequest {
	s.OrderId = &v
	return s
}

func (s *SubmitOrderApprovalRequest) SetTid(v int64) *SubmitOrderApprovalRequest {
	s.Tid = &v
	return s
}

type SubmitOrderApprovalResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SubmitOrderApprovalResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SubmitOrderApprovalResponseBody) GoString() string {
	return s.String()
}

func (s *SubmitOrderApprovalResponseBody) SetErrorCode(v string) *SubmitOrderApprovalResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *SubmitOrderApprovalResponseBody) SetErrorMessage(v string) *SubmitOrderApprovalResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *SubmitOrderApprovalResponseBody) SetRequestId(v string) *SubmitOrderApprovalResponseBody {
	s.RequestId = &v
	return s
}

func (s *SubmitOrderApprovalResponseBody) SetSuccess(v bool) *SubmitOrderApprovalResponseBody {
	s.Success = &v
	return s
}

type SubmitOrderApprovalResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SubmitOrderApprovalResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SubmitOrderApprovalResponse) String() string {
	return tea.Prettify(s)
}

func (s SubmitOrderApprovalResponse) GoString() string {
	return s.String()
}

func (s *SubmitOrderApprovalResponse) SetHeaders(v map[string]*string) *SubmitOrderApprovalResponse {
	s.Headers = v
	return s
}

func (s *SubmitOrderApprovalResponse) SetStatusCode(v int32) *SubmitOrderApprovalResponse {
	s.StatusCode = &v
	return s
}

func (s *SubmitOrderApprovalResponse) SetBody(v *SubmitOrderApprovalResponseBody) *SubmitOrderApprovalResponse {
	s.Body = v
	return s
}

type SubmitStructSyncOrderApprovalRequest struct {
	// The ID of the ticket.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the tenant.
	//
	// > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s SubmitStructSyncOrderApprovalRequest) String() string {
	return tea.Prettify(s)
}

func (s SubmitStructSyncOrderApprovalRequest) GoString() string {
	return s.String()
}

func (s *SubmitStructSyncOrderApprovalRequest) SetOrderId(v int64) *SubmitStructSyncOrderApprovalRequest {
	s.OrderId = &v
	return s
}

func (s *SubmitStructSyncOrderApprovalRequest) SetTid(v int64) *SubmitStructSyncOrderApprovalRequest {
	s.Tid = &v
	return s
}

type SubmitStructSyncOrderApprovalResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The ID of the approval process.
	WorkflowInstanceId *int64 `json:"WorkflowInstanceId,omitempty" xml:"WorkflowInstanceId,omitempty"`
}

func (s SubmitStructSyncOrderApprovalResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SubmitStructSyncOrderApprovalResponseBody) GoString() string {
	return s.String()
}

func (s *SubmitStructSyncOrderApprovalResponseBody) SetErrorCode(v string) *SubmitStructSyncOrderApprovalResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *SubmitStructSyncOrderApprovalResponseBody) SetErrorMessage(v string) *SubmitStructSyncOrderApprovalResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *SubmitStructSyncOrderApprovalResponseBody) SetRequestId(v string) *SubmitStructSyncOrderApprovalResponseBody {
	s.RequestId = &v
	return s
}

func (s *SubmitStructSyncOrderApprovalResponseBody) SetSuccess(v bool) *SubmitStructSyncOrderApprovalResponseBody {
	s.Success = &v
	return s
}

func (s *SubmitStructSyncOrderApprovalResponseBody) SetWorkflowInstanceId(v int64) *SubmitStructSyncOrderApprovalResponseBody {
	s.WorkflowInstanceId = &v
	return s
}

type SubmitStructSyncOrderApprovalResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SubmitStructSyncOrderApprovalResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SubmitStructSyncOrderApprovalResponse) String() string {
	return tea.Prettify(s)
}

func (s SubmitStructSyncOrderApprovalResponse) GoString() string {
	return s.String()
}

func (s *SubmitStructSyncOrderApprovalResponse) SetHeaders(v map[string]*string) *SubmitStructSyncOrderApprovalResponse {
	s.Headers = v
	return s
}

func (s *SubmitStructSyncOrderApprovalResponse) SetStatusCode(v int32) *SubmitStructSyncOrderApprovalResponse {
	s.StatusCode = &v
	return s
}

func (s *SubmitStructSyncOrderApprovalResponse) SetBody(v *SubmitStructSyncOrderApprovalResponseBody) *SubmitStructSyncOrderApprovalResponse {
	s.Body = v
	return s
}

type SuspendTaskFlowInstanceRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the execution record of the task flow. You can call the [ListTaskFlowInstance](~~424689~~) operation to query the execution record ID.
	DagInstanceId *int64 `json:"DagInstanceId,omitempty" xml:"DagInstanceId,omitempty"`
	// The ID of the tenant.
	//
	// > To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s SuspendTaskFlowInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s SuspendTaskFlowInstanceRequest) GoString() string {
	return s.String()
}

func (s *SuspendTaskFlowInstanceRequest) SetDagId(v int64) *SuspendTaskFlowInstanceRequest {
	s.DagId = &v
	return s
}

func (s *SuspendTaskFlowInstanceRequest) SetDagInstanceId(v int64) *SuspendTaskFlowInstanceRequest {
	s.DagInstanceId = &v
	return s
}

func (s *SuspendTaskFlowInstanceRequest) SetTid(v int64) *SuspendTaskFlowInstanceRequest {
	s.Tid = &v
	return s
}

type SuspendTaskFlowInstanceResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SuspendTaskFlowInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SuspendTaskFlowInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *SuspendTaskFlowInstanceResponseBody) SetErrorCode(v string) *SuspendTaskFlowInstanceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *SuspendTaskFlowInstanceResponseBody) SetErrorMessage(v string) *SuspendTaskFlowInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *SuspendTaskFlowInstanceResponseBody) SetRequestId(v string) *SuspendTaskFlowInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *SuspendTaskFlowInstanceResponseBody) SetSuccess(v bool) *SuspendTaskFlowInstanceResponseBody {
	s.Success = &v
	return s
}

type SuspendTaskFlowInstanceResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SuspendTaskFlowInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SuspendTaskFlowInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s SuspendTaskFlowInstanceResponse) GoString() string {
	return s.String()
}

func (s *SuspendTaskFlowInstanceResponse) SetHeaders(v map[string]*string) *SuspendTaskFlowInstanceResponse {
	s.Headers = v
	return s
}

func (s *SuspendTaskFlowInstanceResponse) SetStatusCode(v int32) *SuspendTaskFlowInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *SuspendTaskFlowInstanceResponse) SetBody(v *SuspendTaskFlowInstanceResponseBody) *SuspendTaskFlowInstanceResponse {
	s.Body = v
	return s
}

type SyncDatabaseMetaRequest struct {
	// The ID of the database.
	DbId *string `json:"DbId,omitempty" xml:"DbId,omitempty"`
	// Specifies whether the database is a logical database.
	Logic *bool `json:"Logic,omitempty" xml:"Logic,omitempty"`
	// The ID of the tenant.
	//
	// > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s SyncDatabaseMetaRequest) String() string {
	return tea.Prettify(s)
}

func (s SyncDatabaseMetaRequest) GoString() string {
	return s.String()
}

func (s *SyncDatabaseMetaRequest) SetDbId(v string) *SyncDatabaseMetaRequest {
	s.DbId = &v
	return s
}

func (s *SyncDatabaseMetaRequest) SetLogic(v bool) *SyncDatabaseMetaRequest {
	s.Logic = &v
	return s
}

func (s *SyncDatabaseMetaRequest) SetTid(v int64) *SyncDatabaseMetaRequest {
	s.Tid = &v
	return s
}

type SyncDatabaseMetaResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SyncDatabaseMetaResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SyncDatabaseMetaResponseBody) GoString() string {
	return s.String()
}

func (s *SyncDatabaseMetaResponseBody) SetErrorCode(v string) *SyncDatabaseMetaResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *SyncDatabaseMetaResponseBody) SetErrorMessage(v string) *SyncDatabaseMetaResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *SyncDatabaseMetaResponseBody) SetRequestId(v string) *SyncDatabaseMetaResponseBody {
	s.RequestId = &v
	return s
}

func (s *SyncDatabaseMetaResponseBody) SetSuccess(v bool) *SyncDatabaseMetaResponseBody {
	s.Success = &v
	return s
}

type SyncDatabaseMetaResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SyncDatabaseMetaResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SyncDatabaseMetaResponse) String() string {
	return tea.Prettify(s)
}

func (s SyncDatabaseMetaResponse) GoString() string {
	return s.String()
}

func (s *SyncDatabaseMetaResponse) SetHeaders(v map[string]*string) *SyncDatabaseMetaResponse {
	s.Headers = v
	return s
}

func (s *SyncDatabaseMetaResponse) SetStatusCode(v int32) *SyncDatabaseMetaResponse {
	s.StatusCode = &v
	return s
}

func (s *SyncDatabaseMetaResponse) SetBody(v *SyncDatabaseMetaResponseBody) *SyncDatabaseMetaResponse {
	s.Body = v
	return s
}

type SyncInstanceMetaRequest struct {
	// Specifies whether to skip synchronization for the metadata of table dictionaries. Valid values:
	//
	// *   **true**
	// *   **false**
	IgnoreTable *bool `json:"IgnoreTable,omitempty" xml:"IgnoreTable,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the tenant.
	//
	// > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the [View information about the current tenant](~~181330~~) section of the Manage DMS tenants topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s SyncInstanceMetaRequest) String() string {
	return tea.Prettify(s)
}

func (s SyncInstanceMetaRequest) GoString() string {
	return s.String()
}

func (s *SyncInstanceMetaRequest) SetIgnoreTable(v bool) *SyncInstanceMetaRequest {
	s.IgnoreTable = &v
	return s
}

func (s *SyncInstanceMetaRequest) SetInstanceId(v string) *SyncInstanceMetaRequest {
	s.InstanceId = &v
	return s
}

func (s *SyncInstanceMetaRequest) SetTid(v int64) *SyncInstanceMetaRequest {
	s.Tid = &v
	return s
}

type SyncInstanceMetaResponseBody struct {
	// Details about the topology of the data table.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error code returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SyncInstanceMetaResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SyncInstanceMetaResponseBody) GoString() string {
	return s.String()
}

func (s *SyncInstanceMetaResponseBody) SetErrorCode(v string) *SyncInstanceMetaResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *SyncInstanceMetaResponseBody) SetErrorMessage(v string) *SyncInstanceMetaResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *SyncInstanceMetaResponseBody) SetRequestId(v string) *SyncInstanceMetaResponseBody {
	s.RequestId = &v
	return s
}

func (s *SyncInstanceMetaResponseBody) SetSuccess(v bool) *SyncInstanceMetaResponseBody {
	s.Success = &v
	return s
}

type SyncInstanceMetaResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SyncInstanceMetaResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SyncInstanceMetaResponse) String() string {
	return tea.Prettify(s)
}

func (s SyncInstanceMetaResponse) GoString() string {
	return s.String()
}

func (s *SyncInstanceMetaResponse) SetHeaders(v map[string]*string) *SyncInstanceMetaResponse {
	s.Headers = v
	return s
}

func (s *SyncInstanceMetaResponse) SetStatusCode(v int32) *SyncInstanceMetaResponse {
	s.StatusCode = &v
	return s
}

func (s *SyncInstanceMetaResponse) SetBody(v *SyncInstanceMetaResponseBody) *SyncInstanceMetaResponse {
	s.Body = v
	return s
}

type UpdateAuthorityTemplateRequest struct {
	// The description of the permission template.
	//
	// >  You must specify the Name or Description parameter. Otherwise, the API call fails.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the permission template.
	//
	// >  You must specify the Name or Description parameter. Otherwise, the API call fails.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the permission template.
	TemplateId *int64 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s UpdateAuthorityTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAuthorityTemplateRequest) GoString() string {
	return s.String()
}

func (s *UpdateAuthorityTemplateRequest) SetDescription(v string) *UpdateAuthorityTemplateRequest {
	s.Description = &v
	return s
}

func (s *UpdateAuthorityTemplateRequest) SetName(v string) *UpdateAuthorityTemplateRequest {
	s.Name = &v
	return s
}

func (s *UpdateAuthorityTemplateRequest) SetTemplateId(v int64) *UpdateAuthorityTemplateRequest {
	s.TemplateId = &v
	return s
}

func (s *UpdateAuthorityTemplateRequest) SetTid(v int64) *UpdateAuthorityTemplateRequest {
	s.Tid = &v
	return s
}

type UpdateAuthorityTemplateResponseBody struct {
	// The details of the permission template.
	AuthorityTemplateView *UpdateAuthorityTemplateResponseBodyAuthorityTemplateView `json:"AuthorityTemplateView,omitempty" xml:"AuthorityTemplateView,omitempty" type:"Struct"`
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The ID of the tenant.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s UpdateAuthorityTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateAuthorityTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateAuthorityTemplateResponseBody) SetAuthorityTemplateView(v *UpdateAuthorityTemplateResponseBodyAuthorityTemplateView) *UpdateAuthorityTemplateResponseBody {
	s.AuthorityTemplateView = v
	return s
}

func (s *UpdateAuthorityTemplateResponseBody) SetErrorCode(v string) *UpdateAuthorityTemplateResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateAuthorityTemplateResponseBody) SetErrorMessage(v string) *UpdateAuthorityTemplateResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateAuthorityTemplateResponseBody) SetRequestId(v string) *UpdateAuthorityTemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateAuthorityTemplateResponseBody) SetSuccess(v bool) *UpdateAuthorityTemplateResponseBody {
	s.Success = &v
	return s
}

func (s *UpdateAuthorityTemplateResponseBody) SetTid(v int64) *UpdateAuthorityTemplateResponseBody {
	s.Tid = &v
	return s
}

type UpdateAuthorityTemplateResponseBodyAuthorityTemplateView struct {
	// The ID of the user who created the permission template.
	CreatorId *int64 `json:"CreatorId,omitempty" xml:"CreatorId,omitempty"`
	// The description of the permission template.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the permission template.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the permission template.
	TemplateId *int64 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
}

func (s UpdateAuthorityTemplateResponseBodyAuthorityTemplateView) String() string {
	return tea.Prettify(s)
}

func (s UpdateAuthorityTemplateResponseBodyAuthorityTemplateView) GoString() string {
	return s.String()
}

func (s *UpdateAuthorityTemplateResponseBodyAuthorityTemplateView) SetCreatorId(v int64) *UpdateAuthorityTemplateResponseBodyAuthorityTemplateView {
	s.CreatorId = &v
	return s
}

func (s *UpdateAuthorityTemplateResponseBodyAuthorityTemplateView) SetDescription(v string) *UpdateAuthorityTemplateResponseBodyAuthorityTemplateView {
	s.Description = &v
	return s
}

func (s *UpdateAuthorityTemplateResponseBodyAuthorityTemplateView) SetName(v string) *UpdateAuthorityTemplateResponseBodyAuthorityTemplateView {
	s.Name = &v
	return s
}

func (s *UpdateAuthorityTemplateResponseBodyAuthorityTemplateView) SetTemplateId(v int64) *UpdateAuthorityTemplateResponseBodyAuthorityTemplateView {
	s.TemplateId = &v
	return s
}

type UpdateAuthorityTemplateResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateAuthorityTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateAuthorityTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAuthorityTemplateResponse) GoString() string {
	return s.String()
}

func (s *UpdateAuthorityTemplateResponse) SetHeaders(v map[string]*string) *UpdateAuthorityTemplateResponse {
	s.Headers = v
	return s
}

func (s *UpdateAuthorityTemplateResponse) SetStatusCode(v int32) *UpdateAuthorityTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateAuthorityTemplateResponse) SetBody(v *UpdateAuthorityTemplateResponseBody) *UpdateAuthorityTemplateResponse {
	s.Body = v
	return s
}

type UpdateInstanceRequest struct {
	// The name of the database link for cross-database queries.
	//
	// >
	//
	// *   This parameter is required if UseDsql is set to 1.
	//
	// *   The name can contain only lowercase letters and underscores (\_).
	//
	// *   The name must be unique within a tenant.
	DataLinkName *string `json:"DataLinkName,omitempty" xml:"DataLinkName,omitempty"`
	// The password that is used to log on to the database.
	DatabasePassword *string `json:"DatabasePassword,omitempty" xml:"DatabasePassword,omitempty"`
	// The account that is used to log on to the database.
	DatabaseUser *string `json:"DatabaseUser,omitempty" xml:"DatabaseUser,omitempty"`
	// The ID of the user who assumes the database administrator (DBA) role of the database instance. You can call the [ListUsers](~~141938~~) or [GetInstance](~~141567~~) operation to query the user ID.
	DbaId *string `json:"DbaId,omitempty" xml:"DbaId,omitempty"`
	// Specifies whether to enable the lock-free schema change feature for the database instance. Valid values:
	//
	// *   **0:** disables the lock-free schema change feature.
	// *   **1**: uses the online DDL of MySQL first.
	// *   **2**: uses the lock-free schema change feature of DMS first.
	DdlOnline *int32 `json:"DdlOnline,omitempty" xml:"DdlOnline,omitempty"`
	// The ID of the ECS instance on which the database instance is deployed.
	//
	// > This parameter is required if the InstanceSource parameter is set to ECS_OWN.
	EcsInstanceId *string `json:"EcsInstanceId,omitempty" xml:"EcsInstanceId,omitempty"`
	// The ID of the region in which the database instance resides.
	//
	// > This parameter is required if InstanceSource is set to RDS, ECS_OWN, and VPC_IDC.
	EcsRegion *string `json:"EcsRegion,omitempty" xml:"EcsRegion,omitempty"`
	// *   **Y:** enables the sensitive data protection feature
	// *   **N:** disables the sensitive data protection feature
	// *   **NULL or other:** does not update the status of the sensitive data protection feature
	EnableSellSitd *string `json:"EnableSellSitd,omitempty" xml:"EnableSellSitd,omitempty"`
	// The type of the environment in which the database instance is deployed. Valid values:
	//
	// *   **product:** production environment
	// *   **dev:** development environment
	// *   **pre:** pre-release environment
	// *   **test:** test environment
	// *   **sit:** system integration testing (SIT) environment
	// *   **uat:** user acceptance testing (UAT) environment
	// *   **pet:** stress testing environment
	// *   **stag:** staging environment
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The timeout period for exporting data from the database instance.
	ExportTimeout *int32 `json:"ExportTimeout,omitempty" xml:"ExportTimeout,omitempty"`
	// The host address that is used to connect to the database instance.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The alias of the database instance. Specify an alias that can help you identify the database instance in DMS.
	InstanceAlias *string `json:"InstanceAlias,omitempty" xml:"InstanceAlias,omitempty"`
	// The ID of the database instance. You can call the [GetInstance](~~141567~~) operation to query the instance ID.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The source of the database instance. Valid values:
	//
	// *   **PUBLIC_OWN:** a self-managed database instance that is deployed on the Internet
	// *   **RDS:** an ApsaraDB RDS instance
	// *   **ECS_OWN:** a self-managed database that is deployed on an Elastic Compute Service (ECS) instance
	// *   **VPC_IDC:** a self-managed database instance that is deployed in a data center connected over a virtual private cloud (VPC)
	InstanceSource *string `json:"InstanceSource,omitempty" xml:"InstanceSource,omitempty"`
	// The type of the database. For more information about the valid values of this parameter, see [DbType parameter](~~198106~~).
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The port that is used to connect to the database instance.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The timeout period for querying data in the database instance.
	QueryTimeout *int32 `json:"QueryTimeout,omitempty" xml:"QueryTimeout,omitempty"`
	// The name of the security rule set (GroupName) for the instance. You can call the [ListStandardGroups](~~417891~~) or [GetInstance](~~141567~~) operation to query the name of the security rule set.
	SafeRuleId *string `json:"SafeRuleId,omitempty" xml:"SafeRuleId,omitempty"`
	// The system ID (SID) of the database instance.
	//
	// > This parameter is required if the InstanceType parameter is set to ORACLE.
	Sid *string `json:"Sid,omitempty" xml:"Sid,omitempty"`
	// Specifies whether to skip the connectivity test. Valid values:
	//
	// *   **true:** skips the connectivity test
	// *   **false:** does not skip the connectivity test
	SkipTest *bool `json:"SkipTest,omitempty" xml:"SkipTest,omitempty"`
	// The ID of the classification template. You can call the [ListClassificationTemplates](~~460613~~) operation to query the template ID.
	TemplateId *int64 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The type of the classification template. You can call the [ListClassificationTemplates](~~460613~~) operation to query the template type.
	TemplateType *string `json:"TemplateType,omitempty" xml:"TemplateType,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// Specifies whether to enable the cross-database query feature for the database instance. Valid values:
	//
	// *   **0**: disables the cross-database query feature.
	// *   **1**: enables the cross-database query feature.
	//
	// > Supported database types: MySQL, SQL Server, PostgreSQL, PolarDB for PostgreSQL (compatible with Oracle), and ApsaraDB for Redis.
	UseDsql *int32 `json:"UseDsql,omitempty" xml:"UseDsql,omitempty"`
	// The ID of the VPC to which the database instance belongs.
	//
	// > This parameter is required if the InstanceSource parameter is set to VPC_IDC.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s UpdateInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateInstanceRequest) GoString() string {
	return s.String()
}

func (s *UpdateInstanceRequest) SetDataLinkName(v string) *UpdateInstanceRequest {
	s.DataLinkName = &v
	return s
}

func (s *UpdateInstanceRequest) SetDatabasePassword(v string) *UpdateInstanceRequest {
	s.DatabasePassword = &v
	return s
}

func (s *UpdateInstanceRequest) SetDatabaseUser(v string) *UpdateInstanceRequest {
	s.DatabaseUser = &v
	return s
}

func (s *UpdateInstanceRequest) SetDbaId(v string) *UpdateInstanceRequest {
	s.DbaId = &v
	return s
}

func (s *UpdateInstanceRequest) SetDdlOnline(v int32) *UpdateInstanceRequest {
	s.DdlOnline = &v
	return s
}

func (s *UpdateInstanceRequest) SetEcsInstanceId(v string) *UpdateInstanceRequest {
	s.EcsInstanceId = &v
	return s
}

func (s *UpdateInstanceRequest) SetEcsRegion(v string) *UpdateInstanceRequest {
	s.EcsRegion = &v
	return s
}

func (s *UpdateInstanceRequest) SetEnableSellSitd(v string) *UpdateInstanceRequest {
	s.EnableSellSitd = &v
	return s
}

func (s *UpdateInstanceRequest) SetEnvType(v string) *UpdateInstanceRequest {
	s.EnvType = &v
	return s
}

func (s *UpdateInstanceRequest) SetExportTimeout(v int32) *UpdateInstanceRequest {
	s.ExportTimeout = &v
	return s
}

func (s *UpdateInstanceRequest) SetHost(v string) *UpdateInstanceRequest {
	s.Host = &v
	return s
}

func (s *UpdateInstanceRequest) SetInstanceAlias(v string) *UpdateInstanceRequest {
	s.InstanceAlias = &v
	return s
}

func (s *UpdateInstanceRequest) SetInstanceId(v string) *UpdateInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *UpdateInstanceRequest) SetInstanceSource(v string) *UpdateInstanceRequest {
	s.InstanceSource = &v
	return s
}

func (s *UpdateInstanceRequest) SetInstanceType(v string) *UpdateInstanceRequest {
	s.InstanceType = &v
	return s
}

func (s *UpdateInstanceRequest) SetPort(v int32) *UpdateInstanceRequest {
	s.Port = &v
	return s
}

func (s *UpdateInstanceRequest) SetQueryTimeout(v int32) *UpdateInstanceRequest {
	s.QueryTimeout = &v
	return s
}

func (s *UpdateInstanceRequest) SetSafeRuleId(v string) *UpdateInstanceRequest {
	s.SafeRuleId = &v
	return s
}

func (s *UpdateInstanceRequest) SetSid(v string) *UpdateInstanceRequest {
	s.Sid = &v
	return s
}

func (s *UpdateInstanceRequest) SetSkipTest(v bool) *UpdateInstanceRequest {
	s.SkipTest = &v
	return s
}

func (s *UpdateInstanceRequest) SetTemplateId(v int64) *UpdateInstanceRequest {
	s.TemplateId = &v
	return s
}

func (s *UpdateInstanceRequest) SetTemplateType(v string) *UpdateInstanceRequest {
	s.TemplateType = &v
	return s
}

func (s *UpdateInstanceRequest) SetTid(v int64) *UpdateInstanceRequest {
	s.Tid = &v
	return s
}

func (s *UpdateInstanceRequest) SetUseDsql(v int32) *UpdateInstanceRequest {
	s.UseDsql = &v
	return s
}

func (s *UpdateInstanceRequest) SetVpcId(v string) *UpdateInstanceRequest {
	s.VpcId = &v
	return s
}

type UpdateInstanceResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true:** The request was successful.
	// *   **false:** The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateInstanceResponseBody) SetErrorCode(v string) *UpdateInstanceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateInstanceResponseBody) SetErrorMessage(v string) *UpdateInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateInstanceResponseBody) SetRequestId(v string) *UpdateInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateInstanceResponseBody) SetSuccess(v bool) *UpdateInstanceResponseBody {
	s.Success = &v
	return s
}

type UpdateInstanceResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateInstanceResponse) GoString() string {
	return s.String()
}

func (s *UpdateInstanceResponse) SetHeaders(v map[string]*string) *UpdateInstanceResponse {
	s.Headers = v
	return s
}

func (s *UpdateInstanceResponse) SetStatusCode(v int32) *UpdateInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateInstanceResponse) SetBody(v *UpdateInstanceResponseBody) *UpdateInstanceResponse {
	s.Body = v
	return s
}

type UpdateSLARulesRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The list of SLA rules.
	SlaRuleList []*UpdateSLARulesRequestSlaRuleList `json:"SlaRuleList,omitempty" xml:"SlaRuleList,omitempty" type:"Repeated"`
	// The ID of the tenant.
	//
	// > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s UpdateSLARulesRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateSLARulesRequest) GoString() string {
	return s.String()
}

func (s *UpdateSLARulesRequest) SetDagId(v int64) *UpdateSLARulesRequest {
	s.DagId = &v
	return s
}

func (s *UpdateSLARulesRequest) SetSlaRuleList(v []*UpdateSLARulesRequestSlaRuleList) *UpdateSLARulesRequest {
	s.SlaRuleList = v
	return s
}

func (s *UpdateSLARulesRequest) SetTid(v int64) *UpdateSLARulesRequest {
	s.Tid = &v
	return s
}

type UpdateSLARulesRequestSlaRuleList struct {
	// The ID of the task flow.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The timeout period. Unit: minutes.
	IntervalMinutes *int32 `json:"IntervalMinutes,omitempty" xml:"IntervalMinutes,omitempty"`
	// The ID of the task node.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The rule type. Valid values:
	//
	// *   **0**: SLA rules for task flows
	// *   **1**: SLA rules for nodes
	Type *int32 `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdateSLARulesRequestSlaRuleList) String() string {
	return tea.Prettify(s)
}

func (s UpdateSLARulesRequestSlaRuleList) GoString() string {
	return s.String()
}

func (s *UpdateSLARulesRequestSlaRuleList) SetDagId(v int64) *UpdateSLARulesRequestSlaRuleList {
	s.DagId = &v
	return s
}

func (s *UpdateSLARulesRequestSlaRuleList) SetIntervalMinutes(v int32) *UpdateSLARulesRequestSlaRuleList {
	s.IntervalMinutes = &v
	return s
}

func (s *UpdateSLARulesRequestSlaRuleList) SetNodeId(v int64) *UpdateSLARulesRequestSlaRuleList {
	s.NodeId = &v
	return s
}

func (s *UpdateSLARulesRequestSlaRuleList) SetType(v int32) *UpdateSLARulesRequestSlaRuleList {
	s.Type = &v
	return s
}

type UpdateSLARulesShrinkRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The list of SLA rules.
	SlaRuleListShrink *string `json:"SlaRuleList,omitempty" xml:"SlaRuleList,omitempty"`
	// The ID of the tenant.
	//
	// > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s UpdateSLARulesShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateSLARulesShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateSLARulesShrinkRequest) SetDagId(v int64) *UpdateSLARulesShrinkRequest {
	s.DagId = &v
	return s
}

func (s *UpdateSLARulesShrinkRequest) SetSlaRuleListShrink(v string) *UpdateSLARulesShrinkRequest {
	s.SlaRuleListShrink = &v
	return s
}

func (s *UpdateSLARulesShrinkRequest) SetTid(v int64) *UpdateSLARulesShrinkRequest {
	s.Tid = &v
	return s
}

type UpdateSLARulesResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can use the ID to locate logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateSLARulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateSLARulesResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateSLARulesResponseBody) SetErrorCode(v string) *UpdateSLARulesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateSLARulesResponseBody) SetErrorMessage(v string) *UpdateSLARulesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateSLARulesResponseBody) SetRequestId(v string) *UpdateSLARulesResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateSLARulesResponseBody) SetSuccess(v bool) *UpdateSLARulesResponseBody {
	s.Success = &v
	return s
}

type UpdateSLARulesResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateSLARulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateSLARulesResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateSLARulesResponse) GoString() string {
	return s.String()
}

func (s *UpdateSLARulesResponse) SetHeaders(v map[string]*string) *UpdateSLARulesResponse {
	s.Headers = v
	return s
}

func (s *UpdateSLARulesResponse) SetStatusCode(v int32) *UpdateSLARulesResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateSLARulesResponse) SetBody(v *UpdateSLARulesResponseBody) *UpdateSLARulesResponse {
	s.Body = v
	return s
}

type UpdateScenarioRequest struct {
	// The description of the business scenario.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the business scenario.
	ScenarioId *string `json:"ScenarioId,omitempty" xml:"ScenarioId,omitempty"`
	// The name of the business scenario.
	ScenarioName *string `json:"ScenarioName,omitempty" xml:"ScenarioName,omitempty"`
	// The ID of the tenant.
	//
	// > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s UpdateScenarioRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateScenarioRequest) GoString() string {
	return s.String()
}

func (s *UpdateScenarioRequest) SetDescription(v string) *UpdateScenarioRequest {
	s.Description = &v
	return s
}

func (s *UpdateScenarioRequest) SetScenarioId(v string) *UpdateScenarioRequest {
	s.ScenarioId = &v
	return s
}

func (s *UpdateScenarioRequest) SetScenarioName(v string) *UpdateScenarioRequest {
	s.ScenarioName = &v
	return s
}

func (s *UpdateScenarioRequest) SetTid(v int64) *UpdateScenarioRequest {
	s.Tid = &v
	return s
}

type UpdateScenarioResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateScenarioResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateScenarioResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateScenarioResponseBody) SetErrorCode(v string) *UpdateScenarioResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateScenarioResponseBody) SetErrorMessage(v string) *UpdateScenarioResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateScenarioResponseBody) SetRequestId(v string) *UpdateScenarioResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateScenarioResponseBody) SetSuccess(v bool) *UpdateScenarioResponseBody {
	s.Success = &v
	return s
}

type UpdateScenarioResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateScenarioResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateScenarioResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateScenarioResponse) GoString() string {
	return s.String()
}

func (s *UpdateScenarioResponse) SetHeaders(v map[string]*string) *UpdateScenarioResponse {
	s.Headers = v
	return s
}

func (s *UpdateScenarioResponse) SetStatusCode(v int32) *UpdateScenarioResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateScenarioResponse) SetBody(v *UpdateScenarioResponseBody) *UpdateScenarioResponse {
	s.Body = v
	return s
}

type UpdateStandardGroupRequest struct {
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	GroupId     *int64  `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	GroupName   *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	Tid         *int64  `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s UpdateStandardGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateStandardGroupRequest) GoString() string {
	return s.String()
}

func (s *UpdateStandardGroupRequest) SetDescription(v string) *UpdateStandardGroupRequest {
	s.Description = &v
	return s
}

func (s *UpdateStandardGroupRequest) SetGroupId(v int64) *UpdateStandardGroupRequest {
	s.GroupId = &v
	return s
}

func (s *UpdateStandardGroupRequest) SetGroupName(v string) *UpdateStandardGroupRequest {
	s.GroupName = &v
	return s
}

func (s *UpdateStandardGroupRequest) SetTid(v int64) *UpdateStandardGroupRequest {
	s.Tid = &v
	return s
}

type UpdateStandardGroupResponseBody struct {
	ErrorCode     *string                                       `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage  *string                                       `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId     *string                                       `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	StandardGroup *UpdateStandardGroupResponseBodyStandardGroup `json:"StandardGroup,omitempty" xml:"StandardGroup,omitempty" type:"Struct"`
	Success       *bool                                         `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateStandardGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateStandardGroupResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateStandardGroupResponseBody) SetErrorCode(v string) *UpdateStandardGroupResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateStandardGroupResponseBody) SetErrorMessage(v string) *UpdateStandardGroupResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateStandardGroupResponseBody) SetRequestId(v string) *UpdateStandardGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateStandardGroupResponseBody) SetStandardGroup(v *UpdateStandardGroupResponseBodyStandardGroup) *UpdateStandardGroupResponseBody {
	s.StandardGroup = v
	return s
}

func (s *UpdateStandardGroupResponseBody) SetSuccess(v bool) *UpdateStandardGroupResponseBody {
	s.Success = &v
	return s
}

type UpdateStandardGroupResponseBodyStandardGroup struct {
	DbType       *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	Description  *string `json:"Description,omitempty" xml:"Description,omitempty"`
	GroupId      *int64  `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	GroupMode    *string `json:"GroupMode,omitempty" xml:"GroupMode,omitempty"`
	GroupName    *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	LastMenderId *int64  `json:"LastMenderId,omitempty" xml:"LastMenderId,omitempty"`
}

func (s UpdateStandardGroupResponseBodyStandardGroup) String() string {
	return tea.Prettify(s)
}

func (s UpdateStandardGroupResponseBodyStandardGroup) GoString() string {
	return s.String()
}

func (s *UpdateStandardGroupResponseBodyStandardGroup) SetDbType(v string) *UpdateStandardGroupResponseBodyStandardGroup {
	s.DbType = &v
	return s
}

func (s *UpdateStandardGroupResponseBodyStandardGroup) SetDescription(v string) *UpdateStandardGroupResponseBodyStandardGroup {
	s.Description = &v
	return s
}

func (s *UpdateStandardGroupResponseBodyStandardGroup) SetGroupId(v int64) *UpdateStandardGroupResponseBodyStandardGroup {
	s.GroupId = &v
	return s
}

func (s *UpdateStandardGroupResponseBodyStandardGroup) SetGroupMode(v string) *UpdateStandardGroupResponseBodyStandardGroup {
	s.GroupMode = &v
	return s
}

func (s *UpdateStandardGroupResponseBodyStandardGroup) SetGroupName(v string) *UpdateStandardGroupResponseBodyStandardGroup {
	s.GroupName = &v
	return s
}

func (s *UpdateStandardGroupResponseBodyStandardGroup) SetLastMenderId(v int64) *UpdateStandardGroupResponseBodyStandardGroup {
	s.LastMenderId = &v
	return s
}

type UpdateStandardGroupResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateStandardGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateStandardGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateStandardGroupResponse) GoString() string {
	return s.String()
}

func (s *UpdateStandardGroupResponse) SetHeaders(v map[string]*string) *UpdateStandardGroupResponse {
	s.Headers = v
	return s
}

func (s *UpdateStandardGroupResponse) SetStatusCode(v int32) *UpdateStandardGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateStandardGroupResponse) SetBody(v *UpdateStandardGroupResponseBody) *UpdateStandardGroupResponse {
	s.Body = v
	return s
}

type UpdateTaskConfigRequest struct {
	// The advanced configuration for the node. The value of this parameter must be a JSON string.
	NodeConfig *string `json:"NodeConfig,omitempty" xml:"NodeConfig,omitempty"`
	// The ID of the task node. You can call the [GetTaskInstanceRelation](~~424711~~) operation to query the node ID.
	NodeId *string `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s UpdateTaskConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskConfigRequest) GoString() string {
	return s.String()
}

func (s *UpdateTaskConfigRequest) SetNodeConfig(v string) *UpdateTaskConfigRequest {
	s.NodeConfig = &v
	return s
}

func (s *UpdateTaskConfigRequest) SetNodeId(v string) *UpdateTaskConfigRequest {
	s.NodeId = &v
	return s
}

func (s *UpdateTaskConfigRequest) SetTid(v int64) *UpdateTaskConfigRequest {
	s.Tid = &v
	return s
}

type UpdateTaskConfigResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateTaskConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskConfigResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTaskConfigResponseBody) SetErrorCode(v string) *UpdateTaskConfigResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateTaskConfigResponseBody) SetErrorMessage(v string) *UpdateTaskConfigResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateTaskConfigResponseBody) SetRequestId(v string) *UpdateTaskConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateTaskConfigResponseBody) SetSuccess(v bool) *UpdateTaskConfigResponseBody {
	s.Success = &v
	return s
}

type UpdateTaskConfigResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateTaskConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateTaskConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskConfigResponse) GoString() string {
	return s.String()
}

func (s *UpdateTaskConfigResponse) SetHeaders(v map[string]*string) *UpdateTaskConfigResponse {
	s.Headers = v
	return s
}

func (s *UpdateTaskConfigResponse) SetStatusCode(v int32) *UpdateTaskConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTaskConfigResponse) SetBody(v *UpdateTaskConfigResponseBody) *UpdateTaskConfigResponse {
	s.Body = v
	return s
}

type UpdateTaskContentRequest struct {
	// The node configurations after modification.
	NodeContent *string `json:"NodeContent,omitempty" xml:"NodeContent,omitempty"`
	// The ID of the task node. You can call the [GetTaskInstanceRelation](~~424711~~) operation to query the node ID.
	NodeId *string `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The ID of the tenant.
	//
	// > To view the ID of the tenant, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see the ["View information about the current tenant"](~~181330~~) section of the Manage DMS tenants topic.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s UpdateTaskContentRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskContentRequest) GoString() string {
	return s.String()
}

func (s *UpdateTaskContentRequest) SetNodeContent(v string) *UpdateTaskContentRequest {
	s.NodeContent = &v
	return s
}

func (s *UpdateTaskContentRequest) SetNodeId(v string) *UpdateTaskContentRequest {
	s.NodeId = &v
	return s
}

func (s *UpdateTaskContentRequest) SetTid(v int64) *UpdateTaskContentRequest {
	s.Tid = &v
	return s
}

type UpdateTaskContentResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can use the ID to locate logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateTaskContentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskContentResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTaskContentResponseBody) SetErrorCode(v string) *UpdateTaskContentResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateTaskContentResponseBody) SetErrorMessage(v string) *UpdateTaskContentResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateTaskContentResponseBody) SetRequestId(v string) *UpdateTaskContentResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateTaskContentResponseBody) SetSuccess(v bool) *UpdateTaskContentResponseBody {
	s.Success = &v
	return s
}

type UpdateTaskContentResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateTaskContentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateTaskContentResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskContentResponse) GoString() string {
	return s.String()
}

func (s *UpdateTaskContentResponse) SetHeaders(v map[string]*string) *UpdateTaskContentResponse {
	s.Headers = v
	return s
}

func (s *UpdateTaskContentResponse) SetStatusCode(v int32) *UpdateTaskContentResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTaskContentResponse) SetBody(v *UpdateTaskContentResponseBody) *UpdateTaskContentResponse {
	s.Body = v
	return s
}

type UpdateTaskFlowConstantsRequest struct {
	// The constants for the task flow.
	DagConstants []*UpdateTaskFlowConstantsRequestDagConstants `json:"DagConstants,omitempty" xml:"DagConstants,omitempty" type:"Repeated"`
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s UpdateTaskFlowConstantsRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowConstantsRequest) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowConstantsRequest) SetDagConstants(v []*UpdateTaskFlowConstantsRequestDagConstants) *UpdateTaskFlowConstantsRequest {
	s.DagConstants = v
	return s
}

func (s *UpdateTaskFlowConstantsRequest) SetDagId(v int64) *UpdateTaskFlowConstantsRequest {
	s.DagId = &v
	return s
}

func (s *UpdateTaskFlowConstantsRequest) SetTid(v int64) *UpdateTaskFlowConstantsRequest {
	s.Tid = &v
	return s
}

type UpdateTaskFlowConstantsRequestDagConstants struct {
	// The key name of a constant for the task flow.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The key value of a constant for the task flow.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s UpdateTaskFlowConstantsRequestDagConstants) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowConstantsRequestDagConstants) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowConstantsRequestDagConstants) SetKey(v string) *UpdateTaskFlowConstantsRequestDagConstants {
	s.Key = &v
	return s
}

func (s *UpdateTaskFlowConstantsRequestDagConstants) SetValue(v string) *UpdateTaskFlowConstantsRequestDagConstants {
	s.Value = &v
	return s
}

type UpdateTaskFlowConstantsShrinkRequest struct {
	// The constants for the task flow.
	DagConstantsShrink *string `json:"DagConstants,omitempty" xml:"DagConstants,omitempty"`
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the tenant. You can call the [GetUserActiveTenant](~~198073~~) or [ListUserTenants](~~198074~~) operation to query the tenant ID.
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s UpdateTaskFlowConstantsShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowConstantsShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowConstantsShrinkRequest) SetDagConstantsShrink(v string) *UpdateTaskFlowConstantsShrinkRequest {
	s.DagConstantsShrink = &v
	return s
}

func (s *UpdateTaskFlowConstantsShrinkRequest) SetDagId(v int64) *UpdateTaskFlowConstantsShrinkRequest {
	s.DagId = &v
	return s
}

func (s *UpdateTaskFlowConstantsShrinkRequest) SetTid(v int64) *UpdateTaskFlowConstantsShrinkRequest {
	s.Tid = &v
	return s
}

type UpdateTaskFlowConstantsResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can use the ID to locate logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateTaskFlowConstantsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowConstantsResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowConstantsResponseBody) SetErrorCode(v string) *UpdateTaskFlowConstantsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateTaskFlowConstantsResponseBody) SetErrorMessage(v string) *UpdateTaskFlowConstantsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateTaskFlowConstantsResponseBody) SetRequestId(v string) *UpdateTaskFlowConstantsResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateTaskFlowConstantsResponseBody) SetSuccess(v bool) *UpdateTaskFlowConstantsResponseBody {
	s.Success = &v
	return s
}

type UpdateTaskFlowConstantsResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateTaskFlowConstantsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateTaskFlowConstantsResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowConstantsResponse) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowConstantsResponse) SetHeaders(v map[string]*string) *UpdateTaskFlowConstantsResponse {
	s.Headers = v
	return s
}

func (s *UpdateTaskFlowConstantsResponse) SetStatusCode(v int32) *UpdateTaskFlowConstantsResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTaskFlowConstantsResponse) SetBody(v *UpdateTaskFlowConstantsResponseBody) *UpdateTaskFlowConstantsResponse {
	s.Body = v
	return s
}

type UpdateTaskFlowCooperatorsRequest struct {
	// The IDs of the users who are involved in the task flow to be updated.
	CooperatorIds []*string `json:"CooperatorIds,omitempty" xml:"CooperatorIds,omitempty" type:"Repeated"`
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the tenant.
	//
	// > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s UpdateTaskFlowCooperatorsRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowCooperatorsRequest) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowCooperatorsRequest) SetCooperatorIds(v []*string) *UpdateTaskFlowCooperatorsRequest {
	s.CooperatorIds = v
	return s
}

func (s *UpdateTaskFlowCooperatorsRequest) SetDagId(v int64) *UpdateTaskFlowCooperatorsRequest {
	s.DagId = &v
	return s
}

func (s *UpdateTaskFlowCooperatorsRequest) SetTid(v int64) *UpdateTaskFlowCooperatorsRequest {
	s.Tid = &v
	return s
}

type UpdateTaskFlowCooperatorsShrinkRequest struct {
	// The IDs of the users who are involved in the task flow to be updated.
	CooperatorIdsShrink *string `json:"CooperatorIds,omitempty" xml:"CooperatorIds,omitempty"`
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the tenant.
	//
	// > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s UpdateTaskFlowCooperatorsShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowCooperatorsShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowCooperatorsShrinkRequest) SetCooperatorIdsShrink(v string) *UpdateTaskFlowCooperatorsShrinkRequest {
	s.CooperatorIdsShrink = &v
	return s
}

func (s *UpdateTaskFlowCooperatorsShrinkRequest) SetDagId(v int64) *UpdateTaskFlowCooperatorsShrinkRequest {
	s.DagId = &v
	return s
}

func (s *UpdateTaskFlowCooperatorsShrinkRequest) SetTid(v int64) *UpdateTaskFlowCooperatorsShrinkRequest {
	s.Tid = &v
	return s
}

type UpdateTaskFlowCooperatorsResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can use the ID to locate logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateTaskFlowCooperatorsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowCooperatorsResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowCooperatorsResponseBody) SetErrorCode(v string) *UpdateTaskFlowCooperatorsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateTaskFlowCooperatorsResponseBody) SetErrorMessage(v string) *UpdateTaskFlowCooperatorsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateTaskFlowCooperatorsResponseBody) SetRequestId(v string) *UpdateTaskFlowCooperatorsResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateTaskFlowCooperatorsResponseBody) SetSuccess(v bool) *UpdateTaskFlowCooperatorsResponseBody {
	s.Success = &v
	return s
}

type UpdateTaskFlowCooperatorsResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateTaskFlowCooperatorsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateTaskFlowCooperatorsResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowCooperatorsResponse) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowCooperatorsResponse) SetHeaders(v map[string]*string) *UpdateTaskFlowCooperatorsResponse {
	s.Headers = v
	return s
}

func (s *UpdateTaskFlowCooperatorsResponse) SetStatusCode(v int32) *UpdateTaskFlowCooperatorsResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTaskFlowCooperatorsResponse) SetBody(v *UpdateTaskFlowCooperatorsResponseBody) *UpdateTaskFlowCooperatorsResponse {
	s.Body = v
	return s
}

type UpdateTaskFlowEdgesRequest struct {
	// The task flow ID. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The list of updated task flow edges.
	Edges []*UpdateTaskFlowEdgesRequestEdges `json:"Edges,omitempty" xml:"Edges,omitempty" type:"Repeated"`
	// The tenant ID.
	//
	// > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s UpdateTaskFlowEdgesRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowEdgesRequest) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowEdgesRequest) SetDagId(v int64) *UpdateTaskFlowEdgesRequest {
	s.DagId = &v
	return s
}

func (s *UpdateTaskFlowEdgesRequest) SetEdges(v []*UpdateTaskFlowEdgesRequestEdges) *UpdateTaskFlowEdgesRequest {
	s.Edges = v
	return s
}

func (s *UpdateTaskFlowEdgesRequest) SetTid(v int64) *UpdateTaskFlowEdgesRequest {
	s.Tid = &v
	return s
}

type UpdateTaskFlowEdgesRequestEdges struct {
	// The ID of the task flow edge.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the end node of the edge.
	NodeEnd *int64 `json:"NodeEnd,omitempty" xml:"NodeEnd,omitempty"`
	// The ID of the start node of the edge.
	NodeFrom *int64 `json:"NodeFrom,omitempty" xml:"NodeFrom,omitempty"`
}

func (s UpdateTaskFlowEdgesRequestEdges) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowEdgesRequestEdges) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowEdgesRequestEdges) SetId(v int64) *UpdateTaskFlowEdgesRequestEdges {
	s.Id = &v
	return s
}

func (s *UpdateTaskFlowEdgesRequestEdges) SetNodeEnd(v int64) *UpdateTaskFlowEdgesRequestEdges {
	s.NodeEnd = &v
	return s
}

func (s *UpdateTaskFlowEdgesRequestEdges) SetNodeFrom(v int64) *UpdateTaskFlowEdgesRequestEdges {
	s.NodeFrom = &v
	return s
}

type UpdateTaskFlowEdgesShrinkRequest struct {
	// The task flow ID. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The list of updated task flow edges.
	EdgesShrink *string `json:"Edges,omitempty" xml:"Edges,omitempty"`
	// The tenant ID.
	//
	// > To view the tenant ID, move the pointer over the profile picture in the upper-right corner of the Data Management (DMS) console. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s UpdateTaskFlowEdgesShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowEdgesShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowEdgesShrinkRequest) SetDagId(v int64) *UpdateTaskFlowEdgesShrinkRequest {
	s.DagId = &v
	return s
}

func (s *UpdateTaskFlowEdgesShrinkRequest) SetEdgesShrink(v string) *UpdateTaskFlowEdgesShrinkRequest {
	s.EdgesShrink = &v
	return s
}

func (s *UpdateTaskFlowEdgesShrinkRequest) SetTid(v int64) *UpdateTaskFlowEdgesShrinkRequest {
	s.Tid = &v
	return s
}

type UpdateTaskFlowEdgesResponseBody struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateTaskFlowEdgesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowEdgesResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowEdgesResponseBody) SetErrorCode(v string) *UpdateTaskFlowEdgesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateTaskFlowEdgesResponseBody) SetErrorMessage(v string) *UpdateTaskFlowEdgesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateTaskFlowEdgesResponseBody) SetRequestId(v string) *UpdateTaskFlowEdgesResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateTaskFlowEdgesResponseBody) SetSuccess(v bool) *UpdateTaskFlowEdgesResponseBody {
	s.Success = &v
	return s
}

type UpdateTaskFlowEdgesResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateTaskFlowEdgesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateTaskFlowEdgesResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowEdgesResponse) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowEdgesResponse) SetHeaders(v map[string]*string) *UpdateTaskFlowEdgesResponse {
	s.Headers = v
	return s
}

func (s *UpdateTaskFlowEdgesResponse) SetStatusCode(v int32) *UpdateTaskFlowEdgesResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTaskFlowEdgesResponse) SetBody(v *UpdateTaskFlowEdgesResponseBody) *UpdateTaskFlowEdgesResponse {
	s.Body = v
	return s
}

type UpdateTaskFlowNameAndDescRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The new name that you want to specify for the task flow.
	DagName *string `json:"DagName,omitempty" xml:"DagName,omitempty"`
	// The description that you want to specify for the task flow.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the tenant.
	//
	// >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s UpdateTaskFlowNameAndDescRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowNameAndDescRequest) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowNameAndDescRequest) SetDagId(v int64) *UpdateTaskFlowNameAndDescRequest {
	s.DagId = &v
	return s
}

func (s *UpdateTaskFlowNameAndDescRequest) SetDagName(v string) *UpdateTaskFlowNameAndDescRequest {
	s.DagName = &v
	return s
}

func (s *UpdateTaskFlowNameAndDescRequest) SetDescription(v string) *UpdateTaskFlowNameAndDescRequest {
	s.Description = &v
	return s
}

func (s *UpdateTaskFlowNameAndDescRequest) SetTid(v int64) *UpdateTaskFlowNameAndDescRequest {
	s.Tid = &v
	return s
}

type UpdateTaskFlowNameAndDescResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can use the ID to locate logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateTaskFlowNameAndDescResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowNameAndDescResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowNameAndDescResponseBody) SetErrorCode(v string) *UpdateTaskFlowNameAndDescResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateTaskFlowNameAndDescResponseBody) SetErrorMessage(v string) *UpdateTaskFlowNameAndDescResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateTaskFlowNameAndDescResponseBody) SetRequestId(v string) *UpdateTaskFlowNameAndDescResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateTaskFlowNameAndDescResponseBody) SetSuccess(v bool) *UpdateTaskFlowNameAndDescResponseBody {
	s.Success = &v
	return s
}

type UpdateTaskFlowNameAndDescResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateTaskFlowNameAndDescResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateTaskFlowNameAndDescResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowNameAndDescResponse) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowNameAndDescResponse) SetHeaders(v map[string]*string) *UpdateTaskFlowNameAndDescResponse {
	s.Headers = v
	return s
}

func (s *UpdateTaskFlowNameAndDescResponse) SetStatusCode(v int32) *UpdateTaskFlowNameAndDescResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTaskFlowNameAndDescResponse) SetBody(v *UpdateTaskFlowNameAndDescResponseBody) *UpdateTaskFlowNameAndDescResponse {
	s.Body = v
	return s
}

type UpdateTaskFlowNotificationRequest struct {
	// The unique ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// Specifies whether to enable notifications for failed task flows. Notifications are disabled by default. You can enable notifications based on your business requirements.
	DagNotificationFail *bool `json:"DagNotificationFail,omitempty" xml:"DagNotificationFail,omitempty"`
	// Specifies whether to enable SLA global notifications for task flows. Notifications are disabled by default. You can enable notifications based on your business requirements.
	DagNotificationSla *bool `json:"DagNotificationSla,omitempty" xml:"DagNotificationSla,omitempty"`
	// Specifies whether to enable notifications for successful task flows. Notifications are disabled by default. You can enable notifications based on your business requirements.
	DagNotificationSuccess *bool `json:"DagNotificationSuccess,omitempty" xml:"DagNotificationSuccess,omitempty"`
	// The ID of the tenant.
	//
	// >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s UpdateTaskFlowNotificationRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowNotificationRequest) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowNotificationRequest) SetDagId(v int64) *UpdateTaskFlowNotificationRequest {
	s.DagId = &v
	return s
}

func (s *UpdateTaskFlowNotificationRequest) SetDagNotificationFail(v bool) *UpdateTaskFlowNotificationRequest {
	s.DagNotificationFail = &v
	return s
}

func (s *UpdateTaskFlowNotificationRequest) SetDagNotificationSla(v bool) *UpdateTaskFlowNotificationRequest {
	s.DagNotificationSla = &v
	return s
}

func (s *UpdateTaskFlowNotificationRequest) SetDagNotificationSuccess(v bool) *UpdateTaskFlowNotificationRequest {
	s.DagNotificationSuccess = &v
	return s
}

func (s *UpdateTaskFlowNotificationRequest) SetTid(v int64) *UpdateTaskFlowNotificationRequest {
	s.Tid = &v
	return s
}

type UpdateTaskFlowNotificationResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can use the ID to locate logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateTaskFlowNotificationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowNotificationResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowNotificationResponseBody) SetErrorCode(v string) *UpdateTaskFlowNotificationResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateTaskFlowNotificationResponseBody) SetErrorMessage(v string) *UpdateTaskFlowNotificationResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateTaskFlowNotificationResponseBody) SetRequestId(v string) *UpdateTaskFlowNotificationResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateTaskFlowNotificationResponseBody) SetSuccess(v bool) *UpdateTaskFlowNotificationResponseBody {
	s.Success = &v
	return s
}

type UpdateTaskFlowNotificationResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateTaskFlowNotificationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateTaskFlowNotificationResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowNotificationResponse) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowNotificationResponse) SetHeaders(v map[string]*string) *UpdateTaskFlowNotificationResponse {
	s.Headers = v
	return s
}

func (s *UpdateTaskFlowNotificationResponse) SetStatusCode(v int32) *UpdateTaskFlowNotificationResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTaskFlowNotificationResponse) SetBody(v *UpdateTaskFlowNotificationResponseBody) *UpdateTaskFlowNotificationResponse {
	s.Body = v
	return s
}

type UpdateTaskFlowOwnerRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlowInstance](~~424689~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The user ID of the new owner. You can call the [GetUser](~~147098~~) or [ListUsers](~~141938~~) operation to query the user ID.
	NewOwnerId *string `json:"NewOwnerId,omitempty" xml:"NewOwnerId,omitempty"`
	// The ID of the tenant.
	//
	// >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s UpdateTaskFlowOwnerRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowOwnerRequest) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowOwnerRequest) SetDagId(v int64) *UpdateTaskFlowOwnerRequest {
	s.DagId = &v
	return s
}

func (s *UpdateTaskFlowOwnerRequest) SetNewOwnerId(v string) *UpdateTaskFlowOwnerRequest {
	s.NewOwnerId = &v
	return s
}

func (s *UpdateTaskFlowOwnerRequest) SetTid(v int64) *UpdateTaskFlowOwnerRequest {
	s.Tid = &v
	return s
}

type UpdateTaskFlowOwnerResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can use the ID to locate logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateTaskFlowOwnerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowOwnerResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowOwnerResponseBody) SetErrorCode(v string) *UpdateTaskFlowOwnerResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateTaskFlowOwnerResponseBody) SetErrorMessage(v string) *UpdateTaskFlowOwnerResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateTaskFlowOwnerResponseBody) SetRequestId(v string) *UpdateTaskFlowOwnerResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateTaskFlowOwnerResponseBody) SetSuccess(v bool) *UpdateTaskFlowOwnerResponseBody {
	s.Success = &v
	return s
}

type UpdateTaskFlowOwnerResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateTaskFlowOwnerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateTaskFlowOwnerResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowOwnerResponse) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowOwnerResponse) SetHeaders(v map[string]*string) *UpdateTaskFlowOwnerResponse {
	s.Headers = v
	return s
}

func (s *UpdateTaskFlowOwnerResponse) SetStatusCode(v int32) *UpdateTaskFlowOwnerResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTaskFlowOwnerResponse) SetBody(v *UpdateTaskFlowOwnerResponseBody) *UpdateTaskFlowOwnerResponse {
	s.Body = v
	return s
}

type UpdateTaskFlowRelationsRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The list of task flow edges to be updated.
	Edges []*UpdateTaskFlowRelationsRequestEdges `json:"Edges,omitempty" xml:"Edges,omitempty" type:"Repeated"`
	// The ID of the tenant.
	//
	// >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s UpdateTaskFlowRelationsRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowRelationsRequest) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowRelationsRequest) SetDagId(v int64) *UpdateTaskFlowRelationsRequest {
	s.DagId = &v
	return s
}

func (s *UpdateTaskFlowRelationsRequest) SetEdges(v []*UpdateTaskFlowRelationsRequestEdges) *UpdateTaskFlowRelationsRequest {
	s.Edges = v
	return s
}

func (s *UpdateTaskFlowRelationsRequest) SetTid(v int64) *UpdateTaskFlowRelationsRequest {
	s.Tid = &v
	return s
}

type UpdateTaskFlowRelationsRequestEdges struct {
	// The ID of the task flow edge.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the end node on the edge.
	NodeEnd *int64 `json:"NodeEnd,omitempty" xml:"NodeEnd,omitempty"`
	// The ID of the start node on the edge.
	NodeFrom *int64 `json:"NodeFrom,omitempty" xml:"NodeFrom,omitempty"`
}

func (s UpdateTaskFlowRelationsRequestEdges) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowRelationsRequestEdges) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowRelationsRequestEdges) SetId(v int64) *UpdateTaskFlowRelationsRequestEdges {
	s.Id = &v
	return s
}

func (s *UpdateTaskFlowRelationsRequestEdges) SetNodeEnd(v int64) *UpdateTaskFlowRelationsRequestEdges {
	s.NodeEnd = &v
	return s
}

func (s *UpdateTaskFlowRelationsRequestEdges) SetNodeFrom(v int64) *UpdateTaskFlowRelationsRequestEdges {
	s.NodeFrom = &v
	return s
}

type UpdateTaskFlowRelationsShrinkRequest struct {
	// The ID of the task flow. You can call the [ListTaskFlow](~~424565~~) or [ListLhTaskFlowAndScenario](~~426672~~) operation to query the task flow ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The list of task flow edges to be updated.
	EdgesShrink *string `json:"Edges,omitempty" xml:"Edges,omitempty"`
	// The ID of the tenant.
	//
	// >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s UpdateTaskFlowRelationsShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowRelationsShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowRelationsShrinkRequest) SetDagId(v int64) *UpdateTaskFlowRelationsShrinkRequest {
	s.DagId = &v
	return s
}

func (s *UpdateTaskFlowRelationsShrinkRequest) SetEdgesShrink(v string) *UpdateTaskFlowRelationsShrinkRequest {
	s.EdgesShrink = &v
	return s
}

func (s *UpdateTaskFlowRelationsShrinkRequest) SetTid(v int64) *UpdateTaskFlowRelationsShrinkRequest {
	s.Tid = &v
	return s
}

type UpdateTaskFlowRelationsResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can use the ID to locate logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateTaskFlowRelationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowRelationsResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowRelationsResponseBody) SetErrorCode(v string) *UpdateTaskFlowRelationsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateTaskFlowRelationsResponseBody) SetErrorMessage(v string) *UpdateTaskFlowRelationsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateTaskFlowRelationsResponseBody) SetRequestId(v string) *UpdateTaskFlowRelationsResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateTaskFlowRelationsResponseBody) SetSuccess(v bool) *UpdateTaskFlowRelationsResponseBody {
	s.Success = &v
	return s
}

type UpdateTaskFlowRelationsResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateTaskFlowRelationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateTaskFlowRelationsResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowRelationsResponse) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowRelationsResponse) SetHeaders(v map[string]*string) *UpdateTaskFlowRelationsResponse {
	s.Headers = v
	return s
}

func (s *UpdateTaskFlowRelationsResponse) SetStatusCode(v int32) *UpdateTaskFlowRelationsResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTaskFlowRelationsResponse) SetBody(v *UpdateTaskFlowRelationsResponseBody) *UpdateTaskFlowRelationsResponse {
	s.Body = v
	return s
}

type UpdateTaskFlowScheduleRequest struct {
	// The start of the time range for scheduling.
	CronBeginDate *string `json:"CronBeginDate,omitempty" xml:"CronBeginDate,omitempty"`
	// The end of the time range for scheduling.
	CronEndDate *string `json:"CronEndDate,omitempty" xml:"CronEndDate,omitempty"`
	// The cron expression for timed scheduling.
	CronStr *string `json:"CronStr,omitempty" xml:"CronStr,omitempty"`
	// The type of the scheduling cycle. Valid values:
	//
	// *   **MINUTE**: scheduling by minute
	// *   **HOUR**: scheduling by hour
	// *   **DAY**: scheduling by day
	// *   **WEEK**: scheduling by week
	// *   **MONTH**: scheduling by month
	CronType *string `json:"CronType,omitempty" xml:"CronType,omitempty"`
	// The ID of the task flow.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The event scheduling configuration. The value of this parameter is a JSON string.
	ScheduleParam *string `json:"ScheduleParam,omitempty" xml:"ScheduleParam,omitempty"`
	// Specifies whether to enable scheduling. Valid values:
	//
	// *   **Enable**
	// *   **Disable**
	ScheduleSwitch *bool `json:"ScheduleSwitch,omitempty" xml:"ScheduleSwitch,omitempty"`
	// The ID of the tenant.
	//
	// > : To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The time zone. The default time zone is UTC+8 (Asia/Shanghai).
	TimeZoneId *string `json:"TimeZoneId,omitempty" xml:"TimeZoneId,omitempty"`
	// The mode in which the task flow is triggered. Valid values:
	//
	// *   **Cron**: The task flow is triggered based on timed scheduling.
	// *   **Event**: The task flow is triggered by events.
	TriggerType *string `json:"TriggerType,omitempty" xml:"TriggerType,omitempty"`
}

func (s UpdateTaskFlowScheduleRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowScheduleRequest) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowScheduleRequest) SetCronBeginDate(v string) *UpdateTaskFlowScheduleRequest {
	s.CronBeginDate = &v
	return s
}

func (s *UpdateTaskFlowScheduleRequest) SetCronEndDate(v string) *UpdateTaskFlowScheduleRequest {
	s.CronEndDate = &v
	return s
}

func (s *UpdateTaskFlowScheduleRequest) SetCronStr(v string) *UpdateTaskFlowScheduleRequest {
	s.CronStr = &v
	return s
}

func (s *UpdateTaskFlowScheduleRequest) SetCronType(v string) *UpdateTaskFlowScheduleRequest {
	s.CronType = &v
	return s
}

func (s *UpdateTaskFlowScheduleRequest) SetDagId(v int64) *UpdateTaskFlowScheduleRequest {
	s.DagId = &v
	return s
}

func (s *UpdateTaskFlowScheduleRequest) SetScheduleParam(v string) *UpdateTaskFlowScheduleRequest {
	s.ScheduleParam = &v
	return s
}

func (s *UpdateTaskFlowScheduleRequest) SetScheduleSwitch(v bool) *UpdateTaskFlowScheduleRequest {
	s.ScheduleSwitch = &v
	return s
}

func (s *UpdateTaskFlowScheduleRequest) SetTid(v int64) *UpdateTaskFlowScheduleRequest {
	s.Tid = &v
	return s
}

func (s *UpdateTaskFlowScheduleRequest) SetTimeZoneId(v string) *UpdateTaskFlowScheduleRequest {
	s.TimeZoneId = &v
	return s
}

func (s *UpdateTaskFlowScheduleRequest) SetTriggerType(v string) *UpdateTaskFlowScheduleRequest {
	s.TriggerType = &v
	return s
}

type UpdateTaskFlowScheduleResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateTaskFlowScheduleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowScheduleResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowScheduleResponseBody) SetErrorCode(v string) *UpdateTaskFlowScheduleResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateTaskFlowScheduleResponseBody) SetErrorMessage(v string) *UpdateTaskFlowScheduleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateTaskFlowScheduleResponseBody) SetRequestId(v string) *UpdateTaskFlowScheduleResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateTaskFlowScheduleResponseBody) SetSuccess(v bool) *UpdateTaskFlowScheduleResponseBody {
	s.Success = &v
	return s
}

type UpdateTaskFlowScheduleResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateTaskFlowScheduleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateTaskFlowScheduleResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowScheduleResponse) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowScheduleResponse) SetHeaders(v map[string]*string) *UpdateTaskFlowScheduleResponse {
	s.Headers = v
	return s
}

func (s *UpdateTaskFlowScheduleResponse) SetStatusCode(v int32) *UpdateTaskFlowScheduleResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTaskFlowScheduleResponse) SetBody(v *UpdateTaskFlowScheduleResponseBody) *UpdateTaskFlowScheduleResponse {
	s.Body = v
	return s
}

type UpdateTaskFlowTimeVariablesRequest struct {
	// The ID of the task node. You can call the [GetTaskInstanceRelation](~~424711~~) operation to query the node ID.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the tenant.
	//
	// > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The time variables for the task flow.
	TimeVariables *string `json:"TimeVariables,omitempty" xml:"TimeVariables,omitempty"`
}

func (s UpdateTaskFlowTimeVariablesRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowTimeVariablesRequest) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowTimeVariablesRequest) SetDagId(v int64) *UpdateTaskFlowTimeVariablesRequest {
	s.DagId = &v
	return s
}

func (s *UpdateTaskFlowTimeVariablesRequest) SetTid(v int64) *UpdateTaskFlowTimeVariablesRequest {
	s.Tid = &v
	return s
}

func (s *UpdateTaskFlowTimeVariablesRequest) SetTimeVariables(v string) *UpdateTaskFlowTimeVariablesRequest {
	s.TimeVariables = &v
	return s
}

type UpdateTaskFlowTimeVariablesResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can use the ID to locate logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateTaskFlowTimeVariablesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowTimeVariablesResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowTimeVariablesResponseBody) SetErrorCode(v string) *UpdateTaskFlowTimeVariablesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateTaskFlowTimeVariablesResponseBody) SetErrorMessage(v string) *UpdateTaskFlowTimeVariablesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateTaskFlowTimeVariablesResponseBody) SetRequestId(v string) *UpdateTaskFlowTimeVariablesResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateTaskFlowTimeVariablesResponseBody) SetSuccess(v bool) *UpdateTaskFlowTimeVariablesResponseBody {
	s.Success = &v
	return s
}

type UpdateTaskFlowTimeVariablesResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateTaskFlowTimeVariablesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateTaskFlowTimeVariablesResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskFlowTimeVariablesResponse) GoString() string {
	return s.String()
}

func (s *UpdateTaskFlowTimeVariablesResponse) SetHeaders(v map[string]*string) *UpdateTaskFlowTimeVariablesResponse {
	s.Headers = v
	return s
}

func (s *UpdateTaskFlowTimeVariablesResponse) SetStatusCode(v int32) *UpdateTaskFlowTimeVariablesResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTaskFlowTimeVariablesResponse) SetBody(v *UpdateTaskFlowTimeVariablesResponseBody) *UpdateTaskFlowTimeVariablesResponse {
	s.Body = v
	return s
}

type UpdateTaskNameRequest struct {
	// The ID of the node. You can call the [GetTaskInstanceRelation](~~424711~~) operation to query the node ID.
	NodeId *string `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The name of the node. You can call the [GetTaskInstanceRelation](~~424711~~) operation to query the node name.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The ID of the tenant.
	//
	// >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s UpdateTaskNameRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskNameRequest) GoString() string {
	return s.String()
}

func (s *UpdateTaskNameRequest) SetNodeId(v string) *UpdateTaskNameRequest {
	s.NodeId = &v
	return s
}

func (s *UpdateTaskNameRequest) SetNodeName(v string) *UpdateTaskNameRequest {
	s.NodeName = &v
	return s
}

func (s *UpdateTaskNameRequest) SetTid(v int64) *UpdateTaskNameRequest {
	s.Tid = &v
	return s
}

type UpdateTaskNameResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can use the ID to locate logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateTaskNameResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskNameResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTaskNameResponseBody) SetErrorCode(v string) *UpdateTaskNameResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateTaskNameResponseBody) SetErrorMessage(v string) *UpdateTaskNameResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateTaskNameResponseBody) SetRequestId(v string) *UpdateTaskNameResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateTaskNameResponseBody) SetSuccess(v bool) *UpdateTaskNameResponseBody {
	s.Success = &v
	return s
}

type UpdateTaskNameResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateTaskNameResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateTaskNameResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskNameResponse) GoString() string {
	return s.String()
}

func (s *UpdateTaskNameResponse) SetHeaders(v map[string]*string) *UpdateTaskNameResponse {
	s.Headers = v
	return s
}

func (s *UpdateTaskNameResponse) SetStatusCode(v int32) *UpdateTaskNameResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTaskNameResponse) SetBody(v *UpdateTaskNameResponseBody) *UpdateTaskNameResponse {
	s.Body = v
	return s
}

type UpdateTaskOutputRequest struct {
	// The ID of the node. You can call the [GetTaskInstanceRelation](~~424711~~) operation to query the node ID.
	NodeId *string `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The output variables for the task.
	NodeOutput *string `json:"NodeOutput,omitempty" xml:"NodeOutput,omitempty"`
	// The ID of the tenant.
	//
	// >  To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
}

func (s UpdateTaskOutputRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskOutputRequest) GoString() string {
	return s.String()
}

func (s *UpdateTaskOutputRequest) SetNodeId(v string) *UpdateTaskOutputRequest {
	s.NodeId = &v
	return s
}

func (s *UpdateTaskOutputRequest) SetNodeOutput(v string) *UpdateTaskOutputRequest {
	s.NodeOutput = &v
	return s
}

func (s *UpdateTaskOutputRequest) SetTid(v int64) *UpdateTaskOutputRequest {
	s.Tid = &v
	return s
}

type UpdateTaskOutputResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can use the ID to locate logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateTaskOutputResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskOutputResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTaskOutputResponseBody) SetErrorCode(v string) *UpdateTaskOutputResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateTaskOutputResponseBody) SetErrorMessage(v string) *UpdateTaskOutputResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateTaskOutputResponseBody) SetRequestId(v string) *UpdateTaskOutputResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateTaskOutputResponseBody) SetSuccess(v bool) *UpdateTaskOutputResponseBody {
	s.Success = &v
	return s
}

type UpdateTaskOutputResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateTaskOutputResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateTaskOutputResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskOutputResponse) GoString() string {
	return s.String()
}

func (s *UpdateTaskOutputResponse) SetHeaders(v map[string]*string) *UpdateTaskOutputResponse {
	s.Headers = v
	return s
}

func (s *UpdateTaskOutputResponse) SetStatusCode(v int32) *UpdateTaskOutputResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTaskOutputResponse) SetBody(v *UpdateTaskOutputResponseBody) *UpdateTaskOutputResponse {
	s.Body = v
	return s
}

type UpdateTaskTimeVariablesRequest struct {
	// The ID of the task node. You can call the [GetTaskInstanceRelation](~~424711~~) operation to query the node ID.
	NodeId *string `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The ID of the tenant.
	//
	// > :To view the ID of the tenant, go to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [View information about the current tenant](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The time variables configured for the node. The value of this parameter must be a JSON string.
	TimeVariables *string `json:"TimeVariables,omitempty" xml:"TimeVariables,omitempty"`
}

func (s UpdateTaskTimeVariablesRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskTimeVariablesRequest) GoString() string {
	return s.String()
}

func (s *UpdateTaskTimeVariablesRequest) SetNodeId(v string) *UpdateTaskTimeVariablesRequest {
	s.NodeId = &v
	return s
}

func (s *UpdateTaskTimeVariablesRequest) SetTid(v int64) *UpdateTaskTimeVariablesRequest {
	s.Tid = &v
	return s
}

func (s *UpdateTaskTimeVariablesRequest) SetTimeVariables(v string) *UpdateTaskTimeVariablesRequest {
	s.TimeVariables = &v
	return s
}

type UpdateTaskTimeVariablesResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateTaskTimeVariablesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskTimeVariablesResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTaskTimeVariablesResponseBody) SetErrorCode(v string) *UpdateTaskTimeVariablesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateTaskTimeVariablesResponseBody) SetErrorMessage(v string) *UpdateTaskTimeVariablesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateTaskTimeVariablesResponseBody) SetRequestId(v string) *UpdateTaskTimeVariablesResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateTaskTimeVariablesResponseBody) SetSuccess(v bool) *UpdateTaskTimeVariablesResponseBody {
	s.Success = &v
	return s
}

type UpdateTaskTimeVariablesResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateTaskTimeVariablesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateTaskTimeVariablesResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTaskTimeVariablesResponse) GoString() string {
	return s.String()
}

func (s *UpdateTaskTimeVariablesResponse) SetHeaders(v map[string]*string) *UpdateTaskTimeVariablesResponse {
	s.Headers = v
	return s
}

func (s *UpdateTaskTimeVariablesResponse) SetStatusCode(v int32) *UpdateTaskTimeVariablesResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTaskTimeVariablesResponse) SetBody(v *UpdateTaskTimeVariablesResponseBody) *UpdateTaskTimeVariablesResponse {
	s.Body = v
	return s
}

type UpdateUserRequest struct {
	// The maximum number of queries that can be performed each day.
	MaxExecuteCount *int64 `json:"MaxExecuteCount,omitempty" xml:"MaxExecuteCount,omitempty"`
	// The maximum number of rows that can be queried each day.
	MaxResultCount *int64 `json:"MaxResultCount,omitempty" xml:"MaxResultCount,omitempty"`
	// The DingTalk ID or mobile number of the user.
	Mobile *string `json:"Mobile,omitempty" xml:"Mobile,omitempty"`
	// The roles that the user assumes. For more information about the valid values, see the Request parameters section in the [UpdateUser](~~465812~~) topic.
	RoleNames *string `json:"RoleNames,omitempty" xml:"RoleNames,omitempty"`
	// The ID of the tenant.
	//
	// > : To view the ID of the tenant, log on to the Data Management (DMS) console and move the pointer over the profile picture in the upper-right corner. For more information, see [Manage DMS tenants](~~181330~~).
	Tid *int64 `json:"Tid,omitempty" xml:"Tid,omitempty"`
	// The Alibaba Cloud unique ID (UID) of the user to update.
	Uid *int64 `json:"Uid,omitempty" xml:"Uid,omitempty"`
	// The nickname of the user.
	UserNick *string `json:"UserNick,omitempty" xml:"UserNick,omitempty"`
}

func (s UpdateUserRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateUserRequest) GoString() string {
	return s.String()
}

func (s *UpdateUserRequest) SetMaxExecuteCount(v int64) *UpdateUserRequest {
	s.MaxExecuteCount = &v
	return s
}

func (s *UpdateUserRequest) SetMaxResultCount(v int64) *UpdateUserRequest {
	s.MaxResultCount = &v
	return s
}

func (s *UpdateUserRequest) SetMobile(v string) *UpdateUserRequest {
	s.Mobile = &v
	return s
}

func (s *UpdateUserRequest) SetRoleNames(v string) *UpdateUserRequest {
	s.RoleNames = &v
	return s
}

func (s *UpdateUserRequest) SetTid(v int64) *UpdateUserRequest {
	s.Tid = &v
	return s
}

func (s *UpdateUserRequest) SetUid(v int64) *UpdateUserRequest {
	s.Uid = &v
	return s
}

func (s *UpdateUserRequest) SetUserNick(v string) *UpdateUserRequest {
	s.UserNick = &v
	return s
}

type UpdateUserResponseBody struct {
	// The error code returned if the request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request succeeded.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateUserResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateUserResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateUserResponseBody) SetErrorCode(v string) *UpdateUserResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateUserResponseBody) SetErrorMessage(v string) *UpdateUserResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateUserResponseBody) SetRequestId(v string) *UpdateUserResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateUserResponseBody) SetSuccess(v bool) *UpdateUserResponseBody {
	s.Success = &v
	return s
}

type UpdateUserResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateUserResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateUserResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateUserResponse) GoString() string {
	return s.String()
}

func (s *UpdateUserResponse) SetHeaders(v map[string]*string) *UpdateUserResponse {
	s.Headers = v
	return s
}

func (s *UpdateUserResponse) SetStatusCode(v int32) *UpdateUserResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateUserResponse) SetBody(v *UpdateUserResponseBody) *UpdateUserResponse {
	s.Body = v
	return s
}

type Client struct {
	openapi.Client
}

func NewClient(config *openapi.Config) (*Client, error) {
	client := new(Client)
	err := client.Init(config)
	return client, err
}

func (client *Client) Init(config *openapi.Config) (_err error) {
	_err = client.Client.Init(config)
	if _err != nil {
		return _err
	}
	client.EndpointRule = tea.String("central")
	_err = client.CheckConfig(config)
	if _err != nil {
		return _err
	}
	client.Endpoint, _err = client.GetEndpoint(tea.String("dms-enterprise"), client.RegionId, client.EndpointRule, client.Network, client.Suffix, client.EndpointMap, client.Endpoint)
	if _err != nil {
		return _err
	}

	return nil
}

func (client *Client) GetEndpoint(productId *string, regionId *string, endpointRule *string, network *string, suffix *string, endpointMap map[string]*string, endpoint *string) (_result *string, _err error) {
	if !tea.BoolValue(util.Empty(endpoint)) {
		_result = endpoint
		return _result, _err
	}

	if !tea.BoolValue(util.IsUnset(endpointMap)) && !tea.BoolValue(util.Empty(endpointMap[tea.StringValue(regionId)])) {
		_result = endpointMap[tea.StringValue(regionId)]
		return _result, _err
	}

	_body, _err := endpointutil.GetEndpointRules(productId, regionId, endpointRule, network, suffix)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddDesensitizationRuleWithOptions(request *AddDesensitizationRuleRequest, runtime *util.RuntimeOptions) (_result *AddDesensitizationRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FunctionType)) {
		query["FunctionType"] = request.FunctionType
	}

	if !tea.BoolValue(util.IsUnset(request.RuleDescription)) {
		query["RuleDescription"] = request.RuleDescription
	}

	if !tea.BoolValue(util.IsUnset(request.RuleName)) {
		query["RuleName"] = request.RuleName
	}

	if !tea.BoolValue(util.IsUnset(request.RuleType)) {
		query["RuleType"] = request.RuleType
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	body := map[string]interface{}{}
	bodyFlat := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FunctionParams)) {
		bodyFlat["FunctionParams"] = request.FunctionParams
	}

	body = tea.ToMap(body,
		openapiutil.Query(bodyFlat))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("AddDesensitizationRule"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddDesensitizationRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddDesensitizationRule(request *AddDesensitizationRuleRequest) (_result *AddDesensitizationRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddDesensitizationRuleResponse{}
	_body, _err := client.AddDesensitizationRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddInstanceWithOptions(request *AddInstanceRequest, runtime *util.RuntimeOptions) (_result *AddInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DataLinkName)) {
		query["DataLinkName"] = request.DataLinkName
	}

	if !tea.BoolValue(util.IsUnset(request.DatabasePassword)) {
		query["DatabasePassword"] = request.DatabasePassword
	}

	if !tea.BoolValue(util.IsUnset(request.DatabaseUser)) {
		query["DatabaseUser"] = request.DatabaseUser
	}

	if !tea.BoolValue(util.IsUnset(request.DbaId)) {
		query["DbaId"] = request.DbaId
	}

	if !tea.BoolValue(util.IsUnset(request.DdlOnline)) {
		query["DdlOnline"] = request.DdlOnline
	}

	if !tea.BoolValue(util.IsUnset(request.EcsInstanceId)) {
		query["EcsInstanceId"] = request.EcsInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.EcsRegion)) {
		query["EcsRegion"] = request.EcsRegion
	}

	if !tea.BoolValue(util.IsUnset(request.EnableSellCommon)) {
		query["EnableSellCommon"] = request.EnableSellCommon
	}

	if !tea.BoolValue(util.IsUnset(request.EnableSellSitd)) {
		query["EnableSellSitd"] = request.EnableSellSitd
	}

	if !tea.BoolValue(util.IsUnset(request.EnableSellStable)) {
		query["EnableSellStable"] = request.EnableSellStable
	}

	if !tea.BoolValue(util.IsUnset(request.EnableSellTrust)) {
		query["EnableSellTrust"] = request.EnableSellTrust
	}

	if !tea.BoolValue(util.IsUnset(request.EnvType)) {
		query["EnvType"] = request.EnvType
	}

	if !tea.BoolValue(util.IsUnset(request.ExportTimeout)) {
		query["ExportTimeout"] = request.ExportTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.Host)) {
		query["Host"] = request.Host
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceAlias)) {
		query["InstanceAlias"] = request.InstanceAlias
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceSource)) {
		query["InstanceSource"] = request.InstanceSource
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceType)) {
		query["InstanceType"] = request.InstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkType)) {
		query["NetworkType"] = request.NetworkType
	}

	if !tea.BoolValue(util.IsUnset(request.Port)) {
		query["Port"] = request.Port
	}

	if !tea.BoolValue(util.IsUnset(request.QueryTimeout)) {
		query["QueryTimeout"] = request.QueryTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.SafeRule)) {
		query["SafeRule"] = request.SafeRule
	}

	if !tea.BoolValue(util.IsUnset(request.Sid)) {
		query["Sid"] = request.Sid
	}

	if !tea.BoolValue(util.IsUnset(request.SkipTest)) {
		query["SkipTest"] = request.SkipTest
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		query["TemplateId"] = request.TemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateType)) {
		query["TemplateType"] = request.TemplateType
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.UseDsql)) {
		query["UseDsql"] = request.UseDsql
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddInstance"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddInstance(request *AddInstanceRequest) (_result *AddInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddInstanceResponse{}
	_body, _err := client.AddInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You must call this operation as a DMS administrator, a database administrator (DBA), or a workspace administrator.
 * Usage notes:
 * *   Before you call this operation to add a user as a task flow developer, make sure that you have added the user as a workspace member.
 * *   You cannot call this operation to transfer the ownership of a task flow. To transfer the ownership of a task flow, call the [ChangLhDagOwner](~~424761~~) operation.
 * *   For more information about workspace roles and permissions, see [Manage permissions on a workspace](~~410893~~).
 *
 * @param tmpReq AddLhMembersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddLhMembersResponse
 */
func (client *Client) AddLhMembersWithOptions(tmpReq *AddLhMembersRequest, runtime *util.RuntimeOptions) (_result *AddLhMembersResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &AddLhMembersShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Members)) {
		request.MembersShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Members, tea.String("Members"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MembersShrink)) {
		query["Members"] = request.MembersShrink
	}

	if !tea.BoolValue(util.IsUnset(request.ObjectId)) {
		query["ObjectId"] = request.ObjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ObjectType)) {
		query["ObjectType"] = request.ObjectType
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddLhMembers"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddLhMembersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You must call this operation as a DMS administrator, a database administrator (DBA), or a workspace administrator.
 * Usage notes:
 * *   Before you call this operation to add a user as a task flow developer, make sure that you have added the user as a workspace member.
 * *   You cannot call this operation to transfer the ownership of a task flow. To transfer the ownership of a task flow, call the [ChangLhDagOwner](~~424761~~) operation.
 * *   For more information about workspace roles and permissions, see [Manage permissions on a workspace](~~410893~~).
 *
 * @param request AddLhMembersRequest
 * @return AddLhMembersResponse
 */
func (client *Client) AddLhMembers(request *AddLhMembersRequest) (_result *AddLhMembersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddLhMembersResponse{}
	_body, _err := client.AddLhMembersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddLogicTableRouteConfigWithOptions(request *AddLogicTableRouteConfigRequest, runtime *util.RuntimeOptions) (_result *AddLogicTableRouteConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RouteExpr)) {
		query["RouteExpr"] = request.RouteExpr
	}

	if !tea.BoolValue(util.IsUnset(request.RouteKey)) {
		query["RouteKey"] = request.RouteKey
	}

	if !tea.BoolValue(util.IsUnset(request.TableId)) {
		query["TableId"] = request.TableId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddLogicTableRouteConfig"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddLogicTableRouteConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddLogicTableRouteConfig(request *AddLogicTableRouteConfigRequest) (_result *AddLogicTableRouteConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddLogicTableRouteConfigResponse{}
	_body, _err := client.AddLogicTableRouteConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you add directed edges for a task node, take note of the following limits:
 * 1. The endpoints of the specified edge exist in the Directed Acyclic Graph (DAG) of the task flow specified by DagId.
 * 2. After a backward edge is added, the DAG does not contain loops.
 *
 * @param tmpReq AddTaskFlowEdgesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddTaskFlowEdgesResponse
 */
func (client *Client) AddTaskFlowEdgesWithOptions(tmpReq *AddTaskFlowEdgesRequest, runtime *util.RuntimeOptions) (_result *AddTaskFlowEdgesResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &AddTaskFlowEdgesShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Edges)) {
		request.EdgesShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Edges, tea.String("Edges"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.EdgesShrink)) {
		query["Edges"] = request.EdgesShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddTaskFlowEdges"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddTaskFlowEdgesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you add directed edges for a task node, take note of the following limits:
 * 1. The endpoints of the specified edge exist in the Directed Acyclic Graph (DAG) of the task flow specified by DagId.
 * 2. After a backward edge is added, the DAG does not contain loops.
 *
 * @param request AddTaskFlowEdgesRequest
 * @return AddTaskFlowEdgesResponse
 */
func (client *Client) AddTaskFlowEdges(request *AddTaskFlowEdgesRequest) (_result *AddTaskFlowEdgesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddTaskFlowEdgesResponse{}
	_body, _err := client.AddTaskFlowEdgesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The following conditions must be met before you call this API operation.
 * *   The database instance is of one of the following types: ApsaraDB RDS for MySQL, PolarDB for MySQL, AnalyticDB for MySQL, ApsaraDB RDS for PostgreSQL, PolarDB for PostgreSQL, AnalyticDB for PostgreSQL, Oracle, and openGauss.
 * *   A database instance is managed in Security Collaboration mode. For more information about control modes, see [Control modes](~~151629~~).
 *
 * @param request AnalyzeSQLLineageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AnalyzeSQLLineageResponse
 */
func (client *Client) AnalyzeSQLLineageWithOptions(request *AnalyzeSQLLineageRequest, runtime *util.RuntimeOptions) (_result *AnalyzeSQLLineageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DbId)) {
		query["DbId"] = request.DbId
	}

	if !tea.BoolValue(util.IsUnset(request.SqlContent)) {
		query["SqlContent"] = request.SqlContent
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AnalyzeSQLLineage"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AnalyzeSQLLineageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The following conditions must be met before you call this API operation.
 * *   The database instance is of one of the following types: ApsaraDB RDS for MySQL, PolarDB for MySQL, AnalyticDB for MySQL, ApsaraDB RDS for PostgreSQL, PolarDB for PostgreSQL, AnalyticDB for PostgreSQL, Oracle, and openGauss.
 * *   A database instance is managed in Security Collaboration mode. For more information about control modes, see [Control modes](~~151629~~).
 *
 * @param request AnalyzeSQLLineageRequest
 * @return AnalyzeSQLLineageResponse
 */
func (client *Client) AnalyzeSQLLineage(request *AnalyzeSQLLineageRequest) (_result *AnalyzeSQLLineageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AnalyzeSQLLineageResponse{}
	_body, _err := client.AnalyzeSQLLineageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ApproveOrderWithOptions(request *ApproveOrderRequest, runtime *util.RuntimeOptions) (_result *ApproveOrderResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApprovalNodeId)) {
		query["ApprovalNodeId"] = request.ApprovalNodeId
	}

	if !tea.BoolValue(util.IsUnset(request.ApprovalNodePos)) {
		query["ApprovalNodePos"] = request.ApprovalNodePos
	}

	if !tea.BoolValue(util.IsUnset(request.ApprovalType)) {
		query["ApprovalType"] = request.ApprovalType
	}

	if !tea.BoolValue(util.IsUnset(request.Comment)) {
		query["Comment"] = request.Comment
	}

	if !tea.BoolValue(util.IsUnset(request.NewApprover)) {
		query["NewApprover"] = request.NewApprover
	}

	if !tea.BoolValue(util.IsUnset(request.OldApprover)) {
		query["OldApprover"] = request.OldApprover
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.WorkflowInstanceId)) {
		query["WorkflowInstanceId"] = request.WorkflowInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ApproveOrder"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ApproveOrderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ApproveOrder(request *ApproveOrderRequest) (_result *ApproveOrderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ApproveOrderResponse{}
	_body, _err := client.ApproveOrderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * During a data backfill, task flows are run in sequence based on their dates. You can specify whether task flows are run in chronological or reverse chronological order. After the data backfill is complete, you can specify a date or date range, and a node range to run task flows.
 *
 * @param tmpReq BackFillRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BackFillResponse
 */
func (client *Client) BackFillWithOptions(tmpReq *BackFillRequest, runtime *util.RuntimeOptions) (_result *BackFillResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &BackFillShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.FilterNodeIds)) {
		request.FilterNodeIdsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.FilterNodeIds, tea.String("FilterNodeIds"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.StartNodeIds)) {
		request.StartNodeIdsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.StartNodeIds, tea.String("StartNodeIds"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Asc)) {
		query["Asc"] = request.Asc
	}

	if !tea.BoolValue(util.IsUnset(request.BackFillDate)) {
		query["BackFillDate"] = request.BackFillDate
	}

	if !tea.BoolValue(util.IsUnset(request.BackFillDateBegin)) {
		query["BackFillDateBegin"] = request.BackFillDateBegin
	}

	if !tea.BoolValue(util.IsUnset(request.BackFillDateEnd)) {
		query["BackFillDateEnd"] = request.BackFillDateEnd
	}

	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.FilterNodeIdsShrink)) {
		query["FilterNodeIds"] = request.FilterNodeIdsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.HistoryDagId)) {
		query["HistoryDagId"] = request.HistoryDagId
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IsTriggerSubTree)) {
		query["IsTriggerSubTree"] = request.IsTriggerSubTree
	}

	if !tea.BoolValue(util.IsUnset(request.StartNodeIdsShrink)) {
		query["StartNodeIds"] = request.StartNodeIdsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BackFill"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BackFillResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * During a data backfill, task flows are run in sequence based on their dates. You can specify whether task flows are run in chronological or reverse chronological order. After the data backfill is complete, you can specify a date or date range, and a node range to run task flows.
 *
 * @param request BackFillRequest
 * @return BackFillResponse
 */
func (client *Client) BackFill(request *BackFillRequest) (_result *BackFillResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BackFillResponse{}
	_body, _err := client.BackFillWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) BuyPayAsYouGoOrderWithOptions(request *BuyPayAsYouGoOrderRequest, runtime *util.RuntimeOptions) (_result *BuyPayAsYouGoOrderResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CommodityType)) {
		query["CommodityType"] = request.CommodityType
	}

	if !tea.BoolValue(util.IsUnset(request.InsNum)) {
		query["InsNum"] = request.InsNum
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.VersionType)) {
		query["VersionType"] = request.VersionType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BuyPayAsYouGoOrder"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BuyPayAsYouGoOrderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) BuyPayAsYouGoOrder(request *BuyPayAsYouGoOrderRequest) (_result *BuyPayAsYouGoOrderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BuyPayAsYouGoOrderResponse{}
	_body, _err := client.BuyPayAsYouGoOrderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ChangeColumnSecLevelWithOptions(request *ChangeColumnSecLevelRequest, runtime *util.RuntimeOptions) (_result *ChangeColumnSecLevelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ColumnName)) {
		query["ColumnName"] = request.ColumnName
	}

	if !tea.BoolValue(util.IsUnset(request.DbId)) {
		query["DbId"] = request.DbId
	}

	if !tea.BoolValue(util.IsUnset(request.IsLogic)) {
		query["IsLogic"] = request.IsLogic
	}

	if !tea.BoolValue(util.IsUnset(request.NewLevel)) {
		query["NewLevel"] = request.NewLevel
	}

	if !tea.BoolValue(util.IsUnset(request.SchemaName)) {
		query["SchemaName"] = request.SchemaName
	}

	if !tea.BoolValue(util.IsUnset(request.TableName)) {
		query["TableName"] = request.TableName
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ChangeColumnSecLevel"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ChangeColumnSecLevelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ChangeColumnSecLevel(request *ChangeColumnSecLevelRequest) (_result *ChangeColumnSecLevelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ChangeColumnSecLevelResponse{}
	_body, _err := client.ChangeColumnSecLevelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ChangeColumnSecurityLevelWithOptions(request *ChangeColumnSecurityLevelRequest, runtime *util.RuntimeOptions) (_result *ChangeColumnSecurityLevelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ColumnName)) {
		query["ColumnName"] = request.ColumnName
	}

	if !tea.BoolValue(util.IsUnset(request.DbId)) {
		query["DbId"] = request.DbId
	}

	if !tea.BoolValue(util.IsUnset(request.IsLogic)) {
		query["IsLogic"] = request.IsLogic
	}

	if !tea.BoolValue(util.IsUnset(request.NewSensitivityLevel)) {
		query["NewSensitivityLevel"] = request.NewSensitivityLevel
	}

	if !tea.BoolValue(util.IsUnset(request.SchemaName)) {
		query["SchemaName"] = request.SchemaName
	}

	if !tea.BoolValue(util.IsUnset(request.TableName)) {
		query["TableName"] = request.TableName
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ChangeColumnSecurityLevel"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ChangeColumnSecurityLevelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ChangeColumnSecurityLevel(request *ChangeColumnSecurityLevelRequest) (_result *ChangeColumnSecurityLevelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ChangeColumnSecurityLevelResponse{}
	_body, _err := client.ChangeColumnSecurityLevelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Usage notes:
 * *   If you call this operation to transfer the ownership of a published task flow, the ownership transfer does not take effect.
 * *   You can call the [ReDeployLhDagVersion](~~424712~~) operation to redeploy a published version of a task flow.
 *
 * @param request ChangeLhDagOwnerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeLhDagOwnerResponse
 */
func (client *Client) ChangeLhDagOwnerWithOptions(request *ChangeLhDagOwnerRequest, runtime *util.RuntimeOptions) (_result *ChangeLhDagOwnerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerUserId)) {
		query["OwnerUserId"] = request.OwnerUserId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ChangeLhDagOwner"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ChangeLhDagOwnerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Usage notes:
 * *   If you call this operation to transfer the ownership of a published task flow, the ownership transfer does not take effect.
 * *   You can call the [ReDeployLhDagVersion](~~424712~~) operation to redeploy a published version of a task flow.
 *
 * @param request ChangeLhDagOwnerRequest
 * @return ChangeLhDagOwnerResponse
 */
func (client *Client) ChangeLhDagOwner(request *ChangeLhDagOwnerRequest) (_result *ChangeLhDagOwnerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ChangeLhDagOwnerResponse{}
	_body, _err := client.ChangeLhDagOwnerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CloseOrderWithOptions(request *CloseOrderRequest, runtime *util.RuntimeOptions) (_result *CloseOrderResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CloseReason)) {
		query["CloseReason"] = request.CloseReason
	}

	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CloseOrder"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CloseOrderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CloseOrder(request *CloseOrderRequest) (_result *CloseOrderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CloseOrderResponse{}
	_body, _err := client.CloseOrderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You are a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](~~324212~~).
 *
 * @param request CreateAuthorityTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAuthorityTemplateResponse
 */
func (client *Client) CreateAuthorityTemplateWithOptions(request *CreateAuthorityTemplateRequest, runtime *util.RuntimeOptions) (_result *CreateAuthorityTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateAuthorityTemplate"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateAuthorityTemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You are a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](~~324212~~).
 *
 * @param request CreateAuthorityTemplateRequest
 * @return CreateAuthorityTemplateResponse
 */
func (client *Client) CreateAuthorityTemplate(request *CreateAuthorityTemplateRequest) (_result *CreateAuthorityTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateAuthorityTemplateResponse{}
	_body, _err := client.CreateAuthorityTemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateDataArchiveOrderWithOptions(tmpReq *CreateDataArchiveOrderRequest, runtime *util.RuntimeOptions) (_result *CreateDataArchiveOrderResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateDataArchiveOrderShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Param)) {
		request.ParamShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Param, tea.String("Param"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.RelatedUserList)) {
		request.RelatedUserListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.RelatedUserList, tea.String("RelatedUserList"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Comment)) {
		query["Comment"] = request.Comment
	}

	if !tea.BoolValue(util.IsUnset(request.ParamShrink)) {
		query["Param"] = request.ParamShrink
	}

	if !tea.BoolValue(util.IsUnset(request.ParentId)) {
		query["ParentId"] = request.ParentId
	}

	if !tea.BoolValue(util.IsUnset(request.PluginType)) {
		query["PluginType"] = request.PluginType
	}

	if !tea.BoolValue(util.IsUnset(request.RelatedUserListShrink)) {
		query["RelatedUserList"] = request.RelatedUserListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDataArchiveOrder"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDataArchiveOrderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateDataArchiveOrder(request *CreateDataArchiveOrderRequest) (_result *CreateDataArchiveOrderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDataArchiveOrderResponse{}
	_body, _err := client.CreateDataArchiveOrderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * For more information about the Normal Data Modify feature, see [Change regular data](~~58419~~).
 *
 * @param tmpReq CreateDataCorrectOrderRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDataCorrectOrderResponse
 */
func (client *Client) CreateDataCorrectOrderWithOptions(tmpReq *CreateDataCorrectOrderRequest, runtime *util.RuntimeOptions) (_result *CreateDataCorrectOrderResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateDataCorrectOrderShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Param)) {
		request.ParamShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Param, tea.String("Param"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.RelatedUserList)) {
		request.RelatedUserListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.RelatedUserList, tea.String("RelatedUserList"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AttachmentKey)) {
		query["AttachmentKey"] = request.AttachmentKey
	}

	if !tea.BoolValue(util.IsUnset(request.Comment)) {
		query["Comment"] = request.Comment
	}

	if !tea.BoolValue(util.IsUnset(request.ParamShrink)) {
		query["Param"] = request.ParamShrink
	}

	if !tea.BoolValue(util.IsUnset(request.RelatedUserListShrink)) {
		query["RelatedUserList"] = request.RelatedUserListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDataCorrectOrder"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDataCorrectOrderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * For more information about the Normal Data Modify feature, see [Change regular data](~~58419~~).
 *
 * @param request CreateDataCorrectOrderRequest
 * @return CreateDataCorrectOrderResponse
 */
func (client *Client) CreateDataCorrectOrder(request *CreateDataCorrectOrderRequest) (_result *CreateDataCorrectOrderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDataCorrectOrderResponse{}
	_body, _err := client.CreateDataCorrectOrderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * For more information about the historical data cleaning, see [Clear historical data](~~162507~~).
 * This operation can be used only for MySQL databases.
 *
 * @param tmpReq CreateDataCronClearOrderRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDataCronClearOrderResponse
 */
func (client *Client) CreateDataCronClearOrderWithOptions(tmpReq *CreateDataCronClearOrderRequest, runtime *util.RuntimeOptions) (_result *CreateDataCronClearOrderResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateDataCronClearOrderShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Param)) {
		request.ParamShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Param, tea.String("Param"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.RelatedUserList)) {
		request.RelatedUserListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.RelatedUserList, tea.String("RelatedUserList"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AttachmentKey)) {
		query["AttachmentKey"] = request.AttachmentKey
	}

	if !tea.BoolValue(util.IsUnset(request.Comment)) {
		query["Comment"] = request.Comment
	}

	if !tea.BoolValue(util.IsUnset(request.ParamShrink)) {
		query["Param"] = request.ParamShrink
	}

	if !tea.BoolValue(util.IsUnset(request.RelatedUserListShrink)) {
		query["RelatedUserList"] = request.RelatedUserListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDataCronClearOrder"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDataCronClearOrderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * For more information about the historical data cleaning, see [Clear historical data](~~162507~~).
 * This operation can be used only for MySQL databases.
 *
 * @param request CreateDataCronClearOrderRequest
 * @return CreateDataCronClearOrderResponse
 */
func (client *Client) CreateDataCronClearOrder(request *CreateDataCronClearOrderRequest) (_result *CreateDataCronClearOrderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDataCronClearOrderResponse{}
	_body, _err := client.CreateDataCronClearOrderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateDataExportOrderWithOptions(tmpReq *CreateDataExportOrderRequest, runtime *util.RuntimeOptions) (_result *CreateDataExportOrderResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateDataExportOrderShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.PluginParam)) {
		request.PluginParamShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.PluginParam, tea.String("PluginParam"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.RelatedUserList)) {
		request.RelatedUserListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.RelatedUserList, tea.String("RelatedUserList"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AttachmentKey)) {
		query["AttachmentKey"] = request.AttachmentKey
	}

	if !tea.BoolValue(util.IsUnset(request.Comment)) {
		query["Comment"] = request.Comment
	}

	if !tea.BoolValue(util.IsUnset(request.ParentId)) {
		query["ParentId"] = request.ParentId
	}

	if !tea.BoolValue(util.IsUnset(request.PluginParamShrink)) {
		query["PluginParam"] = request.PluginParamShrink
	}

	if !tea.BoolValue(util.IsUnset(request.RelatedUserListShrink)) {
		query["RelatedUserList"] = request.RelatedUserListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDataExportOrder"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDataExportOrderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateDataExportOrder(request *CreateDataExportOrderRequest) (_result *CreateDataExportOrderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDataExportOrderResponse{}
	_body, _err := client.CreateDataExportOrderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * For more information about the Large Data Import feature, see [Import data](~~161439~~).
 *
 * @param tmpReq CreateDataImportOrderRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDataImportOrderResponse
 */
func (client *Client) CreateDataImportOrderWithOptions(tmpReq *CreateDataImportOrderRequest, runtime *util.RuntimeOptions) (_result *CreateDataImportOrderResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateDataImportOrderShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Param)) {
		request.ParamShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Param, tea.String("Param"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.RelatedUserList)) {
		request.RelatedUserListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.RelatedUserList, tea.String("RelatedUserList"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AttachmentKey)) {
		query["AttachmentKey"] = request.AttachmentKey
	}

	if !tea.BoolValue(util.IsUnset(request.Comment)) {
		query["Comment"] = request.Comment
	}

	if !tea.BoolValue(util.IsUnset(request.ParamShrink)) {
		query["Param"] = request.ParamShrink
	}

	if !tea.BoolValue(util.IsUnset(request.RelatedUserListShrink)) {
		query["RelatedUserList"] = request.RelatedUserListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDataImportOrder"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDataImportOrderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * For more information about the Large Data Import feature, see [Import data](~~161439~~).
 *
 * @param request CreateDataImportOrderRequest
 * @return CreateDataImportOrderResponse
 */
func (client *Client) CreateDataImportOrder(request *CreateDataImportOrderRequest) (_result *CreateDataImportOrderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDataImportOrderResponse{}
	_body, _err := client.CreateDataImportOrderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation is available only for instances that are managed in Security Collaboration mode.
 *
 * @param tmpReq CreateDataTrackOrderRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDataTrackOrderResponse
 */
func (client *Client) CreateDataTrackOrderWithOptions(tmpReq *CreateDataTrackOrderRequest, runtime *util.RuntimeOptions) (_result *CreateDataTrackOrderResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateDataTrackOrderShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Param)) {
		request.ParamShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Param, tea.String("Param"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.RelatedUserList)) {
		request.RelatedUserListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.RelatedUserList, tea.String("RelatedUserList"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Comment)) {
		query["Comment"] = request.Comment
	}

	if !tea.BoolValue(util.IsUnset(request.ParamShrink)) {
		query["Param"] = request.ParamShrink
	}

	if !tea.BoolValue(util.IsUnset(request.RelatedUserListShrink)) {
		query["RelatedUserList"] = request.RelatedUserListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDataTrackOrder"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDataTrackOrderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation is available only for instances that are managed in Security Collaboration mode.
 *
 * @param request CreateDataTrackOrderRequest
 * @return CreateDataTrackOrderResponse
 */
func (client *Client) CreateDataTrackOrder(request *CreateDataTrackOrderRequest) (_result *CreateDataTrackOrderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDataTrackOrderResponse{}
	_body, _err := client.CreateDataTrackOrderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateDatabaseExportOrderWithOptions(tmpReq *CreateDatabaseExportOrderRequest, runtime *util.RuntimeOptions) (_result *CreateDatabaseExportOrderResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateDatabaseExportOrderShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.PluginParam)) {
		request.PluginParamShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.PluginParam, tea.String("PluginParam"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.RelatedUserList)) {
		request.RelatedUserListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.RelatedUserList, tea.String("RelatedUserList"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AttachmentKey)) {
		query["AttachmentKey"] = request.AttachmentKey
	}

	if !tea.BoolValue(util.IsUnset(request.Comment)) {
		query["Comment"] = request.Comment
	}

	if !tea.BoolValue(util.IsUnset(request.ParentId)) {
		query["ParentId"] = request.ParentId
	}

	if !tea.BoolValue(util.IsUnset(request.PluginParamShrink)) {
		query["PluginParam"] = request.PluginParamShrink
	}

	if !tea.BoolValue(util.IsUnset(request.RelatedUserListShrink)) {
		query["RelatedUserList"] = request.RelatedUserListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDatabaseExportOrder"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDatabaseExportOrderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateDatabaseExportOrder(request *CreateDatabaseExportOrderRequest) (_result *CreateDatabaseExportOrderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDatabaseExportOrderResponse{}
	_body, _err := client.CreateDatabaseExportOrderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * For more information about the lock-free change feature, see [Overview](~~207847~~).
 * This operation can be used only for instances that are managed in Stable Change or Security Collaboration mode. For more information, see [Change data without the need to lock tables](~~96145~~) and [Change schemas without locking tables](~~98373~~).
 *
 * @param tmpReq CreateFreeLockCorrectOrderRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFreeLockCorrectOrderResponse
 */
func (client *Client) CreateFreeLockCorrectOrderWithOptions(tmpReq *CreateFreeLockCorrectOrderRequest, runtime *util.RuntimeOptions) (_result *CreateFreeLockCorrectOrderResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateFreeLockCorrectOrderShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Param)) {
		request.ParamShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Param, tea.String("Param"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.RelatedUserList)) {
		request.RelatedUserListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.RelatedUserList, tea.String("RelatedUserList"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AttachmentKey)) {
		query["AttachmentKey"] = request.AttachmentKey
	}

	if !tea.BoolValue(util.IsUnset(request.Comment)) {
		query["Comment"] = request.Comment
	}

	if !tea.BoolValue(util.IsUnset(request.ParamShrink)) {
		query["Param"] = request.ParamShrink
	}

	if !tea.BoolValue(util.IsUnset(request.RelatedUserListShrink)) {
		query["RelatedUserList"] = request.RelatedUserListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateFreeLockCorrectOrder"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateFreeLockCorrectOrderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * For more information about the lock-free change feature, see [Overview](~~207847~~).
 * This operation can be used only for instances that are managed in Stable Change or Security Collaboration mode. For more information, see [Change data without the need to lock tables](~~96145~~) and [Change schemas without locking tables](~~98373~~).
 *
 * @param request CreateFreeLockCorrectOrderRequest
 * @return CreateFreeLockCorrectOrderResponse
 */
func (client *Client) CreateFreeLockCorrectOrder(request *CreateFreeLockCorrectOrderRequest) (_result *CreateFreeLockCorrectOrderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateFreeLockCorrectOrderResponse{}
	_body, _err := client.CreateFreeLockCorrectOrderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The workspace name must be unique within a tenant. If a workspace with the same name already exists within the tenant, the call may fail.
 * *   You can call the [GetLhSpaceByName](~~424379~~) operation to query whether a workspace with a specific name already exists as a DMS administrator or database administrator (DBA).
 *
 * @param request CreateLakeHouseSpaceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateLakeHouseSpaceResponse
 */
func (client *Client) CreateLakeHouseSpaceWithOptions(request *CreateLakeHouseSpaceRequest, runtime *util.RuntimeOptions) (_result *CreateLakeHouseSpaceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DevDbId)) {
		query["DevDbId"] = request.DevDbId
	}

	if !tea.BoolValue(util.IsUnset(request.DwDbType)) {
		query["DwDbType"] = request.DwDbType
	}

	if !tea.BoolValue(util.IsUnset(request.Mode)) {
		query["Mode"] = request.Mode
	}

	if !tea.BoolValue(util.IsUnset(request.ProdDbId)) {
		query["ProdDbId"] = request.ProdDbId
	}

	if !tea.BoolValue(util.IsUnset(request.SpaceConfig)) {
		query["SpaceConfig"] = request.SpaceConfig
	}

	if !tea.BoolValue(util.IsUnset(request.SpaceName)) {
		query["SpaceName"] = request.SpaceName
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateLakeHouseSpace"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateLakeHouseSpaceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The workspace name must be unique within a tenant. If a workspace with the same name already exists within the tenant, the call may fail.
 * *   You can call the [GetLhSpaceByName](~~424379~~) operation to query whether a workspace with a specific name already exists as a DMS administrator or database administrator (DBA).
 *
 * @param request CreateLakeHouseSpaceRequest
 * @return CreateLakeHouseSpaceResponse
 */
func (client *Client) CreateLakeHouseSpace(request *CreateLakeHouseSpaceRequest) (_result *CreateLakeHouseSpaceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateLakeHouseSpaceResponse{}
	_body, _err := client.CreateLakeHouseSpaceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateLogicDatabaseWithOptions(tmpReq *CreateLogicDatabaseRequest, runtime *util.RuntimeOptions) (_result *CreateLogicDatabaseResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateLogicDatabaseShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.DatabaseIds)) {
		request.DatabaseIdsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.DatabaseIds, tea.String("DatabaseIds"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Alias)) {
		query["Alias"] = request.Alias
	}

	if !tea.BoolValue(util.IsUnset(request.DatabaseIdsShrink)) {
		query["DatabaseIds"] = request.DatabaseIdsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateLogicDatabase"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateLogicDatabaseResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateLogicDatabase(request *CreateLogicDatabaseRequest) (_result *CreateLogicDatabaseResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateLogicDatabaseResponse{}
	_body, _err := client.CreateLogicDatabaseWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * To facilitate ticket creation, you can call the following dedicated operations to create some types of tickets:
 * *   [CreateDataCorrectOrder](~~208388~~): creates a regular data change ticket.
 * *   [CreateDataCronClearOrder](~~208385~~): creates a ticket to clear historical data.
 * *   [CreateDataImportOrder](~~208387~~): creates a data import ticket.
 * *   [CreateFreeLockCorrectOrder](~~208386~~): creates a lock-free change ticket.
 *
 * @param tmpReq CreateOrderRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOrderResponse
 */
func (client *Client) CreateOrderWithOptions(tmpReq *CreateOrderRequest, runtime *util.RuntimeOptions) (_result *CreateOrderResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateOrderShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.PluginParam)) {
		request.PluginParamShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.PluginParam, tea.String("PluginParam"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AttachmentKey)) {
		query["AttachmentKey"] = request.AttachmentKey
	}

	if !tea.BoolValue(util.IsUnset(request.Comment)) {
		query["Comment"] = request.Comment
	}

	if !tea.BoolValue(util.IsUnset(request.PluginType)) {
		query["PluginType"] = request.PluginType
	}

	if !tea.BoolValue(util.IsUnset(request.RelatedUserList)) {
		query["RelatedUserList"] = request.RelatedUserList
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PluginParamShrink)) {
		body["PluginParam"] = request.PluginParamShrink
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateOrder"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateOrderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * To facilitate ticket creation, you can call the following dedicated operations to create some types of tickets:
 * *   [CreateDataCorrectOrder](~~208388~~): creates a regular data change ticket.
 * *   [CreateDataCronClearOrder](~~208385~~): creates a ticket to clear historical data.
 * *   [CreateDataImportOrder](~~208387~~): creates a data import ticket.
 * *   [CreateFreeLockCorrectOrder](~~208386~~): creates a lock-free change ticket.
 *
 * @param request CreateOrderRequest
 * @return CreateOrderResponse
 */
func (client *Client) CreateOrder(request *CreateOrderRequest) (_result *CreateOrderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateOrderResponse{}
	_body, _err := client.CreateOrderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateProcCorrectOrderWithOptions(tmpReq *CreateProcCorrectOrderRequest, runtime *util.RuntimeOptions) (_result *CreateProcCorrectOrderResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateProcCorrectOrderShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Param)) {
		request.ParamShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Param, tea.String("Param"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.RelatedUserList)) {
		request.RelatedUserListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.RelatedUserList, tea.String("RelatedUserList"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AttachmentKey)) {
		query["AttachmentKey"] = request.AttachmentKey
	}

	if !tea.BoolValue(util.IsUnset(request.Comment)) {
		query["Comment"] = request.Comment
	}

	if !tea.BoolValue(util.IsUnset(request.ParamShrink)) {
		query["Param"] = request.ParamShrink
	}

	if !tea.BoolValue(util.IsUnset(request.RelatedUserListShrink)) {
		query["RelatedUserList"] = request.RelatedUserListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateProcCorrectOrder"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateProcCorrectOrderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateProcCorrectOrder(request *CreateProcCorrectOrderRequest) (_result *CreateProcCorrectOrderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateProcCorrectOrderResponse{}
	_body, _err := client.CreateProcCorrectOrderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * - The database instance runs the MySQL or MariaDB database engine. For example, the database instance can be an ApsaraDB RDS for MySQL instance, a PolarDB for MySQL cluster, a Distributed Relational Database Service (DRDS) cluster, or an AnalyticDB for MySQL cluster. The database instance can also be a self-managed MySQL or MariaDB database, or a MySQL or MariaDB database in a third-party cloud.
 * - The database instance resides in the China (Hangzhou) or China (Beijing) region.
 * - You are a Data Management (DMS) administrator, a database administrator (DBA), or the owner of the database instance.
 *
 * @param request CreateProxyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateProxyResponse
 */
func (client *Client) CreateProxyWithOptions(request *CreateProxyRequest, runtime *util.RuntimeOptions) (_result *CreateProxyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Password)) {
		query["Password"] = request.Password
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.Username)) {
		query["Username"] = request.Username
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateProxy"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateProxyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * - The database instance runs the MySQL or MariaDB database engine. For example, the database instance can be an ApsaraDB RDS for MySQL instance, a PolarDB for MySQL cluster, a Distributed Relational Database Service (DRDS) cluster, or an AnalyticDB for MySQL cluster. The database instance can also be a self-managed MySQL or MariaDB database, or a MySQL or MariaDB database in a third-party cloud.
 * - The database instance resides in the China (Hangzhou) or China (Beijing) region.
 * - You are a Data Management (DMS) administrator, a database administrator (DBA), or the owner of the database instance.
 *
 * @param request CreateProxyRequest
 * @return CreateProxyResponse
 */
func (client *Client) CreateProxy(request *CreateProxyRequest) (_result *CreateProxyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateProxyResponse{}
	_body, _err := client.CreateProxyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * - The data security protection feature is enabled for the instance.
 * - Your user role is the administrator role, DBA role, or the owner of data security protection for the current instance.
 *
 * @param request CreateProxyAccessRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateProxyAccessResponse
 */
func (client *Client) CreateProxyAccessWithOptions(request *CreateProxyAccessRequest, runtime *util.RuntimeOptions) (_result *CreateProxyAccessResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IndepAccount)) {
		query["IndepAccount"] = request.IndepAccount
	}

	if !tea.BoolValue(util.IsUnset(request.IndepPassword)) {
		query["IndepPassword"] = request.IndepPassword
	}

	if !tea.BoolValue(util.IsUnset(request.ProxyId)) {
		query["ProxyId"] = request.ProxyId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.UserId)) {
		query["UserId"] = request.UserId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateProxyAccess"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateProxyAccessResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * - The data security protection feature is enabled for the instance.
 * - Your user role is the administrator role, DBA role, or the owner of data security protection for the current instance.
 *
 * @param request CreateProxyAccessRequest
 * @return CreateProxyAccessResponse
 */
func (client *Client) CreateProxyAccess(request *CreateProxyAccessRequest) (_result *CreateProxyAccessResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateProxyAccessResponse{}
	_body, _err := client.CreateProxyAccessWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreatePublishGroupTaskWithOptions(request *CreatePublishGroupTaskRequest, runtime *util.RuntimeOptions) (_result *CreatePublishGroupTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DbId)) {
		query["DbId"] = request.DbId
	}

	if !tea.BoolValue(util.IsUnset(request.Logic)) {
		query["Logic"] = request.Logic
	}

	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.PlanTime)) {
		query["PlanTime"] = request.PlanTime
	}

	if !tea.BoolValue(util.IsUnset(request.PublishStrategy)) {
		query["PublishStrategy"] = request.PublishStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreatePublishGroupTask"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreatePublishGroupTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreatePublishGroupTask(request *CreatePublishGroupTaskRequest) (_result *CreatePublishGroupTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreatePublishGroupTaskResponse{}
	_body, _err := client.CreatePublishGroupTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * For more information about the SQL review feature, see [SQL review](~~60374~~).
 *
 * @param tmpReq CreateSQLReviewOrderRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSQLReviewOrderResponse
 */
func (client *Client) CreateSQLReviewOrderWithOptions(tmpReq *CreateSQLReviewOrderRequest, runtime *util.RuntimeOptions) (_result *CreateSQLReviewOrderResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateSQLReviewOrderShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Param)) {
		request.ParamShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Param, tea.String("Param"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.RelatedUserList)) {
		request.RelatedUserListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.RelatedUserList, tea.String("RelatedUserList"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Comment)) {
		query["Comment"] = request.Comment
	}

	if !tea.BoolValue(util.IsUnset(request.ParamShrink)) {
		query["Param"] = request.ParamShrink
	}

	if !tea.BoolValue(util.IsUnset(request.RelatedUserListShrink)) {
		query["RelatedUserList"] = request.RelatedUserListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateSQLReviewOrder"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateSQLReviewOrderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * For more information about the SQL review feature, see [SQL review](~~60374~~).
 *
 * @param request CreateSQLReviewOrderRequest
 * @return CreateSQLReviewOrderResponse
 */
func (client *Client) CreateSQLReviewOrder(request *CreateSQLReviewOrderRequest) (_result *CreateSQLReviewOrderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateSQLReviewOrderResponse{}
	_body, _err := client.CreateSQLReviewOrderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateScenarioWithOptions(request *CreateScenarioRequest, runtime *util.RuntimeOptions) (_result *CreateScenarioResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.ScenarioName)) {
		query["ScenarioName"] = request.ScenarioName
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateScenario"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateScenarioResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateScenario(request *CreateScenarioRequest) (_result *CreateScenarioResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateScenarioResponse{}
	_body, _err := client.CreateScenarioWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateStandardGroupWithOptions(request *CreateStandardGroupRequest, runtime *util.RuntimeOptions) (_result *CreateStandardGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DbType)) {
		query["DbType"] = request.DbType
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateStandardGroup"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateStandardGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateStandardGroup(request *CreateStandardGroupRequest) (_result *CreateStandardGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateStandardGroupResponse{}
	_body, _err := client.CreateStandardGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateStructSyncOrderWithOptions(tmpReq *CreateStructSyncOrderRequest, runtime *util.RuntimeOptions) (_result *CreateStructSyncOrderResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateStructSyncOrderShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Param)) {
		request.ParamShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Param, tea.String("Param"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.RelatedUserList)) {
		request.RelatedUserListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.RelatedUserList, tea.String("RelatedUserList"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AttachmentKey)) {
		query["AttachmentKey"] = request.AttachmentKey
	}

	if !tea.BoolValue(util.IsUnset(request.Comment)) {
		query["Comment"] = request.Comment
	}

	if !tea.BoolValue(util.IsUnset(request.ParamShrink)) {
		query["Param"] = request.ParamShrink
	}

	if !tea.BoolValue(util.IsUnset(request.RelatedUserListShrink)) {
		query["RelatedUserList"] = request.RelatedUserListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateStructSyncOrder"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateStructSyncOrderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateStructSyncOrder(request *CreateStructSyncOrderRequest) (_result *CreateStructSyncOrderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateStructSyncOrderResponse{}
	_body, _err := client.CreateStructSyncOrderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateTaskWithOptions(request *CreateTaskRequest, runtime *util.RuntimeOptions) (_result *CreateTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.GraphParam)) {
		query["GraphParam"] = request.GraphParam
	}

	if !tea.BoolValue(util.IsUnset(request.NodeContent)) {
		query["NodeContent"] = request.NodeContent
	}

	if !tea.BoolValue(util.IsUnset(request.NodeName)) {
		query["NodeName"] = request.NodeName
	}

	if !tea.BoolValue(util.IsUnset(request.NodeOutput)) {
		query["NodeOutput"] = request.NodeOutput
	}

	if !tea.BoolValue(util.IsUnset(request.NodeType)) {
		query["NodeType"] = request.NodeType
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.TimeVariables)) {
		query["TimeVariables"] = request.TimeVariables
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateTask"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateTask(request *CreateTaskRequest) (_result *CreateTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateTaskResponse{}
	_body, _err := client.CreateTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateTaskFlowWithOptions(request *CreateTaskFlowRequest, runtime *util.RuntimeOptions) (_result *CreateTaskFlowResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagName)) {
		query["DagName"] = request.DagName
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.ScenarioId)) {
		query["ScenarioId"] = request.ScenarioId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateTaskFlow"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateTaskFlowResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateTaskFlow(request *CreateTaskFlowRequest) (_result *CreateTaskFlowResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateTaskFlowResponse{}
	_body, _err := client.CreateTaskFlowWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateUploadFileJobWithOptions(request *CreateUploadFileJobRequest, runtime *util.RuntimeOptions) (_result *CreateUploadFileJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FileName)) {
		query["FileName"] = request.FileName
	}

	if !tea.BoolValue(util.IsUnset(request.FileSource)) {
		query["FileSource"] = request.FileSource
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.UploadURL)) {
		query["UploadURL"] = request.UploadURL
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateUploadFileJob"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateUploadFileJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateUploadFileJob(request *CreateUploadFileJobRequest) (_result *CreateUploadFileJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateUploadFileJobResponse{}
	_body, _err := client.CreateUploadFileJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateUploadOSSFileJobWithOptions(tmpReq *CreateUploadOSSFileJobRequest, runtime *util.RuntimeOptions) (_result *CreateUploadOSSFileJobResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateUploadOSSFileJobShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.UploadTarget)) {
		request.UploadTargetShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.UploadTarget, tea.String("UploadTarget"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FileName)) {
		query["FileName"] = request.FileName
	}

	if !tea.BoolValue(util.IsUnset(request.FileSource)) {
		query["FileSource"] = request.FileSource
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.UploadTargetShrink)) {
		query["UploadTarget"] = request.UploadTargetShrink
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateUploadOSSFileJob"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateUploadOSSFileJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateUploadOSSFileJob(request *CreateUploadOSSFileJobRequest) (_result *CreateUploadOSSFileJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateUploadOSSFileJobResponse{}
	_body, _err := client.CreateUploadOSSFileJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteAuthorityTemplateWithOptions(request *DeleteAuthorityTemplateRequest, runtime *util.RuntimeOptions) (_result *DeleteAuthorityTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		query["TemplateId"] = request.TemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAuthorityTemplate"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteAuthorityTemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteAuthorityTemplate(request *DeleteAuthorityTemplateRequest) (_result *DeleteAuthorityTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAuthorityTemplateResponse{}
	_body, _err := client.DeleteAuthorityTemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Note: You can call this operation only to remove a database instance from the instance list of DMS. The instance is not deleted or shut down.
 *
 * @param request DeleteInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteInstanceResponse
 */
func (client *Client) DeleteInstanceWithOptions(request *DeleteInstanceRequest, runtime *util.RuntimeOptions) (_result *DeleteInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Host)) {
		query["Host"] = request.Host
	}

	if !tea.BoolValue(util.IsUnset(request.Port)) {
		query["Port"] = request.Port
	}

	if !tea.BoolValue(util.IsUnset(request.Sid)) {
		query["Sid"] = request.Sid
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteInstance"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Note: You can call this operation only to remove a database instance from the instance list of DMS. The instance is not deleted or shut down.
 *
 * @param request DeleteInstanceRequest
 * @return DeleteInstanceResponse
 */
func (client *Client) DeleteInstance(request *DeleteInstanceRequest) (_result *DeleteInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteInstanceResponse{}
	_body, _err := client.DeleteInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteLakeHouseSpaceWithOptions(request *DeleteLakeHouseSpaceRequest, runtime *util.RuntimeOptions) (_result *DeleteLakeHouseSpaceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.SpaceId)) {
		query["SpaceId"] = request.SpaceId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteLakeHouseSpace"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteLakeHouseSpaceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteLakeHouseSpace(request *DeleteLakeHouseSpaceRequest) (_result *DeleteLakeHouseSpaceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteLakeHouseSpaceResponse{}
	_body, _err := client.DeleteLakeHouseSpaceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You must call this operation as a DMS administrator, a database administrator (DBA), or a workspace administrator.
 * You cannot call this operation to transfer the ownership of a task flow. To transfer the ownership of a task flow, call the [ChangLhDagOwner](~~424761~~) operation.
 *
 * @param tmpReq DeleteLhMembersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteLhMembersResponse
 */
func (client *Client) DeleteLhMembersWithOptions(tmpReq *DeleteLhMembersRequest, runtime *util.RuntimeOptions) (_result *DeleteLhMembersResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &DeleteLhMembersShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.MemberIds)) {
		request.MemberIdsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.MemberIds, tea.String("MemberIds"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MemberIdsShrink)) {
		query["MemberIds"] = request.MemberIdsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.ObjectId)) {
		query["ObjectId"] = request.ObjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ObjectType)) {
		query["ObjectType"] = request.ObjectType
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteLhMembers"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteLhMembersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You must call this operation as a DMS administrator, a database administrator (DBA), or a workspace administrator.
 * You cannot call this operation to transfer the ownership of a task flow. To transfer the ownership of a task flow, call the [ChangLhDagOwner](~~424761~~) operation.
 *
 * @param request DeleteLhMembersRequest
 * @return DeleteLhMembersResponse
 */
func (client *Client) DeleteLhMembers(request *DeleteLhMembersRequest) (_result *DeleteLhMembersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteLhMembersResponse{}
	_body, _err := client.DeleteLhMembersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteLogicDatabaseWithOptions(request *DeleteLogicDatabaseRequest, runtime *util.RuntimeOptions) (_result *DeleteLogicDatabaseResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LogicDbId)) {
		query["LogicDbId"] = request.LogicDbId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteLogicDatabase"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteLogicDatabaseResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteLogicDatabase(request *DeleteLogicDatabaseRequest) (_result *DeleteLogicDatabaseResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteLogicDatabaseResponse{}
	_body, _err := client.DeleteLogicDatabaseWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteLogicTableRouteConfigWithOptions(request *DeleteLogicTableRouteConfigRequest, runtime *util.RuntimeOptions) (_result *DeleteLogicTableRouteConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RouteKey)) {
		query["RouteKey"] = request.RouteKey
	}

	if !tea.BoolValue(util.IsUnset(request.TableId)) {
		query["TableId"] = request.TableId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteLogicTableRouteConfig"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteLogicTableRouteConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteLogicTableRouteConfig(request *DeleteLogicTableRouteConfigRequest) (_result *DeleteLogicTableRouteConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteLogicTableRouteConfigResponse{}
	_body, _err := client.DeleteLogicTableRouteConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * After you disable this feature, your DB instance loses the JDBC protocol. All authorization information is recycled.
 *
 * @param request DeleteProxyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteProxyResponse
 */
func (client *Client) DeleteProxyWithOptions(request *DeleteProxyRequest, runtime *util.RuntimeOptions) (_result *DeleteProxyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ProxyId)) {
		query["ProxyId"] = request.ProxyId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteProxy"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteProxyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * After you disable this feature, your DB instance loses the JDBC protocol. All authorization information is recycled.
 *
 * @param request DeleteProxyRequest
 * @return DeleteProxyResponse
 */
func (client *Client) DeleteProxy(request *DeleteProxyRequest) (_result *DeleteProxyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteProxyResponse{}
	_body, _err := client.DeleteProxyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteProxyAccessWithOptions(request *DeleteProxyAccessRequest, runtime *util.RuntimeOptions) (_result *DeleteProxyAccessResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ProxyAccessId)) {
		query["ProxyAccessId"] = request.ProxyAccessId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteProxyAccess"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteProxyAccessResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteProxyAccess(request *DeleteProxyAccessRequest) (_result *DeleteProxyAccessResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteProxyAccessResponse{}
	_body, _err := client.DeleteProxyAccessWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you call this operation, make sure that no task flow is specified in the business scenario.
 *
 * @param request DeleteScenarioRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteScenarioResponse
 */
func (client *Client) DeleteScenarioWithOptions(request *DeleteScenarioRequest, runtime *util.RuntimeOptions) (_result *DeleteScenarioResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ScenarioId)) {
		query["ScenarioId"] = request.ScenarioId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteScenario"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteScenarioResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you call this operation, make sure that no task flow is specified in the business scenario.
 *
 * @param request DeleteScenarioRequest
 * @return DeleteScenarioResponse
 */
func (client *Client) DeleteScenario(request *DeleteScenarioRequest) (_result *DeleteScenarioResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteScenarioResponse{}
	_body, _err := client.DeleteScenarioWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteStandardGroupWithOptions(request *DeleteStandardGroupRequest, runtime *util.RuntimeOptions) (_result *DeleteStandardGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteStandardGroup"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteStandardGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteStandardGroup(request *DeleteStandardGroupRequest) (_result *DeleteStandardGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteStandardGroupResponse{}
	_body, _err := client.DeleteStandardGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteTaskWithOptions(request *DeleteTaskRequest, runtime *util.RuntimeOptions) (_result *DeleteTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		query["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteTask"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteTask(request *DeleteTaskRequest) (_result *DeleteTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteTaskResponse{}
	_body, _err := client.DeleteTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteTaskFlowWithOptions(request *DeleteTaskFlowRequest, runtime *util.RuntimeOptions) (_result *DeleteTaskFlowResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteTaskFlow"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteTaskFlowResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteTaskFlow(request *DeleteTaskFlowRequest) (_result *DeleteTaskFlowResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteTaskFlowResponse{}
	_body, _err := client.DeleteTaskFlowWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation is used for multi-condition query. You can call it to delete the edges of a specified task flow that meet all specified conditions.
 *
 * @param request DeleteTaskFlowEdgesByConditionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTaskFlowEdgesByConditionResponse
 */
func (client *Client) DeleteTaskFlowEdgesByConditionWithOptions(request *DeleteTaskFlowEdgesByConditionRequest, runtime *util.RuntimeOptions) (_result *DeleteTaskFlowEdgesByConditionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.NodeEnd)) {
		query["NodeEnd"] = request.NodeEnd
	}

	if !tea.BoolValue(util.IsUnset(request.NodeFrom)) {
		query["NodeFrom"] = request.NodeFrom
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteTaskFlowEdgesByCondition"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteTaskFlowEdgesByConditionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation is used for multi-condition query. You can call it to delete the edges of a specified task flow that meet all specified conditions.
 *
 * @param request DeleteTaskFlowEdgesByConditionRequest
 * @return DeleteTaskFlowEdgesByConditionResponse
 */
func (client *Client) DeleteTaskFlowEdgesByCondition(request *DeleteTaskFlowEdgesByConditionRequest) (_result *DeleteTaskFlowEdgesByConditionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteTaskFlowEdgesByConditionResponse{}
	_body, _err := client.DeleteTaskFlowEdgesByConditionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The effect of deleting a user by calling this operation is the same as that of deleting a user by choosing System Management > User Management in the DMS Enterprise console. The administrator of DMS Enterprise can call this operation to delete a user that is no longer used from DMS Enterprise. After the user is deleted, the data source permission, data owner configuration, and database administrator (DBA) configuration of the corresponding Alibaba Cloud account or Resource Access Management (RAM) user are revoked and become invalid.
 * >  This operation only removes the association of the Alibaba Cloud account or RAM user with DMS Enterprise of the enterprise, rather than actually deleting the Alibaba Cloud account or RAM user. After the user is deleted, the Alibaba Cloud account or RAM user cannot log on to DMS Enterprise, unless the user is added to DMS Enterprise again.
 *
 * @param request DeleteUserRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteUserResponse
 */
func (client *Client) DeleteUserWithOptions(request *DeleteUserRequest, runtime *util.RuntimeOptions) (_result *DeleteUserResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.Uid)) {
		query["Uid"] = request.Uid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteUser"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteUserResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The effect of deleting a user by calling this operation is the same as that of deleting a user by choosing System Management > User Management in the DMS Enterprise console. The administrator of DMS Enterprise can call this operation to delete a user that is no longer used from DMS Enterprise. After the user is deleted, the data source permission, data owner configuration, and database administrator (DBA) configuration of the corresponding Alibaba Cloud account or Resource Access Management (RAM) user are revoked and become invalid.
 * >  This operation only removes the association of the Alibaba Cloud account or RAM user with DMS Enterprise of the enterprise, rather than actually deleting the Alibaba Cloud account or RAM user. After the user is deleted, the Alibaba Cloud account or RAM user cannot log on to DMS Enterprise, unless the user is added to DMS Enterprise again.
 *
 * @param request DeleteUserRequest
 * @return DeleteUserResponse
 */
func (client *Client) DeleteUser(request *DeleteUserRequest) (_result *DeleteUserResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteUserResponse{}
	_body, _err := client.DeleteUserWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The effect of disabling a user by calling this operation is the same as that of disabling a user by choosing System Management > User Management in the DMS Enterprise console. The administrator of DMS Enterprise can call this operation to disable a user that is temporarily not used in DMS Enterprise. After the user is disabled, the data source permission, data owner configuration, and database administrator (DBA) configuration of the corresponding Alibaba Cloud account or Resource Access Management (RAM) user are revoked and become invalid.
 * >  This operation only stops the Alibaba Cloud account or RAM user from logging on to DMS Enterprise of the enterprise, rather than actually disabling the Alibaba Cloud account or RAM user. After the user is disabled, the Alibaba Cloud account or RAM user cannot log on to DMS Enterprise, unless the user is enabled again. The disabled user, however, still exists in DMS Enterprise.
 *
 * @param request DisableUserRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableUserResponse
 */
func (client *Client) DisableUserWithOptions(request *DisableUserRequest, runtime *util.RuntimeOptions) (_result *DisableUserResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.Uid)) {
		query["Uid"] = request.Uid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DisableUser"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DisableUserResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The effect of disabling a user by calling this operation is the same as that of disabling a user by choosing System Management > User Management in the DMS Enterprise console. The administrator of DMS Enterprise can call this operation to disable a user that is temporarily not used in DMS Enterprise. After the user is disabled, the data source permission, data owner configuration, and database administrator (DBA) configuration of the corresponding Alibaba Cloud account or Resource Access Management (RAM) user are revoked and become invalid.
 * >  This operation only stops the Alibaba Cloud account or RAM user from logging on to DMS Enterprise of the enterprise, rather than actually disabling the Alibaba Cloud account or RAM user. After the user is disabled, the Alibaba Cloud account or RAM user cannot log on to DMS Enterprise, unless the user is enabled again. The disabled user, however, still exists in DMS Enterprise.
 *
 * @param request DisableUserRequest
 * @return DisableUserResponse
 */
func (client *Client) DisableUser(request *DisableUserRequest) (_result *DisableUserResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DisableUserResponse{}
	_body, _err := client.DisableUserWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DownloadDataTrackResultWithOptions(tmpReq *DownloadDataTrackResultRequest, runtime *util.RuntimeOptions) (_result *DownloadDataTrackResultResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &DownloadDataTrackResultShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.ColumnFilter)) {
		request.ColumnFilterShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.ColumnFilter, tea.String("ColumnFilter"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.EventIdList)) {
		request.EventIdListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.EventIdList, tea.String("EventIdList"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.FilterTableList)) {
		request.FilterTableListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.FilterTableList, tea.String("FilterTableList"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.FilterTypeList)) {
		request.FilterTypeListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.FilterTypeList, tea.String("FilterTypeList"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ColumnFilterShrink)) {
		query["ColumnFilter"] = request.ColumnFilterShrink
	}

	if !tea.BoolValue(util.IsUnset(request.EventIdListShrink)) {
		query["EventIdList"] = request.EventIdListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.FilterEndTime)) {
		query["FilterEndTime"] = request.FilterEndTime
	}

	if !tea.BoolValue(util.IsUnset(request.FilterStartTime)) {
		query["FilterStartTime"] = request.FilterStartTime
	}

	if !tea.BoolValue(util.IsUnset(request.FilterTableListShrink)) {
		query["FilterTableList"] = request.FilterTableListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.FilterTypeListShrink)) {
		query["FilterTypeList"] = request.FilterTypeListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.RollbackSQLType)) {
		query["RollbackSQLType"] = request.RollbackSQLType
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DownloadDataTrackResult"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DownloadDataTrackResultResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DownloadDataTrackResult(request *DownloadDataTrackResultRequest) (_result *DownloadDataTrackResultResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DownloadDataTrackResultResponse{}
	_body, _err := client.DownloadDataTrackResultWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) EditLogicDatabaseWithOptions(tmpReq *EditLogicDatabaseRequest, runtime *util.RuntimeOptions) (_result *EditLogicDatabaseResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &EditLogicDatabaseShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.DatabaseIds)) {
		request.DatabaseIdsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.DatabaseIds, tea.String("DatabaseIds"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Alias)) {
		query["Alias"] = request.Alias
	}

	if !tea.BoolValue(util.IsUnset(request.DatabaseIdsShrink)) {
		query["DatabaseIds"] = request.DatabaseIdsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.LogicDbId)) {
		query["LogicDbId"] = request.LogicDbId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EditLogicDatabase"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EditLogicDatabaseResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) EditLogicDatabase(request *EditLogicDatabaseRequest) (_result *EditLogicDatabaseResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EditLogicDatabaseResponse{}
	_body, _err := client.EditLogicDatabaseWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The effect of enabling a user by calling this operation is the same as that of enabling a user by choosing System Management > User Management in the DMS Enterprise console. The administrator of DMS Enterprise can call this operation to enable a user that has been disabled in DMS Enterprise. After the user is enabled, the corresponding Alibaba Cloud account or Resource Access Management (RAM) user can continue to log on to DMS Enterprise and perform relevant operations.
 * >  This operation only enables the Alibaba Cloud account or RAM user to log on to DMS Enterprise of the enterprise and perform relevant operations, rather than granting other permissions to the Alibaba Cloud account or RAM user.
 *
 * @param request EnableUserRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableUserResponse
 */
func (client *Client) EnableUserWithOptions(request *EnableUserRequest, runtime *util.RuntimeOptions) (_result *EnableUserResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.Uid)) {
		query["Uid"] = request.Uid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EnableUser"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EnableUserResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The effect of enabling a user by calling this operation is the same as that of enabling a user by choosing System Management > User Management in the DMS Enterprise console. The administrator of DMS Enterprise can call this operation to enable a user that has been disabled in DMS Enterprise. After the user is enabled, the corresponding Alibaba Cloud account or Resource Access Management (RAM) user can continue to log on to DMS Enterprise and perform relevant operations.
 * >  This operation only enables the Alibaba Cloud account or RAM user to log on to DMS Enterprise of the enterprise and perform relevant operations, rather than granting other permissions to the Alibaba Cloud account or RAM user.
 *
 * @param request EnableUserRequest
 * @return EnableUserResponse
 */
func (client *Client) EnableUser(request *EnableUserRequest) (_result *EnableUserResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EnableUserResponse{}
	_body, _err := client.EnableUserWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ExecuteDataCorrectWithOptions(tmpReq *ExecuteDataCorrectRequest, runtime *util.RuntimeOptions) (_result *ExecuteDataCorrectResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ExecuteDataCorrectShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.ActionDetail)) {
		request.ActionDetailShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.ActionDetail, tea.String("ActionDetail"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ActionDetailShrink)) {
		query["ActionDetail"] = request.ActionDetailShrink
	}

	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ExecuteDataCorrect"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ExecuteDataCorrectResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ExecuteDataCorrect(request *ExecuteDataCorrectRequest) (_result *ExecuteDataCorrectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ExecuteDataCorrectResponse{}
	_body, _err := client.ExecuteDataCorrectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ExecuteDataExportWithOptions(tmpReq *ExecuteDataExportRequest, runtime *util.RuntimeOptions) (_result *ExecuteDataExportResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ExecuteDataExportShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.ActionDetail)) {
		request.ActionDetailShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.ActionDetail, tea.String("ActionDetail"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ActionDetailShrink)) {
		query["ActionDetail"] = request.ActionDetailShrink
	}

	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ExecuteDataExport"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ExecuteDataExportResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ExecuteDataExport(request *ExecuteDataExportRequest) (_result *ExecuteDataExportResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ExecuteDataExportResponse{}
	_body, _err := client.ExecuteDataExportWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation only for instances that are managed in Security Collaboration mode.
 *
 * @param request ExecuteScriptRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExecuteScriptResponse
 */
func (client *Client) ExecuteScriptWithOptions(request *ExecuteScriptRequest, runtime *util.RuntimeOptions) (_result *ExecuteScriptResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DbId)) {
		query["DbId"] = request.DbId
	}

	if !tea.BoolValue(util.IsUnset(request.Logic)) {
		query["Logic"] = request.Logic
	}

	if !tea.BoolValue(util.IsUnset(request.Script)) {
		query["Script"] = request.Script
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ExecuteScript"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ExecuteScriptResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation only for instances that are managed in Security Collaboration mode.
 *
 * @param request ExecuteScriptRequest
 * @return ExecuteScriptResponse
 */
func (client *Client) ExecuteScript(request *ExecuteScriptRequest) (_result *ExecuteScriptResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ExecuteScriptResponse{}
	_body, _err := client.ExecuteScriptWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If the security rules of an instance indicate that a ticket must be approved before you perform schema synchronization, you can call the [SubmitStructSyncOrderApproval](~~206166~~) operation to submit the ticket for approval.
 * >  You can call the [GetStructSyncJobDetail](~~206160~~) operation to query whether you need to submit a ticket for approval.
 *
 * @param request ExecuteStructSyncRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExecuteStructSyncResponse
 */
func (client *Client) ExecuteStructSyncWithOptions(request *ExecuteStructSyncRequest, runtime *util.RuntimeOptions) (_result *ExecuteStructSyncResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ExecuteStructSync"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ExecuteStructSyncResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If the security rules of an instance indicate that a ticket must be approved before you perform schema synchronization, you can call the [SubmitStructSyncOrderApproval](~~206166~~) operation to submit the ticket for approval.
 * >  You can call the [GetStructSyncJobDetail](~~206160~~) operation to query whether you need to submit a ticket for approval.
 *
 * @param request ExecuteStructSyncRequest
 * @return ExecuteStructSyncResponse
 */
func (client *Client) ExecuteStructSync(request *ExecuteStructSyncRequest) (_result *ExecuteStructSyncResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ExecuteStructSyncResponse{}
	_body, _err := client.ExecuteStructSyncWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetApprovalDetailWithOptions(request *GetApprovalDetailRequest, runtime *util.RuntimeOptions) (_result *GetApprovalDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.WorkflowInstanceId)) {
		query["WorkflowInstanceId"] = request.WorkflowInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetApprovalDetail"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetApprovalDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetApprovalDetail(request *GetApprovalDetailRequest) (_result *GetApprovalDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetApprovalDetailResponse{}
	_body, _err := client.GetApprovalDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You must be a Data Management (DMS) administrator or a database administrator (DBA). For more information about how to view system roles, see [View system roles](~~324212~~).
 *
 * @param request GetAuthorityTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAuthorityTemplateResponse
 */
func (client *Client) GetAuthorityTemplateWithOptions(request *GetAuthorityTemplateRequest, runtime *util.RuntimeOptions) (_result *GetAuthorityTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		query["TemplateId"] = request.TemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAuthorityTemplate"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAuthorityTemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You must be a Data Management (DMS) administrator or a database administrator (DBA). For more information about how to view system roles, see [View system roles](~~324212~~).
 *
 * @param request GetAuthorityTemplateRequest
 * @return GetAuthorityTemplateResponse
 */
func (client *Client) GetAuthorityTemplate(request *GetAuthorityTemplateRequest) (_result *GetAuthorityTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAuthorityTemplateResponse{}
	_body, _err := client.GetAuthorityTemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You are a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](~~324212~~).
 *
 * @param request GetAuthorityTemplateItemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAuthorityTemplateItemResponse
 */
func (client *Client) GetAuthorityTemplateItemWithOptions(request *GetAuthorityTemplateItemRequest, runtime *util.RuntimeOptions) (_result *GetAuthorityTemplateItemResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		query["TemplateId"] = request.TemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAuthorityTemplateItem"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAuthorityTemplateItemResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You are a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](~~324212~~).
 *
 * @param request GetAuthorityTemplateItemRequest
 * @return GetAuthorityTemplateItemResponse
 */
func (client *Client) GetAuthorityTemplateItem(request *GetAuthorityTemplateItemRequest) (_result *GetAuthorityTemplateItemResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAuthorityTemplateItemResponse{}
	_body, _err := client.GetAuthorityTemplateItemWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetClassificationTemplateWithOptions(request *GetClassificationTemplateRequest, runtime *util.RuntimeOptions) (_result *GetClassificationTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetClassificationTemplate"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetClassificationTemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetClassificationTemplate(request *GetClassificationTemplateRequest) (_result *GetClassificationTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetClassificationTemplateResponse{}
	_body, _err := client.GetClassificationTemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDBTaskSQLJobLogWithOptions(request *GetDBTaskSQLJobLogRequest, runtime *util.RuntimeOptions) (_result *GetDBTaskSQLJobLogResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.JobId)) {
		query["JobId"] = request.JobId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDBTaskSQLJobLog"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDBTaskSQLJobLogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDBTaskSQLJobLog(request *GetDBTaskSQLJobLogRequest) (_result *GetDBTaskSQLJobLogResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDBTaskSQLJobLogResponse{}
	_body, _err := client.GetDBTaskSQLJobLogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDBTopologyWithOptions(request *GetDBTopologyRequest, runtime *util.RuntimeOptions) (_result *GetDBTopologyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LogicDbId)) {
		query["LogicDbId"] = request.LogicDbId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDBTopology"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDBTopologyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDBTopology(request *GetDBTopologyRequest) (_result *GetDBTopologyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDBTopologyResponse{}
	_body, _err := client.GetDBTopologyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDataArchiveCountWithOptions(request *GetDataArchiveCountRequest, runtime *util.RuntimeOptions) (_result *GetDataArchiveCountResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderResultType)) {
		query["OrderResultType"] = request.OrderResultType
	}

	if !tea.BoolValue(util.IsUnset(request.PluginType)) {
		query["PluginType"] = request.PluginType
	}

	if !tea.BoolValue(util.IsUnset(request.SearchDateType)) {
		query["SearchDateType"] = request.SearchDateType
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDataArchiveCount"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDataArchiveCountResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDataArchiveCount(request *GetDataArchiveCountRequest) (_result *GetDataArchiveCountResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDataArchiveCountResponse{}
	_body, _err := client.GetDataArchiveCountWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDataArchiveOrderDetailWithOptions(request *GetDataArchiveOrderDetailRequest, runtime *util.RuntimeOptions) (_result *GetDataArchiveOrderDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDataArchiveOrderDetail"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDataArchiveOrderDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDataArchiveOrderDetail(request *GetDataArchiveOrderDetailRequest) (_result *GetDataArchiveOrderDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDataArchiveOrderDetailResponse{}
	_body, _err := client.GetDataArchiveOrderDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDataCorrectBackupFilesWithOptions(tmpReq *GetDataCorrectBackupFilesRequest, runtime *util.RuntimeOptions) (_result *GetDataCorrectBackupFilesResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &GetDataCorrectBackupFilesShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.ActionDetail)) {
		request.ActionDetailShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.ActionDetail, tea.String("ActionDetail"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ActionDetailShrink)) {
		query["ActionDetail"] = request.ActionDetailShrink
	}

	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDataCorrectBackupFiles"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDataCorrectBackupFilesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDataCorrectBackupFiles(request *GetDataCorrectBackupFilesRequest) (_result *GetDataCorrectBackupFilesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDataCorrectBackupFilesResponse{}
	_body, _err := client.GetDataCorrectBackupFilesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDataCorrectOrderDetailWithOptions(request *GetDataCorrectOrderDetailRequest, runtime *util.RuntimeOptions) (_result *GetDataCorrectOrderDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDataCorrectOrderDetail"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDataCorrectOrderDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDataCorrectOrderDetail(request *GetDataCorrectOrderDetailRequest) (_result *GetDataCorrectOrderDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDataCorrectOrderDetailResponse{}
	_body, _err := client.GetDataCorrectOrderDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDataCorrectRollbackFileWithOptions(request *GetDataCorrectRollbackFileRequest, runtime *util.RuntimeOptions) (_result *GetDataCorrectRollbackFileResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDataCorrectRollbackFile"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDataCorrectRollbackFileResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDataCorrectRollbackFile(request *GetDataCorrectRollbackFileRequest) (_result *GetDataCorrectRollbackFileResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDataCorrectRollbackFileResponse{}
	_body, _err := client.GetDataCorrectRollbackFileWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation applies to [regular data change](~~58419~~) and [batch data import](~~144643~~).
 *
 * @param request GetDataCorrectSQLFileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDataCorrectSQLFileResponse
 */
func (client *Client) GetDataCorrectSQLFileWithOptions(request *GetDataCorrectSQLFileRequest, runtime *util.RuntimeOptions) (_result *GetDataCorrectSQLFileResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDataCorrectSQLFile"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDataCorrectSQLFileResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation applies to [regular data change](~~58419~~) and [batch data import](~~144643~~).
 *
 * @param request GetDataCorrectSQLFileRequest
 * @return GetDataCorrectSQLFileResponse
 */
func (client *Client) GetDataCorrectSQLFile(request *GetDataCorrectSQLFileRequest) (_result *GetDataCorrectSQLFileResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDataCorrectSQLFileResponse{}
	_body, _err := client.GetDataCorrectSQLFileWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDataCorrectTaskDetailWithOptions(request *GetDataCorrectTaskDetailRequest, runtime *util.RuntimeOptions) (_result *GetDataCorrectTaskDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDataCorrectTaskDetail"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDataCorrectTaskDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDataCorrectTaskDetail(request *GetDataCorrectTaskDetailRequest) (_result *GetDataCorrectTaskDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDataCorrectTaskDetailResponse{}
	_body, _err := client.GetDataCorrectTaskDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDataCronClearConfigWithOptions(request *GetDataCronClearConfigRequest, runtime *util.RuntimeOptions) (_result *GetDataCronClearConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDataCronClearConfig"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDataCronClearConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDataCronClearConfig(request *GetDataCronClearConfigRequest) (_result *GetDataCronClearConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDataCronClearConfigResponse{}
	_body, _err := client.GetDataCronClearConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDataCronClearTaskDetailListWithOptions(request *GetDataCronClearTaskDetailListRequest, runtime *util.RuntimeOptions) (_result *GetDataCronClearTaskDetailListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDataCronClearTaskDetailList"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDataCronClearTaskDetailListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDataCronClearTaskDetailList(request *GetDataCronClearTaskDetailListRequest) (_result *GetDataCronClearTaskDetailListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDataCronClearTaskDetailListResponse{}
	_body, _err := client.GetDataCronClearTaskDetailListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDataExportDownloadURLWithOptions(request *GetDataExportDownloadURLRequest, runtime *util.RuntimeOptions) (_result *GetDataExportDownloadURLResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDataExportDownloadURL"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDataExportDownloadURLResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDataExportDownloadURL(request *GetDataExportDownloadURLRequest) (_result *GetDataExportDownloadURLResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDataExportDownloadURLResponse{}
	_body, _err := client.GetDataExportDownloadURLWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDataExportOrderDetailWithOptions(request *GetDataExportOrderDetailRequest, runtime *util.RuntimeOptions) (_result *GetDataExportOrderDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		body["OrderId"] = request.OrderId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDataExportOrderDetail"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDataExportOrderDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDataExportOrderDetail(request *GetDataExportOrderDetailRequest) (_result *GetDataExportOrderDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDataExportOrderDetailResponse{}
	_body, _err := client.GetDataExportOrderDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDataExportPreCheckDetailWithOptions(request *GetDataExportPreCheckDetailRequest, runtime *util.RuntimeOptions) (_result *GetDataExportPreCheckDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDataExportPreCheckDetail"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDataExportPreCheckDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDataExportPreCheckDetail(request *GetDataExportPreCheckDetailRequest) (_result *GetDataExportPreCheckDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDataExportPreCheckDetailResponse{}
	_body, _err := client.GetDataExportPreCheckDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation only if the data is imported in security mode in your data import ticket.
 *
 * @param request GetDataImportSQLRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDataImportSQLResponse
 */
func (client *Client) GetDataImportSQLWithOptions(request *GetDataImportSQLRequest, runtime *util.RuntimeOptions) (_result *GetDataImportSQLResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.SqlId)) {
		query["SqlId"] = request.SqlId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDataImportSQL"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDataImportSQLResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation only if the data is imported in security mode in your data import ticket.
 *
 * @param request GetDataImportSQLRequest
 * @return GetDataImportSQLResponse
 */
func (client *Client) GetDataImportSQL(request *GetDataImportSQLRequest) (_result *GetDataImportSQLResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDataImportSQLResponse{}
	_body, _err := client.GetDataImportSQLWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDataTrackJobDegreeWithOptions(request *GetDataTrackJobDegreeRequest, runtime *util.RuntimeOptions) (_result *GetDataTrackJobDegreeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDataTrackJobDegree"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDataTrackJobDegreeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDataTrackJobDegree(request *GetDataTrackJobDegreeRequest) (_result *GetDataTrackJobDegreeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDataTrackJobDegreeResponse{}
	_body, _err := client.GetDataTrackJobDegreeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDataTrackJobTableMetaWithOptions(request *GetDataTrackJobTableMetaRequest, runtime *util.RuntimeOptions) (_result *GetDataTrackJobTableMetaResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDataTrackJobTableMeta"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDataTrackJobTableMetaResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDataTrackJobTableMeta(request *GetDataTrackJobTableMetaRequest) (_result *GetDataTrackJobTableMetaResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDataTrackJobTableMetaResponse{}
	_body, _err := client.GetDataTrackJobTableMetaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDataTrackOrderDetailWithOptions(request *GetDataTrackOrderDetailRequest, runtime *util.RuntimeOptions) (_result *GetDataTrackOrderDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDataTrackOrderDetail"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDataTrackOrderDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDataTrackOrderDetail(request *GetDataTrackOrderDetailRequest) (_result *GetDataTrackOrderDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDataTrackOrderDetailResponse{}
	_body, _err := client.GetDataTrackOrderDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDatabaseWithOptions(request *GetDatabaseRequest, runtime *util.RuntimeOptions) (_result *GetDatabaseResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Host)) {
		query["Host"] = request.Host
	}

	if !tea.BoolValue(util.IsUnset(request.Port)) {
		query["Port"] = request.Port
	}

	if !tea.BoolValue(util.IsUnset(request.SchemaName)) {
		query["SchemaName"] = request.SchemaName
	}

	if !tea.BoolValue(util.IsUnset(request.Sid)) {
		query["Sid"] = request.Sid
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDatabase"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDatabaseResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDatabase(request *GetDatabaseRequest) (_result *GetDatabaseResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDatabaseResponse{}
	_body, _err := client.GetDatabaseWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDatabaseExportOrderDetailWithOptions(request *GetDatabaseExportOrderDetailRequest, runtime *util.RuntimeOptions) (_result *GetDatabaseExportOrderDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		body["OrderId"] = request.OrderId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDatabaseExportOrderDetail"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDatabaseExportOrderDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDatabaseExportOrderDetail(request *GetDatabaseExportOrderDetailRequest) (_result *GetDatabaseExportOrderDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDatabaseExportOrderDetailResponse{}
	_body, _err := client.GetDatabaseExportOrderDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDbExportDownloadURLWithOptions(request *GetDbExportDownloadURLRequest, runtime *util.RuntimeOptions) (_result *GetDbExportDownloadURLResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDbExportDownloadURL"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDbExportDownloadURLResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDbExportDownloadURL(request *GetDbExportDownloadURLRequest) (_result *GetDbExportDownloadURLResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDbExportDownloadURLResponse{}
	_body, _err := client.GetDbExportDownloadURLWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetInstanceWithOptions(request *GetInstanceRequest, runtime *util.RuntimeOptions) (_result *GetInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Host)) {
		query["Host"] = request.Host
	}

	if !tea.BoolValue(util.IsUnset(request.Port)) {
		query["Port"] = request.Port
	}

	if !tea.BoolValue(util.IsUnset(request.Sid)) {
		query["Sid"] = request.Sid
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetInstance"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetInstance(request *GetInstanceRequest) (_result *GetInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetInstanceResponse{}
	_body, _err := client.GetInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The scheduling cycle of a task flow must be greater than the minimum scheduling cycle configured in the SLA rule for the task flow.
 *
 * @param request GetIntervalLimitOfSLARequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetIntervalLimitOfSLAResponse
 */
func (client *Client) GetIntervalLimitOfSLAWithOptions(request *GetIntervalLimitOfSLARequest, runtime *util.RuntimeOptions) (_result *GetIntervalLimitOfSLAResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetIntervalLimitOfSLA"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetIntervalLimitOfSLAResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The scheduling cycle of a task flow must be greater than the minimum scheduling cycle configured in the SLA rule for the task flow.
 *
 * @param request GetIntervalLimitOfSLARequest
 * @return GetIntervalLimitOfSLAResponse
 */
func (client *Client) GetIntervalLimitOfSLA(request *GetIntervalLimitOfSLARequest) (_result *GetIntervalLimitOfSLAResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetIntervalLimitOfSLAResponse{}
	_body, _err := client.GetIntervalLimitOfSLAWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You are a DMS administrator or a database administrator (DBA).
 *
 * @param request GetLhSpaceByNameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLhSpaceByNameResponse
 */
func (client *Client) GetLhSpaceByNameWithOptions(request *GetLhSpaceByNameRequest, runtime *util.RuntimeOptions) (_result *GetLhSpaceByNameResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.SpaceName)) {
		query["SpaceName"] = request.SpaceName
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetLhSpaceByName"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetLhSpaceByNameResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You are a DMS administrator or a database administrator (DBA).
 *
 * @param request GetLhSpaceByNameRequest
 * @return GetLhSpaceByNameResponse
 */
func (client *Client) GetLhSpaceByName(request *GetLhSpaceByNameRequest) (_result *GetLhSpaceByNameResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetLhSpaceByNameResponse{}
	_body, _err := client.GetLhSpaceByNameWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetLogicDatabaseWithOptions(request *GetLogicDatabaseRequest, runtime *util.RuntimeOptions) (_result *GetLogicDatabaseResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DbId)) {
		query["DbId"] = request.DbId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetLogicDatabase"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetLogicDatabaseResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetLogicDatabase(request *GetLogicDatabaseRequest) (_result *GetLogicDatabaseResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetLogicDatabaseResponse{}
	_body, _err := client.GetLogicDatabaseWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation only for database instances whose control mode is Security Collaboration.
 *
 * @param request GetMetaTableColumnRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMetaTableColumnResponse
 */
func (client *Client) GetMetaTableColumnWithOptions(request *GetMetaTableColumnRequest, runtime *util.RuntimeOptions) (_result *GetMetaTableColumnResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TableGuid)) {
		query["TableGuid"] = request.TableGuid
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMetaTableColumn"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMetaTableColumnResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation only for database instances whose control mode is Security Collaboration.
 *
 * @param request GetMetaTableColumnRequest
 * @return GetMetaTableColumnResponse
 */
func (client *Client) GetMetaTableColumn(request *GetMetaTableColumnRequest) (_result *GetMetaTableColumnResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMetaTableColumnResponse{}
	_body, _err := client.GetMetaTableColumnWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation only for database instances whose control mode is Security Collaboration.
 *
 * @param request GetMetaTableDetailInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMetaTableDetailInfoResponse
 */
func (client *Client) GetMetaTableDetailInfoWithOptions(request *GetMetaTableDetailInfoRequest, runtime *util.RuntimeOptions) (_result *GetMetaTableDetailInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TableGuid)) {
		query["TableGuid"] = request.TableGuid
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMetaTableDetailInfo"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMetaTableDetailInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation only for database instances whose control mode is Security Collaboration.
 *
 * @param request GetMetaTableDetailInfoRequest
 * @return GetMetaTableDetailInfoResponse
 */
func (client *Client) GetMetaTableDetailInfo(request *GetMetaTableDetailInfoRequest) (_result *GetMetaTableDetailInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMetaTableDetailInfoResponse{}
	_body, _err := client.GetMetaTableDetailInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetOnlineDDLProgressWithOptions(request *GetOnlineDDLProgressRequest, runtime *util.RuntimeOptions) (_result *GetOnlineDDLProgressResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.JobDetailId)) {
		query["JobDetailId"] = request.JobDetailId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetOnlineDDLProgress"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetOnlineDDLProgressResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetOnlineDDLProgress(request *GetOnlineDDLProgressRequest) (_result *GetOnlineDDLProgressResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetOnlineDDLProgressResponse{}
	_body, _err := client.GetOnlineDDLProgressWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Prerequisites: You are an administrator of Data Management (DMS) or a security administrator. You can call the [ListUsers](~~141938~~) or [GetUser](~~147098~~) operation to obtain your user role from the RoleIdList parameter that is returned.
 *
 * @param request GetOpLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetOpLogResponse
 */
func (client *Client) GetOpLogWithOptions(request *GetOpLogRequest, runtime *util.RuntimeOptions) (_result *GetOpLogResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DatabaseName)) {
		query["DatabaseName"] = request.DatabaseName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Module)) {
		query["Module"] = request.Module
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.UserNick)) {
		query["UserNick"] = request.UserNick
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetOpLog"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetOpLogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Prerequisites: You are an administrator of Data Management (DMS) or a security administrator. You can call the [ListUsers](~~141938~~) or [GetUser](~~147098~~) operation to obtain your user role from the RoleIdList parameter that is returned.
 *
 * @param request GetOpLogRequest
 * @return GetOpLogResponse
 */
func (client *Client) GetOpLog(request *GetOpLogRequest) (_result *GetOpLogResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetOpLogResponse{}
	_body, _err := client.GetOpLogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetOrderAttachmentFileWithOptions(request *GetOrderAttachmentFileRequest, runtime *util.RuntimeOptions) (_result *GetOrderAttachmentFileResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetOrderAttachmentFile"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetOrderAttachmentFileResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetOrderAttachmentFile(request *GetOrderAttachmentFileRequest) (_result *GetOrderAttachmentFileResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetOrderAttachmentFileResponse{}
	_body, _err := client.GetOrderAttachmentFileWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetOrderBaseInfoWithOptions(request *GetOrderBaseInfoRequest, runtime *util.RuntimeOptions) (_result *GetOrderBaseInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetOrderBaseInfo"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetOrderBaseInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetOrderBaseInfo(request *GetOrderBaseInfoRequest) (_result *GetOrderBaseInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetOrderBaseInfoResponse{}
	_body, _err := client.GetOrderBaseInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetOwnerApplyOrderDetailWithOptions(request *GetOwnerApplyOrderDetailRequest, runtime *util.RuntimeOptions) (_result *GetOwnerApplyOrderDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetOwnerApplyOrderDetail"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetOwnerApplyOrderDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetOwnerApplyOrderDetail(request *GetOwnerApplyOrderDetailRequest) (_result *GetOwnerApplyOrderDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetOwnerApplyOrderDetailResponse{}
	_body, _err := client.GetOwnerApplyOrderDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetPagedInstanceWithOptions(request *GetPagedInstanceRequest, runtime *util.RuntimeOptions) (_result *GetPagedInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetPagedInstance"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetPagedInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetPagedInstance(request *GetPagedInstanceRequest) (_result *GetPagedInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetPagedInstanceResponse{}
	_body, _err := client.GetPagedInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to query the information about tickets that apply for permissions on databases, tables, and sensitive columns.
 *
 * @param request GetPermApplyOrderDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetPermApplyOrderDetailResponse
 */
func (client *Client) GetPermApplyOrderDetailWithOptions(request *GetPermApplyOrderDetailRequest, runtime *util.RuntimeOptions) (_result *GetPermApplyOrderDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetPermApplyOrderDetail"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetPermApplyOrderDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to query the information about tickets that apply for permissions on databases, tables, and sensitive columns.
 *
 * @param request GetPermApplyOrderDetailRequest
 * @return GetPermApplyOrderDetailResponse
 */
func (client *Client) GetPermApplyOrderDetail(request *GetPermApplyOrderDetailRequest) (_result *GetPermApplyOrderDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetPermApplyOrderDetailResponse{}
	_body, _err := client.GetPermApplyOrderDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetPhysicalDatabaseWithOptions(request *GetPhysicalDatabaseRequest, runtime *util.RuntimeOptions) (_result *GetPhysicalDatabaseResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DbId)) {
		query["DbId"] = request.DbId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetPhysicalDatabase"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetPhysicalDatabaseResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetPhysicalDatabase(request *GetPhysicalDatabaseRequest) (_result *GetPhysicalDatabaseResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetPhysicalDatabaseResponse{}
	_body, _err := client.GetPhysicalDatabaseWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetProxyWithOptions(request *GetProxyRequest, runtime *util.RuntimeOptions) (_result *GetProxyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ProxyId)) {
		query["ProxyId"] = request.ProxyId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetProxy"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetProxyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetProxy(request *GetProxyRequest) (_result *GetProxyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetProxyResponse{}
	_body, _err := client.GetProxyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetProxyAccessWithOptions(request *GetProxyAccessRequest, runtime *util.RuntimeOptions) (_result *GetProxyAccessResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ProxyAccessId)) {
		query["ProxyAccessId"] = request.ProxyAccessId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetProxyAccess"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetProxyAccessResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetProxyAccess(request *GetProxyAccessRequest) (_result *GetProxyAccessResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetProxyAccessResponse{}
	_body, _err := client.GetProxyAccessWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetRuleNumLimitOfSLAWithOptions(request *GetRuleNumLimitOfSLARequest, runtime *util.RuntimeOptions) (_result *GetRuleNumLimitOfSLAResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetRuleNumLimitOfSLA"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetRuleNumLimitOfSLAResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetRuleNumLimitOfSLA(request *GetRuleNumLimitOfSLARequest) (_result *GetRuleNumLimitOfSLAResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetRuleNumLimitOfSLAResponse{}
	_body, _err := client.GetRuleNumLimitOfSLAWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * For more information about the SQL review feature, see [SQL review](~~60374~~).
 *
 * @param request GetSQLReviewCheckResultStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSQLReviewCheckResultStatusResponse
 */
func (client *Client) GetSQLReviewCheckResultStatusWithOptions(request *GetSQLReviewCheckResultStatusRequest, runtime *util.RuntimeOptions) (_result *GetSQLReviewCheckResultStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetSQLReviewCheckResultStatus"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetSQLReviewCheckResultStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * For more information about the SQL review feature, see [SQL review](~~60374~~).
 *
 * @param request GetSQLReviewCheckResultStatusRequest
 * @return GetSQLReviewCheckResultStatusResponse
 */
func (client *Client) GetSQLReviewCheckResultStatus(request *GetSQLReviewCheckResultStatusRequest) (_result *GetSQLReviewCheckResultStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetSQLReviewCheckResultStatusResponse{}
	_body, _err := client.GetSQLReviewCheckResultStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * For more information about the SQL review feature, see [SQL review](~~60374~~).
 *
 * @param request GetSQLReviewOptimizeDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSQLReviewOptimizeDetailResponse
 */
func (client *Client) GetSQLReviewOptimizeDetailWithOptions(request *GetSQLReviewOptimizeDetailRequest, runtime *util.RuntimeOptions) (_result *GetSQLReviewOptimizeDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.SQLReviewQueryKey)) {
		query["SQLReviewQueryKey"] = request.SQLReviewQueryKey
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetSQLReviewOptimizeDetail"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetSQLReviewOptimizeDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * For more information about the SQL review feature, see [SQL review](~~60374~~).
 *
 * @param request GetSQLReviewOptimizeDetailRequest
 * @return GetSQLReviewOptimizeDetailResponse
 */
func (client *Client) GetSQLReviewOptimizeDetail(request *GetSQLReviewOptimizeDetailRequest) (_result *GetSQLReviewOptimizeDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetSQLReviewOptimizeDetailResponse{}
	_body, _err := client.GetSQLReviewOptimizeDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetStandardGroupWithOptions(request *GetStandardGroupRequest, runtime *util.RuntimeOptions) (_result *GetStandardGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetStandardGroup"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetStandardGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetStandardGroup(request *GetStandardGroupRequest) (_result *GetStandardGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetStandardGroupResponse{}
	_body, _err := client.GetStandardGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetStructSyncExecSqlDetailWithOptions(request *GetStructSyncExecSqlDetailRequest, runtime *util.RuntimeOptions) (_result *GetStructSyncExecSqlDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetStructSyncExecSqlDetail"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetStructSyncExecSqlDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetStructSyncExecSqlDetail(request *GetStructSyncExecSqlDetailRequest) (_result *GetStructSyncExecSqlDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetStructSyncExecSqlDetailResponse{}
	_body, _err := client.GetStructSyncExecSqlDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetStructSyncJobAnalyzeResultWithOptions(request *GetStructSyncJobAnalyzeResultRequest, runtime *util.RuntimeOptions) (_result *GetStructSyncJobAnalyzeResultResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CompareType)) {
		query["CompareType"] = request.CompareType
	}

	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetStructSyncJobAnalyzeResult"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetStructSyncJobAnalyzeResultResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetStructSyncJobAnalyzeResult(request *GetStructSyncJobAnalyzeResultRequest) (_result *GetStructSyncJobAnalyzeResultResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetStructSyncJobAnalyzeResultResponse{}
	_body, _err := client.GetStructSyncJobAnalyzeResultWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetStructSyncJobDetailWithOptions(request *GetStructSyncJobDetailRequest, runtime *util.RuntimeOptions) (_result *GetStructSyncJobDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetStructSyncJobDetail"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetStructSyncJobDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetStructSyncJobDetail(request *GetStructSyncJobDetailRequest) (_result *GetStructSyncJobDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetStructSyncJobDetailResponse{}
	_body, _err := client.GetStructSyncJobDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetStructSyncOrderDetailWithOptions(request *GetStructSyncOrderDetailRequest, runtime *util.RuntimeOptions) (_result *GetStructSyncOrderDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetStructSyncOrderDetail"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetStructSyncOrderDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetStructSyncOrderDetail(request *GetStructSyncOrderDetailRequest) (_result *GetStructSyncOrderDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetStructSyncOrderDetailResponse{}
	_body, _err := client.GetStructSyncOrderDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetTableDBTopologyWithOptions(request *GetTableDBTopologyRequest, runtime *util.RuntimeOptions) (_result *GetTableDBTopologyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TableGuid)) {
		query["TableGuid"] = request.TableGuid
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetTableDBTopology"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetTableDBTopologyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetTableDBTopology(request *GetTableDBTopologyRequest) (_result *GetTableDBTopologyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetTableDBTopologyResponse{}
	_body, _err := client.GetTableDBTopologyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetTableTopologyWithOptions(request *GetTableTopologyRequest, runtime *util.RuntimeOptions) (_result *GetTableTopologyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TableGuid)) {
		query["TableGuid"] = request.TableGuid
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetTableTopology"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetTableTopologyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetTableTopology(request *GetTableTopologyRequest) (_result *GetTableTopologyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetTableTopologyResponse{}
	_body, _err := client.GetTableTopologyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetTaskWithOptions(request *GetTaskRequest, runtime *util.RuntimeOptions) (_result *GetTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		query["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetTask"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetTask(request *GetTaskRequest) (_result *GetTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetTaskResponse{}
	_body, _err := client.GetTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetTaskFlowGraphWithOptions(request *GetTaskFlowGraphRequest, runtime *util.RuntimeOptions) (_result *GetTaskFlowGraphResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetTaskFlowGraph"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetTaskFlowGraphResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetTaskFlowGraph(request *GetTaskFlowGraphRequest) (_result *GetTaskFlowGraphResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetTaskFlowGraphResponse{}
	_body, _err := client.GetTaskFlowGraphWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetTaskFlowNotificationWithOptions(request *GetTaskFlowNotificationRequest, runtime *util.RuntimeOptions) (_result *GetTaskFlowNotificationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetTaskFlowNotification"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetTaskFlowNotificationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetTaskFlowNotification(request *GetTaskFlowNotificationRequest) (_result *GetTaskFlowNotificationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetTaskFlowNotificationResponse{}
	_body, _err := client.GetTaskFlowNotificationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetTaskInstanceRelationWithOptions(request *GetTaskInstanceRelationRequest, runtime *util.RuntimeOptions) (_result *GetTaskInstanceRelationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.DagInstanceId)) {
		query["DagInstanceId"] = request.DagInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetTaskInstanceRelation"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetTaskInstanceRelationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetTaskInstanceRelation(request *GetTaskInstanceRelationRequest) (_result *GetTaskInstanceRelationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetTaskInstanceRelationResponse{}
	_body, _err := client.GetTaskInstanceRelationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetUserWithOptions(request *GetUserRequest, runtime *util.RuntimeOptions) (_result *GetUserResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.Uid)) {
		query["Uid"] = request.Uid
	}

	if !tea.BoolValue(util.IsUnset(request.UserId)) {
		query["UserId"] = request.UserId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetUser"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetUserResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetUser(request *GetUserRequest) (_result *GetUserResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetUserResponse{}
	_body, _err := client.GetUserWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetUserActiveTenantWithOptions(request *GetUserActiveTenantRequest, runtime *util.RuntimeOptions) (_result *GetUserActiveTenantResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetUserActiveTenant"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetUserActiveTenantResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetUserActiveTenant(request *GetUserActiveTenantRequest) (_result *GetUserActiveTenantResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetUserActiveTenantResponse{}
	_body, _err := client.GetUserActiveTenantWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetUserUploadFileJobWithOptions(request *GetUserUploadFileJobRequest, runtime *util.RuntimeOptions) (_result *GetUserUploadFileJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.JobKey)) {
		query["JobKey"] = request.JobKey
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetUserUploadFileJob"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetUserUploadFileJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetUserUploadFileJob(request *GetUserUploadFileJobRequest) (_result *GetUserUploadFileJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetUserUploadFileJobResponse{}
	_body, _err := client.GetUserUploadFileJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You must be a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](~~324212~~).
 *
 * @param request GrantTemplateAuthorityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GrantTemplateAuthorityResponse
 */
func (client *Client) GrantTemplateAuthorityWithOptions(request *GrantTemplateAuthorityRequest, runtime *util.RuntimeOptions) (_result *GrantTemplateAuthorityResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Comment)) {
		query["Comment"] = request.Comment
	}

	if !tea.BoolValue(util.IsUnset(request.ExpireDate)) {
		query["ExpireDate"] = request.ExpireDate
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		query["TemplateId"] = request.TemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.UserIds)) {
		query["UserIds"] = request.UserIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GrantTemplateAuthority"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GrantTemplateAuthorityResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You must be a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](~~324212~~).
 *
 * @param request GrantTemplateAuthorityRequest
 * @return GrantTemplateAuthorityResponse
 */
func (client *Client) GrantTemplateAuthority(request *GrantTemplateAuthorityRequest) (_result *GrantTemplateAuthorityResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GrantTemplateAuthorityResponse{}
	_body, _err := client.GrantTemplateAuthorityWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GrantUserPermissionWithOptions(request *GrantUserPermissionRequest, runtime *util.RuntimeOptions) (_result *GrantUserPermissionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DbId)) {
		query["DbId"] = request.DbId
	}

	if !tea.BoolValue(util.IsUnset(request.DsType)) {
		query["DsType"] = request.DsType
	}

	if !tea.BoolValue(util.IsUnset(request.ExpireDate)) {
		query["ExpireDate"] = request.ExpireDate
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Logic)) {
		query["Logic"] = request.Logic
	}

	if !tea.BoolValue(util.IsUnset(request.PermTypes)) {
		query["PermTypes"] = request.PermTypes
	}

	if !tea.BoolValue(util.IsUnset(request.TableId)) {
		query["TableId"] = request.TableId
	}

	if !tea.BoolValue(util.IsUnset(request.TableName)) {
		query["TableName"] = request.TableName
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.UserId)) {
		query["UserId"] = request.UserId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GrantUserPermission"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GrantUserPermissionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GrantUserPermission(request *GrantUserPermissionRequest) (_result *GrantUserPermissionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GrantUserPermissionResponse{}
	_body, _err := client.GrantUserPermissionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) InspectProxyAccessSecretWithOptions(request *InspectProxyAccessSecretRequest, runtime *util.RuntimeOptions) (_result *InspectProxyAccessSecretResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ProxyAccessId)) {
		query["ProxyAccessId"] = request.ProxyAccessId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("InspectProxyAccessSecret"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &InspectProxyAccessSecretResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) InspectProxyAccessSecret(request *InspectProxyAccessSecretRequest) (_result *InspectProxyAccessSecretResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &InspectProxyAccessSecretResponse{}
	_body, _err := client.InspectProxyAccessSecretWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListAuthorityTemplateWithOptions(request *ListAuthorityTemplateRequest, runtime *util.RuntimeOptions) (_result *ListAuthorityTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SearchKey)) {
		query["SearchKey"] = request.SearchKey
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAuthorityTemplate"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAuthorityTemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListAuthorityTemplate(request *ListAuthorityTemplateRequest) (_result *ListAuthorityTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAuthorityTemplateResponse{}
	_body, _err := client.ListAuthorityTemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListClassificationTemplatesWithOptions(request *ListClassificationTemplatesRequest, runtime *util.RuntimeOptions) (_result *ListClassificationTemplatesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListClassificationTemplates"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListClassificationTemplatesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListClassificationTemplates(request *ListClassificationTemplatesRequest) (_result *ListClassificationTemplatesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListClassificationTemplatesResponse{}
	_body, _err := client.ListClassificationTemplatesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation only for database instances whose control mode is Security Collaboration.
 *
 * @param request ListColumnsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListColumnsResponse
 */
func (client *Client) ListColumnsWithOptions(request *ListColumnsRequest, runtime *util.RuntimeOptions) (_result *ListColumnsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Logic)) {
		query["Logic"] = request.Logic
	}

	if !tea.BoolValue(util.IsUnset(request.TableId)) {
		query["TableId"] = request.TableId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListColumns"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListColumnsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation only for database instances whose control mode is Security Collaboration.
 *
 * @param request ListColumnsRequest
 * @return ListColumnsResponse
 */
func (client *Client) ListColumns(request *ListColumnsRequest) (_result *ListColumnsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListColumnsResponse{}
	_body, _err := client.ListColumnsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListDAGVersionsWithOptions(request *ListDAGVersionsRequest, runtime *util.RuntimeOptions) (_result *ListDAGVersionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.PageIndex)) {
		query["PageIndex"] = request.PageIndex
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDAGVersions"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDAGVersionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListDAGVersions(request *ListDAGVersionsRequest) (_result *ListDAGVersionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDAGVersionsResponse{}
	_body, _err := client.ListDAGVersionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListDBTaskSQLJobWithOptions(request *ListDBTaskSQLJobRequest, runtime *util.RuntimeOptions) (_result *ListDBTaskSQLJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DBTaskGroupId)) {
		query["DBTaskGroupId"] = request.DBTaskGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDBTaskSQLJob"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDBTaskSQLJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListDBTaskSQLJob(request *ListDBTaskSQLJobRequest) (_result *ListDBTaskSQLJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDBTaskSQLJobResponse{}
	_body, _err := client.ListDBTaskSQLJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListDBTaskSQLJobDetailWithOptions(request *ListDBTaskSQLJobDetailRequest, runtime *util.RuntimeOptions) (_result *ListDBTaskSQLJobDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.JobId)) {
		query["JobId"] = request.JobId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDBTaskSQLJobDetail"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDBTaskSQLJobDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListDBTaskSQLJobDetail(request *ListDBTaskSQLJobDetailRequest) (_result *ListDBTaskSQLJobDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDBTaskSQLJobDetailResponse{}
	_body, _err := client.ListDBTaskSQLJobDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListDDLPublishRecordsWithOptions(request *ListDDLPublishRecordsRequest, runtime *util.RuntimeOptions) (_result *ListDDLPublishRecordsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDDLPublishRecords"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDDLPublishRecordsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListDDLPublishRecords(request *ListDDLPublishRecordsRequest) (_result *ListDDLPublishRecordsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDDLPublishRecordsResponse{}
	_body, _err := client.ListDDLPublishRecordsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * For more information about the Normal Data Modify feature, see [Change regular data](~~58419~~).
 *
 * @param request ListDataCorrectPreCheckDBRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDataCorrectPreCheckDBResponse
 */
func (client *Client) ListDataCorrectPreCheckDBWithOptions(request *ListDataCorrectPreCheckDBRequest, runtime *util.RuntimeOptions) (_result *ListDataCorrectPreCheckDBResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDataCorrectPreCheckDB"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDataCorrectPreCheckDBResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * For more information about the Normal Data Modify feature, see [Change regular data](~~58419~~).
 *
 * @param request ListDataCorrectPreCheckDBRequest
 * @return ListDataCorrectPreCheckDBResponse
 */
func (client *Client) ListDataCorrectPreCheckDB(request *ListDataCorrectPreCheckDBRequest) (_result *ListDataCorrectPreCheckDBResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDataCorrectPreCheckDBResponse{}
	_body, _err := client.ListDataCorrectPreCheckDBWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * For more information about the Normal Data Modify feature, see [Change regular data](~~58419~~).
 *
 * @param request ListDataCorrectPreCheckSQLRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDataCorrectPreCheckSQLResponse
 */
func (client *Client) ListDataCorrectPreCheckSQLWithOptions(request *ListDataCorrectPreCheckSQLRequest, runtime *util.RuntimeOptions) (_result *ListDataCorrectPreCheckSQLResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DbId)) {
		query["DbId"] = request.DbId
	}

	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDataCorrectPreCheckSQL"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDataCorrectPreCheckSQLResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * For more information about the Normal Data Modify feature, see [Change regular data](~~58419~~).
 *
 * @param request ListDataCorrectPreCheckSQLRequest
 * @return ListDataCorrectPreCheckSQLResponse
 */
func (client *Client) ListDataCorrectPreCheckSQL(request *ListDataCorrectPreCheckSQLRequest) (_result *ListDataCorrectPreCheckSQLResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDataCorrectPreCheckSQLResponse{}
	_body, _err := client.ListDataCorrectPreCheckSQLWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation only if the data is imported in security mode in your data import ticket.
 *
 * @param request ListDataImportSQLPreCheckDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDataImportSQLPreCheckDetailResponse
 */
func (client *Client) ListDataImportSQLPreCheckDetailWithOptions(request *ListDataImportSQLPreCheckDetailRequest, runtime *util.RuntimeOptions) (_result *ListDataImportSQLPreCheckDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumer)) {
		query["PageNumer"] = request.PageNumer
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SqlType)) {
		query["SqlType"] = request.SqlType
	}

	if !tea.BoolValue(util.IsUnset(request.StatusCode)) {
		query["StatusCode"] = request.StatusCode
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDataImportSQLPreCheckDetail"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDataImportSQLPreCheckDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation only if the data is imported in security mode in your data import ticket.
 *
 * @param request ListDataImportSQLPreCheckDetailRequest
 * @return ListDataImportSQLPreCheckDetailResponse
 */
func (client *Client) ListDataImportSQLPreCheckDetail(request *ListDataImportSQLPreCheckDetailRequest) (_result *ListDataImportSQLPreCheckDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDataImportSQLPreCheckDetailResponse{}
	_body, _err := client.ListDataImportSQLPreCheckDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation only if the data is imported in security mode in your data import ticket.
 *
 * @param request ListDataImportSQLTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDataImportSQLTypeResponse
 */
func (client *Client) ListDataImportSQLTypeWithOptions(request *ListDataImportSQLTypeRequest, runtime *util.RuntimeOptions) (_result *ListDataImportSQLTypeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDataImportSQLType"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDataImportSQLTypeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation only if the data is imported in security mode in your data import ticket.
 *
 * @param request ListDataImportSQLTypeRequest
 * @return ListDataImportSQLTypeResponse
 */
func (client *Client) ListDataImportSQLType(request *ListDataImportSQLTypeRequest) (_result *ListDataImportSQLTypeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDataImportSQLTypeResponse{}
	_body, _err := client.ListDataImportSQLTypeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListDatabaseUserPermssionsWithOptions(request *ListDatabaseUserPermssionsRequest, runtime *util.RuntimeOptions) (_result *ListDatabaseUserPermssionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DbId)) {
		query["DbId"] = request.DbId
	}

	if !tea.BoolValue(util.IsUnset(request.Logic)) {
		query["Logic"] = request.Logic
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.PermType)) {
		query["PermType"] = request.PermType
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.UserName)) {
		query["UserName"] = request.UserName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDatabaseUserPermssions"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDatabaseUserPermssionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListDatabaseUserPermssions(request *ListDatabaseUserPermssionsRequest) (_result *ListDatabaseUserPermssionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDatabaseUserPermssionsResponse{}
	_body, _err := client.ListDatabaseUserPermssionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListDatabasesWithOptions(request *ListDatabasesRequest, runtime *util.RuntimeOptions) (_result *ListDatabasesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDatabases"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDatabasesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListDatabases(request *ListDatabasesRequest) (_result *ListDatabasesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDatabasesResponse{}
	_body, _err := client.ListDatabasesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListDefaultSLARulesWithOptions(request *ListDefaultSLARulesRequest, runtime *util.RuntimeOptions) (_result *ListDefaultSLARulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDefaultSLARules"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDefaultSLARulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListDefaultSLARules(request *ListDefaultSLARulesRequest) (_result *ListDefaultSLARulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDefaultSLARulesResponse{}
	_body, _err := client.ListDefaultSLARulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListDesensitizationRuleWithOptions(request *ListDesensitizationRuleRequest, runtime *util.RuntimeOptions) (_result *ListDesensitizationRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FuncType)) {
		query["FuncType"] = request.FuncType
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RuleId)) {
		query["RuleId"] = request.RuleId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleName)) {
		query["RuleName"] = request.RuleName
	}

	if !tea.BoolValue(util.IsUnset(request.RuleType)) {
		query["RuleType"] = request.RuleType
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDesensitizationRule"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDesensitizationRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListDesensitizationRule(request *ListDesensitizationRuleRequest) (_result *ListDesensitizationRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDesensitizationRuleResponse{}
	_body, _err := client.ListDesensitizationRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListEffectiveOrdersWithOptions(request *ListEffectiveOrdersRequest, runtime *util.RuntimeOptions) (_result *ListEffectiveOrdersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListEffectiveOrders"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListEffectiveOrdersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListEffectiveOrders(request *ListEffectiveOrdersRequest) (_result *ListEffectiveOrdersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListEffectiveOrdersResponse{}
	_body, _err := client.ListEffectiveOrdersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListIndexesWithOptions(request *ListIndexesRequest, runtime *util.RuntimeOptions) (_result *ListIndexesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Logic)) {
		query["Logic"] = request.Logic
	}

	if !tea.BoolValue(util.IsUnset(request.TableId)) {
		query["TableId"] = request.TableId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListIndexes"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListIndexesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListIndexes(request *ListIndexesRequest) (_result *ListIndexesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListIndexesResponse{}
	_body, _err := client.ListIndexesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListInstanceLoginAuditLogWithOptions(request *ListInstanceLoginAuditLogRequest, runtime *util.RuntimeOptions) (_result *ListInstanceLoginAuditLogResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OpUserName)) {
		query["OpUserName"] = request.OpUserName
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SearchName)) {
		query["SearchName"] = request.SearchName
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListInstanceLoginAuditLog"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListInstanceLoginAuditLogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListInstanceLoginAuditLog(request *ListInstanceLoginAuditLogRequest) (_result *ListInstanceLoginAuditLogResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListInstanceLoginAuditLogResponse{}
	_body, _err := client.ListInstanceLoginAuditLogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListInstanceUserPermissionsWithOptions(request *ListInstanceUserPermissionsRequest, runtime *util.RuntimeOptions) (_result *ListInstanceUserPermissionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.UserName)) {
		query["UserName"] = request.UserName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListInstanceUserPermissions"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListInstanceUserPermissionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListInstanceUserPermissions(request *ListInstanceUserPermissionsRequest) (_result *ListInstanceUserPermissionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListInstanceUserPermissionsResponse{}
	_body, _err := client.ListInstanceUserPermissionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListInstancesWithOptions(request *ListInstancesRequest, runtime *util.RuntimeOptions) (_result *ListInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DbType)) {
		query["DbType"] = request.DbType
	}

	if !tea.BoolValue(util.IsUnset(request.EnvType)) {
		query["EnvType"] = request.EnvType
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceSource)) {
		query["InstanceSource"] = request.InstanceSource
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceState)) {
		query["InstanceState"] = request.InstanceState
	}

	if !tea.BoolValue(util.IsUnset(request.NetType)) {
		query["NetType"] = request.NetType
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SearchKey)) {
		query["SearchKey"] = request.SearchKey
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListInstances"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListInstances(request *ListInstancesRequest) (_result *ListInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListInstancesResponse{}
	_body, _err := client.ListInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   Before you call this operation, make sure that you have the access permissions on the workspace. If you do not have the access permissions on the workspace, you can contact a DMS administrator, database administrator (DBA), or workspace administrator to add you as a member of the workspace. The [AddLhMembers](~~424759~~) operation can be called to add a workspace member.
 * *   If you are a DMS administrator or a workspace administrator, you can query the business scenarios and task flows related to a user in a workspace based on the user ID.
 *
 * @param request ListLhTaskFlowAndScenarioRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListLhTaskFlowAndScenarioResponse
 */
func (client *Client) ListLhTaskFlowAndScenarioWithOptions(request *ListLhTaskFlowAndScenarioRequest, runtime *util.RuntimeOptions) (_result *ListLhTaskFlowAndScenarioResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.SpaceId)) {
		query["SpaceId"] = request.SpaceId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.UserId)) {
		query["UserId"] = request.UserId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListLhTaskFlowAndScenario"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListLhTaskFlowAndScenarioResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   Before you call this operation, make sure that you have the access permissions on the workspace. If you do not have the access permissions on the workspace, you can contact a DMS administrator, database administrator (DBA), or workspace administrator to add you as a member of the workspace. The [AddLhMembers](~~424759~~) operation can be called to add a workspace member.
 * *   If you are a DMS administrator or a workspace administrator, you can query the business scenarios and task flows related to a user in a workspace based on the user ID.
 *
 * @param request ListLhTaskFlowAndScenarioRequest
 * @return ListLhTaskFlowAndScenarioResponse
 */
func (client *Client) ListLhTaskFlowAndScenario(request *ListLhTaskFlowAndScenarioRequest) (_result *ListLhTaskFlowAndScenarioResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListLhTaskFlowAndScenarioResponse{}
	_body, _err := client.ListLhTaskFlowAndScenarioWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListLogicDatabasesWithOptions(request *ListLogicDatabasesRequest, runtime *util.RuntimeOptions) (_result *ListLogicDatabasesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListLogicDatabases"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListLogicDatabasesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListLogicDatabases(request *ListLogicDatabasesRequest) (_result *ListLogicDatabasesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListLogicDatabasesResponse{}
	_body, _err := client.ListLogicDatabasesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListLogicTableRouteConfigWithOptions(request *ListLogicTableRouteConfigRequest, runtime *util.RuntimeOptions) (_result *ListLogicTableRouteConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TableId)) {
		query["TableId"] = request.TableId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListLogicTableRouteConfig"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListLogicTableRouteConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListLogicTableRouteConfig(request *ListLogicTableRouteConfigRequest) (_result *ListLogicTableRouteConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListLogicTableRouteConfigResponse{}
	_body, _err := client.ListLogicTableRouteConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListLogicTablesWithOptions(request *ListLogicTablesRequest, runtime *util.RuntimeOptions) (_result *ListLogicTablesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DatabaseId)) {
		query["DatabaseId"] = request.DatabaseId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ReturnGuid)) {
		query["ReturnGuid"] = request.ReturnGuid
	}

	if !tea.BoolValue(util.IsUnset(request.SearchName)) {
		query["SearchName"] = request.SearchName
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListLogicTables"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListLogicTablesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListLogicTables(request *ListLogicTablesRequest) (_result *ListLogicTablesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListLogicTablesResponse{}
	_body, _err := client.ListLogicTablesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListOrdersWithOptions(request *ListOrdersRequest, runtime *util.RuntimeOptions) (_result *ListOrdersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OrderResultType)) {
		query["OrderResultType"] = request.OrderResultType
	}

	if !tea.BoolValue(util.IsUnset(request.OrderStatus)) {
		query["OrderStatus"] = request.OrderStatus
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.PluginType)) {
		query["PluginType"] = request.PluginType
	}

	if !tea.BoolValue(util.IsUnset(request.SearchContent)) {
		query["SearchContent"] = request.SearchContent
	}

	if !tea.BoolValue(util.IsUnset(request.SearchDateType)) {
		query["SearchDateType"] = request.SearchDateType
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListOrders"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListOrdersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListOrders(request *ListOrdersRequest) (_result *ListOrdersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListOrdersResponse{}
	_body, _err := client.ListOrdersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListProxiesWithOptions(request *ListProxiesRequest, runtime *util.RuntimeOptions) (_result *ListProxiesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListProxies"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListProxiesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListProxies(request *ListProxiesRequest) (_result *ListProxiesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListProxiesResponse{}
	_body, _err := client.ListProxiesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListProxyAccessesWithOptions(request *ListProxyAccessesRequest, runtime *util.RuntimeOptions) (_result *ListProxyAccessesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ProxyId)) {
		query["ProxyId"] = request.ProxyId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListProxyAccesses"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListProxyAccessesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListProxyAccesses(request *ListProxyAccessesRequest) (_result *ListProxyAccessesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListProxyAccessesResponse{}
	_body, _err := client.ListProxyAccessesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListProxySQLExecAuditLogWithOptions(request *ListProxySQLExecAuditLogRequest, runtime *util.RuntimeOptions) (_result *ListProxySQLExecAuditLogResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.ExecState)) {
		query["ExecState"] = request.ExecState
	}

	if !tea.BoolValue(util.IsUnset(request.OpUserName)) {
		query["OpUserName"] = request.OpUserName
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SQLType)) {
		query["SQLType"] = request.SQLType
	}

	if !tea.BoolValue(util.IsUnset(request.SearchName)) {
		query["SearchName"] = request.SearchName
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListProxySQLExecAuditLog"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListProxySQLExecAuditLogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListProxySQLExecAuditLog(request *ListProxySQLExecAuditLogRequest) (_result *ListProxySQLExecAuditLogResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListProxySQLExecAuditLogResponse{}
	_body, _err := client.ListProxySQLExecAuditLogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListSLARulesWithOptions(request *ListSLARulesRequest, runtime *util.RuntimeOptions) (_result *ListSLARulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListSLARules"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListSLARulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListSLARules(request *ListSLARulesRequest) (_result *ListSLARulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListSLARulesResponse{}
	_body, _err := client.ListSLARulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListSQLExecAuditLogWithOptions(request *ListSQLExecAuditLogRequest, runtime *util.RuntimeOptions) (_result *ListSQLExecAuditLogResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.ExecState)) {
		query["ExecState"] = request.ExecState
	}

	if !tea.BoolValue(util.IsUnset(request.OpUserName)) {
		query["OpUserName"] = request.OpUserName
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SearchName)) {
		query["SearchName"] = request.SearchName
	}

	if !tea.BoolValue(util.IsUnset(request.SqlType)) {
		query["SqlType"] = request.SqlType
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListSQLExecAuditLog"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListSQLExecAuditLogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListSQLExecAuditLog(request *ListSQLExecAuditLogRequest) (_result *ListSQLExecAuditLogResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListSQLExecAuditLogResponse{}
	_body, _err := client.ListSQLExecAuditLogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * For more information about the SQL review feature, see [SQL review](~~60374~~).
 *
 * @param tmpReq ListSQLReviewOriginSQLRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSQLReviewOriginSQLResponse
 */
func (client *Client) ListSQLReviewOriginSQLWithOptions(tmpReq *ListSQLReviewOriginSQLRequest, runtime *util.RuntimeOptions) (_result *ListSQLReviewOriginSQLResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ListSQLReviewOriginSQLShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.OrderActionDetail)) {
		request.OrderActionDetailShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.OrderActionDetail, tea.String("OrderActionDetail"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderActionDetailShrink)) {
		query["OrderActionDetail"] = request.OrderActionDetailShrink
	}

	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListSQLReviewOriginSQL"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListSQLReviewOriginSQLResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * For more information about the SQL review feature, see [SQL review](~~60374~~).
 *
 * @param request ListSQLReviewOriginSQLRequest
 * @return ListSQLReviewOriginSQLResponse
 */
func (client *Client) ListSQLReviewOriginSQL(request *ListSQLReviewOriginSQLRequest) (_result *ListSQLReviewOriginSQLResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListSQLReviewOriginSQLResponse{}
	_body, _err := client.ListSQLReviewOriginSQLWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListScenariosWithOptions(request *ListScenariosRequest, runtime *util.RuntimeOptions) (_result *ListScenariosResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListScenarios"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListScenariosResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListScenarios(request *ListScenariosRequest) (_result *ListScenariosResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListScenariosResponse{}
	_body, _err := client.ListScenariosWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListSensitiveColumnsWithOptions(request *ListSensitiveColumnsRequest, runtime *util.RuntimeOptions) (_result *ListSensitiveColumnsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ColumnName)) {
		query["ColumnName"] = request.ColumnName
	}

	if !tea.BoolValue(util.IsUnset(request.DbId)) {
		query["DbId"] = request.DbId
	}

	if !tea.BoolValue(util.IsUnset(request.Logic)) {
		query["Logic"] = request.Logic
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SchemaName)) {
		query["SchemaName"] = request.SchemaName
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityLevel)) {
		query["SecurityLevel"] = request.SecurityLevel
	}

	if !tea.BoolValue(util.IsUnset(request.TableName)) {
		query["TableName"] = request.TableName
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListSensitiveColumns"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListSensitiveColumnsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListSensitiveColumns(request *ListSensitiveColumnsRequest) (_result *ListSensitiveColumnsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListSensitiveColumnsResponse{}
	_body, _err := client.ListSensitiveColumnsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListSensitiveColumnsDetailWithOptions(request *ListSensitiveColumnsDetailRequest, runtime *util.RuntimeOptions) (_result *ListSensitiveColumnsDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ColumnName)) {
		query["ColumnName"] = request.ColumnName
	}

	if !tea.BoolValue(util.IsUnset(request.DbId)) {
		query["DbId"] = request.DbId
	}

	if !tea.BoolValue(util.IsUnset(request.Logic)) {
		query["Logic"] = request.Logic
	}

	if !tea.BoolValue(util.IsUnset(request.SchemaName)) {
		query["SchemaName"] = request.SchemaName
	}

	if !tea.BoolValue(util.IsUnset(request.TableName)) {
		query["TableName"] = request.TableName
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListSensitiveColumnsDetail"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListSensitiveColumnsDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListSensitiveColumnsDetail(request *ListSensitiveColumnsDetailRequest) (_result *ListSensitiveColumnsDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListSensitiveColumnsDetailResponse{}
	_body, _err := client.ListSensitiveColumnsDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListSensitiveDataAuditLogWithOptions(request *ListSensitiveDataAuditLogRequest, runtime *util.RuntimeOptions) (_result *ListSensitiveDataAuditLogResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ColumnName)) {
		query["ColumnName"] = request.ColumnName
	}

	if !tea.BoolValue(util.IsUnset(request.DbName)) {
		query["DbName"] = request.DbName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.ModuleName)) {
		query["ModuleName"] = request.ModuleName
	}

	if !tea.BoolValue(util.IsUnset(request.OpUserName)) {
		query["OpUserName"] = request.OpUserName
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.TableName)) {
		query["TableName"] = request.TableName
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListSensitiveDataAuditLog"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListSensitiveDataAuditLogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListSensitiveDataAuditLog(request *ListSensitiveDataAuditLogRequest) (_result *ListSensitiveDataAuditLogResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListSensitiveDataAuditLogResponse{}
	_body, _err := client.ListSensitiveDataAuditLogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListSensitivityLevelWithOptions(request *ListSensitivityLevelRequest, runtime *util.RuntimeOptions) (_result *ListSensitivityLevelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListSensitivityLevel"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListSensitivityLevelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListSensitivityLevel(request *ListSensitivityLevelRequest) (_result *ListSensitivityLevelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListSensitivityLevelResponse{}
	_body, _err := client.ListSensitivityLevelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListStandardGroupsWithOptions(request *ListStandardGroupsRequest, runtime *util.RuntimeOptions) (_result *ListStandardGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListStandardGroups"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListStandardGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListStandardGroups(request *ListStandardGroupsRequest) (_result *ListStandardGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListStandardGroupsResponse{}
	_body, _err := client.ListStandardGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation only for database instances whose control mode is Security Collaboration.
 *
 * @param request ListTablesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTablesResponse
 */
func (client *Client) ListTablesWithOptions(request *ListTablesRequest, runtime *util.RuntimeOptions) (_result *ListTablesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DatabaseId)) {
		query["DatabaseId"] = request.DatabaseId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ReturnGuid)) {
		query["ReturnGuid"] = request.ReturnGuid
	}

	if !tea.BoolValue(util.IsUnset(request.SearchName)) {
		query["SearchName"] = request.SearchName
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTables"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTablesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation only for database instances whose control mode is Security Collaboration.
 *
 * @param request ListTablesRequest
 * @return ListTablesResponse
 */
func (client *Client) ListTables(request *ListTablesRequest) (_result *ListTablesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTablesResponse{}
	_body, _err := client.ListTablesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTaskFlowWithOptions(request *ListTaskFlowRequest, runtime *util.RuntimeOptions) (_result *ListTaskFlowResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTaskFlow"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTaskFlowResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTaskFlow(request *ListTaskFlowRequest) (_result *ListTaskFlowResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTaskFlowResponse{}
	_body, _err := client.ListTaskFlowWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTaskFlowConstantsWithOptions(request *ListTaskFlowConstantsRequest, runtime *util.RuntimeOptions) (_result *ListTaskFlowConstantsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTaskFlowConstants"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTaskFlowConstantsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTaskFlowConstants(request *ListTaskFlowConstantsRequest) (_result *ListTaskFlowConstantsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTaskFlowConstantsResponse{}
	_body, _err := client.ListTaskFlowConstantsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTaskFlowCooperatorsWithOptions(request *ListTaskFlowCooperatorsRequest, runtime *util.RuntimeOptions) (_result *ListTaskFlowCooperatorsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTaskFlowCooperators"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTaskFlowCooperatorsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTaskFlowCooperators(request *ListTaskFlowCooperatorsRequest) (_result *ListTaskFlowCooperatorsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTaskFlowCooperatorsResponse{}
	_body, _err := client.ListTaskFlowCooperatorsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation is used for multi-condition query. You can call this operation to query the edges of a specified task flow that meet all specified conditions.
 *
 * @param request ListTaskFlowEdgesByConditionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTaskFlowEdgesByConditionResponse
 */
func (client *Client) ListTaskFlowEdgesByConditionWithOptions(request *ListTaskFlowEdgesByConditionRequest, runtime *util.RuntimeOptions) (_result *ListTaskFlowEdgesByConditionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.NodeEnd)) {
		query["NodeEnd"] = request.NodeEnd
	}

	if !tea.BoolValue(util.IsUnset(request.NodeFrom)) {
		query["NodeFrom"] = request.NodeFrom
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTaskFlowEdgesByCondition"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTaskFlowEdgesByConditionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation is used for multi-condition query. You can call this operation to query the edges of a specified task flow that meet all specified conditions.
 *
 * @param request ListTaskFlowEdgesByConditionRequest
 * @return ListTaskFlowEdgesByConditionResponse
 */
func (client *Client) ListTaskFlowEdgesByCondition(request *ListTaskFlowEdgesByConditionRequest) (_result *ListTaskFlowEdgesByConditionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTaskFlowEdgesByConditionResponse{}
	_body, _err := client.ListTaskFlowEdgesByConditionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTaskFlowInstanceWithOptions(request *ListTaskFlowInstanceRequest, runtime *util.RuntimeOptions) (_result *ListTaskFlowInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.PageIndex)) {
		query["PageIndex"] = request.PageIndex
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.StartTimeBegin)) {
		query["StartTimeBegin"] = request.StartTimeBegin
	}

	if !tea.BoolValue(util.IsUnset(request.StartTimeEnd)) {
		query["StartTimeEnd"] = request.StartTimeEnd
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.TriggerType)) {
		query["TriggerType"] = request.TriggerType
	}

	if !tea.BoolValue(util.IsUnset(request.UseBizDate)) {
		query["UseBizDate"] = request.UseBizDate
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTaskFlowInstance"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTaskFlowInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTaskFlowInstance(request *ListTaskFlowInstanceRequest) (_result *ListTaskFlowInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTaskFlowInstanceResponse{}
	_body, _err := client.ListTaskFlowInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTaskFlowTimeVariablesWithOptions(request *ListTaskFlowTimeVariablesRequest, runtime *util.RuntimeOptions) (_result *ListTaskFlowTimeVariablesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTaskFlowTimeVariables"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTaskFlowTimeVariablesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTaskFlowTimeVariables(request *ListTaskFlowTimeVariablesRequest) (_result *ListTaskFlowTimeVariablesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTaskFlowTimeVariablesResponse{}
	_body, _err := client.ListTaskFlowTimeVariablesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTaskFlowsByPageWithOptions(tmpReq *ListTaskFlowsByPageRequest, runtime *util.RuntimeOptions) (_result *ListTaskFlowsByPageResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ListTaskFlowsByPageShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.DagIdList)) {
		request.DagIdListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.DagIdList, tea.String("DagIdList"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagIdListShrink)) {
		query["DagIdList"] = request.DagIdListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.PageIndex)) {
		query["PageIndex"] = request.PageIndex
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ScenarioId)) {
		query["ScenarioId"] = request.ScenarioId
	}

	if !tea.BoolValue(util.IsUnset(request.SearchKey)) {
		query["SearchKey"] = request.SearchKey
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTaskFlowsByPage"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTaskFlowsByPageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTaskFlowsByPage(request *ListTaskFlowsByPageRequest) (_result *ListTaskFlowsByPageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTaskFlowsByPageResponse{}
	_body, _err := client.ListTaskFlowsByPageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTasksInTaskFlowWithOptions(request *ListTasksInTaskFlowRequest, runtime *util.RuntimeOptions) (_result *ListTasksInTaskFlowResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTasksInTaskFlow"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTasksInTaskFlowResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTasksInTaskFlow(request *ListTasksInTaskFlowRequest) (_result *ListTasksInTaskFlowResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTasksInTaskFlowResponse{}
	_body, _err := client.ListTasksInTaskFlowWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListUserPermissionsWithOptions(request *ListUserPermissionsRequest, runtime *util.RuntimeOptions) (_result *ListUserPermissionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DatabaseName)) {
		query["DatabaseName"] = request.DatabaseName
	}

	if !tea.BoolValue(util.IsUnset(request.DbType)) {
		query["DbType"] = request.DbType
	}

	if !tea.BoolValue(util.IsUnset(request.EnvType)) {
		query["EnvType"] = request.EnvType
	}

	if !tea.BoolValue(util.IsUnset(request.Logic)) {
		query["Logic"] = request.Logic
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.PermType)) {
		query["PermType"] = request.PermType
	}

	if !tea.BoolValue(util.IsUnset(request.SearchKey)) {
		query["SearchKey"] = request.SearchKey
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.UserId)) {
		query["UserId"] = request.UserId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListUserPermissions"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListUserPermissionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListUserPermissions(request *ListUserPermissionsRequest) (_result *ListUserPermissionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListUserPermissionsResponse{}
	_body, _err := client.ListUserPermissionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListUserTenantsWithOptions(request *ListUserTenantsRequest, runtime *util.RuntimeOptions) (_result *ListUserTenantsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListUserTenants"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListUserTenantsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListUserTenants(request *ListUserTenantsRequest) (_result *ListUserTenantsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListUserTenantsResponse{}
	_body, _err := client.ListUserTenantsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListUsersWithOptions(request *ListUsersRequest, runtime *util.RuntimeOptions) (_result *ListUsersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Role)) {
		query["Role"] = request.Role
	}

	if !tea.BoolValue(util.IsUnset(request.SearchKey)) {
		query["SearchKey"] = request.SearchKey
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.UserState)) {
		query["UserState"] = request.UserState
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListUsers"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListUsersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListUsers(request *ListUsersRequest) (_result *ListUsersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListUsersResponse{}
	_body, _err := client.ListUsersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListWorkFlowNodesWithOptions(request *ListWorkFlowNodesRequest, runtime *util.RuntimeOptions) (_result *ListWorkFlowNodesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.SearchName)) {
		query["SearchName"] = request.SearchName
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListWorkFlowNodes"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListWorkFlowNodesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListWorkFlowNodes(request *ListWorkFlowNodesRequest) (_result *ListWorkFlowNodesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListWorkFlowNodesResponse{}
	_body, _err := client.ListWorkFlowNodesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListWorkFlowTemplatesWithOptions(request *ListWorkFlowTemplatesRequest, runtime *util.RuntimeOptions) (_result *ListWorkFlowTemplatesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.SearchName)) {
		query["SearchName"] = request.SearchName
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListWorkFlowTemplates"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListWorkFlowTemplatesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListWorkFlowTemplates(request *ListWorkFlowTemplatesRequest) (_result *ListWorkFlowTemplatesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListWorkFlowTemplatesResponse{}
	_body, _err := client.ListWorkFlowTemplatesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) MakeTaskFlowInstanceSuccessWithOptions(request *MakeTaskFlowInstanceSuccessRequest, runtime *util.RuntimeOptions) (_result *MakeTaskFlowInstanceSuccessResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.DagInstanceId)) {
		query["DagInstanceId"] = request.DagInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("MakeTaskFlowInstanceSuccess"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &MakeTaskFlowInstanceSuccessResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) MakeTaskFlowInstanceSuccess(request *MakeTaskFlowInstanceSuccessRequest) (_result *MakeTaskFlowInstanceSuccessResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &MakeTaskFlowInstanceSuccessResponse{}
	_body, _err := client.MakeTaskFlowInstanceSuccessWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyDataCorrectExecSQLWithOptions(request *ModifyDataCorrectExecSQLRequest, runtime *util.RuntimeOptions) (_result *ModifyDataCorrectExecSQLResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ExecSQL)) {
		query["ExecSQL"] = request.ExecSQL
	}

	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDataCorrectExecSQL"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDataCorrectExecSQLResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyDataCorrectExecSQL(request *ModifyDataCorrectExecSQLRequest) (_result *ModifyDataCorrectExecSQLResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDataCorrectExecSQLResponse{}
	_body, _err := client.ModifyDataCorrectExecSQLWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyDesensitizationStrategyWithOptions(request *ModifyDesensitizationStrategyRequest, runtime *util.RuntimeOptions) (_result *ModifyDesensitizationStrategyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ColumnName)) {
		query["ColumnName"] = request.ColumnName
	}

	if !tea.BoolValue(util.IsUnset(request.DbId)) {
		query["DbId"] = request.DbId
	}

	if !tea.BoolValue(util.IsUnset(request.IsDefault)) {
		query["IsDefault"] = request.IsDefault
	}

	if !tea.BoolValue(util.IsUnset(request.IsLogic)) {
		query["IsLogic"] = request.IsLogic
	}

	if !tea.BoolValue(util.IsUnset(request.IsReset)) {
		query["IsReset"] = request.IsReset
	}

	if !tea.BoolValue(util.IsUnset(request.RuleId)) {
		query["RuleId"] = request.RuleId
	}

	if !tea.BoolValue(util.IsUnset(request.SchemaName)) {
		query["SchemaName"] = request.SchemaName
	}

	if !tea.BoolValue(util.IsUnset(request.TableName)) {
		query["TableName"] = request.TableName
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDesensitizationStrategy"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDesensitizationStrategyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyDesensitizationStrategy(request *ModifyDesensitizationStrategyRequest) (_result *ModifyDesensitizationStrategyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDesensitizationStrategyResponse{}
	_body, _err := client.ModifyDesensitizationStrategyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyInstanceWithOptions(request *ModifyInstanceRequest, runtime *util.RuntimeOptions) (_result *ModifyInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DataLinkName)) {
		query["DataLinkName"] = request.DataLinkName
	}

	if !tea.BoolValue(util.IsUnset(request.DatabasePassword)) {
		query["DatabasePassword"] = request.DatabasePassword
	}

	if !tea.BoolValue(util.IsUnset(request.DatabaseUser)) {
		query["DatabaseUser"] = request.DatabaseUser
	}

	if !tea.BoolValue(util.IsUnset(request.DbaId)) {
		query["DbaId"] = request.DbaId
	}

	if !tea.BoolValue(util.IsUnset(request.DdlOnline)) {
		query["DdlOnline"] = request.DdlOnline
	}

	if !tea.BoolValue(util.IsUnset(request.EcsInstanceId)) {
		query["EcsInstanceId"] = request.EcsInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.EcsRegion)) {
		query["EcsRegion"] = request.EcsRegion
	}

	if !tea.BoolValue(util.IsUnset(request.EnableSellCommon)) {
		query["EnableSellCommon"] = request.EnableSellCommon
	}

	if !tea.BoolValue(util.IsUnset(request.EnableSellSitd)) {
		query["EnableSellSitd"] = request.EnableSellSitd
	}

	if !tea.BoolValue(util.IsUnset(request.EnableSellStable)) {
		query["EnableSellStable"] = request.EnableSellStable
	}

	if !tea.BoolValue(util.IsUnset(request.EnableSellTrust)) {
		query["EnableSellTrust"] = request.EnableSellTrust
	}

	if !tea.BoolValue(util.IsUnset(request.EnvType)) {
		query["EnvType"] = request.EnvType
	}

	if !tea.BoolValue(util.IsUnset(request.ExportTimeout)) {
		query["ExportTimeout"] = request.ExportTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.Host)) {
		query["Host"] = request.Host
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceAlias)) {
		query["InstanceAlias"] = request.InstanceAlias
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceSource)) {
		query["InstanceSource"] = request.InstanceSource
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceType)) {
		query["InstanceType"] = request.InstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkType)) {
		query["NetworkType"] = request.NetworkType
	}

	if !tea.BoolValue(util.IsUnset(request.Port)) {
		query["Port"] = request.Port
	}

	if !tea.BoolValue(util.IsUnset(request.QueryTimeout)) {
		query["QueryTimeout"] = request.QueryTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.SafeRule)) {
		query["SafeRule"] = request.SafeRule
	}

	if !tea.BoolValue(util.IsUnset(request.Sid)) {
		query["Sid"] = request.Sid
	}

	if !tea.BoolValue(util.IsUnset(request.SkipTest)) {
		query["SkipTest"] = request.SkipTest
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		query["TemplateId"] = request.TemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateType)) {
		query["TemplateType"] = request.TemplateType
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.UseDsql)) {
		query["UseDsql"] = request.UseDsql
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyInstance"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyInstance(request *ModifyInstanceRequest) (_result *ModifyInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyInstanceResponse{}
	_body, _err := client.ModifyInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) MoveTaskFlowToScenarioWithOptions(request *MoveTaskFlowToScenarioRequest, runtime *util.RuntimeOptions) (_result *MoveTaskFlowToScenarioResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.ScenarioId)) {
		query["ScenarioId"] = request.ScenarioId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("MoveTaskFlowToScenario"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &MoveTaskFlowToScenarioResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) MoveTaskFlowToScenario(request *MoveTaskFlowToScenarioRequest) (_result *MoveTaskFlowToScenarioResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &MoveTaskFlowToScenarioResponse{}
	_body, _err := client.MoveTaskFlowToScenarioWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) OfflineTaskFlowWithOptions(request *OfflineTaskFlowRequest, runtime *util.RuntimeOptions) (_result *OfflineTaskFlowResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("OfflineTaskFlow"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &OfflineTaskFlowResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) OfflineTaskFlow(request *OfflineTaskFlowRequest) (_result *OfflineTaskFlowResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &OfflineTaskFlowResponse{}
	_body, _err := client.OfflineTaskFlowWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) PauseDataCorrectSQLJobWithOptions(request *PauseDataCorrectSQLJobRequest, runtime *util.RuntimeOptions) (_result *PauseDataCorrectSQLJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.JobId)) {
		query["JobId"] = request.JobId
	}

	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("PauseDataCorrectSQLJob"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PauseDataCorrectSQLJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) PauseDataCorrectSQLJob(request *PauseDataCorrectSQLJobRequest) (_result *PauseDataCorrectSQLJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PauseDataCorrectSQLJobResponse{}
	_body, _err := client.PauseDataCorrectSQLJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) PreviewWorkflowWithOptions(request *PreviewWorkflowRequest, runtime *util.RuntimeOptions) (_result *PreviewWorkflowResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("PreviewWorkflow"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PreviewWorkflowResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) PreviewWorkflow(request *PreviewWorkflowRequest) (_result *PreviewWorkflowResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PreviewWorkflowResponse{}
	_body, _err := client.PreviewWorkflowWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) PublishAndDeployTaskFlowWithOptions(request *PublishAndDeployTaskFlowRequest, runtime *util.RuntimeOptions) (_result *PublishAndDeployTaskFlowResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.VersionComments)) {
		query["VersionComments"] = request.VersionComments
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("PublishAndDeployTaskFlow"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PublishAndDeployTaskFlowResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) PublishAndDeployTaskFlow(request *PublishAndDeployTaskFlowRequest) (_result *PublishAndDeployTaskFlowResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PublishAndDeployTaskFlowResponse{}
	_body, _err := client.PublishAndDeployTaskFlowWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryDataTrackResultDownloadStatusWithOptions(request *QueryDataTrackResultDownloadStatusRequest, runtime *util.RuntimeOptions) (_result *QueryDataTrackResultDownloadStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DownloadKeyId)) {
		query["DownloadKeyId"] = request.DownloadKeyId
	}

	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDataTrackResultDownloadStatus"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDataTrackResultDownloadStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryDataTrackResultDownloadStatus(request *QueryDataTrackResultDownloadStatusRequest) (_result *QueryDataTrackResultDownloadStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDataTrackResultDownloadStatusResponse{}
	_body, _err := client.QueryDataTrackResultDownloadStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ReDeployLhDagVersionWithOptions(request *ReDeployLhDagVersionRequest, runtime *util.RuntimeOptions) (_result *ReDeployLhDagVersionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.DagVersion)) {
		query["DagVersion"] = request.DagVersion
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ReDeployLhDagVersion"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ReDeployLhDagVersionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ReDeployLhDagVersion(request *ReDeployLhDagVersionRequest) (_result *ReDeployLhDagVersionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ReDeployLhDagVersionResponse{}
	_body, _err := client.ReDeployLhDagVersionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ReRunTaskFlowInstanceWithOptions(request *ReRunTaskFlowInstanceRequest, runtime *util.RuntimeOptions) (_result *ReRunTaskFlowInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.DagInstanceId)) {
		query["DagInstanceId"] = request.DagInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DagVersion)) {
		query["DagVersion"] = request.DagVersion
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ReRunTaskFlowInstance"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ReRunTaskFlowInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ReRunTaskFlowInstance(request *ReRunTaskFlowInstanceRequest) (_result *ReRunTaskFlowInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ReRunTaskFlowInstanceResponse{}
	_body, _err := client.ReRunTaskFlowInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RefundPayAsYouGoOrderWithOptions(request *RefundPayAsYouGoOrderRequest, runtime *util.RuntimeOptions) (_result *RefundPayAsYouGoOrderResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RefundPayAsYouGoOrder"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RefundPayAsYouGoOrderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RefundPayAsYouGoOrder(request *RefundPayAsYouGoOrderRequest) (_result *RefundPayAsYouGoOrderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RefundPayAsYouGoOrderResponse{}
	_body, _err := client.RefundPayAsYouGoOrderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Prerequisites: You are a DMS administrator or a database administrator (DBA). You can call the [ListUsers](~~141938~~) or [GetUser](~~147098~~) operation to query your user role from the RoleIdList parameter that is returned.
 *
 * @param request RegisterInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RegisterInstanceResponse
 */
func (client *Client) RegisterInstanceWithOptions(request *RegisterInstanceRequest, runtime *util.RuntimeOptions) (_result *RegisterInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DataLinkName)) {
		query["DataLinkName"] = request.DataLinkName
	}

	if !tea.BoolValue(util.IsUnset(request.DatabasePassword)) {
		query["DatabasePassword"] = request.DatabasePassword
	}

	if !tea.BoolValue(util.IsUnset(request.DatabaseUser)) {
		query["DatabaseUser"] = request.DatabaseUser
	}

	if !tea.BoolValue(util.IsUnset(request.DbaUid)) {
		query["DbaUid"] = request.DbaUid
	}

	if !tea.BoolValue(util.IsUnset(request.DbaUidByString)) {
		query["DbaUidByString"] = request.DbaUidByString
	}

	if !tea.BoolValue(util.IsUnset(request.DdlOnline)) {
		query["DdlOnline"] = request.DdlOnline
	}

	if !tea.BoolValue(util.IsUnset(request.EcsInstanceId)) {
		query["EcsInstanceId"] = request.EcsInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.EcsRegion)) {
		query["EcsRegion"] = request.EcsRegion
	}

	if !tea.BoolValue(util.IsUnset(request.EnableSellSitd)) {
		query["EnableSellSitd"] = request.EnableSellSitd
	}

	if !tea.BoolValue(util.IsUnset(request.EnvType)) {
		query["EnvType"] = request.EnvType
	}

	if !tea.BoolValue(util.IsUnset(request.ExportTimeout)) {
		query["ExportTimeout"] = request.ExportTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.Host)) {
		query["Host"] = request.Host
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceAlias)) {
		query["InstanceAlias"] = request.InstanceAlias
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceSource)) {
		query["InstanceSource"] = request.InstanceSource
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceType)) {
		query["InstanceType"] = request.InstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkType)) {
		query["NetworkType"] = request.NetworkType
	}

	if !tea.BoolValue(util.IsUnset(request.Port)) {
		query["Port"] = request.Port
	}

	if !tea.BoolValue(util.IsUnset(request.QueryTimeout)) {
		query["QueryTimeout"] = request.QueryTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.SafeRule)) {
		query["SafeRule"] = request.SafeRule
	}

	if !tea.BoolValue(util.IsUnset(request.Sid)) {
		query["Sid"] = request.Sid
	}

	if !tea.BoolValue(util.IsUnset(request.SkipTest)) {
		query["SkipTest"] = request.SkipTest
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		query["TemplateId"] = request.TemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateType)) {
		query["TemplateType"] = request.TemplateType
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.UseDsql)) {
		query["UseDsql"] = request.UseDsql
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RegisterInstance"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RegisterInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Prerequisites: You are a DMS administrator or a database administrator (DBA). You can call the [ListUsers](~~141938~~) or [GetUser](~~147098~~) operation to query your user role from the RoleIdList parameter that is returned.
 *
 * @param request RegisterInstanceRequest
 * @return RegisterInstanceResponse
 */
func (client *Client) RegisterInstance(request *RegisterInstanceRequest) (_result *RegisterInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RegisterInstanceResponse{}
	_body, _err := client.RegisterInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If you are an **administrator** in Data Management (DMS), you can call this operation to register a user for your enterprise. To view users that are assigned the administrator role, perform the following steps: Log on to the DMS console. In the top navigation bar, click O&M. In the left-side navigation pane, click User.
 *
 * @param request RegisterUserRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RegisterUserResponse
 */
func (client *Client) RegisterUserWithOptions(request *RegisterUserRequest, runtime *util.RuntimeOptions) (_result *RegisterUserResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Mobile)) {
		query["Mobile"] = request.Mobile
	}

	if !tea.BoolValue(util.IsUnset(request.RoleNames)) {
		query["RoleNames"] = request.RoleNames
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.Uid)) {
		query["Uid"] = request.Uid
	}

	if !tea.BoolValue(util.IsUnset(request.UserNick)) {
		query["UserNick"] = request.UserNick
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RegisterUser"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RegisterUserResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If you are an **administrator** in Data Management (DMS), you can call this operation to register a user for your enterprise. To view users that are assigned the administrator role, perform the following steps: Log on to the DMS console. In the top navigation bar, click O&M. In the left-side navigation pane, click User.
 *
 * @param request RegisterUserRequest
 * @return RegisterUserResponse
 */
func (client *Client) RegisterUser(request *RegisterUserRequest) (_result *RegisterUserResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RegisterUserResponse{}
	_body, _err := client.RegisterUserWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RestartDataCorrectSQLJobWithOptions(request *RestartDataCorrectSQLJobRequest, runtime *util.RuntimeOptions) (_result *RestartDataCorrectSQLJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.JobId)) {
		query["JobId"] = request.JobId
	}

	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RestartDataCorrectSQLJob"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RestartDataCorrectSQLJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RestartDataCorrectSQLJob(request *RestartDataCorrectSQLJobRequest) (_result *RestartDataCorrectSQLJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RestartDataCorrectSQLJobResponse{}
	_body, _err := client.RestartDataCorrectSQLJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation only for task flows that are suspended.
 *
 * @param request ResumeTaskFlowInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResumeTaskFlowInstanceResponse
 */
func (client *Client) ResumeTaskFlowInstanceWithOptions(request *ResumeTaskFlowInstanceRequest, runtime *util.RuntimeOptions) (_result *ResumeTaskFlowInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.DagInstanceId)) {
		query["DagInstanceId"] = request.DagInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.DagVersion)) {
		query["DagVersion"] = request.DagVersion
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ResumeTaskFlowInstance"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ResumeTaskFlowInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation only for task flows that are suspended.
 *
 * @param request ResumeTaskFlowInstanceRequest
 * @return ResumeTaskFlowInstanceResponse
 */
func (client *Client) ResumeTaskFlowInstance(request *ResumeTaskFlowInstanceRequest) (_result *ResumeTaskFlowInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ResumeTaskFlowInstanceResponse{}
	_body, _err := client.ResumeTaskFlowInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RetryDataCorrectPreCheckWithOptions(request *RetryDataCorrectPreCheckRequest, runtime *util.RuntimeOptions) (_result *RetryDataCorrectPreCheckResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RetryDataCorrectPreCheck"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RetryDataCorrectPreCheckResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RetryDataCorrectPreCheck(request *RetryDataCorrectPreCheckRequest) (_result *RetryDataCorrectPreCheckResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RetryDataCorrectPreCheckResponse{}
	_body, _err := client.RetryDataCorrectPreCheckWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You must be a database administrator (DBA) or a DMS administrator. For more information about how to view system roles, see [View system roles](~~324212~~).
 *
 * @param request RevokeTemplateAuthorityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RevokeTemplateAuthorityResponse
 */
func (client *Client) RevokeTemplateAuthorityWithOptions(request *RevokeTemplateAuthorityRequest, runtime *util.RuntimeOptions) (_result *RevokeTemplateAuthorityResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		query["TemplateId"] = request.TemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.UserIds)) {
		query["UserIds"] = request.UserIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RevokeTemplateAuthority"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RevokeTemplateAuthorityResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You must be a database administrator (DBA) or a DMS administrator. For more information about how to view system roles, see [View system roles](~~324212~~).
 *
 * @param request RevokeTemplateAuthorityRequest
 * @return RevokeTemplateAuthorityResponse
 */
func (client *Client) RevokeTemplateAuthority(request *RevokeTemplateAuthorityRequest) (_result *RevokeTemplateAuthorityResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RevokeTemplateAuthorityResponse{}
	_body, _err := client.RevokeTemplateAuthorityWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RevokeUserPermissionWithOptions(request *RevokeUserPermissionRequest, runtime *util.RuntimeOptions) (_result *RevokeUserPermissionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DbId)) {
		query["DbId"] = request.DbId
	}

	if !tea.BoolValue(util.IsUnset(request.DsType)) {
		query["DsType"] = request.DsType
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Logic)) {
		query["Logic"] = request.Logic
	}

	if !tea.BoolValue(util.IsUnset(request.PermTypes)) {
		query["PermTypes"] = request.PermTypes
	}

	if !tea.BoolValue(util.IsUnset(request.TableId)) {
		query["TableId"] = request.TableId
	}

	if !tea.BoolValue(util.IsUnset(request.TableName)) {
		query["TableName"] = request.TableName
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.UserAccessId)) {
		query["UserAccessId"] = request.UserAccessId
	}

	if !tea.BoolValue(util.IsUnset(request.UserId)) {
		query["UserId"] = request.UserId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RevokeUserPermission"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RevokeUserPermissionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RevokeUserPermission(request *RevokeUserPermissionRequest) (_result *RevokeUserPermissionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RevokeUserPermissionResponse{}
	_body, _err := client.RevokeUserPermissionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SearchDataTrackResultWithOptions(tmpReq *SearchDataTrackResultRequest, runtime *util.RuntimeOptions) (_result *SearchDataTrackResultResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &SearchDataTrackResultShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.ColumnFilter)) {
		request.ColumnFilterShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.ColumnFilter, tea.String("ColumnFilter"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.FilterTableList)) {
		request.FilterTableListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.FilterTableList, tea.String("FilterTableList"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.FilterTypeList)) {
		request.FilterTypeListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.FilterTypeList, tea.String("FilterTypeList"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ColumnFilterShrink)) {
		query["ColumnFilter"] = request.ColumnFilterShrink
	}

	if !tea.BoolValue(util.IsUnset(request.FilterEndTime)) {
		query["FilterEndTime"] = request.FilterEndTime
	}

	if !tea.BoolValue(util.IsUnset(request.FilterStartTime)) {
		query["FilterStartTime"] = request.FilterStartTime
	}

	if !tea.BoolValue(util.IsUnset(request.FilterTableListShrink)) {
		query["FilterTableList"] = request.FilterTableListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.FilterTypeListShrink)) {
		query["FilterTypeList"] = request.FilterTypeListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SearchDataTrackResult"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SearchDataTrackResultResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SearchDataTrackResult(request *SearchDataTrackResultRequest) (_result *SearchDataTrackResultResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SearchDataTrackResultResponse{}
	_body, _err := client.SearchDataTrackResultWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SearchDatabaseWithOptions(request *SearchDatabaseRequest, runtime *util.RuntimeOptions) (_result *SearchDatabaseResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DbType)) {
		query["DbType"] = request.DbType
	}

	if !tea.BoolValue(util.IsUnset(request.EnvType)) {
		query["EnvType"] = request.EnvType
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SearchKey)) {
		query["SearchKey"] = request.SearchKey
	}

	if !tea.BoolValue(util.IsUnset(request.SearchRange)) {
		query["SearchRange"] = request.SearchRange
	}

	if !tea.BoolValue(util.IsUnset(request.SearchTarget)) {
		query["SearchTarget"] = request.SearchTarget
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SearchDatabase"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SearchDatabaseResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SearchDatabase(request *SearchDatabaseRequest) (_result *SearchDatabaseResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SearchDatabaseResponse{}
	_body, _err := client.SearchDatabaseWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation only for database instances that are managed in Security Collaboration mode.
 *
 * @param request SearchTableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchTableResponse
 */
func (client *Client) SearchTableWithOptions(request *SearchTableRequest, runtime *util.RuntimeOptions) (_result *SearchTableResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DbType)) {
		query["DbType"] = request.DbType
	}

	if !tea.BoolValue(util.IsUnset(request.EnvType)) {
		query["EnvType"] = request.EnvType
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ReturnGuid)) {
		query["ReturnGuid"] = request.ReturnGuid
	}

	if !tea.BoolValue(util.IsUnset(request.SearchKey)) {
		query["SearchKey"] = request.SearchKey
	}

	if !tea.BoolValue(util.IsUnset(request.SearchRange)) {
		query["SearchRange"] = request.SearchRange
	}

	if !tea.BoolValue(util.IsUnset(request.SearchTarget)) {
		query["SearchTarget"] = request.SearchTarget
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SearchTable"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SearchTableResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation only for database instances that are managed in Security Collaboration mode.
 *
 * @param request SearchTableRequest
 * @return SearchTableResponse
 */
func (client *Client) SearchTable(request *SearchTableRequest) (_result *SearchTableResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SearchTableResponse{}
	_body, _err := client.SearchTableWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetOwnersWithOptions(request *SetOwnersRequest, runtime *util.RuntimeOptions) (_result *SetOwnersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerIds)) {
		query["OwnerIds"] = request.OwnerIds
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerType)) {
		query["OwnerType"] = request.OwnerType
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetOwners"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetOwnersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetOwners(request *SetOwnersRequest) (_result *SetOwnersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetOwnersResponse{}
	_body, _err := client.SetOwnersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SkipDataCorrectRowCheckWithOptions(request *SkipDataCorrectRowCheckRequest, runtime *util.RuntimeOptions) (_result *SkipDataCorrectRowCheckResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Reason)) {
		query["Reason"] = request.Reason
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SkipDataCorrectRowCheck"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SkipDataCorrectRowCheckResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SkipDataCorrectRowCheck(request *SkipDataCorrectRowCheckRequest) (_result *SkipDataCorrectRowCheckResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SkipDataCorrectRowCheckResponse{}
	_body, _err := client.SkipDataCorrectRowCheckWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) StopTaskFlowInstanceWithOptions(request *StopTaskFlowInstanceRequest, runtime *util.RuntimeOptions) (_result *StopTaskFlowInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.DagInstanceId)) {
		query["DagInstanceId"] = request.DagInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StopTaskFlowInstance"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StopTaskFlowInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) StopTaskFlowInstance(request *StopTaskFlowInstanceRequest) (_result *StopTaskFlowInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StopTaskFlowInstanceResponse{}
	_body, _err := client.StopTaskFlowInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SubmitOrderApprovalWithOptions(request *SubmitOrderApprovalRequest, runtime *util.RuntimeOptions) (_result *SubmitOrderApprovalResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SubmitOrderApproval"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SubmitOrderApprovalResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SubmitOrderApproval(request *SubmitOrderApprovalRequest) (_result *SubmitOrderApprovalResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SubmitOrderApprovalResponse{}
	_body, _err := client.SubmitOrderApprovalWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SubmitStructSyncOrderApprovalWithOptions(request *SubmitStructSyncOrderApprovalRequest, runtime *util.RuntimeOptions) (_result *SubmitStructSyncOrderApprovalResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SubmitStructSyncOrderApproval"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SubmitStructSyncOrderApprovalResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SubmitStructSyncOrderApproval(request *SubmitStructSyncOrderApprovalRequest) (_result *SubmitStructSyncOrderApprovalResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SubmitStructSyncOrderApprovalResponse{}
	_body, _err := client.SubmitStructSyncOrderApprovalWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SuspendTaskFlowInstanceWithOptions(request *SuspendTaskFlowInstanceRequest, runtime *util.RuntimeOptions) (_result *SuspendTaskFlowInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.DagInstanceId)) {
		query["DagInstanceId"] = request.DagInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SuspendTaskFlowInstance"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SuspendTaskFlowInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SuspendTaskFlowInstance(request *SuspendTaskFlowInstanceRequest) (_result *SuspendTaskFlowInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SuspendTaskFlowInstanceResponse{}
	_body, _err := client.SuspendTaskFlowInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SyncDatabaseMetaWithOptions(request *SyncDatabaseMetaRequest, runtime *util.RuntimeOptions) (_result *SyncDatabaseMetaResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DbId)) {
		query["DbId"] = request.DbId
	}

	if !tea.BoolValue(util.IsUnset(request.Logic)) {
		query["Logic"] = request.Logic
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SyncDatabaseMeta"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SyncDatabaseMetaResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SyncDatabaseMeta(request *SyncDatabaseMetaRequest) (_result *SyncDatabaseMetaResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SyncDatabaseMetaResponse{}
	_body, _err := client.SyncDatabaseMetaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation only for database instances whose control mode is Security Collaboration.
 *
 * @param request SyncInstanceMetaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SyncInstanceMetaResponse
 */
func (client *Client) SyncInstanceMetaWithOptions(request *SyncInstanceMetaRequest, runtime *util.RuntimeOptions) (_result *SyncInstanceMetaResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IgnoreTable)) {
		query["IgnoreTable"] = request.IgnoreTable
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SyncInstanceMeta"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SyncInstanceMetaResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation only for database instances whose control mode is Security Collaboration.
 *
 * @param request SyncInstanceMetaRequest
 * @return SyncInstanceMetaResponse
 */
func (client *Client) SyncInstanceMeta(request *SyncInstanceMetaRequest) (_result *SyncInstanceMetaResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SyncInstanceMetaResponse{}
	_body, _err := client.SyncInstanceMetaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You are a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](~~324212~~).
 *
 * @param request UpdateAuthorityTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAuthorityTemplateResponse
 */
func (client *Client) UpdateAuthorityTemplateWithOptions(request *UpdateAuthorityTemplateRequest, runtime *util.RuntimeOptions) (_result *UpdateAuthorityTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		query["TemplateId"] = request.TemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAuthorityTemplate"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateAuthorityTemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You are a database administrator (DBA) or a Data Management (DMS) administrator. For more information about how to view system roles, see [View system roles](~~324212~~).
 *
 * @param request UpdateAuthorityTemplateRequest
 * @return UpdateAuthorityTemplateResponse
 */
func (client *Client) UpdateAuthorityTemplate(request *UpdateAuthorityTemplateRequest) (_result *UpdateAuthorityTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateAuthorityTemplateResponse{}
	_body, _err := client.UpdateAuthorityTemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call the UpdateInstance operation, call the [GetInstance](~~141567~~) or [ListInstances](~~141936~~) operation to obtain the complete information about the instance.
 *
 * @param request UpdateInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateInstanceResponse
 */
func (client *Client) UpdateInstanceWithOptions(request *UpdateInstanceRequest, runtime *util.RuntimeOptions) (_result *UpdateInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DataLinkName)) {
		query["DataLinkName"] = request.DataLinkName
	}

	if !tea.BoolValue(util.IsUnset(request.DatabasePassword)) {
		query["DatabasePassword"] = request.DatabasePassword
	}

	if !tea.BoolValue(util.IsUnset(request.DatabaseUser)) {
		query["DatabaseUser"] = request.DatabaseUser
	}

	if !tea.BoolValue(util.IsUnset(request.DbaId)) {
		query["DbaId"] = request.DbaId
	}

	if !tea.BoolValue(util.IsUnset(request.DdlOnline)) {
		query["DdlOnline"] = request.DdlOnline
	}

	if !tea.BoolValue(util.IsUnset(request.EcsInstanceId)) {
		query["EcsInstanceId"] = request.EcsInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.EcsRegion)) {
		query["EcsRegion"] = request.EcsRegion
	}

	if !tea.BoolValue(util.IsUnset(request.EnableSellSitd)) {
		query["EnableSellSitd"] = request.EnableSellSitd
	}

	if !tea.BoolValue(util.IsUnset(request.EnvType)) {
		query["EnvType"] = request.EnvType
	}

	if !tea.BoolValue(util.IsUnset(request.ExportTimeout)) {
		query["ExportTimeout"] = request.ExportTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.Host)) {
		query["Host"] = request.Host
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceAlias)) {
		query["InstanceAlias"] = request.InstanceAlias
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceSource)) {
		query["InstanceSource"] = request.InstanceSource
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceType)) {
		query["InstanceType"] = request.InstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.Port)) {
		query["Port"] = request.Port
	}

	if !tea.BoolValue(util.IsUnset(request.QueryTimeout)) {
		query["QueryTimeout"] = request.QueryTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.SafeRuleId)) {
		query["SafeRuleId"] = request.SafeRuleId
	}

	if !tea.BoolValue(util.IsUnset(request.Sid)) {
		query["Sid"] = request.Sid
	}

	if !tea.BoolValue(util.IsUnset(request.SkipTest)) {
		query["SkipTest"] = request.SkipTest
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		query["TemplateId"] = request.TemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateType)) {
		query["TemplateType"] = request.TemplateType
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.UseDsql)) {
		query["UseDsql"] = request.UseDsql
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateInstance"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call the UpdateInstance operation, call the [GetInstance](~~141567~~) or [ListInstances](~~141936~~) operation to obtain the complete information about the instance.
 *
 * @param request UpdateInstanceRequest
 * @return UpdateInstanceResponse
 */
func (client *Client) UpdateInstance(request *UpdateInstanceRequest) (_result *UpdateInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateInstanceResponse{}
	_body, _err := client.UpdateInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * SLA rules take effect after task flows are deployed and published.
 *
 * @param tmpReq UpdateSLARulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateSLARulesResponse
 */
func (client *Client) UpdateSLARulesWithOptions(tmpReq *UpdateSLARulesRequest, runtime *util.RuntimeOptions) (_result *UpdateSLARulesResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateSLARulesShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.SlaRuleList)) {
		request.SlaRuleListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.SlaRuleList, tea.String("SlaRuleList"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.SlaRuleListShrink)) {
		query["SlaRuleList"] = request.SlaRuleListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateSLARules"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateSLARulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * SLA rules take effect after task flows are deployed and published.
 *
 * @param request UpdateSLARulesRequest
 * @return UpdateSLARulesResponse
 */
func (client *Client) UpdateSLARules(request *UpdateSLARulesRequest) (_result *UpdateSLARulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateSLARulesResponse{}
	_body, _err := client.UpdateSLARulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateScenarioWithOptions(request *UpdateScenarioRequest, runtime *util.RuntimeOptions) (_result *UpdateScenarioResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.ScenarioId)) {
		query["ScenarioId"] = request.ScenarioId
	}

	if !tea.BoolValue(util.IsUnset(request.ScenarioName)) {
		query["ScenarioName"] = request.ScenarioName
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateScenario"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateScenarioResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateScenario(request *UpdateScenarioRequest) (_result *UpdateScenarioResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateScenarioResponse{}
	_body, _err := client.UpdateScenarioWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateStandardGroupWithOptions(request *UpdateStandardGroupRequest, runtime *util.RuntimeOptions) (_result *UpdateStandardGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateStandardGroup"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateStandardGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateStandardGroup(request *UpdateStandardGroupRequest) (_result *UpdateStandardGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateStandardGroupResponse{}
	_body, _err := client.UpdateStandardGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to configure a failed task or rerun a task.
 *
 * @param request UpdateTaskConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTaskConfigResponse
 */
func (client *Client) UpdateTaskConfigWithOptions(request *UpdateTaskConfigRequest, runtime *util.RuntimeOptions) (_result *UpdateTaskConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NodeConfig)) {
		query["NodeConfig"] = request.NodeConfig
	}

	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		query["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTaskConfig"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTaskConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to configure a failed task or rerun a task.
 *
 * @param request UpdateTaskConfigRequest
 * @return UpdateTaskConfigResponse
 */
func (client *Client) UpdateTaskConfig(request *UpdateTaskConfigRequest) (_result *UpdateTaskConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTaskConfigResponse{}
	_body, _err := client.UpdateTaskConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to modify node configurations.
 *
 * @param request UpdateTaskContentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTaskContentResponse
 */
func (client *Client) UpdateTaskContentWithOptions(request *UpdateTaskContentRequest, runtime *util.RuntimeOptions) (_result *UpdateTaskContentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NodeContent)) {
		query["NodeContent"] = request.NodeContent
	}

	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		query["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTaskContent"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTaskContentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to modify node configurations.
 *
 * @param request UpdateTaskContentRequest
 * @return UpdateTaskContentResponse
 */
func (client *Client) UpdateTaskContent(request *UpdateTaskContentRequest) (_result *UpdateTaskContentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTaskContentResponse{}
	_body, _err := client.UpdateTaskContentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateTaskFlowConstantsWithOptions(tmpReq *UpdateTaskFlowConstantsRequest, runtime *util.RuntimeOptions) (_result *UpdateTaskFlowConstantsResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateTaskFlowConstantsShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.DagConstants)) {
		request.DagConstantsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.DagConstants, tea.String("DagConstants"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagConstantsShrink)) {
		query["DagConstants"] = request.DagConstantsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTaskFlowConstants"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTaskFlowConstantsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateTaskFlowConstants(request *UpdateTaskFlowConstantsRequest) (_result *UpdateTaskFlowConstantsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTaskFlowConstantsResponse{}
	_body, _err := client.UpdateTaskFlowConstantsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateTaskFlowCooperatorsWithOptions(tmpReq *UpdateTaskFlowCooperatorsRequest, runtime *util.RuntimeOptions) (_result *UpdateTaskFlowCooperatorsResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateTaskFlowCooperatorsShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.CooperatorIds)) {
		request.CooperatorIdsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.CooperatorIds, tea.String("CooperatorIds"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CooperatorIdsShrink)) {
		query["CooperatorIds"] = request.CooperatorIdsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTaskFlowCooperators"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTaskFlowCooperatorsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateTaskFlowCooperators(request *UpdateTaskFlowCooperatorsRequest) (_result *UpdateTaskFlowCooperatorsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTaskFlowCooperatorsResponse{}
	_body, _err := client.UpdateTaskFlowCooperatorsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ###
 * The edges can be updated only when the following conditions are met:
 * 1.  The specified edge exists in the directed acyclic graph (DAG) of the task flow specified by DagId.
 * 2.  The specified edge nodes exist in the DAG of the task flow specified by DagId.
 * 3.  After the update, rings do not exist in the DAG.
 *
 * @param tmpReq UpdateTaskFlowEdgesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTaskFlowEdgesResponse
 */
func (client *Client) UpdateTaskFlowEdgesWithOptions(tmpReq *UpdateTaskFlowEdgesRequest, runtime *util.RuntimeOptions) (_result *UpdateTaskFlowEdgesResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateTaskFlowEdgesShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Edges)) {
		request.EdgesShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Edges, tea.String("Edges"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.EdgesShrink)) {
		query["Edges"] = request.EdgesShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTaskFlowEdges"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTaskFlowEdgesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ###
 * The edges can be updated only when the following conditions are met:
 * 1.  The specified edge exists in the directed acyclic graph (DAG) of the task flow specified by DagId.
 * 2.  The specified edge nodes exist in the DAG of the task flow specified by DagId.
 * 3.  After the update, rings do not exist in the DAG.
 *
 * @param request UpdateTaskFlowEdgesRequest
 * @return UpdateTaskFlowEdgesResponse
 */
func (client *Client) UpdateTaskFlowEdges(request *UpdateTaskFlowEdgesRequest) (_result *UpdateTaskFlowEdgesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTaskFlowEdgesResponse{}
	_body, _err := client.UpdateTaskFlowEdgesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateTaskFlowNameAndDescWithOptions(request *UpdateTaskFlowNameAndDescRequest, runtime *util.RuntimeOptions) (_result *UpdateTaskFlowNameAndDescResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.DagName)) {
		query["DagName"] = request.DagName
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTaskFlowNameAndDesc"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTaskFlowNameAndDescResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateTaskFlowNameAndDesc(request *UpdateTaskFlowNameAndDescRequest) (_result *UpdateTaskFlowNameAndDescResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTaskFlowNameAndDescResponse{}
	_body, _err := client.UpdateTaskFlowNameAndDescWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateTaskFlowNotificationWithOptions(request *UpdateTaskFlowNotificationRequest, runtime *util.RuntimeOptions) (_result *UpdateTaskFlowNotificationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.DagNotificationFail)) {
		query["DagNotificationFail"] = request.DagNotificationFail
	}

	if !tea.BoolValue(util.IsUnset(request.DagNotificationSla)) {
		query["DagNotificationSla"] = request.DagNotificationSla
	}

	if !tea.BoolValue(util.IsUnset(request.DagNotificationSuccess)) {
		query["DagNotificationSuccess"] = request.DagNotificationSuccess
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTaskFlowNotification"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTaskFlowNotificationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateTaskFlowNotification(request *UpdateTaskFlowNotificationRequest) (_result *UpdateTaskFlowNotificationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTaskFlowNotificationResponse{}
	_body, _err := client.UpdateTaskFlowNotificationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Note: The new owner of the task flow must belong to the same tenant as the previous owner.
 *
 * @param request UpdateTaskFlowOwnerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTaskFlowOwnerResponse
 */
func (client *Client) UpdateTaskFlowOwnerWithOptions(request *UpdateTaskFlowOwnerRequest, runtime *util.RuntimeOptions) (_result *UpdateTaskFlowOwnerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.NewOwnerId)) {
		query["NewOwnerId"] = request.NewOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTaskFlowOwner"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTaskFlowOwnerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Note: The new owner of the task flow must belong to the same tenant as the previous owner.
 *
 * @param request UpdateTaskFlowOwnerRequest
 * @return UpdateTaskFlowOwnerResponse
 */
func (client *Client) UpdateTaskFlowOwner(request *UpdateTaskFlowOwnerRequest) (_result *UpdateTaskFlowOwnerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTaskFlowOwnerResponse{}
	_body, _err := client.UpdateTaskFlowOwnerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to perform a full update. For incremental updates, see AddTaskFlowEdges, UpdateTaskFlowEdges, and DeleteTaskFlowEdgesByMultiCondition.
 *
 * @param tmpReq UpdateTaskFlowRelationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTaskFlowRelationsResponse
 */
func (client *Client) UpdateTaskFlowRelationsWithOptions(tmpReq *UpdateTaskFlowRelationsRequest, runtime *util.RuntimeOptions) (_result *UpdateTaskFlowRelationsResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateTaskFlowRelationsShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Edges)) {
		request.EdgesShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Edges, tea.String("Edges"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.EdgesShrink)) {
		query["Edges"] = request.EdgesShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTaskFlowRelations"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTaskFlowRelationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to perform a full update. For incremental updates, see AddTaskFlowEdges, UpdateTaskFlowEdges, and DeleteTaskFlowEdgesByMultiCondition.
 *
 * @param request UpdateTaskFlowRelationsRequest
 * @return UpdateTaskFlowRelationsResponse
 */
func (client *Client) UpdateTaskFlowRelations(request *UpdateTaskFlowRelationsRequest) (_result *UpdateTaskFlowRelationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTaskFlowRelationsResponse{}
	_body, _err := client.UpdateTaskFlowRelationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to update the scheduling properties for a task flow in the editing state. You can configure a **timed scheduling** task flow or an **event scheduling** task flow. When you configure a **timed scheduling** task flow, you can choose from one-time scheduling or periodic scheduling. When you configure an **event scheduling** task flow, you can subscribe to task flows or task flow nodes.****\\
 * After you update the scheduling properties, you need to publish and deploy the task flow again. The new task flow instance will run based on the updated scheduling properties.
 *
 * @param request UpdateTaskFlowScheduleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTaskFlowScheduleResponse
 */
func (client *Client) UpdateTaskFlowScheduleWithOptions(request *UpdateTaskFlowScheduleRequest, runtime *util.RuntimeOptions) (_result *UpdateTaskFlowScheduleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CronBeginDate)) {
		query["CronBeginDate"] = request.CronBeginDate
	}

	if !tea.BoolValue(util.IsUnset(request.CronEndDate)) {
		query["CronEndDate"] = request.CronEndDate
	}

	if !tea.BoolValue(util.IsUnset(request.CronStr)) {
		query["CronStr"] = request.CronStr
	}

	if !tea.BoolValue(util.IsUnset(request.CronType)) {
		query["CronType"] = request.CronType
	}

	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduleParam)) {
		query["ScheduleParam"] = request.ScheduleParam
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduleSwitch)) {
		query["ScheduleSwitch"] = request.ScheduleSwitch
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.TimeZoneId)) {
		query["TimeZoneId"] = request.TimeZoneId
	}

	if !tea.BoolValue(util.IsUnset(request.TriggerType)) {
		query["TriggerType"] = request.TriggerType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTaskFlowSchedule"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTaskFlowScheduleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to update the scheduling properties for a task flow in the editing state. You can configure a **timed scheduling** task flow or an **event scheduling** task flow. When you configure a **timed scheduling** task flow, you can choose from one-time scheduling or periodic scheduling. When you configure an **event scheduling** task flow, you can subscribe to task flows or task flow nodes.****\\
 * After you update the scheduling properties, you need to publish and deploy the task flow again. The new task flow instance will run based on the updated scheduling properties.
 *
 * @param request UpdateTaskFlowScheduleRequest
 * @return UpdateTaskFlowScheduleResponse
 */
func (client *Client) UpdateTaskFlowSchedule(request *UpdateTaskFlowScheduleRequest) (_result *UpdateTaskFlowScheduleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTaskFlowScheduleResponse{}
	_body, _err := client.UpdateTaskFlowScheduleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateTaskFlowTimeVariablesWithOptions(request *UpdateTaskFlowTimeVariablesRequest, runtime *util.RuntimeOptions) (_result *UpdateTaskFlowTimeVariablesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		query["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.TimeVariables)) {
		query["TimeVariables"] = request.TimeVariables
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTaskFlowTimeVariables"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTaskFlowTimeVariablesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateTaskFlowTimeVariables(request *UpdateTaskFlowTimeVariablesRequest) (_result *UpdateTaskFlowTimeVariablesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTaskFlowTimeVariablesResponse{}
	_body, _err := client.UpdateTaskFlowTimeVariablesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateTaskNameWithOptions(request *UpdateTaskNameRequest, runtime *util.RuntimeOptions) (_result *UpdateTaskNameResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		query["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.NodeName)) {
		query["NodeName"] = request.NodeName
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTaskName"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTaskNameResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateTaskName(request *UpdateTaskNameRequest) (_result *UpdateTaskNameResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTaskNameResponse{}
	_body, _err := client.UpdateTaskNameWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Only nodes of single-instance SQL assignment, script code, and ECS remote command have output variables.
 *
 * @param request UpdateTaskOutputRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTaskOutputResponse
 */
func (client *Client) UpdateTaskOutputWithOptions(request *UpdateTaskOutputRequest, runtime *util.RuntimeOptions) (_result *UpdateTaskOutputResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		query["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.NodeOutput)) {
		query["NodeOutput"] = request.NodeOutput
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTaskOutput"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTaskOutputResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Only nodes of single-instance SQL assignment, script code, and ECS remote command have output variables.
 *
 * @param request UpdateTaskOutputRequest
 * @return UpdateTaskOutputResponse
 */
func (client *Client) UpdateTaskOutput(request *UpdateTaskOutputRequest) (_result *UpdateTaskOutputResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTaskOutputResponse{}
	_body, _err := client.UpdateTaskOutputWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateTaskTimeVariablesWithOptions(request *UpdateTaskTimeVariablesRequest, runtime *util.RuntimeOptions) (_result *UpdateTaskTimeVariablesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		query["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.TimeVariables)) {
		query["TimeVariables"] = request.TimeVariables
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTaskTimeVariables"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTaskTimeVariablesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateTaskTimeVariables(request *UpdateTaskTimeVariablesRequest) (_result *UpdateTaskTimeVariablesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTaskTimeVariablesResponse{}
	_body, _err := client.UpdateTaskTimeVariablesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateUserWithOptions(request *UpdateUserRequest, runtime *util.RuntimeOptions) (_result *UpdateUserResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaxExecuteCount)) {
		query["MaxExecuteCount"] = request.MaxExecuteCount
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResultCount)) {
		query["MaxResultCount"] = request.MaxResultCount
	}

	if !tea.BoolValue(util.IsUnset(request.Mobile)) {
		query["Mobile"] = request.Mobile
	}

	if !tea.BoolValue(util.IsUnset(request.RoleNames)) {
		query["RoleNames"] = request.RoleNames
	}

	if !tea.BoolValue(util.IsUnset(request.Tid)) {
		query["Tid"] = request.Tid
	}

	if !tea.BoolValue(util.IsUnset(request.Uid)) {
		query["Uid"] = request.Uid
	}

	if !tea.BoolValue(util.IsUnset(request.UserNick)) {
		query["UserNick"] = request.UserNick
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateUser"),
		Version:     tea.String("2018-11-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateUserResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateUser(request *UpdateUserRequest) (_result *UpdateUserResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateUserResponse{}
	_body, _err := client.UpdateUserWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}
