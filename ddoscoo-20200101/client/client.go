// This file is auto-generated, don't edit it. Thanks.
/**
 *
 */
package client

import (
	openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
	endpointutil "github.com/alibabacloud-go/endpoint-util/service"
	openapiutil "github.com/alibabacloud-go/openapi-util/service"
	util "github.com/alibabacloud-go/tea-utils/v2/service"
	"github.com/alibabacloud-go/tea/tea"
)

type AddAutoCcBlacklistRequest struct {
	Blacklist  *string `json:"Blacklist,omitempty" xml:"Blacklist,omitempty"`
	ExpireTime *int32  `json:"ExpireTime,omitempty" xml:"ExpireTime,omitempty"`
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s AddAutoCcBlacklistRequest) String() string {
	return tea.Prettify(s)
}

func (s AddAutoCcBlacklistRequest) GoString() string {
	return s.String()
}

func (s *AddAutoCcBlacklistRequest) SetBlacklist(v string) *AddAutoCcBlacklistRequest {
	s.Blacklist = &v
	return s
}

func (s *AddAutoCcBlacklistRequest) SetExpireTime(v int32) *AddAutoCcBlacklistRequest {
	s.ExpireTime = &v
	return s
}

func (s *AddAutoCcBlacklistRequest) SetInstanceId(v string) *AddAutoCcBlacklistRequest {
	s.InstanceId = &v
	return s
}

type AddAutoCcBlacklistResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddAutoCcBlacklistResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddAutoCcBlacklistResponseBody) GoString() string {
	return s.String()
}

func (s *AddAutoCcBlacklistResponseBody) SetRequestId(v string) *AddAutoCcBlacklistResponseBody {
	s.RequestId = &v
	return s
}

type AddAutoCcBlacklistResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *AddAutoCcBlacklistResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AddAutoCcBlacklistResponse) String() string {
	return tea.Prettify(s)
}

func (s AddAutoCcBlacklistResponse) GoString() string {
	return s.String()
}

func (s *AddAutoCcBlacklistResponse) SetHeaders(v map[string]*string) *AddAutoCcBlacklistResponse {
	s.Headers = v
	return s
}

func (s *AddAutoCcBlacklistResponse) SetStatusCode(v int32) *AddAutoCcBlacklistResponse {
	s.StatusCode = &v
	return s
}

func (s *AddAutoCcBlacklistResponse) SetBody(v *AddAutoCcBlacklistResponseBody) *AddAutoCcBlacklistResponse {
	s.Body = v
	return s
}

type AddAutoCcWhitelistRequest struct {
	// This parameter is deprecated.
	//
	// > This parameter indicates the validity period of the IP address blacklist. By default, the traffic from the IP addresses that you add to the whitelist is always allowed. You do not need to set this parameter.
	ExpireTime *int32 `json:"ExpireTime,omitempty" xml:"ExpireTime,omitempty"`
	// The ID of the instance.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The configuration of the IP addresses that you want to add to the whitelist. The value is a string that consists of JSON arrays. Each element in a JSON array is a JSON struct that contains the following fields:
	//
	// *   **src**: the IP address that you want to add. This parameter is required. Data type: string.
	Whitelist *string `json:"Whitelist,omitempty" xml:"Whitelist,omitempty"`
}

func (s AddAutoCcWhitelistRequest) String() string {
	return tea.Prettify(s)
}

func (s AddAutoCcWhitelistRequest) GoString() string {
	return s.String()
}

func (s *AddAutoCcWhitelistRequest) SetExpireTime(v int32) *AddAutoCcWhitelistRequest {
	s.ExpireTime = &v
	return s
}

func (s *AddAutoCcWhitelistRequest) SetInstanceId(v string) *AddAutoCcWhitelistRequest {
	s.InstanceId = &v
	return s
}

func (s *AddAutoCcWhitelistRequest) SetWhitelist(v string) *AddAutoCcWhitelistRequest {
	s.Whitelist = &v
	return s
}

type AddAutoCcWhitelistResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddAutoCcWhitelistResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddAutoCcWhitelistResponseBody) GoString() string {
	return s.String()
}

func (s *AddAutoCcWhitelistResponseBody) SetRequestId(v string) *AddAutoCcWhitelistResponseBody {
	s.RequestId = &v
	return s
}

type AddAutoCcWhitelistResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *AddAutoCcWhitelistResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AddAutoCcWhitelistResponse) String() string {
	return tea.Prettify(s)
}

func (s AddAutoCcWhitelistResponse) GoString() string {
	return s.String()
}

func (s *AddAutoCcWhitelistResponse) SetHeaders(v map[string]*string) *AddAutoCcWhitelistResponse {
	s.Headers = v
	return s
}

func (s *AddAutoCcWhitelistResponse) SetStatusCode(v int32) *AddAutoCcWhitelistResponse {
	s.StatusCode = &v
	return s
}

func (s *AddAutoCcWhitelistResponse) SetBody(v *AddAutoCcWhitelistResponseBody) *AddAutoCcWhitelistResponse {
	s.Body = v
	return s
}

type AssociateWebCertRequest struct {
	// The public key of the certificate that you want to associate. This parameter must be used together with **CertName** and **Key**.
	//
	// > If you specify **CertName**, **Cert**, and **Key**, you do not need to specify **CertId**.
	Cert *string `json:"Cert,omitempty" xml:"Cert,omitempty"`
	// The ID of the certificate that you want to associate. If the certificate that you want to associate has been issued in Certificate Management Service, you can specify the certificate ID to associate the certificate.
	//
	// > If you specify the certificate ID, you do not need to specify a value for the **CertName**, **Cert**, and **Key** parameters.
	CertId         *int32  `json:"CertId,omitempty" xml:"CertId,omitempty"`
	CertIdentifier *string `json:"CertIdentifier,omitempty" xml:"CertIdentifier,omitempty"`
	// The name of the certificate that you want to associate. This parameter must be used together with the **Cert** and **Key** parameters.
	//
	// > If you specify a value for the **CertName**, **Cert**, and **Key** parameters, you do not need to specify a value for the **CertId** parameter.
	CertName   *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	CertRegion *string `json:"CertRegion,omitempty" xml:"CertRegion,omitempty"`
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The private key of the certificate that you want to associate. This parameter must be used together with **CertName** and **Cert**.
	//
	// > If you specify **CertName**, **Cert**, and **Key**, you do not need to specify **CertId**.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s AssociateWebCertRequest) String() string {
	return tea.Prettify(s)
}

func (s AssociateWebCertRequest) GoString() string {
	return s.String()
}

func (s *AssociateWebCertRequest) SetCert(v string) *AssociateWebCertRequest {
	s.Cert = &v
	return s
}

func (s *AssociateWebCertRequest) SetCertId(v int32) *AssociateWebCertRequest {
	s.CertId = &v
	return s
}

func (s *AssociateWebCertRequest) SetCertIdentifier(v string) *AssociateWebCertRequest {
	s.CertIdentifier = &v
	return s
}

func (s *AssociateWebCertRequest) SetCertName(v string) *AssociateWebCertRequest {
	s.CertName = &v
	return s
}

func (s *AssociateWebCertRequest) SetCertRegion(v string) *AssociateWebCertRequest {
	s.CertRegion = &v
	return s
}

func (s *AssociateWebCertRequest) SetDomain(v string) *AssociateWebCertRequest {
	s.Domain = &v
	return s
}

func (s *AssociateWebCertRequest) SetKey(v string) *AssociateWebCertRequest {
	s.Key = &v
	return s
}

func (s *AssociateWebCertRequest) SetResourceGroupId(v string) *AssociateWebCertRequest {
	s.ResourceGroupId = &v
	return s
}

type AssociateWebCertResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AssociateWebCertResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AssociateWebCertResponseBody) GoString() string {
	return s.String()
}

func (s *AssociateWebCertResponseBody) SetRequestId(v string) *AssociateWebCertResponseBody {
	s.RequestId = &v
	return s
}

type AssociateWebCertResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *AssociateWebCertResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AssociateWebCertResponse) String() string {
	return tea.Prettify(s)
}

func (s AssociateWebCertResponse) GoString() string {
	return s.String()
}

func (s *AssociateWebCertResponse) SetHeaders(v map[string]*string) *AssociateWebCertResponse {
	s.Headers = v
	return s
}

func (s *AssociateWebCertResponse) SetStatusCode(v int32) *AssociateWebCertResponse {
	s.StatusCode = &v
	return s
}

func (s *AssociateWebCertResponse) SetBody(v *AssociateWebCertResponseBody) *AssociateWebCertResponse {
	s.Body = v
	return s
}

type AttachSceneDefenseObjectRequest struct {
	// The type of the object. Set the value to **Domain**, which indicates a domain name.
	ObjectType *string `json:"ObjectType,omitempty" xml:"ObjectType,omitempty"`
	// The object that you want to add to the policy. Separate multiple objects with commas (,).
	Objects *string `json:"Objects,omitempty" xml:"Objects,omitempty"`
	// The ID of the policy.
	//
	// > You can call the [DescribeSceneDefensePolicies](~~159382~~) operation to query the IDs of all policies.
	PolicyId *string `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
}

func (s AttachSceneDefenseObjectRequest) String() string {
	return tea.Prettify(s)
}

func (s AttachSceneDefenseObjectRequest) GoString() string {
	return s.String()
}

func (s *AttachSceneDefenseObjectRequest) SetObjectType(v string) *AttachSceneDefenseObjectRequest {
	s.ObjectType = &v
	return s
}

func (s *AttachSceneDefenseObjectRequest) SetObjects(v string) *AttachSceneDefenseObjectRequest {
	s.Objects = &v
	return s
}

func (s *AttachSceneDefenseObjectRequest) SetPolicyId(v string) *AttachSceneDefenseObjectRequest {
	s.PolicyId = &v
	return s
}

type AttachSceneDefenseObjectResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AttachSceneDefenseObjectResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AttachSceneDefenseObjectResponseBody) GoString() string {
	return s.String()
}

func (s *AttachSceneDefenseObjectResponseBody) SetRequestId(v string) *AttachSceneDefenseObjectResponseBody {
	s.RequestId = &v
	return s
}

func (s *AttachSceneDefenseObjectResponseBody) SetSuccess(v bool) *AttachSceneDefenseObjectResponseBody {
	s.Success = &v
	return s
}

type AttachSceneDefenseObjectResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *AttachSceneDefenseObjectResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AttachSceneDefenseObjectResponse) String() string {
	return tea.Prettify(s)
}

func (s AttachSceneDefenseObjectResponse) GoString() string {
	return s.String()
}

func (s *AttachSceneDefenseObjectResponse) SetHeaders(v map[string]*string) *AttachSceneDefenseObjectResponse {
	s.Headers = v
	return s
}

func (s *AttachSceneDefenseObjectResponse) SetStatusCode(v int32) *AttachSceneDefenseObjectResponse {
	s.StatusCode = &v
	return s
}

func (s *AttachSceneDefenseObjectResponse) SetBody(v *AttachSceneDefenseObjectResponseBody) *AttachSceneDefenseObjectResponse {
	s.Body = v
	return s
}

type ConfigL7RsPolicyRequest struct {
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query the domain names for which forwarding rules are configured.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The back-to-origin policy. The value is a string that consists of a JSON struct. The JSON struct contains the following fields:
	//
	// *   **ProxyMode**: The load balancing algorithm for back-to-origin traffic. This field is required and must be a string. Valid values:
	//
	//     *   **ip_hash**: the IP hash algorithm. This algorithm is used to redirect the requests from the same IP address to the same origin server.
	//     *   **rr**: the round-robin algorithm. This algorithm is used to redirect requests to origin servers in turn. If you use this algorithm, you can specify a weight for each server based on server performance.
	//     *   **least_time**: the least response time algorithm. This algorithm is used to minimize the latency when requests are forwarded from Anti-DDoS Pro or Anti-DDoS Premium instances to origin servers based on the intelligent DNS resolution feature.
	//
	// *   **Attributes**: the parameters for back-to-origin. This field is optional and must be a JSON array. Each element in the array contains the following fields:
	//
	//     *   **RealServer**: the address of the origin server. This field is optional and must be a string.
	//
	//     *   **Attribute**: the parameter for back-to-origin. This field is optional and must be a JSON object. The value contains the following field:
	//
	//         *   **Weight**: the weight of the server. This field is optional and must be an integer. This field takes effect only when **ProxyMode** is set to **rr**. Valid values: **1** to **100**. Default value: **100**. An origin server with a higher weight receives more requests.
	Policy *string `json:"Policy,omitempty" xml:"Policy,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	//
	// For more information about resource groups, see [Create a resource group](~~94485~~).
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s ConfigL7RsPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s ConfigL7RsPolicyRequest) GoString() string {
	return s.String()
}

func (s *ConfigL7RsPolicyRequest) SetDomain(v string) *ConfigL7RsPolicyRequest {
	s.Domain = &v
	return s
}

func (s *ConfigL7RsPolicyRequest) SetPolicy(v string) *ConfigL7RsPolicyRequest {
	s.Policy = &v
	return s
}

func (s *ConfigL7RsPolicyRequest) SetResourceGroupId(v string) *ConfigL7RsPolicyRequest {
	s.ResourceGroupId = &v
	return s
}

type ConfigL7RsPolicyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ConfigL7RsPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ConfigL7RsPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *ConfigL7RsPolicyResponseBody) SetRequestId(v string) *ConfigL7RsPolicyResponseBody {
	s.RequestId = &v
	return s
}

type ConfigL7RsPolicyResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ConfigL7RsPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ConfigL7RsPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s ConfigL7RsPolicyResponse) GoString() string {
	return s.String()
}

func (s *ConfigL7RsPolicyResponse) SetHeaders(v map[string]*string) *ConfigL7RsPolicyResponse {
	s.Headers = v
	return s
}

func (s *ConfigL7RsPolicyResponse) SetStatusCode(v int32) *ConfigL7RsPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *ConfigL7RsPolicyResponse) SetBody(v *ConfigL7RsPolicyResponseBody) *ConfigL7RsPolicyResponse {
	s.Body = v
	return s
}

type ConfigLayer4RealLimitRequest struct {
	// The ID of the Anti-DDoS Pro or Anti-DDoS Premium instance.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// Specifies the threshold of the clean bandwidth. Valid values: 0 to 15360. The value 0 indicates that rate limiting is never triggered. Unit: Mbit/s
	LimitValue *int64 `json:"LimitValue,omitempty" xml:"LimitValue,omitempty"`
}

func (s ConfigLayer4RealLimitRequest) String() string {
	return tea.Prettify(s)
}

func (s ConfigLayer4RealLimitRequest) GoString() string {
	return s.String()
}

func (s *ConfigLayer4RealLimitRequest) SetInstanceId(v string) *ConfigLayer4RealLimitRequest {
	s.InstanceId = &v
	return s
}

func (s *ConfigLayer4RealLimitRequest) SetLimitValue(v int64) *ConfigLayer4RealLimitRequest {
	s.LimitValue = &v
	return s
}

type ConfigLayer4RealLimitResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ConfigLayer4RealLimitResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ConfigLayer4RealLimitResponseBody) GoString() string {
	return s.String()
}

func (s *ConfigLayer4RealLimitResponseBody) SetRequestId(v string) *ConfigLayer4RealLimitResponseBody {
	s.RequestId = &v
	return s
}

type ConfigLayer4RealLimitResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ConfigLayer4RealLimitResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ConfigLayer4RealLimitResponse) String() string {
	return tea.Prettify(s)
}

func (s ConfigLayer4RealLimitResponse) GoString() string {
	return s.String()
}

func (s *ConfigLayer4RealLimitResponse) SetHeaders(v map[string]*string) *ConfigLayer4RealLimitResponse {
	s.Headers = v
	return s
}

func (s *ConfigLayer4RealLimitResponse) SetStatusCode(v int32) *ConfigLayer4RealLimitResponse {
	s.StatusCode = &v
	return s
}

func (s *ConfigLayer4RealLimitResponse) SetBody(v *ConfigLayer4RealLimitResponseBody) *ConfigLayer4RealLimitResponse {
	s.Body = v
	return s
}

type ConfigLayer4RemarkRequest struct {
	// The port forwarding rule that you want to manage.
	//
	// This parameter is a string that consists of JSON arrays. Each element in a JSON array indicates a port forwarding rule. You can perform this operation only on one port forwarding rule at a time.
	//
	// > You can call the [DescribeNetworkRules](~~157484~~) to query existing port forwarding rules.
	//
	// Each port forwarding rule contains the following fields:
	//
	// *   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
	// *   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
	// *   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.
	// *   **Remark**: the remarks of the port forwarding rule. This field is required and must be of the STRING type. The value can contain letters, digits, and some special characters, such as `, . + - * / _`. The value can be up to 200 characters in length.
	Listeners *string `json:"Listeners,omitempty" xml:"Listeners,omitempty"`
}

func (s ConfigLayer4RemarkRequest) String() string {
	return tea.Prettify(s)
}

func (s ConfigLayer4RemarkRequest) GoString() string {
	return s.String()
}

func (s *ConfigLayer4RemarkRequest) SetListeners(v string) *ConfigLayer4RemarkRequest {
	s.Listeners = &v
	return s
}

type ConfigLayer4RemarkResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ConfigLayer4RemarkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ConfigLayer4RemarkResponseBody) GoString() string {
	return s.String()
}

func (s *ConfigLayer4RemarkResponseBody) SetRequestId(v string) *ConfigLayer4RemarkResponseBody {
	s.RequestId = &v
	return s
}

type ConfigLayer4RemarkResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ConfigLayer4RemarkResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ConfigLayer4RemarkResponse) String() string {
	return tea.Prettify(s)
}

func (s ConfigLayer4RemarkResponse) GoString() string {
	return s.String()
}

func (s *ConfigLayer4RemarkResponse) SetHeaders(v map[string]*string) *ConfigLayer4RemarkResponse {
	s.Headers = v
	return s
}

func (s *ConfigLayer4RemarkResponse) SetStatusCode(v int32) *ConfigLayer4RemarkResponse {
	s.StatusCode = &v
	return s
}

func (s *ConfigLayer4RemarkResponse) SetBody(v *ConfigLayer4RemarkResponseBody) *ConfigLayer4RemarkResponse {
	s.Body = v
	return s
}

type ConfigLayer4RuleBakModeRequest struct {
	// The mode that you want to use to forward service traffic. Valid values:
	//
	// *   **0**: the default mode. In this mode, Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the origin IP address that you specified when you created the port forwarding rule. You can call the [CreateNetworkRules](~~157482~~) operation to create a port forwarding rule.
	// *   **1**: the origin redundancy mode. In this mode, Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the primary or secondary origin servers. You can call the [ConfigLayer4RulePolicy](~~312684~~) operation to configure IP addresses.
	BakMode *string `json:"BakMode,omitempty" xml:"BakMode,omitempty"`
	// The port forwarding rule that you want to manage.
	//
	// This parameter is a string that consists of JSON arrays. Each element in a JSON array indicates a port forwarding rule. You can perform this operation only on one port forwarding rule at a time.
	//
	// > You can call the [DescribeNetworkRules](~~157484~~) to query existing port forwarding rules.
	//
	// Each port forwarding rule contains the following fields:
	//
	// *   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
	// *   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
	// *   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.
	Listeners *string `json:"Listeners,omitempty" xml:"Listeners,omitempty"`
}

func (s ConfigLayer4RuleBakModeRequest) String() string {
	return tea.Prettify(s)
}

func (s ConfigLayer4RuleBakModeRequest) GoString() string {
	return s.String()
}

func (s *ConfigLayer4RuleBakModeRequest) SetBakMode(v string) *ConfigLayer4RuleBakModeRequest {
	s.BakMode = &v
	return s
}

func (s *ConfigLayer4RuleBakModeRequest) SetListeners(v string) *ConfigLayer4RuleBakModeRequest {
	s.Listeners = &v
	return s
}

type ConfigLayer4RuleBakModeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ConfigLayer4RuleBakModeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ConfigLayer4RuleBakModeResponseBody) GoString() string {
	return s.String()
}

func (s *ConfigLayer4RuleBakModeResponseBody) SetRequestId(v string) *ConfigLayer4RuleBakModeResponseBody {
	s.RequestId = &v
	return s
}

type ConfigLayer4RuleBakModeResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ConfigLayer4RuleBakModeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ConfigLayer4RuleBakModeResponse) String() string {
	return tea.Prettify(s)
}

func (s ConfigLayer4RuleBakModeResponse) GoString() string {
	return s.String()
}

func (s *ConfigLayer4RuleBakModeResponse) SetHeaders(v map[string]*string) *ConfigLayer4RuleBakModeResponse {
	s.Headers = v
	return s
}

func (s *ConfigLayer4RuleBakModeResponse) SetStatusCode(v int32) *ConfigLayer4RuleBakModeResponse {
	s.StatusCode = &v
	return s
}

func (s *ConfigLayer4RuleBakModeResponse) SetBody(v *ConfigLayer4RuleBakModeResponseBody) *ConfigLayer4RuleBakModeResponse {
	s.Body = v
	return s
}

type ConfigLayer4RulePolicyRequest struct {
	// The port forwarding rule that you want to manage.
	//
	// This parameter is a string that consists of JSON arrays. Each element in a JSON array indicates a port forwarding rule. You can perform this operation only on one port forwarding rule at a time.
	//
	// > You can call the [DescribeNetworkRules](~~157484~~) to query existing port forwarding rules.
	//
	// Each port forwarding rule contains the following fields:
	//
	// *   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
	//
	// *   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
	//
	// *   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.
	//
	// *   **BackendPort**: the port of the origin server. This field is required and must be of the INTEGER type.
	//
	// *   **PriRealServers**: the IP addresses of the primary origin server. This field is required and must be a JSON array. Each element in a JSON array indicates an IP address of the primary origin server. You can configure a maximum of 20 IP addresses.
	//
	//     Each element in the JSON array contains the following field:
	//
	//     *   **RealServer**: the IP address of the primary origin server. This field is required and must be of the STRING type.
	//
	// *   **SecRealServers**: the IP addresses of the secondary origin server. This field is required and must be a JSON array. Each element in a JSON array indicates an IP address of the secondary origin server. You can configure a maximum of 20 IP addresses.
	//
	//     Each element in the JSON array contains the following field:
	//
	//     *   **RealServer**: the IP address of the secondary origin server. This field is required and must be of the STRING type.
	//
	// *   **CurrentRsIndex**: the origin server that you want to use to receive service traffic. This field is required and must be of the INTEGER type. Valid values:
	//
	//     *   **1**: the primary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the primary origin server.
	//     *   **2**: the secondary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the secondary origin server.
	Listeners *string `json:"Listeners,omitempty" xml:"Listeners,omitempty"`
}

func (s ConfigLayer4RulePolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s ConfigLayer4RulePolicyRequest) GoString() string {
	return s.String()
}

func (s *ConfigLayer4RulePolicyRequest) SetListeners(v string) *ConfigLayer4RulePolicyRequest {
	s.Listeners = &v
	return s
}

type ConfigLayer4RulePolicyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ConfigLayer4RulePolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ConfigLayer4RulePolicyResponseBody) GoString() string {
	return s.String()
}

func (s *ConfigLayer4RulePolicyResponseBody) SetRequestId(v string) *ConfigLayer4RulePolicyResponseBody {
	s.RequestId = &v
	return s
}

type ConfigLayer4RulePolicyResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ConfigLayer4RulePolicyResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ConfigLayer4RulePolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s ConfigLayer4RulePolicyResponse) GoString() string {
	return s.String()
}

func (s *ConfigLayer4RulePolicyResponse) SetHeaders(v map[string]*string) *ConfigLayer4RulePolicyResponse {
	s.Headers = v
	return s
}

func (s *ConfigLayer4RulePolicyResponse) SetStatusCode(v int32) *ConfigLayer4RulePolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *ConfigLayer4RulePolicyResponse) SetBody(v *ConfigLayer4RulePolicyResponseBody) *ConfigLayer4RulePolicyResponse {
	s.Body = v
	return s
}

type ConfigNetworkRegionBlockRequest struct {
	// The details of the configurations of blocked locations. This parameter is a JSON string. The value consists of the following fields:
	//
	// *   **RegionBlockSwitch**: the status of the Location Blacklist policy. This field is required and must be of the string type. Valid values:
	//
	//     *   **on**: enables the policy.
	//     *   **off**: disables the policy.
	//
	// *   **Countries**: the codes of the countries or areas from which you want to block requests. This field is optional and must be of the array type.
	//
	//     **
	//
	//     **Note**For more information, see the **Codes of countries and areas** section of the [Codes of administrative regions in China and codes of countries and areas](~~167926~~) topic.
	//
	//
	// *   **Provinces**: the codes of the administrative regions in China from which you want to block requests. This field is optional and must be of the array type.
	//
	//     **
	//
	//     **Note**For more information, see the **Codes of administrative regions in China** section of the [Codes of administrative regions in China and codes of countries and areas](~~167926~~) topic.
	//
	//     For example, `[11,12]` specifies Beijing and Tianjin.
	Config *string `json:"Config,omitempty" xml:"Config,omitempty"`
	// The ID of the instance.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s ConfigNetworkRegionBlockRequest) String() string {
	return tea.Prettify(s)
}

func (s ConfigNetworkRegionBlockRequest) GoString() string {
	return s.String()
}

func (s *ConfigNetworkRegionBlockRequest) SetConfig(v string) *ConfigNetworkRegionBlockRequest {
	s.Config = &v
	return s
}

func (s *ConfigNetworkRegionBlockRequest) SetInstanceId(v string) *ConfigNetworkRegionBlockRequest {
	s.InstanceId = &v
	return s
}

type ConfigNetworkRegionBlockResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ConfigNetworkRegionBlockResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ConfigNetworkRegionBlockResponseBody) GoString() string {
	return s.String()
}

func (s *ConfigNetworkRegionBlockResponseBody) SetRequestId(v string) *ConfigNetworkRegionBlockResponseBody {
	s.RequestId = &v
	return s
}

type ConfigNetworkRegionBlockResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ConfigNetworkRegionBlockResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ConfigNetworkRegionBlockResponse) String() string {
	return tea.Prettify(s)
}

func (s ConfigNetworkRegionBlockResponse) GoString() string {
	return s.String()
}

func (s *ConfigNetworkRegionBlockResponse) SetHeaders(v map[string]*string) *ConfigNetworkRegionBlockResponse {
	s.Headers = v
	return s
}

func (s *ConfigNetworkRegionBlockResponse) SetStatusCode(v int32) *ConfigNetworkRegionBlockResponse {
	s.StatusCode = &v
	return s
}

func (s *ConfigNetworkRegionBlockResponse) SetBody(v *ConfigNetworkRegionBlockResponseBody) *ConfigNetworkRegionBlockResponse {
	s.Body = v
	return s
}

type ConfigNetworkRulesRequest struct {
	// The details of the port forwarding rule. This parameter is a JSON string. The string contains the following fields:
	//
	// *   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
	// *   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
	// *   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.
	// *   **BackendPort**: the port of the origin server. This field is required and must be of the INTEGER type.
	// *   **RealServers**: the IP addresses of the origin server. This field is required and must be a JSON array. You can specify up to 20 IP addresses.
	//
	// > You can modify only the value of **RealServers** when you modify a port forwarding rule.
	NetworkRules *string `json:"NetworkRules,omitempty" xml:"NetworkRules,omitempty"`
}

func (s ConfigNetworkRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s ConfigNetworkRulesRequest) GoString() string {
	return s.String()
}

func (s *ConfigNetworkRulesRequest) SetNetworkRules(v string) *ConfigNetworkRulesRequest {
	s.NetworkRules = &v
	return s
}

type ConfigNetworkRulesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ConfigNetworkRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ConfigNetworkRulesResponseBody) GoString() string {
	return s.String()
}

func (s *ConfigNetworkRulesResponseBody) SetRequestId(v string) *ConfigNetworkRulesResponseBody {
	s.RequestId = &v
	return s
}

type ConfigNetworkRulesResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ConfigNetworkRulesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ConfigNetworkRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s ConfigNetworkRulesResponse) GoString() string {
	return s.String()
}

func (s *ConfigNetworkRulesResponse) SetHeaders(v map[string]*string) *ConfigNetworkRulesResponse {
	s.Headers = v
	return s
}

func (s *ConfigNetworkRulesResponse) SetStatusCode(v int32) *ConfigNetworkRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *ConfigNetworkRulesResponse) SetBody(v *ConfigNetworkRulesResponseBody) *ConfigNetworkRulesResponse {
	s.Body = v
	return s
}

type ConfigUdpReflectRequest struct {
	// The configuration of the filtering policy for UDP reflection attacks.
	//
	// The value is a string that consists of a JSON struct. The JSON struct contains the following field:
	//
	// *   **UdpSports**: the source ports of the UDP traffic that you want to block. This field is required and must be of the ARRAY type. Example: `[17,19]`.
	//
	//     We recommend that you block the following source ports of UDP traffic:
	//
	//     *   UDP 17: QOTD reflection attacks
	//     *   UDP 19: CharGEN reflection attacks
	//     *   UDP 69: TFTP reflection attacks
	//     *   UDP 111: Portmap reflection attacks
	//     *   UDP 123: NTP reflection attacks
	//     *   UDP 137: NetBIOS reflection attacks
	//     *   UDP 161: SNMPv2 reflection attacks
	//     *   UDP 389: CLDAP reflection attacks
	//     *   UDP 1194: OpenVPN reflection attacks
	//     *   UDP 1900: SSDP reflection attacks
	//     *   UDP 3389: RDP reflection attacks
	//     *   UDP 11211: memcached reflection attacks
	Config *string `json:"Config,omitempty" xml:"Config,omitempty"`
	// The ID of the instance.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The region ID of the instance. Valid values:
	//
	// *   **cn-hangzhou**: Chinese mainland, which indicates Anti-DDoS Pro instances. This is the default value.
	// *   **ap-southeast-1**: outside the Chinese mainland, which indicates Anti-DDoS Premium instances.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ConfigUdpReflectRequest) String() string {
	return tea.Prettify(s)
}

func (s ConfigUdpReflectRequest) GoString() string {
	return s.String()
}

func (s *ConfigUdpReflectRequest) SetConfig(v string) *ConfigUdpReflectRequest {
	s.Config = &v
	return s
}

func (s *ConfigUdpReflectRequest) SetInstanceId(v string) *ConfigUdpReflectRequest {
	s.InstanceId = &v
	return s
}

func (s *ConfigUdpReflectRequest) SetRegionId(v string) *ConfigUdpReflectRequest {
	s.RegionId = &v
	return s
}

type ConfigUdpReflectResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ConfigUdpReflectResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ConfigUdpReflectResponseBody) GoString() string {
	return s.String()
}

func (s *ConfigUdpReflectResponseBody) SetRequestId(v string) *ConfigUdpReflectResponseBody {
	s.RequestId = &v
	return s
}

type ConfigUdpReflectResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ConfigUdpReflectResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ConfigUdpReflectResponse) String() string {
	return tea.Prettify(s)
}

func (s ConfigUdpReflectResponse) GoString() string {
	return s.String()
}

func (s *ConfigUdpReflectResponse) SetHeaders(v map[string]*string) *ConfigUdpReflectResponse {
	s.Headers = v
	return s
}

func (s *ConfigUdpReflectResponse) SetStatusCode(v int32) *ConfigUdpReflectResponse {
	s.StatusCode = &v
	return s
}

func (s *ConfigUdpReflectResponse) SetBody(v *ConfigUdpReflectResponseBody) *ConfigUdpReflectResponse {
	s.Body = v
	return s
}

type ConfigWebCCTemplateRequest struct {
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The mode of the Frequency Control policy. Valid values:
	//
	// *   **default**: Normal
	// *   **gf_under_attack**: Emergency
	// *   **gf_sos_verify**: Strict
	// *   **gf_sos_enhance**: Super Strict
	Template *string `json:"Template,omitempty" xml:"Template,omitempty"`
}

func (s ConfigWebCCTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s ConfigWebCCTemplateRequest) GoString() string {
	return s.String()
}

func (s *ConfigWebCCTemplateRequest) SetDomain(v string) *ConfigWebCCTemplateRequest {
	s.Domain = &v
	return s
}

func (s *ConfigWebCCTemplateRequest) SetResourceGroupId(v string) *ConfigWebCCTemplateRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ConfigWebCCTemplateRequest) SetTemplate(v string) *ConfigWebCCTemplateRequest {
	s.Template = &v
	return s
}

type ConfigWebCCTemplateResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ConfigWebCCTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ConfigWebCCTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *ConfigWebCCTemplateResponseBody) SetRequestId(v string) *ConfigWebCCTemplateResponseBody {
	s.RequestId = &v
	return s
}

type ConfigWebCCTemplateResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ConfigWebCCTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ConfigWebCCTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s ConfigWebCCTemplateResponse) GoString() string {
	return s.String()
}

func (s *ConfigWebCCTemplateResponse) SetHeaders(v map[string]*string) *ConfigWebCCTemplateResponse {
	s.Headers = v
	return s
}

func (s *ConfigWebCCTemplateResponse) SetStatusCode(v int32) *ConfigWebCCTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *ConfigWebCCTemplateResponse) SetBody(v *ConfigWebCCTemplateResponseBody) *ConfigWebCCTemplateResponse {
	s.Body = v
	return s
}

type ConfigWebIpSetRequest struct {
	// IP address N or CIDR block N that you want to add to the blacklist. The maximum value of N is 200. You can add up to 200 IP addresses or CIDR blocks to the blacklist.
	BlackList []*string `json:"BlackList,omitempty" xml:"BlackList,omitempty" type:"Repeated"`
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// IP address N or CIDR block N that you want to add to the whitelist. The maximum value of N is 200. You can add up to 200 IP addresses or CIDR blocks to the whitelist.
	WhiteList []*string `json:"WhiteList,omitempty" xml:"WhiteList,omitempty" type:"Repeated"`
}

func (s ConfigWebIpSetRequest) String() string {
	return tea.Prettify(s)
}

func (s ConfigWebIpSetRequest) GoString() string {
	return s.String()
}

func (s *ConfigWebIpSetRequest) SetBlackList(v []*string) *ConfigWebIpSetRequest {
	s.BlackList = v
	return s
}

func (s *ConfigWebIpSetRequest) SetDomain(v string) *ConfigWebIpSetRequest {
	s.Domain = &v
	return s
}

func (s *ConfigWebIpSetRequest) SetResourceGroupId(v string) *ConfigWebIpSetRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ConfigWebIpSetRequest) SetWhiteList(v []*string) *ConfigWebIpSetRequest {
	s.WhiteList = v
	return s
}

type ConfigWebIpSetResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ConfigWebIpSetResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ConfigWebIpSetResponseBody) GoString() string {
	return s.String()
}

func (s *ConfigWebIpSetResponseBody) SetRequestId(v string) *ConfigWebIpSetResponseBody {
	s.RequestId = &v
	return s
}

type ConfigWebIpSetResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ConfigWebIpSetResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ConfigWebIpSetResponse) String() string {
	return tea.Prettify(s)
}

func (s ConfigWebIpSetResponse) GoString() string {
	return s.String()
}

func (s *ConfigWebIpSetResponse) SetHeaders(v map[string]*string) *ConfigWebIpSetResponse {
	s.Headers = v
	return s
}

func (s *ConfigWebIpSetResponse) SetStatusCode(v int32) *ConfigWebIpSetResponse {
	s.StatusCode = &v
	return s
}

func (s *ConfigWebIpSetResponse) SetBody(v *ConfigWebIpSetResponseBody) *ConfigWebIpSetResponse {
	s.Body = v
	return s
}

type CreateAsyncTaskRequest struct {
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The details of the asynchronous export task. The value is a JSON string. The field in the value varies with **TaskType**.
	//
	// If **TaskType** is set to **1**, **3**, **4**, **5**, or **6**, the following filed is returned:
	//
	// *   **instanceId**: the ID of the instance. This field is required and must be of the STRING type.
	//
	// If **TaskType** is set to **2**, the following field is returned:
	//
	// *   **domain**: the domain name of the website, which must be of the STRING type. If you do not specify this field, the forwarding rules of all websites are exported.
	TaskParams *string `json:"TaskParams,omitempty" xml:"TaskParams,omitempty"`
	// The type of the asynchronous export task that you want to create. Valid values:
	//
	// *   **1**: the task to export the port forwarding rules of an instance
	// *   **2**: the task to export the forwarding rules of a website protected by an instance
	// *   **3**: the task to export the session persistence and health check settings of an instance
	// *   **4**: the task to export the anti-DDoS mitigation policies of an instance
	// *   **5**: the task to download the blacklist for destination IP addresses of an instance
	// *   **6**: the task to download the whitelist for destination IP addresses of an instance
	TaskType *int32 `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
}

func (s CreateAsyncTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAsyncTaskRequest) GoString() string {
	return s.String()
}

func (s *CreateAsyncTaskRequest) SetResourceGroupId(v string) *CreateAsyncTaskRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateAsyncTaskRequest) SetTaskParams(v string) *CreateAsyncTaskRequest {
	s.TaskParams = &v
	return s
}

func (s *CreateAsyncTaskRequest) SetTaskType(v int32) *CreateAsyncTaskRequest {
	s.TaskType = &v
	return s
}

type CreateAsyncTaskResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateAsyncTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateAsyncTaskResponseBody) GoString() string {
	return s.String()
}

func (s *CreateAsyncTaskResponseBody) SetRequestId(v string) *CreateAsyncTaskResponseBody {
	s.RequestId = &v
	return s
}

type CreateAsyncTaskResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateAsyncTaskResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateAsyncTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateAsyncTaskResponse) GoString() string {
	return s.String()
}

func (s *CreateAsyncTaskResponse) SetHeaders(v map[string]*string) *CreateAsyncTaskResponse {
	s.Headers = v
	return s
}

func (s *CreateAsyncTaskResponse) SetStatusCode(v int32) *CreateAsyncTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateAsyncTaskResponse) SetBody(v *CreateAsyncTaskResponseBody) *CreateAsyncTaskResponse {
	s.Body = v
	return s
}

type CreateDomainResourceRequest struct {
	// The domain name of the website that you want to add to the Anti-DDoS Pro or Anti-DDoS Premium instance.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The advanced HTTPS settings. This parameter takes effect only when the value of the **ProxyType** parameter includes **https**. The value is a string that consists of a JSON struct. The JSON struct contains the following fields:
	//
	// *   **Http2https**: specifies whether to turn on Enforce HTTPS Routing. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enforce HTTPS Routing is turned off. The value 1 indicates that Enforce HTTPS Routing is turned on. The default value is 0.
	//
	//     If your website supports both HTTP and HTTPS, this feature meets your business requirements. If you enable this feature, all HTTP requests to access the website are redirected to HTTPS requests on the standard port 443.
	//
	// *   **Https2http**: specifies whether to turn on Enable HTTP. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTP is turned off. The value 1 indicates that Enable HTTP is turned on. The default value is 0.
	//
	//     If your website does not support HTTPS, this feature meets your business requirements If this feature is enabled, all HTTPS requests are redirected to HTTP requests and forwarded to origin servers. This feature can redirect WebSockets requests to WebSocket requests. Requests are redirected over the standard port 80.
	//
	// *   **Http2**: specifies whether to turn on Enable HTTP/2. This field is optional. Data type: integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTP/2 is turned off. The value 1 indicates that Enable HTTP/2 is turned on. The default value is 0.
	//
	//     After you turn on the switch, HTTP/2 is used.
	HttpsExt *string `json:"HttpsExt,omitempty" xml:"HttpsExt,omitempty"`
	// An array consisting of the IDs of instances that you want to associate.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	// An array that consists of the details of the protocol type and port number.
	ProxyTypes []*CreateDomainResourceRequestProxyTypes `json:"ProxyTypes,omitempty" xml:"ProxyTypes,omitempty" type:"Repeated"`
	// An array that consists of the addresses of origin servers.
	RealServers []*string `json:"RealServers,omitempty" xml:"RealServers,omitempty" type:"Repeated"`
	// The address type of the origin server. Valid values:
	//
	// *   **0**: IP address
	//
	// *   **1**: domain name
	//
	//     If you deploy proxies, such as a Web Application Firewall (WAF) instance, between the origin server and the Anti-DDoS Pro or Anti-DDoS Premium instance, set the value to 1. If you use the domain name, you must enter the address of the proxy, such as the CNAME of WAF.
	RsType *int32 `json:"RsType,omitempty" xml:"RsType,omitempty"`
}

func (s CreateDomainResourceRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDomainResourceRequest) GoString() string {
	return s.String()
}

func (s *CreateDomainResourceRequest) SetDomain(v string) *CreateDomainResourceRequest {
	s.Domain = &v
	return s
}

func (s *CreateDomainResourceRequest) SetHttpsExt(v string) *CreateDomainResourceRequest {
	s.HttpsExt = &v
	return s
}

func (s *CreateDomainResourceRequest) SetInstanceIds(v []*string) *CreateDomainResourceRequest {
	s.InstanceIds = v
	return s
}

func (s *CreateDomainResourceRequest) SetProxyTypes(v []*CreateDomainResourceRequestProxyTypes) *CreateDomainResourceRequest {
	s.ProxyTypes = v
	return s
}

func (s *CreateDomainResourceRequest) SetRealServers(v []*string) *CreateDomainResourceRequest {
	s.RealServers = v
	return s
}

func (s *CreateDomainResourceRequest) SetRsType(v int32) *CreateDomainResourceRequest {
	s.RsType = &v
	return s
}

type CreateDomainResourceRequestProxyTypes struct {
	// An array that consists of port numbers.
	ProxyPorts []*int32 `json:"ProxyPorts,omitempty" xml:"ProxyPorts,omitempty" type:"Repeated"`
	// The type of the protocol. Valid values:
	//
	// *   **http**
	// *   **https**
	// *   **websocket**
	// *   **websockets**
	ProxyType *string `json:"ProxyType,omitempty" xml:"ProxyType,omitempty"`
}

func (s CreateDomainResourceRequestProxyTypes) String() string {
	return tea.Prettify(s)
}

func (s CreateDomainResourceRequestProxyTypes) GoString() string {
	return s.String()
}

func (s *CreateDomainResourceRequestProxyTypes) SetProxyPorts(v []*int32) *CreateDomainResourceRequestProxyTypes {
	s.ProxyPorts = v
	return s
}

func (s *CreateDomainResourceRequestProxyTypes) SetProxyType(v string) *CreateDomainResourceRequestProxyTypes {
	s.ProxyType = &v
	return s
}

type CreateDomainResourceResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateDomainResourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDomainResourceResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDomainResourceResponseBody) SetRequestId(v string) *CreateDomainResourceResponseBody {
	s.RequestId = &v
	return s
}

type CreateDomainResourceResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateDomainResourceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateDomainResourceResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDomainResourceResponse) GoString() string {
	return s.String()
}

func (s *CreateDomainResourceResponse) SetHeaders(v map[string]*string) *CreateDomainResourceResponse {
	s.Headers = v
	return s
}

func (s *CreateDomainResourceResponse) SetStatusCode(v int32) *CreateDomainResourceResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDomainResourceResponse) SetBody(v *CreateDomainResourceResponseBody) *CreateDomainResourceResponse {
	s.Body = v
	return s
}

type CreateNetworkRulesRequest struct {
	// The details of the port forwarding rule. This parameter is a JSON string. The string contains the following fields:
	//
	// *   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
	// *   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
	// *   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.
	// *   **BackendPort**: the port of the origin server. This field is required and must be of the INTEGER type.
	// *   **RealServers**: the IP addresses of the origin server. This field is required and must be a JSON array. You can specify up to 20 IP addresses.
	NetworkRules *string `json:"NetworkRules,omitempty" xml:"NetworkRules,omitempty"`
}

func (s CreateNetworkRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateNetworkRulesRequest) GoString() string {
	return s.String()
}

func (s *CreateNetworkRulesRequest) SetNetworkRules(v string) *CreateNetworkRulesRequest {
	s.NetworkRules = &v
	return s
}

type CreateNetworkRulesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateNetworkRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateNetworkRulesResponseBody) GoString() string {
	return s.String()
}

func (s *CreateNetworkRulesResponseBody) SetRequestId(v string) *CreateNetworkRulesResponseBody {
	s.RequestId = &v
	return s
}

type CreateNetworkRulesResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateNetworkRulesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateNetworkRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateNetworkRulesResponse) GoString() string {
	return s.String()
}

func (s *CreateNetworkRulesResponse) SetHeaders(v map[string]*string) *CreateNetworkRulesResponse {
	s.Headers = v
	return s
}

func (s *CreateNetworkRulesResponse) SetStatusCode(v int32) *CreateNetworkRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateNetworkRulesResponse) SetBody(v *CreateNetworkRulesResponseBody) *CreateNetworkRulesResponse {
	s.Body = v
	return s
}

type CreatePortRequest struct {
	// The port of the origin server. Valid values: **0** to **65535**.
	BackendPort *string `json:"BackendPort,omitempty" xml:"BackendPort,omitempty"`
	// The forwarding port. Valid values: **0** to **65535**.
	FrontendPort *string `json:"FrontendPort,omitempty" xml:"FrontendPort,omitempty"`
	// The type of the protocol. Valid values:
	//
	// *   **tcp**
	// *   **udp**
	FrontendProtocol *string `json:"FrontendProtocol,omitempty" xml:"FrontendProtocol,omitempty"`
	// The ID of the Anti-DDoS Pro or Anti-DDoS Premium instance to which the port forwarding rule belongs.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// An array that consists of the IP addresses of origin servers.
	RealServers []*string `json:"RealServers,omitempty" xml:"RealServers,omitempty" type:"Repeated"`
}

func (s CreatePortRequest) String() string {
	return tea.Prettify(s)
}

func (s CreatePortRequest) GoString() string {
	return s.String()
}

func (s *CreatePortRequest) SetBackendPort(v string) *CreatePortRequest {
	s.BackendPort = &v
	return s
}

func (s *CreatePortRequest) SetFrontendPort(v string) *CreatePortRequest {
	s.FrontendPort = &v
	return s
}

func (s *CreatePortRequest) SetFrontendProtocol(v string) *CreatePortRequest {
	s.FrontendProtocol = &v
	return s
}

func (s *CreatePortRequest) SetInstanceId(v string) *CreatePortRequest {
	s.InstanceId = &v
	return s
}

func (s *CreatePortRequest) SetRealServers(v []*string) *CreatePortRequest {
	s.RealServers = v
	return s
}

type CreatePortResponseBody struct {
	// The ID of the request, which is used to locate and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreatePortResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreatePortResponseBody) GoString() string {
	return s.String()
}

func (s *CreatePortResponseBody) SetRequestId(v string) *CreatePortResponseBody {
	s.RequestId = &v
	return s
}

type CreatePortResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreatePortResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreatePortResponse) String() string {
	return tea.Prettify(s)
}

func (s CreatePortResponse) GoString() string {
	return s.String()
}

func (s *CreatePortResponse) SetHeaders(v map[string]*string) *CreatePortResponse {
	s.Headers = v
	return s
}

func (s *CreatePortResponse) SetStatusCode(v int32) *CreatePortResponse {
	s.StatusCode = &v
	return s
}

func (s *CreatePortResponse) SetBody(v *CreatePortResponseBody) *CreatePortResponse {
	s.Body = v
	return s
}

type CreateSceneDefensePolicyRequest struct {
	// The end time of the policy. This value is a UNIX timestamp. Units: milliseconds.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The name of the policy.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The start time of the policy. This value is a UNIX timestamp. Units: milliseconds.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The template of the policy. Valid values:
	//
	// *   **promotion**: important activity
	// *   **bypass**: all traffic forwarded
	Template *string `json:"Template,omitempty" xml:"Template,omitempty"`
}

func (s CreateSceneDefensePolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateSceneDefensePolicyRequest) GoString() string {
	return s.String()
}

func (s *CreateSceneDefensePolicyRequest) SetEndTime(v int64) *CreateSceneDefensePolicyRequest {
	s.EndTime = &v
	return s
}

func (s *CreateSceneDefensePolicyRequest) SetName(v string) *CreateSceneDefensePolicyRequest {
	s.Name = &v
	return s
}

func (s *CreateSceneDefensePolicyRequest) SetStartTime(v int64) *CreateSceneDefensePolicyRequest {
	s.StartTime = &v
	return s
}

func (s *CreateSceneDefensePolicyRequest) SetTemplate(v string) *CreateSceneDefensePolicyRequest {
	s.Template = &v
	return s
}

type CreateSceneDefensePolicyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateSceneDefensePolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateSceneDefensePolicyResponseBody) GoString() string {
	return s.String()
}

func (s *CreateSceneDefensePolicyResponseBody) SetRequestId(v string) *CreateSceneDefensePolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateSceneDefensePolicyResponseBody) SetSuccess(v bool) *CreateSceneDefensePolicyResponseBody {
	s.Success = &v
	return s
}

type CreateSceneDefensePolicyResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateSceneDefensePolicyResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateSceneDefensePolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateSceneDefensePolicyResponse) GoString() string {
	return s.String()
}

func (s *CreateSceneDefensePolicyResponse) SetHeaders(v map[string]*string) *CreateSceneDefensePolicyResponse {
	s.Headers = v
	return s
}

func (s *CreateSceneDefensePolicyResponse) SetStatusCode(v int32) *CreateSceneDefensePolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateSceneDefensePolicyResponse) SetBody(v *CreateSceneDefensePolicyResponseBody) *CreateSceneDefensePolicyResponse {
	s.Body = v
	return s
}

type CreateSchedulerRuleRequest struct {
	// The details of the CDN interaction rule. This parameter is a JSON string. The following list describes the fields in the value of the parameter:
	//
	// *   **ParamType**: the type of the scheduling rule. This field is required and must be of the string type. Set the value to **cdn**. This indicates that you want to modify a CDN interaction rule.
	//
	// *   **ParamData**: the values of parameters that you want to modify for the CDN interaction rule. This field is required and must be of the map type. ParamData contains the following parameters:
	//
	//     *   **Domain**: the accelerated domain in CDN. This parameter is required and must be of the string type.
	//     *   **Cname**: the CNAME that is assigned to the accelerated domain. This parameter is required and must be of the string type.
	//     *   **AccessQps**: the queries per second (QPS) threshold that is used to switch service traffic to Anti-DDoS Pro or Anti-DDoS Premium. This parameter is required and must be of the integer type.
	//     *   **UpstreamQps**: the QPS threshold that is used to switch service traffic to CDN. This parameter is optional and must be of the integer type.
	Param *string `json:"Param,omitempty" xml:"Param,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The name of the rule.
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	// The type of the custom defense rule. Valid values:
	//
	// *   **2**: tiered protection
	// *   **3**: network acceleration
	// *   **5**: CDN interaction
	// *   **6**: cloud service interaction
	RuleType *int32 `json:"RuleType,omitempty" xml:"RuleType,omitempty"`
	// The details of the scheduling rule. This parameter is a JSON string. The following list describes the fields in the value of the parameter:
	//
	// *   **Type**: the address type of the interaction resource that you want to use in the scheduling rule. This field is required and must be of the string type. Valid values:
	//
	//     *   **A**: IP address
	//     *   **CNAME**: domain name
	//
	// *   **Value**: the address of the interaction resource that you want to use in the scheduling rule. This field is required and must be of the string type.
	//
	// *   **Priority**: the priority of the scheduling rule. This field is required and must be of the integer type. Valid values: **0** to **100**. A larger value indicates a higher priority.
	//
	// *   **ValueType**: the type of the interaction resource that you want to use in the scheduling rule. This field is required and must be of the integer type. Valid values:
	//
	//     *   **1**: the IP address of the Anti-DDoS Pro or Anti-DDoS Premium instance
	//     *   **2**: the IP address of the interaction resource in the tiered protection scenario
	//     *   **3**: the IP address that is used to accelerate access in the network acceleration scenario
	//     *   **5**: the domain name that is configured in Alibaba Cloud CDN (CDN) in the CDN interaction scenario
	//     *   **6** the IP address of the interaction resource in the cloud service interaction scenario
	//
	// *   **RegionId**: the region where the interaction resource is deployed. This parameter must be specified when **ValueType** is set to **2**. The value must be of the string type.
	Rules *string `json:"Rules,omitempty" xml:"Rules,omitempty"`
}

func (s CreateSchedulerRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateSchedulerRuleRequest) GoString() string {
	return s.String()
}

func (s *CreateSchedulerRuleRequest) SetParam(v string) *CreateSchedulerRuleRequest {
	s.Param = &v
	return s
}

func (s *CreateSchedulerRuleRequest) SetResourceGroupId(v string) *CreateSchedulerRuleRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateSchedulerRuleRequest) SetRuleName(v string) *CreateSchedulerRuleRequest {
	s.RuleName = &v
	return s
}

func (s *CreateSchedulerRuleRequest) SetRuleType(v int32) *CreateSchedulerRuleRequest {
	s.RuleType = &v
	return s
}

func (s *CreateSchedulerRuleRequest) SetRules(v string) *CreateSchedulerRuleRequest {
	s.Rules = &v
	return s
}

type CreateSchedulerRuleResponseBody struct {
	// The CNAME that is assigned by Sec-Traffic Manager for the scheduling rule.
	//
	// > To enable the scheduling rule, you must map the domain name of the service to the CNAME.
	Cname *string `json:"Cname,omitempty" xml:"Cname,omitempty"`
	// The ID of the request, which is used to locate and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The name of the rule.
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
}

func (s CreateSchedulerRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateSchedulerRuleResponseBody) GoString() string {
	return s.String()
}

func (s *CreateSchedulerRuleResponseBody) SetCname(v string) *CreateSchedulerRuleResponseBody {
	s.Cname = &v
	return s
}

func (s *CreateSchedulerRuleResponseBody) SetRequestId(v string) *CreateSchedulerRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateSchedulerRuleResponseBody) SetRuleName(v string) *CreateSchedulerRuleResponseBody {
	s.RuleName = &v
	return s
}

type CreateSchedulerRuleResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateSchedulerRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateSchedulerRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateSchedulerRuleResponse) GoString() string {
	return s.String()
}

func (s *CreateSchedulerRuleResponse) SetHeaders(v map[string]*string) *CreateSchedulerRuleResponse {
	s.Headers = v
	return s
}

func (s *CreateSchedulerRuleResponse) SetStatusCode(v int32) *CreateSchedulerRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateSchedulerRuleResponse) SetBody(v *CreateSchedulerRuleResponseBody) *CreateSchedulerRuleResponse {
	s.Body = v
	return s
}

type CreateTagResourcesRequest struct {
	// The region ID of the instance. Set the value to **cn-hangzhou**, which indicates an Anti-DDoS Pro instance in the Chinese mainland.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management.
	//
	// If you do not specify this parameter, the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// An array consisting of the IDs of the Anti-DDoS Pro instances to which you want to add the tag.
	ResourceIds []*string `json:"ResourceIds,omitempty" xml:"ResourceIds,omitempty" type:"Repeated"`
	// The type of the resource to which the tag belongs. Set the value to **INSTANCE**, which indicates an Anti-DDoS Pro instance.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// An array that consists of the tags to add.
	Tags []*CreateTagResourcesRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s CreateTagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateTagResourcesRequest) GoString() string {
	return s.String()
}

func (s *CreateTagResourcesRequest) SetRegionId(v string) *CreateTagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *CreateTagResourcesRequest) SetResourceGroupId(v string) *CreateTagResourcesRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateTagResourcesRequest) SetResourceIds(v []*string) *CreateTagResourcesRequest {
	s.ResourceIds = v
	return s
}

func (s *CreateTagResourcesRequest) SetResourceType(v string) *CreateTagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *CreateTagResourcesRequest) SetTags(v []*CreateTagResourcesRequestTags) *CreateTagResourcesRequest {
	s.Tags = v
	return s
}

type CreateTagResourcesRequestTags struct {
	// The key of the tag to add.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag to add.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateTagResourcesRequestTags) String() string {
	return tea.Prettify(s)
}

func (s CreateTagResourcesRequestTags) GoString() string {
	return s.String()
}

func (s *CreateTagResourcesRequestTags) SetKey(v string) *CreateTagResourcesRequestTags {
	s.Key = &v
	return s
}

func (s *CreateTagResourcesRequestTags) SetValue(v string) *CreateTagResourcesRequestTags {
	s.Value = &v
	return s
}

type CreateTagResourcesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateTagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateTagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *CreateTagResourcesResponseBody) SetRequestId(v string) *CreateTagResourcesResponseBody {
	s.RequestId = &v
	return s
}

type CreateTagResourcesResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateTagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateTagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateTagResourcesResponse) GoString() string {
	return s.String()
}

func (s *CreateTagResourcesResponse) SetHeaders(v map[string]*string) *CreateTagResourcesResponse {
	s.Headers = v
	return s
}

func (s *CreateTagResourcesResponse) SetStatusCode(v int32) *CreateTagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateTagResourcesResponse) SetBody(v *CreateTagResourcesResponseBody) *CreateTagResourcesResponse {
	s.Body = v
	return s
}

type CreateWebCCRuleRequest struct {
	Act             *string `json:"Act,omitempty" xml:"Act,omitempty"`
	Count           *int32  `json:"Count,omitempty" xml:"Count,omitempty"`
	Domain          *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	Interval        *int32  `json:"Interval,omitempty" xml:"Interval,omitempty"`
	Mode            *string `json:"Mode,omitempty" xml:"Mode,omitempty"`
	Name            *string `json:"Name,omitempty" xml:"Name,omitempty"`
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	Ttl             *int32  `json:"Ttl,omitempty" xml:"Ttl,omitempty"`
	Uri             *string `json:"Uri,omitempty" xml:"Uri,omitempty"`
}

func (s CreateWebCCRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateWebCCRuleRequest) GoString() string {
	return s.String()
}

func (s *CreateWebCCRuleRequest) SetAct(v string) *CreateWebCCRuleRequest {
	s.Act = &v
	return s
}

func (s *CreateWebCCRuleRequest) SetCount(v int32) *CreateWebCCRuleRequest {
	s.Count = &v
	return s
}

func (s *CreateWebCCRuleRequest) SetDomain(v string) *CreateWebCCRuleRequest {
	s.Domain = &v
	return s
}

func (s *CreateWebCCRuleRequest) SetInterval(v int32) *CreateWebCCRuleRequest {
	s.Interval = &v
	return s
}

func (s *CreateWebCCRuleRequest) SetMode(v string) *CreateWebCCRuleRequest {
	s.Mode = &v
	return s
}

func (s *CreateWebCCRuleRequest) SetName(v string) *CreateWebCCRuleRequest {
	s.Name = &v
	return s
}

func (s *CreateWebCCRuleRequest) SetResourceGroupId(v string) *CreateWebCCRuleRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateWebCCRuleRequest) SetTtl(v int32) *CreateWebCCRuleRequest {
	s.Ttl = &v
	return s
}

func (s *CreateWebCCRuleRequest) SetUri(v string) *CreateWebCCRuleRequest {
	s.Uri = &v
	return s
}

type CreateWebCCRuleResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateWebCCRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateWebCCRuleResponseBody) GoString() string {
	return s.String()
}

func (s *CreateWebCCRuleResponseBody) SetRequestId(v string) *CreateWebCCRuleResponseBody {
	s.RequestId = &v
	return s
}

type CreateWebCCRuleResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateWebCCRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateWebCCRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateWebCCRuleResponse) GoString() string {
	return s.String()
}

func (s *CreateWebCCRuleResponse) SetHeaders(v map[string]*string) *CreateWebCCRuleResponse {
	s.Headers = v
	return s
}

func (s *CreateWebCCRuleResponse) SetStatusCode(v int32) *CreateWebCCRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateWebCCRuleResponse) SetBody(v *CreateWebCCRuleResponseBody) *CreateWebCCRuleResponse {
	s.Body = v
	return s
}

type CreateWebRuleRequest struct {
	// The ID of the associated defense. This parameter applies to scenarios in which other cloud services, such as Object Storage Service (OSS), are integrated with Anti-DDoS Pro or Anti-DDoS Premium.
	//
	// > This parameter is in internal preview. Do not use this parameter.
	//
	// For example, if you integrate OSS with Anti-DDoS Pro or Anti-DDoS Premium, Anti-DDoS Pro or Anti-DDoS Premium allocates an IP address pool for the OSS production account. Each IP address corresponds to a unique defense ID. A defense ID is a CNAME, which is automatically resolved to the IP address of the required Anti-DDoS Pro or Anti-DDoS Premium instance. A defense ID can be resolved to the same IP address to facilitate scheduling.
	//
	// > You can specify only one of the following parameters: **InstanceIds** and **DefenseId**.
	DefenseId *string `json:"DefenseId,omitempty" xml:"DefenseId,omitempty"`
	// The domain name of the website that you want to add to the instance.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The advanced HTTPS settings. This parameter takes effect only when the value of the **ProxyType** parameter includes **https**. The value is a string that consists of a JSON struct. The JSON struct contains the following fields:
	//
	// *   **Http2https**: specifies whether to turn on Enforce HTTPS Routing. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enforce HTTPS Routing is turned off. The value 1 indicates that Enforce HTTPS Routing is turned on. The default value is 0.
	//
	//     If your website supports both HTTP and HTTPS, this feature meets your business requirements. If you enable this feature, all HTTP requests to access the website are redirected to HTTPS requests on the standard port 443.
	//
	// *   **Https2http**: specifies whether to turn on Enable HTTP. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTP is turned off. The value 1 indicates that Enable HTTP is turned on. The default value is 0.
	//
	//     If your website does not support HTTPS, this feature meets your business requirements If this feature is enabled, all HTTPS requests are redirected to HTTP requests and forwarded to origin servers. This feature can redirect WebSockets requests to WebSocket requests. Requests are redirected over the standard port 80.
	//
	// *   **Http2**: specifies whether to turn on Enable HTTP/2. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTP/2 is turned off. The value 1 indicates that Enable HTTP/2 is turned on. The default value is 0.
	//
	//     After you turn on Enable HTTP/2, the protocol type is HTTP/2.
	HttpsExt *string `json:"HttpsExt,omitempty" xml:"HttpsExt,omitempty"`
	// An array consisting of the IDs of instances that you want to associate.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	//
	// For more information about resource groups, see [Create a resource group](~~94485~~).
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The address type of the origin server. Valid values:
	//
	// *   **0**: IP address
	// *   **1**: domain name The domain name of the origin server is returned if you deploy proxies, such as Web Application Firewall (WAF), between the origin server and the instance. In this case, the address of the proxy, such as the CNAME provided by WAF, is returned.
	RsType *int32 `json:"RsType,omitempty" xml:"RsType,omitempty"`
	// The details of the forwarding rule. The value is a string that consists of JSON arrays. Each element in a JSON array is a JSON struct that contains the following fields:
	//
	// *   **ProxyRules**: the information about the origin server. The information includes the port number and IP address. This field is required and must be a JSON array. Each element in a JSON array is a JSON struct that contains the following fields:
	//
	//     *   **ProxyPort**: the port number. This field is required and must be an integer.
	//     *   **RealServers**: the IP address. This field is required and must be a string array.
	//
	// *   **ProxyType**: the protocol type. This field is required and must be a string. Valid values: **http**, **https**, **websocket**, and **websockets**.
	Rules *string `json:"Rules,omitempty" xml:"Rules,omitempty"`
}

func (s CreateWebRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateWebRuleRequest) GoString() string {
	return s.String()
}

func (s *CreateWebRuleRequest) SetDefenseId(v string) *CreateWebRuleRequest {
	s.DefenseId = &v
	return s
}

func (s *CreateWebRuleRequest) SetDomain(v string) *CreateWebRuleRequest {
	s.Domain = &v
	return s
}

func (s *CreateWebRuleRequest) SetHttpsExt(v string) *CreateWebRuleRequest {
	s.HttpsExt = &v
	return s
}

func (s *CreateWebRuleRequest) SetInstanceIds(v []*string) *CreateWebRuleRequest {
	s.InstanceIds = v
	return s
}

func (s *CreateWebRuleRequest) SetResourceGroupId(v string) *CreateWebRuleRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateWebRuleRequest) SetRsType(v int32) *CreateWebRuleRequest {
	s.RsType = &v
	return s
}

func (s *CreateWebRuleRequest) SetRules(v string) *CreateWebRuleRequest {
	s.Rules = &v
	return s
}

type CreateWebRuleResponseBody struct {
	// The ID of the request, which is used to locate and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateWebRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateWebRuleResponseBody) GoString() string {
	return s.String()
}

func (s *CreateWebRuleResponseBody) SetRequestId(v string) *CreateWebRuleResponseBody {
	s.RequestId = &v
	return s
}

type CreateWebRuleResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateWebRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateWebRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateWebRuleResponse) GoString() string {
	return s.String()
}

func (s *CreateWebRuleResponse) SetHeaders(v map[string]*string) *CreateWebRuleResponse {
	s.Headers = v
	return s
}

func (s *CreateWebRuleResponse) SetStatusCode(v int32) *CreateWebRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateWebRuleResponse) SetBody(v *CreateWebRuleResponseBody) *CreateWebRuleResponse {
	s.Body = v
	return s
}

type DeleteAsyncTaskRequest struct {
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The ID of the task that you want to delete.
	//
	// > You can call the [DescribeAsyncTasks](~~159405~~) operation to query the IDs of all asynchronous export tasks.
	TaskId *int32 `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s DeleteAsyncTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAsyncTaskRequest) GoString() string {
	return s.String()
}

func (s *DeleteAsyncTaskRequest) SetResourceGroupId(v string) *DeleteAsyncTaskRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DeleteAsyncTaskRequest) SetTaskId(v int32) *DeleteAsyncTaskRequest {
	s.TaskId = &v
	return s
}

type DeleteAsyncTaskResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteAsyncTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAsyncTaskResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAsyncTaskResponseBody) SetRequestId(v string) *DeleteAsyncTaskResponseBody {
	s.RequestId = &v
	return s
}

type DeleteAsyncTaskResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteAsyncTaskResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteAsyncTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAsyncTaskResponse) GoString() string {
	return s.String()
}

func (s *DeleteAsyncTaskResponse) SetHeaders(v map[string]*string) *DeleteAsyncTaskResponse {
	s.Headers = v
	return s
}

func (s *DeleteAsyncTaskResponse) SetStatusCode(v int32) *DeleteAsyncTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAsyncTaskResponse) SetBody(v *DeleteAsyncTaskResponseBody) *DeleteAsyncTaskResponse {
	s.Body = v
	return s
}

type DeleteAutoCcBlacklistRequest struct {
	// The IP addresses that you want to manage. This parameter is a JSON string. The string contains the following fields:
	//
	// *   **src**: the IP address. This field is required and must be of the STRING type.
	Blacklist *string `json:"Blacklist,omitempty" xml:"Blacklist,omitempty"`
	// The ID of the instance.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s DeleteAutoCcBlacklistRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAutoCcBlacklistRequest) GoString() string {
	return s.String()
}

func (s *DeleteAutoCcBlacklistRequest) SetBlacklist(v string) *DeleteAutoCcBlacklistRequest {
	s.Blacklist = &v
	return s
}

func (s *DeleteAutoCcBlacklistRequest) SetInstanceId(v string) *DeleteAutoCcBlacklistRequest {
	s.InstanceId = &v
	return s
}

type DeleteAutoCcBlacklistResponseBody struct {
	// The ID of the request, which is used to locate and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteAutoCcBlacklistResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAutoCcBlacklistResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAutoCcBlacklistResponseBody) SetRequestId(v string) *DeleteAutoCcBlacklistResponseBody {
	s.RequestId = &v
	return s
}

type DeleteAutoCcBlacklistResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteAutoCcBlacklistResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteAutoCcBlacklistResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAutoCcBlacklistResponse) GoString() string {
	return s.String()
}

func (s *DeleteAutoCcBlacklistResponse) SetHeaders(v map[string]*string) *DeleteAutoCcBlacklistResponse {
	s.Headers = v
	return s
}

func (s *DeleteAutoCcBlacklistResponse) SetStatusCode(v int32) *DeleteAutoCcBlacklistResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAutoCcBlacklistResponse) SetBody(v *DeleteAutoCcBlacklistResponseBody) *DeleteAutoCcBlacklistResponse {
	s.Body = v
	return s
}

type DeleteAutoCcWhitelistRequest struct {
	// The ID of the instance.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The IP addresses that you want to manage. This parameter is a JSON string. This parameter is a JSON string. The string contains the following field:
	//
	// *   **src**: the IP address. This field is required and must be of the string type.
	Whitelist *string `json:"Whitelist,omitempty" xml:"Whitelist,omitempty"`
}

func (s DeleteAutoCcWhitelistRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAutoCcWhitelistRequest) GoString() string {
	return s.String()
}

func (s *DeleteAutoCcWhitelistRequest) SetInstanceId(v string) *DeleteAutoCcWhitelistRequest {
	s.InstanceId = &v
	return s
}

func (s *DeleteAutoCcWhitelistRequest) SetWhitelist(v string) *DeleteAutoCcWhitelistRequest {
	s.Whitelist = &v
	return s
}

type DeleteAutoCcWhitelistResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteAutoCcWhitelistResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAutoCcWhitelistResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAutoCcWhitelistResponseBody) SetRequestId(v string) *DeleteAutoCcWhitelistResponseBody {
	s.RequestId = &v
	return s
}

type DeleteAutoCcWhitelistResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteAutoCcWhitelistResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteAutoCcWhitelistResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAutoCcWhitelistResponse) GoString() string {
	return s.String()
}

func (s *DeleteAutoCcWhitelistResponse) SetHeaders(v map[string]*string) *DeleteAutoCcWhitelistResponse {
	s.Headers = v
	return s
}

func (s *DeleteAutoCcWhitelistResponse) SetStatusCode(v int32) *DeleteAutoCcWhitelistResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAutoCcWhitelistResponse) SetBody(v *DeleteAutoCcWhitelistResponseBody) *DeleteAutoCcWhitelistResponse {
	s.Body = v
	return s
}

type DeleteDomainResourceRequest struct {
	// The domain name for which the forwarding rule is configured.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
}

func (s DeleteDomainResourceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDomainResourceRequest) GoString() string {
	return s.String()
}

func (s *DeleteDomainResourceRequest) SetDomain(v string) *DeleteDomainResourceRequest {
	s.Domain = &v
	return s
}

type DeleteDomainResourceResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDomainResourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDomainResourceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDomainResourceResponseBody) SetRequestId(v string) *DeleteDomainResourceResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDomainResourceResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteDomainResourceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteDomainResourceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDomainResourceResponse) GoString() string {
	return s.String()
}

func (s *DeleteDomainResourceResponse) SetHeaders(v map[string]*string) *DeleteDomainResourceResponse {
	s.Headers = v
	return s
}

func (s *DeleteDomainResourceResponse) SetStatusCode(v int32) *DeleteDomainResourceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDomainResourceResponse) SetBody(v *DeleteDomainResourceResponseBody) *DeleteDomainResourceResponse {
	s.Body = v
	return s
}

type DeleteNetworkRuleRequest struct {
	// An array that consists of the information about the port forwarding rule. This parameter is a JSON string. The string contains the following fields:
	//
	// *   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
	// *   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
	// *   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.
	NetworkRule *string `json:"NetworkRule,omitempty" xml:"NetworkRule,omitempty"`
}

func (s DeleteNetworkRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteNetworkRuleRequest) GoString() string {
	return s.String()
}

func (s *DeleteNetworkRuleRequest) SetNetworkRule(v string) *DeleteNetworkRuleRequest {
	s.NetworkRule = &v
	return s
}

type DeleteNetworkRuleResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteNetworkRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteNetworkRuleResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteNetworkRuleResponseBody) SetRequestId(v string) *DeleteNetworkRuleResponseBody {
	s.RequestId = &v
	return s
}

type DeleteNetworkRuleResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteNetworkRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteNetworkRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteNetworkRuleResponse) GoString() string {
	return s.String()
}

func (s *DeleteNetworkRuleResponse) SetHeaders(v map[string]*string) *DeleteNetworkRuleResponse {
	s.Headers = v
	return s
}

func (s *DeleteNetworkRuleResponse) SetStatusCode(v int32) *DeleteNetworkRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteNetworkRuleResponse) SetBody(v *DeleteNetworkRuleResponseBody) *DeleteNetworkRuleResponse {
	s.Body = v
	return s
}

type DeletePortRequest struct {
	// The port of the origin server. Valid values: **0** to **65535**.
	BackendPort *string `json:"BackendPort,omitempty" xml:"BackendPort,omitempty"`
	// The forwarding port. Valid values: **0** to **65535**.
	FrontendPort *string `json:"FrontendPort,omitempty" xml:"FrontendPort,omitempty"`
	// The type of the protocol. Valid values:
	//
	// *   **tcp**
	// *   **udp**
	FrontendProtocol *string `json:"FrontendProtocol,omitempty" xml:"FrontendProtocol,omitempty"`
	// The ID of the Anti-DDoS Pro or Anti-DDoS Premium instance to which the port forwarding rule belongs.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// An array that consists of the IP addresses of origin servers.
	RealServers []*string `json:"RealServers,omitempty" xml:"RealServers,omitempty" type:"Repeated"`
}

func (s DeletePortRequest) String() string {
	return tea.Prettify(s)
}

func (s DeletePortRequest) GoString() string {
	return s.String()
}

func (s *DeletePortRequest) SetBackendPort(v string) *DeletePortRequest {
	s.BackendPort = &v
	return s
}

func (s *DeletePortRequest) SetFrontendPort(v string) *DeletePortRequest {
	s.FrontendPort = &v
	return s
}

func (s *DeletePortRequest) SetFrontendProtocol(v string) *DeletePortRequest {
	s.FrontendProtocol = &v
	return s
}

func (s *DeletePortRequest) SetInstanceId(v string) *DeletePortRequest {
	s.InstanceId = &v
	return s
}

func (s *DeletePortRequest) SetRealServers(v []*string) *DeletePortRequest {
	s.RealServers = v
	return s
}

type DeletePortResponseBody struct {
	// The ID of the request, which is used to locate and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeletePortResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeletePortResponseBody) GoString() string {
	return s.String()
}

func (s *DeletePortResponseBody) SetRequestId(v string) *DeletePortResponseBody {
	s.RequestId = &v
	return s
}

type DeletePortResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeletePortResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeletePortResponse) String() string {
	return tea.Prettify(s)
}

func (s DeletePortResponse) GoString() string {
	return s.String()
}

func (s *DeletePortResponse) SetHeaders(v map[string]*string) *DeletePortResponse {
	s.Headers = v
	return s
}

func (s *DeletePortResponse) SetStatusCode(v int32) *DeletePortResponse {
	s.StatusCode = &v
	return s
}

func (s *DeletePortResponse) SetBody(v *DeletePortResponseBody) *DeletePortResponse {
	s.Body = v
	return s
}

type DeleteSceneDefensePolicyRequest struct {
	// The ID of the policy that you want to delete.
	//
	// > You can call the [DescribeSceneDefensePolicies](~~159382~~) operation to query the IDs of all policies.
	PolicyId *string `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
}

func (s DeleteSceneDefensePolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSceneDefensePolicyRequest) GoString() string {
	return s.String()
}

func (s *DeleteSceneDefensePolicyRequest) SetPolicyId(v string) *DeleteSceneDefensePolicyRequest {
	s.PolicyId = &v
	return s
}

type DeleteSceneDefensePolicyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteSceneDefensePolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteSceneDefensePolicyResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSceneDefensePolicyResponseBody) SetRequestId(v string) *DeleteSceneDefensePolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteSceneDefensePolicyResponseBody) SetSuccess(v bool) *DeleteSceneDefensePolicyResponseBody {
	s.Success = &v
	return s
}

type DeleteSceneDefensePolicyResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteSceneDefensePolicyResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteSceneDefensePolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSceneDefensePolicyResponse) GoString() string {
	return s.String()
}

func (s *DeleteSceneDefensePolicyResponse) SetHeaders(v map[string]*string) *DeleteSceneDefensePolicyResponse {
	s.Headers = v
	return s
}

func (s *DeleteSceneDefensePolicyResponse) SetStatusCode(v int32) *DeleteSceneDefensePolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSceneDefensePolicyResponse) SetBody(v *DeleteSceneDefensePolicyResponseBody) *DeleteSceneDefensePolicyResponse {
	s.Body = v
	return s
}

type DeleteSchedulerRuleRequest struct {
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The name of the scheduling rule that you want to delete.
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
}

func (s DeleteSchedulerRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSchedulerRuleRequest) GoString() string {
	return s.String()
}

func (s *DeleteSchedulerRuleRequest) SetResourceGroupId(v string) *DeleteSchedulerRuleRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DeleteSchedulerRuleRequest) SetRuleName(v string) *DeleteSchedulerRuleRequest {
	s.RuleName = &v
	return s
}

type DeleteSchedulerRuleResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteSchedulerRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteSchedulerRuleResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSchedulerRuleResponseBody) SetRequestId(v string) *DeleteSchedulerRuleResponseBody {
	s.RequestId = &v
	return s
}

type DeleteSchedulerRuleResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteSchedulerRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteSchedulerRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSchedulerRuleResponse) GoString() string {
	return s.String()
}

func (s *DeleteSchedulerRuleResponse) SetHeaders(v map[string]*string) *DeleteSchedulerRuleResponse {
	s.Headers = v
	return s
}

func (s *DeleteSchedulerRuleResponse) SetStatusCode(v int32) *DeleteSchedulerRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSchedulerRuleResponse) SetBody(v *DeleteSchedulerRuleResponseBody) *DeleteSchedulerRuleResponse {
	s.Body = v
	return s
}

type DeleteTagResourcesRequest struct {
	// Specifies whether to remove all tags from the specified resource. Valid values:
	//
	// *   **true**: yes.
	// *   **false** no. This is the default value.
	All *bool `json:"All,omitempty" xml:"All,omitempty"`
	// The region ID of the instance. Set the value to **cn-hangzhou**, which indicates an Anti-DDoS Pro instance in the Chinese mainland.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management.
	//
	// If you do not configure this parameter, the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// An array consisting of the IDs of instances from which you want to remove tags.
	ResourceIds []*string `json:"ResourceIds,omitempty" xml:"ResourceIds,omitempty" type:"Repeated"`
	// The type of the resource to which the tag belongs. Set the value to **INSTANCE**, which indicates an Anti-DDoS Pro instance.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// An array consisting of the keys of the tags that you want to remove.
	TagKey []*string `json:"TagKey,omitempty" xml:"TagKey,omitempty" type:"Repeated"`
}

func (s DeleteTagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteTagResourcesRequest) GoString() string {
	return s.String()
}

func (s *DeleteTagResourcesRequest) SetAll(v bool) *DeleteTagResourcesRequest {
	s.All = &v
	return s
}

func (s *DeleteTagResourcesRequest) SetRegionId(v string) *DeleteTagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteTagResourcesRequest) SetResourceGroupId(v string) *DeleteTagResourcesRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DeleteTagResourcesRequest) SetResourceIds(v []*string) *DeleteTagResourcesRequest {
	s.ResourceIds = v
	return s
}

func (s *DeleteTagResourcesRequest) SetResourceType(v string) *DeleteTagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *DeleteTagResourcesRequest) SetTagKey(v []*string) *DeleteTagResourcesRequest {
	s.TagKey = v
	return s
}

type DeleteTagResourcesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteTagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteTagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteTagResourcesResponseBody) SetRequestId(v string) *DeleteTagResourcesResponseBody {
	s.RequestId = &v
	return s
}

type DeleteTagResourcesResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteTagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteTagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteTagResourcesResponse) GoString() string {
	return s.String()
}

func (s *DeleteTagResourcesResponse) SetHeaders(v map[string]*string) *DeleteTagResourcesResponse {
	s.Headers = v
	return s
}

func (s *DeleteTagResourcesResponse) SetStatusCode(v int32) *DeleteTagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteTagResourcesResponse) SetBody(v *DeleteTagResourcesResponseBody) *DeleteTagResourcesResponse {
	s.Body = v
	return s
}

type DeleteWebCCRuleRequest struct {
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for a domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The name of the custom frequency control rule that you want to delete.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DeleteWebCCRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteWebCCRuleRequest) GoString() string {
	return s.String()
}

func (s *DeleteWebCCRuleRequest) SetDomain(v string) *DeleteWebCCRuleRequest {
	s.Domain = &v
	return s
}

func (s *DeleteWebCCRuleRequest) SetName(v string) *DeleteWebCCRuleRequest {
	s.Name = &v
	return s
}

func (s *DeleteWebCCRuleRequest) SetResourceGroupId(v string) *DeleteWebCCRuleRequest {
	s.ResourceGroupId = &v
	return s
}

type DeleteWebCCRuleResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteWebCCRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteWebCCRuleResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteWebCCRuleResponseBody) SetRequestId(v string) *DeleteWebCCRuleResponseBody {
	s.RequestId = &v
	return s
}

type DeleteWebCCRuleResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteWebCCRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteWebCCRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteWebCCRuleResponse) GoString() string {
	return s.String()
}

func (s *DeleteWebCCRuleResponse) SetHeaders(v map[string]*string) *DeleteWebCCRuleResponse {
	s.Headers = v
	return s
}

func (s *DeleteWebCCRuleResponse) SetStatusCode(v int32) *DeleteWebCCRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteWebCCRuleResponse) SetBody(v *DeleteWebCCRuleResponseBody) *DeleteWebCCRuleResponse {
	s.Body = v
	return s
}

type DeleteWebCacheCustomRuleRequest struct {
	// The domain name for which you want to delete the custom rules of the Static Page Caching policy.
	//
	// > You can call the [DescribeDomains](~~91724~~) operation to query all the domain names that are added to Anti-DDoS Pro or Anti-DDoS Premium.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management.
	//
	// If you do not configure this parameter, the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// An array consisting of the names of the rules that you want to delete.
	RuleNames []*string `json:"RuleNames,omitempty" xml:"RuleNames,omitempty" type:"Repeated"`
}

func (s DeleteWebCacheCustomRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteWebCacheCustomRuleRequest) GoString() string {
	return s.String()
}

func (s *DeleteWebCacheCustomRuleRequest) SetDomain(v string) *DeleteWebCacheCustomRuleRequest {
	s.Domain = &v
	return s
}

func (s *DeleteWebCacheCustomRuleRequest) SetResourceGroupId(v string) *DeleteWebCacheCustomRuleRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DeleteWebCacheCustomRuleRequest) SetRuleNames(v []*string) *DeleteWebCacheCustomRuleRequest {
	s.RuleNames = v
	return s
}

type DeleteWebCacheCustomRuleResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteWebCacheCustomRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteWebCacheCustomRuleResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteWebCacheCustomRuleResponseBody) SetRequestId(v string) *DeleteWebCacheCustomRuleResponseBody {
	s.RequestId = &v
	return s
}

type DeleteWebCacheCustomRuleResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteWebCacheCustomRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteWebCacheCustomRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteWebCacheCustomRuleResponse) GoString() string {
	return s.String()
}

func (s *DeleteWebCacheCustomRuleResponse) SetHeaders(v map[string]*string) *DeleteWebCacheCustomRuleResponse {
	s.Headers = v
	return s
}

func (s *DeleteWebCacheCustomRuleResponse) SetStatusCode(v int32) *DeleteWebCacheCustomRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteWebCacheCustomRuleResponse) SetBody(v *DeleteWebCacheCustomRuleResponseBody) *DeleteWebCacheCustomRuleResponse {
	s.Body = v
	return s
}

type DeleteWebPreciseAccessRuleRequest struct {
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// An array that consists of the names of rules to delete.
	RuleNames []*string `json:"RuleNames,omitempty" xml:"RuleNames,omitempty" type:"Repeated"`
}

func (s DeleteWebPreciseAccessRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteWebPreciseAccessRuleRequest) GoString() string {
	return s.String()
}

func (s *DeleteWebPreciseAccessRuleRequest) SetDomain(v string) *DeleteWebPreciseAccessRuleRequest {
	s.Domain = &v
	return s
}

func (s *DeleteWebPreciseAccessRuleRequest) SetResourceGroupId(v string) *DeleteWebPreciseAccessRuleRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DeleteWebPreciseAccessRuleRequest) SetRuleNames(v []*string) *DeleteWebPreciseAccessRuleRequest {
	s.RuleNames = v
	return s
}

type DeleteWebPreciseAccessRuleResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteWebPreciseAccessRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteWebPreciseAccessRuleResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteWebPreciseAccessRuleResponseBody) SetRequestId(v string) *DeleteWebPreciseAccessRuleResponseBody {
	s.RequestId = &v
	return s
}

type DeleteWebPreciseAccessRuleResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteWebPreciseAccessRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteWebPreciseAccessRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteWebPreciseAccessRuleResponse) GoString() string {
	return s.String()
}

func (s *DeleteWebPreciseAccessRuleResponse) SetHeaders(v map[string]*string) *DeleteWebPreciseAccessRuleResponse {
	s.Headers = v
	return s
}

func (s *DeleteWebPreciseAccessRuleResponse) SetStatusCode(v int32) *DeleteWebPreciseAccessRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteWebPreciseAccessRuleResponse) SetBody(v *DeleteWebPreciseAccessRuleResponseBody) *DeleteWebPreciseAccessRuleResponse {
	s.Body = v
	return s
}

type DeleteWebRuleRequest struct {
	// The domain name of the website from which you want to delete the forwarding rule.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query the domain names for which forwarding rules are configured.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	//
	// For more information about resource groups, see [Create a resource group](~~94485~~).
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DeleteWebRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteWebRuleRequest) GoString() string {
	return s.String()
}

func (s *DeleteWebRuleRequest) SetDomain(v string) *DeleteWebRuleRequest {
	s.Domain = &v
	return s
}

func (s *DeleteWebRuleRequest) SetResourceGroupId(v string) *DeleteWebRuleRequest {
	s.ResourceGroupId = &v
	return s
}

type DeleteWebRuleResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteWebRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteWebRuleResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteWebRuleResponseBody) SetRequestId(v string) *DeleteWebRuleResponseBody {
	s.RequestId = &v
	return s
}

type DeleteWebRuleResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteWebRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteWebRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteWebRuleResponse) GoString() string {
	return s.String()
}

func (s *DeleteWebRuleResponse) SetHeaders(v map[string]*string) *DeleteWebRuleResponse {
	s.Headers = v
	return s
}

func (s *DeleteWebRuleResponse) SetStatusCode(v int32) *DeleteWebRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteWebRuleResponse) SetBody(v *DeleteWebRuleResponseBody) *DeleteWebRuleResponse {
	s.Body = v
	return s
}

type DescribeAsyncTasksRequest struct {
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management.
	//
	// If you do not configure this parameter, the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeAsyncTasksRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeAsyncTasksRequest) GoString() string {
	return s.String()
}

func (s *DescribeAsyncTasksRequest) SetPageNumber(v int32) *DescribeAsyncTasksRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeAsyncTasksRequest) SetPageSize(v int32) *DescribeAsyncTasksRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeAsyncTasksRequest) SetResourceGroupId(v string) *DescribeAsyncTasksRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeAsyncTasksResponseBody struct {
	// An array that consists of the details of the asynchronous export tasks.
	AsyncTasks []*DescribeAsyncTasksResponseBodyAsyncTasks `json:"AsyncTasks,omitempty" xml:"AsyncTasks,omitempty" type:"Repeated"`
	// The ID of the request, which is used to locate and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of asynchronous export tasks that are returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeAsyncTasksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeAsyncTasksResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAsyncTasksResponseBody) SetAsyncTasks(v []*DescribeAsyncTasksResponseBodyAsyncTasks) *DescribeAsyncTasksResponseBody {
	s.AsyncTasks = v
	return s
}

func (s *DescribeAsyncTasksResponseBody) SetRequestId(v string) *DescribeAsyncTasksResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeAsyncTasksResponseBody) SetTotalCount(v int32) *DescribeAsyncTasksResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeAsyncTasksResponseBodyAsyncTasks struct {
	// The end time of the task. This value is a UNIX timestamp. Unit: milliseconds.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The start time of the task. The value is a UNIX timestamp. Unit: milliseconds.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The ID of the job.
	TaskId *int64 `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The task parameter. The value is a JSON string. The returned field in the value varies based on the value of **TaskType**.
	//
	// If **TaskType** is set to **1**, **3**, **4**, **5**, or **6**, the following filed is returned:
	//
	// *   **instanceId**: the ID of the instance. Data type: string.
	//
	// If **TaskType** is set to **2**, the following field is returned:
	//
	// *   **domain**: the domain name of the website. Data type: string.
	TaskParams *string `json:"TaskParams,omitempty" xml:"TaskParams,omitempty"`
	// The execution result of the task. The value is a JSON string. The returned fields in the value vary based on the value of **TaskType**.
	//
	// If **TaskType** is set to **1**, **3**, **4**, **5**, or **6**, the following fields are returned:
	//
	// *   **instanceId**: the ID of the instance. Data type: string.
	// *   **url**: the URL to download the exported file from Object Storage Service (OSS). Data type: string.
	//
	// If **TaskType** is set to **2**, the following fields are returned:
	//
	// *   **domain**: the domain name of the website. Data type: string.
	// *   **url**: the URL to download the exported file from OSS. Data type: string.
	TaskResult *string `json:"TaskResult,omitempty" xml:"TaskResult,omitempty"`
	// The status of the task. Valid values:
	//
	// *   **0**: indicates that the task is being initialized.
	// *   **1**: indicates that the task is in progress.
	// *   **2**: indicates that the task is successful.
	// *   **3**: indicates that the task failed.
	TaskStatus *int32 `json:"TaskStatus,omitempty" xml:"TaskStatus,omitempty"`
	// The type of the task. Valid values:
	//
	// *   **1**: the task to export the port forwarding rules of an instance
	// *   **2**: the task to export the forwarding rules of a website protected by an instance
	// *   **3**: the task to export the sessions and health check settings of an instance
	// *   **4**: the task to export the mitigation policies of an instance
	// *   **5**: the task to download the blacklist for destination IP addresses of an instance
	// *   **6**: the task to download the whitelist for destination IP addresses of an instance
	TaskType *int32 `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
}

func (s DescribeAsyncTasksResponseBodyAsyncTasks) String() string {
	return tea.Prettify(s)
}

func (s DescribeAsyncTasksResponseBodyAsyncTasks) GoString() string {
	return s.String()
}

func (s *DescribeAsyncTasksResponseBodyAsyncTasks) SetEndTime(v int64) *DescribeAsyncTasksResponseBodyAsyncTasks {
	s.EndTime = &v
	return s
}

func (s *DescribeAsyncTasksResponseBodyAsyncTasks) SetStartTime(v int64) *DescribeAsyncTasksResponseBodyAsyncTasks {
	s.StartTime = &v
	return s
}

func (s *DescribeAsyncTasksResponseBodyAsyncTasks) SetTaskId(v int64) *DescribeAsyncTasksResponseBodyAsyncTasks {
	s.TaskId = &v
	return s
}

func (s *DescribeAsyncTasksResponseBodyAsyncTasks) SetTaskParams(v string) *DescribeAsyncTasksResponseBodyAsyncTasks {
	s.TaskParams = &v
	return s
}

func (s *DescribeAsyncTasksResponseBodyAsyncTasks) SetTaskResult(v string) *DescribeAsyncTasksResponseBodyAsyncTasks {
	s.TaskResult = &v
	return s
}

func (s *DescribeAsyncTasksResponseBodyAsyncTasks) SetTaskStatus(v int32) *DescribeAsyncTasksResponseBodyAsyncTasks {
	s.TaskStatus = &v
	return s
}

func (s *DescribeAsyncTasksResponseBodyAsyncTasks) SetTaskType(v int32) *DescribeAsyncTasksResponseBodyAsyncTasks {
	s.TaskType = &v
	return s
}

type DescribeAsyncTasksResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeAsyncTasksResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeAsyncTasksResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeAsyncTasksResponse) GoString() string {
	return s.String()
}

func (s *DescribeAsyncTasksResponse) SetHeaders(v map[string]*string) *DescribeAsyncTasksResponse {
	s.Headers = v
	return s
}

func (s *DescribeAsyncTasksResponse) SetStatusCode(v int32) *DescribeAsyncTasksResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAsyncTasksResponse) SetBody(v *DescribeAsyncTasksResponseBody) *DescribeAsyncTasksResponse {
	s.Body = v
	return s
}

type DescribeAttackAnalysisMaxQpsRequest struct {
	// The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeAttackAnalysisMaxQpsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeAttackAnalysisMaxQpsRequest) GoString() string {
	return s.String()
}

func (s *DescribeAttackAnalysisMaxQpsRequest) SetEndTime(v int64) *DescribeAttackAnalysisMaxQpsRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeAttackAnalysisMaxQpsRequest) SetStartTime(v int64) *DescribeAttackAnalysisMaxQpsRequest {
	s.StartTime = &v
	return s
}

type DescribeAttackAnalysisMaxQpsResponseBody struct {
	// The peak queries per second (QPS) of DDoS attacks. Units: QPS.
	Qps *int64 `json:"Qps,omitempty" xml:"Qps,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeAttackAnalysisMaxQpsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeAttackAnalysisMaxQpsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAttackAnalysisMaxQpsResponseBody) SetQps(v int64) *DescribeAttackAnalysisMaxQpsResponseBody {
	s.Qps = &v
	return s
}

func (s *DescribeAttackAnalysisMaxQpsResponseBody) SetRequestId(v string) *DescribeAttackAnalysisMaxQpsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeAttackAnalysisMaxQpsResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeAttackAnalysisMaxQpsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeAttackAnalysisMaxQpsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeAttackAnalysisMaxQpsResponse) GoString() string {
	return s.String()
}

func (s *DescribeAttackAnalysisMaxQpsResponse) SetHeaders(v map[string]*string) *DescribeAttackAnalysisMaxQpsResponse {
	s.Headers = v
	return s
}

func (s *DescribeAttackAnalysisMaxQpsResponse) SetStatusCode(v int32) *DescribeAttackAnalysisMaxQpsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAttackAnalysisMaxQpsResponse) SetBody(v *DescribeAttackAnalysisMaxQpsResponseBody) *DescribeAttackAnalysisMaxQpsResponse {
	s.Body = v
	return s
}

type DescribeAutoCcBlacklistRequest struct {
	// The ID of the instance.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The keyword for the query. This keyword is used to specify the prefix of the source IP address that you want to query.
	//
	// > The keyword must be greater than three characters in length.
	KeyWord *string `json:"KeyWord,omitempty" xml:"KeyWord,omitempty"`
	// The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribeAutoCcBlacklistRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeAutoCcBlacklistRequest) GoString() string {
	return s.String()
}

func (s *DescribeAutoCcBlacklistRequest) SetInstanceId(v string) *DescribeAutoCcBlacklistRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeAutoCcBlacklistRequest) SetKeyWord(v string) *DescribeAutoCcBlacklistRequest {
	s.KeyWord = &v
	return s
}

func (s *DescribeAutoCcBlacklistRequest) SetPageNumber(v int32) *DescribeAutoCcBlacklistRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeAutoCcBlacklistRequest) SetPageSize(v int32) *DescribeAutoCcBlacklistRequest {
	s.PageSize = &v
	return s
}

type DescribeAutoCcBlacklistResponseBody struct {
	// An array that consists of the details of the IP addresses in the blacklist of the instance.
	AutoCcBlacklist []*DescribeAutoCcBlacklistResponseBodyAutoCcBlacklist `json:"AutoCcBlacklist,omitempty" xml:"AutoCcBlacklist,omitempty" type:"Repeated"`
	// The ID of the request, which is used to locate and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of returned IP addresses in the blacklist.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeAutoCcBlacklistResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeAutoCcBlacklistResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAutoCcBlacklistResponseBody) SetAutoCcBlacklist(v []*DescribeAutoCcBlacklistResponseBodyAutoCcBlacklist) *DescribeAutoCcBlacklistResponseBody {
	s.AutoCcBlacklist = v
	return s
}

func (s *DescribeAutoCcBlacklistResponseBody) SetRequestId(v string) *DescribeAutoCcBlacklistResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeAutoCcBlacklistResponseBody) SetTotalCount(v int64) *DescribeAutoCcBlacklistResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeAutoCcBlacklistResponseBodyAutoCcBlacklist struct {
	// The IP address of the instance.
	DestIp *string `json:"DestIp,omitempty" xml:"DestIp,omitempty"`
	// The validity period of the IP address in the blacklist. The value is a UNIX timestamp. Unit: seconds.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The IP address in the blacklist.
	SourceIp *string `json:"SourceIp,omitempty" xml:"SourceIp,omitempty"`
	// The mode of how the IP address is added to the blacklist. Valid values:
	//
	// *   **manual**: manually added
	// *   **auto**: automatically added
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeAutoCcBlacklistResponseBodyAutoCcBlacklist) String() string {
	return tea.Prettify(s)
}

func (s DescribeAutoCcBlacklistResponseBodyAutoCcBlacklist) GoString() string {
	return s.String()
}

func (s *DescribeAutoCcBlacklistResponseBodyAutoCcBlacklist) SetDestIp(v string) *DescribeAutoCcBlacklistResponseBodyAutoCcBlacklist {
	s.DestIp = &v
	return s
}

func (s *DescribeAutoCcBlacklistResponseBodyAutoCcBlacklist) SetEndTime(v int64) *DescribeAutoCcBlacklistResponseBodyAutoCcBlacklist {
	s.EndTime = &v
	return s
}

func (s *DescribeAutoCcBlacklistResponseBodyAutoCcBlacklist) SetSourceIp(v string) *DescribeAutoCcBlacklistResponseBodyAutoCcBlacklist {
	s.SourceIp = &v
	return s
}

func (s *DescribeAutoCcBlacklistResponseBodyAutoCcBlacklist) SetType(v string) *DescribeAutoCcBlacklistResponseBodyAutoCcBlacklist {
	s.Type = &v
	return s
}

type DescribeAutoCcBlacklistResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeAutoCcBlacklistResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeAutoCcBlacklistResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeAutoCcBlacklistResponse) GoString() string {
	return s.String()
}

func (s *DescribeAutoCcBlacklistResponse) SetHeaders(v map[string]*string) *DescribeAutoCcBlacklistResponse {
	s.Headers = v
	return s
}

func (s *DescribeAutoCcBlacklistResponse) SetStatusCode(v int32) *DescribeAutoCcBlacklistResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAutoCcBlacklistResponse) SetBody(v *DescribeAutoCcBlacklistResponseBody) *DescribeAutoCcBlacklistResponse {
	s.Body = v
	return s
}

type DescribeAutoCcListCountRequest struct {
	// The ID of the instance.
	//
	// > You can call the **DescribeInstanceIds** operation to query the IDs of all instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The mode of how an IP address is added to the whitelist or blacklist. Valid values:
	//
	// *   **manual**: manually added
	// *   **auto**: automatically added
	QueryType *string `json:"QueryType,omitempty" xml:"QueryType,omitempty"`
}

func (s DescribeAutoCcListCountRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeAutoCcListCountRequest) GoString() string {
	return s.String()
}

func (s *DescribeAutoCcListCountRequest) SetInstanceId(v string) *DescribeAutoCcListCountRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeAutoCcListCountRequest) SetQueryType(v string) *DescribeAutoCcListCountRequest {
	s.QueryType = &v
	return s
}

type DescribeAutoCcListCountResponseBody struct {
	// The total number of IP addresses in the blacklist.
	BlackCount *int32 `json:"BlackCount,omitempty" xml:"BlackCount,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of IP addresses in the whitelist.
	WhiteCount *int32 `json:"WhiteCount,omitempty" xml:"WhiteCount,omitempty"`
}

func (s DescribeAutoCcListCountResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeAutoCcListCountResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAutoCcListCountResponseBody) SetBlackCount(v int32) *DescribeAutoCcListCountResponseBody {
	s.BlackCount = &v
	return s
}

func (s *DescribeAutoCcListCountResponseBody) SetRequestId(v string) *DescribeAutoCcListCountResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeAutoCcListCountResponseBody) SetWhiteCount(v int32) *DescribeAutoCcListCountResponseBody {
	s.WhiteCount = &v
	return s
}

type DescribeAutoCcListCountResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeAutoCcListCountResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeAutoCcListCountResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeAutoCcListCountResponse) GoString() string {
	return s.String()
}

func (s *DescribeAutoCcListCountResponse) SetHeaders(v map[string]*string) *DescribeAutoCcListCountResponse {
	s.Headers = v
	return s
}

func (s *DescribeAutoCcListCountResponse) SetStatusCode(v int32) *DescribeAutoCcListCountResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAutoCcListCountResponse) SetBody(v *DescribeAutoCcListCountResponseBody) *DescribeAutoCcListCountResponse {
	s.Body = v
	return s
}

type DescribeAutoCcWhitelistRequest struct {
	// The ID of the instance.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The keyword for the query. This keyword is used to specify the prefix of the source IP address that you want to query.
	//
	// > The keyword must be greater than three characters in length.
	KeyWord *string `json:"KeyWord,omitempty" xml:"KeyWord,omitempty"`
	// The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribeAutoCcWhitelistRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeAutoCcWhitelistRequest) GoString() string {
	return s.String()
}

func (s *DescribeAutoCcWhitelistRequest) SetInstanceId(v string) *DescribeAutoCcWhitelistRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeAutoCcWhitelistRequest) SetKeyWord(v string) *DescribeAutoCcWhitelistRequest {
	s.KeyWord = &v
	return s
}

func (s *DescribeAutoCcWhitelistRequest) SetPageNumber(v int32) *DescribeAutoCcWhitelistRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeAutoCcWhitelistRequest) SetPageSize(v int32) *DescribeAutoCcWhitelistRequest {
	s.PageSize = &v
	return s
}

type DescribeAutoCcWhitelistResponseBody struct {
	// An array that consists of details of the IP address in the whitelist of the instance.
	AutoCcWhitelist []*DescribeAutoCcWhitelistResponseBodyAutoCcWhitelist `json:"AutoCcWhitelist,omitempty" xml:"AutoCcWhitelist,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of returned IP addresses in the whitelist.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeAutoCcWhitelistResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeAutoCcWhitelistResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAutoCcWhitelistResponseBody) SetAutoCcWhitelist(v []*DescribeAutoCcWhitelistResponseBodyAutoCcWhitelist) *DescribeAutoCcWhitelistResponseBody {
	s.AutoCcWhitelist = v
	return s
}

func (s *DescribeAutoCcWhitelistResponseBody) SetRequestId(v string) *DescribeAutoCcWhitelistResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeAutoCcWhitelistResponseBody) SetTotalCount(v int64) *DescribeAutoCcWhitelistResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeAutoCcWhitelistResponseBodyAutoCcWhitelist struct {
	// The IP address of the instance.
	DestIp *string `json:"DestIp,omitempty" xml:"DestIp,omitempty"`
	// The validity period of the IP address in the whitelist. Unit: seconds. **0** indicates that the IP address in the whitelist never expires.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The IP addresses that is contained in the IP address whitelist.
	SourceIp *string `json:"SourceIp,omitempty" xml:"SourceIp,omitempty"`
	// The mode of how an IP address is added to the whitelist. Valid values:
	//
	// *   **manual**: manually added
	// *   **auto**: automatically added
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeAutoCcWhitelistResponseBodyAutoCcWhitelist) String() string {
	return tea.Prettify(s)
}

func (s DescribeAutoCcWhitelistResponseBodyAutoCcWhitelist) GoString() string {
	return s.String()
}

func (s *DescribeAutoCcWhitelistResponseBodyAutoCcWhitelist) SetDestIp(v string) *DescribeAutoCcWhitelistResponseBodyAutoCcWhitelist {
	s.DestIp = &v
	return s
}

func (s *DescribeAutoCcWhitelistResponseBodyAutoCcWhitelist) SetEndTime(v int64) *DescribeAutoCcWhitelistResponseBodyAutoCcWhitelist {
	s.EndTime = &v
	return s
}

func (s *DescribeAutoCcWhitelistResponseBodyAutoCcWhitelist) SetSourceIp(v string) *DescribeAutoCcWhitelistResponseBodyAutoCcWhitelist {
	s.SourceIp = &v
	return s
}

func (s *DescribeAutoCcWhitelistResponseBodyAutoCcWhitelist) SetType(v string) *DescribeAutoCcWhitelistResponseBodyAutoCcWhitelist {
	s.Type = &v
	return s
}

type DescribeAutoCcWhitelistResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeAutoCcWhitelistResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeAutoCcWhitelistResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeAutoCcWhitelistResponse) GoString() string {
	return s.String()
}

func (s *DescribeAutoCcWhitelistResponse) SetHeaders(v map[string]*string) *DescribeAutoCcWhitelistResponse {
	s.Headers = v
	return s
}

func (s *DescribeAutoCcWhitelistResponse) SetStatusCode(v int32) *DescribeAutoCcWhitelistResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAutoCcWhitelistResponse) SetBody(v *DescribeAutoCcWhitelistResponseBody) *DescribeAutoCcWhitelistResponse {
	s.Body = v
	return s
}

type DescribeBackSourceCidrRequest struct {
	// The IP version of the back-to-origin CIDR block.
	//
	// *   **Ipv4**
	// *   **Ipv6**
	IpVersion *string `json:"IpVersion,omitempty" xml:"IpVersion,omitempty"`
	// The Internet service provider (ISP) line that you want to query.
	Line *string `json:"Line,omitempty" xml:"Line,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeBackSourceCidrRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeBackSourceCidrRequest) GoString() string {
	return s.String()
}

func (s *DescribeBackSourceCidrRequest) SetIpVersion(v string) *DescribeBackSourceCidrRequest {
	s.IpVersion = &v
	return s
}

func (s *DescribeBackSourceCidrRequest) SetLine(v string) *DescribeBackSourceCidrRequest {
	s.Line = &v
	return s
}

func (s *DescribeBackSourceCidrRequest) SetResourceGroupId(v string) *DescribeBackSourceCidrRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeBackSourceCidrResponseBody struct {
	// An array that consists of the back-to-origin CIDR blocks of the instance.
	Cidrs []*string `json:"Cidrs,omitempty" xml:"Cidrs,omitempty" type:"Repeated"`
	// The ID of the request, which is used to locate and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeBackSourceCidrResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeBackSourceCidrResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeBackSourceCidrResponseBody) SetCidrs(v []*string) *DescribeBackSourceCidrResponseBody {
	s.Cidrs = v
	return s
}

func (s *DescribeBackSourceCidrResponseBody) SetRequestId(v string) *DescribeBackSourceCidrResponseBody {
	s.RequestId = &v
	return s
}

type DescribeBackSourceCidrResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeBackSourceCidrResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeBackSourceCidrResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeBackSourceCidrResponse) GoString() string {
	return s.String()
}

func (s *DescribeBackSourceCidrResponse) SetHeaders(v map[string]*string) *DescribeBackSourceCidrResponse {
	s.Headers = v
	return s
}

func (s *DescribeBackSourceCidrResponse) SetStatusCode(v int32) *DescribeBackSourceCidrResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeBackSourceCidrResponse) SetBody(v *DescribeBackSourceCidrResponseBody) *DescribeBackSourceCidrResponse {
	s.Body = v
	return s
}

type DescribeBlackholeStatusRequest struct {
	// The ID of the instance.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
}

func (s DescribeBlackholeStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeBlackholeStatusRequest) GoString() string {
	return s.String()
}

func (s *DescribeBlackholeStatusRequest) SetInstanceIds(v []*string) *DescribeBlackholeStatusRequest {
	s.InstanceIds = v
	return s
}

type DescribeBlackholeStatusResponseBody struct {
	// An array that consists of the blackhole filtering status of the instance.
	BlackholeStatus []*DescribeBlackholeStatusResponseBodyBlackholeStatus `json:"BlackholeStatus,omitempty" xml:"BlackholeStatus,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeBlackholeStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeBlackholeStatusResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeBlackholeStatusResponseBody) SetBlackholeStatus(v []*DescribeBlackholeStatusResponseBodyBlackholeStatus) *DescribeBlackholeStatusResponseBody {
	s.BlackholeStatus = v
	return s
}

func (s *DescribeBlackholeStatusResponseBody) SetRequestId(v string) *DescribeBlackholeStatusResponseBody {
	s.RequestId = &v
	return s
}

type DescribeBlackholeStatusResponseBodyBlackholeStatus struct {
	// Indicates whether blackhole filtering is triggered for the instance. Valid values:
	//
	// *   **blackhole**: yes
	// *   **normal**: no
	BlackStatus *string `json:"BlackStatus,omitempty" xml:"BlackStatus,omitempty"`
	// The end time of blackhole filtering. The value is a UNIX timestamp. Unit: seconds.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The IP address of the instance.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The start time of blackhole filtering. The value is a UNIX timestamp. Unit: seconds.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeBlackholeStatusResponseBodyBlackholeStatus) String() string {
	return tea.Prettify(s)
}

func (s DescribeBlackholeStatusResponseBodyBlackholeStatus) GoString() string {
	return s.String()
}

func (s *DescribeBlackholeStatusResponseBodyBlackholeStatus) SetBlackStatus(v string) *DescribeBlackholeStatusResponseBodyBlackholeStatus {
	s.BlackStatus = &v
	return s
}

func (s *DescribeBlackholeStatusResponseBodyBlackholeStatus) SetEndTime(v int64) *DescribeBlackholeStatusResponseBodyBlackholeStatus {
	s.EndTime = &v
	return s
}

func (s *DescribeBlackholeStatusResponseBodyBlackholeStatus) SetIp(v string) *DescribeBlackholeStatusResponseBodyBlackholeStatus {
	s.Ip = &v
	return s
}

func (s *DescribeBlackholeStatusResponseBodyBlackholeStatus) SetStartTime(v int64) *DescribeBlackholeStatusResponseBodyBlackholeStatus {
	s.StartTime = &v
	return s
}

type DescribeBlackholeStatusResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeBlackholeStatusResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeBlackholeStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeBlackholeStatusResponse) GoString() string {
	return s.String()
}

func (s *DescribeBlackholeStatusResponse) SetHeaders(v map[string]*string) *DescribeBlackholeStatusResponse {
	s.Headers = v
	return s
}

func (s *DescribeBlackholeStatusResponse) SetStatusCode(v int32) *DescribeBlackholeStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeBlackholeStatusResponse) SetBody(v *DescribeBlackholeStatusResponseBody) *DescribeBlackholeStatusResponse {
	s.Body = v
	return s
}

type DescribeBlockStatusRequest struct {
	// An array consisting of information about the IDs of the instances that you want to query.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	// The ID of the resource group to which the instance belongs in Resource Management.
	//
	// If you do not configure this parameter, the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeBlockStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeBlockStatusRequest) GoString() string {
	return s.String()
}

func (s *DescribeBlockStatusRequest) SetInstanceIds(v []*string) *DescribeBlockStatusRequest {
	s.InstanceIds = v
	return s
}

func (s *DescribeBlockStatusRequest) SetResourceGroupId(v string) *DescribeBlockStatusRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeBlockStatusResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// An array that consists of details of the Diversion from Origin Server configurations of the instance.
	StatusList []*DescribeBlockStatusResponseBodyStatusList `json:"StatusList,omitempty" xml:"StatusList,omitempty" type:"Repeated"`
}

func (s DescribeBlockStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeBlockStatusResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeBlockStatusResponseBody) SetRequestId(v string) *DescribeBlockStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeBlockStatusResponseBody) SetStatusList(v []*DescribeBlockStatusResponseBodyStatusList) *DescribeBlockStatusResponseBody {
	s.StatusList = v
	return s
}

type DescribeBlockStatusResponseBodyStatusList struct {
	// An array that consists of details of the Diversion from Origin Server configuration.
	BlockStatusList []*DescribeBlockStatusResponseBodyStatusListBlockStatusList `json:"BlockStatusList,omitempty" xml:"BlockStatusList,omitempty" type:"Repeated"`
	// The IP address of the instance.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
}

func (s DescribeBlockStatusResponseBodyStatusList) String() string {
	return tea.Prettify(s)
}

func (s DescribeBlockStatusResponseBodyStatusList) GoString() string {
	return s.String()
}

func (s *DescribeBlockStatusResponseBodyStatusList) SetBlockStatusList(v []*DescribeBlockStatusResponseBodyStatusListBlockStatusList) *DescribeBlockStatusResponseBodyStatusList {
	s.BlockStatusList = v
	return s
}

func (s *DescribeBlockStatusResponseBodyStatusList) SetIp(v string) *DescribeBlockStatusResponseBodyStatusList {
	s.Ip = &v
	return s
}

type DescribeBlockStatusResponseBodyStatusListBlockStatusList struct {
	// The blocking status of the network traffic. Valid values:
	//
	// *   **areablock**: Network traffic is blocked.
	// *   **normal**: Network traffic is not blocked.
	BlockStatus *string `json:"BlockStatus,omitempty" xml:"BlockStatus,omitempty"`
	// The end time of the blocking. This value is a UNIX timestamp. Unit: seconds.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The Internet service provider (ISP) line from which the traffic is blocked. Valid values:
	//
	// *   **ct**: China Telecom (International)
	// *   **cut**: China Unicom (International)
	Line *string `json:"Line,omitempty" xml:"Line,omitempty"`
	// The start time of the blocking. This value is a UNIX timestamp. Unit: seconds.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeBlockStatusResponseBodyStatusListBlockStatusList) String() string {
	return tea.Prettify(s)
}

func (s DescribeBlockStatusResponseBodyStatusListBlockStatusList) GoString() string {
	return s.String()
}

func (s *DescribeBlockStatusResponseBodyStatusListBlockStatusList) SetBlockStatus(v string) *DescribeBlockStatusResponseBodyStatusListBlockStatusList {
	s.BlockStatus = &v
	return s
}

func (s *DescribeBlockStatusResponseBodyStatusListBlockStatusList) SetEndTime(v int64) *DescribeBlockStatusResponseBodyStatusListBlockStatusList {
	s.EndTime = &v
	return s
}

func (s *DescribeBlockStatusResponseBodyStatusListBlockStatusList) SetLine(v string) *DescribeBlockStatusResponseBodyStatusListBlockStatusList {
	s.Line = &v
	return s
}

func (s *DescribeBlockStatusResponseBodyStatusListBlockStatusList) SetStartTime(v int64) *DescribeBlockStatusResponseBodyStatusListBlockStatusList {
	s.StartTime = &v
	return s
}

type DescribeBlockStatusResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeBlockStatusResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeBlockStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeBlockStatusResponse) GoString() string {
	return s.String()
}

func (s *DescribeBlockStatusResponse) SetHeaders(v map[string]*string) *DescribeBlockStatusResponse {
	s.Headers = v
	return s
}

func (s *DescribeBlockStatusResponse) SetStatusCode(v int32) *DescribeBlockStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeBlockStatusResponse) SetBody(v *DescribeBlockStatusResponseBody) *DescribeBlockStatusResponse {
	s.Body = v
	return s
}

type DescribeCertsRequest struct {
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeCertsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCertsRequest) GoString() string {
	return s.String()
}

func (s *DescribeCertsRequest) SetDomain(v string) *DescribeCertsRequest {
	s.Domain = &v
	return s
}

func (s *DescribeCertsRequest) SetResourceGroupId(v string) *DescribeCertsRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeCertsResponseBody struct {
	// The certificate information about the website.
	Certs []*DescribeCertsResponseBodyCerts `json:"Certs,omitempty" xml:"Certs,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCertsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCertsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCertsResponseBody) SetCerts(v []*DescribeCertsResponseBodyCerts) *DescribeCertsResponseBody {
	s.Certs = v
	return s
}

func (s *DescribeCertsResponseBody) SetRequestId(v string) *DescribeCertsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCertsResponseBodyCerts struct {
	CertIdentifier *string `json:"CertIdentifier,omitempty" xml:"CertIdentifier,omitempty"`
	// The domain name that is associated with the certificate.
	Common *string `json:"Common,omitempty" xml:"Common,omitempty"`
	// Indicates whether the certificate is associated with the domain name. Valid values:
	//
	// *   **true**: The certificate is associated with the domain name.
	// *   **false**: The certificate is not associated with the domain name.
	DomainRelated *bool `json:"DomainRelated,omitempty" xml:"DomainRelated,omitempty"`
	// The expiration date of the certificate. string
	EndDate *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	// The ID of the certificate.
	Id *int32 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The certificate authority (CA) that issued the certificate.
	Issuer *string `json:"Issuer,omitempty" xml:"Issuer,omitempty"`
	// The name of the certificate.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The issuance date of the certificate. string
	StartDate *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
}

func (s DescribeCertsResponseBodyCerts) String() string {
	return tea.Prettify(s)
}

func (s DescribeCertsResponseBodyCerts) GoString() string {
	return s.String()
}

func (s *DescribeCertsResponseBodyCerts) SetCertIdentifier(v string) *DescribeCertsResponseBodyCerts {
	s.CertIdentifier = &v
	return s
}

func (s *DescribeCertsResponseBodyCerts) SetCommon(v string) *DescribeCertsResponseBodyCerts {
	s.Common = &v
	return s
}

func (s *DescribeCertsResponseBodyCerts) SetDomainRelated(v bool) *DescribeCertsResponseBodyCerts {
	s.DomainRelated = &v
	return s
}

func (s *DescribeCertsResponseBodyCerts) SetEndDate(v string) *DescribeCertsResponseBodyCerts {
	s.EndDate = &v
	return s
}

func (s *DescribeCertsResponseBodyCerts) SetId(v int32) *DescribeCertsResponseBodyCerts {
	s.Id = &v
	return s
}

func (s *DescribeCertsResponseBodyCerts) SetIssuer(v string) *DescribeCertsResponseBodyCerts {
	s.Issuer = &v
	return s
}

func (s *DescribeCertsResponseBodyCerts) SetName(v string) *DescribeCertsResponseBodyCerts {
	s.Name = &v
	return s
}

func (s *DescribeCertsResponseBodyCerts) SetStartDate(v string) *DescribeCertsResponseBodyCerts {
	s.StartDate = &v
	return s
}

type DescribeCertsResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeCertsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeCertsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCertsResponse) GoString() string {
	return s.String()
}

func (s *DescribeCertsResponse) SetHeaders(v map[string]*string) *DescribeCertsResponse {
	s.Headers = v
	return s
}

func (s *DescribeCertsResponse) SetStatusCode(v int32) *DescribeCertsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCertsResponse) SetBody(v *DescribeCertsResponseBody) *DescribeCertsResponse {
	s.Body = v
	return s
}

type DescribeCnameReusesRequest struct {
	Domains         []*string `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Repeated"`
	ResourceGroupId *string   `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeCnameReusesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCnameReusesRequest) GoString() string {
	return s.String()
}

func (s *DescribeCnameReusesRequest) SetDomains(v []*string) *DescribeCnameReusesRequest {
	s.Domains = v
	return s
}

func (s *DescribeCnameReusesRequest) SetResourceGroupId(v string) *DescribeCnameReusesRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeCnameReusesResponseBody struct {
	CnameReuses []*DescribeCnameReusesResponseBodyCnameReuses `json:"CnameReuses,omitempty" xml:"CnameReuses,omitempty" type:"Repeated"`
	RequestId   *string                                       `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCnameReusesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCnameReusesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCnameReusesResponseBody) SetCnameReuses(v []*DescribeCnameReusesResponseBodyCnameReuses) *DescribeCnameReusesResponseBody {
	s.CnameReuses = v
	return s
}

func (s *DescribeCnameReusesResponseBody) SetRequestId(v string) *DescribeCnameReusesResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCnameReusesResponseBodyCnameReuses struct {
	Cname  *string `json:"Cname,omitempty" xml:"Cname,omitempty"`
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	Enable *int32  `json:"Enable,omitempty" xml:"Enable,omitempty"`
}

func (s DescribeCnameReusesResponseBodyCnameReuses) String() string {
	return tea.Prettify(s)
}

func (s DescribeCnameReusesResponseBodyCnameReuses) GoString() string {
	return s.String()
}

func (s *DescribeCnameReusesResponseBodyCnameReuses) SetCname(v string) *DescribeCnameReusesResponseBodyCnameReuses {
	s.Cname = &v
	return s
}

func (s *DescribeCnameReusesResponseBodyCnameReuses) SetDomain(v string) *DescribeCnameReusesResponseBodyCnameReuses {
	s.Domain = &v
	return s
}

func (s *DescribeCnameReusesResponseBodyCnameReuses) SetEnable(v int32) *DescribeCnameReusesResponseBodyCnameReuses {
	s.Enable = &v
	return s
}

type DescribeCnameReusesResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeCnameReusesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeCnameReusesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCnameReusesResponse) GoString() string {
	return s.String()
}

func (s *DescribeCnameReusesResponse) SetHeaders(v map[string]*string) *DescribeCnameReusesResponse {
	s.Headers = v
	return s
}

func (s *DescribeCnameReusesResponse) SetStatusCode(v int32) *DescribeCnameReusesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCnameReusesResponse) SetBody(v *DescribeCnameReusesResponseBody) *DescribeCnameReusesResponse {
	s.Body = v
	return s
}

type DescribeDDoSEventsRequest struct {
	// The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the instance.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	// The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDDoSEventsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDDoSEventsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDDoSEventsRequest) SetEndTime(v int64) *DescribeDDoSEventsRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDDoSEventsRequest) SetInstanceIds(v []*string) *DescribeDDoSEventsRequest {
	s.InstanceIds = v
	return s
}

func (s *DescribeDDoSEventsRequest) SetPageNumber(v int32) *DescribeDDoSEventsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDDoSEventsRequest) SetPageSize(v int32) *DescribeDDoSEventsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDDoSEventsRequest) SetResourceGroupId(v string) *DescribeDDoSEventsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDDoSEventsRequest) SetStartTime(v int64) *DescribeDDoSEventsRequest {
	s.StartTime = &v
	return s
}

type DescribeDDoSEventsResponseBody struct {
	// The DDoS attack events.
	DDoSEvents []*DescribeDDoSEventsResponseBodyDDoSEvents `json:"DDoSEvents,omitempty" xml:"DDoSEvents,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of returned attack events.
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s DescribeDDoSEventsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDDoSEventsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDDoSEventsResponseBody) SetDDoSEvents(v []*DescribeDDoSEventsResponseBodyDDoSEvents) *DescribeDDoSEventsResponseBody {
	s.DDoSEvents = v
	return s
}

func (s *DescribeDDoSEventsResponseBody) SetRequestId(v string) *DescribeDDoSEventsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDDoSEventsResponseBody) SetTotal(v int64) *DescribeDDoSEventsResponseBody {
	s.Total = &v
	return s
}

type DescribeDDoSEventsResponseBodyDDoSEvents struct {
	// The bandwidth of attack traffic. Unit: bit/s.
	Bps *int64 `json:"Bps,omitempty" xml:"Bps,omitempty"`
	// The time when the DDoS attack stopped. The value is a UNIX timestamp. Unit: seconds.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The type of the attack event. Valid values:
	//
	// *   **defense**: traffic scrubbing events
	// *   **blackhole**: blackhole filtering events
	EventType *string `json:"EventType,omitempty" xml:"EventType,omitempty"`
	// The attacked IP address.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The attacked port.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The packet forwarding rate of attack traffic. Unit: packets per second (pps).
	Pps *int64 `json:"Pps,omitempty" xml:"Pps,omitempty"`
	// The region from which the attack was launched. Valid values:
	//
	// *   **cn**: a region in the Chinese mainland
	// *   **alb-ap-northeast-1-gf-x**: Japan (Tokyo)
	// *   **alb-ap-southeast-gf-x**: Singapore
	// *   **alb-cn-hongkong-gf-x**: Hong Kong (China)
	// *   **alb-eu-central-1-gf-x**: Germany (Frankfurt)
	// *   **alb-us-west-1-gf-x**: US (Silicon Valley)
	//
	// > The values except **cn** are returned only when **RegionId** is set to **ap-southeast-1**.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The time when the DDoS attack started. The value is a UNIX timestamp. Unit: seconds.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDDoSEventsResponseBodyDDoSEvents) String() string {
	return tea.Prettify(s)
}

func (s DescribeDDoSEventsResponseBodyDDoSEvents) GoString() string {
	return s.String()
}

func (s *DescribeDDoSEventsResponseBodyDDoSEvents) SetBps(v int64) *DescribeDDoSEventsResponseBodyDDoSEvents {
	s.Bps = &v
	return s
}

func (s *DescribeDDoSEventsResponseBodyDDoSEvents) SetEndTime(v int64) *DescribeDDoSEventsResponseBodyDDoSEvents {
	s.EndTime = &v
	return s
}

func (s *DescribeDDoSEventsResponseBodyDDoSEvents) SetEventType(v string) *DescribeDDoSEventsResponseBodyDDoSEvents {
	s.EventType = &v
	return s
}

func (s *DescribeDDoSEventsResponseBodyDDoSEvents) SetIp(v string) *DescribeDDoSEventsResponseBodyDDoSEvents {
	s.Ip = &v
	return s
}

func (s *DescribeDDoSEventsResponseBodyDDoSEvents) SetPort(v string) *DescribeDDoSEventsResponseBodyDDoSEvents {
	s.Port = &v
	return s
}

func (s *DescribeDDoSEventsResponseBodyDDoSEvents) SetPps(v int64) *DescribeDDoSEventsResponseBodyDDoSEvents {
	s.Pps = &v
	return s
}

func (s *DescribeDDoSEventsResponseBodyDDoSEvents) SetRegion(v string) *DescribeDDoSEventsResponseBodyDDoSEvents {
	s.Region = &v
	return s
}

func (s *DescribeDDoSEventsResponseBodyDDoSEvents) SetStartTime(v int64) *DescribeDDoSEventsResponseBodyDDoSEvents {
	s.StartTime = &v
	return s
}

type DescribeDDoSEventsResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeDDoSEventsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeDDoSEventsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDDoSEventsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDDoSEventsResponse) SetHeaders(v map[string]*string) *DescribeDDoSEventsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDDoSEventsResponse) SetStatusCode(v int32) *DescribeDDoSEventsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDDoSEventsResponse) SetBody(v *DescribeDDoSEventsResponseBody) *DescribeDDoSEventsResponse {
	s.Body = v
	return s
}

type DescribeDDosAllEventListRequest struct {
	// The end of the time range to query. The DDoS attack events occur before **EndTime** are queried. This value is a UNIX timestamp. Unit: seconds.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The type of the DDoS attack events you want to query. Valid values:
	//
	// *   **web-cc**: resource exhaustion attacks
	// *   **cc**: connection flood attacks
	// *   **defense**: DDoS attacks that trigger traffic scrubbing
	// *   **blackhole**: DDoS attacks that trigger blackhole filtering
	//
	// If you want to query multiple types of DDoS attack events, separate them with commas (,).
	//
	// If you do not configure this parameter, DDoS attack events of all types are queried.
	EventType *string `json:"EventType,omitempty" xml:"EventType,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The beginning of the time range to query. The DDoS attack events occur after **StartTime** are queried. This value is a UNIX timestamp. Unit: seconds.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDDosAllEventListRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDDosAllEventListRequest) GoString() string {
	return s.String()
}

func (s *DescribeDDosAllEventListRequest) SetEndTime(v int64) *DescribeDDosAllEventListRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDDosAllEventListRequest) SetEventType(v string) *DescribeDDosAllEventListRequest {
	s.EventType = &v
	return s
}

func (s *DescribeDDosAllEventListRequest) SetPageNumber(v int32) *DescribeDDosAllEventListRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDDosAllEventListRequest) SetPageSize(v int32) *DescribeDDosAllEventListRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDDosAllEventListRequest) SetStartTime(v int64) *DescribeDDosAllEventListRequest {
	s.StartTime = &v
	return s
}

type DescribeDDosAllEventListResponseBody struct {
	// An array that consists of attack events.
	AttackEvents []*DescribeDDosAllEventListResponseBodyAttackEvents `json:"AttackEvents,omitempty" xml:"AttackEvents,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of DDoS attack events.
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s DescribeDDosAllEventListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDDosAllEventListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDDosAllEventListResponseBody) SetAttackEvents(v []*DescribeDDosAllEventListResponseBodyAttackEvents) *DescribeDDosAllEventListResponseBody {
	s.AttackEvents = v
	return s
}

func (s *DescribeDDosAllEventListResponseBody) SetRequestId(v string) *DescribeDDosAllEventListResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDDosAllEventListResponseBody) SetTotal(v int64) *DescribeDDosAllEventListResponseBody {
	s.Total = &v
	return s
}

type DescribeDDosAllEventListResponseBodyAttackEvents struct {
	// The source location or region from which the attack was initiated. Valid values:
	//
	// *   **cn**: Chinese mainland
	// *   **alb-cn-hongkong-gf-2**: China (Hongkong)
	// *   **alb-us-west-1-gf-2**: US (Silicon Valley)
	// *   **alb-ap-northeast-1-gf-1**: Japan (Tokyo)
	// *   **alb-ap-southeast-gf-1**: Singapore
	// *   **alb-eu-central-1-gf-1**: Germany (Frankfurt)
	// *   **alb-eu-central-1-gf-1** or **selb-eu-west-1-gf-1a**: UK (London)
	// *   **alb-us-east-gf-1**: US (Virginia)
	// *   **CT-yundi**: China (Hongkong) This value is returned only for Anti-DDoS Premium instances of the Secure Chinese Mainland Acceleration (Sec-CMA) mitigation plan.
	Area *string `json:"Area,omitempty" xml:"Area,omitempty"`
	// The time when the DDoS attack stopped. This value is a UNIX timestamp. Unit: seconds.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The type of the DDoS attack event. Valid values:
	//
	// *   **web-cc**: resource exhaustion attacks
	// *   **cc**: connection flood attacks
	// *   **defense**: DDoS attacks that trigger traffic scrubbing
	// *   **blackhole**: DDoS attacks that trigger blackhole filtering
	EventType *string `json:"EventType,omitempty" xml:"EventType,omitempty"`
	// The attacked object. The attacked object varies based on the attack event type. The following list describes different attacked objects of different attack event types:
	//
	// *   If **EventType** is set to **web-cc**, the value of this parameter indicates the domain name of the attacked website.
	// *   If **EventType** is set to **cc**, the value of this parameter indicates the IP address of the attacked Anti-DDoS Pro or Anti-DDoS Premium instance.
	// *   If **EventType** is set to **defense** or **blackhole**, the value of this parameter indicates the IP address of the attacked Anti-DDoS Pro or Anti-DDoS Premium instance.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The peak bandwidth of the attack traffic. Unit: Mbit/s.
	Mbps *int64 `json:"Mbps,omitempty" xml:"Mbps,omitempty"`
	// The attacked port.
	//
	// > If **EventType** is set to **web-cc**, this parameter is not returned.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The peak packet forwarding rate of attack traffic. Unit: packets per second (pps).
	Pps *int64 `json:"Pps,omitempty" xml:"Pps,omitempty"`
	// The time when the DDoS attack started. This value is a UNIX timestamp. Unit: seconds.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDDosAllEventListResponseBodyAttackEvents) String() string {
	return tea.Prettify(s)
}

func (s DescribeDDosAllEventListResponseBodyAttackEvents) GoString() string {
	return s.String()
}

func (s *DescribeDDosAllEventListResponseBodyAttackEvents) SetArea(v string) *DescribeDDosAllEventListResponseBodyAttackEvents {
	s.Area = &v
	return s
}

func (s *DescribeDDosAllEventListResponseBodyAttackEvents) SetEndTime(v int64) *DescribeDDosAllEventListResponseBodyAttackEvents {
	s.EndTime = &v
	return s
}

func (s *DescribeDDosAllEventListResponseBodyAttackEvents) SetEventType(v string) *DescribeDDosAllEventListResponseBodyAttackEvents {
	s.EventType = &v
	return s
}

func (s *DescribeDDosAllEventListResponseBodyAttackEvents) SetIp(v string) *DescribeDDosAllEventListResponseBodyAttackEvents {
	s.Ip = &v
	return s
}

func (s *DescribeDDosAllEventListResponseBodyAttackEvents) SetMbps(v int64) *DescribeDDosAllEventListResponseBodyAttackEvents {
	s.Mbps = &v
	return s
}

func (s *DescribeDDosAllEventListResponseBodyAttackEvents) SetPort(v string) *DescribeDDosAllEventListResponseBodyAttackEvents {
	s.Port = &v
	return s
}

func (s *DescribeDDosAllEventListResponseBodyAttackEvents) SetPps(v int64) *DescribeDDosAllEventListResponseBodyAttackEvents {
	s.Pps = &v
	return s
}

func (s *DescribeDDosAllEventListResponseBodyAttackEvents) SetStartTime(v int64) *DescribeDDosAllEventListResponseBodyAttackEvents {
	s.StartTime = &v
	return s
}

type DescribeDDosAllEventListResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeDDosAllEventListResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeDDosAllEventListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDDosAllEventListResponse) GoString() string {
	return s.String()
}

func (s *DescribeDDosAllEventListResponse) SetHeaders(v map[string]*string) *DescribeDDosAllEventListResponse {
	s.Headers = v
	return s
}

func (s *DescribeDDosAllEventListResponse) SetStatusCode(v int32) *DescribeDDosAllEventListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDDosAllEventListResponse) SetBody(v *DescribeDDosAllEventListResponseBody) *DescribeDDosAllEventListResponse {
	s.Body = v
	return s
}

type DescribeDDosEventAreaRequest struct {
	// The type of the attack event that you want to query. Valid values:
	//
	// *   **defense**: attack events that trigger traffic scrubbing
	// *   **blackhole**: attack events that trigger blackhole filtering
	EventType *string `json:"EventType,omitempty" xml:"EventType,omitempty"`
	// The IP address of the attacked Anti-DDoS Pro or Anti-DDoS Premium instance.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The UNIX timestamp when the query starts. Unit: seconds.
	//
	// > You can call the [DescribeDDosAllEventList](~~188604~~) operation to query the beginning time of all attack events.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDDosEventAreaRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDDosEventAreaRequest) GoString() string {
	return s.String()
}

func (s *DescribeDDosEventAreaRequest) SetEventType(v string) *DescribeDDosEventAreaRequest {
	s.EventType = &v
	return s
}

func (s *DescribeDDosEventAreaRequest) SetIp(v string) *DescribeDDosEventAreaRequest {
	s.Ip = &v
	return s
}

func (s *DescribeDDosEventAreaRequest) SetStartTime(v int64) *DescribeDDosEventAreaRequest {
	s.StartTime = &v
	return s
}

type DescribeDDosEventAreaResponseBody struct {
	// The information about the source region from which the volumetric attack was initiated.
	Areas []*DescribeDDosEventAreaResponseBodyAreas `json:"Areas,omitempty" xml:"Areas,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDDosEventAreaResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDDosEventAreaResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDDosEventAreaResponseBody) SetAreas(v []*DescribeDDosEventAreaResponseBodyAreas) *DescribeDDosEventAreaResponseBody {
	s.Areas = v
	return s
}

func (s *DescribeDDosEventAreaResponseBody) SetRequestId(v string) *DescribeDDosEventAreaResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDDosEventAreaResponseBodyAreas struct {
	// The code or ID of the source region. For more information, see [Codes of administrative regions in China and codes of countries and areas](~~167926~~). For example, **110000** indicates Beijing, China, and **us** indicates the United States.
	Area *string `json:"Area,omitempty" xml:"Area,omitempty"`
	// The number of request packets that were sent from the source region.
	InPkts *int64 `json:"InPkts,omitempty" xml:"InPkts,omitempty"`
}

func (s DescribeDDosEventAreaResponseBodyAreas) String() string {
	return tea.Prettify(s)
}

func (s DescribeDDosEventAreaResponseBodyAreas) GoString() string {
	return s.String()
}

func (s *DescribeDDosEventAreaResponseBodyAreas) SetArea(v string) *DescribeDDosEventAreaResponseBodyAreas {
	s.Area = &v
	return s
}

func (s *DescribeDDosEventAreaResponseBodyAreas) SetInPkts(v int64) *DescribeDDosEventAreaResponseBodyAreas {
	s.InPkts = &v
	return s
}

type DescribeDDosEventAreaResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeDDosEventAreaResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeDDosEventAreaResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDDosEventAreaResponse) GoString() string {
	return s.String()
}

func (s *DescribeDDosEventAreaResponse) SetHeaders(v map[string]*string) *DescribeDDosEventAreaResponse {
	s.Headers = v
	return s
}

func (s *DescribeDDosEventAreaResponse) SetStatusCode(v int32) *DescribeDDosEventAreaResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDDosEventAreaResponse) SetBody(v *DescribeDDosEventAreaResponseBody) *DescribeDDosEventAreaResponse {
	s.Body = v
	return s
}

type DescribeDDosEventAttackTypeRequest struct {
	// The type of the attack event that you want to query. Valid values:
	//
	// *   **defense**: attack events that trigger traffic scrubbing
	// *   **blackhole**: attack events that trigger blackhole filtering
	EventType *string `json:"EventType,omitempty" xml:"EventType,omitempty"`
	// The IP address of the attacked Anti-DDoS Pro or Anti-DDoS Premium instance.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The UNIX timestamp when the query starts. Unit: seconds.
	//
	// > You can call the [DescribeDDosAllEventList](~~188604~~) operation to query the beginning time of all attack events.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDDosEventAttackTypeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDDosEventAttackTypeRequest) GoString() string {
	return s.String()
}

func (s *DescribeDDosEventAttackTypeRequest) SetEventType(v string) *DescribeDDosEventAttackTypeRequest {
	s.EventType = &v
	return s
}

func (s *DescribeDDosEventAttackTypeRequest) SetIp(v string) *DescribeDDosEventAttackTypeRequest {
	s.Ip = &v
	return s
}

func (s *DescribeDDosEventAttackTypeRequest) SetStartTime(v int64) *DescribeDDosEventAttackTypeRequest {
	s.StartTime = &v
	return s
}

type DescribeDDosEventAttackTypeResponseBody struct {
	// The information about the attack types.
	AttackTypes []*DescribeDDosEventAttackTypeResponseBodyAttackTypes `json:"AttackTypes,omitempty" xml:"AttackTypes,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDDosEventAttackTypeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDDosEventAttackTypeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDDosEventAttackTypeResponseBody) SetAttackTypes(v []*DescribeDDosEventAttackTypeResponseBodyAttackTypes) *DescribeDDosEventAttackTypeResponseBody {
	s.AttackTypes = v
	return s
}

func (s *DescribeDDosEventAttackTypeResponseBody) SetRequestId(v string) *DescribeDDosEventAttackTypeResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDDosEventAttackTypeResponseBodyAttackTypes struct {
	// The type of the attack Valid values:
	//
	// *   **QOTD-Reflect-Flood**: QOTD reflection attacks
	// *   **CharGEN-Reflect-Flood**: CHARGEN reflection attacks
	// *   **DNS-Reflect-Flood**: DNS reflection attacks
	// *   **TFTP-Reflect-Flood**: TFTP reflection attacks
	// *   **Portmap-Reflect-Flood**: Portmap reflection attacks
	// *   **NTP-Reflect-Flood**: NTP reflection attacks
	// *   **NetBIOS-Reflect-Flood**: NetBIOS reflection attacks
	// *   **SNMPv2-Reflect-Flood**: SNMPv2 reflection attacks
	// *   **CLDAP-Reflect-Flood**: CLDAP reflection attacks
	// *   **Ripv1-Reflect-Flood**: RIPv1 reflection attacks
	// *   **OpenVPN-Reflect-Flood**: OpenVPN reflection attacks
	// *   **SSDP-Reflect-Flood**: SSDP reflection attacks
	// *   **NetAssistant-Reflect-Flood**: NetAssistant reflection attacks
	// *   **WSDiscovery-Reflect-Flood**: WS-Discovery reflection attacks
	// *   **Kad-Reflect-Flood**: Kad reflection attacks
	// *   **mDNS-Reflect-Flood**: mDNS reflection attacks
	// *   **10001-Reflect-Flood**: reflection attacks over port 10001
	// *   **Memcached-Reflect-Flood**: Memcached reflection attacks
	// *   **QNP-Reflect-Flood**: QNP reflection attacks
	// *   **DVR-Reflect-Flood**: DVR reflection attacks
	// *   **CoAP-Reflect-Flood**: CoAP reflection attacks
	// *   **ADDP-Reflect-Flood**: ADDP reflection attacks
	// *   **Tcp-Syn**: TCP SYN flood attacks
	// *   **Tcp-Fin**: TCP FIN flood attacks
	// *   **Tcp-Ack**: TCP ACK flood attacks
	// *   **Tcp-Rst**: TCP RST flood attacks
	// *   **Tcp-Pushack**: TCP PSH-ACK flood attacks
	// *   **Tcp-Synack**: TCP SYN-ACK flood attacks
	// *   **Udp-None**: UDP attacks
	// *   **Udp-Ssh**: UDP-based SSH attacks
	// *   **Udp-Dns**: UDP-based DNS attacks
	// *   **Udp-Http**: UDP-based HTTP attacks
	// *   **Udp-Https**: UDP-based HTTPS attacks
	// *   **Udp-Ntp**: UDP-based NTP attacks
	// *   **Udp-Ldap**: UDP-based LDAP attacks
	// *   **Udp-Ssdp**: UDP-based SSDP attacks
	// *   **Udp-Memcached**: Memcached UDP reflection attacks
	// *   **Tcp-Other**: other TCP attacks
	// *   **Icmp**: ICMP flood attacks
	// *   **Igmp**: IGMP flood attacks
	// *   **Ipv6**: IPv6 attacks
	AttackType *string `json:"AttackType,omitempty" xml:"AttackType,omitempty"`
	// The number of request packets of the attack type.
	InPkts *int64 `json:"InPkts,omitempty" xml:"InPkts,omitempty"`
}

func (s DescribeDDosEventAttackTypeResponseBodyAttackTypes) String() string {
	return tea.Prettify(s)
}

func (s DescribeDDosEventAttackTypeResponseBodyAttackTypes) GoString() string {
	return s.String()
}

func (s *DescribeDDosEventAttackTypeResponseBodyAttackTypes) SetAttackType(v string) *DescribeDDosEventAttackTypeResponseBodyAttackTypes {
	s.AttackType = &v
	return s
}

func (s *DescribeDDosEventAttackTypeResponseBodyAttackTypes) SetInPkts(v int64) *DescribeDDosEventAttackTypeResponseBodyAttackTypes {
	s.InPkts = &v
	return s
}

type DescribeDDosEventAttackTypeResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeDDosEventAttackTypeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeDDosEventAttackTypeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDDosEventAttackTypeResponse) GoString() string {
	return s.String()
}

func (s *DescribeDDosEventAttackTypeResponse) SetHeaders(v map[string]*string) *DescribeDDosEventAttackTypeResponse {
	s.Headers = v
	return s
}

func (s *DescribeDDosEventAttackTypeResponse) SetStatusCode(v int32) *DescribeDDosEventAttackTypeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDDosEventAttackTypeResponse) SetBody(v *DescribeDDosEventAttackTypeResponseBody) *DescribeDDosEventAttackTypeResponse {
	s.Body = v
	return s
}

type DescribeDDosEventIspRequest struct {
	// The type of the attack event that you want to query. Valid values:
	//
	// *   **defense**: attack events that trigger traffic scrubbing
	// *   **blackhole**: attack events that trigger blackhole filtering
	EventType *string `json:"EventType,omitempty" xml:"EventType,omitempty"`
	// The IP address of the attacked Anti-DDoS Pro or Anti-DDoS Premium instance.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The UNIX timestamp when the query starts. Unit: seconds.
	//
	// > You can call the [DescribeDDosAllEventList](~~188604~~) operation to query the beginning time of all attack events.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDDosEventIspRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDDosEventIspRequest) GoString() string {
	return s.String()
}

func (s *DescribeDDosEventIspRequest) SetEventType(v string) *DescribeDDosEventIspRequest {
	s.EventType = &v
	return s
}

func (s *DescribeDDosEventIspRequest) SetIp(v string) *DescribeDDosEventIspRequest {
	s.Ip = &v
	return s
}

func (s *DescribeDDosEventIspRequest) SetStartTime(v int64) *DescribeDDosEventIspRequest {
	s.StartTime = &v
	return s
}

type DescribeDDosEventIspResponseBody struct {
	// An array that consists of the ISPs for the volumetric attack.
	Isps []*DescribeDDosEventIspResponseBodyIsps `json:"Isps,omitempty" xml:"Isps,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDDosEventIspResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDDosEventIspResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDDosEventIspResponseBody) SetIsps(v []*DescribeDDosEventIspResponseBodyIsps) *DescribeDDosEventIspResponseBody {
	s.Isps = v
	return s
}

func (s *DescribeDDosEventIspResponseBody) SetRequestId(v string) *DescribeDDosEventIspResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDDosEventIspResponseBodyIsps struct {
	// The number of request packets that were sent from the ISP.
	InPkts *int64 `json:"InPkts,omitempty" xml:"InPkts,omitempty"`
	// The code of the ISP. Valid values:
	//
	// *   **100017**: China Telecom
	// *   **100026**: China Unicom
	// *   **100025**: China Mobile
	// *   **100027**: China Education and Research Network
	// *   **100020**: China Mobile Tietong
	// *   **1000143**: Dr.Peng Telecom & Media Group
	// *   **100080**: Beijing Gehua CATV Network
	// *   **1000139**: National Radio and Television Administration
	// *   **100023**: Oriental Cable Network
	// *   **100063**: Founder Broadband
	// *   **1000337**: China Internet Exchange
	// *   **100021**: 21Vianet Group
	// *   **1000333**: Wasu Media Holding
	// *   **100093**: Wangsu Science & Technology
	// *   **1000401**: Tencent
	// *   **100099**: Baidu
	// *   **1000323**: Alibaba Cloud
	// *   **100098**: Alibaba
	Isp *string `json:"Isp,omitempty" xml:"Isp,omitempty"`
}

func (s DescribeDDosEventIspResponseBodyIsps) String() string {
	return tea.Prettify(s)
}

func (s DescribeDDosEventIspResponseBodyIsps) GoString() string {
	return s.String()
}

func (s *DescribeDDosEventIspResponseBodyIsps) SetInPkts(v int64) *DescribeDDosEventIspResponseBodyIsps {
	s.InPkts = &v
	return s
}

func (s *DescribeDDosEventIspResponseBodyIsps) SetIsp(v string) *DescribeDDosEventIspResponseBodyIsps {
	s.Isp = &v
	return s
}

type DescribeDDosEventIspResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeDDosEventIspResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeDDosEventIspResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDDosEventIspResponse) GoString() string {
	return s.String()
}

func (s *DescribeDDosEventIspResponse) SetHeaders(v map[string]*string) *DescribeDDosEventIspResponse {
	s.Headers = v
	return s
}

func (s *DescribeDDosEventIspResponse) SetStatusCode(v int32) *DescribeDDosEventIspResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDDosEventIspResponse) SetBody(v *DescribeDDosEventIspResponseBody) *DescribeDDosEventIspResponse {
	s.Body = v
	return s
}

type DescribeDDosEventMaxRequest struct {
	// The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDDosEventMaxRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDDosEventMaxRequest) GoString() string {
	return s.String()
}

func (s *DescribeDDosEventMaxRequest) SetEndTime(v int64) *DescribeDDosEventMaxRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDDosEventMaxRequest) SetStartTime(v int64) *DescribeDDosEventMaxRequest {
	s.StartTime = &v
	return s
}

type DescribeDDosEventMaxResponseBody struct {
	// The peak of connection flood attacks. Unit: connections per seconds (CPS).
	Cps *int64 `json:"Cps,omitempty" xml:"Cps,omitempty"`
	// The peak of volumetric attacks. Unit: Mbit/s.
	Mbps *int64 `json:"Mbps,omitempty" xml:"Mbps,omitempty"`
	// The peak of resource exhaustion attacks. Unit: queries per second (QPS).
	Qps *int64 `json:"Qps,omitempty" xml:"Qps,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDDosEventMaxResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDDosEventMaxResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDDosEventMaxResponseBody) SetCps(v int64) *DescribeDDosEventMaxResponseBody {
	s.Cps = &v
	return s
}

func (s *DescribeDDosEventMaxResponseBody) SetMbps(v int64) *DescribeDDosEventMaxResponseBody {
	s.Mbps = &v
	return s
}

func (s *DescribeDDosEventMaxResponseBody) SetQps(v int64) *DescribeDDosEventMaxResponseBody {
	s.Qps = &v
	return s
}

func (s *DescribeDDosEventMaxResponseBody) SetRequestId(v string) *DescribeDDosEventMaxResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDDosEventMaxResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeDDosEventMaxResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeDDosEventMaxResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDDosEventMaxResponse) GoString() string {
	return s.String()
}

func (s *DescribeDDosEventMaxResponse) SetHeaders(v map[string]*string) *DescribeDDosEventMaxResponse {
	s.Headers = v
	return s
}

func (s *DescribeDDosEventMaxResponse) SetStatusCode(v int32) *DescribeDDosEventMaxResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDDosEventMaxResponse) SetBody(v *DescribeDDosEventMaxResponseBody) *DescribeDDosEventMaxResponse {
	s.Body = v
	return s
}

type DescribeDDosEventSrcIpRequest struct {
	// The type of the attack event that you want to query. Valid values:
	//
	// *   **defense**: attack events that trigger traffic scrubbing
	// *   **blackhole**: attack events that trigger blackhole filtering
	EventType *string `json:"EventType,omitempty" xml:"EventType,omitempty"`
	// The IP address of the attacked Anti-DDoS Pro or Anti-DDoS Premium instance.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The number of source IP addresses that you want to return. The source IP addresses are returned in descending order of attack traffic. By default, the top **five** source IP addresses are returned.
	Range *int64 `json:"Range,omitempty" xml:"Range,omitempty"`
	// The UNIX timestamp when the query starts. Unit: seconds.
	//
	// > You can call the [DescribeDDosAllEventList](~~188604~~) operation to query the beginning time of all attack events.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDDosEventSrcIpRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDDosEventSrcIpRequest) GoString() string {
	return s.String()
}

func (s *DescribeDDosEventSrcIpRequest) SetEventType(v string) *DescribeDDosEventSrcIpRequest {
	s.EventType = &v
	return s
}

func (s *DescribeDDosEventSrcIpRequest) SetIp(v string) *DescribeDDosEventSrcIpRequest {
	s.Ip = &v
	return s
}

func (s *DescribeDDosEventSrcIpRequest) SetRange(v int64) *DescribeDDosEventSrcIpRequest {
	s.Range = &v
	return s
}

func (s *DescribeDDosEventSrcIpRequest) SetStartTime(v int64) *DescribeDDosEventSrcIpRequest {
	s.StartTime = &v
	return s
}

type DescribeDDosEventSrcIpResponseBody struct {
	// An array that consists of information about the source IP address of the volumetric attack.
	Ips []*DescribeDDosEventSrcIpResponseBodyIps `json:"Ips,omitempty" xml:"Ips,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDDosEventSrcIpResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDDosEventSrcIpResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDDosEventSrcIpResponseBody) SetIps(v []*DescribeDDosEventSrcIpResponseBodyIps) *DescribeDDosEventSrcIpResponseBody {
	s.Ips = v
	return s
}

func (s *DescribeDDosEventSrcIpResponseBody) SetRequestId(v string) *DescribeDDosEventSrcIpResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDDosEventSrcIpResponseBodyIps struct {
	// The code or ID of the source region. For more information, see [Codes of administrative regions in China and codes of countries and areas](~~167926~~). For example, **110000** indicates Beijing, China, and **us** indicates the United States.
	AreaId *string `json:"AreaId,omitempty" xml:"AreaId,omitempty"`
	// The Internet service provider (ISP) for the volumetric attack. Valid values:
	//
	// *   **100017**: China Telecom
	// *   **100026**: China Unicom
	// *   **100025**: China Mobile
	// *   **100027**: China Education and Research Network
	// *   **100020**: China Mobile Tietong
	// *   **1000143**: Dr.Peng Telecom & Media Group
	// *   **100080**: Beijing Gehua CATV Network
	// *   **1000139**: National Radio and Television Administration
	// *   **100023**: Oriental Cable Network
	// *   **100063**: Founder Broadband
	// *   **1000337**: China Internet Exchange
	// *   **100021**: 21Vianet Group
	// *   **1000333**: Wasu Media Holding
	// *   **100093**: Wangsu Science & Technology
	// *   **1000401**: Tencent
	// *   **100099**: Baidu
	// *   **1000323**: Alibaba Cloud
	// *   **100098**: Alibaba
	Isp *string `json:"Isp,omitempty" xml:"Isp,omitempty"`
	// The source IP address of the volumetric attack.
	SrcIp *string `json:"SrcIp,omitempty" xml:"SrcIp,omitempty"`
}

func (s DescribeDDosEventSrcIpResponseBodyIps) String() string {
	return tea.Prettify(s)
}

func (s DescribeDDosEventSrcIpResponseBodyIps) GoString() string {
	return s.String()
}

func (s *DescribeDDosEventSrcIpResponseBodyIps) SetAreaId(v string) *DescribeDDosEventSrcIpResponseBodyIps {
	s.AreaId = &v
	return s
}

func (s *DescribeDDosEventSrcIpResponseBodyIps) SetIsp(v string) *DescribeDDosEventSrcIpResponseBodyIps {
	s.Isp = &v
	return s
}

func (s *DescribeDDosEventSrcIpResponseBodyIps) SetSrcIp(v string) *DescribeDDosEventSrcIpResponseBodyIps {
	s.SrcIp = &v
	return s
}

type DescribeDDosEventSrcIpResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeDDosEventSrcIpResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeDDosEventSrcIpResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDDosEventSrcIpResponse) GoString() string {
	return s.String()
}

func (s *DescribeDDosEventSrcIpResponse) SetHeaders(v map[string]*string) *DescribeDDosEventSrcIpResponse {
	s.Headers = v
	return s
}

func (s *DescribeDDosEventSrcIpResponse) SetStatusCode(v int32) *DescribeDDosEventSrcIpResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDDosEventSrcIpResponse) SetBody(v *DescribeDDosEventSrcIpResponseBody) *DescribeDDosEventSrcIpResponse {
	s.Body = v
	return s
}

type DescribeDefenseCountStatisticsRequest struct {
	// The ID of the resource group to which the instance belongs in Resource Management.
	//
	// If you do not configure this parameter, the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeDefenseCountStatisticsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDefenseCountStatisticsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDefenseCountStatisticsRequest) SetResourceGroupId(v string) *DescribeDefenseCountStatisticsRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeDefenseCountStatisticsResponseBody struct {
	// The statistics on the number of advanced mitigation sessions.
	DefenseCountStatistics *DescribeDefenseCountStatisticsResponseBodyDefenseCountStatistics `json:"DefenseCountStatistics,omitempty" xml:"DefenseCountStatistics,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDefenseCountStatisticsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDefenseCountStatisticsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDefenseCountStatisticsResponseBody) SetDefenseCountStatistics(v *DescribeDefenseCountStatisticsResponseBodyDefenseCountStatistics) *DescribeDefenseCountStatisticsResponseBody {
	s.DefenseCountStatistics = v
	return s
}

func (s *DescribeDefenseCountStatisticsResponseBody) SetRequestId(v string) *DescribeDefenseCountStatisticsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDefenseCountStatisticsResponseBodyDefenseCountStatistics struct {
	// The number of advanced mitigation sessions that are used within the current calendar month.
	DefenseCountTotalUsageOfCurrentMonth *int32 `json:"DefenseCountTotalUsageOfCurrentMonth,omitempty" xml:"DefenseCountTotalUsageOfCurrentMonth,omitempty"`
	// The number of available global advanced mitigation sessions for the Insurance mitigation plan.
	FlowPackCountRemain *int32 `json:"FlowPackCountRemain,omitempty" xml:"FlowPackCountRemain,omitempty"`
	// The maximum number of advanced mitigation sessions available for the current calendar month. The advanced mitigation sessions include the advanced mitigation sessions that are provided free of charge and the global advanced mitigation sessions that you purchase.
	MaxUsableDefenseCountCurrentMonth *int32 `json:"MaxUsableDefenseCountCurrentMonth,omitempty" xml:"MaxUsableDefenseCountCurrentMonth,omitempty"`
	// The number of available global advanced mitigation sessions for the Secure Chinese Mainland Acceleration (Sec-CMA) mitigation plan.
	SecHighSpeedCountRemain *int32 `json:"SecHighSpeedCountRemain,omitempty" xml:"SecHighSpeedCountRemain,omitempty"`
}

func (s DescribeDefenseCountStatisticsResponseBodyDefenseCountStatistics) String() string {
	return tea.Prettify(s)
}

func (s DescribeDefenseCountStatisticsResponseBodyDefenseCountStatistics) GoString() string {
	return s.String()
}

func (s *DescribeDefenseCountStatisticsResponseBodyDefenseCountStatistics) SetDefenseCountTotalUsageOfCurrentMonth(v int32) *DescribeDefenseCountStatisticsResponseBodyDefenseCountStatistics {
	s.DefenseCountTotalUsageOfCurrentMonth = &v
	return s
}

func (s *DescribeDefenseCountStatisticsResponseBodyDefenseCountStatistics) SetFlowPackCountRemain(v int32) *DescribeDefenseCountStatisticsResponseBodyDefenseCountStatistics {
	s.FlowPackCountRemain = &v
	return s
}

func (s *DescribeDefenseCountStatisticsResponseBodyDefenseCountStatistics) SetMaxUsableDefenseCountCurrentMonth(v int32) *DescribeDefenseCountStatisticsResponseBodyDefenseCountStatistics {
	s.MaxUsableDefenseCountCurrentMonth = &v
	return s
}

func (s *DescribeDefenseCountStatisticsResponseBodyDefenseCountStatistics) SetSecHighSpeedCountRemain(v int32) *DescribeDefenseCountStatisticsResponseBodyDefenseCountStatistics {
	s.SecHighSpeedCountRemain = &v
	return s
}

type DescribeDefenseCountStatisticsResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeDefenseCountStatisticsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeDefenseCountStatisticsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDefenseCountStatisticsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDefenseCountStatisticsResponse) SetHeaders(v map[string]*string) *DescribeDefenseCountStatisticsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDefenseCountStatisticsResponse) SetStatusCode(v int32) *DescribeDefenseCountStatisticsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDefenseCountStatisticsResponse) SetBody(v *DescribeDefenseCountStatisticsResponseBody) *DescribeDefenseCountStatisticsResponse {
	s.Body = v
	return s
}

type DescribeDefenseRecordsRequest struct {
	// The end of the time range to query. This value is a UNIX timestamp. Units: miliseconds.
	//
	// > The time must be in the latest 90 days.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the instance.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The beginning of the time range to query. This value is a UNIX timestamp. Units: miliseconds.
	//
	// > The time must be in the latest 90 days.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDefenseRecordsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDefenseRecordsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDefenseRecordsRequest) SetEndTime(v int64) *DescribeDefenseRecordsRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDefenseRecordsRequest) SetInstanceId(v string) *DescribeDefenseRecordsRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeDefenseRecordsRequest) SetPageNumber(v int32) *DescribeDefenseRecordsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDefenseRecordsRequest) SetPageSize(v int32) *DescribeDefenseRecordsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDefenseRecordsRequest) SetResourceGroupId(v string) *DescribeDefenseRecordsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDefenseRecordsRequest) SetStartTime(v int64) *DescribeDefenseRecordsRequest {
	s.StartTime = &v
	return s
}

type DescribeDefenseRecordsResponseBody struct {
	// An array that consists of details of the log of an advanced mitigation session.
	DefenseRecords []*DescribeDefenseRecordsResponseBodyDefenseRecords `json:"DefenseRecords,omitempty" xml:"DefenseRecords,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of advanced mitigation sessions.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeDefenseRecordsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDefenseRecordsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDefenseRecordsResponseBody) SetDefenseRecords(v []*DescribeDefenseRecordsResponseBodyDefenseRecords) *DescribeDefenseRecordsResponseBody {
	s.DefenseRecords = v
	return s
}

func (s *DescribeDefenseRecordsResponseBody) SetRequestId(v string) *DescribeDefenseRecordsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDefenseRecordsResponseBody) SetTotalCount(v int64) *DescribeDefenseRecordsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeDefenseRecordsResponseBodyDefenseRecords struct {
	// The peak attack traffic. Unit: bit/s.
	AttackPeak *int64 `json:"AttackPeak,omitempty" xml:"AttackPeak,omitempty"`
	// The end time of the advanced mitigation session. This value is a UNIX timestamp. Units: miliseconds.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The number of attacks.
	EventCount *int32 `json:"EventCount,omitempty" xml:"EventCount,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The start time of the advanced mitigation session. This value is a UNIX timestamp. Units: miliseconds.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The status of the advanced mitigation session. Valid values:
	//
	// *   **0**: The advanced mitigation session is being used.
	// *   **1**: The advanced mitigation session is used.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeDefenseRecordsResponseBodyDefenseRecords) String() string {
	return tea.Prettify(s)
}

func (s DescribeDefenseRecordsResponseBodyDefenseRecords) GoString() string {
	return s.String()
}

func (s *DescribeDefenseRecordsResponseBodyDefenseRecords) SetAttackPeak(v int64) *DescribeDefenseRecordsResponseBodyDefenseRecords {
	s.AttackPeak = &v
	return s
}

func (s *DescribeDefenseRecordsResponseBodyDefenseRecords) SetEndTime(v int64) *DescribeDefenseRecordsResponseBodyDefenseRecords {
	s.EndTime = &v
	return s
}

func (s *DescribeDefenseRecordsResponseBodyDefenseRecords) SetEventCount(v int32) *DescribeDefenseRecordsResponseBodyDefenseRecords {
	s.EventCount = &v
	return s
}

func (s *DescribeDefenseRecordsResponseBodyDefenseRecords) SetInstanceId(v string) *DescribeDefenseRecordsResponseBodyDefenseRecords {
	s.InstanceId = &v
	return s
}

func (s *DescribeDefenseRecordsResponseBodyDefenseRecords) SetStartTime(v int64) *DescribeDefenseRecordsResponseBodyDefenseRecords {
	s.StartTime = &v
	return s
}

func (s *DescribeDefenseRecordsResponseBodyDefenseRecords) SetStatus(v int32) *DescribeDefenseRecordsResponseBodyDefenseRecords {
	s.Status = &v
	return s
}

type DescribeDefenseRecordsResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeDefenseRecordsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeDefenseRecordsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDefenseRecordsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDefenseRecordsResponse) SetHeaders(v map[string]*string) *DescribeDefenseRecordsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDefenseRecordsResponse) SetStatusCode(v int32) *DescribeDefenseRecordsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDefenseRecordsResponse) SetBody(v *DescribeDefenseRecordsResponseBody) *DescribeDefenseRecordsResponse {
	s.Body = v
	return s
}

type DescribeDomainAttackEventsRequest struct {
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainAttackEventsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainAttackEventsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainAttackEventsRequest) SetDomain(v string) *DescribeDomainAttackEventsRequest {
	s.Domain = &v
	return s
}

func (s *DescribeDomainAttackEventsRequest) SetEndTime(v int64) *DescribeDomainAttackEventsRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainAttackEventsRequest) SetPageNumber(v int32) *DescribeDomainAttackEventsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDomainAttackEventsRequest) SetPageSize(v int32) *DescribeDomainAttackEventsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDomainAttackEventsRequest) SetResourceGroupId(v string) *DescribeDomainAttackEventsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDomainAttackEventsRequest) SetStartTime(v int64) *DescribeDomainAttackEventsRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainAttackEventsResponseBody struct {
	// An array that consists of the details of the DDoS attack event.
	DomainAttackEvents []*DescribeDomainAttackEventsResponseBodyDomainAttackEvents `json:"DomainAttackEvents,omitempty" xml:"DomainAttackEvents,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of returned DDoS attack events.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeDomainAttackEventsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainAttackEventsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainAttackEventsResponseBody) SetDomainAttackEvents(v []*DescribeDomainAttackEventsResponseBodyDomainAttackEvents) *DescribeDomainAttackEventsResponseBody {
	s.DomainAttackEvents = v
	return s
}

func (s *DescribeDomainAttackEventsResponseBody) SetRequestId(v string) *DescribeDomainAttackEventsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainAttackEventsResponseBody) SetTotalCount(v int64) *DescribeDomainAttackEventsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeDomainAttackEventsResponseBodyDomainAttackEvents struct {
	// The attacked domain name.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The time when the DDoS attack stopped. The value is a UNIX timestamp. Unit: seconds.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The peak attack QPS.
	MaxQps *int64 `json:"MaxQps,omitempty" xml:"MaxQps,omitempty"`
	// The time when the DDoS attack started. The value is a UNIX timestamp. Unit: seconds.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainAttackEventsResponseBodyDomainAttackEvents) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainAttackEventsResponseBodyDomainAttackEvents) GoString() string {
	return s.String()
}

func (s *DescribeDomainAttackEventsResponseBodyDomainAttackEvents) SetDomain(v string) *DescribeDomainAttackEventsResponseBodyDomainAttackEvents {
	s.Domain = &v
	return s
}

func (s *DescribeDomainAttackEventsResponseBodyDomainAttackEvents) SetEndTime(v int64) *DescribeDomainAttackEventsResponseBodyDomainAttackEvents {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainAttackEventsResponseBodyDomainAttackEvents) SetMaxQps(v int64) *DescribeDomainAttackEventsResponseBodyDomainAttackEvents {
	s.MaxQps = &v
	return s
}

func (s *DescribeDomainAttackEventsResponseBodyDomainAttackEvents) SetStartTime(v int64) *DescribeDomainAttackEventsResponseBodyDomainAttackEvents {
	s.StartTime = &v
	return s
}

type DescribeDomainAttackEventsResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeDomainAttackEventsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeDomainAttackEventsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainAttackEventsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainAttackEventsResponse) SetHeaders(v map[string]*string) *DescribeDomainAttackEventsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainAttackEventsResponse) SetStatusCode(v int32) *DescribeDomainAttackEventsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainAttackEventsResponse) SetBody(v *DescribeDomainAttackEventsResponseBody) *DescribeDomainAttackEventsResponse {
	s.Body = v
	return s
}

type DescribeDomainOverviewRequest struct {
	// The domain name of the website that you want to query. If you leave this parameter unspecified, the statistics on all domain names are queried.
	//
	// > The domain name must be added to Anti-DDoS Pro or Anti-DDoS Premium. You can call the [DescribeDomains](~~91724~~) operation to query all the domain names that are added to Anti-DDoS Pro or Anti-DDoS Premium.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The end of the time range to query. The value is a UNIX timestamp. Unit: seconds. If you leave this parameter unspecified, the current system time is used as the end time.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	//
	// For more information about resource groups, see [Create a resource group](~~94485~~).
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainOverviewRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainOverviewRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainOverviewRequest) SetDomain(v string) *DescribeDomainOverviewRequest {
	s.Domain = &v
	return s
}

func (s *DescribeDomainOverviewRequest) SetEndTime(v int64) *DescribeDomainOverviewRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainOverviewRequest) SetResourceGroupId(v string) *DescribeDomainOverviewRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDomainOverviewRequest) SetStartTime(v int64) *DescribeDomainOverviewRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainOverviewResponseBody struct {
	// The peak queries per second (QPS) during HTTP traffic scrubbing. Unit: QPS.
	MaxHttp *int64 `json:"MaxHttp,omitempty" xml:"MaxHttp,omitempty"`
	// The peak QPS during HTTPS traffic scrubbing. Unit: QPS.
	MaxHttps *int64 `json:"MaxHttps,omitempty" xml:"MaxHttps,omitempty"`
	// The ID of the request, which is used to locate and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDomainOverviewResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainOverviewResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainOverviewResponseBody) SetMaxHttp(v int64) *DescribeDomainOverviewResponseBody {
	s.MaxHttp = &v
	return s
}

func (s *DescribeDomainOverviewResponseBody) SetMaxHttps(v int64) *DescribeDomainOverviewResponseBody {
	s.MaxHttps = &v
	return s
}

func (s *DescribeDomainOverviewResponseBody) SetRequestId(v string) *DescribeDomainOverviewResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDomainOverviewResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeDomainOverviewResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeDomainOverviewResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainOverviewResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainOverviewResponse) SetHeaders(v map[string]*string) *DescribeDomainOverviewResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainOverviewResponse) SetStatusCode(v int32) *DescribeDomainOverviewResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainOverviewResponse) SetBody(v *DescribeDomainOverviewResponseBody) *DescribeDomainOverviewResponse {
	s.Body = v
	return s
}

type DescribeDomainQPSListRequest struct {
	// The domain name of the website. If you do not specify this parameter, the statistics on the QPS of all domain names are queried.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The interval for returning data. Unit: seconds.
	Interval *int64 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainQPSListRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainQPSListRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainQPSListRequest) SetDomain(v string) *DescribeDomainQPSListRequest {
	s.Domain = &v
	return s
}

func (s *DescribeDomainQPSListRequest) SetEndTime(v int64) *DescribeDomainQPSListRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainQPSListRequest) SetInterval(v int64) *DescribeDomainQPSListRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDomainQPSListRequest) SetResourceGroupId(v string) *DescribeDomainQPSListRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDomainQPSListRequest) SetStartTime(v int64) *DescribeDomainQPSListRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainQPSListResponseBody struct {
	// An array that consists of the statistics on the QPS of the website.
	DomainQPSList []*DescribeDomainQPSListResponseBodyDomainQPSList `json:"DomainQPSList,omitempty" xml:"DomainQPSList,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDomainQPSListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainQPSListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainQPSListResponseBody) SetDomainQPSList(v []*DescribeDomainQPSListResponseBodyDomainQPSList) *DescribeDomainQPSListResponseBody {
	s.DomainQPSList = v
	return s
}

func (s *DescribeDomainQPSListResponseBody) SetRequestId(v string) *DescribeDomainQPSListResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDomainQPSListResponseBodyDomainQPSList struct {
	// The attack QPS.
	AttackQps *int64 `json:"AttackQps,omitempty" xml:"AttackQps,omitempty"`
	// The number of cache hits.
	CacheHits *int64 `json:"CacheHits,omitempty" xml:"CacheHits,omitempty"`
	// The index number of the returned data.
	Index *int64 `json:"Index,omitempty" xml:"Index,omitempty"`
	// The peak attack QPS.
	MaxAttackQps *int64 `json:"MaxAttackQps,omitempty" xml:"MaxAttackQps,omitempty"`
	// The peak of normal QPS.
	MaxNormalQps *int64 `json:"MaxNormalQps,omitempty" xml:"MaxNormalQps,omitempty"`
	// The peak of total QPS.
	MaxQps *int64 `json:"MaxQps,omitempty" xml:"MaxQps,omitempty"`
	// The time when the data was collected. The value is a UNIX timestamp. Unit: seconds.
	Time *int64 `json:"Time,omitempty" xml:"Time,omitempty"`
	// The total number of requests.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The total QPS.
	TotalQps *int64 `json:"TotalQps,omitempty" xml:"TotalQps,omitempty"`
}

func (s DescribeDomainQPSListResponseBodyDomainQPSList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainQPSListResponseBodyDomainQPSList) GoString() string {
	return s.String()
}

func (s *DescribeDomainQPSListResponseBodyDomainQPSList) SetAttackQps(v int64) *DescribeDomainQPSListResponseBodyDomainQPSList {
	s.AttackQps = &v
	return s
}

func (s *DescribeDomainQPSListResponseBodyDomainQPSList) SetCacheHits(v int64) *DescribeDomainQPSListResponseBodyDomainQPSList {
	s.CacheHits = &v
	return s
}

func (s *DescribeDomainQPSListResponseBodyDomainQPSList) SetIndex(v int64) *DescribeDomainQPSListResponseBodyDomainQPSList {
	s.Index = &v
	return s
}

func (s *DescribeDomainQPSListResponseBodyDomainQPSList) SetMaxAttackQps(v int64) *DescribeDomainQPSListResponseBodyDomainQPSList {
	s.MaxAttackQps = &v
	return s
}

func (s *DescribeDomainQPSListResponseBodyDomainQPSList) SetMaxNormalQps(v int64) *DescribeDomainQPSListResponseBodyDomainQPSList {
	s.MaxNormalQps = &v
	return s
}

func (s *DescribeDomainQPSListResponseBodyDomainQPSList) SetMaxQps(v int64) *DescribeDomainQPSListResponseBodyDomainQPSList {
	s.MaxQps = &v
	return s
}

func (s *DescribeDomainQPSListResponseBodyDomainQPSList) SetTime(v int64) *DescribeDomainQPSListResponseBodyDomainQPSList {
	s.Time = &v
	return s
}

func (s *DescribeDomainQPSListResponseBodyDomainQPSList) SetTotalCount(v int64) *DescribeDomainQPSListResponseBodyDomainQPSList {
	s.TotalCount = &v
	return s
}

func (s *DescribeDomainQPSListResponseBodyDomainQPSList) SetTotalQps(v int64) *DescribeDomainQPSListResponseBodyDomainQPSList {
	s.TotalQps = &v
	return s
}

type DescribeDomainQPSListResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeDomainQPSListResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeDomainQPSListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainQPSListResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainQPSListResponse) SetHeaders(v map[string]*string) *DescribeDomainQPSListResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainQPSListResponse) SetStatusCode(v int32) *DescribeDomainQPSListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainQPSListResponse) SetBody(v *DescribeDomainQPSListResponseBody) *DescribeDomainQPSListResponse {
	s.Body = v
	return s
}

type DescribeDomainResourceRequest struct {
	// The domain name of the website that you want to query.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// An array that consists of the IDs of instances to query.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The match mode. Valid values:
	//
	// *   **fuzzy**: fuzzy match. This is the default value.
	// *   **exact**: exact match.
	QueryDomainPattern *string `json:"QueryDomainPattern,omitempty" xml:"QueryDomainPattern,omitempty"`
}

func (s DescribeDomainResourceRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainResourceRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainResourceRequest) SetDomain(v string) *DescribeDomainResourceRequest {
	s.Domain = &v
	return s
}

func (s *DescribeDomainResourceRequest) SetInstanceIds(v []*string) *DescribeDomainResourceRequest {
	s.InstanceIds = v
	return s
}

func (s *DescribeDomainResourceRequest) SetPageNumber(v int32) *DescribeDomainResourceRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeDomainResourceRequest) SetPageSize(v int32) *DescribeDomainResourceRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeDomainResourceRequest) SetQueryDomainPattern(v string) *DescribeDomainResourceRequest {
	s.QueryDomainPattern = &v
	return s
}

type DescribeDomainResourceResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of forwarding rules.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The configurations of the forwarding rule.
	WebRules []*DescribeDomainResourceResponseBodyWebRules `json:"WebRules,omitempty" xml:"WebRules,omitempty" type:"Repeated"`
}

func (s DescribeDomainResourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainResourceResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainResourceResponseBody) SetRequestId(v string) *DescribeDomainResourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainResourceResponseBody) SetTotalCount(v int64) *DescribeDomainResourceResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeDomainResourceResponseBody) SetWebRules(v []*DescribeDomainResourceResponseBodyWebRules) *DescribeDomainResourceResponseBody {
	s.WebRules = v
	return s
}

type DescribeDomainResourceResponseBodyWebRules struct {
	// The IP addresses that are included in the blacklist of the domain name.
	BlackList []*string `json:"BlackList,omitempty" xml:"BlackList,omitempty" type:"Repeated"`
	// Indicates whether the Frequency Control policy is enabled. Valid values:
	//
	// *   **true**
	// *   **false**
	CcEnabled *bool `json:"CcEnabled,omitempty" xml:"CcEnabled,omitempty"`
	// Indicates whether the Custom Rule switch of the Frequency Control policy is turned on. Valid values:
	//
	// *   **true**
	// *   **false**
	CcRuleEnabled *bool `json:"CcRuleEnabled,omitempty" xml:"CcRuleEnabled,omitempty"`
	// The mode of the Frequency Control policy. Valid values:
	//
	// *   **default**: the Normal mode
	// *   **gf_under_attack**: the Emergency mode
	// *   **gf_sos_verify**: the Strict mode
	// *   **gf_sos_verify**: the Super Strict mode
	CcTemplate *string `json:"CcTemplate,omitempty" xml:"CcTemplate,omitempty"`
	// The name of the SSL certificate used by the domain name.
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The CNAME provided by the instance to which the domain name is added.
	Cname *string `json:"Cname,omitempty" xml:"Cname,omitempty"`
	// The custom cipher suites.
	CustomCiphers []*string `json:"CustomCiphers,omitempty" xml:"CustomCiphers,omitempty" type:"Repeated"`
	// The domain name of the website.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// Indicates whether Enable HTTP/2 is turned on. Valid values:
	//
	// *   **true**
	// *   **false**
	Http2Enable *bool `json:"Http2Enable,omitempty" xml:"Http2Enable,omitempty"`
	// Indicates whether Enforce HTTPS Routing is turned on. Valid values:
	//
	// *   **true**
	// *   **false**
	Http2HttpsEnable *bool `json:"Http2HttpsEnable,omitempty" xml:"Http2HttpsEnable,omitempty"`
	// Indicates whether Enable HTTP is turned on. Valid values:
	//
	// *   **true**
	// *   **false**
	Https2HttpEnable *bool `json:"Https2HttpEnable,omitempty" xml:"Https2HttpEnable,omitempty"`
	// The advanced HTTPS settings. This parameter takes effect only when the value of the **ProxyType** parameter includes **https**. The value is a string that consists of a JSON struct. The JSON struct contains the following fields:
	//
	// *   **Http2https**: indicates whether the feature of redirecting HTTP requests to HTTPS requests is enabled. Data type: integer. Valid values: **0** and **1**. The value 0 indicates that the feature is disabled. The value 1 indicates that the feature is enabled.
	// *   **Https2http**: indicates whether the feature of redirecting HTTPS requests to HTTP requests is enabled. Data type: integer. Valid values: **0** and **1**. The value 0 indicates that the feature is disabled. The value 1 indicates that the feature is enabled.
	// *   **Http2**: indicates whether HTTP/2 is supported. Data type: integer. Valid values: **0** and **1**. The value 0 indicates that HTTP/2 is not supported. The value 1 indicates that HTTP/2 is supported.
	HttpsExt *string `json:"HttpsExt,omitempty" xml:"HttpsExt,omitempty"`
	// The IDs of the instances to which the domain name is added.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	// Indicates whether the Online Certificate Status Protocol (OCSP) feature is enabled. Valid values:
	// - **true**: yes
	// - **false**: no
	OcspEnabled *bool `json:"OcspEnabled,omitempty" xml:"OcspEnabled,omitempty"`
	// The load balancing algorithm for back-to-origin traffic. Valid values:
	//
	// *   **ip_hash**: the IP hash algorithm. This algorithm is used to redirect the requests from the same IP address to the same origin server.
	// *   **rr**: the round-robin algorithm. This algorithm is used to redirect requests to origin servers in turn.
	// *   **least_time**: the least response time algorithm. This algorithm is used to minimize the latency when requests are forwarded from Anti-DDoS Pro or Anti-DDoS Premium instances to origin servers based on the intelligent DNS resolution feature.
	PolicyMode *string `json:"PolicyMode,omitempty" xml:"PolicyMode,omitempty"`
	// Indicates whether the instance forwards the traffic that is destined for the website. Valid values:
	//
	// *   **true**: Anti-DDoS Pro or Anti-DDoS Premium forwards the traffic that is destined for the website.
	// *   **false**: no
	ProxyEnabled *bool `json:"ProxyEnabled,omitempty" xml:"ProxyEnabled,omitempty"`
	// The details about the protocol type and port number.
	ProxyTypes []*DescribeDomainResourceResponseBodyWebRulesProxyTypes `json:"ProxyTypes,omitempty" xml:"ProxyTypes,omitempty" type:"Repeated"`
	// The reason why the domain name is invalid. Valid values:
	//
	// *   **1**: No Content Provider (ICP) filing is completed for the domain name.
	// *   **2**: The business for which you registered the domain name does not meet regulatory requirements.
	//
	// If the two reasons are both involved, the value **2** is returned.
	PunishReason *int32 `json:"PunishReason,omitempty" xml:"PunishReason,omitempty"`
	// Indicates whether the domain name is invalid. Valid values:
	//
	// *   **true**: The domain name is invalid. You can view the specific reasons from the **PunishReason** parameter.
	// *   **false**: The domain name is valid.
	PunishStatus *bool `json:"PunishStatus,omitempty" xml:"PunishStatus,omitempty"`
	// The addresses of origin servers.
	RealServers []*string `json:"RealServers,omitempty" xml:"RealServers,omitempty" type:"Repeated"`
	// The address type of the origin server. Valid values:
	//
	// *   **0**: IP address
	// *   **1**: domain name
	RsType *int32 `json:"RsType,omitempty" xml:"RsType,omitempty"`
	// Indicates whether TLS 1.3 is supported. Valid values:
	//
	// *   **true**
	// *   **false**
	Ssl13Enabled *bool `json:"Ssl13Enabled,omitempty" xml:"Ssl13Enabled,omitempty"`
	// The type of the cipher suite. Valid values:
	//
	// *   **default**: custom cipher suite
	// *   **all**: all cipher suites
	// *   **strong**: strong cipher suites
	SslCiphers *string `json:"SslCiphers,omitempty" xml:"SslCiphers,omitempty"`
	// The version of the TLS protocol. Valid values:
	//
	// *   **tls1.0**: TLS 1.0 or later
	// *   **tls1.1**: TLS 1.1 or later
	// *   **tls1.2**: TLS 1.2 or later
	SslProtocols *string `json:"SslProtocols,omitempty" xml:"SslProtocols,omitempty"`
	// The IP addresses that are included in the whitelist of the domain name.
	WhiteList []*string `json:"WhiteList,omitempty" xml:"WhiteList,omitempty" type:"Repeated"`
}

func (s DescribeDomainResourceResponseBodyWebRules) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainResourceResponseBodyWebRules) GoString() string {
	return s.String()
}

func (s *DescribeDomainResourceResponseBodyWebRules) SetBlackList(v []*string) *DescribeDomainResourceResponseBodyWebRules {
	s.BlackList = v
	return s
}

func (s *DescribeDomainResourceResponseBodyWebRules) SetCcEnabled(v bool) *DescribeDomainResourceResponseBodyWebRules {
	s.CcEnabled = &v
	return s
}

func (s *DescribeDomainResourceResponseBodyWebRules) SetCcRuleEnabled(v bool) *DescribeDomainResourceResponseBodyWebRules {
	s.CcRuleEnabled = &v
	return s
}

func (s *DescribeDomainResourceResponseBodyWebRules) SetCcTemplate(v string) *DescribeDomainResourceResponseBodyWebRules {
	s.CcTemplate = &v
	return s
}

func (s *DescribeDomainResourceResponseBodyWebRules) SetCertName(v string) *DescribeDomainResourceResponseBodyWebRules {
	s.CertName = &v
	return s
}

func (s *DescribeDomainResourceResponseBodyWebRules) SetCname(v string) *DescribeDomainResourceResponseBodyWebRules {
	s.Cname = &v
	return s
}

func (s *DescribeDomainResourceResponseBodyWebRules) SetCustomCiphers(v []*string) *DescribeDomainResourceResponseBodyWebRules {
	s.CustomCiphers = v
	return s
}

func (s *DescribeDomainResourceResponseBodyWebRules) SetDomain(v string) *DescribeDomainResourceResponseBodyWebRules {
	s.Domain = &v
	return s
}

func (s *DescribeDomainResourceResponseBodyWebRules) SetHttp2Enable(v bool) *DescribeDomainResourceResponseBodyWebRules {
	s.Http2Enable = &v
	return s
}

func (s *DescribeDomainResourceResponseBodyWebRules) SetHttp2HttpsEnable(v bool) *DescribeDomainResourceResponseBodyWebRules {
	s.Http2HttpsEnable = &v
	return s
}

func (s *DescribeDomainResourceResponseBodyWebRules) SetHttps2HttpEnable(v bool) *DescribeDomainResourceResponseBodyWebRules {
	s.Https2HttpEnable = &v
	return s
}

func (s *DescribeDomainResourceResponseBodyWebRules) SetHttpsExt(v string) *DescribeDomainResourceResponseBodyWebRules {
	s.HttpsExt = &v
	return s
}

func (s *DescribeDomainResourceResponseBodyWebRules) SetInstanceIds(v []*string) *DescribeDomainResourceResponseBodyWebRules {
	s.InstanceIds = v
	return s
}

func (s *DescribeDomainResourceResponseBodyWebRules) SetOcspEnabled(v bool) *DescribeDomainResourceResponseBodyWebRules {
	s.OcspEnabled = &v
	return s
}

func (s *DescribeDomainResourceResponseBodyWebRules) SetPolicyMode(v string) *DescribeDomainResourceResponseBodyWebRules {
	s.PolicyMode = &v
	return s
}

func (s *DescribeDomainResourceResponseBodyWebRules) SetProxyEnabled(v bool) *DescribeDomainResourceResponseBodyWebRules {
	s.ProxyEnabled = &v
	return s
}

func (s *DescribeDomainResourceResponseBodyWebRules) SetProxyTypes(v []*DescribeDomainResourceResponseBodyWebRulesProxyTypes) *DescribeDomainResourceResponseBodyWebRules {
	s.ProxyTypes = v
	return s
}

func (s *DescribeDomainResourceResponseBodyWebRules) SetPunishReason(v int32) *DescribeDomainResourceResponseBodyWebRules {
	s.PunishReason = &v
	return s
}

func (s *DescribeDomainResourceResponseBodyWebRules) SetPunishStatus(v bool) *DescribeDomainResourceResponseBodyWebRules {
	s.PunishStatus = &v
	return s
}

func (s *DescribeDomainResourceResponseBodyWebRules) SetRealServers(v []*string) *DescribeDomainResourceResponseBodyWebRules {
	s.RealServers = v
	return s
}

func (s *DescribeDomainResourceResponseBodyWebRules) SetRsType(v int32) *DescribeDomainResourceResponseBodyWebRules {
	s.RsType = &v
	return s
}

func (s *DescribeDomainResourceResponseBodyWebRules) SetSsl13Enabled(v bool) *DescribeDomainResourceResponseBodyWebRules {
	s.Ssl13Enabled = &v
	return s
}

func (s *DescribeDomainResourceResponseBodyWebRules) SetSslCiphers(v string) *DescribeDomainResourceResponseBodyWebRules {
	s.SslCiphers = &v
	return s
}

func (s *DescribeDomainResourceResponseBodyWebRules) SetSslProtocols(v string) *DescribeDomainResourceResponseBodyWebRules {
	s.SslProtocols = &v
	return s
}

func (s *DescribeDomainResourceResponseBodyWebRules) SetWhiteList(v []*string) *DescribeDomainResourceResponseBodyWebRules {
	s.WhiteList = v
	return s
}

type DescribeDomainResourceResponseBodyWebRulesProxyTypes struct {
	// The port numbers.
	ProxyPorts []*string `json:"ProxyPorts,omitempty" xml:"ProxyPorts,omitempty" type:"Repeated"`
	// The type of the protocol. Valid values:
	//
	// *   **http**
	// *   **https**
	// *   **websocket**
	// *   **websockets**
	ProxyType *string `json:"ProxyType,omitempty" xml:"ProxyType,omitempty"`
}

func (s DescribeDomainResourceResponseBodyWebRulesProxyTypes) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainResourceResponseBodyWebRulesProxyTypes) GoString() string {
	return s.String()
}

func (s *DescribeDomainResourceResponseBodyWebRulesProxyTypes) SetProxyPorts(v []*string) *DescribeDomainResourceResponseBodyWebRulesProxyTypes {
	s.ProxyPorts = v
	return s
}

func (s *DescribeDomainResourceResponseBodyWebRulesProxyTypes) SetProxyType(v string) *DescribeDomainResourceResponseBodyWebRulesProxyTypes {
	s.ProxyType = &v
	return s
}

type DescribeDomainResourceResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeDomainResourceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeDomainResourceResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainResourceResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainResourceResponse) SetHeaders(v map[string]*string) *DescribeDomainResourceResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainResourceResponse) SetStatusCode(v int32) *DescribeDomainResourceResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainResourceResponse) SetBody(v *DescribeDomainResourceResponseBody) *DescribeDomainResourceResponse {
	s.Body = v
	return s
}

type DescribeDomainSecurityProfileRequest struct {
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
}

func (s DescribeDomainSecurityProfileRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSecurityProfileRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainSecurityProfileRequest) SetDomain(v string) *DescribeDomainSecurityProfileRequest {
	s.Domain = &v
	return s
}

type DescribeDomainSecurityProfileResponseBody struct {
	// The ID of the request, which is used to locate and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned results.
	Result []*DescribeDomainSecurityProfileResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
}

func (s DescribeDomainSecurityProfileResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSecurityProfileResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainSecurityProfileResponseBody) SetRequestId(v string) *DescribeDomainSecurityProfileResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainSecurityProfileResponseBody) SetResult(v []*DescribeDomainSecurityProfileResponseBodyResult) *DescribeDomainSecurityProfileResponseBody {
	s.Result = v
	return s
}

type DescribeDomainSecurityProfileResponseBodyResult struct {
	// Indicates whether the global mitigation policy is enabled. Valid values:
	//
	// *   **true**
	// *   **false**
	GlobalEnable *bool `json:"GlobalEnable,omitempty" xml:"GlobalEnable,omitempty"`
	// The mode of the global mitigation policy. Valid values:
	//
	// *   **weak**: the Low mode
	// *   **default**: the Normal mode
	// *   **hard**: the Strict mode
	GlobalMode *string `json:"GlobalMode,omitempty" xml:"GlobalMode,omitempty"`
}

func (s DescribeDomainSecurityProfileResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSecurityProfileResponseBodyResult) GoString() string {
	return s.String()
}

func (s *DescribeDomainSecurityProfileResponseBodyResult) SetGlobalEnable(v bool) *DescribeDomainSecurityProfileResponseBodyResult {
	s.GlobalEnable = &v
	return s
}

func (s *DescribeDomainSecurityProfileResponseBodyResult) SetGlobalMode(v string) *DescribeDomainSecurityProfileResponseBodyResult {
	s.GlobalMode = &v
	return s
}

type DescribeDomainSecurityProfileResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeDomainSecurityProfileResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeDomainSecurityProfileResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainSecurityProfileResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainSecurityProfileResponse) SetHeaders(v map[string]*string) *DescribeDomainSecurityProfileResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainSecurityProfileResponse) SetStatusCode(v int32) *DescribeDomainSecurityProfileResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainSecurityProfileResponse) SetBody(v *DescribeDomainSecurityProfileResponseBody) *DescribeDomainSecurityProfileResponse {
	s.Body = v
	return s
}

type DescribeDomainStatusCodeCountRequest struct {
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainStatusCodeCountRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainStatusCodeCountRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainStatusCodeCountRequest) SetDomain(v string) *DescribeDomainStatusCodeCountRequest {
	s.Domain = &v
	return s
}

func (s *DescribeDomainStatusCodeCountRequest) SetEndTime(v int64) *DescribeDomainStatusCodeCountRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainStatusCodeCountRequest) SetResourceGroupId(v string) *DescribeDomainStatusCodeCountRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDomainStatusCodeCountRequest) SetStartTime(v int64) *DescribeDomainStatusCodeCountRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainStatusCodeCountResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of 200 status codes within the specified period of time.
	Status200 *int64 `json:"Status200,omitempty" xml:"Status200,omitempty"`
	// The number of 2xx status codes within the specified period of time.
	Status2XX *int64 `json:"Status2XX,omitempty" xml:"Status2XX,omitempty"`
	// The number of 3xx status codes within the specified period of time.
	Status3XX *int64 `json:"Status3XX,omitempty" xml:"Status3XX,omitempty"`
	// The number of 403 status codes within the specified period of time.
	Status403 *int64 `json:"Status403,omitempty" xml:"Status403,omitempty"`
	// The number of 404 status codes within the specified period of time.
	Status404 *int64 `json:"Status404,omitempty" xml:"Status404,omitempty"`
	// The number of 405 status codes within the specified period of time.
	Status405 *int64 `json:"Status405,omitempty" xml:"Status405,omitempty"`
	// The number of 4xx status codes within the specified period of time.
	Status4XX *int64 `json:"Status4XX,omitempty" xml:"Status4XX,omitempty"`
	// The number of 501 status codes within the specified period of time.
	Status501 *int64 `json:"Status501,omitempty" xml:"Status501,omitempty"`
	// The number of 502 status codes within the specified period of time.
	Status502 *int64 `json:"Status502,omitempty" xml:"Status502,omitempty"`
	// The number of 503 status codes within the specified period of time.
	Status503 *int64 `json:"Status503,omitempty" xml:"Status503,omitempty"`
	// The number of 504 status codes within the specified period of time.
	Status504 *int64 `json:"Status504,omitempty" xml:"Status504,omitempty"`
	// The number of 5xx status codes within the specified period of time.
	Status5XX *int64 `json:"Status5XX,omitempty" xml:"Status5XX,omitempty"`
}

func (s DescribeDomainStatusCodeCountResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainStatusCodeCountResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainStatusCodeCountResponseBody) SetRequestId(v string) *DescribeDomainStatusCodeCountResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainStatusCodeCountResponseBody) SetStatus200(v int64) *DescribeDomainStatusCodeCountResponseBody {
	s.Status200 = &v
	return s
}

func (s *DescribeDomainStatusCodeCountResponseBody) SetStatus2XX(v int64) *DescribeDomainStatusCodeCountResponseBody {
	s.Status2XX = &v
	return s
}

func (s *DescribeDomainStatusCodeCountResponseBody) SetStatus3XX(v int64) *DescribeDomainStatusCodeCountResponseBody {
	s.Status3XX = &v
	return s
}

func (s *DescribeDomainStatusCodeCountResponseBody) SetStatus403(v int64) *DescribeDomainStatusCodeCountResponseBody {
	s.Status403 = &v
	return s
}

func (s *DescribeDomainStatusCodeCountResponseBody) SetStatus404(v int64) *DescribeDomainStatusCodeCountResponseBody {
	s.Status404 = &v
	return s
}

func (s *DescribeDomainStatusCodeCountResponseBody) SetStatus405(v int64) *DescribeDomainStatusCodeCountResponseBody {
	s.Status405 = &v
	return s
}

func (s *DescribeDomainStatusCodeCountResponseBody) SetStatus4XX(v int64) *DescribeDomainStatusCodeCountResponseBody {
	s.Status4XX = &v
	return s
}

func (s *DescribeDomainStatusCodeCountResponseBody) SetStatus501(v int64) *DescribeDomainStatusCodeCountResponseBody {
	s.Status501 = &v
	return s
}

func (s *DescribeDomainStatusCodeCountResponseBody) SetStatus502(v int64) *DescribeDomainStatusCodeCountResponseBody {
	s.Status502 = &v
	return s
}

func (s *DescribeDomainStatusCodeCountResponseBody) SetStatus503(v int64) *DescribeDomainStatusCodeCountResponseBody {
	s.Status503 = &v
	return s
}

func (s *DescribeDomainStatusCodeCountResponseBody) SetStatus504(v int64) *DescribeDomainStatusCodeCountResponseBody {
	s.Status504 = &v
	return s
}

func (s *DescribeDomainStatusCodeCountResponseBody) SetStatus5XX(v int64) *DescribeDomainStatusCodeCountResponseBody {
	s.Status5XX = &v
	return s
}

type DescribeDomainStatusCodeCountResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeDomainStatusCodeCountResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeDomainStatusCodeCountResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainStatusCodeCountResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainStatusCodeCountResponse) SetHeaders(v map[string]*string) *DescribeDomainStatusCodeCountResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainStatusCodeCountResponse) SetStatusCode(v int32) *DescribeDomainStatusCodeCountResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainStatusCodeCountResponse) SetBody(v *DescribeDomainStatusCodeCountResponseBody) *DescribeDomainStatusCodeCountResponse {
	s.Body = v
	return s
}

type DescribeDomainStatusCodeListRequest struct {
	// The domain name of the website. If you do not specify this parameter, the statistics on response status codes of all domain names are queried.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The interval for returning data. Unit: seconds.
	Interval *int64 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The source of the statistics. Valid values:
	//
	// *   **gf**: Anti-DDoS Pro or Anti-DDoS Premium
	// *   **upstrem**: origin server
	QueryType *string `json:"QueryType,omitempty" xml:"QueryType,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The start time of the event. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainStatusCodeListRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainStatusCodeListRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainStatusCodeListRequest) SetDomain(v string) *DescribeDomainStatusCodeListRequest {
	s.Domain = &v
	return s
}

func (s *DescribeDomainStatusCodeListRequest) SetEndTime(v int64) *DescribeDomainStatusCodeListRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainStatusCodeListRequest) SetInterval(v int64) *DescribeDomainStatusCodeListRequest {
	s.Interval = &v
	return s
}

func (s *DescribeDomainStatusCodeListRequest) SetQueryType(v string) *DescribeDomainStatusCodeListRequest {
	s.QueryType = &v
	return s
}

func (s *DescribeDomainStatusCodeListRequest) SetResourceGroupId(v string) *DescribeDomainStatusCodeListRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDomainStatusCodeListRequest) SetStartTime(v int64) *DescribeDomainStatusCodeListRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainStatusCodeListResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The statistics on response status codes.
	StatusCodeList []*DescribeDomainStatusCodeListResponseBodyStatusCodeList `json:"StatusCodeList,omitempty" xml:"StatusCodeList,omitempty" type:"Repeated"`
}

func (s DescribeDomainStatusCodeListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainStatusCodeListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainStatusCodeListResponseBody) SetRequestId(v string) *DescribeDomainStatusCodeListResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainStatusCodeListResponseBody) SetStatusCodeList(v []*DescribeDomainStatusCodeListResponseBodyStatusCodeList) *DescribeDomainStatusCodeListResponseBody {
	s.StatusCodeList = v
	return s
}

type DescribeDomainStatusCodeListResponseBodyStatusCodeList struct {
	// The index number of the returned data.
	Index *int32 `json:"Index,omitempty" xml:"Index,omitempty"`
	// The number of 200 status codes.
	Status200 *int64 `json:"Status200,omitempty" xml:"Status200,omitempty"`
	// The number of 2xx status codes.
	Status2XX *int64 `json:"Status2XX,omitempty" xml:"Status2XX,omitempty"`
	// The number of 3xx status codes.
	Status3XX *int64 `json:"Status3XX,omitempty" xml:"Status3XX,omitempty"`
	// The number of 403 status codes.
	Status403 *int64 `json:"Status403,omitempty" xml:"Status403,omitempty"`
	// The number of 404 status codes.
	Status404 *int64 `json:"Status404,omitempty" xml:"Status404,omitempty"`
	// The number of 405 status codes.
	Status405 *int64 `json:"Status405,omitempty" xml:"Status405,omitempty"`
	// The number of 4xx status codes.
	Status4XX *int64 `json:"Status4XX,omitempty" xml:"Status4XX,omitempty"`
	// The number of 501 status codes.
	Status501 *int64 `json:"Status501,omitempty" xml:"Status501,omitempty"`
	// The number of 502 status codes.
	Status502 *int64 `json:"Status502,omitempty" xml:"Status502,omitempty"`
	// The number of 503 status codes.
	Status503 *int64 `json:"Status503,omitempty" xml:"Status503,omitempty"`
	// The number of 504 status codes.
	Status504 *int64 `json:"Status504,omitempty" xml:"Status504,omitempty"`
	// The number of 5xx status codes.
	Status5XX *int64 `json:"Status5XX,omitempty" xml:"Status5XX,omitempty"`
	// The time when the data was collected. The value is a UNIX timestamp. Unit: seconds.
	Time *int64 `json:"Time,omitempty" xml:"Time,omitempty"`
}

func (s DescribeDomainStatusCodeListResponseBodyStatusCodeList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainStatusCodeListResponseBodyStatusCodeList) GoString() string {
	return s.String()
}

func (s *DescribeDomainStatusCodeListResponseBodyStatusCodeList) SetIndex(v int32) *DescribeDomainStatusCodeListResponseBodyStatusCodeList {
	s.Index = &v
	return s
}

func (s *DescribeDomainStatusCodeListResponseBodyStatusCodeList) SetStatus200(v int64) *DescribeDomainStatusCodeListResponseBodyStatusCodeList {
	s.Status200 = &v
	return s
}

func (s *DescribeDomainStatusCodeListResponseBodyStatusCodeList) SetStatus2XX(v int64) *DescribeDomainStatusCodeListResponseBodyStatusCodeList {
	s.Status2XX = &v
	return s
}

func (s *DescribeDomainStatusCodeListResponseBodyStatusCodeList) SetStatus3XX(v int64) *DescribeDomainStatusCodeListResponseBodyStatusCodeList {
	s.Status3XX = &v
	return s
}

func (s *DescribeDomainStatusCodeListResponseBodyStatusCodeList) SetStatus403(v int64) *DescribeDomainStatusCodeListResponseBodyStatusCodeList {
	s.Status403 = &v
	return s
}

func (s *DescribeDomainStatusCodeListResponseBodyStatusCodeList) SetStatus404(v int64) *DescribeDomainStatusCodeListResponseBodyStatusCodeList {
	s.Status404 = &v
	return s
}

func (s *DescribeDomainStatusCodeListResponseBodyStatusCodeList) SetStatus405(v int64) *DescribeDomainStatusCodeListResponseBodyStatusCodeList {
	s.Status405 = &v
	return s
}

func (s *DescribeDomainStatusCodeListResponseBodyStatusCodeList) SetStatus4XX(v int64) *DescribeDomainStatusCodeListResponseBodyStatusCodeList {
	s.Status4XX = &v
	return s
}

func (s *DescribeDomainStatusCodeListResponseBodyStatusCodeList) SetStatus501(v int64) *DescribeDomainStatusCodeListResponseBodyStatusCodeList {
	s.Status501 = &v
	return s
}

func (s *DescribeDomainStatusCodeListResponseBodyStatusCodeList) SetStatus502(v int64) *DescribeDomainStatusCodeListResponseBodyStatusCodeList {
	s.Status502 = &v
	return s
}

func (s *DescribeDomainStatusCodeListResponseBodyStatusCodeList) SetStatus503(v int64) *DescribeDomainStatusCodeListResponseBodyStatusCodeList {
	s.Status503 = &v
	return s
}

func (s *DescribeDomainStatusCodeListResponseBodyStatusCodeList) SetStatus504(v int64) *DescribeDomainStatusCodeListResponseBodyStatusCodeList {
	s.Status504 = &v
	return s
}

func (s *DescribeDomainStatusCodeListResponseBodyStatusCodeList) SetStatus5XX(v int64) *DescribeDomainStatusCodeListResponseBodyStatusCodeList {
	s.Status5XX = &v
	return s
}

func (s *DescribeDomainStatusCodeListResponseBodyStatusCodeList) SetTime(v int64) *DescribeDomainStatusCodeListResponseBodyStatusCodeList {
	s.Time = &v
	return s
}

type DescribeDomainStatusCodeListResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeDomainStatusCodeListResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeDomainStatusCodeListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainStatusCodeListResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainStatusCodeListResponse) SetHeaders(v map[string]*string) *DescribeDomainStatusCodeListResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainStatusCodeListResponse) SetStatusCode(v int32) *DescribeDomainStatusCodeListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainStatusCodeListResponse) SetBody(v *DescribeDomainStatusCodeListResponseBody) *DescribeDomainStatusCodeListResponse {
	s.Body = v
	return s
}

type DescribeDomainTopAttackListRequest struct {
	// The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainTopAttackListRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTopAttackListRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainTopAttackListRequest) SetEndTime(v int64) *DescribeDomainTopAttackListRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainTopAttackListRequest) SetResourceGroupId(v string) *DescribeDomainTopAttackListRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDomainTopAttackListRequest) SetStartTime(v int64) *DescribeDomainTopAttackListRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainTopAttackListResponseBody struct {
	// The peak QPS of the website.
	AttackList []*DescribeDomainTopAttackListResponseBodyAttackList `json:"AttackList,omitempty" xml:"AttackList,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDomainTopAttackListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTopAttackListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainTopAttackListResponseBody) SetAttackList(v []*DescribeDomainTopAttackListResponseBodyAttackList) *DescribeDomainTopAttackListResponseBody {
	s.AttackList = v
	return s
}

func (s *DescribeDomainTopAttackListResponseBody) SetRequestId(v string) *DescribeDomainTopAttackListResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDomainTopAttackListResponseBodyAttackList struct {
	// The attack QPS. Unit: QPS
	Attack *int64 `json:"Attack,omitempty" xml:"Attack,omitempty"`
	// The number of all QPS, which includes normal and attack QPS. Unit: QPS.
	Count *int64 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The domain name of the website.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
}

func (s DescribeDomainTopAttackListResponseBodyAttackList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTopAttackListResponseBodyAttackList) GoString() string {
	return s.String()
}

func (s *DescribeDomainTopAttackListResponseBodyAttackList) SetAttack(v int64) *DescribeDomainTopAttackListResponseBodyAttackList {
	s.Attack = &v
	return s
}

func (s *DescribeDomainTopAttackListResponseBodyAttackList) SetCount(v int64) *DescribeDomainTopAttackListResponseBodyAttackList {
	s.Count = &v
	return s
}

func (s *DescribeDomainTopAttackListResponseBodyAttackList) SetDomain(v string) *DescribeDomainTopAttackListResponseBodyAttackList {
	s.Domain = &v
	return s
}

type DescribeDomainTopAttackListResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeDomainTopAttackListResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeDomainTopAttackListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainTopAttackListResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainTopAttackListResponse) SetHeaders(v map[string]*string) *DescribeDomainTopAttackListResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainTopAttackListResponse) SetStatusCode(v int32) *DescribeDomainTopAttackListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainTopAttackListResponse) SetBody(v *DescribeDomainTopAttackListResponseBody) *DescribeDomainTopAttackListResponse {
	s.Body = v
	return s
}

type DescribeDomainViewSourceCountriesRequest struct {
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainViewSourceCountriesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainViewSourceCountriesRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainViewSourceCountriesRequest) SetDomain(v string) *DescribeDomainViewSourceCountriesRequest {
	s.Domain = &v
	return s
}

func (s *DescribeDomainViewSourceCountriesRequest) SetEndTime(v int64) *DescribeDomainViewSourceCountriesRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainViewSourceCountriesRequest) SetResourceGroupId(v string) *DescribeDomainViewSourceCountriesRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDomainViewSourceCountriesRequest) SetStartTime(v int64) *DescribeDomainViewSourceCountriesRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainViewSourceCountriesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// An array consisting of the country or area from which the requests are sent.
	SourceCountrys []*DescribeDomainViewSourceCountriesResponseBodySourceCountrys `json:"SourceCountrys,omitempty" xml:"SourceCountrys,omitempty" type:"Repeated"`
}

func (s DescribeDomainViewSourceCountriesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainViewSourceCountriesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainViewSourceCountriesResponseBody) SetRequestId(v string) *DescribeDomainViewSourceCountriesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainViewSourceCountriesResponseBody) SetSourceCountrys(v []*DescribeDomainViewSourceCountriesResponseBodySourceCountrys) *DescribeDomainViewSourceCountriesResponseBody {
	s.SourceCountrys = v
	return s
}

type DescribeDomainViewSourceCountriesResponseBodySourceCountrys struct {
	// The total number of requests.
	Count *int64 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The abbreviation of the country or area. For more information, see the **Codes of countries and areas** section of the [Codes of administrative regions in China and codes of countries and areas](~~167926~~) topic. For example, **cn** indicates China, and **us** indicates the United States.
	CountryId *string `json:"CountryId,omitempty" xml:"CountryId,omitempty"`
}

func (s DescribeDomainViewSourceCountriesResponseBodySourceCountrys) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainViewSourceCountriesResponseBodySourceCountrys) GoString() string {
	return s.String()
}

func (s *DescribeDomainViewSourceCountriesResponseBodySourceCountrys) SetCount(v int64) *DescribeDomainViewSourceCountriesResponseBodySourceCountrys {
	s.Count = &v
	return s
}

func (s *DescribeDomainViewSourceCountriesResponseBodySourceCountrys) SetCountryId(v string) *DescribeDomainViewSourceCountriesResponseBodySourceCountrys {
	s.CountryId = &v
	return s
}

type DescribeDomainViewSourceCountriesResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeDomainViewSourceCountriesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeDomainViewSourceCountriesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainViewSourceCountriesResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainViewSourceCountriesResponse) SetHeaders(v map[string]*string) *DescribeDomainViewSourceCountriesResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainViewSourceCountriesResponse) SetStatusCode(v int32) *DescribeDomainViewSourceCountriesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainViewSourceCountriesResponse) SetBody(v *DescribeDomainViewSourceCountriesResponseBody) *DescribeDomainViewSourceCountriesResponse {
	s.Body = v
	return s
}

type DescribeDomainViewSourceProvincesRequest struct {
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeDomainViewSourceProvincesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainViewSourceProvincesRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainViewSourceProvincesRequest) SetDomain(v string) *DescribeDomainViewSourceProvincesRequest {
	s.Domain = &v
	return s
}

func (s *DescribeDomainViewSourceProvincesRequest) SetEndTime(v int64) *DescribeDomainViewSourceProvincesRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainViewSourceProvincesRequest) SetResourceGroupId(v string) *DescribeDomainViewSourceProvincesRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDomainViewSourceProvincesRequest) SetStartTime(v int64) *DescribeDomainViewSourceProvincesRequest {
	s.StartTime = &v
	return s
}

type DescribeDomainViewSourceProvincesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// An array consisting of the details of the administrative region in China from which the requests are sent.
	SourceProvinces []*DescribeDomainViewSourceProvincesResponseBodySourceProvinces `json:"SourceProvinces,omitempty" xml:"SourceProvinces,omitempty" type:"Repeated"`
}

func (s DescribeDomainViewSourceProvincesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainViewSourceProvincesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainViewSourceProvincesResponseBody) SetRequestId(v string) *DescribeDomainViewSourceProvincesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainViewSourceProvincesResponseBody) SetSourceProvinces(v []*DescribeDomainViewSourceProvincesResponseBodySourceProvinces) *DescribeDomainViewSourceProvincesResponseBody {
	s.SourceProvinces = v
	return s
}

type DescribeDomainViewSourceProvincesResponseBodySourceProvinces struct {
	// The total number of requests.
	Count *int64 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The ID of the region inside China. For more information, see the **Codes of administrative regions in China** section of the [Codes of administrative regions in China and codes of countries and areas](~~167926~~) topic. For example, **110000** indicates Beijing, and **120000** indicates Tianjin.
	ProvinceId *string `json:"ProvinceId,omitempty" xml:"ProvinceId,omitempty"`
}

func (s DescribeDomainViewSourceProvincesResponseBodySourceProvinces) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainViewSourceProvincesResponseBodySourceProvinces) GoString() string {
	return s.String()
}

func (s *DescribeDomainViewSourceProvincesResponseBodySourceProvinces) SetCount(v int64) *DescribeDomainViewSourceProvincesResponseBodySourceProvinces {
	s.Count = &v
	return s
}

func (s *DescribeDomainViewSourceProvincesResponseBodySourceProvinces) SetProvinceId(v string) *DescribeDomainViewSourceProvincesResponseBodySourceProvinces {
	s.ProvinceId = &v
	return s
}

type DescribeDomainViewSourceProvincesResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeDomainViewSourceProvincesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeDomainViewSourceProvincesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainViewSourceProvincesResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainViewSourceProvincesResponse) SetHeaders(v map[string]*string) *DescribeDomainViewSourceProvincesResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainViewSourceProvincesResponse) SetStatusCode(v int32) *DescribeDomainViewSourceProvincesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainViewSourceProvincesResponse) SetBody(v *DescribeDomainViewSourceProvincesResponseBody) *DescribeDomainViewSourceProvincesResponse {
	s.Body = v
	return s
}

type DescribeDomainViewTopCostTimeRequest struct {
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The number of URLs to query. Valid values: **1** to **100**.
	Top *int32 `json:"Top,omitempty" xml:"Top,omitempty"`
}

func (s DescribeDomainViewTopCostTimeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainViewTopCostTimeRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainViewTopCostTimeRequest) SetDomain(v string) *DescribeDomainViewTopCostTimeRequest {
	s.Domain = &v
	return s
}

func (s *DescribeDomainViewTopCostTimeRequest) SetEndTime(v int64) *DescribeDomainViewTopCostTimeRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainViewTopCostTimeRequest) SetResourceGroupId(v string) *DescribeDomainViewTopCostTimeRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDomainViewTopCostTimeRequest) SetStartTime(v int64) *DescribeDomainViewTopCostTimeRequest {
	s.StartTime = &v
	return s
}

func (s *DescribeDomainViewTopCostTimeRequest) SetTop(v int32) *DescribeDomainViewTopCostTimeRequest {
	s.Top = &v
	return s
}

type DescribeDomainViewTopCostTimeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The URLs which require the longest time to respond to requests.
	UrlList []*DescribeDomainViewTopCostTimeResponseBodyUrlList `json:"UrlList,omitempty" xml:"UrlList,omitempty" type:"Repeated"`
}

func (s DescribeDomainViewTopCostTimeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainViewTopCostTimeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainViewTopCostTimeResponseBody) SetRequestId(v string) *DescribeDomainViewTopCostTimeResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainViewTopCostTimeResponseBody) SetUrlList(v []*DescribeDomainViewTopCostTimeResponseBodyUrlList) *DescribeDomainViewTopCostTimeResponseBody {
	s.UrlList = v
	return s
}

type DescribeDomainViewTopCostTimeResponseBodyUrlList struct {
	// The response duration. Unit: milliseconds.
	CostTime *float32 `json:"CostTime,omitempty" xml:"CostTime,omitempty"`
	// The domain name of the website.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The URL that is Base64-encoded.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s DescribeDomainViewTopCostTimeResponseBodyUrlList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainViewTopCostTimeResponseBodyUrlList) GoString() string {
	return s.String()
}

func (s *DescribeDomainViewTopCostTimeResponseBodyUrlList) SetCostTime(v float32) *DescribeDomainViewTopCostTimeResponseBodyUrlList {
	s.CostTime = &v
	return s
}

func (s *DescribeDomainViewTopCostTimeResponseBodyUrlList) SetDomain(v string) *DescribeDomainViewTopCostTimeResponseBodyUrlList {
	s.Domain = &v
	return s
}

func (s *DescribeDomainViewTopCostTimeResponseBodyUrlList) SetUrl(v string) *DescribeDomainViewTopCostTimeResponseBodyUrlList {
	s.Url = &v
	return s
}

type DescribeDomainViewTopCostTimeResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeDomainViewTopCostTimeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeDomainViewTopCostTimeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainViewTopCostTimeResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainViewTopCostTimeResponse) SetHeaders(v map[string]*string) *DescribeDomainViewTopCostTimeResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainViewTopCostTimeResponse) SetStatusCode(v int32) *DescribeDomainViewTopCostTimeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainViewTopCostTimeResponse) SetBody(v *DescribeDomainViewTopCostTimeResponseBody) *DescribeDomainViewTopCostTimeResponse {
	s.Body = v
	return s
}

type DescribeDomainViewTopUrlRequest struct {
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The number of URLs to query. Valid values: **1** to **100**.
	Top *int32 `json:"Top,omitempty" xml:"Top,omitempty"`
}

func (s DescribeDomainViewTopUrlRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainViewTopUrlRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainViewTopUrlRequest) SetDomain(v string) *DescribeDomainViewTopUrlRequest {
	s.Domain = &v
	return s
}

func (s *DescribeDomainViewTopUrlRequest) SetEndTime(v int64) *DescribeDomainViewTopUrlRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeDomainViewTopUrlRequest) SetResourceGroupId(v string) *DescribeDomainViewTopUrlRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeDomainViewTopUrlRequest) SetStartTime(v int64) *DescribeDomainViewTopUrlRequest {
	s.StartTime = &v
	return s
}

func (s *DescribeDomainViewTopUrlRequest) SetTop(v int32) *DescribeDomainViewTopUrlRequest {
	s.Top = &v
	return s
}

type DescribeDomainViewTopUrlResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// An array consisting of the URLs that receive the most requests.
	UrlList []*DescribeDomainViewTopUrlResponseBodyUrlList `json:"UrlList,omitempty" xml:"UrlList,omitempty" type:"Repeated"`
}

func (s DescribeDomainViewTopUrlResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainViewTopUrlResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainViewTopUrlResponseBody) SetRequestId(v string) *DescribeDomainViewTopUrlResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainViewTopUrlResponseBody) SetUrlList(v []*DescribeDomainViewTopUrlResponseBodyUrlList) *DescribeDomainViewTopUrlResponseBody {
	s.UrlList = v
	return s
}

type DescribeDomainViewTopUrlResponseBodyUrlList struct {
	// The total number of requests.
	Count *int64 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The domain name of the website.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The URL that is Base64-encoded.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s DescribeDomainViewTopUrlResponseBodyUrlList) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainViewTopUrlResponseBodyUrlList) GoString() string {
	return s.String()
}

func (s *DescribeDomainViewTopUrlResponseBodyUrlList) SetCount(v int64) *DescribeDomainViewTopUrlResponseBodyUrlList {
	s.Count = &v
	return s
}

func (s *DescribeDomainViewTopUrlResponseBodyUrlList) SetDomain(v string) *DescribeDomainViewTopUrlResponseBodyUrlList {
	s.Domain = &v
	return s
}

func (s *DescribeDomainViewTopUrlResponseBodyUrlList) SetUrl(v string) *DescribeDomainViewTopUrlResponseBodyUrlList {
	s.Url = &v
	return s
}

type DescribeDomainViewTopUrlResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeDomainViewTopUrlResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeDomainViewTopUrlResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainViewTopUrlResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainViewTopUrlResponse) SetHeaders(v map[string]*string) *DescribeDomainViewTopUrlResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainViewTopUrlResponse) SetStatusCode(v int32) *DescribeDomainViewTopUrlResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainViewTopUrlResponse) SetBody(v *DescribeDomainViewTopUrlResponseBody) *DescribeDomainViewTopUrlResponse {
	s.Body = v
	return s
}

type DescribeDomainsRequest struct {
	// The ID of the instance that you want to query.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	//
	// For more information about resource groups, see [Create a resource group](~~94485~~).
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeDomainsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainsRequest) SetInstanceIds(v []*string) *DescribeDomainsRequest {
	s.InstanceIds = v
	return s
}

func (s *DescribeDomainsRequest) SetResourceGroupId(v string) *DescribeDomainsRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeDomainsResponseBody struct {
	// An array consisting of details of the domain name for which the forwarding rules are configured.
	Domains []*string `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDomainsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainsResponseBody) SetDomains(v []*string) *DescribeDomainsResponseBody {
	s.Domains = v
	return s
}

func (s *DescribeDomainsResponseBody) SetRequestId(v string) *DescribeDomainsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDomainsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeDomainsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeDomainsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainsResponse) SetHeaders(v map[string]*string) *DescribeDomainsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainsResponse) SetStatusCode(v int32) *DescribeDomainsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainsResponse) SetBody(v *DescribeDomainsResponseBody) *DescribeDomainsResponse {
	s.Body = v
	return s
}

type DescribeElasticBandwidthSpecRequest struct {
	// The ID of the instance.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s DescribeElasticBandwidthSpecRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeElasticBandwidthSpecRequest) GoString() string {
	return s.String()
}

func (s *DescribeElasticBandwidthSpecRequest) SetInstanceId(v string) *DescribeElasticBandwidthSpecRequest {
	s.InstanceId = &v
	return s
}

type DescribeElasticBandwidthSpecResponseBody struct {
	// An array that consists of the available burstable protection bandwidths. Unit: Gbit/s.
	ElasticBandwidthSpec []*string `json:"ElasticBandwidthSpec,omitempty" xml:"ElasticBandwidthSpec,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeElasticBandwidthSpecResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeElasticBandwidthSpecResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeElasticBandwidthSpecResponseBody) SetElasticBandwidthSpec(v []*string) *DescribeElasticBandwidthSpecResponseBody {
	s.ElasticBandwidthSpec = v
	return s
}

func (s *DescribeElasticBandwidthSpecResponseBody) SetRequestId(v string) *DescribeElasticBandwidthSpecResponseBody {
	s.RequestId = &v
	return s
}

type DescribeElasticBandwidthSpecResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeElasticBandwidthSpecResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeElasticBandwidthSpecResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeElasticBandwidthSpecResponse) GoString() string {
	return s.String()
}

func (s *DescribeElasticBandwidthSpecResponse) SetHeaders(v map[string]*string) *DescribeElasticBandwidthSpecResponse {
	s.Headers = v
	return s
}

func (s *DescribeElasticBandwidthSpecResponse) SetStatusCode(v int32) *DescribeElasticBandwidthSpecResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeElasticBandwidthSpecResponse) SetBody(v *DescribeElasticBandwidthSpecResponseBody) *DescribeElasticBandwidthSpecResponse {
	s.Body = v
	return s
}

type DescribeElasticQpsRequest struct {
	EndTime   *int64  `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	Interval  *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	Ip        *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	Region    *string `json:"Region,omitempty" xml:"Region,omitempty"`
	StartTime *int64  `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeElasticQpsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeElasticQpsRequest) GoString() string {
	return s.String()
}

func (s *DescribeElasticQpsRequest) SetEndTime(v int64) *DescribeElasticQpsRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeElasticQpsRequest) SetInterval(v string) *DescribeElasticQpsRequest {
	s.Interval = &v
	return s
}

func (s *DescribeElasticQpsRequest) SetIp(v string) *DescribeElasticQpsRequest {
	s.Ip = &v
	return s
}

func (s *DescribeElasticQpsRequest) SetRegion(v string) *DescribeElasticQpsRequest {
	s.Region = &v
	return s
}

func (s *DescribeElasticQpsRequest) SetStartTime(v int64) *DescribeElasticQpsRequest {
	s.StartTime = &v
	return s
}

type DescribeElasticQpsResponseBody struct {
	ElasticQps []*DescribeElasticQpsResponseBodyElasticQps `json:"ElasticQps,omitempty" xml:"ElasticQps,omitempty" type:"Repeated"`
	RequestId  *string                                     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeElasticQpsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeElasticQpsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeElasticQpsResponseBody) SetElasticQps(v []*DescribeElasticQpsResponseBodyElasticQps) *DescribeElasticQpsResponseBody {
	s.ElasticQps = v
	return s
}

func (s *DescribeElasticQpsResponseBody) SetRequestId(v string) *DescribeElasticQpsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeElasticQpsResponseBodyElasticQps struct {
	Index        *int64 `json:"Index,omitempty" xml:"Index,omitempty"`
	MaxNormalQps *int64 `json:"MaxNormalQps,omitempty" xml:"MaxNormalQps,omitempty"`
	MaxQps       *int64 `json:"MaxQps,omitempty" xml:"MaxQps,omitempty"`
	Pv           *int64 `json:"Pv,omitempty" xml:"Pv,omitempty"`
	Status2      *int64 `json:"Status2,omitempty" xml:"Status2,omitempty"`
	Status3      *int64 `json:"Status3,omitempty" xml:"Status3,omitempty"`
	Status4      *int64 `json:"Status4,omitempty" xml:"Status4,omitempty"`
	Status5      *int64 `json:"Status5,omitempty" xml:"Status5,omitempty"`
	Ups          *int64 `json:"Ups,omitempty" xml:"Ups,omitempty"`
}

func (s DescribeElasticQpsResponseBodyElasticQps) String() string {
	return tea.Prettify(s)
}

func (s DescribeElasticQpsResponseBodyElasticQps) GoString() string {
	return s.String()
}

func (s *DescribeElasticQpsResponseBodyElasticQps) SetIndex(v int64) *DescribeElasticQpsResponseBodyElasticQps {
	s.Index = &v
	return s
}

func (s *DescribeElasticQpsResponseBodyElasticQps) SetMaxNormalQps(v int64) *DescribeElasticQpsResponseBodyElasticQps {
	s.MaxNormalQps = &v
	return s
}

func (s *DescribeElasticQpsResponseBodyElasticQps) SetMaxQps(v int64) *DescribeElasticQpsResponseBodyElasticQps {
	s.MaxQps = &v
	return s
}

func (s *DescribeElasticQpsResponseBodyElasticQps) SetPv(v int64) *DescribeElasticQpsResponseBodyElasticQps {
	s.Pv = &v
	return s
}

func (s *DescribeElasticQpsResponseBodyElasticQps) SetStatus2(v int64) *DescribeElasticQpsResponseBodyElasticQps {
	s.Status2 = &v
	return s
}

func (s *DescribeElasticQpsResponseBodyElasticQps) SetStatus3(v int64) *DescribeElasticQpsResponseBodyElasticQps {
	s.Status3 = &v
	return s
}

func (s *DescribeElasticQpsResponseBodyElasticQps) SetStatus4(v int64) *DescribeElasticQpsResponseBodyElasticQps {
	s.Status4 = &v
	return s
}

func (s *DescribeElasticQpsResponseBodyElasticQps) SetStatus5(v int64) *DescribeElasticQpsResponseBodyElasticQps {
	s.Status5 = &v
	return s
}

func (s *DescribeElasticQpsResponseBodyElasticQps) SetUps(v int64) *DescribeElasticQpsResponseBodyElasticQps {
	s.Ups = &v
	return s
}

type DescribeElasticQpsResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeElasticQpsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeElasticQpsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeElasticQpsResponse) GoString() string {
	return s.String()
}

func (s *DescribeElasticQpsResponse) SetHeaders(v map[string]*string) *DescribeElasticQpsResponse {
	s.Headers = v
	return s
}

func (s *DescribeElasticQpsResponse) SetStatusCode(v int32) *DescribeElasticQpsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeElasticQpsResponse) SetBody(v *DescribeElasticQpsResponseBody) *DescribeElasticQpsResponse {
	s.Body = v
	return s
}

type DescribeElasticQpsRecordRequest struct {
	EndTime   *int64  `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	Ip        *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	StartTime *int64  `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeElasticQpsRecordRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeElasticQpsRecordRequest) GoString() string {
	return s.String()
}

func (s *DescribeElasticQpsRecordRequest) SetEndTime(v int64) *DescribeElasticQpsRecordRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeElasticQpsRecordRequest) SetIp(v string) *DescribeElasticQpsRecordRequest {
	s.Ip = &v
	return s
}

func (s *DescribeElasticQpsRecordRequest) SetStartTime(v int64) *DescribeElasticQpsRecordRequest {
	s.StartTime = &v
	return s
}

type DescribeElasticQpsRecordResponseBody struct {
	ElasticQpsList []*DescribeElasticQpsRecordResponseBodyElasticQpsList `json:"ElasticQpsList,omitempty" xml:"ElasticQpsList,omitempty" type:"Repeated"`
	RequestId      *string                                               `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeElasticQpsRecordResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeElasticQpsRecordResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeElasticQpsRecordResponseBody) SetElasticQpsList(v []*DescribeElasticQpsRecordResponseBodyElasticQpsList) *DescribeElasticQpsRecordResponseBody {
	s.ElasticQpsList = v
	return s
}

func (s *DescribeElasticQpsRecordResponseBody) SetRequestId(v string) *DescribeElasticQpsRecordResponseBody {
	s.RequestId = &v
	return s
}

type DescribeElasticQpsRecordResponseBodyElasticQpsList struct {
	Date          *int64  `json:"Date,omitempty" xml:"Date,omitempty"`
	InstanceId    *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	Ip            *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	OpsElasticQps *int64  `json:"OpsElasticQps,omitempty" xml:"OpsElasticQps,omitempty"`
	OpsQps        *int64  `json:"OpsQps,omitempty" xml:"OpsQps,omitempty"`
	OriginQps     *int64  `json:"OriginQps,omitempty" xml:"OriginQps,omitempty"`
	Qps           *int64  `json:"Qps,omitempty" xml:"Qps,omitempty"`
	QpsPeak       *int64  `json:"QpsPeak,omitempty" xml:"QpsPeak,omitempty"`
	Status        *int64  `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeElasticQpsRecordResponseBodyElasticQpsList) String() string {
	return tea.Prettify(s)
}

func (s DescribeElasticQpsRecordResponseBodyElasticQpsList) GoString() string {
	return s.String()
}

func (s *DescribeElasticQpsRecordResponseBodyElasticQpsList) SetDate(v int64) *DescribeElasticQpsRecordResponseBodyElasticQpsList {
	s.Date = &v
	return s
}

func (s *DescribeElasticQpsRecordResponseBodyElasticQpsList) SetInstanceId(v string) *DescribeElasticQpsRecordResponseBodyElasticQpsList {
	s.InstanceId = &v
	return s
}

func (s *DescribeElasticQpsRecordResponseBodyElasticQpsList) SetIp(v string) *DescribeElasticQpsRecordResponseBodyElasticQpsList {
	s.Ip = &v
	return s
}

func (s *DescribeElasticQpsRecordResponseBodyElasticQpsList) SetOpsElasticQps(v int64) *DescribeElasticQpsRecordResponseBodyElasticQpsList {
	s.OpsElasticQps = &v
	return s
}

func (s *DescribeElasticQpsRecordResponseBodyElasticQpsList) SetOpsQps(v int64) *DescribeElasticQpsRecordResponseBodyElasticQpsList {
	s.OpsQps = &v
	return s
}

func (s *DescribeElasticQpsRecordResponseBodyElasticQpsList) SetOriginQps(v int64) *DescribeElasticQpsRecordResponseBodyElasticQpsList {
	s.OriginQps = &v
	return s
}

func (s *DescribeElasticQpsRecordResponseBodyElasticQpsList) SetQps(v int64) *DescribeElasticQpsRecordResponseBodyElasticQpsList {
	s.Qps = &v
	return s
}

func (s *DescribeElasticQpsRecordResponseBodyElasticQpsList) SetQpsPeak(v int64) *DescribeElasticQpsRecordResponseBodyElasticQpsList {
	s.QpsPeak = &v
	return s
}

func (s *DescribeElasticQpsRecordResponseBodyElasticQpsList) SetStatus(v int64) *DescribeElasticQpsRecordResponseBodyElasticQpsList {
	s.Status = &v
	return s
}

type DescribeElasticQpsRecordResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeElasticQpsRecordResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeElasticQpsRecordResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeElasticQpsRecordResponse) GoString() string {
	return s.String()
}

func (s *DescribeElasticQpsRecordResponse) SetHeaders(v map[string]*string) *DescribeElasticQpsRecordResponse {
	s.Headers = v
	return s
}

func (s *DescribeElasticQpsRecordResponse) SetStatusCode(v int32) *DescribeElasticQpsRecordResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeElasticQpsRecordResponse) SetBody(v *DescribeElasticQpsRecordResponseBody) *DescribeElasticQpsRecordResponse {
	s.Body = v
	return s
}

type DescribeHeadersRequest struct {
	// The domain name that you want to query.
	//
	// > You can call the [DescribeDomains](~~91724~~) operation to query all the domain names that are added to Anti-DDoS Pro or Anti-DDoS Premium.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeHeadersRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeHeadersRequest) GoString() string {
	return s.String()
}

func (s *DescribeHeadersRequest) SetDomain(v string) *DescribeHeadersRequest {
	s.Domain = &v
	return s
}

func (s *DescribeHeadersRequest) SetResourceGroupId(v string) *DescribeHeadersRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeHeadersResponseBody struct {
	// The information about the custom header.
	CustomHeader *DescribeHeadersResponseBodyCustomHeader `json:"CustomHeader,omitempty" xml:"CustomHeader,omitempty" type:"Struct"`
	// The ID of the request, which is used to locate and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeHeadersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeHeadersResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeHeadersResponseBody) SetCustomHeader(v *DescribeHeadersResponseBodyCustomHeader) *DescribeHeadersResponseBody {
	s.CustomHeader = v
	return s
}

func (s *DescribeHeadersResponseBody) SetRequestId(v string) *DescribeHeadersResponseBody {
	s.RequestId = &v
	return s
}

type DescribeHeadersResponseBodyCustomHeader struct {
	// The domain name of the website.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The header of the response.
	Headers *string `json:"Headers,omitempty" xml:"Headers,omitempty"`
}

func (s DescribeHeadersResponseBodyCustomHeader) String() string {
	return tea.Prettify(s)
}

func (s DescribeHeadersResponseBodyCustomHeader) GoString() string {
	return s.String()
}

func (s *DescribeHeadersResponseBodyCustomHeader) SetDomain(v string) *DescribeHeadersResponseBodyCustomHeader {
	s.Domain = &v
	return s
}

func (s *DescribeHeadersResponseBodyCustomHeader) SetHeaders(v string) *DescribeHeadersResponseBodyCustomHeader {
	s.Headers = &v
	return s
}

type DescribeHeadersResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeHeadersResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeHeadersResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeHeadersResponse) GoString() string {
	return s.String()
}

func (s *DescribeHeadersResponse) SetHeaders(v map[string]*string) *DescribeHeadersResponse {
	s.Headers = v
	return s
}

func (s *DescribeHeadersResponse) SetStatusCode(v int32) *DescribeHeadersResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeHeadersResponse) SetBody(v *DescribeHeadersResponseBody) *DescribeHeadersResponse {
	s.Body = v
	return s
}

type DescribeHealthCheckListRequest struct {
	// The information about the port forwarding rule. This parameter is a JSON string. The string contains the following fields:
	//
	// *   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
	// *   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
	// *   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.
	NetworkRules *string `json:"NetworkRules,omitempty" xml:"NetworkRules,omitempty"`
}

func (s DescribeHealthCheckListRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeHealthCheckListRequest) GoString() string {
	return s.String()
}

func (s *DescribeHealthCheckListRequest) SetNetworkRules(v string) *DescribeHealthCheckListRequest {
	s.NetworkRules = &v
	return s
}

type DescribeHealthCheckListResponseBody struct {
	// An array that consists of information about the health check configuration.
	HealthCheckList []*DescribeHealthCheckListResponseBodyHealthCheckList `json:"HealthCheckList,omitempty" xml:"HealthCheckList,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeHealthCheckListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeHealthCheckListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeHealthCheckListResponseBody) SetHealthCheckList(v []*DescribeHealthCheckListResponseBodyHealthCheckList) *DescribeHealthCheckListResponseBody {
	s.HealthCheckList = v
	return s
}

func (s *DescribeHealthCheckListResponseBody) SetRequestId(v string) *DescribeHealthCheckListResponseBody {
	s.RequestId = &v
	return s
}

type DescribeHealthCheckListResponseBodyHealthCheckList struct {
	// The forwarding port.
	FrontendPort *int32 `json:"FrontendPort,omitempty" xml:"FrontendPort,omitempty"`
	// The health check configuration.
	HealthCheck *DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck `json:"HealthCheck,omitempty" xml:"HealthCheck,omitempty" type:"Struct"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The forwarding protocol. Valid values:
	//
	// *   **tcp**
	// *   **udp**
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
}

func (s DescribeHealthCheckListResponseBodyHealthCheckList) String() string {
	return tea.Prettify(s)
}

func (s DescribeHealthCheckListResponseBodyHealthCheckList) GoString() string {
	return s.String()
}

func (s *DescribeHealthCheckListResponseBodyHealthCheckList) SetFrontendPort(v int32) *DescribeHealthCheckListResponseBodyHealthCheckList {
	s.FrontendPort = &v
	return s
}

func (s *DescribeHealthCheckListResponseBodyHealthCheckList) SetHealthCheck(v *DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck) *DescribeHealthCheckListResponseBodyHealthCheckList {
	s.HealthCheck = v
	return s
}

func (s *DescribeHealthCheckListResponseBodyHealthCheckList) SetInstanceId(v string) *DescribeHealthCheckListResponseBodyHealthCheckList {
	s.InstanceId = &v
	return s
}

func (s *DescribeHealthCheckListResponseBodyHealthCheckList) SetProtocol(v string) *DescribeHealthCheckListResponseBodyHealthCheckList {
	s.Protocol = &v
	return s
}

type DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck struct {
	// The domain name.
	//
	// > This parameter is returned only when the Layer 7 health check configuration is queried.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The number of consecutive failed health checks that must occur before a port is declared unhealthy. Valid values: **1** to **10**.
	Down *int32 `json:"Down,omitempty" xml:"Down,omitempty"`
	// The interval at which checks are performed. Valid values: **1** to **30**. Unit: seconds.
	Interval *int32 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The port that was checked.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The response timeout period. Valid values: **1** to **30**. Unit: seconds.
	Timeout *int32 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
	// The type of the protocol. Valid values:
	//
	// *   **tcp**: The Layer 4 health check configuration was queried.
	// *   **http**: The Layer 7 health check configuration was queried.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The number of consecutive successful health checks that must occur before a port is declared healthy. Valid values: **1** to **10**.
	Up *int32 `json:"Up,omitempty" xml:"Up,omitempty"`
	// The check path.
	//
	// > This parameter is returned only when the Layer 7 health check configuration is queried.
	Uri *string `json:"Uri,omitempty" xml:"Uri,omitempty"`
}

func (s DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck) String() string {
	return tea.Prettify(s)
}

func (s DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck) GoString() string {
	return s.String()
}

func (s *DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck) SetDomain(v string) *DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck {
	s.Domain = &v
	return s
}

func (s *DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck) SetDown(v int32) *DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck {
	s.Down = &v
	return s
}

func (s *DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck) SetInterval(v int32) *DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck {
	s.Interval = &v
	return s
}

func (s *DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck) SetPort(v int32) *DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck {
	s.Port = &v
	return s
}

func (s *DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck) SetTimeout(v int32) *DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck {
	s.Timeout = &v
	return s
}

func (s *DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck) SetType(v string) *DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck {
	s.Type = &v
	return s
}

func (s *DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck) SetUp(v int32) *DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck {
	s.Up = &v
	return s
}

func (s *DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck) SetUri(v string) *DescribeHealthCheckListResponseBodyHealthCheckListHealthCheck {
	s.Uri = &v
	return s
}

type DescribeHealthCheckListResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeHealthCheckListResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeHealthCheckListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeHealthCheckListResponse) GoString() string {
	return s.String()
}

func (s *DescribeHealthCheckListResponse) SetHeaders(v map[string]*string) *DescribeHealthCheckListResponse {
	s.Headers = v
	return s
}

func (s *DescribeHealthCheckListResponse) SetStatusCode(v int32) *DescribeHealthCheckListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeHealthCheckListResponse) SetBody(v *DescribeHealthCheckListResponseBody) *DescribeHealthCheckListResponse {
	s.Body = v
	return s
}

type DescribeHealthCheckStatusRequest struct {
	// An array that consists of the details of the port forwarding rule. This parameter is a JSON string. The string contains the following fields:
	//
	// *   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
	// *   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
	// *   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.
	NetworkRules *string `json:"NetworkRules,omitempty" xml:"NetworkRules,omitempty"`
}

func (s DescribeHealthCheckStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeHealthCheckStatusRequest) GoString() string {
	return s.String()
}

func (s *DescribeHealthCheckStatusRequest) SetNetworkRules(v string) *DescribeHealthCheckStatusRequest {
	s.NetworkRules = &v
	return s
}

type DescribeHealthCheckStatusResponseBody struct {
	// An array that consists of the details of the health status of the origin server.
	HealthCheckStatus []*DescribeHealthCheckStatusResponseBodyHealthCheckStatus `json:"HealthCheckStatus,omitempty" xml:"HealthCheckStatus,omitempty" type:"Repeated"`
	// The ID of the request, which is used to locate and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeHealthCheckStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeHealthCheckStatusResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeHealthCheckStatusResponseBody) SetHealthCheckStatus(v []*DescribeHealthCheckStatusResponseBodyHealthCheckStatus) *DescribeHealthCheckStatusResponseBody {
	s.HealthCheckStatus = v
	return s
}

func (s *DescribeHealthCheckStatusResponseBody) SetRequestId(v string) *DescribeHealthCheckStatusResponseBody {
	s.RequestId = &v
	return s
}

type DescribeHealthCheckStatusResponseBodyHealthCheckStatus struct {
	// The forwarding port.
	FrontendPort *int32 `json:"FrontendPort,omitempty" xml:"FrontendPort,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The forwarding protocol. Valid values:
	//
	// *   **tcp**
	// *   **udp**
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// An array that consists of the health states of the IP addresses of the origin server.
	RealServerStatusList []*DescribeHealthCheckStatusResponseBodyHealthCheckStatusRealServerStatusList `json:"RealServerStatusList,omitempty" xml:"RealServerStatusList,omitempty" type:"Repeated"`
	// The health status of the origin server. Valid values:
	//
	// *   **normal**: healthy
	// *   **abnormal**: unhealthy
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeHealthCheckStatusResponseBodyHealthCheckStatus) String() string {
	return tea.Prettify(s)
}

func (s DescribeHealthCheckStatusResponseBodyHealthCheckStatus) GoString() string {
	return s.String()
}

func (s *DescribeHealthCheckStatusResponseBodyHealthCheckStatus) SetFrontendPort(v int32) *DescribeHealthCheckStatusResponseBodyHealthCheckStatus {
	s.FrontendPort = &v
	return s
}

func (s *DescribeHealthCheckStatusResponseBodyHealthCheckStatus) SetInstanceId(v string) *DescribeHealthCheckStatusResponseBodyHealthCheckStatus {
	s.InstanceId = &v
	return s
}

func (s *DescribeHealthCheckStatusResponseBodyHealthCheckStatus) SetProtocol(v string) *DescribeHealthCheckStatusResponseBodyHealthCheckStatus {
	s.Protocol = &v
	return s
}

func (s *DescribeHealthCheckStatusResponseBodyHealthCheckStatus) SetRealServerStatusList(v []*DescribeHealthCheckStatusResponseBodyHealthCheckStatusRealServerStatusList) *DescribeHealthCheckStatusResponseBodyHealthCheckStatus {
	s.RealServerStatusList = v
	return s
}

func (s *DescribeHealthCheckStatusResponseBodyHealthCheckStatus) SetStatus(v string) *DescribeHealthCheckStatusResponseBodyHealthCheckStatus {
	s.Status = &v
	return s
}

type DescribeHealthCheckStatusResponseBodyHealthCheckStatusRealServerStatusList struct {
	// The IP address of the origin server.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// The health state of the IP address. Valid values:
	//
	// *   **normal**: healthy
	// *   **abnormal**: unhealthy
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeHealthCheckStatusResponseBodyHealthCheckStatusRealServerStatusList) String() string {
	return tea.Prettify(s)
}

func (s DescribeHealthCheckStatusResponseBodyHealthCheckStatusRealServerStatusList) GoString() string {
	return s.String()
}

func (s *DescribeHealthCheckStatusResponseBodyHealthCheckStatusRealServerStatusList) SetAddress(v string) *DescribeHealthCheckStatusResponseBodyHealthCheckStatusRealServerStatusList {
	s.Address = &v
	return s
}

func (s *DescribeHealthCheckStatusResponseBodyHealthCheckStatusRealServerStatusList) SetStatus(v string) *DescribeHealthCheckStatusResponseBodyHealthCheckStatusRealServerStatusList {
	s.Status = &v
	return s
}

type DescribeHealthCheckStatusResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeHealthCheckStatusResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeHealthCheckStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeHealthCheckStatusResponse) GoString() string {
	return s.String()
}

func (s *DescribeHealthCheckStatusResponse) SetHeaders(v map[string]*string) *DescribeHealthCheckStatusResponse {
	s.Headers = v
	return s
}

func (s *DescribeHealthCheckStatusResponse) SetStatusCode(v int32) *DescribeHealthCheckStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeHealthCheckStatusResponse) SetBody(v *DescribeHealthCheckStatusResponseBody) *DescribeHealthCheckStatusResponse {
	s.Body = v
	return s
}

type DescribeInstanceDetailsRequest struct {
	// An array that consists of the IDs of instances to query.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
}

func (s DescribeInstanceDetailsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceDetailsRequest) GoString() string {
	return s.String()
}

func (s *DescribeInstanceDetailsRequest) SetInstanceIds(v []*string) *DescribeInstanceDetailsRequest {
	s.InstanceIds = v
	return s
}

type DescribeInstanceDetailsResponseBody struct {
	// The IP address and ISP line information about the instance.
	InstanceDetails []*DescribeInstanceDetailsResponseBodyInstanceDetails `json:"InstanceDetails,omitempty" xml:"InstanceDetails,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeInstanceDetailsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceDetailsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeInstanceDetailsResponseBody) SetInstanceDetails(v []*DescribeInstanceDetailsResponseBodyInstanceDetails) *DescribeInstanceDetailsResponseBody {
	s.InstanceDetails = v
	return s
}

func (s *DescribeInstanceDetailsResponseBody) SetRequestId(v string) *DescribeInstanceDetailsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeInstanceDetailsResponseBodyInstanceDetails struct {
	// The information about the IP address of the instance.
	EipInfos []*DescribeInstanceDetailsResponseBodyInstanceDetailsEipInfos `json:"EipInfos,omitempty" xml:"EipInfos,omitempty" type:"Repeated"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The protection line of the instance.
	Line *string `json:"Line,omitempty" xml:"Line,omitempty"`
}

func (s DescribeInstanceDetailsResponseBodyInstanceDetails) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceDetailsResponseBodyInstanceDetails) GoString() string {
	return s.String()
}

func (s *DescribeInstanceDetailsResponseBodyInstanceDetails) SetEipInfos(v []*DescribeInstanceDetailsResponseBodyInstanceDetailsEipInfos) *DescribeInstanceDetailsResponseBodyInstanceDetails {
	s.EipInfos = v
	return s
}

func (s *DescribeInstanceDetailsResponseBodyInstanceDetails) SetInstanceId(v string) *DescribeInstanceDetailsResponseBodyInstanceDetails {
	s.InstanceId = &v
	return s
}

func (s *DescribeInstanceDetailsResponseBodyInstanceDetails) SetLine(v string) *DescribeInstanceDetailsResponseBodyInstanceDetails {
	s.Line = &v
	return s
}

type DescribeInstanceDetailsResponseBodyInstanceDetailsEipInfos struct {
	// The IP address of the instance.
	Eip *string `json:"Eip,omitempty" xml:"Eip,omitempty"`
	// The IP address-based forwarding mode of the instance. Valid values:
	//
	// *   **fnat**: Requests from IPv4 addresses are forwarded to origin servers that use IPv4 addresses and requests from IPv6 addresses are forwarded to origin servers that use IPv6 addresses.
	// *   **v6tov4**: All requests are forwarded to origin servers that use IPv4 addresses.
	IpMode *string `json:"IpMode,omitempty" xml:"IpMode,omitempty"`
	// The IP version of the protocol. Valid values:
	//
	// *   **Ipv4**: IPv4
	// *   **Ipv6**: IPv6
	IpVersion *string `json:"IpVersion,omitempty" xml:"IpVersion,omitempty"`
	// The status of the instance. Valid values:
	//
	// *   **normal**: indicates that the instance is normal.
	// *   **expired**: indicates that the instance expired.
	// *   **defense**: indicates that traffic scrubbing is performed on the asset that is protected by the instance.
	// *   **blackhole**: indicates that blackhole filtering is triggered for the asset that is protected by the instance.
	// *   **punished**: indicates that the instance is in penalty.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeInstanceDetailsResponseBodyInstanceDetailsEipInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceDetailsResponseBodyInstanceDetailsEipInfos) GoString() string {
	return s.String()
}

func (s *DescribeInstanceDetailsResponseBodyInstanceDetailsEipInfos) SetEip(v string) *DescribeInstanceDetailsResponseBodyInstanceDetailsEipInfos {
	s.Eip = &v
	return s
}

func (s *DescribeInstanceDetailsResponseBodyInstanceDetailsEipInfos) SetIpMode(v string) *DescribeInstanceDetailsResponseBodyInstanceDetailsEipInfos {
	s.IpMode = &v
	return s
}

func (s *DescribeInstanceDetailsResponseBodyInstanceDetailsEipInfos) SetIpVersion(v string) *DescribeInstanceDetailsResponseBodyInstanceDetailsEipInfos {
	s.IpVersion = &v
	return s
}

func (s *DescribeInstanceDetailsResponseBodyInstanceDetailsEipInfos) SetStatus(v string) *DescribeInstanceDetailsResponseBodyInstanceDetailsEipInfos {
	s.Status = &v
	return s
}

type DescribeInstanceDetailsResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeInstanceDetailsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeInstanceDetailsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceDetailsResponse) GoString() string {
	return s.String()
}

func (s *DescribeInstanceDetailsResponse) SetHeaders(v map[string]*string) *DescribeInstanceDetailsResponse {
	s.Headers = v
	return s
}

func (s *DescribeInstanceDetailsResponse) SetStatusCode(v int32) *DescribeInstanceDetailsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeInstanceDetailsResponse) SetBody(v *DescribeInstanceDetailsResponseBody) *DescribeInstanceDetailsResponse {
	s.Body = v
	return s
}

type DescribeInstanceExtRequest struct {
	// The ID of the instance.
	//
	// >  You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The number of the page. For example, to query the returned results on the first page, set the value to **1**.
	PageNumber *string `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	PageSize *string `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribeInstanceExtRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceExtRequest) GoString() string {
	return s.String()
}

func (s *DescribeInstanceExtRequest) SetInstanceId(v string) *DescribeInstanceExtRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeInstanceExtRequest) SetPageNumber(v string) *DescribeInstanceExtRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeInstanceExtRequest) SetPageSize(v string) *DescribeInstanceExtRequest {
	s.PageSize = &v
	return s
}

type DescribeInstanceExtResponseBody struct {
	// The information about the instance.
	InstanceExtSpecs []*DescribeInstanceExtResponseBodyInstanceExtSpecs `json:"InstanceExtSpecs,omitempty" xml:"InstanceExtSpecs,omitempty" type:"Repeated"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of queried instances.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeInstanceExtResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceExtResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeInstanceExtResponseBody) SetInstanceExtSpecs(v []*DescribeInstanceExtResponseBodyInstanceExtSpecs) *DescribeInstanceExtResponseBody {
	s.InstanceExtSpecs = v
	return s
}

func (s *DescribeInstanceExtResponseBody) SetRequestId(v string) *DescribeInstanceExtResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeInstanceExtResponseBody) SetTotalCount(v int64) *DescribeInstanceExtResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeInstanceExtResponseBodyInstanceExtSpecs struct {
	// The function plan. Valid values:
	//
	// *   **0**: Standard
	// *   **1**: Enhanced
	FunctionVersion *int64 `json:"FunctionVersion,omitempty" xml:"FunctionVersion,omitempty"`
	// The instance ID
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The clean bandwidth. Unit: Mbit/s.
	NormalBandwidth *int64 `json:"NormalBandwidth,omitempty" xml:"NormalBandwidth,omitempty"`
	// The type of the instance. Valid value:
	//
	// *   **0**: Anti-DDoS Premium instance of the Insurance mitigation plan
	// *   **1**: Anti-DDoS Premium instance of the Unlimited mitigation plan
	// *   **2**: Anti-DDoS Premium instance of the CMA mitigation plan
	// *   **3**: Anti-DDoS Premium instance of the Secure Chinese Mainland Acceleration (Sec-CMA) plan
	// *   **9**: Anti-DDoS Pro instance of the Profession mitigation plan
	ProductPlan *int64 `json:"ProductPlan,omitempty" xml:"ProductPlan,omitempty"`
	// The Internet service provider (ISP) line resource of the Anti-DDoS Pro instance.
	ServicePartner *string `json:"ServicePartner,omitempty" xml:"ServicePartner,omitempty"`
}

func (s DescribeInstanceExtResponseBodyInstanceExtSpecs) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceExtResponseBodyInstanceExtSpecs) GoString() string {
	return s.String()
}

func (s *DescribeInstanceExtResponseBodyInstanceExtSpecs) SetFunctionVersion(v int64) *DescribeInstanceExtResponseBodyInstanceExtSpecs {
	s.FunctionVersion = &v
	return s
}

func (s *DescribeInstanceExtResponseBodyInstanceExtSpecs) SetInstanceId(v string) *DescribeInstanceExtResponseBodyInstanceExtSpecs {
	s.InstanceId = &v
	return s
}

func (s *DescribeInstanceExtResponseBodyInstanceExtSpecs) SetNormalBandwidth(v int64) *DescribeInstanceExtResponseBodyInstanceExtSpecs {
	s.NormalBandwidth = &v
	return s
}

func (s *DescribeInstanceExtResponseBodyInstanceExtSpecs) SetProductPlan(v int64) *DescribeInstanceExtResponseBodyInstanceExtSpecs {
	s.ProductPlan = &v
	return s
}

func (s *DescribeInstanceExtResponseBodyInstanceExtSpecs) SetServicePartner(v string) *DescribeInstanceExtResponseBodyInstanceExtSpecs {
	s.ServicePartner = &v
	return s
}

type DescribeInstanceExtResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeInstanceExtResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeInstanceExtResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceExtResponse) GoString() string {
	return s.String()
}

func (s *DescribeInstanceExtResponse) SetHeaders(v map[string]*string) *DescribeInstanceExtResponse {
	s.Headers = v
	return s
}

func (s *DescribeInstanceExtResponse) SetStatusCode(v int32) *DescribeInstanceExtResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeInstanceExtResponse) SetBody(v *DescribeInstanceExtResponseBody) *DescribeInstanceExtResponse {
	s.Body = v
	return s
}

type DescribeInstanceIdsRequest struct {
	Edition         *int32    `json:"Edition,omitempty" xml:"Edition,omitempty"`
	InstanceIds     []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	ResourceGroupId *string   `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeInstanceIdsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceIdsRequest) GoString() string {
	return s.String()
}

func (s *DescribeInstanceIdsRequest) SetEdition(v int32) *DescribeInstanceIdsRequest {
	s.Edition = &v
	return s
}

func (s *DescribeInstanceIdsRequest) SetInstanceIds(v []*string) *DescribeInstanceIdsRequest {
	s.InstanceIds = v
	return s
}

func (s *DescribeInstanceIdsRequest) SetResourceGroupId(v string) *DescribeInstanceIdsRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeInstanceIdsResponseBody struct {
	InstanceIds []*DescribeInstanceIdsResponseBodyInstanceIds `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	RequestId   *string                                       `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeInstanceIdsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceIdsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeInstanceIdsResponseBody) SetInstanceIds(v []*DescribeInstanceIdsResponseBodyInstanceIds) *DescribeInstanceIdsResponseBody {
	s.InstanceIds = v
	return s
}

func (s *DescribeInstanceIdsResponseBody) SetRequestId(v string) *DescribeInstanceIdsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeInstanceIdsResponseBodyInstanceIds struct {
	Edition    *int32  `json:"Edition,omitempty" xml:"Edition,omitempty"`
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IpMode     *string `json:"IpMode,omitempty" xml:"IpMode,omitempty"`
	IpVersion  *string `json:"IpVersion,omitempty" xml:"IpVersion,omitempty"`
	Remark     *string `json:"Remark,omitempty" xml:"Remark,omitempty"`
}

func (s DescribeInstanceIdsResponseBodyInstanceIds) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceIdsResponseBodyInstanceIds) GoString() string {
	return s.String()
}

func (s *DescribeInstanceIdsResponseBodyInstanceIds) SetEdition(v int32) *DescribeInstanceIdsResponseBodyInstanceIds {
	s.Edition = &v
	return s
}

func (s *DescribeInstanceIdsResponseBodyInstanceIds) SetInstanceId(v string) *DescribeInstanceIdsResponseBodyInstanceIds {
	s.InstanceId = &v
	return s
}

func (s *DescribeInstanceIdsResponseBodyInstanceIds) SetIpMode(v string) *DescribeInstanceIdsResponseBodyInstanceIds {
	s.IpMode = &v
	return s
}

func (s *DescribeInstanceIdsResponseBodyInstanceIds) SetIpVersion(v string) *DescribeInstanceIdsResponseBodyInstanceIds {
	s.IpVersion = &v
	return s
}

func (s *DescribeInstanceIdsResponseBodyInstanceIds) SetRemark(v string) *DescribeInstanceIdsResponseBodyInstanceIds {
	s.Remark = &v
	return s
}

type DescribeInstanceIdsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeInstanceIdsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeInstanceIdsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceIdsResponse) GoString() string {
	return s.String()
}

func (s *DescribeInstanceIdsResponse) SetHeaders(v map[string]*string) *DescribeInstanceIdsResponse {
	s.Headers = v
	return s
}

func (s *DescribeInstanceIdsResponse) SetStatusCode(v int32) *DescribeInstanceIdsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeInstanceIdsResponse) SetBody(v *DescribeInstanceIdsResponseBody) *DescribeInstanceIdsResponse {
	s.Body = v
	return s
}

type DescribeInstanceSpecsRequest struct {
	// An array that consists of the IDs of instances to query.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
}

func (s DescribeInstanceSpecsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceSpecsRequest) GoString() string {
	return s.String()
}

func (s *DescribeInstanceSpecsRequest) SetInstanceIds(v []*string) *DescribeInstanceSpecsRequest {
	s.InstanceIds = v
	return s
}

type DescribeInstanceSpecsResponseBody struct {
	// An array that consists of the specifications of instances.
	InstanceSpecs []*DescribeInstanceSpecsResponseBodyInstanceSpecs `json:"InstanceSpecs,omitempty" xml:"InstanceSpecs,omitempty" type:"Repeated"`
	// The ID of the request, which is used to locate and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeInstanceSpecsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceSpecsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeInstanceSpecsResponseBody) SetInstanceSpecs(v []*DescribeInstanceSpecsResponseBodyInstanceSpecs) *DescribeInstanceSpecsResponseBody {
	s.InstanceSpecs = v
	return s
}

func (s *DescribeInstanceSpecsResponseBody) SetRequestId(v string) *DescribeInstanceSpecsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeInstanceSpecsResponseBodyInstanceSpecs struct {
	// The clean bandwidth of normal services. Unit: Mbit/s.
	BandwidthMbps *int32 `json:"BandwidthMbps,omitempty" xml:"BandwidthMbps,omitempty"`
	// The basic protection bandwidth. Unit: Gbit/s.
	BaseBandwidth *int32 `json:"BaseBandwidth,omitempty" xml:"BaseBandwidth,omitempty"`
	// The specification of concurrent connections of the instance.
	ConnLimit *int64 `json:"ConnLimit,omitempty" xml:"ConnLimit,omitempty"`
	// The specification of new connections of the instance.
	CpsLimit *int64 `json:"CpsLimit,omitempty" xml:"CpsLimit,omitempty"`
	// The number of available advanced mitigation sessions for this month. If **-1** is returned, advanced mitigation capabilities are unlimited.
	//
	// > This parameter is returned only when **RegionId** is set to **ap-southeast-1**. If RegionId is set to ap-southeast-1, the specifications of Anti-DDoS Premium instances are queried.
	DefenseCount *int32 `json:"DefenseCount,omitempty" xml:"DefenseCount,omitempty"`
	// The number of domain names that can be protected by the instance.
	DomainLimit *int32 `json:"DomainLimit,omitempty" xml:"DomainLimit,omitempty"`
	// The burstable protection bandwidth. Unit: Gbit/s.
	ElasticBandwidth *int32 `json:"ElasticBandwidth,omitempty" xml:"ElasticBandwidth,omitempty"`
	// The burstable clean bandwidth. Unit: Mbit/s.
	ElasticBw *int32 `json:"ElasticBw,omitempty" xml:"ElasticBw,omitempty"`
	// The metering method of the burstable clean bandwidth. Valid values:
	//
	// *   **day**: the metering method of daily 95th percentile
	// *   **month**: the metering method of monthly 95th percentile
	ElasticBwModel *string `json:"ElasticBwModel,omitempty" xml:"ElasticBwModel,omitempty"`
	ElasticQps     *int64  `json:"ElasticQps,omitempty" xml:"ElasticQps,omitempty"`
	ElasticQpsMode *string `json:"ElasticQpsMode,omitempty" xml:"ElasticQpsMode,omitempty"`
	// The function plan of the instance. Valid values:
	//
	// *   **default**: Standard
	// *   **enhance**: Enhanced
	// *   **cnhk**: Chinese Mainland Acceleration (CMA)
	// *   **cnhk_default**: Secure Chinese Mainland Acceleration (Sec-CMA) standard function plan
	// *   **cnhk_enhance**: Sec-CMA enhanced function plan
	FunctionVersion *string `json:"FunctionVersion,omitempty" xml:"FunctionVersion,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The number of ports that can be protected by the instance.
	PortLimit *int32 `json:"PortLimit,omitempty" xml:"PortLimit,omitempty"`
	// The clean queries per second (QPS) of normal services.
	QpsLimit *int32 `json:"QpsLimit,omitempty" xml:"QpsLimit,omitempty"`
	// 0153600mbps
	RealLimitBw *int64 `json:"RealLimitBw,omitempty" xml:"RealLimitBw,omitempty"`
	// The number of sites that can be protected by the instance.
	SiteLimit *int32 `json:"SiteLimit,omitempty" xml:"SiteLimit,omitempty"`
}

func (s DescribeInstanceSpecsResponseBodyInstanceSpecs) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceSpecsResponseBodyInstanceSpecs) GoString() string {
	return s.String()
}

func (s *DescribeInstanceSpecsResponseBodyInstanceSpecs) SetBandwidthMbps(v int32) *DescribeInstanceSpecsResponseBodyInstanceSpecs {
	s.BandwidthMbps = &v
	return s
}

func (s *DescribeInstanceSpecsResponseBodyInstanceSpecs) SetBaseBandwidth(v int32) *DescribeInstanceSpecsResponseBodyInstanceSpecs {
	s.BaseBandwidth = &v
	return s
}

func (s *DescribeInstanceSpecsResponseBodyInstanceSpecs) SetConnLimit(v int64) *DescribeInstanceSpecsResponseBodyInstanceSpecs {
	s.ConnLimit = &v
	return s
}

func (s *DescribeInstanceSpecsResponseBodyInstanceSpecs) SetCpsLimit(v int64) *DescribeInstanceSpecsResponseBodyInstanceSpecs {
	s.CpsLimit = &v
	return s
}

func (s *DescribeInstanceSpecsResponseBodyInstanceSpecs) SetDefenseCount(v int32) *DescribeInstanceSpecsResponseBodyInstanceSpecs {
	s.DefenseCount = &v
	return s
}

func (s *DescribeInstanceSpecsResponseBodyInstanceSpecs) SetDomainLimit(v int32) *DescribeInstanceSpecsResponseBodyInstanceSpecs {
	s.DomainLimit = &v
	return s
}

func (s *DescribeInstanceSpecsResponseBodyInstanceSpecs) SetElasticBandwidth(v int32) *DescribeInstanceSpecsResponseBodyInstanceSpecs {
	s.ElasticBandwidth = &v
	return s
}

func (s *DescribeInstanceSpecsResponseBodyInstanceSpecs) SetElasticBw(v int32) *DescribeInstanceSpecsResponseBodyInstanceSpecs {
	s.ElasticBw = &v
	return s
}

func (s *DescribeInstanceSpecsResponseBodyInstanceSpecs) SetElasticBwModel(v string) *DescribeInstanceSpecsResponseBodyInstanceSpecs {
	s.ElasticBwModel = &v
	return s
}

func (s *DescribeInstanceSpecsResponseBodyInstanceSpecs) SetElasticQps(v int64) *DescribeInstanceSpecsResponseBodyInstanceSpecs {
	s.ElasticQps = &v
	return s
}

func (s *DescribeInstanceSpecsResponseBodyInstanceSpecs) SetElasticQpsMode(v string) *DescribeInstanceSpecsResponseBodyInstanceSpecs {
	s.ElasticQpsMode = &v
	return s
}

func (s *DescribeInstanceSpecsResponseBodyInstanceSpecs) SetFunctionVersion(v string) *DescribeInstanceSpecsResponseBodyInstanceSpecs {
	s.FunctionVersion = &v
	return s
}

func (s *DescribeInstanceSpecsResponseBodyInstanceSpecs) SetInstanceId(v string) *DescribeInstanceSpecsResponseBodyInstanceSpecs {
	s.InstanceId = &v
	return s
}

func (s *DescribeInstanceSpecsResponseBodyInstanceSpecs) SetPortLimit(v int32) *DescribeInstanceSpecsResponseBodyInstanceSpecs {
	s.PortLimit = &v
	return s
}

func (s *DescribeInstanceSpecsResponseBodyInstanceSpecs) SetQpsLimit(v int32) *DescribeInstanceSpecsResponseBodyInstanceSpecs {
	s.QpsLimit = &v
	return s
}

func (s *DescribeInstanceSpecsResponseBodyInstanceSpecs) SetRealLimitBw(v int64) *DescribeInstanceSpecsResponseBodyInstanceSpecs {
	s.RealLimitBw = &v
	return s
}

func (s *DescribeInstanceSpecsResponseBodyInstanceSpecs) SetSiteLimit(v int32) *DescribeInstanceSpecsResponseBodyInstanceSpecs {
	s.SiteLimit = &v
	return s
}

type DescribeInstanceSpecsResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeInstanceSpecsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeInstanceSpecsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceSpecsResponse) GoString() string {
	return s.String()
}

func (s *DescribeInstanceSpecsResponse) SetHeaders(v map[string]*string) *DescribeInstanceSpecsResponse {
	s.Headers = v
	return s
}

func (s *DescribeInstanceSpecsResponse) SetStatusCode(v int32) *DescribeInstanceSpecsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeInstanceSpecsResponse) SetBody(v *DescribeInstanceSpecsResponseBody) *DescribeInstanceSpecsResponse {
	s.Body = v
	return s
}

type DescribeInstanceStatisticsRequest struct {
	// The ID of the instance that you want to query.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
}

func (s DescribeInstanceStatisticsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceStatisticsRequest) GoString() string {
	return s.String()
}

func (s *DescribeInstanceStatisticsRequest) SetInstanceIds(v []*string) *DescribeInstanceStatisticsRequest {
	s.InstanceIds = v
	return s
}

type DescribeInstanceStatisticsResponseBody struct {
	// The statistics on the instances.
	InstanceStatistics []*DescribeInstanceStatisticsResponseBodyInstanceStatistics `json:"InstanceStatistics,omitempty" xml:"InstanceStatistics,omitempty" type:"Repeated"`
	// The ID of the request, which is used to locate and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeInstanceStatisticsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceStatisticsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeInstanceStatisticsResponseBody) SetInstanceStatistics(v []*DescribeInstanceStatisticsResponseBodyInstanceStatistics) *DescribeInstanceStatisticsResponseBody {
	s.InstanceStatistics = v
	return s
}

func (s *DescribeInstanceStatisticsResponseBody) SetRequestId(v string) *DescribeInstanceStatisticsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeInstanceStatisticsResponseBodyInstanceStatistics struct {
	// The number of advanced mitigation sessions that are used in this month.
	//
	// > This parameter is returned only if Anti-DDoS Premium instances are queried.
	DefenseCountUsage *int32 `json:"DefenseCountUsage,omitempty" xml:"DefenseCountUsage,omitempty"`
	// The number of domain names that are protected by the instance.
	DomainUsage *int32 `json:"DomainUsage,omitempty" xml:"DomainUsage,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The number of ports that are protected by the instance.
	PortUsage *int32 `json:"PortUsage,omitempty" xml:"PortUsage,omitempty"`
	// The number of websites that are protected by the instance.
	SiteUsage *int32 `json:"SiteUsage,omitempty" xml:"SiteUsage,omitempty"`
}

func (s DescribeInstanceStatisticsResponseBodyInstanceStatistics) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceStatisticsResponseBodyInstanceStatistics) GoString() string {
	return s.String()
}

func (s *DescribeInstanceStatisticsResponseBodyInstanceStatistics) SetDefenseCountUsage(v int32) *DescribeInstanceStatisticsResponseBodyInstanceStatistics {
	s.DefenseCountUsage = &v
	return s
}

func (s *DescribeInstanceStatisticsResponseBodyInstanceStatistics) SetDomainUsage(v int32) *DescribeInstanceStatisticsResponseBodyInstanceStatistics {
	s.DomainUsage = &v
	return s
}

func (s *DescribeInstanceStatisticsResponseBodyInstanceStatistics) SetInstanceId(v string) *DescribeInstanceStatisticsResponseBodyInstanceStatistics {
	s.InstanceId = &v
	return s
}

func (s *DescribeInstanceStatisticsResponseBodyInstanceStatistics) SetPortUsage(v int32) *DescribeInstanceStatisticsResponseBodyInstanceStatistics {
	s.PortUsage = &v
	return s
}

func (s *DescribeInstanceStatisticsResponseBodyInstanceStatistics) SetSiteUsage(v int32) *DescribeInstanceStatisticsResponseBodyInstanceStatistics {
	s.SiteUsage = &v
	return s
}

type DescribeInstanceStatisticsResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeInstanceStatisticsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeInstanceStatisticsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceStatisticsResponse) GoString() string {
	return s.String()
}

func (s *DescribeInstanceStatisticsResponse) SetHeaders(v map[string]*string) *DescribeInstanceStatisticsResponse {
	s.Headers = v
	return s
}

func (s *DescribeInstanceStatisticsResponse) SetStatusCode(v int32) *DescribeInstanceStatisticsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeInstanceStatisticsResponse) SetBody(v *DescribeInstanceStatisticsResponseBody) *DescribeInstanceStatisticsResponse {
	s.Body = v
	return s
}

type DescribeInstanceStatusRequest struct {
	// The ID of the instance to query.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all Anti-DDoS Pro or Anti-DDoS Premium instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The type of the instance to query. Valid values:
	//
	// *   **1**: an Anti-DDoS Pro instance
	// *   **2**: an Anti-DDoS Premium instance
	ProductType *int32 `json:"ProductType,omitempty" xml:"ProductType,omitempty"`
}

func (s DescribeInstanceStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceStatusRequest) GoString() string {
	return s.String()
}

func (s *DescribeInstanceStatusRequest) SetInstanceId(v string) *DescribeInstanceStatusRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeInstanceStatusRequest) SetProductType(v int32) *DescribeInstanceStatusRequest {
	s.ProductType = &v
	return s
}

type DescribeInstanceStatusResponseBody struct {
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The status of the instance. Valid values:
	//
	// *   **1**: normal
	// *   **2**: expired
	// *   **3**: overdue
	// *   **4**: released
	InstanceStatus *int32 `json:"InstanceStatus,omitempty" xml:"InstanceStatus,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeInstanceStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceStatusResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeInstanceStatusResponseBody) SetInstanceId(v string) *DescribeInstanceStatusResponseBody {
	s.InstanceId = &v
	return s
}

func (s *DescribeInstanceStatusResponseBody) SetInstanceStatus(v int32) *DescribeInstanceStatusResponseBody {
	s.InstanceStatus = &v
	return s
}

func (s *DescribeInstanceStatusResponseBody) SetRequestId(v string) *DescribeInstanceStatusResponseBody {
	s.RequestId = &v
	return s
}

type DescribeInstanceStatusResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeInstanceStatusResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeInstanceStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstanceStatusResponse) GoString() string {
	return s.String()
}

func (s *DescribeInstanceStatusResponse) SetHeaders(v map[string]*string) *DescribeInstanceStatusResponse {
	s.Headers = v
	return s
}

func (s *DescribeInstanceStatusResponse) SetStatusCode(v int32) *DescribeInstanceStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeInstanceStatusResponse) SetBody(v *DescribeInstanceStatusResponseBody) *DescribeInstanceStatusResponse {
	s.Body = v
	return s
}

type DescribeInstancesRequest struct {
	// The mitigation plan of the instance to query. Valid values:
	//
	// *   **0**: Anti-DDoS Premium instance of the Insurance mitigation plan
	// *   **1**: Anti-DDoS Premium instance of the Unlimited mitigation plan
	// *   **2**: Anti-DDoS Premium instance of the Mainland China Acceleration (MCA) mitigation plan
	// *   **9**: Anti-DDoS Pro instance of the Profession mitigation plan
	Edition *int32 `json:"Edition,omitempty" xml:"Edition,omitempty"`
	// The traffic forwarding status of the instance to query. Valid values:
	//
	// *   **0**: The instance no longer forwards service traffic.
	// *   **1**: The instance forwards service traffic as expected.
	Enabled *int32 `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	// The end of the time range to query. Instances whose expiration time is earlier than the point in time are queried. This value is a UNIX timestamp. Unit: milliseconds.
	ExpireEndTime *int64 `json:"ExpireEndTime,omitempty" xml:"ExpireEndTime,omitempty"`
	// The beginning of the time range to query. Instances whose expiration time is later than the point in time are queried. This value is a UNIX timestamp. Unit: milliseconds.
	ExpireStartTime *int64    `json:"ExpireStartTime,omitempty" xml:"ExpireStartTime,omitempty"`
	InstanceIds     []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	// The IP address of the instance to query.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The number of the page to return.
	PageNumber *string `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *string `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The remarks of the instance to query. Fuzzy match is supported.
	Remark *string `json:"Remark,omitempty" xml:"Remark,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management.
	//
	// If you do not specify this parameter, the instance belongs to the default resource group.
	ResourceGroupId *string                        `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	Status          []*int32                       `json:"Status,omitempty" xml:"Status,omitempty" type:"Repeated"`
	Tag             []*DescribeInstancesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstancesRequest) GoString() string {
	return s.String()
}

func (s *DescribeInstancesRequest) SetEdition(v int32) *DescribeInstancesRequest {
	s.Edition = &v
	return s
}

func (s *DescribeInstancesRequest) SetEnabled(v int32) *DescribeInstancesRequest {
	s.Enabled = &v
	return s
}

func (s *DescribeInstancesRequest) SetExpireEndTime(v int64) *DescribeInstancesRequest {
	s.ExpireEndTime = &v
	return s
}

func (s *DescribeInstancesRequest) SetExpireStartTime(v int64) *DescribeInstancesRequest {
	s.ExpireStartTime = &v
	return s
}

func (s *DescribeInstancesRequest) SetInstanceIds(v []*string) *DescribeInstancesRequest {
	s.InstanceIds = v
	return s
}

func (s *DescribeInstancesRequest) SetIp(v string) *DescribeInstancesRequest {
	s.Ip = &v
	return s
}

func (s *DescribeInstancesRequest) SetPageNumber(v string) *DescribeInstancesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeInstancesRequest) SetPageSize(v string) *DescribeInstancesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeInstancesRequest) SetRemark(v string) *DescribeInstancesRequest {
	s.Remark = &v
	return s
}

func (s *DescribeInstancesRequest) SetResourceGroupId(v string) *DescribeInstancesRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeInstancesRequest) SetStatus(v []*int32) *DescribeInstancesRequest {
	s.Status = v
	return s
}

func (s *DescribeInstancesRequest) SetTag(v []*DescribeInstancesRequestTag) *DescribeInstancesRequest {
	s.Tag = v
	return s
}

type DescribeInstancesRequestTag struct {
	// The key of tag N that is added to the instance to query. The maximum value of N is 200. You can specify up to 200 tags. When you specify tags, take note of the following rules:
	//
	// *   Each tag consists of a key (**Key**) and a value (**Value**), which are separated by a comma (,).
	// *   Separate multiple tags with commas (,).
	//
	// >  The tag key (**Key**) and tag value (**Value**) must be specified in pairs.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of tag N that is added to the instance to query. The maximum value of N is 200. You can specify up to 200 tags. When you specify tags, take note of the following rules:
	//
	// *   Each tag consists of a key (**Key**) and a value (**Value**), which are separated by a comma (,).
	// *   Separate multiple tags with commas (,).
	//
	// >  The tag key (**Key**) and tag value (**Value**) must be specified in pairs.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeInstancesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstancesRequestTag) GoString() string {
	return s.String()
}

func (s *DescribeInstancesRequestTag) SetKey(v string) *DescribeInstancesRequestTag {
	s.Key = &v
	return s
}

func (s *DescribeInstancesRequestTag) SetValue(v string) *DescribeInstancesRequestTag {
	s.Value = &v
	return s
}

type DescribeInstancesResponseBody struct {
	// An array that consists of the details of the instances.
	Instances []*DescribeInstancesResponseBodyInstances `json:"Instances,omitempty" xml:"Instances,omitempty" type:"Repeated"`
	// The ID of the request, which is used to locate and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of the instances.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeInstancesResponseBody) SetInstances(v []*DescribeInstancesResponseBodyInstances) *DescribeInstancesResponseBody {
	s.Instances = v
	return s
}

func (s *DescribeInstancesResponseBody) SetRequestId(v string) *DescribeInstancesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeInstancesResponseBody) SetTotalCount(v int64) *DescribeInstancesResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeInstancesResponseBodyInstances struct {
	// The time when the instance is created. This value is a UNIX timestamp. Unit: milliseconds.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The overdue status of the instance. The value is fixed as **0**, which indicates that your Alibaba Cloud account does not have overdue payments. The instance supports only the subscription billing method.
	DebtStatus *int32 `json:"DebtStatus,omitempty" xml:"DebtStatus,omitempty"`
	// The mitigation plan of the instance. Valid values:
	//
	// *   **0**: Anti-DDoS Premium instance of the Insurance mitigation plan
	// *   **1**: Anti-DDoS Premium instance of the Unlimited mitigation plan
	// *   **2**: Anti-DDoS Premium instance of the MCA mitigation plan
	// *   **9**: Anti-DDoS Pro instance of the Profession mitigation plan
	Edition *int32 `json:"Edition,omitempty" xml:"Edition,omitempty"`
	// The forwarding status of the instance. Valid values:
	//
	// *   **0**: The instance no longer forwards service traffic.
	// *   **1**: The instance forwards service traffic as expected.
	Enabled *int32 `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	// The time when the instance expires. This value is a UNIX timestamp. Unit: milliseconds.
	ExpireTime *int64 `json:"ExpireTime,omitempty" xml:"ExpireTime,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The IP address of the instance.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The IP address-based forwarding mode of the instance. Valid values:
	//
	// *   **fnat**: Requests from IPv4 addresses are forwarded to origin servers that use IPv4 addresses and requests from IPv6 addresses are forwarded to origin servers that use IPv6 addresses.
	// *   **v6tov4**: All requests are forwarded to origin servers that use IPv4 addresses.
	IpMode *string `json:"IpMode,omitempty" xml:"IpMode,omitempty"`
	// The IP version of the instance. Valid values:
	//
	// *   **Ipv4**: IPv4
	// *   **Ipv6**: IPv6
	IpVersion *string `json:"IpVersion,omitempty" xml:"IpVersion,omitempty"`
	// Indicates whether the 95th percentile metering method has been enabled for the instance. Valid values:
	//
	// *   0: The 95th percentile metering method has not been enabled for the instance.
	// *   1: The 95th percentile metering method has been enabled for the instance.
	IsFirstOpenBw *int64 `json:"IsFirstOpenBw,omitempty" xml:"IsFirstOpenBw,omitempty"`
	// Indicates whether the metering method of the 95th percentile burstable QPS is enabled for the instance. Valid values:
	//
	// - 0: no
	// - 1: yes
	IsFirstOpenQps *int64 `json:"IsFirstOpenQps,omitempty" xml:"IsFirstOpenQps,omitempty"`
	// The remarks of the instance.
	Remark *string `json:"Remark,omitempty" xml:"Remark,omitempty"`
	// The status of the instance. Valid values:
	//
	// *   **1**: normal
	// *   **2**: expired
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeInstancesResponseBodyInstances) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstancesResponseBodyInstances) GoString() string {
	return s.String()
}

func (s *DescribeInstancesResponseBodyInstances) SetCreateTime(v int64) *DescribeInstancesResponseBodyInstances {
	s.CreateTime = &v
	return s
}

func (s *DescribeInstancesResponseBodyInstances) SetDebtStatus(v int32) *DescribeInstancesResponseBodyInstances {
	s.DebtStatus = &v
	return s
}

func (s *DescribeInstancesResponseBodyInstances) SetEdition(v int32) *DescribeInstancesResponseBodyInstances {
	s.Edition = &v
	return s
}

func (s *DescribeInstancesResponseBodyInstances) SetEnabled(v int32) *DescribeInstancesResponseBodyInstances {
	s.Enabled = &v
	return s
}

func (s *DescribeInstancesResponseBodyInstances) SetExpireTime(v int64) *DescribeInstancesResponseBodyInstances {
	s.ExpireTime = &v
	return s
}

func (s *DescribeInstancesResponseBodyInstances) SetInstanceId(v string) *DescribeInstancesResponseBodyInstances {
	s.InstanceId = &v
	return s
}

func (s *DescribeInstancesResponseBodyInstances) SetIp(v string) *DescribeInstancesResponseBodyInstances {
	s.Ip = &v
	return s
}

func (s *DescribeInstancesResponseBodyInstances) SetIpMode(v string) *DescribeInstancesResponseBodyInstances {
	s.IpMode = &v
	return s
}

func (s *DescribeInstancesResponseBodyInstances) SetIpVersion(v string) *DescribeInstancesResponseBodyInstances {
	s.IpVersion = &v
	return s
}

func (s *DescribeInstancesResponseBodyInstances) SetIsFirstOpenBw(v int64) *DescribeInstancesResponseBodyInstances {
	s.IsFirstOpenBw = &v
	return s
}

func (s *DescribeInstancesResponseBodyInstances) SetIsFirstOpenQps(v int64) *DescribeInstancesResponseBodyInstances {
	s.IsFirstOpenQps = &v
	return s
}

func (s *DescribeInstancesResponseBodyInstances) SetRemark(v string) *DescribeInstancesResponseBodyInstances {
	s.Remark = &v
	return s
}

func (s *DescribeInstancesResponseBodyInstances) SetStatus(v int32) *DescribeInstancesResponseBodyInstances {
	s.Status = &v
	return s
}

type DescribeInstancesResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeInstancesResponse) GoString() string {
	return s.String()
}

func (s *DescribeInstancesResponse) SetHeaders(v map[string]*string) *DescribeInstancesResponse {
	s.Headers = v
	return s
}

func (s *DescribeInstancesResponse) SetStatusCode(v int32) *DescribeInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeInstancesResponse) SetBody(v *DescribeInstancesResponseBody) *DescribeInstancesResponse {
	s.Body = v
	return s
}

type DescribeL7RsPolicyRequest struct {
	// The domain name of the website to query.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query the domain names for which forwarding rules are configured.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// An array that consists of N addresses of origin servers to query. The maximum value of N is 200. You can specify up to 200 addresses.
	RealServers []*string `json:"RealServers,omitempty" xml:"RealServers,omitempty" type:"Repeated"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	//
	// For more information about resource groups, see [Create a resource group](~~94485~~).
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeL7RsPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeL7RsPolicyRequest) GoString() string {
	return s.String()
}

func (s *DescribeL7RsPolicyRequest) SetDomain(v string) *DescribeL7RsPolicyRequest {
	s.Domain = &v
	return s
}

func (s *DescribeL7RsPolicyRequest) SetRealServers(v []*string) *DescribeL7RsPolicyRequest {
	s.RealServers = v
	return s
}

func (s *DescribeL7RsPolicyRequest) SetResourceGroupId(v string) *DescribeL7RsPolicyRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeL7RsPolicyResponseBody struct {
	// The details of the parameters for back-to-origin.
	Attributes []*DescribeL7RsPolicyResponseBodyAttributes `json:"Attributes,omitempty" xml:"Attributes,omitempty" type:"Repeated"`
	// The scheduling algorithm for back-to-origin traffic. Valid values:
	//
	// *   **ip_hash**: the IP hash algorithm. This algorithm is used to redirect the requests from the same IP address to the same origin server.
	// *   **rr**: the round-robin algorithm. This algorithm is used to redirect requests to origin servers in turn.
	// *   **least_time**: the least response time algorithm. This algorithm is used to minimize the latency when requests are forwarded from Anti-DDoS Pro or Anti-DDoS Premium instances to origin servers based on the intelligent DNS resolution feature.
	ProxyMode *string `json:"ProxyMode,omitempty" xml:"ProxyMode,omitempty"`
	// The ID of the request, which is used to locate and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeL7RsPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeL7RsPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeL7RsPolicyResponseBody) SetAttributes(v []*DescribeL7RsPolicyResponseBodyAttributes) *DescribeL7RsPolicyResponseBody {
	s.Attributes = v
	return s
}

func (s *DescribeL7RsPolicyResponseBody) SetProxyMode(v string) *DescribeL7RsPolicyResponseBody {
	s.ProxyMode = &v
	return s
}

func (s *DescribeL7RsPolicyResponseBody) SetRequestId(v string) *DescribeL7RsPolicyResponseBody {
	s.RequestId = &v
	return s
}

type DescribeL7RsPolicyResponseBodyAttributes struct {
	// The parameter for back-to-origin.
	Attribute *DescribeL7RsPolicyResponseBodyAttributesAttribute `json:"Attribute,omitempty" xml:"Attribute,omitempty" type:"Struct"`
	// The address of the origin server.
	RealServer *string `json:"RealServer,omitempty" xml:"RealServer,omitempty"`
	// The address type of the origin server. Valid values:
	//
	// *   **0**: IP address
	// *   **1**: domain name
	RsType *int32 `json:"RsType,omitempty" xml:"RsType,omitempty"`
}

func (s DescribeL7RsPolicyResponseBodyAttributes) String() string {
	return tea.Prettify(s)
}

func (s DescribeL7RsPolicyResponseBodyAttributes) GoString() string {
	return s.String()
}

func (s *DescribeL7RsPolicyResponseBodyAttributes) SetAttribute(v *DescribeL7RsPolicyResponseBodyAttributesAttribute) *DescribeL7RsPolicyResponseBodyAttributes {
	s.Attribute = v
	return s
}

func (s *DescribeL7RsPolicyResponseBodyAttributes) SetRealServer(v string) *DescribeL7RsPolicyResponseBodyAttributes {
	s.RealServer = &v
	return s
}

func (s *DescribeL7RsPolicyResponseBodyAttributes) SetRsType(v int32) *DescribeL7RsPolicyResponseBodyAttributes {
	s.RsType = &v
	return s
}

type DescribeL7RsPolicyResponseBodyAttributesAttribute struct {
	// The weight of the origin server. This parameter takes effect only when **ProxyMode** is set to **rr**.
	//
	// Valid values: **1** to **100**. Default value: **100**. A server with a higher weight receives more requests.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeL7RsPolicyResponseBodyAttributesAttribute) String() string {
	return tea.Prettify(s)
}

func (s DescribeL7RsPolicyResponseBodyAttributesAttribute) GoString() string {
	return s.String()
}

func (s *DescribeL7RsPolicyResponseBodyAttributesAttribute) SetWeight(v int32) *DescribeL7RsPolicyResponseBodyAttributesAttribute {
	s.Weight = &v
	return s
}

type DescribeL7RsPolicyResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeL7RsPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeL7RsPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeL7RsPolicyResponse) GoString() string {
	return s.String()
}

func (s *DescribeL7RsPolicyResponse) SetHeaders(v map[string]*string) *DescribeL7RsPolicyResponse {
	s.Headers = v
	return s
}

func (s *DescribeL7RsPolicyResponse) SetStatusCode(v int32) *DescribeL7RsPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeL7RsPolicyResponse) SetBody(v *DescribeL7RsPolicyResponseBody) *DescribeL7RsPolicyResponse {
	s.Body = v
	return s
}

type DescribeLayer4RulePolicyRequest struct {
	// The port forwarding rule that you want to query.
	//
	// This parameter is a string that consists of JSON arrays. Each element in a JSON array indicates a port forwarding rule. You can query only one port forwarding rule at a time.
	//
	// > You can call the [DescribeNetworkRules](~~157484~~) to query existing port forwarding rules.
	//
	// Each port forwarding rule contains the following fields:
	//
	// *   **InstanceId**: the ID of the instance. This field is required and must be of the string type.
	// *   **Protocol**: the forwarding protocol. This field is required and must be of the string type. Valid values: **tcp** and **udp**.
	// *   **FrontendPort**: the forwarding port. This field is required and must be of the integer type.
	Listeners *string `json:"Listeners,omitempty" xml:"Listeners,omitempty"`
}

func (s DescribeLayer4RulePolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeLayer4RulePolicyRequest) GoString() string {
	return s.String()
}

func (s *DescribeLayer4RulePolicyRequest) SetListeners(v string) *DescribeLayer4RulePolicyRequest {
	s.Listeners = &v
	return s
}

type DescribeLayer4RulePolicyResponseBody struct {
	// The port of the origin server.
	BackendPort *int32 `json:"BackendPort,omitempty" xml:"BackendPort,omitempty"`
	// The mode that is used to forward service traffic. Valid values:
	//
	// *   0: the default mode. In this mode, Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the origin IP address that you specified when you created the port forwarding rule. You can call the [CreateNetworkRules](~~157482~~) operation to create a port forwarding rule.
	// *   1: the origin redundancy mode. In this mode, Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the primary or secondary origin servers. You can call the [ConfigLayer4RulePolicy](~~312684~~) operation to configure IP addresses.
	BakMode *string `json:"BakMode,omitempty" xml:"BakMode,omitempty"`
	// The origin server that is used to receive service traffic. Valid values:
	//
	// *   **1**: the primary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the primary origin server.
	// *   **2**: the secondary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the secondary origin server.
	CurrentIndex *int32 `json:"CurrentIndex,omitempty" xml:"CurrentIndex,omitempty"`
	// The type of the protocol.
	ForwardProtocol *string `json:"ForwardProtocol,omitempty" xml:"ForwardProtocol,omitempty"`
	// The forwarding port.
	FrontendPort *int32 `json:"FrontendPort,omitempty" xml:"FrontendPort,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// An array that consists of the information about the primary origin server, including the IP addresses, forwarding protocol, and forwarding port.
	PriRealServers []*DescribeLayer4RulePolicyResponseBodyPriRealServers `json:"PriRealServers,omitempty" xml:"PriRealServers,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// An array that consists of the information about the secondary origin server, including the IP addresses, forwarding protocol, and forwarding port.
	SecRealServers []*DescribeLayer4RulePolicyResponseBodySecRealServers `json:"SecRealServers,omitempty" xml:"SecRealServers,omitempty" type:"Repeated"`
}

func (s DescribeLayer4RulePolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeLayer4RulePolicyResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeLayer4RulePolicyResponseBody) SetBackendPort(v int32) *DescribeLayer4RulePolicyResponseBody {
	s.BackendPort = &v
	return s
}

func (s *DescribeLayer4RulePolicyResponseBody) SetBakMode(v string) *DescribeLayer4RulePolicyResponseBody {
	s.BakMode = &v
	return s
}

func (s *DescribeLayer4RulePolicyResponseBody) SetCurrentIndex(v int32) *DescribeLayer4RulePolicyResponseBody {
	s.CurrentIndex = &v
	return s
}

func (s *DescribeLayer4RulePolicyResponseBody) SetForwardProtocol(v string) *DescribeLayer4RulePolicyResponseBody {
	s.ForwardProtocol = &v
	return s
}

func (s *DescribeLayer4RulePolicyResponseBody) SetFrontendPort(v int32) *DescribeLayer4RulePolicyResponseBody {
	s.FrontendPort = &v
	return s
}

func (s *DescribeLayer4RulePolicyResponseBody) SetInstanceId(v string) *DescribeLayer4RulePolicyResponseBody {
	s.InstanceId = &v
	return s
}

func (s *DescribeLayer4RulePolicyResponseBody) SetPriRealServers(v []*DescribeLayer4RulePolicyResponseBodyPriRealServers) *DescribeLayer4RulePolicyResponseBody {
	s.PriRealServers = v
	return s
}

func (s *DescribeLayer4RulePolicyResponseBody) SetRequestId(v string) *DescribeLayer4RulePolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeLayer4RulePolicyResponseBody) SetSecRealServers(v []*DescribeLayer4RulePolicyResponseBodySecRealServers) *DescribeLayer4RulePolicyResponseBody {
	s.SecRealServers = v
	return s
}

type DescribeLayer4RulePolicyResponseBodyPriRealServers struct {
	// The origin server that is used to receive service traffic. Valid values:
	//
	// *   **1**: the primary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the primary origin server.
	// *   **2**: the secondary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the secondary origin server.
	CurrentIndex *int32 `json:"CurrentIndex,omitempty" xml:"CurrentIndex,omitempty"`
	// The IP address of the instance.
	Eip *string `json:"Eip,omitempty" xml:"Eip,omitempty"`
	// The forwarding port.
	FrontendPort *int32 `json:"FrontendPort,omitempty" xml:"FrontendPort,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The type of the protocol.
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The IP address of the primary origin server.
	RealServer *string `json:"RealServer,omitempty" xml:"RealServer,omitempty"`
}

func (s DescribeLayer4RulePolicyResponseBodyPriRealServers) String() string {
	return tea.Prettify(s)
}

func (s DescribeLayer4RulePolicyResponseBodyPriRealServers) GoString() string {
	return s.String()
}

func (s *DescribeLayer4RulePolicyResponseBodyPriRealServers) SetCurrentIndex(v int32) *DescribeLayer4RulePolicyResponseBodyPriRealServers {
	s.CurrentIndex = &v
	return s
}

func (s *DescribeLayer4RulePolicyResponseBodyPriRealServers) SetEip(v string) *DescribeLayer4RulePolicyResponseBodyPriRealServers {
	s.Eip = &v
	return s
}

func (s *DescribeLayer4RulePolicyResponseBodyPriRealServers) SetFrontendPort(v int32) *DescribeLayer4RulePolicyResponseBodyPriRealServers {
	s.FrontendPort = &v
	return s
}

func (s *DescribeLayer4RulePolicyResponseBodyPriRealServers) SetInstanceId(v string) *DescribeLayer4RulePolicyResponseBodyPriRealServers {
	s.InstanceId = &v
	return s
}

func (s *DescribeLayer4RulePolicyResponseBodyPriRealServers) SetProtocol(v string) *DescribeLayer4RulePolicyResponseBodyPriRealServers {
	s.Protocol = &v
	return s
}

func (s *DescribeLayer4RulePolicyResponseBodyPriRealServers) SetRealServer(v string) *DescribeLayer4RulePolicyResponseBodyPriRealServers {
	s.RealServer = &v
	return s
}

type DescribeLayer4RulePolicyResponseBodySecRealServers struct {
	// The origin server that is used to receive service traffic. Valid values:
	//
	// *   **1**: the primary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the primary origin server.
	// *   **2**: the secondary origin server, which indicates that Anti-DDoS Pro or Anti-DDoS Premium forwards service traffic to the IP addresses of the secondary origin server.
	CurrentIndex *int32 `json:"CurrentIndex,omitempty" xml:"CurrentIndex,omitempty"`
	// The IP address of the instance.
	Eip *string `json:"Eip,omitempty" xml:"Eip,omitempty"`
	// The forwarding port.
	FrontendPort *int32 `json:"FrontendPort,omitempty" xml:"FrontendPort,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The type of the protocol.
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The IP address of the secondary origin server.
	RealServer *string `json:"RealServer,omitempty" xml:"RealServer,omitempty"`
}

func (s DescribeLayer4RulePolicyResponseBodySecRealServers) String() string {
	return tea.Prettify(s)
}

func (s DescribeLayer4RulePolicyResponseBodySecRealServers) GoString() string {
	return s.String()
}

func (s *DescribeLayer4RulePolicyResponseBodySecRealServers) SetCurrentIndex(v int32) *DescribeLayer4RulePolicyResponseBodySecRealServers {
	s.CurrentIndex = &v
	return s
}

func (s *DescribeLayer4RulePolicyResponseBodySecRealServers) SetEip(v string) *DescribeLayer4RulePolicyResponseBodySecRealServers {
	s.Eip = &v
	return s
}

func (s *DescribeLayer4RulePolicyResponseBodySecRealServers) SetFrontendPort(v int32) *DescribeLayer4RulePolicyResponseBodySecRealServers {
	s.FrontendPort = &v
	return s
}

func (s *DescribeLayer4RulePolicyResponseBodySecRealServers) SetInstanceId(v string) *DescribeLayer4RulePolicyResponseBodySecRealServers {
	s.InstanceId = &v
	return s
}

func (s *DescribeLayer4RulePolicyResponseBodySecRealServers) SetProtocol(v string) *DescribeLayer4RulePolicyResponseBodySecRealServers {
	s.Protocol = &v
	return s
}

func (s *DescribeLayer4RulePolicyResponseBodySecRealServers) SetRealServer(v string) *DescribeLayer4RulePolicyResponseBodySecRealServers {
	s.RealServer = &v
	return s
}

type DescribeLayer4RulePolicyResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeLayer4RulePolicyResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeLayer4RulePolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeLayer4RulePolicyResponse) GoString() string {
	return s.String()
}

func (s *DescribeLayer4RulePolicyResponse) SetHeaders(v map[string]*string) *DescribeLayer4RulePolicyResponse {
	s.Headers = v
	return s
}

func (s *DescribeLayer4RulePolicyResponse) SetStatusCode(v int32) *DescribeLayer4RulePolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeLayer4RulePolicyResponse) SetBody(v *DescribeLayer4RulePolicyResponseBody) *DescribeLayer4RulePolicyResponse {
	s.Body = v
	return s
}

type DescribeLogStoreExistStatusRequest struct {
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeLogStoreExistStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeLogStoreExistStatusRequest) GoString() string {
	return s.String()
}

func (s *DescribeLogStoreExistStatusRequest) SetResourceGroupId(v string) *DescribeLogStoreExistStatusRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeLogStoreExistStatusResponseBody struct {
	// Indicates whether a Logstore is created for Anti-DDoS Pro or Anti-DDoS Premium. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	ExistStatus *bool `json:"ExistStatus,omitempty" xml:"ExistStatus,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeLogStoreExistStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeLogStoreExistStatusResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeLogStoreExistStatusResponseBody) SetExistStatus(v bool) *DescribeLogStoreExistStatusResponseBody {
	s.ExistStatus = &v
	return s
}

func (s *DescribeLogStoreExistStatusResponseBody) SetRequestId(v string) *DescribeLogStoreExistStatusResponseBody {
	s.RequestId = &v
	return s
}

type DescribeLogStoreExistStatusResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeLogStoreExistStatusResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeLogStoreExistStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeLogStoreExistStatusResponse) GoString() string {
	return s.String()
}

func (s *DescribeLogStoreExistStatusResponse) SetHeaders(v map[string]*string) *DescribeLogStoreExistStatusResponse {
	s.Headers = v
	return s
}

func (s *DescribeLogStoreExistStatusResponse) SetStatusCode(v int32) *DescribeLogStoreExistStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeLogStoreExistStatusResponse) SetBody(v *DescribeLogStoreExistStatusResponseBody) *DescribeLogStoreExistStatusResponse {
	s.Body = v
	return s
}

type DescribeNetworkRegionBlockRequest struct {
	// The ID of the instance.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s DescribeNetworkRegionBlockRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkRegionBlockRequest) GoString() string {
	return s.String()
}

func (s *DescribeNetworkRegionBlockRequest) SetInstanceId(v string) *DescribeNetworkRegionBlockRequest {
	s.InstanceId = &v
	return s
}

type DescribeNetworkRegionBlockResponseBody struct {
	// The configuration of blocked locations.
	Config *DescribeNetworkRegionBlockResponseBodyConfig `json:"Config,omitempty" xml:"Config,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeNetworkRegionBlockResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkRegionBlockResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeNetworkRegionBlockResponseBody) SetConfig(v *DescribeNetworkRegionBlockResponseBodyConfig) *DescribeNetworkRegionBlockResponseBody {
	s.Config = v
	return s
}

func (s *DescribeNetworkRegionBlockResponseBody) SetRequestId(v string) *DescribeNetworkRegionBlockResponseBody {
	s.RequestId = &v
	return s
}

type DescribeNetworkRegionBlockResponseBodyConfig struct {
	// An array consisting of the codes of the countries or areas from which the requests are blocked.
	Countries []*string `json:"Countries,omitempty" xml:"Countries,omitempty" type:"Repeated"`
	// An array consisting of the codes of the administrative regions in China from which the requests are blocked.
	Provinces []*string `json:"Provinces,omitempty" xml:"Provinces,omitempty" type:"Repeated"`
	// The status of the Location Blacklist policy. Valid values:
	//
	// *   **on**: enabled
	// *   **off**: disabled
	RegionBlockSwitch *string `json:"RegionBlockSwitch,omitempty" xml:"RegionBlockSwitch,omitempty"`
}

func (s DescribeNetworkRegionBlockResponseBodyConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkRegionBlockResponseBodyConfig) GoString() string {
	return s.String()
}

func (s *DescribeNetworkRegionBlockResponseBodyConfig) SetCountries(v []*string) *DescribeNetworkRegionBlockResponseBodyConfig {
	s.Countries = v
	return s
}

func (s *DescribeNetworkRegionBlockResponseBodyConfig) SetProvinces(v []*string) *DescribeNetworkRegionBlockResponseBodyConfig {
	s.Provinces = v
	return s
}

func (s *DescribeNetworkRegionBlockResponseBodyConfig) SetRegionBlockSwitch(v string) *DescribeNetworkRegionBlockResponseBodyConfig {
	s.RegionBlockSwitch = &v
	return s
}

type DescribeNetworkRegionBlockResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeNetworkRegionBlockResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeNetworkRegionBlockResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkRegionBlockResponse) GoString() string {
	return s.String()
}

func (s *DescribeNetworkRegionBlockResponse) SetHeaders(v map[string]*string) *DescribeNetworkRegionBlockResponse {
	s.Headers = v
	return s
}

func (s *DescribeNetworkRegionBlockResponse) SetStatusCode(v int32) *DescribeNetworkRegionBlockResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeNetworkRegionBlockResponse) SetBody(v *DescribeNetworkRegionBlockResponseBody) *DescribeNetworkRegionBlockResponse {
	s.Body = v
	return s
}

type DescribeNetworkRuleAttributesRequest struct {
	// The details of the port forwarding rule. This parameter is a JSON string. The string contains the following fields:
	//
	// *   **InstanceId**: the ID of the instance. This field is required and must be of the STRING type.
	// *   **Protocol**: the forwarding protocol. This field is required and must be of the STRING type. Valid values: **tcp** and **udp**.
	// *   **FrontendPort**: the forwarding port. This field is required and must be of the INTEGER type.
	NetworkRules *string `json:"NetworkRules,omitempty" xml:"NetworkRules,omitempty"`
}

func (s DescribeNetworkRuleAttributesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkRuleAttributesRequest) GoString() string {
	return s.String()
}

func (s *DescribeNetworkRuleAttributesRequest) SetNetworkRules(v string) *DescribeNetworkRuleAttributesRequest {
	s.NetworkRules = &v
	return s
}

type DescribeNetworkRuleAttributesResponseBody struct {
	// An array that consists of the mitigation settings of the port forwarding rule for a non-website service. The mitigation settings include session persistence and DDoS mitigation policies.
	NetworkRuleAttributes []*DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributes `json:"NetworkRuleAttributes,omitempty" xml:"NetworkRuleAttributes,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeNetworkRuleAttributesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkRuleAttributesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeNetworkRuleAttributesResponseBody) SetNetworkRuleAttributes(v []*DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributes) *DescribeNetworkRuleAttributesResponseBody {
	s.NetworkRuleAttributes = v
	return s
}

func (s *DescribeNetworkRuleAttributesResponseBody) SetRequestId(v string) *DescribeNetworkRuleAttributesResponseBody {
	s.RequestId = &v
	return s
}

type DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributes struct {
	// The mitigation settings of the port forwarding rule.
	Config *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfig `json:"Config,omitempty" xml:"Config,omitempty" type:"Struct"`
	// The forwarding port.
	FrontendPort *int32 `json:"FrontendPort,omitempty" xml:"FrontendPort,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The forwarding protocol. Valid values:
	//
	// *   **tcp**
	// *   **udp**
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
}

func (s DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributes) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributes) GoString() string {
	return s.String()
}

func (s *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributes) SetConfig(v *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfig) *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributes {
	s.Config = v
	return s
}

func (s *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributes) SetFrontendPort(v int32) *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributes {
	s.FrontendPort = &v
	return s
}

func (s *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributes) SetInstanceId(v string) *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributes {
	s.InstanceId = &v
	return s
}

func (s *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributes) SetProtocol(v string) *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributes {
	s.Protocol = &v
	return s
}

type DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfig struct {
	// The protection policy applied when the number of connections initiated from a source IP address frequently exceeds the limit.
	Cc *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCc `json:"Cc,omitempty" xml:"Cc,omitempty" type:"Struct"`
	// The status of the Empty Connection switch. Valid values:
	//
	// *   **on**: The switch is turned on.
	// *   **off**: The switch is turned off.
	NodataConn *string `json:"NodataConn,omitempty" xml:"NodataConn,omitempty"`
	// The settings of the Packet Length Limit policy.
	PayloadLen *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigPayloadLen `json:"PayloadLen,omitempty" xml:"PayloadLen,omitempty" type:"Struct"`
	// The timeout period of session persistence. Valid values: **30** to **3600**. Unit: seconds. Default value: **0**, which indicates that session persistence is disabled.
	PersistenceTimeout *int32 `json:"PersistenceTimeout,omitempty" xml:"PersistenceTimeout,omitempty"`
	// The settings of the Speed Limit for Destination policy.
	Sla *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSla `json:"Sla,omitempty" xml:"Sla,omitempty" type:"Struct"`
	// The settings of the Speed Limit for Source policy.
	Slimit *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSlimit `json:"Slimit,omitempty" xml:"Slimit,omitempty" type:"Struct"`
	// The status of the False Source switch. Valid values:
	//
	// *   **on**: The switch is turned on.
	// *   **off**: The switch is turned off.
	Synproxy *string `json:"Synproxy,omitempty" xml:"Synproxy,omitempty"`
}

func (s DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfig) GoString() string {
	return s.String()
}

func (s *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfig) SetCc(v *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCc) *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfig {
	s.Cc = v
	return s
}

func (s *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfig) SetNodataConn(v string) *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfig {
	s.NodataConn = &v
	return s
}

func (s *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfig) SetPayloadLen(v *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigPayloadLen) *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfig {
	s.PayloadLen = v
	return s
}

func (s *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfig) SetPersistenceTimeout(v int32) *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfig {
	s.PersistenceTimeout = &v
	return s
}

func (s *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfig) SetSla(v *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSla) *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfig {
	s.Sla = v
	return s
}

func (s *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfig) SetSlimit(v *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSlimit) *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfig {
	s.Slimit = v
	return s
}

func (s *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfig) SetSynproxy(v string) *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfig {
	s.Synproxy = &v
	return s
}

type DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCc struct {
	// The protection policy that a source IP address is added to the blacklist when the number of connections initiated from the IP address frequently exceeds the limit.
	Sblack []*DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCcSblack `json:"Sblack,omitempty" xml:"Sblack,omitempty" type:"Repeated"`
}

func (s DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCc) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCc) GoString() string {
	return s.String()
}

func (s *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCc) SetSblack(v []*DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCcSblack) *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCc {
	s.Sblack = v
	return s
}

type DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCcSblack struct {
	// The threshold that the number of connections initiated from a source IP address can exceed the limit. Set the value to **5**. If the number of connections initiated from a source IP address exceeds the limit five times during the check, the source IP address is added to the blacklist.
	Cnt *int32 `json:"Cnt,omitempty" xml:"Cnt,omitempty"`
	// The interval at which checks are performed. Set the value to **60**. Unit: seconds.
	During *int32 `json:"During,omitempty" xml:"During,omitempty"`
	// The validity period of the IP address in the blacklist. Valid values: **60** to **604800**. Unit: seconds.
	Expires *int32 `json:"Expires,omitempty" xml:"Expires,omitempty"`
	// The type of the limit that causes a source IP address to be added to the blacklist. Valid values:
	//
	// *   **1**: Source New Connection Rate Limit
	// *   **2**: Source Concurrent Connection Rate Limit
	// *   **3**: PPS Limit for Source
	// *   **4**: Bandwidth Limit for Source
	Type *int32 `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCcSblack) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCcSblack) GoString() string {
	return s.String()
}

func (s *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCcSblack) SetCnt(v int32) *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCcSblack {
	s.Cnt = &v
	return s
}

func (s *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCcSblack) SetDuring(v int32) *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCcSblack {
	s.During = &v
	return s
}

func (s *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCcSblack) SetExpires(v int32) *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCcSblack {
	s.Expires = &v
	return s
}

func (s *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCcSblack) SetType(v int32) *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigCcSblack {
	s.Type = &v
	return s
}

type DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigPayloadLen struct {
	// The maximum length of a packet. Valid values: **0** to **6000**. Unit: bytes.
	Max *int32 `json:"Max,omitempty" xml:"Max,omitempty"`
	// The minimum length of a packet. Valid values: **0** to **6000**. Unit: bytes.
	Min *int32 `json:"Min,omitempty" xml:"Min,omitempty"`
}

func (s DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigPayloadLen) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigPayloadLen) GoString() string {
	return s.String()
}

func (s *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigPayloadLen) SetMax(v int32) *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigPayloadLen {
	s.Max = &v
	return s
}

func (s *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigPayloadLen) SetMin(v int32) *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigPayloadLen {
	s.Min = &v
	return s
}

type DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSla struct {
	// The maximum number of new connections per second that can be established over the port of the destination instance. Valid values: **100** to **100000**.
	Cps *int32 `json:"Cps,omitempty" xml:"Cps,omitempty"`
	// The status of the Destination New Connection Rate Limit switch. Valid values:
	//
	// *   **0**: The switch is turned off.
	// *   **1**: The switch is turned on.
	CpsEnable *int32 `json:"CpsEnable,omitempty" xml:"CpsEnable,omitempty"`
	// The maximum number of concurrent connections that can be established over the port of the destination instance. Valid values: **1000** to **1000000**.
	Maxconn *int32 `json:"Maxconn,omitempty" xml:"Maxconn,omitempty"`
	// The status of the Destination Concurrent Connection Rate Limit switch. Valid values:
	//
	// *   **0**: The switch is turned off.
	// *   **1**: The switch is turned on.
	MaxconnEnable *int32 `json:"MaxconnEnable,omitempty" xml:"MaxconnEnable,omitempty"`
}

func (s DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSla) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSla) GoString() string {
	return s.String()
}

func (s *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSla) SetCps(v int32) *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSla {
	s.Cps = &v
	return s
}

func (s *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSla) SetCpsEnable(v int32) *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSla {
	s.CpsEnable = &v
	return s
}

func (s *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSla) SetMaxconn(v int32) *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSla {
	s.Maxconn = &v
	return s
}

func (s *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSla) SetMaxconnEnable(v int32) *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSla {
	s.MaxconnEnable = &v
	return s
}

type DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSlimit struct {
	// The bandwidth limit for a source IP address. Valid values: **1024** to **268435456**. Unit: bytes/s. Default value: **0**, which indicates that the bandwidth for a source IP address is unlimited.
	Bps *int64 `json:"Bps,omitempty" xml:"Bps,omitempty"`
	// The maximum number of new connections per second that can be initiated from a source IP address. Valid values: **1** to **500000**.
	Cps *int32 `json:"Cps,omitempty" xml:"Cps,omitempty"`
	// The status of the Source New Connection Rate Limit switch. Valid values:
	//
	// *   **0**: The switch is turned off.
	// *   **1**: The switch is turned on.
	CpsEnable *int32 `json:"CpsEnable,omitempty" xml:"CpsEnable,omitempty"`
	// The mode of the Source New Connection Rate Limit switch. Valid values:
	//
	// *   **1**: the manual mode
	// *   **2**: the automatic mode
	CpsMode *int32 `json:"CpsMode,omitempty" xml:"CpsMode,omitempty"`
	// The maximum number of concurrent connections initiated from a source IP address. Valid values: **1** to **500000**.
	Maxconn *int32 `json:"Maxconn,omitempty" xml:"Maxconn,omitempty"`
	// The status of the Source Concurrent Connection Rate Limit switch. Valid values:
	//
	// *   **0**: The switch is turned off.
	// *   **1**: The switch is turned on.
	MaxconnEnable *int32 `json:"MaxconnEnable,omitempty" xml:"MaxconnEnable,omitempty"`
	// The packets per second (pps) limit for a source IP address. Valid values: **1** to **100000**. Unit: packets/s. Default value: **0**, which indicates that the pps for a source IP address is unlimited.
	Pps *int64 `json:"Pps,omitempty" xml:"Pps,omitempty"`
}

func (s DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSlimit) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSlimit) GoString() string {
	return s.String()
}

func (s *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSlimit) SetBps(v int64) *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSlimit {
	s.Bps = &v
	return s
}

func (s *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSlimit) SetCps(v int32) *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSlimit {
	s.Cps = &v
	return s
}

func (s *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSlimit) SetCpsEnable(v int32) *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSlimit {
	s.CpsEnable = &v
	return s
}

func (s *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSlimit) SetCpsMode(v int32) *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSlimit {
	s.CpsMode = &v
	return s
}

func (s *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSlimit) SetMaxconn(v int32) *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSlimit {
	s.Maxconn = &v
	return s
}

func (s *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSlimit) SetMaxconnEnable(v int32) *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSlimit {
	s.MaxconnEnable = &v
	return s
}

func (s *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSlimit) SetPps(v int64) *DescribeNetworkRuleAttributesResponseBodyNetworkRuleAttributesConfigSlimit {
	s.Pps = &v
	return s
}

type DescribeNetworkRuleAttributesResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeNetworkRuleAttributesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeNetworkRuleAttributesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkRuleAttributesResponse) GoString() string {
	return s.String()
}

func (s *DescribeNetworkRuleAttributesResponse) SetHeaders(v map[string]*string) *DescribeNetworkRuleAttributesResponse {
	s.Headers = v
	return s
}

func (s *DescribeNetworkRuleAttributesResponse) SetStatusCode(v int32) *DescribeNetworkRuleAttributesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeNetworkRuleAttributesResponse) SetBody(v *DescribeNetworkRuleAttributesResponseBody) *DescribeNetworkRuleAttributesResponse {
	s.Body = v
	return s
}

type DescribeNetworkRulesRequest struct {
	// The forwarding protocol. Valid values:
	//
	// *   **tcp**
	// *   **udp**
	ForwardProtocol *string `json:"ForwardProtocol,omitempty" xml:"ForwardProtocol,omitempty"`
	// The forwarding port.
	FrontendPort *int32 `json:"FrontendPort,omitempty" xml:"FrontendPort,omitempty"`
	// The ID of the instance.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribeNetworkRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkRulesRequest) GoString() string {
	return s.String()
}

func (s *DescribeNetworkRulesRequest) SetForwardProtocol(v string) *DescribeNetworkRulesRequest {
	s.ForwardProtocol = &v
	return s
}

func (s *DescribeNetworkRulesRequest) SetFrontendPort(v int32) *DescribeNetworkRulesRequest {
	s.FrontendPort = &v
	return s
}

func (s *DescribeNetworkRulesRequest) SetInstanceId(v string) *DescribeNetworkRulesRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeNetworkRulesRequest) SetPageNumber(v int32) *DescribeNetworkRulesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeNetworkRulesRequest) SetPageSize(v int32) *DescribeNetworkRulesRequest {
	s.PageSize = &v
	return s
}

type DescribeNetworkRulesResponseBody struct {
	// An array that consists of the details of a port forwarding rule.
	NetworkRules []*DescribeNetworkRulesResponseBodyNetworkRules `json:"NetworkRules,omitempty" xml:"NetworkRules,omitempty" type:"Repeated"`
	// The ID of the request, which is used to locate and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of returned port forwarding rules.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeNetworkRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkRulesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeNetworkRulesResponseBody) SetNetworkRules(v []*DescribeNetworkRulesResponseBodyNetworkRules) *DescribeNetworkRulesResponseBody {
	s.NetworkRules = v
	return s
}

func (s *DescribeNetworkRulesResponseBody) SetRequestId(v string) *DescribeNetworkRulesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeNetworkRulesResponseBody) SetTotalCount(v int64) *DescribeNetworkRulesResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeNetworkRulesResponseBodyNetworkRules struct {
	// The port of the origin server.
	BackendPort *int32 `json:"BackendPort,omitempty" xml:"BackendPort,omitempty"`
	// The forwarding port.
	FrontendPort *int32 `json:"FrontendPort,omitempty" xml:"FrontendPort,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// Indicates whether the port forwarding rule is automatically created. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	IsAutoCreate *bool `json:"IsAutoCreate,omitempty" xml:"IsAutoCreate,omitempty"`
	// The forwarding protocol. Valid values:
	//
	// *   **tcp**
	// *   **udp**
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// An array that consists of IP addresses of origin servers.
	RealServers []*string `json:"RealServers,omitempty" xml:"RealServers,omitempty" type:"Repeated"`
	Remark      *string   `json:"Remark,omitempty" xml:"Remark,omitempty"`
}

func (s DescribeNetworkRulesResponseBodyNetworkRules) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkRulesResponseBodyNetworkRules) GoString() string {
	return s.String()
}

func (s *DescribeNetworkRulesResponseBodyNetworkRules) SetBackendPort(v int32) *DescribeNetworkRulesResponseBodyNetworkRules {
	s.BackendPort = &v
	return s
}

func (s *DescribeNetworkRulesResponseBodyNetworkRules) SetFrontendPort(v int32) *DescribeNetworkRulesResponseBodyNetworkRules {
	s.FrontendPort = &v
	return s
}

func (s *DescribeNetworkRulesResponseBodyNetworkRules) SetInstanceId(v string) *DescribeNetworkRulesResponseBodyNetworkRules {
	s.InstanceId = &v
	return s
}

func (s *DescribeNetworkRulesResponseBodyNetworkRules) SetIsAutoCreate(v bool) *DescribeNetworkRulesResponseBodyNetworkRules {
	s.IsAutoCreate = &v
	return s
}

func (s *DescribeNetworkRulesResponseBodyNetworkRules) SetProtocol(v string) *DescribeNetworkRulesResponseBodyNetworkRules {
	s.Protocol = &v
	return s
}

func (s *DescribeNetworkRulesResponseBodyNetworkRules) SetRealServers(v []*string) *DescribeNetworkRulesResponseBodyNetworkRules {
	s.RealServers = v
	return s
}

func (s *DescribeNetworkRulesResponseBodyNetworkRules) SetRemark(v string) *DescribeNetworkRulesResponseBodyNetworkRules {
	s.Remark = &v
	return s
}

type DescribeNetworkRulesResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeNetworkRulesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeNetworkRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeNetworkRulesResponse) GoString() string {
	return s.String()
}

func (s *DescribeNetworkRulesResponse) SetHeaders(v map[string]*string) *DescribeNetworkRulesResponse {
	s.Headers = v
	return s
}

func (s *DescribeNetworkRulesResponse) SetStatusCode(v int32) *DescribeNetworkRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeNetworkRulesResponse) SetBody(v *DescribeNetworkRulesResponseBody) *DescribeNetworkRulesResponse {
	s.Body = v
	return s
}

type DescribeOpEntitiesRequest struct {
	// The end of the time range to query. The value is a UNIX timestamp. Unit: milliseconds.
	//
	// > The time must be in the latest 30 days.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The operation object that you want to query.
	EntityObject *string `json:"EntityObject,omitempty" xml:"EntityObject,omitempty"`
	// The type of the operation object that you want to query. Valid values:
	//
	// *   **1**: the IP address of the Anti-DDoS Pro or Anti-DDoS Premium instance
	// *   **2**: Anti-DDoS plans
	// *   **3**: ECS instances
	// *   **4**: all logs
	EntityType *int32 `json:"EntityType,omitempty" xml:"EntityType,omitempty"`
	// The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The beginning of the time range to query. The value is a UNIX timestamp. Unit: milliseconds.
	//
	// > The time must be in the latest 30 days.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeOpEntitiesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeOpEntitiesRequest) GoString() string {
	return s.String()
}

func (s *DescribeOpEntitiesRequest) SetEndTime(v int64) *DescribeOpEntitiesRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeOpEntitiesRequest) SetEntityObject(v string) *DescribeOpEntitiesRequest {
	s.EntityObject = &v
	return s
}

func (s *DescribeOpEntitiesRequest) SetEntityType(v int32) *DescribeOpEntitiesRequest {
	s.EntityType = &v
	return s
}

func (s *DescribeOpEntitiesRequest) SetPageNumber(v int32) *DescribeOpEntitiesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeOpEntitiesRequest) SetPageSize(v int32) *DescribeOpEntitiesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeOpEntitiesRequest) SetResourceGroupId(v string) *DescribeOpEntitiesRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeOpEntitiesRequest) SetStartTime(v int64) *DescribeOpEntitiesRequest {
	s.StartTime = &v
	return s
}

type DescribeOpEntitiesResponseBody struct {
	// An array that consists of the details of the operation log.
	OpEntities []*DescribeOpEntitiesResponseBodyOpEntities `json:"OpEntities,omitempty" xml:"OpEntities,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of returned operation records.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeOpEntitiesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeOpEntitiesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeOpEntitiesResponseBody) SetOpEntities(v []*DescribeOpEntitiesResponseBodyOpEntities) *DescribeOpEntitiesResponseBody {
	s.OpEntities = v
	return s
}

func (s *DescribeOpEntitiesResponseBody) SetRequestId(v string) *DescribeOpEntitiesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeOpEntitiesResponseBody) SetTotalCount(v int64) *DescribeOpEntitiesResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeOpEntitiesResponseBodyOpEntities struct {
	// The operation object.
	EntityObject *string `json:"EntityObject,omitempty" xml:"EntityObject,omitempty"`
	// The type of the operation object. Valid values:
	//
	// *   **1**: the IP address of the Anti-DDoS Pro or Anti-DDoS Premium instance
	// *   **2**: Anti-DDoS plans
	// *   **3**: ECS instances
	// *   **4**: all logs
	EntityType *int32 `json:"EntityType,omitempty" xml:"EntityType,omitempty"`
	// The time when the operation was performed. The value is a UNIX timestamp. Unit: milliseconds.
	GmtCreate *int64 `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The ID of the Alibaba Cloud account that is used to call the API operation.
	OpAccount *string `json:"OpAccount,omitempty" xml:"OpAccount,omitempty"`
	// The type of the operation. Valid values:
	//
	// *   **1**: configuring burstable protection bandwidth.
	// *   **5**: using Anti-DDoS plans.
	// *   **8**: changing IP addresses of ECS instances.
	// *   **9**: deactivating blackhole filtering.
	// *   **10**: configuring the Diversion from Origin Server policy.
	// *   **11**: clearing all logs.
	// *   **12**: downgrading the specifications of instances. If the instance expires or the account has overdue payments, this operation is performed to downgrade the burstable protection bandwidth.
	// *   **13**: restoring the specifications of instances. If the instance is renewed or you have paid the overdue payments within your account, this operation is performed to restore the burstable protection bandwidth.
	OpAction *int32 `json:"OpAction,omitempty" xml:"OpAction,omitempty"`
	// The details of the operation. This parameter is a JSON string. The string contains the following fields:
	//
	// *   **newEntity**: the values of the parameters after the operation. This field must be of the STRING type.
	// *   **oldEntity**: the values of the parameters before the operation. This field must be of the STRING type.
	//
	// Both **newEntity** and **oldEntity** are JSON strings. The returned parameters vary with **OpAtion**.
	//
	// If **OpAction** is **1**, **12**, or **13**, the following parameter is returned:
	//
	// *   **elasticBandwidth**: the burstable protection bandwidth. The value is of the INTEGER type.
	//
	//     For example: `{"newEntity":{"elasticBandwidth":300},"oldEntity":{"elasticBandwidth":300}}`
	//
	// If **OpAction** is **5**, the following parameters are returned:
	//
	// *   **bandwidth**: the burstable protection bandwidth. The value is of the INTEGER type. Unit: Gbit/s.
	//
	// *   **count**: the number of Anti-DDoS plans. The value is of the INTEGER type.
	//
	// *   **deductCount**: the number of used Anti-DDoS plans. The value is of the INTEGER type.
	//
	// *   **expireTime**: the expiration time of the Anti-DDoS plans. The value is of the LONG type. The value is a UNIX timestamp. Unit: milliseconds.
	//
	// *   **instanceId**: the ID of the instance. The value is of the STRING type.
	//
	// *   **peakFlow**: the peak throughput on the instance. The value is of the INTEGER type. Unit: bit/s.
	//
	//     For example: `{"newEntity":{"bandwidth":100,"count":4,"deductCount":1,"expireTime":1616299196000,"instanceId":"ddoscoo-cn-v641kpmq****","peakFlow":751427000}}`
	//
	// If **OpAction** is **8**, the following parameter is returned:
	//
	// *   **instanceId**: the ID of the ECS instance whose IP address is changed. The value is of the STRING type.
	//
	//     For example: `{"newEntity":{"instanceId":"i-wz9h6nc313zptbqn****"}}`
	//
	// If **OpAction** is **9**, the following parameter is returned:
	//
	// *   **actionMethod**: the operation method. The value is of the STRING type. Valid value: **undo**, which indicates that you deactivated blackhole filtering.
	//
	//     For example: `{"newEntity":{"actionMethod":"undo"}}`
	//
	// If **OpAction** is **10**, the following parameters are returned:
	//
	// *   **actionMethod**: the operation method. The value is of the STRING type. Valid values:
	//
	//     *   **do**: The Diversion from Origin Server policy is enabled.
	//     *   **undo**: The Diversion from Origin Server policy is disabled.
	//
	// *   **lines**: The Internet service provider (ISP) line from which the traffic is blocked. Valid values:
	//
	//     *   **ct**: China Telecom (International)
	//     *   **cut**: China Unicom (International)
	//
	//     For example: `{"newEntity":{"actionMethod":"undo","lines":["ct"]}}`
	//
	// If **OpAction** is **11**, no parameter is returned, and the description is empty.
	OpDesc *string `json:"OpDesc,omitempty" xml:"OpDesc,omitempty"`
}

func (s DescribeOpEntitiesResponseBodyOpEntities) String() string {
	return tea.Prettify(s)
}

func (s DescribeOpEntitiesResponseBodyOpEntities) GoString() string {
	return s.String()
}

func (s *DescribeOpEntitiesResponseBodyOpEntities) SetEntityObject(v string) *DescribeOpEntitiesResponseBodyOpEntities {
	s.EntityObject = &v
	return s
}

func (s *DescribeOpEntitiesResponseBodyOpEntities) SetEntityType(v int32) *DescribeOpEntitiesResponseBodyOpEntities {
	s.EntityType = &v
	return s
}

func (s *DescribeOpEntitiesResponseBodyOpEntities) SetGmtCreate(v int64) *DescribeOpEntitiesResponseBodyOpEntities {
	s.GmtCreate = &v
	return s
}

func (s *DescribeOpEntitiesResponseBodyOpEntities) SetOpAccount(v string) *DescribeOpEntitiesResponseBodyOpEntities {
	s.OpAccount = &v
	return s
}

func (s *DescribeOpEntitiesResponseBodyOpEntities) SetOpAction(v int32) *DescribeOpEntitiesResponseBodyOpEntities {
	s.OpAction = &v
	return s
}

func (s *DescribeOpEntitiesResponseBodyOpEntities) SetOpDesc(v string) *DescribeOpEntitiesResponseBodyOpEntities {
	s.OpDesc = &v
	return s
}

type DescribeOpEntitiesResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeOpEntitiesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeOpEntitiesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeOpEntitiesResponse) GoString() string {
	return s.String()
}

func (s *DescribeOpEntitiesResponse) SetHeaders(v map[string]*string) *DescribeOpEntitiesResponse {
	s.Headers = v
	return s
}

func (s *DescribeOpEntitiesResponse) SetStatusCode(v int32) *DescribeOpEntitiesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeOpEntitiesResponse) SetBody(v *DescribeOpEntitiesResponseBody) *DescribeOpEntitiesResponse {
	s.Body = v
	return s
}

type DescribePortRequest struct {
	// The forwarding port to query. Valid values: **0** to **65535**.
	FrontendPort *int32 `json:"FrontendPort,omitempty" xml:"FrontendPort,omitempty"`
	// The type of the forwarding protocol to query. Valid values:
	//
	// *   **tcp**
	// *   **udp**
	FrontendProtocol *string `json:"FrontendProtocol,omitempty" xml:"FrontendProtocol,omitempty"`
	// The ID of the instance to query.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The number of the page to return. For example, if you want to obtain results on the first page, set the value to **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribePortRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePortRequest) GoString() string {
	return s.String()
}

func (s *DescribePortRequest) SetFrontendPort(v int32) *DescribePortRequest {
	s.FrontendPort = &v
	return s
}

func (s *DescribePortRequest) SetFrontendProtocol(v string) *DescribePortRequest {
	s.FrontendProtocol = &v
	return s
}

func (s *DescribePortRequest) SetInstanceId(v string) *DescribePortRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribePortRequest) SetPageNumber(v int32) *DescribePortRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribePortRequest) SetPageSize(v int32) *DescribePortRequest {
	s.PageSize = &v
	return s
}

type DescribePortResponseBody struct {
	// An array that consists of port forwarding rules.
	NetworkRules []*DescribePortResponseBodyNetworkRules `json:"NetworkRules,omitempty" xml:"NetworkRules,omitempty" type:"Repeated"`
	// The ID of the request, which is used to locate and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of port forwarding rules returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribePortResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePortResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePortResponseBody) SetNetworkRules(v []*DescribePortResponseBodyNetworkRules) *DescribePortResponseBody {
	s.NetworkRules = v
	return s
}

func (s *DescribePortResponseBody) SetRequestId(v string) *DescribePortResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribePortResponseBody) SetTotalCount(v int64) *DescribePortResponseBody {
	s.TotalCount = &v
	return s
}

type DescribePortResponseBodyNetworkRules struct {
	// The port of the origin server.
	BackendPort *int32 `json:"BackendPort,omitempty" xml:"BackendPort,omitempty"`
	// The forwarding port.
	FrontendPort *int32 `json:"FrontendPort,omitempty" xml:"FrontendPort,omitempty"`
	// The type of the protocol. Valid values:
	//
	// *   **tcp**
	// *   **udp**
	FrontendProtocol *string `json:"FrontendProtocol,omitempty" xml:"FrontendProtocol,omitempty"`
	// The ID of the instance to which the port forwarding rule is applied.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// Indicates whether the port forwarding rule is automatically created by the instance. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	IsAutoCreate *bool `json:"IsAutoCreate,omitempty" xml:"IsAutoCreate,omitempty"`
	// An array that consists of IP addresses of origin servers.
	RealServers []*string `json:"RealServers,omitempty" xml:"RealServers,omitempty" type:"Repeated"`
}

func (s DescribePortResponseBodyNetworkRules) String() string {
	return tea.Prettify(s)
}

func (s DescribePortResponseBodyNetworkRules) GoString() string {
	return s.String()
}

func (s *DescribePortResponseBodyNetworkRules) SetBackendPort(v int32) *DescribePortResponseBodyNetworkRules {
	s.BackendPort = &v
	return s
}

func (s *DescribePortResponseBodyNetworkRules) SetFrontendPort(v int32) *DescribePortResponseBodyNetworkRules {
	s.FrontendPort = &v
	return s
}

func (s *DescribePortResponseBodyNetworkRules) SetFrontendProtocol(v string) *DescribePortResponseBodyNetworkRules {
	s.FrontendProtocol = &v
	return s
}

func (s *DescribePortResponseBodyNetworkRules) SetInstanceId(v string) *DescribePortResponseBodyNetworkRules {
	s.InstanceId = &v
	return s
}

func (s *DescribePortResponseBodyNetworkRules) SetIsAutoCreate(v bool) *DescribePortResponseBodyNetworkRules {
	s.IsAutoCreate = &v
	return s
}

func (s *DescribePortResponseBodyNetworkRules) SetRealServers(v []*string) *DescribePortResponseBodyNetworkRules {
	s.RealServers = v
	return s
}

type DescribePortResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribePortResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribePortResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePortResponse) GoString() string {
	return s.String()
}

func (s *DescribePortResponse) SetHeaders(v map[string]*string) *DescribePortResponse {
	s.Headers = v
	return s
}

func (s *DescribePortResponse) SetStatusCode(v int32) *DescribePortResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePortResponse) SetBody(v *DescribePortResponseBody) *DescribePortResponse {
	s.Body = v
	return s
}

type DescribePortAttackMaxFlowRequest struct {
	// The end of the time range to query. This value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// An array that consists of the IDs of instances to query.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	// The ID of the resource group to which the instance belongs in Resource Management.
	//
	// If you do not configure this parameter, the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The beginning of the time range to query. This value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribePortAttackMaxFlowRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePortAttackMaxFlowRequest) GoString() string {
	return s.String()
}

func (s *DescribePortAttackMaxFlowRequest) SetEndTime(v int64) *DescribePortAttackMaxFlowRequest {
	s.EndTime = &v
	return s
}

func (s *DescribePortAttackMaxFlowRequest) SetInstanceIds(v []*string) *DescribePortAttackMaxFlowRequest {
	s.InstanceIds = v
	return s
}

func (s *DescribePortAttackMaxFlowRequest) SetResourceGroupId(v string) *DescribePortAttackMaxFlowRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribePortAttackMaxFlowRequest) SetStartTime(v int64) *DescribePortAttackMaxFlowRequest {
	s.StartTime = &v
	return s
}

type DescribePortAttackMaxFlowResponseBody struct {
	// The peak bandwidth of attack traffic. Unit: bit/s.
	Bps *int64 `json:"Bps,omitempty" xml:"Bps,omitempty"`
	// The peak packet rate of attack traffic . Unit: packets per second (pps).
	Pps *int64 `json:"Pps,omitempty" xml:"Pps,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribePortAttackMaxFlowResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePortAttackMaxFlowResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePortAttackMaxFlowResponseBody) SetBps(v int64) *DescribePortAttackMaxFlowResponseBody {
	s.Bps = &v
	return s
}

func (s *DescribePortAttackMaxFlowResponseBody) SetPps(v int64) *DescribePortAttackMaxFlowResponseBody {
	s.Pps = &v
	return s
}

func (s *DescribePortAttackMaxFlowResponseBody) SetRequestId(v string) *DescribePortAttackMaxFlowResponseBody {
	s.RequestId = &v
	return s
}

type DescribePortAttackMaxFlowResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribePortAttackMaxFlowResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribePortAttackMaxFlowResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePortAttackMaxFlowResponse) GoString() string {
	return s.String()
}

func (s *DescribePortAttackMaxFlowResponse) SetHeaders(v map[string]*string) *DescribePortAttackMaxFlowResponse {
	s.Headers = v
	return s
}

func (s *DescribePortAttackMaxFlowResponse) SetStatusCode(v int32) *DescribePortAttackMaxFlowResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePortAttackMaxFlowResponse) SetBody(v *DescribePortAttackMaxFlowResponseBody) *DescribePortAttackMaxFlowResponse {
	s.Body = v
	return s
}

type DescribePortAutoCcStatusRequest struct {
	// The ID of the instance.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
}

func (s DescribePortAutoCcStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePortAutoCcStatusRequest) GoString() string {
	return s.String()
}

func (s *DescribePortAutoCcStatusRequest) SetInstanceIds(v []*string) *DescribePortAutoCcStatusRequest {
	s.InstanceIds = v
	return s
}

type DescribePortAutoCcStatusResponseBody struct {
	// An array that consists of the configurations of the Intelligent Protection policy.
	PortAutoCcStatus []*DescribePortAutoCcStatusResponseBodyPortAutoCcStatus `json:"PortAutoCcStatus,omitempty" xml:"PortAutoCcStatus,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribePortAutoCcStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePortAutoCcStatusResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePortAutoCcStatusResponseBody) SetPortAutoCcStatus(v []*DescribePortAutoCcStatusResponseBodyPortAutoCcStatus) *DescribePortAutoCcStatusResponseBody {
	s.PortAutoCcStatus = v
	return s
}

func (s *DescribePortAutoCcStatusResponseBody) SetRequestId(v string) *DescribePortAutoCcStatusResponseBody {
	s.RequestId = &v
	return s
}

type DescribePortAutoCcStatusResponseBodyPortAutoCcStatus struct {
	// The mode of the Intelligent Protection policy. Valid values:
	//
	// *   **normal**
	// *   **loose**
	// *   **strict**
	Mode *string `json:"Mode,omitempty" xml:"Mode,omitempty"`
	// The status of the Intelligent Protection policy. Valid values:
	//
	// *   **on**: enabled
	// *   **off**: disabled
	Switch *string `json:"Switch,omitempty" xml:"Switch,omitempty"`
	// The protection mode for ports 80 and 443. Valid values:
	//
	// *   **normal**
	// *   **loose**
	// *   **strict**
	WebMode *string `json:"WebMode,omitempty" xml:"WebMode,omitempty"`
	// The status of the Intelligent Protection policy for ports 80 and 443. Valid values:
	//
	// *   **on**: enabled
	// *   **off**: disabled
	WebSwitch *string `json:"WebSwitch,omitempty" xml:"WebSwitch,omitempty"`
}

func (s DescribePortAutoCcStatusResponseBodyPortAutoCcStatus) String() string {
	return tea.Prettify(s)
}

func (s DescribePortAutoCcStatusResponseBodyPortAutoCcStatus) GoString() string {
	return s.String()
}

func (s *DescribePortAutoCcStatusResponseBodyPortAutoCcStatus) SetMode(v string) *DescribePortAutoCcStatusResponseBodyPortAutoCcStatus {
	s.Mode = &v
	return s
}

func (s *DescribePortAutoCcStatusResponseBodyPortAutoCcStatus) SetSwitch(v string) *DescribePortAutoCcStatusResponseBodyPortAutoCcStatus {
	s.Switch = &v
	return s
}

func (s *DescribePortAutoCcStatusResponseBodyPortAutoCcStatus) SetWebMode(v string) *DescribePortAutoCcStatusResponseBodyPortAutoCcStatus {
	s.WebMode = &v
	return s
}

func (s *DescribePortAutoCcStatusResponseBodyPortAutoCcStatus) SetWebSwitch(v string) *DescribePortAutoCcStatusResponseBodyPortAutoCcStatus {
	s.WebSwitch = &v
	return s
}

type DescribePortAutoCcStatusResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribePortAutoCcStatusResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribePortAutoCcStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePortAutoCcStatusResponse) GoString() string {
	return s.String()
}

func (s *DescribePortAutoCcStatusResponse) SetHeaders(v map[string]*string) *DescribePortAutoCcStatusResponse {
	s.Headers = v
	return s
}

func (s *DescribePortAutoCcStatusResponse) SetStatusCode(v int32) *DescribePortAutoCcStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePortAutoCcStatusResponse) SetBody(v *DescribePortAutoCcStatusResponseBody) *DescribePortAutoCcStatusResponse {
	s.Body = v
	return s
}

type DescribePortCcAttackTopIPRequest struct {
	Ip             *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	Limit          *int64  `json:"Limit,omitempty" xml:"Limit,omitempty"`
	Port           *string `json:"Port,omitempty" xml:"Port,omitempty"`
	StartTimestamp *int64  `json:"StartTimestamp,omitempty" xml:"StartTimestamp,omitempty"`
}

func (s DescribePortCcAttackTopIPRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePortCcAttackTopIPRequest) GoString() string {
	return s.String()
}

func (s *DescribePortCcAttackTopIPRequest) SetIp(v string) *DescribePortCcAttackTopIPRequest {
	s.Ip = &v
	return s
}

func (s *DescribePortCcAttackTopIPRequest) SetLimit(v int64) *DescribePortCcAttackTopIPRequest {
	s.Limit = &v
	return s
}

func (s *DescribePortCcAttackTopIPRequest) SetPort(v string) *DescribePortCcAttackTopIPRequest {
	s.Port = &v
	return s
}

func (s *DescribePortCcAttackTopIPRequest) SetStartTimestamp(v int64) *DescribePortCcAttackTopIPRequest {
	s.StartTimestamp = &v
	return s
}

type DescribePortCcAttackTopIPResponseBody struct {
	RequestId *string                                       `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TopIp     []*DescribePortCcAttackTopIPResponseBodyTopIp `json:"TopIp,omitempty" xml:"TopIp,omitempty" type:"Repeated"`
}

func (s DescribePortCcAttackTopIPResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePortCcAttackTopIPResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePortCcAttackTopIPResponseBody) SetRequestId(v string) *DescribePortCcAttackTopIPResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribePortCcAttackTopIPResponseBody) SetTopIp(v []*DescribePortCcAttackTopIPResponseBodyTopIp) *DescribePortCcAttackTopIPResponseBody {
	s.TopIp = v
	return s
}

type DescribePortCcAttackTopIPResponseBodyTopIp struct {
	AreaId *string `json:"AreaId,omitempty" xml:"AreaId,omitempty"`
	Pv     *int64  `json:"Pv,omitempty" xml:"Pv,omitempty"`
	SrcIp  *string `json:"SrcIp,omitempty" xml:"SrcIp,omitempty"`
}

func (s DescribePortCcAttackTopIPResponseBodyTopIp) String() string {
	return tea.Prettify(s)
}

func (s DescribePortCcAttackTopIPResponseBodyTopIp) GoString() string {
	return s.String()
}

func (s *DescribePortCcAttackTopIPResponseBodyTopIp) SetAreaId(v string) *DescribePortCcAttackTopIPResponseBodyTopIp {
	s.AreaId = &v
	return s
}

func (s *DescribePortCcAttackTopIPResponseBodyTopIp) SetPv(v int64) *DescribePortCcAttackTopIPResponseBodyTopIp {
	s.Pv = &v
	return s
}

func (s *DescribePortCcAttackTopIPResponseBodyTopIp) SetSrcIp(v string) *DescribePortCcAttackTopIPResponseBodyTopIp {
	s.SrcIp = &v
	return s
}

type DescribePortCcAttackTopIPResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribePortCcAttackTopIPResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribePortCcAttackTopIPResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePortCcAttackTopIPResponse) GoString() string {
	return s.String()
}

func (s *DescribePortCcAttackTopIPResponse) SetHeaders(v map[string]*string) *DescribePortCcAttackTopIPResponse {
	s.Headers = v
	return s
}

func (s *DescribePortCcAttackTopIPResponse) SetStatusCode(v int32) *DescribePortCcAttackTopIPResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePortCcAttackTopIPResponse) SetBody(v *DescribePortCcAttackTopIPResponseBody) *DescribePortCcAttackTopIPResponse {
	s.Body = v
	return s
}

type DescribePortConnsCountRequest struct {
	// The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// An array that consists of the IDs of instances.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	// The number of port that you want to query. If you do not specify this parameter, all ports are queried.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribePortConnsCountRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePortConnsCountRequest) GoString() string {
	return s.String()
}

func (s *DescribePortConnsCountRequest) SetEndTime(v int64) *DescribePortConnsCountRequest {
	s.EndTime = &v
	return s
}

func (s *DescribePortConnsCountRequest) SetInstanceIds(v []*string) *DescribePortConnsCountRequest {
	s.InstanceIds = v
	return s
}

func (s *DescribePortConnsCountRequest) SetPort(v string) *DescribePortConnsCountRequest {
	s.Port = &v
	return s
}

func (s *DescribePortConnsCountRequest) SetResourceGroupId(v string) *DescribePortConnsCountRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribePortConnsCountRequest) SetStartTime(v int64) *DescribePortConnsCountRequest {
	s.StartTime = &v
	return s
}

type DescribePortConnsCountResponseBody struct {
	// The number of active connections.
	ActConns *int64 `json:"ActConns,omitempty" xml:"ActConns,omitempty"`
	// The number of concurrent connections.
	Conns *int64 `json:"Conns,omitempty" xml:"Conns,omitempty"`
	// The number of new connections.
	Cps *int64 `json:"Cps,omitempty" xml:"Cps,omitempty"`
	// The number of inactive connections.
	InActConns *int64 `json:"InActConns,omitempty" xml:"InActConns,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribePortConnsCountResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePortConnsCountResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePortConnsCountResponseBody) SetActConns(v int64) *DescribePortConnsCountResponseBody {
	s.ActConns = &v
	return s
}

func (s *DescribePortConnsCountResponseBody) SetConns(v int64) *DescribePortConnsCountResponseBody {
	s.Conns = &v
	return s
}

func (s *DescribePortConnsCountResponseBody) SetCps(v int64) *DescribePortConnsCountResponseBody {
	s.Cps = &v
	return s
}

func (s *DescribePortConnsCountResponseBody) SetInActConns(v int64) *DescribePortConnsCountResponseBody {
	s.InActConns = &v
	return s
}

func (s *DescribePortConnsCountResponseBody) SetRequestId(v string) *DescribePortConnsCountResponseBody {
	s.RequestId = &v
	return s
}

type DescribePortConnsCountResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribePortConnsCountResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribePortConnsCountResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePortConnsCountResponse) GoString() string {
	return s.String()
}

func (s *DescribePortConnsCountResponse) SetHeaders(v map[string]*string) *DescribePortConnsCountResponse {
	s.Headers = v
	return s
}

func (s *DescribePortConnsCountResponse) SetStatusCode(v int32) *DescribePortConnsCountResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePortConnsCountResponse) SetBody(v *DescribePortConnsCountResponseBody) *DescribePortConnsCountResponse {
	s.Body = v
	return s
}

type DescribePortConnsListRequest struct {
	// The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the instance.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	// The interval for returning data. Unit: seconds.
	Interval *int32 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The number of port that you want to query. If you do not specify this parameter, all ports are queried.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribePortConnsListRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePortConnsListRequest) GoString() string {
	return s.String()
}

func (s *DescribePortConnsListRequest) SetEndTime(v int64) *DescribePortConnsListRequest {
	s.EndTime = &v
	return s
}

func (s *DescribePortConnsListRequest) SetInstanceIds(v []*string) *DescribePortConnsListRequest {
	s.InstanceIds = v
	return s
}

func (s *DescribePortConnsListRequest) SetInterval(v int32) *DescribePortConnsListRequest {
	s.Interval = &v
	return s
}

func (s *DescribePortConnsListRequest) SetPort(v string) *DescribePortConnsListRequest {
	s.Port = &v
	return s
}

func (s *DescribePortConnsListRequest) SetResourceGroupId(v string) *DescribePortConnsListRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribePortConnsListRequest) SetStartTime(v int64) *DescribePortConnsListRequest {
	s.StartTime = &v
	return s
}

type DescribePortConnsListResponseBody struct {
	// An array that consists of the connections established over the port.
	ConnsList []*DescribePortConnsListResponseBodyConnsList `json:"ConnsList,omitempty" xml:"ConnsList,omitempty" type:"Repeated"`
	// The ID of the request, which is used to locate and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribePortConnsListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePortConnsListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePortConnsListResponseBody) SetConnsList(v []*DescribePortConnsListResponseBodyConnsList) *DescribePortConnsListResponseBody {
	s.ConnsList = v
	return s
}

func (s *DescribePortConnsListResponseBody) SetRequestId(v string) *DescribePortConnsListResponseBody {
	s.RequestId = &v
	return s
}

type DescribePortConnsListResponseBodyConnsList struct {
	// The number of active connections.
	ActConns *int64 `json:"ActConns,omitempty" xml:"ActConns,omitempty"`
	// The number of concurrent connections.
	Conns *int64 `json:"Conns,omitempty" xml:"Conns,omitempty"`
	// The new connection creation rate.
	Cps *int64 `json:"Cps,omitempty" xml:"Cps,omitempty"`
	// The number of inactive connections.
	InActConns *int64 `json:"InActConns,omitempty" xml:"InActConns,omitempty"`
	// The index number of the returned data.
	Index *int64 `json:"Index,omitempty" xml:"Index,omitempty"`
}

func (s DescribePortConnsListResponseBodyConnsList) String() string {
	return tea.Prettify(s)
}

func (s DescribePortConnsListResponseBodyConnsList) GoString() string {
	return s.String()
}

func (s *DescribePortConnsListResponseBodyConnsList) SetActConns(v int64) *DescribePortConnsListResponseBodyConnsList {
	s.ActConns = &v
	return s
}

func (s *DescribePortConnsListResponseBodyConnsList) SetConns(v int64) *DescribePortConnsListResponseBodyConnsList {
	s.Conns = &v
	return s
}

func (s *DescribePortConnsListResponseBodyConnsList) SetCps(v int64) *DescribePortConnsListResponseBodyConnsList {
	s.Cps = &v
	return s
}

func (s *DescribePortConnsListResponseBodyConnsList) SetInActConns(v int64) *DescribePortConnsListResponseBodyConnsList {
	s.InActConns = &v
	return s
}

func (s *DescribePortConnsListResponseBodyConnsList) SetIndex(v int64) *DescribePortConnsListResponseBodyConnsList {
	s.Index = &v
	return s
}

type DescribePortConnsListResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribePortConnsListResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribePortConnsListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePortConnsListResponse) GoString() string {
	return s.String()
}

func (s *DescribePortConnsListResponse) SetHeaders(v map[string]*string) *DescribePortConnsListResponse {
	s.Headers = v
	return s
}

func (s *DescribePortConnsListResponse) SetStatusCode(v int32) *DescribePortConnsListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePortConnsListResponse) SetBody(v *DescribePortConnsListResponseBody) *DescribePortConnsListResponse {
	s.Body = v
	return s
}

type DescribePortFlowListRequest struct {
	// The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// **
	//
	// **This UNIX timestamp must indicate a point in time that is accurate to the minute.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// An array that consists of the IDs of instances.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	// The interval for returning data. Unit: seconds. The interval that you can specify varies based on the time range to query. The time range to query is determined by the values of **StartTime** and **EndTime**.
	//
	// *   If the time range to query is no greater than 1 hour, we recommend that you specify the interval from 60 seconds to the time range to query.
	// *   If the time range to query is greater than 1 hour but no greater than 6 hours, we recommend that you specify the interval from 600 seconds to the time range to query.
	// *   If the time range to query is greater than 6 hours but no greater than 24 hours, we recommend that you specify the interval from 1,800 seconds to the time range to query.
	// *   If the time range to query is greater than 24 hours but no greater than 7 days, we recommend that you specify the interval from 3,600 seconds to the time range to query.
	// *   If the time range to query is greater than 7 days but no greater than 15 days, we recommend that you specify the interval from 14,400 seconds to the time range to query.
	// *   If the time range to query is greater than 15 days, we recommend that you specify the interval from 43,200 seconds to the time range to query.
	Interval *int32 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	//
	// For more information about resource groups, see [Create a resource group](~~94485~~).
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// **
	//
	// **This UNIX timestamp must indicate a point in time that is accurate to the minute.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribePortFlowListRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePortFlowListRequest) GoString() string {
	return s.String()
}

func (s *DescribePortFlowListRequest) SetEndTime(v int64) *DescribePortFlowListRequest {
	s.EndTime = &v
	return s
}

func (s *DescribePortFlowListRequest) SetInstanceIds(v []*string) *DescribePortFlowListRequest {
	s.InstanceIds = v
	return s
}

func (s *DescribePortFlowListRequest) SetInterval(v int32) *DescribePortFlowListRequest {
	s.Interval = &v
	return s
}

func (s *DescribePortFlowListRequest) SetResourceGroupId(v string) *DescribePortFlowListRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribePortFlowListRequest) SetStartTime(v int64) *DescribePortFlowListRequest {
	s.StartTime = &v
	return s
}

type DescribePortFlowListResponseBody struct {
	// The returned traffic data.
	PortFlowList []*DescribePortFlowListResponseBodyPortFlowList `json:"PortFlowList,omitempty" xml:"PortFlowList,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribePortFlowListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePortFlowListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePortFlowListResponseBody) SetPortFlowList(v []*DescribePortFlowListResponseBodyPortFlowList) *DescribePortFlowListResponseBody {
	s.PortFlowList = v
	return s
}

func (s *DescribePortFlowListResponseBody) SetRequestId(v string) *DescribePortFlowListResponseBody {
	s.RequestId = &v
	return s
}

type DescribePortFlowListResponseBodyPortFlowList struct {
	// The bandwidth of attack traffic. Unit: bit/s.
	AttackBps *int64 `json:"AttackBps,omitempty" xml:"AttackBps,omitempty"`
	// The packet forwarding rate of attack traffic. Unit: pps.
	AttackPps *int64 `json:"AttackPps,omitempty" xml:"AttackPps,omitempty"`
	// The inbound bandwidth. Unit: bit/s.
	InBps *int64 `json:"InBps,omitempty" xml:"InBps,omitempty"`
	// The packet forwarding rate of inbound traffic. Unit: packets per second.
	InPps *int64 `json:"InPps,omitempty" xml:"InPps,omitempty"`
	// The index number of the returned data.
	Index *int64 `json:"Index,omitempty" xml:"Index,omitempty"`
	// The outbound bandwidth. Unit: bit/s.
	OutBps *int64 `json:"OutBps,omitempty" xml:"OutBps,omitempty"`
	// The packet forwarding rate of outbound traffic. Unit: packets per second (pps).
	OutPps *int64 `json:"OutPps,omitempty" xml:"OutPps,omitempty"`
	// The source region of the traffic. Valid values:
	//
	// *   **cn**: mainland China
	// *   **alb-ap-northeast-1-gf-x**: Japan (Tokyo)
	// *   **alb-ap-southeast-gf-x**: Singapore
	// *   **alb-cn-hongkong-gf-x**: Hong Kong (China)
	// *   **alb-eu-central-1-gf-x**: Germany (Frankfurt)
	// *   **alb-us-west-1-gf-x**: US (Silicon Valley)
	//
	// > The values except **cn** are returned only when **RegionId** is set to **ap-southeast-1**.
	Region         *string `json:"Region,omitempty" xml:"Region,omitempty"`
	SlaBpsDropBps  *int64  `json:"SlaBpsDropBps,omitempty" xml:"SlaBpsDropBps,omitempty"`
	SlaBpsDropPps  *int64  `json:"SlaBpsDropPps,omitempty" xml:"SlaBpsDropPps,omitempty"`
	SlaConnDropBps *int64  `json:"SlaConnDropBps,omitempty" xml:"SlaConnDropBps,omitempty"`
	SlaConnDropPps *int64  `json:"SlaConnDropPps,omitempty" xml:"SlaConnDropPps,omitempty"`
	SlaCpsDropBps  *int64  `json:"SlaCpsDropBps,omitempty" xml:"SlaCpsDropBps,omitempty"`
	SlaCpsDropPps  *int64  `json:"SlaCpsDropPps,omitempty" xml:"SlaCpsDropPps,omitempty"`
	SlaPpsDropBps  *int64  `json:"SlaPpsDropBps,omitempty" xml:"SlaPpsDropBps,omitempty"`
	SlaPpsDropPps  *int64  `json:"SlaPpsDropPps,omitempty" xml:"SlaPpsDropPps,omitempty"`
	// The time when the data was collected. The value is a UNIX timestamp. Unit: seconds.
	Time *int64 `json:"Time,omitempty" xml:"Time,omitempty"`
}

func (s DescribePortFlowListResponseBodyPortFlowList) String() string {
	return tea.Prettify(s)
}

func (s DescribePortFlowListResponseBodyPortFlowList) GoString() string {
	return s.String()
}

func (s *DescribePortFlowListResponseBodyPortFlowList) SetAttackBps(v int64) *DescribePortFlowListResponseBodyPortFlowList {
	s.AttackBps = &v
	return s
}

func (s *DescribePortFlowListResponseBodyPortFlowList) SetAttackPps(v int64) *DescribePortFlowListResponseBodyPortFlowList {
	s.AttackPps = &v
	return s
}

func (s *DescribePortFlowListResponseBodyPortFlowList) SetInBps(v int64) *DescribePortFlowListResponseBodyPortFlowList {
	s.InBps = &v
	return s
}

func (s *DescribePortFlowListResponseBodyPortFlowList) SetInPps(v int64) *DescribePortFlowListResponseBodyPortFlowList {
	s.InPps = &v
	return s
}

func (s *DescribePortFlowListResponseBodyPortFlowList) SetIndex(v int64) *DescribePortFlowListResponseBodyPortFlowList {
	s.Index = &v
	return s
}

func (s *DescribePortFlowListResponseBodyPortFlowList) SetOutBps(v int64) *DescribePortFlowListResponseBodyPortFlowList {
	s.OutBps = &v
	return s
}

func (s *DescribePortFlowListResponseBodyPortFlowList) SetOutPps(v int64) *DescribePortFlowListResponseBodyPortFlowList {
	s.OutPps = &v
	return s
}

func (s *DescribePortFlowListResponseBodyPortFlowList) SetRegion(v string) *DescribePortFlowListResponseBodyPortFlowList {
	s.Region = &v
	return s
}

func (s *DescribePortFlowListResponseBodyPortFlowList) SetSlaBpsDropBps(v int64) *DescribePortFlowListResponseBodyPortFlowList {
	s.SlaBpsDropBps = &v
	return s
}

func (s *DescribePortFlowListResponseBodyPortFlowList) SetSlaBpsDropPps(v int64) *DescribePortFlowListResponseBodyPortFlowList {
	s.SlaBpsDropPps = &v
	return s
}

func (s *DescribePortFlowListResponseBodyPortFlowList) SetSlaConnDropBps(v int64) *DescribePortFlowListResponseBodyPortFlowList {
	s.SlaConnDropBps = &v
	return s
}

func (s *DescribePortFlowListResponseBodyPortFlowList) SetSlaConnDropPps(v int64) *DescribePortFlowListResponseBodyPortFlowList {
	s.SlaConnDropPps = &v
	return s
}

func (s *DescribePortFlowListResponseBodyPortFlowList) SetSlaCpsDropBps(v int64) *DescribePortFlowListResponseBodyPortFlowList {
	s.SlaCpsDropBps = &v
	return s
}

func (s *DescribePortFlowListResponseBodyPortFlowList) SetSlaCpsDropPps(v int64) *DescribePortFlowListResponseBodyPortFlowList {
	s.SlaCpsDropPps = &v
	return s
}

func (s *DescribePortFlowListResponseBodyPortFlowList) SetSlaPpsDropBps(v int64) *DescribePortFlowListResponseBodyPortFlowList {
	s.SlaPpsDropBps = &v
	return s
}

func (s *DescribePortFlowListResponseBodyPortFlowList) SetSlaPpsDropPps(v int64) *DescribePortFlowListResponseBodyPortFlowList {
	s.SlaPpsDropPps = &v
	return s
}

func (s *DescribePortFlowListResponseBodyPortFlowList) SetTime(v int64) *DescribePortFlowListResponseBodyPortFlowList {
	s.Time = &v
	return s
}

type DescribePortFlowListResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribePortFlowListResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribePortFlowListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePortFlowListResponse) GoString() string {
	return s.String()
}

func (s *DescribePortFlowListResponse) SetHeaders(v map[string]*string) *DescribePortFlowListResponse {
	s.Headers = v
	return s
}

func (s *DescribePortFlowListResponse) SetStatusCode(v int32) *DescribePortFlowListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePortFlowListResponse) SetBody(v *DescribePortFlowListResponseBody) *DescribePortFlowListResponse {
	s.Body = v
	return s
}

type DescribePortMaxConnsRequest struct {
	// The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the instance.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribePortMaxConnsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePortMaxConnsRequest) GoString() string {
	return s.String()
}

func (s *DescribePortMaxConnsRequest) SetEndTime(v int64) *DescribePortMaxConnsRequest {
	s.EndTime = &v
	return s
}

func (s *DescribePortMaxConnsRequest) SetInstanceIds(v []*string) *DescribePortMaxConnsRequest {
	s.InstanceIds = v
	return s
}

func (s *DescribePortMaxConnsRequest) SetResourceGroupId(v string) *DescribePortMaxConnsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribePortMaxConnsRequest) SetStartTime(v int64) *DescribePortMaxConnsRequest {
	s.StartTime = &v
	return s
}

type DescribePortMaxConnsResponseBody struct {
	// An array consisting of the details of the maximum number of connections that are established over a port of the instance.
	PortMaxConns []*DescribePortMaxConnsResponseBodyPortMaxConns `json:"PortMaxConns,omitempty" xml:"PortMaxConns,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribePortMaxConnsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePortMaxConnsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePortMaxConnsResponseBody) SetPortMaxConns(v []*DescribePortMaxConnsResponseBodyPortMaxConns) *DescribePortMaxConnsResponseBody {
	s.PortMaxConns = v
	return s
}

func (s *DescribePortMaxConnsResponseBody) SetRequestId(v string) *DescribePortMaxConnsResponseBody {
	s.RequestId = &v
	return s
}

type DescribePortMaxConnsResponseBodyPortMaxConns struct {
	// The maximum number of connections per second (CPS).
	Cps *int64 `json:"Cps,omitempty" xml:"Cps,omitempty"`
	// The IP address of the instance.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The port of the instance.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
}

func (s DescribePortMaxConnsResponseBodyPortMaxConns) String() string {
	return tea.Prettify(s)
}

func (s DescribePortMaxConnsResponseBodyPortMaxConns) GoString() string {
	return s.String()
}

func (s *DescribePortMaxConnsResponseBodyPortMaxConns) SetCps(v int64) *DescribePortMaxConnsResponseBodyPortMaxConns {
	s.Cps = &v
	return s
}

func (s *DescribePortMaxConnsResponseBodyPortMaxConns) SetIp(v string) *DescribePortMaxConnsResponseBodyPortMaxConns {
	s.Ip = &v
	return s
}

func (s *DescribePortMaxConnsResponseBodyPortMaxConns) SetPort(v string) *DescribePortMaxConnsResponseBodyPortMaxConns {
	s.Port = &v
	return s
}

type DescribePortMaxConnsResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribePortMaxConnsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribePortMaxConnsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePortMaxConnsResponse) GoString() string {
	return s.String()
}

func (s *DescribePortMaxConnsResponse) SetHeaders(v map[string]*string) *DescribePortMaxConnsResponse {
	s.Headers = v
	return s
}

func (s *DescribePortMaxConnsResponse) SetStatusCode(v int32) *DescribePortMaxConnsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePortMaxConnsResponse) SetBody(v *DescribePortMaxConnsResponseBody) *DescribePortMaxConnsResponse {
	s.Body = v
	return s
}

type DescribePortViewSourceCountriesRequest struct {
	// The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// An array that consists of the IDs of instances to query.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	//
	// For more information about resource groups, see [Create a resource group](~~94485~~).
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribePortViewSourceCountriesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePortViewSourceCountriesRequest) GoString() string {
	return s.String()
}

func (s *DescribePortViewSourceCountriesRequest) SetEndTime(v int64) *DescribePortViewSourceCountriesRequest {
	s.EndTime = &v
	return s
}

func (s *DescribePortViewSourceCountriesRequest) SetInstanceIds(v []*string) *DescribePortViewSourceCountriesRequest {
	s.InstanceIds = v
	return s
}

func (s *DescribePortViewSourceCountriesRequest) SetResourceGroupId(v string) *DescribePortViewSourceCountriesRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribePortViewSourceCountriesRequest) SetStartTime(v int64) *DescribePortViewSourceCountriesRequest {
	s.StartTime = &v
	return s
}

type DescribePortViewSourceCountriesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// An array consisting of countries or areas from which the requests are sent.
	SourceCountrys []*DescribePortViewSourceCountriesResponseBodySourceCountrys `json:"SourceCountrys,omitempty" xml:"SourceCountrys,omitempty" type:"Repeated"`
}

func (s DescribePortViewSourceCountriesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePortViewSourceCountriesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePortViewSourceCountriesResponseBody) SetRequestId(v string) *DescribePortViewSourceCountriesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribePortViewSourceCountriesResponseBody) SetSourceCountrys(v []*DescribePortViewSourceCountriesResponseBodySourceCountrys) *DescribePortViewSourceCountriesResponseBody {
	s.SourceCountrys = v
	return s
}

type DescribePortViewSourceCountriesResponseBodySourceCountrys struct {
	// The number of requests.
	Count *int64 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The abbreviation of the country or area. For example, **cn** indicates China and **us** indicates the United States.
	//
	// > For more information, see [Location parameters](~~167926~~).
	CountryId *string `json:"CountryId,omitempty" xml:"CountryId,omitempty"`
}

func (s DescribePortViewSourceCountriesResponseBodySourceCountrys) String() string {
	return tea.Prettify(s)
}

func (s DescribePortViewSourceCountriesResponseBodySourceCountrys) GoString() string {
	return s.String()
}

func (s *DescribePortViewSourceCountriesResponseBodySourceCountrys) SetCount(v int64) *DescribePortViewSourceCountriesResponseBodySourceCountrys {
	s.Count = &v
	return s
}

func (s *DescribePortViewSourceCountriesResponseBodySourceCountrys) SetCountryId(v string) *DescribePortViewSourceCountriesResponseBodySourceCountrys {
	s.CountryId = &v
	return s
}

type DescribePortViewSourceCountriesResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribePortViewSourceCountriesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribePortViewSourceCountriesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePortViewSourceCountriesResponse) GoString() string {
	return s.String()
}

func (s *DescribePortViewSourceCountriesResponse) SetHeaders(v map[string]*string) *DescribePortViewSourceCountriesResponse {
	s.Headers = v
	return s
}

func (s *DescribePortViewSourceCountriesResponse) SetStatusCode(v int32) *DescribePortViewSourceCountriesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePortViewSourceCountriesResponse) SetBody(v *DescribePortViewSourceCountriesResponseBody) *DescribePortViewSourceCountriesResponse {
	s.Body = v
	return s
}

type DescribePortViewSourceIspsRequest struct {
	// The end of the time range to query. This value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// An array that consists of the IDs of instances to query.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	// The ID of the resource group to which the instance belongs in Resource Management.
	//
	// If you do not configure this parameter, the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The beginning of the time range to query. This value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribePortViewSourceIspsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePortViewSourceIspsRequest) GoString() string {
	return s.String()
}

func (s *DescribePortViewSourceIspsRequest) SetEndTime(v int64) *DescribePortViewSourceIspsRequest {
	s.EndTime = &v
	return s
}

func (s *DescribePortViewSourceIspsRequest) SetInstanceIds(v []*string) *DescribePortViewSourceIspsRequest {
	s.InstanceIds = v
	return s
}

func (s *DescribePortViewSourceIspsRequest) SetResourceGroupId(v string) *DescribePortViewSourceIspsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribePortViewSourceIspsRequest) SetStartTime(v int64) *DescribePortViewSourceIspsRequest {
	s.StartTime = &v
	return s
}

type DescribePortViewSourceIspsResponseBody struct {
	// An array that consists of the details of the ISP.
	Isps []*DescribePortViewSourceIspsResponseBodyIsps `json:"Isps,omitempty" xml:"Isps,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribePortViewSourceIspsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePortViewSourceIspsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePortViewSourceIspsResponseBody) SetIsps(v []*DescribePortViewSourceIspsResponseBodyIsps) *DescribePortViewSourceIspsResponseBody {
	s.Isps = v
	return s
}

func (s *DescribePortViewSourceIspsResponseBody) SetRequestId(v string) *DescribePortViewSourceIspsResponseBody {
	s.RequestId = &v
	return s
}

type DescribePortViewSourceIspsResponseBodyIsps struct {
	// The total number of requests that are sent from the ISP.
	//
	// > This parameter does not indicate the accurate number of requests. You can use this parameter to calculate the proportion of requests from different ISPs.
	Count *int64 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The ID of the ISP. For more information, see the ISP codes table.
	IspId *string `json:"IspId,omitempty" xml:"IspId,omitempty"`
}

func (s DescribePortViewSourceIspsResponseBodyIsps) String() string {
	return tea.Prettify(s)
}

func (s DescribePortViewSourceIspsResponseBodyIsps) GoString() string {
	return s.String()
}

func (s *DescribePortViewSourceIspsResponseBodyIsps) SetCount(v int64) *DescribePortViewSourceIspsResponseBodyIsps {
	s.Count = &v
	return s
}

func (s *DescribePortViewSourceIspsResponseBodyIsps) SetIspId(v string) *DescribePortViewSourceIspsResponseBodyIsps {
	s.IspId = &v
	return s
}

type DescribePortViewSourceIspsResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribePortViewSourceIspsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribePortViewSourceIspsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePortViewSourceIspsResponse) GoString() string {
	return s.String()
}

func (s *DescribePortViewSourceIspsResponse) SetHeaders(v map[string]*string) *DescribePortViewSourceIspsResponse {
	s.Headers = v
	return s
}

func (s *DescribePortViewSourceIspsResponse) SetStatusCode(v int32) *DescribePortViewSourceIspsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePortViewSourceIspsResponse) SetBody(v *DescribePortViewSourceIspsResponseBody) *DescribePortViewSourceIspsResponse {
	s.Body = v
	return s
}

type DescribePortViewSourceProvincesRequest struct {
	// The end of the time range to query. The value is a UNIX timestamp. Unit: seconds. If you do not configure this parameter, the current system time is used as the end time.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The IDs of instances to query.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	//
	// For more information about resource groups, see [Create a resource group](~~94485~~).
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribePortViewSourceProvincesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePortViewSourceProvincesRequest) GoString() string {
	return s.String()
}

func (s *DescribePortViewSourceProvincesRequest) SetEndTime(v int64) *DescribePortViewSourceProvincesRequest {
	s.EndTime = &v
	return s
}

func (s *DescribePortViewSourceProvincesRequest) SetInstanceIds(v []*string) *DescribePortViewSourceProvincesRequest {
	s.InstanceIds = v
	return s
}

func (s *DescribePortViewSourceProvincesRequest) SetResourceGroupId(v string) *DescribePortViewSourceProvincesRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribePortViewSourceProvincesRequest) SetStartTime(v int64) *DescribePortViewSourceProvincesRequest {
	s.StartTime = &v
	return s
}

type DescribePortViewSourceProvincesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Details about the administrative region in China from which the requests are sent.
	SourceProvinces []*DescribePortViewSourceProvincesResponseBodySourceProvinces `json:"SourceProvinces,omitempty" xml:"SourceProvinces,omitempty" type:"Repeated"`
}

func (s DescribePortViewSourceProvincesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePortViewSourceProvincesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePortViewSourceProvincesResponseBody) SetRequestId(v string) *DescribePortViewSourceProvincesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribePortViewSourceProvincesResponseBody) SetSourceProvinces(v []*DescribePortViewSourceProvincesResponseBodySourceProvinces) *DescribePortViewSourceProvincesResponseBody {
	s.SourceProvinces = v
	return s
}

type DescribePortViewSourceProvincesResponseBodySourceProvinces struct {
	// The total number of requests that are sent from the ISP.
	//
	// > This parameter does not indicate the accurate number of requests. You can use this parameter to calculate the proportion of requests from different administrative regions in China.
	Count *int64 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The ID of the administrative region in China from which the requests are sent. For example, **110000** indicates Beijing, and **120000** indicates Tianjin.
	//
	// > For more information, see [Location parameters](~~167926~~).
	ProvinceId *string `json:"ProvinceId,omitempty" xml:"ProvinceId,omitempty"`
}

func (s DescribePortViewSourceProvincesResponseBodySourceProvinces) String() string {
	return tea.Prettify(s)
}

func (s DescribePortViewSourceProvincesResponseBodySourceProvinces) GoString() string {
	return s.String()
}

func (s *DescribePortViewSourceProvincesResponseBodySourceProvinces) SetCount(v int64) *DescribePortViewSourceProvincesResponseBodySourceProvinces {
	s.Count = &v
	return s
}

func (s *DescribePortViewSourceProvincesResponseBodySourceProvinces) SetProvinceId(v string) *DescribePortViewSourceProvincesResponseBodySourceProvinces {
	s.ProvinceId = &v
	return s
}

type DescribePortViewSourceProvincesResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribePortViewSourceProvincesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribePortViewSourceProvincesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePortViewSourceProvincesResponse) GoString() string {
	return s.String()
}

func (s *DescribePortViewSourceProvincesResponse) SetHeaders(v map[string]*string) *DescribePortViewSourceProvincesResponse {
	s.Headers = v
	return s
}

func (s *DescribePortViewSourceProvincesResponse) SetStatusCode(v int32) *DescribePortViewSourceProvincesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePortViewSourceProvincesResponse) SetBody(v *DescribePortViewSourceProvincesResponseBody) *DescribePortViewSourceProvincesResponse {
	s.Body = v
	return s
}

type DescribeSceneDefenseObjectsRequest struct {
	// The ID of the policy that you want to query.
	//
	// > You can call the [DescribeSceneDefensePolicies](~~159382~~) operation to query the IDs of all policies.
	PolicyId *string `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management.
	//
	// If you do not configure this parameter, the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeSceneDefenseObjectsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeSceneDefenseObjectsRequest) GoString() string {
	return s.String()
}

func (s *DescribeSceneDefenseObjectsRequest) SetPolicyId(v string) *DescribeSceneDefenseObjectsRequest {
	s.PolicyId = &v
	return s
}

func (s *DescribeSceneDefenseObjectsRequest) SetResourceGroupId(v string) *DescribeSceneDefenseObjectsRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeSceneDefenseObjectsResponseBody struct {
	// The information about the protected assets.
	Objects []*DescribeSceneDefenseObjectsResponseBodyObjects `json:"Objects,omitempty" xml:"Objects,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DescribeSceneDefenseObjectsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeSceneDefenseObjectsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSceneDefenseObjectsResponseBody) SetObjects(v []*DescribeSceneDefenseObjectsResponseBodyObjects) *DescribeSceneDefenseObjectsResponseBody {
	s.Objects = v
	return s
}

func (s *DescribeSceneDefenseObjectsResponseBody) SetRequestId(v string) *DescribeSceneDefenseObjectsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeSceneDefenseObjectsResponseBody) SetSuccess(v bool) *DescribeSceneDefenseObjectsResponseBody {
	s.Success = &v
	return s
}

type DescribeSceneDefenseObjectsResponseBodyObjects struct {
	// The domain name that is protected by the policy.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The ID of the policy.
	PolicyId *string `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
	// The IP address of the Anti-DDoS Pro or Anti-DDoS Premium instance that is protected by the policy.
	Vip *string `json:"Vip,omitempty" xml:"Vip,omitempty"`
}

func (s DescribeSceneDefenseObjectsResponseBodyObjects) String() string {
	return tea.Prettify(s)
}

func (s DescribeSceneDefenseObjectsResponseBodyObjects) GoString() string {
	return s.String()
}

func (s *DescribeSceneDefenseObjectsResponseBodyObjects) SetDomain(v string) *DescribeSceneDefenseObjectsResponseBodyObjects {
	s.Domain = &v
	return s
}

func (s *DescribeSceneDefenseObjectsResponseBodyObjects) SetPolicyId(v string) *DescribeSceneDefenseObjectsResponseBodyObjects {
	s.PolicyId = &v
	return s
}

func (s *DescribeSceneDefenseObjectsResponseBodyObjects) SetVip(v string) *DescribeSceneDefenseObjectsResponseBodyObjects {
	s.Vip = &v
	return s
}

type DescribeSceneDefenseObjectsResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeSceneDefenseObjectsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeSceneDefenseObjectsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeSceneDefenseObjectsResponse) GoString() string {
	return s.String()
}

func (s *DescribeSceneDefenseObjectsResponse) SetHeaders(v map[string]*string) *DescribeSceneDefenseObjectsResponse {
	s.Headers = v
	return s
}

func (s *DescribeSceneDefenseObjectsResponse) SetStatusCode(v int32) *DescribeSceneDefenseObjectsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSceneDefenseObjectsResponse) SetBody(v *DescribeSceneDefenseObjectsResponseBody) *DescribeSceneDefenseObjectsResponse {
	s.Body = v
	return s
}

type DescribeSceneDefensePoliciesRequest struct {
	// The ID of the resource group to which the instance belongs in Resource Management.
	//
	// If you do not configure this parameter, the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The status of the policy. Valid values:
	//
	// *   **0**: disabled
	// *   **1**: pending enabling
	// *   **2**: enabled
	// *   **3**: expired
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the template that is used to create the policy. Valid values:
	//
	// *   **promotion**: the Important Activity template
	// *   **bypass**: the Forward All template
	Template *string `json:"Template,omitempty" xml:"Template,omitempty"`
}

func (s DescribeSceneDefensePoliciesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeSceneDefensePoliciesRequest) GoString() string {
	return s.String()
}

func (s *DescribeSceneDefensePoliciesRequest) SetResourceGroupId(v string) *DescribeSceneDefensePoliciesRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeSceneDefensePoliciesRequest) SetStatus(v string) *DescribeSceneDefensePoliciesRequest {
	s.Status = &v
	return s
}

func (s *DescribeSceneDefensePoliciesRequest) SetTemplate(v string) *DescribeSceneDefensePoliciesRequest {
	s.Template = &v
	return s
}

type DescribeSceneDefensePoliciesResponseBody struct {
	// An array that consists of the configurations of the scenario-specific custom policy.
	Policies []*DescribeSceneDefensePoliciesResponseBodyPolicies `json:"Policies,omitempty" xml:"Policies,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DescribeSceneDefensePoliciesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeSceneDefensePoliciesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSceneDefensePoliciesResponseBody) SetPolicies(v []*DescribeSceneDefensePoliciesResponseBodyPolicies) *DescribeSceneDefensePoliciesResponseBody {
	s.Policies = v
	return s
}

func (s *DescribeSceneDefensePoliciesResponseBody) SetRequestId(v string) *DescribeSceneDefensePoliciesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeSceneDefensePoliciesResponseBody) SetSuccess(v bool) *DescribeSceneDefensePoliciesResponseBody {
	s.Success = &v
	return s
}

type DescribeSceneDefensePoliciesResponseBodyPolicies struct {
	// The execution status of the policy. Valid values:
	//
	// *   **1**: not executed or execution completed
	// *   **0**: being executed
	// *   **-1**: execution failed
	Done *int32 `json:"Done,omitempty" xml:"Done,omitempty"`
	// The time at which the policy expires. The value is a UNIX timestamp. Unit: milliseconds.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The name of the policy.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The number of objects that are protected by the policy.
	ObjectCount *int32 `json:"ObjectCount,omitempty" xml:"ObjectCount,omitempty"`
	// The ID of the policy.
	PolicyId *string `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
	// The running rules of the policy.
	RuntimePolicies []*DescribeSceneDefensePoliciesResponseBodyPoliciesRuntimePolicies `json:"RuntimePolicies,omitempty" xml:"RuntimePolicies,omitempty" type:"Repeated"`
	// The time at which the policy takes effect. The value is a UNIX timestamp. Unit: milliseconds.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The status of the policy. Valid values:
	//
	// *   **0**: disabled
	// *   **1**: pending enabling
	// *   **2**: enabled
	// *   **3**: expired
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the template that is used to create the policy. Valid values:
	//
	// *   **promotion**: the Important Activity template
	// *   **bypass**: the Forward All template
	Template *string `json:"Template,omitempty" xml:"Template,omitempty"`
}

func (s DescribeSceneDefensePoliciesResponseBodyPolicies) String() string {
	return tea.Prettify(s)
}

func (s DescribeSceneDefensePoliciesResponseBodyPolicies) GoString() string {
	return s.String()
}

func (s *DescribeSceneDefensePoliciesResponseBodyPolicies) SetDone(v int32) *DescribeSceneDefensePoliciesResponseBodyPolicies {
	s.Done = &v
	return s
}

func (s *DescribeSceneDefensePoliciesResponseBodyPolicies) SetEndTime(v int64) *DescribeSceneDefensePoliciesResponseBodyPolicies {
	s.EndTime = &v
	return s
}

func (s *DescribeSceneDefensePoliciesResponseBodyPolicies) SetName(v string) *DescribeSceneDefensePoliciesResponseBodyPolicies {
	s.Name = &v
	return s
}

func (s *DescribeSceneDefensePoliciesResponseBodyPolicies) SetObjectCount(v int32) *DescribeSceneDefensePoliciesResponseBodyPolicies {
	s.ObjectCount = &v
	return s
}

func (s *DescribeSceneDefensePoliciesResponseBodyPolicies) SetPolicyId(v string) *DescribeSceneDefensePoliciesResponseBodyPolicies {
	s.PolicyId = &v
	return s
}

func (s *DescribeSceneDefensePoliciesResponseBodyPolicies) SetRuntimePolicies(v []*DescribeSceneDefensePoliciesResponseBodyPoliciesRuntimePolicies) *DescribeSceneDefensePoliciesResponseBodyPolicies {
	s.RuntimePolicies = v
	return s
}

func (s *DescribeSceneDefensePoliciesResponseBodyPolicies) SetStartTime(v int64) *DescribeSceneDefensePoliciesResponseBodyPolicies {
	s.StartTime = &v
	return s
}

func (s *DescribeSceneDefensePoliciesResponseBodyPolicies) SetStatus(v int32) *DescribeSceneDefensePoliciesResponseBodyPolicies {
	s.Status = &v
	return s
}

func (s *DescribeSceneDefensePoliciesResponseBodyPolicies) SetTemplate(v string) *DescribeSceneDefensePoliciesResponseBodyPolicies {
	s.Template = &v
	return s
}

type DescribeSceneDefensePoliciesResponseBodyPoliciesRuntimePolicies struct {
	// The protection rule that is applied when the policy takes effect.
	//
	// If you set **PolicyType** to **1**, the value is **{"cc_rule_enable": false }**. The value indicates that the Frequency Control policy is disabled.
	//
	// If you set **PolicyType** to **2**, the value is **{"ai_rule_enable": 0}**. The value indicates that the Intelligent Protection policy is disabled.
	NewValue *string `json:"NewValue,omitempty" xml:"NewValue,omitempty"`
	// The protection policy whose status is changed when the policy takes effect. Valid values:
	//
	// *   **1**: indicates that the Frequency Control policy is changed.
	// *   **2**: indicates that the Intelligent Protection policy is changed.
	PolicyType *int32 `json:"PolicyType,omitempty" xml:"PolicyType,omitempty"`
	// The running status of the policy. Valid values:
	//
	// *   **0**: The policy has not been issued or is restored.
	// *   **1**: The policy is pending.
	// *   **2**: The policy is being restored.
	// *   **3**: The policy takes effect.
	// *   **4**: The policy fails to take effect.
	// *   **5**:The policy fails to be restored.
	// *   **6**: The configurations of the protected objects for the policy does not exist because the configurations may be deleted.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The protection rule that is applied before the policy takes effect.
	//
	// If you set **PolicyType** to **1**, the value is **{"cc_rule_enable": true}**. The value indicates that the Frequency Control policy is enabled.
	//
	// If you set **PolicyType** to **2**, the value is **{"ai_rule_enable": 1}**. The value indicates that the Intelligent Protection policy is enabled.
	OldValue *string `json:"oldValue,omitempty" xml:"oldValue,omitempty"`
}

func (s DescribeSceneDefensePoliciesResponseBodyPoliciesRuntimePolicies) String() string {
	return tea.Prettify(s)
}

func (s DescribeSceneDefensePoliciesResponseBodyPoliciesRuntimePolicies) GoString() string {
	return s.String()
}

func (s *DescribeSceneDefensePoliciesResponseBodyPoliciesRuntimePolicies) SetNewValue(v string) *DescribeSceneDefensePoliciesResponseBodyPoliciesRuntimePolicies {
	s.NewValue = &v
	return s
}

func (s *DescribeSceneDefensePoliciesResponseBodyPoliciesRuntimePolicies) SetPolicyType(v int32) *DescribeSceneDefensePoliciesResponseBodyPoliciesRuntimePolicies {
	s.PolicyType = &v
	return s
}

func (s *DescribeSceneDefensePoliciesResponseBodyPoliciesRuntimePolicies) SetStatus(v int32) *DescribeSceneDefensePoliciesResponseBodyPoliciesRuntimePolicies {
	s.Status = &v
	return s
}

func (s *DescribeSceneDefensePoliciesResponseBodyPoliciesRuntimePolicies) SetOldValue(v string) *DescribeSceneDefensePoliciesResponseBodyPoliciesRuntimePolicies {
	s.OldValue = &v
	return s
}

type DescribeSceneDefensePoliciesResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeSceneDefensePoliciesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeSceneDefensePoliciesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeSceneDefensePoliciesResponse) GoString() string {
	return s.String()
}

func (s *DescribeSceneDefensePoliciesResponse) SetHeaders(v map[string]*string) *DescribeSceneDefensePoliciesResponse {
	s.Headers = v
	return s
}

func (s *DescribeSceneDefensePoliciesResponse) SetStatusCode(v int32) *DescribeSceneDefensePoliciesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSceneDefensePoliciesResponse) SetBody(v *DescribeSceneDefensePoliciesResponseBody) *DescribeSceneDefensePoliciesResponse {
	s.Body = v
	return s
}

type DescribeSchedulerRulesRequest struct {
	PageNumber      *int32  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize        *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	RuleName        *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
}

func (s DescribeSchedulerRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeSchedulerRulesRequest) GoString() string {
	return s.String()
}

func (s *DescribeSchedulerRulesRequest) SetPageNumber(v int32) *DescribeSchedulerRulesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeSchedulerRulesRequest) SetPageSize(v int32) *DescribeSchedulerRulesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeSchedulerRulesRequest) SetResourceGroupId(v string) *DescribeSchedulerRulesRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeSchedulerRulesRequest) SetRuleName(v string) *DescribeSchedulerRulesRequest {
	s.RuleName = &v
	return s
}

type DescribeSchedulerRulesResponseBody struct {
	RequestId      *string                                             `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	SchedulerRules []*DescribeSchedulerRulesResponseBodySchedulerRules `json:"SchedulerRules,omitempty" xml:"SchedulerRules,omitempty" type:"Repeated"`
	TotalCount     *string                                             `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeSchedulerRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeSchedulerRulesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSchedulerRulesResponseBody) SetRequestId(v string) *DescribeSchedulerRulesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeSchedulerRulesResponseBody) SetSchedulerRules(v []*DescribeSchedulerRulesResponseBodySchedulerRules) *DescribeSchedulerRulesResponseBody {
	s.SchedulerRules = v
	return s
}

func (s *DescribeSchedulerRulesResponseBody) SetTotalCount(v string) *DescribeSchedulerRulesResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeSchedulerRulesResponseBodySchedulerRules struct {
	Cname    *string                                                  `json:"Cname,omitempty" xml:"Cname,omitempty"`
	Param    *DescribeSchedulerRulesResponseBodySchedulerRulesParam   `json:"Param,omitempty" xml:"Param,omitempty" type:"Struct"`
	RuleName *string                                                  `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	RuleType *string                                                  `json:"RuleType,omitempty" xml:"RuleType,omitempty"`
	Rules    []*DescribeSchedulerRulesResponseBodySchedulerRulesRules `json:"Rules,omitempty" xml:"Rules,omitempty" type:"Repeated"`
}

func (s DescribeSchedulerRulesResponseBodySchedulerRules) String() string {
	return tea.Prettify(s)
}

func (s DescribeSchedulerRulesResponseBodySchedulerRules) GoString() string {
	return s.String()
}

func (s *DescribeSchedulerRulesResponseBodySchedulerRules) SetCname(v string) *DescribeSchedulerRulesResponseBodySchedulerRules {
	s.Cname = &v
	return s
}

func (s *DescribeSchedulerRulesResponseBodySchedulerRules) SetParam(v *DescribeSchedulerRulesResponseBodySchedulerRulesParam) *DescribeSchedulerRulesResponseBodySchedulerRules {
	s.Param = v
	return s
}

func (s *DescribeSchedulerRulesResponseBodySchedulerRules) SetRuleName(v string) *DescribeSchedulerRulesResponseBodySchedulerRules {
	s.RuleName = &v
	return s
}

func (s *DescribeSchedulerRulesResponseBodySchedulerRules) SetRuleType(v string) *DescribeSchedulerRulesResponseBodySchedulerRules {
	s.RuleType = &v
	return s
}

func (s *DescribeSchedulerRulesResponseBodySchedulerRules) SetRules(v []*DescribeSchedulerRulesResponseBodySchedulerRulesRules) *DescribeSchedulerRulesResponseBodySchedulerRules {
	s.Rules = v
	return s
}

type DescribeSchedulerRulesResponseBodySchedulerRulesParam struct {
	ParamData *DescribeSchedulerRulesResponseBodySchedulerRulesParamParamData `json:"ParamData,omitempty" xml:"ParamData,omitempty" type:"Struct"`
	ParamType *string                                                         `json:"ParamType,omitempty" xml:"ParamType,omitempty"`
}

func (s DescribeSchedulerRulesResponseBodySchedulerRulesParam) String() string {
	return tea.Prettify(s)
}

func (s DescribeSchedulerRulesResponseBodySchedulerRulesParam) GoString() string {
	return s.String()
}

func (s *DescribeSchedulerRulesResponseBodySchedulerRulesParam) SetParamData(v *DescribeSchedulerRulesResponseBodySchedulerRulesParamParamData) *DescribeSchedulerRulesResponseBodySchedulerRulesParam {
	s.ParamData = v
	return s
}

func (s *DescribeSchedulerRulesResponseBodySchedulerRulesParam) SetParamType(v string) *DescribeSchedulerRulesResponseBodySchedulerRulesParam {
	s.ParamType = &v
	return s
}

type DescribeSchedulerRulesResponseBodySchedulerRulesParamParamData struct {
	CloudInstanceId *string `json:"CloudInstanceId,omitempty" xml:"CloudInstanceId,omitempty"`
}

func (s DescribeSchedulerRulesResponseBodySchedulerRulesParamParamData) String() string {
	return tea.Prettify(s)
}

func (s DescribeSchedulerRulesResponseBodySchedulerRulesParamParamData) GoString() string {
	return s.String()
}

func (s *DescribeSchedulerRulesResponseBodySchedulerRulesParamParamData) SetCloudInstanceId(v string) *DescribeSchedulerRulesResponseBodySchedulerRulesParamParamData {
	s.CloudInstanceId = &v
	return s
}

type DescribeSchedulerRulesResponseBodySchedulerRulesRules struct {
	Line         *string `json:"Line,omitempty" xml:"Line,omitempty"`
	Priority     *int32  `json:"Priority,omitempty" xml:"Priority,omitempty"`
	RegionId     *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	RestoreDelay *int32  `json:"RestoreDelay,omitempty" xml:"RestoreDelay,omitempty"`
	Status       *int32  `json:"Status,omitempty" xml:"Status,omitempty"`
	Type         *string `json:"Type,omitempty" xml:"Type,omitempty"`
	Value        *string `json:"Value,omitempty" xml:"Value,omitempty"`
	ValueType    *int32  `json:"ValueType,omitempty" xml:"ValueType,omitempty"`
}

func (s DescribeSchedulerRulesResponseBodySchedulerRulesRules) String() string {
	return tea.Prettify(s)
}

func (s DescribeSchedulerRulesResponseBodySchedulerRulesRules) GoString() string {
	return s.String()
}

func (s *DescribeSchedulerRulesResponseBodySchedulerRulesRules) SetLine(v string) *DescribeSchedulerRulesResponseBodySchedulerRulesRules {
	s.Line = &v
	return s
}

func (s *DescribeSchedulerRulesResponseBodySchedulerRulesRules) SetPriority(v int32) *DescribeSchedulerRulesResponseBodySchedulerRulesRules {
	s.Priority = &v
	return s
}

func (s *DescribeSchedulerRulesResponseBodySchedulerRulesRules) SetRegionId(v string) *DescribeSchedulerRulesResponseBodySchedulerRulesRules {
	s.RegionId = &v
	return s
}

func (s *DescribeSchedulerRulesResponseBodySchedulerRulesRules) SetRestoreDelay(v int32) *DescribeSchedulerRulesResponseBodySchedulerRulesRules {
	s.RestoreDelay = &v
	return s
}

func (s *DescribeSchedulerRulesResponseBodySchedulerRulesRules) SetStatus(v int32) *DescribeSchedulerRulesResponseBodySchedulerRulesRules {
	s.Status = &v
	return s
}

func (s *DescribeSchedulerRulesResponseBodySchedulerRulesRules) SetType(v string) *DescribeSchedulerRulesResponseBodySchedulerRulesRules {
	s.Type = &v
	return s
}

func (s *DescribeSchedulerRulesResponseBodySchedulerRulesRules) SetValue(v string) *DescribeSchedulerRulesResponseBodySchedulerRulesRules {
	s.Value = &v
	return s
}

func (s *DescribeSchedulerRulesResponseBodySchedulerRulesRules) SetValueType(v int32) *DescribeSchedulerRulesResponseBodySchedulerRulesRules {
	s.ValueType = &v
	return s
}

type DescribeSchedulerRulesResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeSchedulerRulesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeSchedulerRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeSchedulerRulesResponse) GoString() string {
	return s.String()
}

func (s *DescribeSchedulerRulesResponse) SetHeaders(v map[string]*string) *DescribeSchedulerRulesResponse {
	s.Headers = v
	return s
}

func (s *DescribeSchedulerRulesResponse) SetStatusCode(v int32) *DescribeSchedulerRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSchedulerRulesResponse) SetBody(v *DescribeSchedulerRulesResponseBody) *DescribeSchedulerRulesResponse {
	s.Body = v
	return s
}

type DescribeSlaEventListRequest struct {
	// The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// >  This UNIX timestamp must indicate a point in time that is accurate to the minute.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The IP address of the Anti-DDoS Pro or Anti-DDoS Premium instance.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The page number.
	Page *int64 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The number of entries per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The type of the service Valid values:
	//
	// *   **cn**: Anti-DDoS Pro
	// *   **cn-hongkong**: Anti-DDoS Premium
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// >  This UNIX timestamp must indicate a point in time that is accurate to the minute.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeSlaEventListRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeSlaEventListRequest) GoString() string {
	return s.String()
}

func (s *DescribeSlaEventListRequest) SetEndTime(v int64) *DescribeSlaEventListRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeSlaEventListRequest) SetIp(v string) *DescribeSlaEventListRequest {
	s.Ip = &v
	return s
}

func (s *DescribeSlaEventListRequest) SetPage(v int64) *DescribeSlaEventListRequest {
	s.Page = &v
	return s
}

func (s *DescribeSlaEventListRequest) SetPageSize(v int64) *DescribeSlaEventListRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeSlaEventListRequest) SetRegion(v string) *DescribeSlaEventListRequest {
	s.Region = &v
	return s
}

func (s *DescribeSlaEventListRequest) SetStartTime(v int64) *DescribeSlaEventListRequest {
	s.StartTime = &v
	return s
}

type DescribeSlaEventListResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The destination rate limit events.
	SlaEvent []*DescribeSlaEventListResponseBodySlaEvent `json:"SlaEvent,omitempty" xml:"SlaEvent,omitempty" type:"Repeated"`
	// The total number of entries returned.
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s DescribeSlaEventListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeSlaEventListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSlaEventListResponseBody) SetRequestId(v string) *DescribeSlaEventListResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeSlaEventListResponseBody) SetSlaEvent(v []*DescribeSlaEventListResponseBodySlaEvent) *DescribeSlaEventListResponseBody {
	s.SlaEvent = v
	return s
}

func (s *DescribeSlaEventListResponseBody) SetTotal(v int64) *DescribeSlaEventListResponseBody {
	s.Total = &v
	return s
}

type DescribeSlaEventListResponseBodySlaEvent struct {
	// The end of the time range. Unit: seconds.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The IP address of the instance.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The region to which the destination IP address belongs. Valid values:
	//
	// *   **cn**: a region in the Chinese mainland
	// *   **cn-hongkong**: China (Hong Kong)
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The beginning of the time range. Unit: seconds.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeSlaEventListResponseBodySlaEvent) String() string {
	return tea.Prettify(s)
}

func (s DescribeSlaEventListResponseBodySlaEvent) GoString() string {
	return s.String()
}

func (s *DescribeSlaEventListResponseBodySlaEvent) SetEndTime(v int64) *DescribeSlaEventListResponseBodySlaEvent {
	s.EndTime = &v
	return s
}

func (s *DescribeSlaEventListResponseBodySlaEvent) SetIp(v string) *DescribeSlaEventListResponseBodySlaEvent {
	s.Ip = &v
	return s
}

func (s *DescribeSlaEventListResponseBodySlaEvent) SetRegion(v string) *DescribeSlaEventListResponseBodySlaEvent {
	s.Region = &v
	return s
}

func (s *DescribeSlaEventListResponseBodySlaEvent) SetStartTime(v int64) *DescribeSlaEventListResponseBodySlaEvent {
	s.StartTime = &v
	return s
}

type DescribeSlaEventListResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeSlaEventListResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeSlaEventListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeSlaEventListResponse) GoString() string {
	return s.String()
}

func (s *DescribeSlaEventListResponse) SetHeaders(v map[string]*string) *DescribeSlaEventListResponse {
	s.Headers = v
	return s
}

func (s *DescribeSlaEventListResponse) SetStatusCode(v int32) *DescribeSlaEventListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSlaEventListResponse) SetBody(v *DescribeSlaEventListResponseBody) *DescribeSlaEventListResponse {
	s.Body = v
	return s
}

type DescribeSlsAuthStatusRequest struct {
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeSlsAuthStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeSlsAuthStatusRequest) GoString() string {
	return s.String()
}

func (s *DescribeSlsAuthStatusRequest) SetResourceGroupId(v string) *DescribeSlsAuthStatusRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeSlsAuthStatusResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether Anti-DDoS Pro or Anti-DDoS Premium is authorized to access Log Service. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	SlsAuthStatus *bool `json:"SlsAuthStatus,omitempty" xml:"SlsAuthStatus,omitempty"`
}

func (s DescribeSlsAuthStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeSlsAuthStatusResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSlsAuthStatusResponseBody) SetRequestId(v string) *DescribeSlsAuthStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeSlsAuthStatusResponseBody) SetSlsAuthStatus(v bool) *DescribeSlsAuthStatusResponseBody {
	s.SlsAuthStatus = &v
	return s
}

type DescribeSlsAuthStatusResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeSlsAuthStatusResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeSlsAuthStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeSlsAuthStatusResponse) GoString() string {
	return s.String()
}

func (s *DescribeSlsAuthStatusResponse) SetHeaders(v map[string]*string) *DescribeSlsAuthStatusResponse {
	s.Headers = v
	return s
}

func (s *DescribeSlsAuthStatusResponse) SetStatusCode(v int32) *DescribeSlsAuthStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSlsAuthStatusResponse) SetBody(v *DescribeSlsAuthStatusResponseBody) *DescribeSlsAuthStatusResponse {
	s.Body = v
	return s
}

type DescribeSlsLogstoreInfoRequest struct {
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeSlsLogstoreInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeSlsLogstoreInfoRequest) GoString() string {
	return s.String()
}

func (s *DescribeSlsLogstoreInfoRequest) SetResourceGroupId(v string) *DescribeSlsLogstoreInfoRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeSlsLogstoreInfoResponseBody struct {
	// The Logstore of the Anti-DDoS Pro or Anti-DDoS Premium instance.
	LogStore *string `json:"LogStore,omitempty" xml:"LogStore,omitempty"`
	// The Logstore project of the Anti-DDoS Pro or Anti-DDoS Premium instance.
	Project *string `json:"Project,omitempty" xml:"Project,omitempty"`
	// The available log storage capacity. Unit: bytes.
	Quota *int64 `json:"Quota,omitempty" xml:"Quota,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The log storage duration. Unit: days.
	Ttl *int32 `json:"Ttl,omitempty" xml:"Ttl,omitempty"`
	// The used log storage capacity. Unit: bytes.
	//
	// > The statistics on Log Service are delayed for about two hours.
	Used *int64 `json:"Used,omitempty" xml:"Used,omitempty"`
}

func (s DescribeSlsLogstoreInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeSlsLogstoreInfoResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSlsLogstoreInfoResponseBody) SetLogStore(v string) *DescribeSlsLogstoreInfoResponseBody {
	s.LogStore = &v
	return s
}

func (s *DescribeSlsLogstoreInfoResponseBody) SetProject(v string) *DescribeSlsLogstoreInfoResponseBody {
	s.Project = &v
	return s
}

func (s *DescribeSlsLogstoreInfoResponseBody) SetQuota(v int64) *DescribeSlsLogstoreInfoResponseBody {
	s.Quota = &v
	return s
}

func (s *DescribeSlsLogstoreInfoResponseBody) SetRequestId(v string) *DescribeSlsLogstoreInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeSlsLogstoreInfoResponseBody) SetTtl(v int32) *DescribeSlsLogstoreInfoResponseBody {
	s.Ttl = &v
	return s
}

func (s *DescribeSlsLogstoreInfoResponseBody) SetUsed(v int64) *DescribeSlsLogstoreInfoResponseBody {
	s.Used = &v
	return s
}

type DescribeSlsLogstoreInfoResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeSlsLogstoreInfoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeSlsLogstoreInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeSlsLogstoreInfoResponse) GoString() string {
	return s.String()
}

func (s *DescribeSlsLogstoreInfoResponse) SetHeaders(v map[string]*string) *DescribeSlsLogstoreInfoResponse {
	s.Headers = v
	return s
}

func (s *DescribeSlsLogstoreInfoResponse) SetStatusCode(v int32) *DescribeSlsLogstoreInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSlsLogstoreInfoResponse) SetBody(v *DescribeSlsLogstoreInfoResponseBody) *DescribeSlsLogstoreInfoResponse {
	s.Body = v
	return s
}

type DescribeSlsOpenStatusRequest struct {
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeSlsOpenStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeSlsOpenStatusRequest) GoString() string {
	return s.String()
}

func (s *DescribeSlsOpenStatusRequest) SetResourceGroupId(v string) *DescribeSlsOpenStatusRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeSlsOpenStatusResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether Log Service is activated. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	SlsOpenStatus *bool `json:"SlsOpenStatus,omitempty" xml:"SlsOpenStatus,omitempty"`
}

func (s DescribeSlsOpenStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeSlsOpenStatusResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSlsOpenStatusResponseBody) SetRequestId(v string) *DescribeSlsOpenStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeSlsOpenStatusResponseBody) SetSlsOpenStatus(v bool) *DescribeSlsOpenStatusResponseBody {
	s.SlsOpenStatus = &v
	return s
}

type DescribeSlsOpenStatusResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeSlsOpenStatusResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeSlsOpenStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeSlsOpenStatusResponse) GoString() string {
	return s.String()
}

func (s *DescribeSlsOpenStatusResponse) SetHeaders(v map[string]*string) *DescribeSlsOpenStatusResponse {
	s.Headers = v
	return s
}

func (s *DescribeSlsOpenStatusResponse) SetStatusCode(v int32) *DescribeSlsOpenStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSlsOpenStatusResponse) SetBody(v *DescribeSlsOpenStatusResponseBody) *DescribeSlsOpenStatusResponse {
	s.Body = v
	return s
}

type DescribeStsGrantStatusRequest struct {
	// The ID of the resource group to which the instance belongs in Resource Management.
	//
	// If you do not configure this parameter, the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The name of the RAM role to query. Set the value to **AliyunDDoSCOODefaultRole**, which indicates the default role of Anti-DDoS Pro or Anti-DDoS Premium.
	//
	// > Anti-DDoS Pro or Anti-DDoS Premium uses the default role to access other cloud services.
	Role *string `json:"Role,omitempty" xml:"Role,omitempty"`
}

func (s DescribeStsGrantStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeStsGrantStatusRequest) GoString() string {
	return s.String()
}

func (s *DescribeStsGrantStatusRequest) SetResourceGroupId(v string) *DescribeStsGrantStatusRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeStsGrantStatusRequest) SetRole(v string) *DescribeStsGrantStatusRequest {
	s.Role = &v
	return s
}

type DescribeStsGrantStatusResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The authorization status of Anti-DDoS Pro or Anti-DDoS Premium.
	StsGrant *DescribeStsGrantStatusResponseBodyStsGrant `json:"StsGrant,omitempty" xml:"StsGrant,omitempty" type:"Struct"`
}

func (s DescribeStsGrantStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeStsGrantStatusResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeStsGrantStatusResponseBody) SetRequestId(v string) *DescribeStsGrantStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeStsGrantStatusResponseBody) SetStsGrant(v *DescribeStsGrantStatusResponseBodyStsGrant) *DescribeStsGrantStatusResponseBody {
	s.StsGrant = v
	return s
}

type DescribeStsGrantStatusResponseBodyStsGrant struct {
	// The authorization status. Valid values:
	//
	// *   **0**: Anti-DDoS Pro or Anti-DDoS Premium is not authorized to access other cloud services.
	// *   **1**: Anti-DDoS Pro or Anti-DDoS Premium is authorized to access other cloud services.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeStsGrantStatusResponseBodyStsGrant) String() string {
	return tea.Prettify(s)
}

func (s DescribeStsGrantStatusResponseBodyStsGrant) GoString() string {
	return s.String()
}

func (s *DescribeStsGrantStatusResponseBodyStsGrant) SetStatus(v int32) *DescribeStsGrantStatusResponseBodyStsGrant {
	s.Status = &v
	return s
}

type DescribeStsGrantStatusResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeStsGrantStatusResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeStsGrantStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeStsGrantStatusResponse) GoString() string {
	return s.String()
}

func (s *DescribeStsGrantStatusResponse) SetHeaders(v map[string]*string) *DescribeStsGrantStatusResponse {
	s.Headers = v
	return s
}

func (s *DescribeStsGrantStatusResponse) SetStatusCode(v int32) *DescribeStsGrantStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeStsGrantStatusResponse) SetBody(v *DescribeStsGrantStatusResponseBody) *DescribeStsGrantStatusResponse {
	s.Body = v
	return s
}

type DescribeSystemLogRequest struct {
	// The end of the time range to query. The bills of the burstable clean bandwidth that are issued before this point in time are queried. The value is a UNIX timestamp. Unit: milliseconds.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The IP address of the instance.
	//
	// > You can call the [DescribeInstanceDetails](~~91490~~) operation to query the IP addresses of all instances.
	EntityObject *string `json:"EntityObject,omitempty" xml:"EntityObject,omitempty"`
	// The type of the system log. Set the value to **20**, which indicates the billing logs for the burstable clean bandwidth.
	//
	// > You must specify this parameter. Otherwise, the call fails.
	EntityType *int32 `json:"EntityType,omitempty" xml:"EntityType,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The beginning of the time range to query. The bills of the burstable clean bandwidth that are issued after this point in time are queried. The value is a UNIX timestamp. Unit: milliseconds.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeSystemLogRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeSystemLogRequest) GoString() string {
	return s.String()
}

func (s *DescribeSystemLogRequest) SetEndTime(v int64) *DescribeSystemLogRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeSystemLogRequest) SetEntityObject(v string) *DescribeSystemLogRequest {
	s.EntityObject = &v
	return s
}

func (s *DescribeSystemLogRequest) SetEntityType(v int32) *DescribeSystemLogRequest {
	s.EntityType = &v
	return s
}

func (s *DescribeSystemLogRequest) SetPageNumber(v int32) *DescribeSystemLogRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeSystemLogRequest) SetPageSize(v int32) *DescribeSystemLogRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeSystemLogRequest) SetStartTime(v int64) *DescribeSystemLogRequest {
	s.StartTime = &v
	return s
}

type DescribeSystemLogResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// An array that consists of details of the billing logs for the burstable clean bandwidth.
	SystemLog []*DescribeSystemLogResponseBodySystemLog `json:"SystemLog,omitempty" xml:"SystemLog,omitempty" type:"Repeated"`
	// The total number of billing logs for the burstable clean bandwidth.
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s DescribeSystemLogResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeSystemLogResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeSystemLogResponseBody) SetRequestId(v string) *DescribeSystemLogResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeSystemLogResponseBody) SetSystemLog(v []*DescribeSystemLogResponseBodySystemLog) *DescribeSystemLogResponseBody {
	s.SystemLog = v
	return s
}

func (s *DescribeSystemLogResponseBody) SetTotal(v int64) *DescribeSystemLogResponseBody {
	s.Total = &v
	return s
}

type DescribeSystemLogResponseBodySystemLog struct {
	// The IP address of the instance.
	EntityObject *string `json:"EntityObject,omitempty" xml:"EntityObject,omitempty"`
	// The type of the system log. The value is fixed as **20**, which indicates the billing logs for burstable clean bandwidth.
	EntityType *int32 `json:"EntityType,omitempty" xml:"EntityType,omitempty"`
	// The time when the bill was generated. The value is a UNIX timestamp. Unit: milliseconds.
	GmtCreate *int64 `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The time when the bill was last modified. The value is a UNIX timestamp. Unit: milliseconds.
	GmtModified *int64 `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the Alibaba Cloud account to which the bill belongs.
	OpAccount *string `json:"OpAccount,omitempty" xml:"OpAccount,omitempty"`
	// The operation type. The value is fixed as **100**, which indicates the billing logs for the burstable clean bandwidth that you increased.
	OpAction *int32 `json:"OpAction,omitempty" xml:"OpAction,omitempty"`
	// The details of the bill. The value is a string that consists of a JSON struct. The JSON struct contains the following fields:
	//
	// *   **newEntity**: the bill record, which contains the following fields. Data type: object.
	//
	//     *   **billValue**: the usage of the burstable clean bandwidth within a month. Unit: Mbit/s. Data type: integer.
	//     *   **instanceId**: the ID of the instance. Data type: string.
	//     *   **ip**: the IP address of the instance. Data type: string.
	//     *   **maxBw**: the peak service traffic (monthly 95th percentile bandwidth) within a month. Unit: Mbit/s. Data type: string.
	//     *   **month**: the month in which the bill of the previous calendar month is issued. This value is a UNIX timestamp. Unit: milliseconds. Data type: long.
	//     *   **overBandwidth**: the peak service traffic minus the clean bandwidth of the instance. Unit: Mbit/s. Data type: integer.
	//     *   **peakTime**: the time in point of the peak service traffic that is measured for billing. This value is a UNIX timestamp. Unit: seconds. Data type: long.
	//     *   **startTimestamp**: the beginning of the time range for the peak service traffic range. This value is a UNIX timestamp. Unit: seconds. Data type: long.
	OpDesc *string `json:"OpDesc,omitempty" xml:"OpDesc,omitempty"`
	// The status of the bill. Valid values:
	//
	// *   **0**: to be billed
	// *   **1**: billed
	// *   **2**: terminated
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeSystemLogResponseBodySystemLog) String() string {
	return tea.Prettify(s)
}

func (s DescribeSystemLogResponseBodySystemLog) GoString() string {
	return s.String()
}

func (s *DescribeSystemLogResponseBodySystemLog) SetEntityObject(v string) *DescribeSystemLogResponseBodySystemLog {
	s.EntityObject = &v
	return s
}

func (s *DescribeSystemLogResponseBodySystemLog) SetEntityType(v int32) *DescribeSystemLogResponseBodySystemLog {
	s.EntityType = &v
	return s
}

func (s *DescribeSystemLogResponseBodySystemLog) SetGmtCreate(v int64) *DescribeSystemLogResponseBodySystemLog {
	s.GmtCreate = &v
	return s
}

func (s *DescribeSystemLogResponseBodySystemLog) SetGmtModified(v int64) *DescribeSystemLogResponseBodySystemLog {
	s.GmtModified = &v
	return s
}

func (s *DescribeSystemLogResponseBodySystemLog) SetOpAccount(v string) *DescribeSystemLogResponseBodySystemLog {
	s.OpAccount = &v
	return s
}

func (s *DescribeSystemLogResponseBodySystemLog) SetOpAction(v int32) *DescribeSystemLogResponseBodySystemLog {
	s.OpAction = &v
	return s
}

func (s *DescribeSystemLogResponseBodySystemLog) SetOpDesc(v string) *DescribeSystemLogResponseBodySystemLog {
	s.OpDesc = &v
	return s
}

func (s *DescribeSystemLogResponseBodySystemLog) SetStatus(v int32) *DescribeSystemLogResponseBodySystemLog {
	s.Status = &v
	return s
}

type DescribeSystemLogResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeSystemLogResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeSystemLogResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeSystemLogResponse) GoString() string {
	return s.String()
}

func (s *DescribeSystemLogResponse) SetHeaders(v map[string]*string) *DescribeSystemLogResponse {
	s.Headers = v
	return s
}

func (s *DescribeSystemLogResponse) SetStatusCode(v int32) *DescribeSystemLogResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeSystemLogResponse) SetBody(v *DescribeSystemLogResponseBody) *DescribeSystemLogResponse {
	s.Body = v
	return s
}

type DescribeTagKeysRequest struct {
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the instance. Set the value to **cn-hangzhou**, which indicates an Anti-DDoS Pro instance in the Chinese mainland.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management.
	//
	// If you do not configure this parameter, the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The type of the resource to which the tag belongs. Set the value to **INSTANCE**, which indicates an Anti-DDoS Pro instance.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s DescribeTagKeysRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagKeysRequest) GoString() string {
	return s.String()
}

func (s *DescribeTagKeysRequest) SetPageNumber(v int32) *DescribeTagKeysRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeTagKeysRequest) SetPageSize(v int32) *DescribeTagKeysRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeTagKeysRequest) SetRegionId(v string) *DescribeTagKeysRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeTagKeysRequest) SetResourceGroupId(v string) *DescribeTagKeysRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeTagKeysRequest) SetResourceType(v string) *DescribeTagKeysRequest {
	s.ResourceType = &v
	return s
}

type DescribeTagKeysResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// An array that consists of the details of the tag key.
	TagKeys []*DescribeTagKeysResponseBodyTagKeys `json:"TagKeys,omitempty" xml:"TagKeys,omitempty" type:"Repeated"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeTagKeysResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagKeysResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeTagKeysResponseBody) SetPageNumber(v int32) *DescribeTagKeysResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeTagKeysResponseBody) SetPageSize(v int32) *DescribeTagKeysResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeTagKeysResponseBody) SetRequestId(v string) *DescribeTagKeysResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeTagKeysResponseBody) SetTagKeys(v []*DescribeTagKeysResponseBodyTagKeys) *DescribeTagKeysResponseBody {
	s.TagKeys = v
	return s
}

func (s *DescribeTagKeysResponseBody) SetTotalCount(v int32) *DescribeTagKeysResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeTagKeysResponseBodyTagKeys struct {
	// The number of Anti-DDoS Pro instances to which the tag key is added.
	TagCount *int32 `json:"TagCount,omitempty" xml:"TagCount,omitempty"`
	// The tag key.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
}

func (s DescribeTagKeysResponseBodyTagKeys) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagKeysResponseBodyTagKeys) GoString() string {
	return s.String()
}

func (s *DescribeTagKeysResponseBodyTagKeys) SetTagCount(v int32) *DescribeTagKeysResponseBodyTagKeys {
	s.TagCount = &v
	return s
}

func (s *DescribeTagKeysResponseBodyTagKeys) SetTagKey(v string) *DescribeTagKeysResponseBodyTagKeys {
	s.TagKey = &v
	return s
}

type DescribeTagKeysResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeTagKeysResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeTagKeysResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagKeysResponse) GoString() string {
	return s.String()
}

func (s *DescribeTagKeysResponse) SetHeaders(v map[string]*string) *DescribeTagKeysResponse {
	s.Headers = v
	return s
}

func (s *DescribeTagKeysResponse) SetStatusCode(v int32) *DescribeTagKeysResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeTagKeysResponse) SetBody(v *DescribeTagKeysResponseBody) *DescribeTagKeysResponse {
	s.Body = v
	return s
}

type DescribeTagResourcesRequest struct {
	// The query token. Set the value to the value of **NextToken** that is returned in the last call.
	//
	// > You do not need to configure this parameter if you call this operation for the first time.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The region ID of the instance. Set the value to **cn-hangzhou**, which indicates an Anti-DDoS Pro instance in the Chinese mainland.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management.
	//
	// If you do not configure this parameter, the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// An array consisting of IDs of the Anti-DDoS Pro instances that you want to query.
	ResourceIds []*string `json:"ResourceIds,omitempty" xml:"ResourceIds,omitempty" type:"Repeated"`
	// The type of the resource to which the tag belongs. Set the value to **INSTANCE**, which indicates an Anti-DDoS Pro instance.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// An array consisting of tags that you want to query. Each tag consists of a tag **key** and a tag **value**.
	Tags []*DescribeTagResourcesRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s DescribeTagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagResourcesRequest) GoString() string {
	return s.String()
}

func (s *DescribeTagResourcesRequest) SetNextToken(v string) *DescribeTagResourcesRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeTagResourcesRequest) SetRegionId(v string) *DescribeTagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeTagResourcesRequest) SetResourceGroupId(v string) *DescribeTagResourcesRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeTagResourcesRequest) SetResourceIds(v []*string) *DescribeTagResourcesRequest {
	s.ResourceIds = v
	return s
}

func (s *DescribeTagResourcesRequest) SetResourceType(v string) *DescribeTagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *DescribeTagResourcesRequest) SetTags(v []*DescribeTagResourcesRequestTags) *DescribeTagResourcesRequest {
	s.Tags = v
	return s
}

type DescribeTagResourcesRequestTags struct {
	// The key of the tag that you want to query.
	//
	// >
	//
	// *   You must specify at least one of the **ResourceIds.N** and **Tags.N.Key** parameters.
	//
	// *   You can call the [DescribeTagKeys](~~159785~~) operation to query all tag keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag that you want to query.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeTagResourcesRequestTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagResourcesRequestTags) GoString() string {
	return s.String()
}

func (s *DescribeTagResourcesRequestTags) SetKey(v string) *DescribeTagResourcesRequestTags {
	s.Key = &v
	return s
}

func (s *DescribeTagResourcesRequestTags) SetValue(v string) *DescribeTagResourcesRequestTags {
	s.Value = &v
	return s
}

type DescribeTagResourcesResponseBody struct {
	// The query token that is returned in this call.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// An array consisting of the details of the tags that are added to the Anti-DDoS Pro instance.
	TagResources *DescribeTagResourcesResponseBodyTagResources `json:"TagResources,omitempty" xml:"TagResources,omitempty" type:"Struct"`
}

func (s DescribeTagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeTagResourcesResponseBody) SetNextToken(v string) *DescribeTagResourcesResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeTagResourcesResponseBody) SetRequestId(v string) *DescribeTagResourcesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeTagResourcesResponseBody) SetTagResources(v *DescribeTagResourcesResponseBodyTagResources) *DescribeTagResourcesResponseBody {
	s.TagResources = v
	return s
}

type DescribeTagResourcesResponseBodyTagResources struct {
	TagResource []*DescribeTagResourcesResponseBodyTagResourcesTagResource `json:"TagResource,omitempty" xml:"TagResource,omitempty" type:"Repeated"`
}

func (s DescribeTagResourcesResponseBodyTagResources) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagResourcesResponseBodyTagResources) GoString() string {
	return s.String()
}

func (s *DescribeTagResourcesResponseBodyTagResources) SetTagResource(v []*DescribeTagResourcesResponseBodyTagResourcesTagResource) *DescribeTagResourcesResponseBodyTagResources {
	s.TagResource = v
	return s
}

type DescribeTagResourcesResponseBodyTagResourcesTagResource struct {
	// The ID of the Anti-DDoS Pro instance.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of the resource. The value is fixed as **INSTANCE**, which indicates an Anti-DDoS Pro instance.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The key of the tag that is added to the Anti-DDoS Pro instance.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The value of the tag that is added to the Anti-DDoS Pro instance.
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s DescribeTagResourcesResponseBodyTagResourcesTagResource) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagResourcesResponseBodyTagResourcesTagResource) GoString() string {
	return s.String()
}

func (s *DescribeTagResourcesResponseBodyTagResourcesTagResource) SetResourceId(v string) *DescribeTagResourcesResponseBodyTagResourcesTagResource {
	s.ResourceId = &v
	return s
}

func (s *DescribeTagResourcesResponseBodyTagResourcesTagResource) SetResourceType(v string) *DescribeTagResourcesResponseBodyTagResourcesTagResource {
	s.ResourceType = &v
	return s
}

func (s *DescribeTagResourcesResponseBodyTagResourcesTagResource) SetTagKey(v string) *DescribeTagResourcesResponseBodyTagResourcesTagResource {
	s.TagKey = &v
	return s
}

func (s *DescribeTagResourcesResponseBodyTagResourcesTagResource) SetTagValue(v string) *DescribeTagResourcesResponseBodyTagResourcesTagResource {
	s.TagValue = &v
	return s
}

type DescribeTagResourcesResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeTagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeTagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagResourcesResponse) GoString() string {
	return s.String()
}

func (s *DescribeTagResourcesResponse) SetHeaders(v map[string]*string) *DescribeTagResourcesResponse {
	s.Headers = v
	return s
}

func (s *DescribeTagResourcesResponse) SetStatusCode(v int32) *DescribeTagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeTagResourcesResponse) SetBody(v *DescribeTagResourcesResponseBody) *DescribeTagResourcesResponse {
	s.Body = v
	return s
}

type DescribeTotalAttackMaxFlowRequest struct {
	// The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The IDs of the instances. Separate multiple instance IDs with commas (,). Example: InstanceIds.1, InstanceIds.2, InstanceIds.3.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	// The ID of the resource group to which the instance belongs in Resource Management. If you do not configure this parameter, the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.
	//
	// > This UNIX timestamp must indicate a point in time that is accurate to the minute.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeTotalAttackMaxFlowRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeTotalAttackMaxFlowRequest) GoString() string {
	return s.String()
}

func (s *DescribeTotalAttackMaxFlowRequest) SetEndTime(v int64) *DescribeTotalAttackMaxFlowRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeTotalAttackMaxFlowRequest) SetInstanceIds(v []*string) *DescribeTotalAttackMaxFlowRequest {
	s.InstanceIds = v
	return s
}

func (s *DescribeTotalAttackMaxFlowRequest) SetResourceGroupId(v string) *DescribeTotalAttackMaxFlowRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeTotalAttackMaxFlowRequest) SetStartTime(v int64) *DescribeTotalAttackMaxFlowRequest {
	s.StartTime = &v
	return s
}

type DescribeTotalAttackMaxFlowResponseBody struct {
	// The peak bandwidth of attack traffic. Unit: bit/s.
	Bps *int64 `json:"Bps,omitempty" xml:"Bps,omitempty"`
	// The peak packet rate of attack traffic . Unit: packets per second (pps).
	Pps *int64 `json:"Pps,omitempty" xml:"Pps,omitempty"`
	// The ID of the request, which is used to locate and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeTotalAttackMaxFlowResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeTotalAttackMaxFlowResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeTotalAttackMaxFlowResponseBody) SetBps(v int64) *DescribeTotalAttackMaxFlowResponseBody {
	s.Bps = &v
	return s
}

func (s *DescribeTotalAttackMaxFlowResponseBody) SetPps(v int64) *DescribeTotalAttackMaxFlowResponseBody {
	s.Pps = &v
	return s
}

func (s *DescribeTotalAttackMaxFlowResponseBody) SetRequestId(v string) *DescribeTotalAttackMaxFlowResponseBody {
	s.RequestId = &v
	return s
}

type DescribeTotalAttackMaxFlowResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeTotalAttackMaxFlowResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeTotalAttackMaxFlowResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeTotalAttackMaxFlowResponse) GoString() string {
	return s.String()
}

func (s *DescribeTotalAttackMaxFlowResponse) SetHeaders(v map[string]*string) *DescribeTotalAttackMaxFlowResponse {
	s.Headers = v
	return s
}

func (s *DescribeTotalAttackMaxFlowResponse) SetStatusCode(v int32) *DescribeTotalAttackMaxFlowResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeTotalAttackMaxFlowResponse) SetBody(v *DescribeTotalAttackMaxFlowResponseBody) *DescribeTotalAttackMaxFlowResponse {
	s.Body = v
	return s
}

type DescribeUdpReflectRequest struct {
	// The ID of the instance to query.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The region ID of the instance. Valid values:
	//
	// *   **cn-hangzhou**: Chinese mainland, which indicates an Anti-DDoS Pro instance. This is the default value.
	// *   **ap-southeast-1**: outside the Chinese mainland, which indicates an Anti-DDoS Premium instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeUdpReflectRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeUdpReflectRequest) GoString() string {
	return s.String()
}

func (s *DescribeUdpReflectRequest) SetInstanceId(v string) *DescribeUdpReflectRequest {
	s.InstanceId = &v
	return s
}

func (s *DescribeUdpReflectRequest) SetRegionId(v string) *DescribeUdpReflectRequest {
	s.RegionId = &v
	return s
}

type DescribeUdpReflectResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// An array consisting of the source ports of the UDP traffic that are filtered out by the filtering policies for UDP reflection attacks.
	UdpSports []*string `json:"UdpSports,omitempty" xml:"UdpSports,omitempty" type:"Repeated"`
}

func (s DescribeUdpReflectResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeUdpReflectResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeUdpReflectResponseBody) SetRequestId(v string) *DescribeUdpReflectResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeUdpReflectResponseBody) SetUdpSports(v []*string) *DescribeUdpReflectResponseBody {
	s.UdpSports = v
	return s
}

type DescribeUdpReflectResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeUdpReflectResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeUdpReflectResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeUdpReflectResponse) GoString() string {
	return s.String()
}

func (s *DescribeUdpReflectResponse) SetHeaders(v map[string]*string) *DescribeUdpReflectResponse {
	s.Headers = v
	return s
}

func (s *DescribeUdpReflectResponse) SetStatusCode(v int32) *DescribeUdpReflectResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeUdpReflectResponse) SetBody(v *DescribeUdpReflectResponseBody) *DescribeUdpReflectResponse {
	s.Body = v
	return s
}

type DescribeUnBlackholeCountRequest struct {
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeUnBlackholeCountRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeUnBlackholeCountRequest) GoString() string {
	return s.String()
}

func (s *DescribeUnBlackholeCountRequest) SetResourceGroupId(v string) *DescribeUnBlackholeCountRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeUnBlackholeCountResponseBody struct {
	// The remaining quota that you can deactivate blackhole filtering.
	RemainCount *int32 `json:"RemainCount,omitempty" xml:"RemainCount,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total quota that you can deactivate blackhole filtering.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeUnBlackholeCountResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeUnBlackholeCountResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeUnBlackholeCountResponseBody) SetRemainCount(v int32) *DescribeUnBlackholeCountResponseBody {
	s.RemainCount = &v
	return s
}

func (s *DescribeUnBlackholeCountResponseBody) SetRequestId(v string) *DescribeUnBlackholeCountResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeUnBlackholeCountResponseBody) SetTotalCount(v int32) *DescribeUnBlackholeCountResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeUnBlackholeCountResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeUnBlackholeCountResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeUnBlackholeCountResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeUnBlackholeCountResponse) GoString() string {
	return s.String()
}

func (s *DescribeUnBlackholeCountResponse) SetHeaders(v map[string]*string) *DescribeUnBlackholeCountResponse {
	s.Headers = v
	return s
}

func (s *DescribeUnBlackholeCountResponse) SetStatusCode(v int32) *DescribeUnBlackholeCountResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeUnBlackholeCountResponse) SetBody(v *DescribeUnBlackholeCountResponseBody) *DescribeUnBlackholeCountResponse {
	s.Body = v
	return s
}

type DescribeUnBlockCountRequest struct {
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeUnBlockCountRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeUnBlockCountRequest) GoString() string {
	return s.String()
}

func (s *DescribeUnBlockCountRequest) SetResourceGroupId(v string) *DescribeUnBlockCountRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeUnBlockCountResponseBody struct {
	// The remaining quota that you can use the Diversion from Origin Server policy.
	RemainCount *int32 `json:"RemainCount,omitempty" xml:"RemainCount,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total quota that you can use the Diversion from Origin Server policy.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeUnBlockCountResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeUnBlockCountResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeUnBlockCountResponseBody) SetRemainCount(v int32) *DescribeUnBlockCountResponseBody {
	s.RemainCount = &v
	return s
}

func (s *DescribeUnBlockCountResponseBody) SetRequestId(v string) *DescribeUnBlockCountResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeUnBlockCountResponseBody) SetTotalCount(v int32) *DescribeUnBlockCountResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeUnBlockCountResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeUnBlockCountResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeUnBlockCountResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeUnBlockCountResponse) GoString() string {
	return s.String()
}

func (s *DescribeUnBlockCountResponse) SetHeaders(v map[string]*string) *DescribeUnBlockCountResponse {
	s.Headers = v
	return s
}

func (s *DescribeUnBlockCountResponse) SetStatusCode(v int32) *DescribeUnBlockCountResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeUnBlockCountResponse) SetBody(v *DescribeUnBlockCountResponseBody) *DescribeUnBlockCountResponse {
	s.Body = v
	return s
}

type DescribeWebAccessLogDispatchStatusRequest struct {
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management.
	//
	// If you do not configure this parameter, the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeWebAccessLogDispatchStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebAccessLogDispatchStatusRequest) GoString() string {
	return s.String()
}

func (s *DescribeWebAccessLogDispatchStatusRequest) SetPageNumber(v int32) *DescribeWebAccessLogDispatchStatusRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeWebAccessLogDispatchStatusRequest) SetPageSize(v int32) *DescribeWebAccessLogDispatchStatusRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeWebAccessLogDispatchStatusRequest) SetResourceGroupId(v string) *DescribeWebAccessLogDispatchStatusRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeWebAccessLogDispatchStatusResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the log analysis feature is enabled for domain names.
	SlsConfigStatus []*DescribeWebAccessLogDispatchStatusResponseBodySlsConfigStatus `json:"SlsConfigStatus,omitempty" xml:"SlsConfigStatus,omitempty" type:"Repeated"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeWebAccessLogDispatchStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebAccessLogDispatchStatusResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeWebAccessLogDispatchStatusResponseBody) SetRequestId(v string) *DescribeWebAccessLogDispatchStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeWebAccessLogDispatchStatusResponseBody) SetSlsConfigStatus(v []*DescribeWebAccessLogDispatchStatusResponseBodySlsConfigStatus) *DescribeWebAccessLogDispatchStatusResponseBody {
	s.SlsConfigStatus = v
	return s
}

func (s *DescribeWebAccessLogDispatchStatusResponseBody) SetTotalCount(v int32) *DescribeWebAccessLogDispatchStatusResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeWebAccessLogDispatchStatusResponseBodySlsConfigStatus struct {
	// The domain name.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// Indicates whether the log analysis feature is enabled. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
}

func (s DescribeWebAccessLogDispatchStatusResponseBodySlsConfigStatus) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebAccessLogDispatchStatusResponseBodySlsConfigStatus) GoString() string {
	return s.String()
}

func (s *DescribeWebAccessLogDispatchStatusResponseBodySlsConfigStatus) SetDomain(v string) *DescribeWebAccessLogDispatchStatusResponseBodySlsConfigStatus {
	s.Domain = &v
	return s
}

func (s *DescribeWebAccessLogDispatchStatusResponseBodySlsConfigStatus) SetEnable(v bool) *DescribeWebAccessLogDispatchStatusResponseBodySlsConfigStatus {
	s.Enable = &v
	return s
}

type DescribeWebAccessLogDispatchStatusResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeWebAccessLogDispatchStatusResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeWebAccessLogDispatchStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebAccessLogDispatchStatusResponse) GoString() string {
	return s.String()
}

func (s *DescribeWebAccessLogDispatchStatusResponse) SetHeaders(v map[string]*string) *DescribeWebAccessLogDispatchStatusResponse {
	s.Headers = v
	return s
}

func (s *DescribeWebAccessLogDispatchStatusResponse) SetStatusCode(v int32) *DescribeWebAccessLogDispatchStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeWebAccessLogDispatchStatusResponse) SetBody(v *DescribeWebAccessLogDispatchStatusResponseBody) *DescribeWebAccessLogDispatchStatusResponse {
	s.Body = v
	return s
}

type DescribeWebAccessLogEmptyCountRequest struct {
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeWebAccessLogEmptyCountRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebAccessLogEmptyCountRequest) GoString() string {
	return s.String()
}

func (s *DescribeWebAccessLogEmptyCountRequest) SetResourceGroupId(v string) *DescribeWebAccessLogEmptyCountRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeWebAccessLogEmptyCountResponseBody struct {
	// The remaining quota that you can clear the Logstore.
	AvailableCount *int32 `json:"AvailableCount,omitempty" xml:"AvailableCount,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeWebAccessLogEmptyCountResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebAccessLogEmptyCountResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeWebAccessLogEmptyCountResponseBody) SetAvailableCount(v int32) *DescribeWebAccessLogEmptyCountResponseBody {
	s.AvailableCount = &v
	return s
}

func (s *DescribeWebAccessLogEmptyCountResponseBody) SetRequestId(v string) *DescribeWebAccessLogEmptyCountResponseBody {
	s.RequestId = &v
	return s
}

type DescribeWebAccessLogEmptyCountResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeWebAccessLogEmptyCountResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeWebAccessLogEmptyCountResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebAccessLogEmptyCountResponse) GoString() string {
	return s.String()
}

func (s *DescribeWebAccessLogEmptyCountResponse) SetHeaders(v map[string]*string) *DescribeWebAccessLogEmptyCountResponse {
	s.Headers = v
	return s
}

func (s *DescribeWebAccessLogEmptyCountResponse) SetStatusCode(v int32) *DescribeWebAccessLogEmptyCountResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeWebAccessLogEmptyCountResponse) SetBody(v *DescribeWebAccessLogEmptyCountResponseBody) *DescribeWebAccessLogEmptyCountResponse {
	s.Body = v
	return s
}

type DescribeWebAccessLogStatusRequest struct {
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeWebAccessLogStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebAccessLogStatusRequest) GoString() string {
	return s.String()
}

func (s *DescribeWebAccessLogStatusRequest) SetDomain(v string) *DescribeWebAccessLogStatusRequest {
	s.Domain = &v
	return s
}

func (s *DescribeWebAccessLogStatusRequest) SetResourceGroupId(v string) *DescribeWebAccessLogStatusRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeWebAccessLogStatusResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The Logstore of the instance.
	SlsLogstore *string `json:"SlsLogstore,omitempty" xml:"SlsLogstore,omitempty"`
	// The Log Service project of the instance.
	SlsProject *string `json:"SlsProject,omitempty" xml:"SlsProject,omitempty"`
	// Indicates whether the Log Analysis feature is enabled for the website. Valid values:
	//
	// *   **true**: enabled
	// *   **false**: disabled
	SlsStatus *bool `json:"SlsStatus,omitempty" xml:"SlsStatus,omitempty"`
}

func (s DescribeWebAccessLogStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebAccessLogStatusResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeWebAccessLogStatusResponseBody) SetRequestId(v string) *DescribeWebAccessLogStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeWebAccessLogStatusResponseBody) SetSlsLogstore(v string) *DescribeWebAccessLogStatusResponseBody {
	s.SlsLogstore = &v
	return s
}

func (s *DescribeWebAccessLogStatusResponseBody) SetSlsProject(v string) *DescribeWebAccessLogStatusResponseBody {
	s.SlsProject = &v
	return s
}

func (s *DescribeWebAccessLogStatusResponseBody) SetSlsStatus(v bool) *DescribeWebAccessLogStatusResponseBody {
	s.SlsStatus = &v
	return s
}

type DescribeWebAccessLogStatusResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeWebAccessLogStatusResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeWebAccessLogStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebAccessLogStatusResponse) GoString() string {
	return s.String()
}

func (s *DescribeWebAccessLogStatusResponse) SetHeaders(v map[string]*string) *DescribeWebAccessLogStatusResponse {
	s.Headers = v
	return s
}

func (s *DescribeWebAccessLogStatusResponse) SetStatusCode(v int32) *DescribeWebAccessLogStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeWebAccessLogStatusResponse) SetBody(v *DescribeWebAccessLogStatusResponseBody) *DescribeWebAccessLogStatusResponse {
	s.Body = v
	return s
}

type DescribeWebAccessModeRequest struct {
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for a domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domains []*string `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Repeated"`
}

func (s DescribeWebAccessModeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebAccessModeRequest) GoString() string {
	return s.String()
}

func (s *DescribeWebAccessModeRequest) SetDomains(v []*string) *DescribeWebAccessModeRequest {
	s.Domains = v
	return s
}

type DescribeWebAccessModeResponseBody struct {
	// An array consisting of the modes in which the website service is added.
	DomainModes []*DescribeWebAccessModeResponseBodyDomainModes `json:"DomainModes,omitempty" xml:"DomainModes,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeWebAccessModeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebAccessModeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeWebAccessModeResponseBody) SetDomainModes(v []*DescribeWebAccessModeResponseBodyDomainModes) *DescribeWebAccessModeResponseBody {
	s.DomainModes = v
	return s
}

func (s *DescribeWebAccessModeResponseBody) SetRequestId(v string) *DescribeWebAccessModeResponseBody {
	s.RequestId = &v
	return s
}

type DescribeWebAccessModeResponseBodyDomainModes struct {
	// The mode in which the website service is added. Valid values:
	//
	// *   **0**: A record
	// *   **1**: anti-DDoS mode
	// *   **2**: origin redundancy mode
	AccessMode *int32 `json:"AccessMode,omitempty" xml:"AccessMode,omitempty"`
	// The domain name of the website.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
}

func (s DescribeWebAccessModeResponseBodyDomainModes) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebAccessModeResponseBodyDomainModes) GoString() string {
	return s.String()
}

func (s *DescribeWebAccessModeResponseBodyDomainModes) SetAccessMode(v int32) *DescribeWebAccessModeResponseBodyDomainModes {
	s.AccessMode = &v
	return s
}

func (s *DescribeWebAccessModeResponseBodyDomainModes) SetDomain(v string) *DescribeWebAccessModeResponseBodyDomainModes {
	s.Domain = &v
	return s
}

type DescribeWebAccessModeResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeWebAccessModeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeWebAccessModeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebAccessModeResponse) GoString() string {
	return s.String()
}

func (s *DescribeWebAccessModeResponse) SetHeaders(v map[string]*string) *DescribeWebAccessModeResponse {
	s.Headers = v
	return s
}

func (s *DescribeWebAccessModeResponse) SetStatusCode(v int32) *DescribeWebAccessModeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeWebAccessModeResponse) SetBody(v *DescribeWebAccessModeResponseBody) *DescribeWebAccessModeResponse {
	s.Body = v
	return s
}

type DescribeWebAreaBlockConfigsRequest struct {
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domains []*string `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Repeated"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeWebAreaBlockConfigsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebAreaBlockConfigsRequest) GoString() string {
	return s.String()
}

func (s *DescribeWebAreaBlockConfigsRequest) SetDomains(v []*string) *DescribeWebAreaBlockConfigsRequest {
	s.Domains = v
	return s
}

func (s *DescribeWebAreaBlockConfigsRequest) SetResourceGroupId(v string) *DescribeWebAreaBlockConfigsRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeWebAreaBlockConfigsResponseBody struct {
	// An array that consists of the configurations of the Location Blacklist (Domain Names) policy.
	AreaBlockConfigs []*DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigs `json:"AreaBlockConfigs,omitempty" xml:"AreaBlockConfigs,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeWebAreaBlockConfigsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebAreaBlockConfigsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeWebAreaBlockConfigsResponseBody) SetAreaBlockConfigs(v []*DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigs) *DescribeWebAreaBlockConfigsResponseBody {
	s.AreaBlockConfigs = v
	return s
}

func (s *DescribeWebAreaBlockConfigsResponseBody) SetRequestId(v string) *DescribeWebAreaBlockConfigsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigs struct {
	// The domain name of the website.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The configuration of the blocked locations.
	RegionList []*DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigsRegionList `json:"RegionList,omitempty" xml:"RegionList,omitempty" type:"Repeated"`
}

func (s DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigs) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigs) GoString() string {
	return s.String()
}

func (s *DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigs) SetDomain(v string) *DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigs {
	s.Domain = &v
	return s
}

func (s *DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigs) SetRegionList(v []*DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigsRegionList) *DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigs {
	s.RegionList = v
	return s
}

type DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigsRegionList struct {
	// Indicates whether the location is blocked. Valid values:
	//
	// *   **0**: yes
	// *   **1**: no
	Block *int32 `json:"Block,omitempty" xml:"Block,omitempty"`
	// The name of the location.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
}

func (s DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigsRegionList) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigsRegionList) GoString() string {
	return s.String()
}

func (s *DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigsRegionList) SetBlock(v int32) *DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigsRegionList {
	s.Block = &v
	return s
}

func (s *DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigsRegionList) SetRegion(v string) *DescribeWebAreaBlockConfigsResponseBodyAreaBlockConfigsRegionList {
	s.Region = &v
	return s
}

type DescribeWebAreaBlockConfigsResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeWebAreaBlockConfigsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeWebAreaBlockConfigsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebAreaBlockConfigsResponse) GoString() string {
	return s.String()
}

func (s *DescribeWebAreaBlockConfigsResponse) SetHeaders(v map[string]*string) *DescribeWebAreaBlockConfigsResponse {
	s.Headers = v
	return s
}

func (s *DescribeWebAreaBlockConfigsResponse) SetStatusCode(v int32) *DescribeWebAreaBlockConfigsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeWebAreaBlockConfigsResponse) SetBody(v *DescribeWebAreaBlockConfigsResponseBody) *DescribeWebAreaBlockConfigsResponse {
	s.Body = v
	return s
}

type DescribeWebCCRulesRequest struct {
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The number of the page to return. For example, to query the returned results on the first page, set the value to **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *string `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeWebCCRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebCCRulesRequest) GoString() string {
	return s.String()
}

func (s *DescribeWebCCRulesRequest) SetDomain(v string) *DescribeWebCCRulesRequest {
	s.Domain = &v
	return s
}

func (s *DescribeWebCCRulesRequest) SetPageNumber(v int32) *DescribeWebCCRulesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeWebCCRulesRequest) SetPageSize(v string) *DescribeWebCCRulesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeWebCCRulesRequest) SetResourceGroupId(v string) *DescribeWebCCRulesRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeWebCCRulesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of returned custom frequency control rules.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// An array that consists of the details of the custom frequency control rule.
	WebCCRules []*DescribeWebCCRulesResponseBodyWebCCRules `json:"WebCCRules,omitempty" xml:"WebCCRules,omitempty" type:"Repeated"`
}

func (s DescribeWebCCRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebCCRulesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeWebCCRulesResponseBody) SetRequestId(v string) *DescribeWebCCRulesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeWebCCRulesResponseBody) SetTotalCount(v int64) *DescribeWebCCRulesResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeWebCCRulesResponseBody) SetWebCCRules(v []*DescribeWebCCRulesResponseBodyWebCCRules) *DescribeWebCCRulesResponseBody {
	s.WebCCRules = v
	return s
}

type DescribeWebCCRulesResponseBodyWebCCRules struct {
	// The blocking type. Valid values:
	//
	// *   **close**: blocks requests.
	// *   **captcha**: enables Completely Automated Public Turing test to tell Computers and Humans Apart (CAPTCHA) verification.
	Act *string `json:"Act,omitempty" xml:"Act,omitempty"`
	// The number of requests that are allowed from an individual IP address. Valid values: **2** to **2000**.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The check intervals. Valid values: **5** to **10800**. Unit: seconds.
	Interval *int32 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The match mode. Valid values:
	//
	// *   **prefix**: prefix match
	// *   **match**: exact match
	Mode *string `json:"Mode,omitempty" xml:"Mode,omitempty"`
	// The name of the rule.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The blocking duration. Valid values: **1** to **1440**. Unit: minutes.
	Ttl *int32 `json:"Ttl,omitempty" xml:"Ttl,omitempty"`
	// The check path.
	Uri *string `json:"Uri,omitempty" xml:"Uri,omitempty"`
}

func (s DescribeWebCCRulesResponseBodyWebCCRules) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebCCRulesResponseBodyWebCCRules) GoString() string {
	return s.String()
}

func (s *DescribeWebCCRulesResponseBodyWebCCRules) SetAct(v string) *DescribeWebCCRulesResponseBodyWebCCRules {
	s.Act = &v
	return s
}

func (s *DescribeWebCCRulesResponseBodyWebCCRules) SetCount(v int32) *DescribeWebCCRulesResponseBodyWebCCRules {
	s.Count = &v
	return s
}

func (s *DescribeWebCCRulesResponseBodyWebCCRules) SetInterval(v int32) *DescribeWebCCRulesResponseBodyWebCCRules {
	s.Interval = &v
	return s
}

func (s *DescribeWebCCRulesResponseBodyWebCCRules) SetMode(v string) *DescribeWebCCRulesResponseBodyWebCCRules {
	s.Mode = &v
	return s
}

func (s *DescribeWebCCRulesResponseBodyWebCCRules) SetName(v string) *DescribeWebCCRulesResponseBodyWebCCRules {
	s.Name = &v
	return s
}

func (s *DescribeWebCCRulesResponseBodyWebCCRules) SetTtl(v int32) *DescribeWebCCRulesResponseBodyWebCCRules {
	s.Ttl = &v
	return s
}

func (s *DescribeWebCCRulesResponseBodyWebCCRules) SetUri(v string) *DescribeWebCCRulesResponseBodyWebCCRules {
	s.Uri = &v
	return s
}

type DescribeWebCCRulesResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeWebCCRulesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeWebCCRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebCCRulesResponse) GoString() string {
	return s.String()
}

func (s *DescribeWebCCRulesResponse) SetHeaders(v map[string]*string) *DescribeWebCCRulesResponse {
	s.Headers = v
	return s
}

func (s *DescribeWebCCRulesResponse) SetStatusCode(v int32) *DescribeWebCCRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeWebCCRulesResponse) SetBody(v *DescribeWebCCRulesResponseBody) *DescribeWebCCRulesResponse {
	s.Body = v
	return s
}

type DescribeWebCacheConfigsRequest struct {
	// An array consisting of domain names for which you want to query the Static Page Caching configurations.
	Domains []*string `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Repeated"`
	// The ID of the resource group to which the instance belongs in Resource Management.
	//
	// If you do not configure this parameter, the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeWebCacheConfigsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebCacheConfigsRequest) GoString() string {
	return s.String()
}

func (s *DescribeWebCacheConfigsRequest) SetDomains(v []*string) *DescribeWebCacheConfigsRequest {
	s.Domains = v
	return s
}

func (s *DescribeWebCacheConfigsRequest) SetResourceGroupId(v string) *DescribeWebCacheConfigsRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeWebCacheConfigsResponseBody struct {
	// An array that consists of Static Page Caching configurations.
	DomainCacheConfigs []*DescribeWebCacheConfigsResponseBodyDomainCacheConfigs `json:"DomainCacheConfigs,omitempty" xml:"DomainCacheConfigs,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeWebCacheConfigsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebCacheConfigsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeWebCacheConfigsResponseBody) SetDomainCacheConfigs(v []*DescribeWebCacheConfigsResponseBodyDomainCacheConfigs) *DescribeWebCacheConfigsResponseBody {
	s.DomainCacheConfigs = v
	return s
}

func (s *DescribeWebCacheConfigsResponseBody) SetRequestId(v string) *DescribeWebCacheConfigsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeWebCacheConfigsResponseBodyDomainCacheConfigs struct {
	// An array that consists of custom caching rules.
	CustomRules []*DescribeWebCacheConfigsResponseBodyDomainCacheConfigsCustomRules `json:"CustomRules,omitempty" xml:"CustomRules,omitempty" type:"Repeated"`
	// The domain name of the website.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The status of the Static Page Caching policy. Valid values:
	//
	// *   **1**: enabled
	// *   **0**: disabled
	Enable *int32 `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The cache mode. Valid values:
	//
	// *   **standard**: The standard cache mode is used.
	// *   **aggressive**: The enhanced cache mode is used.
	// *   **bypass**: No data is cached.
	Mode *string `json:"Mode,omitempty" xml:"Mode,omitempty"`
}

func (s DescribeWebCacheConfigsResponseBodyDomainCacheConfigs) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebCacheConfigsResponseBodyDomainCacheConfigs) GoString() string {
	return s.String()
}

func (s *DescribeWebCacheConfigsResponseBodyDomainCacheConfigs) SetCustomRules(v []*DescribeWebCacheConfigsResponseBodyDomainCacheConfigsCustomRules) *DescribeWebCacheConfigsResponseBodyDomainCacheConfigs {
	s.CustomRules = v
	return s
}

func (s *DescribeWebCacheConfigsResponseBodyDomainCacheConfigs) SetDomain(v string) *DescribeWebCacheConfigsResponseBodyDomainCacheConfigs {
	s.Domain = &v
	return s
}

func (s *DescribeWebCacheConfigsResponseBodyDomainCacheConfigs) SetEnable(v int32) *DescribeWebCacheConfigsResponseBodyDomainCacheConfigs {
	s.Enable = &v
	return s
}

func (s *DescribeWebCacheConfigsResponseBodyDomainCacheConfigs) SetMode(v string) *DescribeWebCacheConfigsResponseBodyDomainCacheConfigs {
	s.Mode = &v
	return s
}

type DescribeWebCacheConfigsResponseBodyDomainCacheConfigsCustomRules struct {
	// The expiration time of the page cache. Unit: seconds.
	CacheTtl *int64 `json:"CacheTtl,omitempty" xml:"CacheTtl,omitempty"`
	// The cache mode. Valid values:
	//
	// *   **standard**: The standard cache mode is used.
	// *   **aggressive**: The enhanced cache mode is used.
	// *   **bypass**: No data is cached.
	Mode *string `json:"Mode,omitempty" xml:"Mode,omitempty"`
	// The name of the rule.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The path to the cached page.
	Uri *string `json:"Uri,omitempty" xml:"Uri,omitempty"`
}

func (s DescribeWebCacheConfigsResponseBodyDomainCacheConfigsCustomRules) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebCacheConfigsResponseBodyDomainCacheConfigsCustomRules) GoString() string {
	return s.String()
}

func (s *DescribeWebCacheConfigsResponseBodyDomainCacheConfigsCustomRules) SetCacheTtl(v int64) *DescribeWebCacheConfigsResponseBodyDomainCacheConfigsCustomRules {
	s.CacheTtl = &v
	return s
}

func (s *DescribeWebCacheConfigsResponseBodyDomainCacheConfigsCustomRules) SetMode(v string) *DescribeWebCacheConfigsResponseBodyDomainCacheConfigsCustomRules {
	s.Mode = &v
	return s
}

func (s *DescribeWebCacheConfigsResponseBodyDomainCacheConfigsCustomRules) SetName(v string) *DescribeWebCacheConfigsResponseBodyDomainCacheConfigsCustomRules {
	s.Name = &v
	return s
}

func (s *DescribeWebCacheConfigsResponseBodyDomainCacheConfigsCustomRules) SetUri(v string) *DescribeWebCacheConfigsResponseBodyDomainCacheConfigsCustomRules {
	s.Uri = &v
	return s
}

type DescribeWebCacheConfigsResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeWebCacheConfigsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeWebCacheConfigsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebCacheConfigsResponse) GoString() string {
	return s.String()
}

func (s *DescribeWebCacheConfigsResponse) SetHeaders(v map[string]*string) *DescribeWebCacheConfigsResponse {
	s.Headers = v
	return s
}

func (s *DescribeWebCacheConfigsResponse) SetStatusCode(v int32) *DescribeWebCacheConfigsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeWebCacheConfigsResponse) SetBody(v *DescribeWebCacheConfigsResponseBody) *DescribeWebCacheConfigsResponse {
	s.Body = v
	return s
}

type DescribeWebCcProtectSwitchRequest struct {
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domains []*string `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Repeated"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeWebCcProtectSwitchRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebCcProtectSwitchRequest) GoString() string {
	return s.String()
}

func (s *DescribeWebCcProtectSwitchRequest) SetDomains(v []*string) *DescribeWebCcProtectSwitchRequest {
	s.Domains = v
	return s
}

func (s *DescribeWebCcProtectSwitchRequest) SetResourceGroupId(v string) *DescribeWebCcProtectSwitchRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeWebCcProtectSwitchResponseBody struct {
	// The status of each protection policy for a website.
	ProtectSwitchList []*DescribeWebCcProtectSwitchResponseBodyProtectSwitchList `json:"ProtectSwitchList,omitempty" xml:"ProtectSwitchList,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeWebCcProtectSwitchResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebCcProtectSwitchResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeWebCcProtectSwitchResponseBody) SetProtectSwitchList(v []*DescribeWebCcProtectSwitchResponseBodyProtectSwitchList) *DescribeWebCcProtectSwitchResponseBody {
	s.ProtectSwitchList = v
	return s
}

func (s *DescribeWebCcProtectSwitchResponseBody) SetRequestId(v string) *DescribeWebCcProtectSwitchResponseBody {
	s.RequestId = &v
	return s
}

type DescribeWebCcProtectSwitchResponseBodyProtectSwitchList struct {
	// The mode of the Intelligent Protection policy. Valid values:
	//
	// *   **watch**: the Warning mode
	// *   **defense**: the Defense mode
	AiMode *string `json:"AiMode,omitempty" xml:"AiMode,omitempty"`
	// The status of the Intelligent Protection policy. Valid values:
	//
	// *   **0**: disabled
	// *   **1**: enabled
	AiRuleEnable *int32 `json:"AiRuleEnable,omitempty" xml:"AiRuleEnable,omitempty"`
	// The level of the Intelligent Protection policy. Valid values:
	//
	// *   **level30**: the Low level
	// *   **level60**: the Normal level
	// *   **level90**: the Strict level
	AiTemplate *string `json:"AiTemplate,omitempty" xml:"AiTemplate,omitempty"`
	// The status of the Black Lists and White Lists (Domain Names) policy. Valid values:
	//
	// *   **0**: disabled
	// *   **1**: enabled
	BlackWhiteListEnable *int32 `json:"BlackWhiteListEnable,omitempty" xml:"BlackWhiteListEnable,omitempty"`
	// The status of the Custom Rule switch for the Frequency Control policy. Valid values:
	//
	// *   **0**: disabled
	// *   **1**: enabled
	CcCustomRuleEnable *int32 `json:"CcCustomRuleEnable,omitempty" xml:"CcCustomRuleEnable,omitempty"`
	// The status of the Frequency Control policy. Valid values:
	//
	// *   **0**: disabled
	// *   **1**: enabled
	CcEnable       *int32  `json:"CcEnable,omitempty" xml:"CcEnable,omitempty"`
	CcGlobalSwitch *string `json:"CcGlobalSwitch,omitempty" xml:"CcGlobalSwitch,omitempty"`
	// The mode of the Frequency Control policy. Valid values:
	//
	// *   **default**: Normal
	// *   **gf_under_attack**: Emergency
	// *   **gf_sos_verify**: Strict
	// *   **gf_sos_enhance**: Super Strict
	CcTemplate *string `json:"CcTemplate,omitempty" xml:"CcTemplate,omitempty"`
	// The domain name of the website.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The status of the Accurate Access Control policy. Valid values:
	//
	// *   **0**: disabled
	// *   **1**: enabled
	PreciseRuleEnable *int32 `json:"PreciseRuleEnable,omitempty" xml:"PreciseRuleEnable,omitempty"`
	// The status of the Location Blacklist (Domain Names) policy. Valid values:
	//
	// *   **0**: disabled
	// *   **1**: enabled
	RegionBlockEnable *int32 `json:"RegionBlockEnable,omitempty" xml:"RegionBlockEnable,omitempty"`
}

func (s DescribeWebCcProtectSwitchResponseBodyProtectSwitchList) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebCcProtectSwitchResponseBodyProtectSwitchList) GoString() string {
	return s.String()
}

func (s *DescribeWebCcProtectSwitchResponseBodyProtectSwitchList) SetAiMode(v string) *DescribeWebCcProtectSwitchResponseBodyProtectSwitchList {
	s.AiMode = &v
	return s
}

func (s *DescribeWebCcProtectSwitchResponseBodyProtectSwitchList) SetAiRuleEnable(v int32) *DescribeWebCcProtectSwitchResponseBodyProtectSwitchList {
	s.AiRuleEnable = &v
	return s
}

func (s *DescribeWebCcProtectSwitchResponseBodyProtectSwitchList) SetAiTemplate(v string) *DescribeWebCcProtectSwitchResponseBodyProtectSwitchList {
	s.AiTemplate = &v
	return s
}

func (s *DescribeWebCcProtectSwitchResponseBodyProtectSwitchList) SetBlackWhiteListEnable(v int32) *DescribeWebCcProtectSwitchResponseBodyProtectSwitchList {
	s.BlackWhiteListEnable = &v
	return s
}

func (s *DescribeWebCcProtectSwitchResponseBodyProtectSwitchList) SetCcCustomRuleEnable(v int32) *DescribeWebCcProtectSwitchResponseBodyProtectSwitchList {
	s.CcCustomRuleEnable = &v
	return s
}

func (s *DescribeWebCcProtectSwitchResponseBodyProtectSwitchList) SetCcEnable(v int32) *DescribeWebCcProtectSwitchResponseBodyProtectSwitchList {
	s.CcEnable = &v
	return s
}

func (s *DescribeWebCcProtectSwitchResponseBodyProtectSwitchList) SetCcGlobalSwitch(v string) *DescribeWebCcProtectSwitchResponseBodyProtectSwitchList {
	s.CcGlobalSwitch = &v
	return s
}

func (s *DescribeWebCcProtectSwitchResponseBodyProtectSwitchList) SetCcTemplate(v string) *DescribeWebCcProtectSwitchResponseBodyProtectSwitchList {
	s.CcTemplate = &v
	return s
}

func (s *DescribeWebCcProtectSwitchResponseBodyProtectSwitchList) SetDomain(v string) *DescribeWebCcProtectSwitchResponseBodyProtectSwitchList {
	s.Domain = &v
	return s
}

func (s *DescribeWebCcProtectSwitchResponseBodyProtectSwitchList) SetPreciseRuleEnable(v int32) *DescribeWebCcProtectSwitchResponseBodyProtectSwitchList {
	s.PreciseRuleEnable = &v
	return s
}

func (s *DescribeWebCcProtectSwitchResponseBodyProtectSwitchList) SetRegionBlockEnable(v int32) *DescribeWebCcProtectSwitchResponseBodyProtectSwitchList {
	s.RegionBlockEnable = &v
	return s
}

type DescribeWebCcProtectSwitchResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeWebCcProtectSwitchResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeWebCcProtectSwitchResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebCcProtectSwitchResponse) GoString() string {
	return s.String()
}

func (s *DescribeWebCcProtectSwitchResponse) SetHeaders(v map[string]*string) *DescribeWebCcProtectSwitchResponse {
	s.Headers = v
	return s
}

func (s *DescribeWebCcProtectSwitchResponse) SetStatusCode(v int32) *DescribeWebCcProtectSwitchResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeWebCcProtectSwitchResponse) SetBody(v *DescribeWebCcProtectSwitchResponseBody) *DescribeWebCcProtectSwitchResponse {
	s.Body = v
	return s
}

type DescribeWebCustomPortsRequest struct {
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeWebCustomPortsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebCustomPortsRequest) GoString() string {
	return s.String()
}

func (s *DescribeWebCustomPortsRequest) SetResourceGroupId(v string) *DescribeWebCustomPortsRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeWebCustomPortsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// An array consisting of information about supported custom ports that are used by a website.
	WebCustomPorts []*DescribeWebCustomPortsResponseBodyWebCustomPorts `json:"WebCustomPorts,omitempty" xml:"WebCustomPorts,omitempty" type:"Repeated"`
}

func (s DescribeWebCustomPortsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebCustomPortsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeWebCustomPortsResponseBody) SetRequestId(v string) *DescribeWebCustomPortsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeWebCustomPortsResponseBody) SetWebCustomPorts(v []*DescribeWebCustomPortsResponseBodyWebCustomPorts) *DescribeWebCustomPortsResponseBody {
	s.WebCustomPorts = v
	return s
}

type DescribeWebCustomPortsResponseBodyWebCustomPorts struct {
	// An array that consists of supported custom ports.
	ProxyPorts []*string `json:"ProxyPorts,omitempty" xml:"ProxyPorts,omitempty" type:"Repeated"`
	// The type of the protocol. Valid values:
	//
	// *   **http**
	// *   **https**
	ProxyType *string `json:"ProxyType,omitempty" xml:"ProxyType,omitempty"`
}

func (s DescribeWebCustomPortsResponseBodyWebCustomPorts) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebCustomPortsResponseBodyWebCustomPorts) GoString() string {
	return s.String()
}

func (s *DescribeWebCustomPortsResponseBodyWebCustomPorts) SetProxyPorts(v []*string) *DescribeWebCustomPortsResponseBodyWebCustomPorts {
	s.ProxyPorts = v
	return s
}

func (s *DescribeWebCustomPortsResponseBodyWebCustomPorts) SetProxyType(v string) *DescribeWebCustomPortsResponseBodyWebCustomPorts {
	s.ProxyType = &v
	return s
}

type DescribeWebCustomPortsResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeWebCustomPortsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeWebCustomPortsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebCustomPortsResponse) GoString() string {
	return s.String()
}

func (s *DescribeWebCustomPortsResponse) SetHeaders(v map[string]*string) *DescribeWebCustomPortsResponse {
	s.Headers = v
	return s
}

func (s *DescribeWebCustomPortsResponse) SetStatusCode(v int32) *DescribeWebCustomPortsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeWebCustomPortsResponse) SetBody(v *DescribeWebCustomPortsResponseBody) *DescribeWebCustomPortsResponse {
	s.Body = v
	return s
}

type DescribeWebInstanceRelationsRequest struct {
	// The domain names of the website. list
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domains []*string `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Repeated"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeWebInstanceRelationsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebInstanceRelationsRequest) GoString() string {
	return s.String()
}

func (s *DescribeWebInstanceRelationsRequest) SetDomains(v []*string) *DescribeWebInstanceRelationsRequest {
	s.Domains = v
	return s
}

func (s *DescribeWebInstanceRelationsRequest) SetResourceGroupId(v string) *DescribeWebInstanceRelationsRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeWebInstanceRelationsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the instances to which a website service is added.
	WebInstanceRelations []*DescribeWebInstanceRelationsResponseBodyWebInstanceRelations `json:"WebInstanceRelations,omitempty" xml:"WebInstanceRelations,omitempty" type:"Repeated"`
}

func (s DescribeWebInstanceRelationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebInstanceRelationsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeWebInstanceRelationsResponseBody) SetRequestId(v string) *DescribeWebInstanceRelationsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeWebInstanceRelationsResponseBody) SetWebInstanceRelations(v []*DescribeWebInstanceRelationsResponseBodyWebInstanceRelations) *DescribeWebInstanceRelationsResponseBody {
	s.WebInstanceRelations = v
	return s
}

type DescribeWebInstanceRelationsResponseBodyWebInstanceRelations struct {
	// The domain name of the website.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The information about the instance to which a website service is added.
	InstanceDetails []*DescribeWebInstanceRelationsResponseBodyWebInstanceRelationsInstanceDetails `json:"InstanceDetails,omitempty" xml:"InstanceDetails,omitempty" type:"Repeated"`
}

func (s DescribeWebInstanceRelationsResponseBodyWebInstanceRelations) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebInstanceRelationsResponseBodyWebInstanceRelations) GoString() string {
	return s.String()
}

func (s *DescribeWebInstanceRelationsResponseBodyWebInstanceRelations) SetDomain(v string) *DescribeWebInstanceRelationsResponseBodyWebInstanceRelations {
	s.Domain = &v
	return s
}

func (s *DescribeWebInstanceRelationsResponseBodyWebInstanceRelations) SetInstanceDetails(v []*DescribeWebInstanceRelationsResponseBodyWebInstanceRelationsInstanceDetails) *DescribeWebInstanceRelationsResponseBodyWebInstanceRelations {
	s.InstanceDetails = v
	return s
}

type DescribeWebInstanceRelationsResponseBodyWebInstanceRelationsInstanceDetails struct {
	// The IP addresses of the instance.
	EipList []*string `json:"EipList,omitempty" xml:"EipList,omitempty" type:"Repeated"`
	// The function plan of the instance. Valid values:
	//
	// *   **default**: Standard function plan
	// *   **enhance**: Enhanced function plan
	FunctionVersion *string `json:"FunctionVersion,omitempty" xml:"FunctionVersion,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s DescribeWebInstanceRelationsResponseBodyWebInstanceRelationsInstanceDetails) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebInstanceRelationsResponseBodyWebInstanceRelationsInstanceDetails) GoString() string {
	return s.String()
}

func (s *DescribeWebInstanceRelationsResponseBodyWebInstanceRelationsInstanceDetails) SetEipList(v []*string) *DescribeWebInstanceRelationsResponseBodyWebInstanceRelationsInstanceDetails {
	s.EipList = v
	return s
}

func (s *DescribeWebInstanceRelationsResponseBodyWebInstanceRelationsInstanceDetails) SetFunctionVersion(v string) *DescribeWebInstanceRelationsResponseBodyWebInstanceRelationsInstanceDetails {
	s.FunctionVersion = &v
	return s
}

func (s *DescribeWebInstanceRelationsResponseBodyWebInstanceRelationsInstanceDetails) SetInstanceId(v string) *DescribeWebInstanceRelationsResponseBodyWebInstanceRelationsInstanceDetails {
	s.InstanceId = &v
	return s
}

type DescribeWebInstanceRelationsResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeWebInstanceRelationsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeWebInstanceRelationsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebInstanceRelationsResponse) GoString() string {
	return s.String()
}

func (s *DescribeWebInstanceRelationsResponse) SetHeaders(v map[string]*string) *DescribeWebInstanceRelationsResponse {
	s.Headers = v
	return s
}

func (s *DescribeWebInstanceRelationsResponse) SetStatusCode(v int32) *DescribeWebInstanceRelationsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeWebInstanceRelationsResponse) SetBody(v *DescribeWebInstanceRelationsResponseBody) *DescribeWebInstanceRelationsResponse {
	s.Body = v
	return s
}

type DescribeWebPreciseAccessRuleRequest struct {
	// An array that consists of the domain names of websites.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domains []*string `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Repeated"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeWebPreciseAccessRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebPreciseAccessRuleRequest) GoString() string {
	return s.String()
}

func (s *DescribeWebPreciseAccessRuleRequest) SetDomains(v []*string) *DescribeWebPreciseAccessRuleRequest {
	s.Domains = v
	return s
}

func (s *DescribeWebPreciseAccessRuleRequest) SetResourceGroupId(v string) *DescribeWebPreciseAccessRuleRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeWebPreciseAccessRuleResponseBody struct {
	// An array consisting of the configuration of the accurate access control rule that is created for the website.
	PreciseAccessConfigList []*DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigList `json:"PreciseAccessConfigList,omitempty" xml:"PreciseAccessConfigList,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeWebPreciseAccessRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebPreciseAccessRuleResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeWebPreciseAccessRuleResponseBody) SetPreciseAccessConfigList(v []*DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigList) *DescribeWebPreciseAccessRuleResponseBody {
	s.PreciseAccessConfigList = v
	return s
}

func (s *DescribeWebPreciseAccessRuleResponseBody) SetRequestId(v string) *DescribeWebPreciseAccessRuleResponseBody {
	s.RequestId = &v
	return s
}

type DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigList struct {
	// The domain name of the website.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// An array that consists of the rules.
	RuleList []*DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleList `json:"RuleList,omitempty" xml:"RuleList,omitempty" type:"Repeated"`
}

func (s DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigList) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigList) GoString() string {
	return s.String()
}

func (s *DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigList) SetDomain(v string) *DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigList {
	s.Domain = &v
	return s
}

func (s *DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigList) SetRuleList(v []*DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleList) *DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigList {
	s.RuleList = v
	return s
}

type DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleList struct {
	// The action triggered if the rule is matched. Valid values:
	//
	// *   **accept**: allows the requests that match the rule.
	// *   **block**: blocks the requests that match the rule.
	// *   **challenge**: implements Completely Automated Public Turing test to tell Computers and Humans Apart (CAPTCHA) verification for the requests that match the rule.
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	// The match conditions.
	ConditionList []*DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleListConditionList `json:"ConditionList,omitempty" xml:"ConditionList,omitempty" type:"Repeated"`
	// The validity period of the rule. Unit: seconds. This parameter takes effect only when **action** of a rule is **block**. Access requests that match the rule are blocked within the specified validity period of the rule. **0** indicates that the rule takes effect all the time.
	Expires *int64 `json:"Expires,omitempty" xml:"Expires,omitempty"`
	// The name of the rule.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The source of the rule. Valid values:
	//
	// *   **manual**: manually created. This is the default value.
	// *   **auto**: automatically generated.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
}

func (s DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleList) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleList) GoString() string {
	return s.String()
}

func (s *DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleList) SetAction(v string) *DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleList {
	s.Action = &v
	return s
}

func (s *DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleList) SetConditionList(v []*DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleListConditionList) *DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleList {
	s.ConditionList = v
	return s
}

func (s *DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleList) SetExpires(v int64) *DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleList {
	s.Expires = &v
	return s
}

func (s *DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleList) SetName(v string) *DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleList {
	s.Name = &v
	return s
}

func (s *DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleList) SetOwner(v string) *DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleList {
	s.Owner = &v
	return s
}

type DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleListConditionList struct {
	// The match content.
	Content     *string   `json:"Content,omitempty" xml:"Content,omitempty"`
	ContentList []*string `json:"ContentList,omitempty" xml:"ContentList,omitempty" type:"Repeated"`
	// The match field.
	Field *string `json:"Field,omitempty" xml:"Field,omitempty"`
	// The custom HTTP header.
	//
	// > This parameter takes effect only when **Field** is set to **header**.
	HeaderName *string `json:"HeaderName,omitempty" xml:"HeaderName,omitempty"`
	// The logical operator.
	MatchMethod *string `json:"MatchMethod,omitempty" xml:"MatchMethod,omitempty"`
}

func (s DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleListConditionList) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleListConditionList) GoString() string {
	return s.String()
}

func (s *DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleListConditionList) SetContent(v string) *DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleListConditionList {
	s.Content = &v
	return s
}

func (s *DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleListConditionList) SetContentList(v []*string) *DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleListConditionList {
	s.ContentList = v
	return s
}

func (s *DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleListConditionList) SetField(v string) *DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleListConditionList {
	s.Field = &v
	return s
}

func (s *DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleListConditionList) SetHeaderName(v string) *DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleListConditionList {
	s.HeaderName = &v
	return s
}

func (s *DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleListConditionList) SetMatchMethod(v string) *DescribeWebPreciseAccessRuleResponseBodyPreciseAccessConfigListRuleListConditionList {
	s.MatchMethod = &v
	return s
}

type DescribeWebPreciseAccessRuleResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeWebPreciseAccessRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeWebPreciseAccessRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebPreciseAccessRuleResponse) GoString() string {
	return s.String()
}

func (s *DescribeWebPreciseAccessRuleResponse) SetHeaders(v map[string]*string) *DescribeWebPreciseAccessRuleResponse {
	s.Headers = v
	return s
}

func (s *DescribeWebPreciseAccessRuleResponse) SetStatusCode(v int32) *DescribeWebPreciseAccessRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeWebPreciseAccessRuleResponse) SetBody(v *DescribeWebPreciseAccessRuleResponseBody) *DescribeWebPreciseAccessRuleResponse {
	s.Body = v
	return s
}

type DescribeWebReportTopIpRequest struct {
	Domain    *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	EndTime   *int64  `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	Interval  *int32  `json:"Interval,omitempty" xml:"Interval,omitempty"`
	QueryType *string `json:"QueryType,omitempty" xml:"QueryType,omitempty"`
	StartTime *int64  `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	Top       *int32  `json:"Top,omitempty" xml:"Top,omitempty"`
}

func (s DescribeWebReportTopIpRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebReportTopIpRequest) GoString() string {
	return s.String()
}

func (s *DescribeWebReportTopIpRequest) SetDomain(v string) *DescribeWebReportTopIpRequest {
	s.Domain = &v
	return s
}

func (s *DescribeWebReportTopIpRequest) SetEndTime(v int64) *DescribeWebReportTopIpRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeWebReportTopIpRequest) SetInterval(v int32) *DescribeWebReportTopIpRequest {
	s.Interval = &v
	return s
}

func (s *DescribeWebReportTopIpRequest) SetQueryType(v string) *DescribeWebReportTopIpRequest {
	s.QueryType = &v
	return s
}

func (s *DescribeWebReportTopIpRequest) SetStartTime(v int64) *DescribeWebReportTopIpRequest {
	s.StartTime = &v
	return s
}

func (s *DescribeWebReportTopIpRequest) SetTop(v int32) *DescribeWebReportTopIpRequest {
	s.Top = &v
	return s
}

type DescribeWebReportTopIpResponseBody struct {
	DataList  []*DescribeWebReportTopIpResponseBodyDataList `json:"DataList,omitempty" xml:"DataList,omitempty" type:"Repeated"`
	RequestId *string                                       `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeWebReportTopIpResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebReportTopIpResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeWebReportTopIpResponseBody) SetDataList(v []*DescribeWebReportTopIpResponseBodyDataList) *DescribeWebReportTopIpResponseBody {
	s.DataList = v
	return s
}

func (s *DescribeWebReportTopIpResponseBody) SetRequestId(v string) *DescribeWebReportTopIpResponseBody {
	s.RequestId = &v
	return s
}

type DescribeWebReportTopIpResponseBodyDataList struct {
	AreaId   *string `json:"AreaId,omitempty" xml:"AreaId,omitempty"`
	Count    *int64  `json:"Count,omitempty" xml:"Count,omitempty"`
	Isp      *string `json:"Isp,omitempty" xml:"Isp,omitempty"`
	SourceIp *string `json:"SourceIp,omitempty" xml:"SourceIp,omitempty"`
}

func (s DescribeWebReportTopIpResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebReportTopIpResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *DescribeWebReportTopIpResponseBodyDataList) SetAreaId(v string) *DescribeWebReportTopIpResponseBodyDataList {
	s.AreaId = &v
	return s
}

func (s *DescribeWebReportTopIpResponseBodyDataList) SetCount(v int64) *DescribeWebReportTopIpResponseBodyDataList {
	s.Count = &v
	return s
}

func (s *DescribeWebReportTopIpResponseBodyDataList) SetIsp(v string) *DescribeWebReportTopIpResponseBodyDataList {
	s.Isp = &v
	return s
}

func (s *DescribeWebReportTopIpResponseBodyDataList) SetSourceIp(v string) *DescribeWebReportTopIpResponseBodyDataList {
	s.SourceIp = &v
	return s
}

type DescribeWebReportTopIpResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeWebReportTopIpResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeWebReportTopIpResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebReportTopIpResponse) GoString() string {
	return s.String()
}

func (s *DescribeWebReportTopIpResponse) SetHeaders(v map[string]*string) *DescribeWebReportTopIpResponse {
	s.Headers = v
	return s
}

func (s *DescribeWebReportTopIpResponse) SetStatusCode(v int32) *DescribeWebReportTopIpResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeWebReportTopIpResponse) SetBody(v *DescribeWebReportTopIpResponseBody) *DescribeWebReportTopIpResponse {
	s.Body = v
	return s
}

type DescribeWebRulesRequest struct {
	Cname              *string   `json:"Cname,omitempty" xml:"Cname,omitempty"`
	Domain             *string   `json:"Domain,omitempty" xml:"Domain,omitempty"`
	InstanceIds        []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	PageNumber         *int32    `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize           *int32    `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	QueryDomainPattern *string   `json:"QueryDomainPattern,omitempty" xml:"QueryDomainPattern,omitempty"`
	ResourceGroupId    *string   `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DescribeWebRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebRulesRequest) GoString() string {
	return s.String()
}

func (s *DescribeWebRulesRequest) SetCname(v string) *DescribeWebRulesRequest {
	s.Cname = &v
	return s
}

func (s *DescribeWebRulesRequest) SetDomain(v string) *DescribeWebRulesRequest {
	s.Domain = &v
	return s
}

func (s *DescribeWebRulesRequest) SetInstanceIds(v []*string) *DescribeWebRulesRequest {
	s.InstanceIds = v
	return s
}

func (s *DescribeWebRulesRequest) SetPageNumber(v int32) *DescribeWebRulesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeWebRulesRequest) SetPageSize(v int32) *DescribeWebRulesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeWebRulesRequest) SetQueryDomainPattern(v string) *DescribeWebRulesRequest {
	s.QueryDomainPattern = &v
	return s
}

func (s *DescribeWebRulesRequest) SetResourceGroupId(v string) *DescribeWebRulesRequest {
	s.ResourceGroupId = &v
	return s
}

type DescribeWebRulesResponseBody struct {
	RequestId  *string                                 `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TotalCount *int64                                  `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	WebRules   []*DescribeWebRulesResponseBodyWebRules `json:"WebRules,omitempty" xml:"WebRules,omitempty" type:"Repeated"`
}

func (s DescribeWebRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebRulesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeWebRulesResponseBody) SetRequestId(v string) *DescribeWebRulesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeWebRulesResponseBody) SetTotalCount(v int64) *DescribeWebRulesResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeWebRulesResponseBody) SetWebRules(v []*DescribeWebRulesResponseBodyWebRules) *DescribeWebRulesResponseBody {
	s.WebRules = v
	return s
}

type DescribeWebRulesResponseBodyWebRules struct {
	BlackList        []*string                                          `json:"BlackList,omitempty" xml:"BlackList,omitempty" type:"Repeated"`
	CcEnabled        *bool                                              `json:"CcEnabled,omitempty" xml:"CcEnabled,omitempty"`
	CcRuleEnabled    *bool                                              `json:"CcRuleEnabled,omitempty" xml:"CcRuleEnabled,omitempty"`
	CcTemplate       *string                                            `json:"CcTemplate,omitempty" xml:"CcTemplate,omitempty"`
	CertName         *string                                            `json:"CertName,omitempty" xml:"CertName,omitempty"`
	CertRegion       *string                                            `json:"CertRegion,omitempty" xml:"CertRegion,omitempty"`
	Cname            *string                                            `json:"Cname,omitempty" xml:"Cname,omitempty"`
	CustomCiphers    []*string                                          `json:"CustomCiphers,omitempty" xml:"CustomCiphers,omitempty" type:"Repeated"`
	Domain           *string                                            `json:"Domain,omitempty" xml:"Domain,omitempty"`
	GmCert           *DescribeWebRulesResponseBodyWebRulesGmCert        `json:"GmCert,omitempty" xml:"GmCert,omitempty" type:"Struct"`
	Http2Enable      *bool                                              `json:"Http2Enable,omitempty" xml:"Http2Enable,omitempty"`
	Http2HttpsEnable *bool                                              `json:"Http2HttpsEnable,omitempty" xml:"Http2HttpsEnable,omitempty"`
	Https2HttpEnable *bool                                              `json:"Https2HttpEnable,omitempty" xml:"Https2HttpEnable,omitempty"`
	OcspEnabled      *bool                                              `json:"OcspEnabled,omitempty" xml:"OcspEnabled,omitempty"`
	PolicyMode       *string                                            `json:"PolicyMode,omitempty" xml:"PolicyMode,omitempty"`
	ProxyEnabled     *bool                                              `json:"ProxyEnabled,omitempty" xml:"ProxyEnabled,omitempty"`
	ProxyTypes       []*DescribeWebRulesResponseBodyWebRulesProxyTypes  `json:"ProxyTypes,omitempty" xml:"ProxyTypes,omitempty" type:"Repeated"`
	PunishReason     *int32                                             `json:"PunishReason,omitempty" xml:"PunishReason,omitempty"`
	PunishStatus     *bool                                              `json:"PunishStatus,omitempty" xml:"PunishStatus,omitempty"`
	RealServers      []*DescribeWebRulesResponseBodyWebRulesRealServers `json:"RealServers,omitempty" xml:"RealServers,omitempty" type:"Repeated"`
	Ssl13Enabled     *bool                                              `json:"Ssl13Enabled,omitempty" xml:"Ssl13Enabled,omitempty"`
	SslCiphers       *string                                            `json:"SslCiphers,omitempty" xml:"SslCiphers,omitempty"`
	SslProtocols     *string                                            `json:"SslProtocols,omitempty" xml:"SslProtocols,omitempty"`
	WhiteList        []*string                                          `json:"WhiteList,omitempty" xml:"WhiteList,omitempty" type:"Repeated"`
}

func (s DescribeWebRulesResponseBodyWebRules) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebRulesResponseBodyWebRules) GoString() string {
	return s.String()
}

func (s *DescribeWebRulesResponseBodyWebRules) SetBlackList(v []*string) *DescribeWebRulesResponseBodyWebRules {
	s.BlackList = v
	return s
}

func (s *DescribeWebRulesResponseBodyWebRules) SetCcEnabled(v bool) *DescribeWebRulesResponseBodyWebRules {
	s.CcEnabled = &v
	return s
}

func (s *DescribeWebRulesResponseBodyWebRules) SetCcRuleEnabled(v bool) *DescribeWebRulesResponseBodyWebRules {
	s.CcRuleEnabled = &v
	return s
}

func (s *DescribeWebRulesResponseBodyWebRules) SetCcTemplate(v string) *DescribeWebRulesResponseBodyWebRules {
	s.CcTemplate = &v
	return s
}

func (s *DescribeWebRulesResponseBodyWebRules) SetCertName(v string) *DescribeWebRulesResponseBodyWebRules {
	s.CertName = &v
	return s
}

func (s *DescribeWebRulesResponseBodyWebRules) SetCertRegion(v string) *DescribeWebRulesResponseBodyWebRules {
	s.CertRegion = &v
	return s
}

func (s *DescribeWebRulesResponseBodyWebRules) SetCname(v string) *DescribeWebRulesResponseBodyWebRules {
	s.Cname = &v
	return s
}

func (s *DescribeWebRulesResponseBodyWebRules) SetCustomCiphers(v []*string) *DescribeWebRulesResponseBodyWebRules {
	s.CustomCiphers = v
	return s
}

func (s *DescribeWebRulesResponseBodyWebRules) SetDomain(v string) *DescribeWebRulesResponseBodyWebRules {
	s.Domain = &v
	return s
}

func (s *DescribeWebRulesResponseBodyWebRules) SetGmCert(v *DescribeWebRulesResponseBodyWebRulesGmCert) *DescribeWebRulesResponseBodyWebRules {
	s.GmCert = v
	return s
}

func (s *DescribeWebRulesResponseBodyWebRules) SetHttp2Enable(v bool) *DescribeWebRulesResponseBodyWebRules {
	s.Http2Enable = &v
	return s
}

func (s *DescribeWebRulesResponseBodyWebRules) SetHttp2HttpsEnable(v bool) *DescribeWebRulesResponseBodyWebRules {
	s.Http2HttpsEnable = &v
	return s
}

func (s *DescribeWebRulesResponseBodyWebRules) SetHttps2HttpEnable(v bool) *DescribeWebRulesResponseBodyWebRules {
	s.Https2HttpEnable = &v
	return s
}

func (s *DescribeWebRulesResponseBodyWebRules) SetOcspEnabled(v bool) *DescribeWebRulesResponseBodyWebRules {
	s.OcspEnabled = &v
	return s
}

func (s *DescribeWebRulesResponseBodyWebRules) SetPolicyMode(v string) *DescribeWebRulesResponseBodyWebRules {
	s.PolicyMode = &v
	return s
}

func (s *DescribeWebRulesResponseBodyWebRules) SetProxyEnabled(v bool) *DescribeWebRulesResponseBodyWebRules {
	s.ProxyEnabled = &v
	return s
}

func (s *DescribeWebRulesResponseBodyWebRules) SetProxyTypes(v []*DescribeWebRulesResponseBodyWebRulesProxyTypes) *DescribeWebRulesResponseBodyWebRules {
	s.ProxyTypes = v
	return s
}

func (s *DescribeWebRulesResponseBodyWebRules) SetPunishReason(v int32) *DescribeWebRulesResponseBodyWebRules {
	s.PunishReason = &v
	return s
}

func (s *DescribeWebRulesResponseBodyWebRules) SetPunishStatus(v bool) *DescribeWebRulesResponseBodyWebRules {
	s.PunishStatus = &v
	return s
}

func (s *DescribeWebRulesResponseBodyWebRules) SetRealServers(v []*DescribeWebRulesResponseBodyWebRulesRealServers) *DescribeWebRulesResponseBodyWebRules {
	s.RealServers = v
	return s
}

func (s *DescribeWebRulesResponseBodyWebRules) SetSsl13Enabled(v bool) *DescribeWebRulesResponseBodyWebRules {
	s.Ssl13Enabled = &v
	return s
}

func (s *DescribeWebRulesResponseBodyWebRules) SetSslCiphers(v string) *DescribeWebRulesResponseBodyWebRules {
	s.SslCiphers = &v
	return s
}

func (s *DescribeWebRulesResponseBodyWebRules) SetSslProtocols(v string) *DescribeWebRulesResponseBodyWebRules {
	s.SslProtocols = &v
	return s
}

func (s *DescribeWebRulesResponseBodyWebRules) SetWhiteList(v []*string) *DescribeWebRulesResponseBodyWebRules {
	s.WhiteList = v
	return s
}

type DescribeWebRulesResponseBodyWebRulesGmCert struct {
	CertId   *string `json:"CertId,omitempty" xml:"CertId,omitempty"`
	GmEnable *int64  `json:"GmEnable,omitempty" xml:"GmEnable,omitempty"`
	GmOnly   *int64  `json:"GmOnly,omitempty" xml:"GmOnly,omitempty"`
}

func (s DescribeWebRulesResponseBodyWebRulesGmCert) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebRulesResponseBodyWebRulesGmCert) GoString() string {
	return s.String()
}

func (s *DescribeWebRulesResponseBodyWebRulesGmCert) SetCertId(v string) *DescribeWebRulesResponseBodyWebRulesGmCert {
	s.CertId = &v
	return s
}

func (s *DescribeWebRulesResponseBodyWebRulesGmCert) SetGmEnable(v int64) *DescribeWebRulesResponseBodyWebRulesGmCert {
	s.GmEnable = &v
	return s
}

func (s *DescribeWebRulesResponseBodyWebRulesGmCert) SetGmOnly(v int64) *DescribeWebRulesResponseBodyWebRulesGmCert {
	s.GmOnly = &v
	return s
}

type DescribeWebRulesResponseBodyWebRulesProxyTypes struct {
	ProxyPorts []*string `json:"ProxyPorts,omitempty" xml:"ProxyPorts,omitempty" type:"Repeated"`
	ProxyType  *string   `json:"ProxyType,omitempty" xml:"ProxyType,omitempty"`
}

func (s DescribeWebRulesResponseBodyWebRulesProxyTypes) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebRulesResponseBodyWebRulesProxyTypes) GoString() string {
	return s.String()
}

func (s *DescribeWebRulesResponseBodyWebRulesProxyTypes) SetProxyPorts(v []*string) *DescribeWebRulesResponseBodyWebRulesProxyTypes {
	s.ProxyPorts = v
	return s
}

func (s *DescribeWebRulesResponseBodyWebRulesProxyTypes) SetProxyType(v string) *DescribeWebRulesResponseBodyWebRulesProxyTypes {
	s.ProxyType = &v
	return s
}

type DescribeWebRulesResponseBodyWebRulesRealServers struct {
	RealServer *string `json:"RealServer,omitempty" xml:"RealServer,omitempty"`
	RsType     *int32  `json:"RsType,omitempty" xml:"RsType,omitempty"`
}

func (s DescribeWebRulesResponseBodyWebRulesRealServers) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebRulesResponseBodyWebRulesRealServers) GoString() string {
	return s.String()
}

func (s *DescribeWebRulesResponseBodyWebRulesRealServers) SetRealServer(v string) *DescribeWebRulesResponseBodyWebRulesRealServers {
	s.RealServer = &v
	return s
}

func (s *DescribeWebRulesResponseBodyWebRulesRealServers) SetRsType(v int32) *DescribeWebRulesResponseBodyWebRulesRealServers {
	s.RsType = &v
	return s
}

type DescribeWebRulesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeWebRulesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeWebRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeWebRulesResponse) GoString() string {
	return s.String()
}

func (s *DescribeWebRulesResponse) SetHeaders(v map[string]*string) *DescribeWebRulesResponse {
	s.Headers = v
	return s
}

func (s *DescribeWebRulesResponse) SetStatusCode(v int32) *DescribeWebRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeWebRulesResponse) SetBody(v *DescribeWebRulesResponseBody) *DescribeWebRulesResponse {
	s.Body = v
	return s
}

type DetachSceneDefenseObjectRequest struct {
	// The type of the object. Set the value to **Domain**, which indicates a domain name.
	ObjectType *string `json:"ObjectType,omitempty" xml:"ObjectType,omitempty"`
	// The protection asset that you want to remove from a policy. Separate multiple protection assets with commas (,).
	Objects *string `json:"Objects,omitempty" xml:"Objects,omitempty"`
	// The ID of the policy.
	//
	// > You can call the [DescribeSceneDefensePolicies](~~159382~~) operation to query the IDs of all policies.
	PolicyId *string `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
}

func (s DetachSceneDefenseObjectRequest) String() string {
	return tea.Prettify(s)
}

func (s DetachSceneDefenseObjectRequest) GoString() string {
	return s.String()
}

func (s *DetachSceneDefenseObjectRequest) SetObjectType(v string) *DetachSceneDefenseObjectRequest {
	s.ObjectType = &v
	return s
}

func (s *DetachSceneDefenseObjectRequest) SetObjects(v string) *DetachSceneDefenseObjectRequest {
	s.Objects = &v
	return s
}

func (s *DetachSceneDefenseObjectRequest) SetPolicyId(v string) *DetachSceneDefenseObjectRequest {
	s.PolicyId = &v
	return s
}

type DetachSceneDefenseObjectResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DetachSceneDefenseObjectResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DetachSceneDefenseObjectResponseBody) GoString() string {
	return s.String()
}

func (s *DetachSceneDefenseObjectResponseBody) SetRequestId(v string) *DetachSceneDefenseObjectResponseBody {
	s.RequestId = &v
	return s
}

func (s *DetachSceneDefenseObjectResponseBody) SetSuccess(v bool) *DetachSceneDefenseObjectResponseBody {
	s.Success = &v
	return s
}

type DetachSceneDefenseObjectResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DetachSceneDefenseObjectResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DetachSceneDefenseObjectResponse) String() string {
	return tea.Prettify(s)
}

func (s DetachSceneDefenseObjectResponse) GoString() string {
	return s.String()
}

func (s *DetachSceneDefenseObjectResponse) SetHeaders(v map[string]*string) *DetachSceneDefenseObjectResponse {
	s.Headers = v
	return s
}

func (s *DetachSceneDefenseObjectResponse) SetStatusCode(v int32) *DetachSceneDefenseObjectResponse {
	s.StatusCode = &v
	return s
}

func (s *DetachSceneDefenseObjectResponse) SetBody(v *DetachSceneDefenseObjectResponseBody) *DetachSceneDefenseObjectResponse {
	s.Body = v
	return s
}

type DisableSceneDefensePolicyRequest struct {
	// The ID of the policy that you want to disable.
	//
	// > You can call the [DescribeSceneDefensePolicies](~~159382~~) operation to query the IDs of all policies.
	PolicyId *string `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
}

func (s DisableSceneDefensePolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s DisableSceneDefensePolicyRequest) GoString() string {
	return s.String()
}

func (s *DisableSceneDefensePolicyRequest) SetPolicyId(v string) *DisableSceneDefensePolicyRequest {
	s.PolicyId = &v
	return s
}

type DisableSceneDefensePolicyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DisableSceneDefensePolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DisableSceneDefensePolicyResponseBody) GoString() string {
	return s.String()
}

func (s *DisableSceneDefensePolicyResponseBody) SetRequestId(v string) *DisableSceneDefensePolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *DisableSceneDefensePolicyResponseBody) SetSuccess(v bool) *DisableSceneDefensePolicyResponseBody {
	s.Success = &v
	return s
}

type DisableSceneDefensePolicyResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DisableSceneDefensePolicyResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DisableSceneDefensePolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s DisableSceneDefensePolicyResponse) GoString() string {
	return s.String()
}

func (s *DisableSceneDefensePolicyResponse) SetHeaders(v map[string]*string) *DisableSceneDefensePolicyResponse {
	s.Headers = v
	return s
}

func (s *DisableSceneDefensePolicyResponse) SetStatusCode(v int32) *DisableSceneDefensePolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *DisableSceneDefensePolicyResponse) SetBody(v *DisableSceneDefensePolicyResponseBody) *DisableSceneDefensePolicyResponse {
	s.Body = v
	return s
}

type DisableWebAccessLogConfigRequest struct {
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DisableWebAccessLogConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DisableWebAccessLogConfigRequest) GoString() string {
	return s.String()
}

func (s *DisableWebAccessLogConfigRequest) SetDomain(v string) *DisableWebAccessLogConfigRequest {
	s.Domain = &v
	return s
}

func (s *DisableWebAccessLogConfigRequest) SetResourceGroupId(v string) *DisableWebAccessLogConfigRequest {
	s.ResourceGroupId = &v
	return s
}

type DisableWebAccessLogConfigResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DisableWebAccessLogConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DisableWebAccessLogConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DisableWebAccessLogConfigResponseBody) SetRequestId(v string) *DisableWebAccessLogConfigResponseBody {
	s.RequestId = &v
	return s
}

type DisableWebAccessLogConfigResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DisableWebAccessLogConfigResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DisableWebAccessLogConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DisableWebAccessLogConfigResponse) GoString() string {
	return s.String()
}

func (s *DisableWebAccessLogConfigResponse) SetHeaders(v map[string]*string) *DisableWebAccessLogConfigResponse {
	s.Headers = v
	return s
}

func (s *DisableWebAccessLogConfigResponse) SetStatusCode(v int32) *DisableWebAccessLogConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DisableWebAccessLogConfigResponse) SetBody(v *DisableWebAccessLogConfigResponseBody) *DisableWebAccessLogConfigResponse {
	s.Body = v
	return s
}

type DisableWebCCRequest struct {
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for a domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DisableWebCCRequest) String() string {
	return tea.Prettify(s)
}

func (s DisableWebCCRequest) GoString() string {
	return s.String()
}

func (s *DisableWebCCRequest) SetDomain(v string) *DisableWebCCRequest {
	s.Domain = &v
	return s
}

func (s *DisableWebCCRequest) SetResourceGroupId(v string) *DisableWebCCRequest {
	s.ResourceGroupId = &v
	return s
}

type DisableWebCCResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DisableWebCCResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DisableWebCCResponseBody) GoString() string {
	return s.String()
}

func (s *DisableWebCCResponseBody) SetRequestId(v string) *DisableWebCCResponseBody {
	s.RequestId = &v
	return s
}

type DisableWebCCResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DisableWebCCResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DisableWebCCResponse) String() string {
	return tea.Prettify(s)
}

func (s DisableWebCCResponse) GoString() string {
	return s.String()
}

func (s *DisableWebCCResponse) SetHeaders(v map[string]*string) *DisableWebCCResponse {
	s.Headers = v
	return s
}

func (s *DisableWebCCResponse) SetStatusCode(v int32) *DisableWebCCResponse {
	s.StatusCode = &v
	return s
}

func (s *DisableWebCCResponse) SetBody(v *DisableWebCCResponseBody) *DisableWebCCResponse {
	s.Body = v
	return s
}

type DisableWebCCRuleRequest struct {
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for a domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s DisableWebCCRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s DisableWebCCRuleRequest) GoString() string {
	return s.String()
}

func (s *DisableWebCCRuleRequest) SetDomain(v string) *DisableWebCCRuleRequest {
	s.Domain = &v
	return s
}

func (s *DisableWebCCRuleRequest) SetResourceGroupId(v string) *DisableWebCCRuleRequest {
	s.ResourceGroupId = &v
	return s
}

type DisableWebCCRuleResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DisableWebCCRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DisableWebCCRuleResponseBody) GoString() string {
	return s.String()
}

func (s *DisableWebCCRuleResponseBody) SetRequestId(v string) *DisableWebCCRuleResponseBody {
	s.RequestId = &v
	return s
}

type DisableWebCCRuleResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DisableWebCCRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DisableWebCCRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s DisableWebCCRuleResponse) GoString() string {
	return s.String()
}

func (s *DisableWebCCRuleResponse) SetHeaders(v map[string]*string) *DisableWebCCRuleResponse {
	s.Headers = v
	return s
}

func (s *DisableWebCCRuleResponse) SetStatusCode(v int32) *DisableWebCCRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *DisableWebCCRuleResponse) SetBody(v *DisableWebCCRuleResponseBody) *DisableWebCCRuleResponse {
	s.Body = v
	return s
}

type EmptyAutoCcBlacklistRequest struct {
	// The ID of the instance.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s EmptyAutoCcBlacklistRequest) String() string {
	return tea.Prettify(s)
}

func (s EmptyAutoCcBlacklistRequest) GoString() string {
	return s.String()
}

func (s *EmptyAutoCcBlacklistRequest) SetInstanceId(v string) *EmptyAutoCcBlacklistRequest {
	s.InstanceId = &v
	return s
}

type EmptyAutoCcBlacklistResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s EmptyAutoCcBlacklistResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EmptyAutoCcBlacklistResponseBody) GoString() string {
	return s.String()
}

func (s *EmptyAutoCcBlacklistResponseBody) SetRequestId(v string) *EmptyAutoCcBlacklistResponseBody {
	s.RequestId = &v
	return s
}

type EmptyAutoCcBlacklistResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *EmptyAutoCcBlacklistResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s EmptyAutoCcBlacklistResponse) String() string {
	return tea.Prettify(s)
}

func (s EmptyAutoCcBlacklistResponse) GoString() string {
	return s.String()
}

func (s *EmptyAutoCcBlacklistResponse) SetHeaders(v map[string]*string) *EmptyAutoCcBlacklistResponse {
	s.Headers = v
	return s
}

func (s *EmptyAutoCcBlacklistResponse) SetStatusCode(v int32) *EmptyAutoCcBlacklistResponse {
	s.StatusCode = &v
	return s
}

func (s *EmptyAutoCcBlacklistResponse) SetBody(v *EmptyAutoCcBlacklistResponseBody) *EmptyAutoCcBlacklistResponse {
	s.Body = v
	return s
}

type EmptyAutoCcWhitelistRequest struct {
	// The ID of the instance.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s EmptyAutoCcWhitelistRequest) String() string {
	return tea.Prettify(s)
}

func (s EmptyAutoCcWhitelistRequest) GoString() string {
	return s.String()
}

func (s *EmptyAutoCcWhitelistRequest) SetInstanceId(v string) *EmptyAutoCcWhitelistRequest {
	s.InstanceId = &v
	return s
}

type EmptyAutoCcWhitelistResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s EmptyAutoCcWhitelistResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EmptyAutoCcWhitelistResponseBody) GoString() string {
	return s.String()
}

func (s *EmptyAutoCcWhitelistResponseBody) SetRequestId(v string) *EmptyAutoCcWhitelistResponseBody {
	s.RequestId = &v
	return s
}

type EmptyAutoCcWhitelistResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *EmptyAutoCcWhitelistResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s EmptyAutoCcWhitelistResponse) String() string {
	return tea.Prettify(s)
}

func (s EmptyAutoCcWhitelistResponse) GoString() string {
	return s.String()
}

func (s *EmptyAutoCcWhitelistResponse) SetHeaders(v map[string]*string) *EmptyAutoCcWhitelistResponse {
	s.Headers = v
	return s
}

func (s *EmptyAutoCcWhitelistResponse) SetStatusCode(v int32) *EmptyAutoCcWhitelistResponse {
	s.StatusCode = &v
	return s
}

func (s *EmptyAutoCcWhitelistResponse) SetBody(v *EmptyAutoCcWhitelistResponseBody) *EmptyAutoCcWhitelistResponse {
	s.Body = v
	return s
}

type EmptySlsLogstoreRequest struct {
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s EmptySlsLogstoreRequest) String() string {
	return tea.Prettify(s)
}

func (s EmptySlsLogstoreRequest) GoString() string {
	return s.String()
}

func (s *EmptySlsLogstoreRequest) SetResourceGroupId(v string) *EmptySlsLogstoreRequest {
	s.ResourceGroupId = &v
	return s
}

type EmptySlsLogstoreResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s EmptySlsLogstoreResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EmptySlsLogstoreResponseBody) GoString() string {
	return s.String()
}

func (s *EmptySlsLogstoreResponseBody) SetRequestId(v string) *EmptySlsLogstoreResponseBody {
	s.RequestId = &v
	return s
}

type EmptySlsLogstoreResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *EmptySlsLogstoreResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s EmptySlsLogstoreResponse) String() string {
	return tea.Prettify(s)
}

func (s EmptySlsLogstoreResponse) GoString() string {
	return s.String()
}

func (s *EmptySlsLogstoreResponse) SetHeaders(v map[string]*string) *EmptySlsLogstoreResponse {
	s.Headers = v
	return s
}

func (s *EmptySlsLogstoreResponse) SetStatusCode(v int32) *EmptySlsLogstoreResponse {
	s.StatusCode = &v
	return s
}

func (s *EmptySlsLogstoreResponse) SetBody(v *EmptySlsLogstoreResponseBody) *EmptySlsLogstoreResponse {
	s.Body = v
	return s
}

type EnableSceneDefensePolicyRequest struct {
	// The ID of the policy that you want to enable.
	//
	// > You can call the [DescribeSceneDefensePolicies](~~159382~~) operation to query the IDs of all policies.
	PolicyId *string `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
}

func (s EnableSceneDefensePolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s EnableSceneDefensePolicyRequest) GoString() string {
	return s.String()
}

func (s *EnableSceneDefensePolicyRequest) SetPolicyId(v string) *EnableSceneDefensePolicyRequest {
	s.PolicyId = &v
	return s
}

type EnableSceneDefensePolicyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s EnableSceneDefensePolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EnableSceneDefensePolicyResponseBody) GoString() string {
	return s.String()
}

func (s *EnableSceneDefensePolicyResponseBody) SetRequestId(v string) *EnableSceneDefensePolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *EnableSceneDefensePolicyResponseBody) SetSuccess(v bool) *EnableSceneDefensePolicyResponseBody {
	s.Success = &v
	return s
}

type EnableSceneDefensePolicyResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *EnableSceneDefensePolicyResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s EnableSceneDefensePolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s EnableSceneDefensePolicyResponse) GoString() string {
	return s.String()
}

func (s *EnableSceneDefensePolicyResponse) SetHeaders(v map[string]*string) *EnableSceneDefensePolicyResponse {
	s.Headers = v
	return s
}

func (s *EnableSceneDefensePolicyResponse) SetStatusCode(v int32) *EnableSceneDefensePolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *EnableSceneDefensePolicyResponse) SetBody(v *EnableSceneDefensePolicyResponseBody) *EnableSceneDefensePolicyResponse {
	s.Body = v
	return s
}

type EnableWebAccessLogConfigRequest struct {
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s EnableWebAccessLogConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s EnableWebAccessLogConfigRequest) GoString() string {
	return s.String()
}

func (s *EnableWebAccessLogConfigRequest) SetDomain(v string) *EnableWebAccessLogConfigRequest {
	s.Domain = &v
	return s
}

func (s *EnableWebAccessLogConfigRequest) SetResourceGroupId(v string) *EnableWebAccessLogConfigRequest {
	s.ResourceGroupId = &v
	return s
}

type EnableWebAccessLogConfigResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s EnableWebAccessLogConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EnableWebAccessLogConfigResponseBody) GoString() string {
	return s.String()
}

func (s *EnableWebAccessLogConfigResponseBody) SetRequestId(v string) *EnableWebAccessLogConfigResponseBody {
	s.RequestId = &v
	return s
}

type EnableWebAccessLogConfigResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *EnableWebAccessLogConfigResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s EnableWebAccessLogConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s EnableWebAccessLogConfigResponse) GoString() string {
	return s.String()
}

func (s *EnableWebAccessLogConfigResponse) SetHeaders(v map[string]*string) *EnableWebAccessLogConfigResponse {
	s.Headers = v
	return s
}

func (s *EnableWebAccessLogConfigResponse) SetStatusCode(v int32) *EnableWebAccessLogConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *EnableWebAccessLogConfigResponse) SetBody(v *EnableWebAccessLogConfigResponseBody) *EnableWebAccessLogConfigResponse {
	s.Body = v
	return s
}

type EnableWebCCRequest struct {
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s EnableWebCCRequest) String() string {
	return tea.Prettify(s)
}

func (s EnableWebCCRequest) GoString() string {
	return s.String()
}

func (s *EnableWebCCRequest) SetDomain(v string) *EnableWebCCRequest {
	s.Domain = &v
	return s
}

func (s *EnableWebCCRequest) SetResourceGroupId(v string) *EnableWebCCRequest {
	s.ResourceGroupId = &v
	return s
}

type EnableWebCCResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s EnableWebCCResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EnableWebCCResponseBody) GoString() string {
	return s.String()
}

func (s *EnableWebCCResponseBody) SetRequestId(v string) *EnableWebCCResponseBody {
	s.RequestId = &v
	return s
}

type EnableWebCCResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *EnableWebCCResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s EnableWebCCResponse) String() string {
	return tea.Prettify(s)
}

func (s EnableWebCCResponse) GoString() string {
	return s.String()
}

func (s *EnableWebCCResponse) SetHeaders(v map[string]*string) *EnableWebCCResponse {
	s.Headers = v
	return s
}

func (s *EnableWebCCResponse) SetStatusCode(v int32) *EnableWebCCResponse {
	s.StatusCode = &v
	return s
}

func (s *EnableWebCCResponse) SetBody(v *EnableWebCCResponseBody) *EnableWebCCResponse {
	s.Body = v
	return s
}

type EnableWebCCRuleRequest struct {
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s EnableWebCCRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s EnableWebCCRuleRequest) GoString() string {
	return s.String()
}

func (s *EnableWebCCRuleRequest) SetDomain(v string) *EnableWebCCRuleRequest {
	s.Domain = &v
	return s
}

func (s *EnableWebCCRuleRequest) SetResourceGroupId(v string) *EnableWebCCRuleRequest {
	s.ResourceGroupId = &v
	return s
}

type EnableWebCCRuleResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s EnableWebCCRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EnableWebCCRuleResponseBody) GoString() string {
	return s.String()
}

func (s *EnableWebCCRuleResponseBody) SetRequestId(v string) *EnableWebCCRuleResponseBody {
	s.RequestId = &v
	return s
}

type EnableWebCCRuleResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *EnableWebCCRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s EnableWebCCRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s EnableWebCCRuleResponse) GoString() string {
	return s.String()
}

func (s *EnableWebCCRuleResponse) SetHeaders(v map[string]*string) *EnableWebCCRuleResponse {
	s.Headers = v
	return s
}

func (s *EnableWebCCRuleResponse) SetStatusCode(v int32) *EnableWebCCRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *EnableWebCCRuleResponse) SetBody(v *EnableWebCCRuleResponseBody) *EnableWebCCRuleResponse {
	s.Body = v
	return s
}

type ModifyBizBandWidthModeRequest struct {
	// The ID of the instance.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The metering method of the burstable clean bandwidth feature. Valid values:
	//
	// *   **month**: the metering method of monthly 95th percentile
	// *   **day**: the metering method of daily 95th percentile
	Mode *string `json:"Mode,omitempty" xml:"Mode,omitempty"`
}

func (s ModifyBizBandWidthModeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyBizBandWidthModeRequest) GoString() string {
	return s.String()
}

func (s *ModifyBizBandWidthModeRequest) SetInstanceId(v string) *ModifyBizBandWidthModeRequest {
	s.InstanceId = &v
	return s
}

func (s *ModifyBizBandWidthModeRequest) SetMode(v string) *ModifyBizBandWidthModeRequest {
	s.Mode = &v
	return s
}

type ModifyBizBandWidthModeResponseBody struct {
	// The ID of the request, which is used to locate and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyBizBandWidthModeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyBizBandWidthModeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyBizBandWidthModeResponseBody) SetRequestId(v string) *ModifyBizBandWidthModeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyBizBandWidthModeResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyBizBandWidthModeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyBizBandWidthModeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyBizBandWidthModeResponse) GoString() string {
	return s.String()
}

func (s *ModifyBizBandWidthModeResponse) SetHeaders(v map[string]*string) *ModifyBizBandWidthModeResponse {
	s.Headers = v
	return s
}

func (s *ModifyBizBandWidthModeResponse) SetStatusCode(v int32) *ModifyBizBandWidthModeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyBizBandWidthModeResponse) SetBody(v *ModifyBizBandWidthModeResponseBody) *ModifyBizBandWidthModeResponse {
	s.Body = v
	return s
}

type ModifyBlackholeStatusRequest struct {
	// The action that you want to perform on the instance. Set the value to **undo**, which indicates that you want to deactivate blackhole filtering.
	BlackholeStatus *string `json:"BlackholeStatus,omitempty" xml:"BlackholeStatus,omitempty"`
	// The ID of the instance.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s ModifyBlackholeStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyBlackholeStatusRequest) GoString() string {
	return s.String()
}

func (s *ModifyBlackholeStatusRequest) SetBlackholeStatus(v string) *ModifyBlackholeStatusRequest {
	s.BlackholeStatus = &v
	return s
}

func (s *ModifyBlackholeStatusRequest) SetInstanceId(v string) *ModifyBlackholeStatusRequest {
	s.InstanceId = &v
	return s
}

type ModifyBlackholeStatusResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyBlackholeStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyBlackholeStatusResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyBlackholeStatusResponseBody) SetRequestId(v string) *ModifyBlackholeStatusResponseBody {
	s.RequestId = &v
	return s
}

type ModifyBlackholeStatusResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyBlackholeStatusResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyBlackholeStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyBlackholeStatusResponse) GoString() string {
	return s.String()
}

func (s *ModifyBlackholeStatusResponse) SetHeaders(v map[string]*string) *ModifyBlackholeStatusResponse {
	s.Headers = v
	return s
}

func (s *ModifyBlackholeStatusResponse) SetStatusCode(v int32) *ModifyBlackholeStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyBlackholeStatusResponse) SetBody(v *ModifyBlackholeStatusResponseBody) *ModifyBlackholeStatusResponse {
	s.Body = v
	return s
}

type ModifyBlockStatusRequest struct {
	// The blocking period. Valid values: **15** to **43200**. Unit: minutes.
	//
	// > If you set **Status** to **do**, you must also specify this parameter.
	Duration *int32 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The ID of the Anti-DDoS Pro instance to manage.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// An array consisting of the Internet service provider (ISP) lines from which traffic is blocked.
	Lines []*string `json:"Lines,omitempty" xml:"Lines,omitempty" type:"Repeated"`
	// Specifies the status of the Diversion from Origin Server policy. Valid values:
	//
	// *   **do**: enables the policy.
	// *   **undo**: disables the policy.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ModifyBlockStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyBlockStatusRequest) GoString() string {
	return s.String()
}

func (s *ModifyBlockStatusRequest) SetDuration(v int32) *ModifyBlockStatusRequest {
	s.Duration = &v
	return s
}

func (s *ModifyBlockStatusRequest) SetInstanceId(v string) *ModifyBlockStatusRequest {
	s.InstanceId = &v
	return s
}

func (s *ModifyBlockStatusRequest) SetLines(v []*string) *ModifyBlockStatusRequest {
	s.Lines = v
	return s
}

func (s *ModifyBlockStatusRequest) SetStatus(v string) *ModifyBlockStatusRequest {
	s.Status = &v
	return s
}

type ModifyBlockStatusResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyBlockStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyBlockStatusResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyBlockStatusResponseBody) SetRequestId(v string) *ModifyBlockStatusResponseBody {
	s.RequestId = &v
	return s
}

type ModifyBlockStatusResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyBlockStatusResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyBlockStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyBlockStatusResponse) GoString() string {
	return s.String()
}

func (s *ModifyBlockStatusResponse) SetHeaders(v map[string]*string) *ModifyBlockStatusResponse {
	s.Headers = v
	return s
}

func (s *ModifyBlockStatusResponse) SetStatusCode(v int32) *ModifyBlockStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyBlockStatusResponse) SetBody(v *ModifyBlockStatusResponseBody) *ModifyBlockStatusResponse {
	s.Body = v
	return s
}

type ModifyCnameReuseRequest struct {
	// The CNAME record that you want to reuse for the website.
	Cname *string `json:"Cname,omitempty" xml:"Cname,omitempty"`
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// Specifies whether to enable CNAME reuse. Valid values:
	//
	// *   **1**: enables CNAME reuse.
	// *   **2**: disables CNAME reuse.
	Enable *int32 `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s ModifyCnameReuseRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyCnameReuseRequest) GoString() string {
	return s.String()
}

func (s *ModifyCnameReuseRequest) SetCname(v string) *ModifyCnameReuseRequest {
	s.Cname = &v
	return s
}

func (s *ModifyCnameReuseRequest) SetDomain(v string) *ModifyCnameReuseRequest {
	s.Domain = &v
	return s
}

func (s *ModifyCnameReuseRequest) SetEnable(v int32) *ModifyCnameReuseRequest {
	s.Enable = &v
	return s
}

func (s *ModifyCnameReuseRequest) SetResourceGroupId(v string) *ModifyCnameReuseRequest {
	s.ResourceGroupId = &v
	return s
}

type ModifyCnameReuseResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyCnameReuseResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyCnameReuseResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyCnameReuseResponseBody) SetRequestId(v string) *ModifyCnameReuseResponseBody {
	s.RequestId = &v
	return s
}

type ModifyCnameReuseResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyCnameReuseResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyCnameReuseResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyCnameReuseResponse) GoString() string {
	return s.String()
}

func (s *ModifyCnameReuseResponse) SetHeaders(v map[string]*string) *ModifyCnameReuseResponse {
	s.Headers = v
	return s
}

func (s *ModifyCnameReuseResponse) SetStatusCode(v int32) *ModifyCnameReuseResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyCnameReuseResponse) SetBody(v *ModifyCnameReuseResponseBody) *ModifyCnameReuseResponse {
	s.Body = v
	return s
}

type ModifyDomainResourceRequest struct {
	// The domain name that is added to the Anti-DDoS Pro or Anti-DDoS Premium instance.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The advanced HTTPS settings. This parameter takes effect only when the value of the **ProxyType** parameter includes **https**. The value is a string that consists of a JSON struct. The JSON struct contains the following fields:
	//
	// *   **Http2https**: specifies whether to turn on Enforce HTTPS Routing. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enforce HTTPS Routing is turned off. The value 1 indicates that Enforce HTTPS Routing is turned on. The default value is 0.
	//
	//     If your website supports both HTTP and HTTPS, this feature meets your business requirements. If you enable this feature, all HTTP requests to access the website are redirected to HTTPS requests on the standard port 443.
	//
	// *   **Https2http**: specifies whether to turn on Enable HTTP. This field is optional and must be an integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTP is turned off. The value 1 indicates that Enable HTTP is turned on. The default value is 0.
	//
	//     If your website does not support HTTPS, this feature meets your business requirements If this feature is enabled, all HTTPS requests are redirected to HTTP requests and forwarded to origin servers. This feature can redirect WebSockets requests to WebSocket requests. Requests are redirected over the standard port 80.
	//
	// *   **Http2**: specifies whether to turn on Enable HTTP/2. This field is optional. Data type: integer. Valid values: **0** and **1**. The value 0 indicates that Enable HTTP/2 is turned off. The value 1 indicates that Enable HTTP/2 is turned on. The default value is 0.
	//
	//     After you turn on the switch, HTTP/2 is used.
	HttpsExt *string `json:"HttpsExt,omitempty" xml:"HttpsExt,omitempty"`
	// An array consisting of the IDs of instances that you want to associate.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	// An array that consists of the details of the protocol type and port number.
	ProxyTypes []*ModifyDomainResourceRequestProxyTypes `json:"ProxyTypes,omitempty" xml:"ProxyTypes,omitempty" type:"Repeated"`
	// An array that consists of the addresses of origin servers.
	RealServers []*string `json:"RealServers,omitempty" xml:"RealServers,omitempty" type:"Repeated"`
	// The address type of the origin server. Valid values:
	//
	// *   **0**: IP address
	//
	// *   **1**: domain name
	//
	//     If you deploy proxies, such as a Web Application Firewall (WAF) instance, between the origin server and the Anti-DDoS Pro or Anti-DDoS Premium instance, set the value to 1. If you use the domain name, you must enter the address of the proxy, such as the CNAME of WAF.
	RsType *int32 `json:"RsType,omitempty" xml:"RsType,omitempty"`
}

func (s ModifyDomainResourceRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyDomainResourceRequest) GoString() string {
	return s.String()
}

func (s *ModifyDomainResourceRequest) SetDomain(v string) *ModifyDomainResourceRequest {
	s.Domain = &v
	return s
}

func (s *ModifyDomainResourceRequest) SetHttpsExt(v string) *ModifyDomainResourceRequest {
	s.HttpsExt = &v
	return s
}

func (s *ModifyDomainResourceRequest) SetInstanceIds(v []*string) *ModifyDomainResourceRequest {
	s.InstanceIds = v
	return s
}

func (s *ModifyDomainResourceRequest) SetProxyTypes(v []*ModifyDomainResourceRequestProxyTypes) *ModifyDomainResourceRequest {
	s.ProxyTypes = v
	return s
}

func (s *ModifyDomainResourceRequest) SetRealServers(v []*string) *ModifyDomainResourceRequest {
	s.RealServers = v
	return s
}

func (s *ModifyDomainResourceRequest) SetRsType(v int32) *ModifyDomainResourceRequest {
	s.RsType = &v
	return s
}

type ModifyDomainResourceRequestProxyTypes struct {
	// An array that consists of port numbers.
	ProxyPorts []*int32 `json:"ProxyPorts,omitempty" xml:"ProxyPorts,omitempty" type:"Repeated"`
	// The type of the protocol. Valid values:
	//
	// *   **http**
	// *   **https**
	// *   **websocket**
	// *   **websockets**
	ProxyType *string `json:"ProxyType,omitempty" xml:"ProxyType,omitempty"`
}

func (s ModifyDomainResourceRequestProxyTypes) String() string {
	return tea.Prettify(s)
}

func (s ModifyDomainResourceRequestProxyTypes) GoString() string {
	return s.String()
}

func (s *ModifyDomainResourceRequestProxyTypes) SetProxyPorts(v []*int32) *ModifyDomainResourceRequestProxyTypes {
	s.ProxyPorts = v
	return s
}

func (s *ModifyDomainResourceRequestProxyTypes) SetProxyType(v string) *ModifyDomainResourceRequestProxyTypes {
	s.ProxyType = &v
	return s
}

type ModifyDomainResourceResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyDomainResourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyDomainResourceResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyDomainResourceResponseBody) SetRequestId(v string) *ModifyDomainResourceResponseBody {
	s.RequestId = &v
	return s
}

type ModifyDomainResourceResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyDomainResourceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyDomainResourceResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyDomainResourceResponse) GoString() string {
	return s.String()
}

func (s *ModifyDomainResourceResponse) SetHeaders(v map[string]*string) *ModifyDomainResourceResponse {
	s.Headers = v
	return s
}

func (s *ModifyDomainResourceResponse) SetStatusCode(v int32) *ModifyDomainResourceResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyDomainResourceResponse) SetBody(v *ModifyDomainResourceResponseBody) *ModifyDomainResourceResponse {
	s.Body = v
	return s
}

type ModifyElasticBandWidthRequest struct {
	// The new burstable protection bandwidth that you want to use. Unit: Gbit/s.
	//
	// > You can call the [DescribeElasticBandwidthSpec](~~91502~~) operation to query the available burstable protection bandwidth of the instance.
	ElasticBandwidth *int32 `json:"ElasticBandwidth,omitempty" xml:"ElasticBandwidth,omitempty"`
	// The ID of the instance.
	//
	// >  The instance must be in a normal state. You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s ModifyElasticBandWidthRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyElasticBandWidthRequest) GoString() string {
	return s.String()
}

func (s *ModifyElasticBandWidthRequest) SetElasticBandwidth(v int32) *ModifyElasticBandWidthRequest {
	s.ElasticBandwidth = &v
	return s
}

func (s *ModifyElasticBandWidthRequest) SetInstanceId(v string) *ModifyElasticBandWidthRequest {
	s.InstanceId = &v
	return s
}

type ModifyElasticBandWidthResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyElasticBandWidthResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyElasticBandWidthResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyElasticBandWidthResponseBody) SetRequestId(v string) *ModifyElasticBandWidthResponseBody {
	s.RequestId = &v
	return s
}

type ModifyElasticBandWidthResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyElasticBandWidthResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyElasticBandWidthResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyElasticBandWidthResponse) GoString() string {
	return s.String()
}

func (s *ModifyElasticBandWidthResponse) SetHeaders(v map[string]*string) *ModifyElasticBandWidthResponse {
	s.Headers = v
	return s
}

func (s *ModifyElasticBandWidthResponse) SetStatusCode(v int32) *ModifyElasticBandWidthResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyElasticBandWidthResponse) SetBody(v *ModifyElasticBandWidthResponseBody) *ModifyElasticBandWidthResponse {
	s.Body = v
	return s
}

type ModifyElasticBizBandWidthRequest struct {
	// The burstable clean bandwidth. Unit: Mbit/s. The burstable clean bandwidth cannot exceed nine times the clean bandwidth of your Anti-DDoS Pro or Anti-DDoS Premium instance, and the sum of the clean bandwidth and the burstable clean bandwidth cannot exceed the maximum clean bandwidth that is supported by your instance. The value 0 indicates that the burstable clean bandwidth feature is disabled. You can disable the burstable clean bandwidth feature once a month.
	ElasticBizBandwidth *int32 `json:"ElasticBizBandwidth,omitempty" xml:"ElasticBizBandwidth,omitempty"`
	// The ID of the instance.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The metering method of the burstable clean bandwidth feature. Valid values:
	//
	// *   **month**: the metering method of monthly 95th percentile
	// *   **day**: the metering method of daily 95th percentile
	Mode *string `json:"Mode,omitempty" xml:"Mode,omitempty"`
}

func (s ModifyElasticBizBandWidthRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyElasticBizBandWidthRequest) GoString() string {
	return s.String()
}

func (s *ModifyElasticBizBandWidthRequest) SetElasticBizBandwidth(v int32) *ModifyElasticBizBandWidthRequest {
	s.ElasticBizBandwidth = &v
	return s
}

func (s *ModifyElasticBizBandWidthRequest) SetInstanceId(v string) *ModifyElasticBizBandWidthRequest {
	s.InstanceId = &v
	return s
}

func (s *ModifyElasticBizBandWidthRequest) SetMode(v string) *ModifyElasticBizBandWidthRequest {
	s.Mode = &v
	return s
}

type ModifyElasticBizBandWidthResponseBody struct {
	// The ID of the request, which is used to locate and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyElasticBizBandWidthResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyElasticBizBandWidthResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyElasticBizBandWidthResponseBody) SetRequestId(v string) *ModifyElasticBizBandWidthResponseBody {
	s.RequestId = &v
	return s
}

type ModifyElasticBizBandWidthResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyElasticBizBandWidthResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyElasticBizBandWidthResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyElasticBizBandWidthResponse) GoString() string {
	return s.String()
}

func (s *ModifyElasticBizBandWidthResponse) SetHeaders(v map[string]*string) *ModifyElasticBizBandWidthResponse {
	s.Headers = v
	return s
}

func (s *ModifyElasticBizBandWidthResponse) SetStatusCode(v int32) *ModifyElasticBizBandWidthResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyElasticBizBandWidthResponse) SetBody(v *ModifyElasticBizBandWidthResponseBody) *ModifyElasticBizBandWidthResponse {
	s.Body = v
	return s
}

type ModifyElasticBizQpsRequest struct {
	InstanceId    *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	Mode          *string `json:"Mode,omitempty" xml:"Mode,omitempty"`
	OpsElasticQps *int64  `json:"OpsElasticQps,omitempty" xml:"OpsElasticQps,omitempty"`
}

func (s ModifyElasticBizQpsRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyElasticBizQpsRequest) GoString() string {
	return s.String()
}

func (s *ModifyElasticBizQpsRequest) SetInstanceId(v string) *ModifyElasticBizQpsRequest {
	s.InstanceId = &v
	return s
}

func (s *ModifyElasticBizQpsRequest) SetMode(v string) *ModifyElasticBizQpsRequest {
	s.Mode = &v
	return s
}

func (s *ModifyElasticBizQpsRequest) SetOpsElasticQps(v int64) *ModifyElasticBizQpsRequest {
	s.OpsElasticQps = &v
	return s
}

type ModifyElasticBizQpsResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyElasticBizQpsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyElasticBizQpsResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyElasticBizQpsResponseBody) SetRequestId(v string) *ModifyElasticBizQpsResponseBody {
	s.RequestId = &v
	return s
}

type ModifyElasticBizQpsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyElasticBizQpsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyElasticBizQpsResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyElasticBizQpsResponse) GoString() string {
	return s.String()
}

func (s *ModifyElasticBizQpsResponse) SetHeaders(v map[string]*string) *ModifyElasticBizQpsResponse {
	s.Headers = v
	return s
}

func (s *ModifyElasticBizQpsResponse) SetStatusCode(v int32) *ModifyElasticBizQpsResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyElasticBizQpsResponse) SetBody(v *ModifyElasticBizQpsResponseBody) *ModifyElasticBizQpsResponse {
	s.Body = v
	return s
}

type ModifyFullLogTtlRequest struct {
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The log storage duration of a website. Valid values: **30** to **180**. Unit: days.
	Ttl *int32 `json:"Ttl,omitempty" xml:"Ttl,omitempty"`
}

func (s ModifyFullLogTtlRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyFullLogTtlRequest) GoString() string {
	return s.String()
}

func (s *ModifyFullLogTtlRequest) SetResourceGroupId(v string) *ModifyFullLogTtlRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ModifyFullLogTtlRequest) SetTtl(v int32) *ModifyFullLogTtlRequest {
	s.Ttl = &v
	return s
}

type ModifyFullLogTtlResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyFullLogTtlResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyFullLogTtlResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyFullLogTtlResponseBody) SetRequestId(v string) *ModifyFullLogTtlResponseBody {
	s.RequestId = &v
	return s
}

type ModifyFullLogTtlResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyFullLogTtlResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyFullLogTtlResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyFullLogTtlResponse) GoString() string {
	return s.String()
}

func (s *ModifyFullLogTtlResponse) SetHeaders(v map[string]*string) *ModifyFullLogTtlResponse {
	s.Headers = v
	return s
}

func (s *ModifyFullLogTtlResponse) SetStatusCode(v int32) *ModifyFullLogTtlResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyFullLogTtlResponse) SetBody(v *ModifyFullLogTtlResponseBody) *ModifyFullLogTtlResponse {
	s.Body = v
	return s
}

type ModifyHeadersRequest struct {
	// The key-value pair of the custom header. Key indicates the header name and Value indicates the header value. You can specify up to five key-value pairs. The key-value pairs can be up to 200 characters in length.
	//
	// Take note of the following items:
	//
	// *   Do not use X-Forwarded-ClientSrcPort as a custom header.
	// *   Do not use a standard HTTP header such as User-Agent. If you use a standard HTTP header, the original header may be overwritten.
	//
	// > If you set Key to X-Forwarded-ClientSrcPort, the actual source port of the client that accesses Anti-DDoS Pro or Anti-DDoS Premium (a Layer 7 proxy) is obtained. In this case, the Value is "".
	CustomHeaders *string `json:"CustomHeaders,omitempty" xml:"CustomHeaders,omitempty"`
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The ID of the resource group to which the instance belongs.
	//
	// >
	//
	// *   You can query resource group IDs in the Anti-DDoS Pro or Anti-DDoS Premium console or by calling the [ListResourceGroups](~~158855~~) operation. For more information, see [View basic information of a resource group](~~151181~~).
	//
	// *   Before you modify the resource group to which an instance belongs, you can call the [ListResources](~~158866~~) operation to view the current resource group of the instance.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s ModifyHeadersRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyHeadersRequest) GoString() string {
	return s.String()
}

func (s *ModifyHeadersRequest) SetCustomHeaders(v string) *ModifyHeadersRequest {
	s.CustomHeaders = &v
	return s
}

func (s *ModifyHeadersRequest) SetDomain(v string) *ModifyHeadersRequest {
	s.Domain = &v
	return s
}

func (s *ModifyHeadersRequest) SetResourceGroupId(v string) *ModifyHeadersRequest {
	s.ResourceGroupId = &v
	return s
}

type ModifyHeadersResponseBody struct {
	// The unique ID of the request, which is used to locate and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyHeadersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyHeadersResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyHeadersResponseBody) SetRequestId(v string) *ModifyHeadersResponseBody {
	s.RequestId = &v
	return s
}

type ModifyHeadersResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyHeadersResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyHeadersResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyHeadersResponse) GoString() string {
	return s.String()
}

func (s *ModifyHeadersResponse) SetHeaders(v map[string]*string) *ModifyHeadersResponse {
	s.Headers = v
	return s
}

func (s *ModifyHeadersResponse) SetStatusCode(v int32) *ModifyHeadersResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyHeadersResponse) SetBody(v *ModifyHeadersResponseBody) *ModifyHeadersResponse {
	s.Body = v
	return s
}

type ModifyHealthCheckConfigRequest struct {
	// The forwarding protocol. Valid values:
	//
	// *   **tcp**
	// *   **udp**
	ForwardProtocol *string `json:"ForwardProtocol,omitempty" xml:"ForwardProtocol,omitempty"`
	// The forwarding port.
	FrontendPort *int32 `json:"FrontendPort,omitempty" xml:"FrontendPort,omitempty"`
	// The details of the health check configuration. This parameter is a JSON string. The string contains the following fields:
	//
	// *   **Type**: the protocol type. This field is required and must be of the STRING type. Valid values: **tcp** (Layer 4) and **http** (Layer 7).
	//
	// *   **Domain**: the domain name, which must be of the STRING type.
	//
	//     **
	//
	//     **Note**This parameter is returned only when the Layer 7 health check configuration is queried.
	//
	// *   **Uri**: the check path, which must be of the STRING type.
	//
	//     **
	//
	//     **Note**This parameter is returned only when the Layer 7 health check configuration is queried.
	//
	// *   **Timeout**: the response timeout period, which must be of the INTEGER type. Valid values: **1** to **30**. Unit: seconds.
	//
	// *   **Port**: the port on which you want to perform the health check, which must be of the INTEGER type.
	//
	// *   **Interval**: the health check interval, which must be of the INTEGER type. Valid values: **1** to **30**. Unit: seconds.
	//
	// *   **Up**: the number of consecutive successful health checks that must occur before declaring a port healthy, which must be of the INTEGER type. Valid values: **1** to **10**.
	//
	// *   **Down**: the number of consecutive failed health checks that must occur before declaring a port unhealthy, which must be of the INTEGER type. Valid values: **1** to **10**.
	HealthCheck *string `json:"HealthCheck,omitempty" xml:"HealthCheck,omitempty"`
	// The ID of the instance.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s ModifyHealthCheckConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyHealthCheckConfigRequest) GoString() string {
	return s.String()
}

func (s *ModifyHealthCheckConfigRequest) SetForwardProtocol(v string) *ModifyHealthCheckConfigRequest {
	s.ForwardProtocol = &v
	return s
}

func (s *ModifyHealthCheckConfigRequest) SetFrontendPort(v int32) *ModifyHealthCheckConfigRequest {
	s.FrontendPort = &v
	return s
}

func (s *ModifyHealthCheckConfigRequest) SetHealthCheck(v string) *ModifyHealthCheckConfigRequest {
	s.HealthCheck = &v
	return s
}

func (s *ModifyHealthCheckConfigRequest) SetInstanceId(v string) *ModifyHealthCheckConfigRequest {
	s.InstanceId = &v
	return s
}

type ModifyHealthCheckConfigResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyHealthCheckConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyHealthCheckConfigResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyHealthCheckConfigResponseBody) SetRequestId(v string) *ModifyHealthCheckConfigResponseBody {
	s.RequestId = &v
	return s
}

type ModifyHealthCheckConfigResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyHealthCheckConfigResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyHealthCheckConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyHealthCheckConfigResponse) GoString() string {
	return s.String()
}

func (s *ModifyHealthCheckConfigResponse) SetHeaders(v map[string]*string) *ModifyHealthCheckConfigResponse {
	s.Headers = v
	return s
}

func (s *ModifyHealthCheckConfigResponse) SetStatusCode(v int32) *ModifyHealthCheckConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyHealthCheckConfigResponse) SetBody(v *ModifyHealthCheckConfigResponseBody) *ModifyHealthCheckConfigResponse {
	s.Body = v
	return s
}

type ModifyHttp2EnableRequest struct {
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for the domain name, and the domain name must be associated with an instance that uses the Enhanced function plan. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// Specifies whether to enable HTTP/2. Valid values:
	//
	// *   **0**: disables HTTP/2.
	// *   **1**: enables HTTP/2.
	Enable *int32 `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s ModifyHttp2EnableRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyHttp2EnableRequest) GoString() string {
	return s.String()
}

func (s *ModifyHttp2EnableRequest) SetDomain(v string) *ModifyHttp2EnableRequest {
	s.Domain = &v
	return s
}

func (s *ModifyHttp2EnableRequest) SetEnable(v int32) *ModifyHttp2EnableRequest {
	s.Enable = &v
	return s
}

func (s *ModifyHttp2EnableRequest) SetResourceGroupId(v string) *ModifyHttp2EnableRequest {
	s.ResourceGroupId = &v
	return s
}

type ModifyHttp2EnableResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyHttp2EnableResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyHttp2EnableResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyHttp2EnableResponseBody) SetRequestId(v string) *ModifyHttp2EnableResponseBody {
	s.RequestId = &v
	return s
}

type ModifyHttp2EnableResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyHttp2EnableResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyHttp2EnableResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyHttp2EnableResponse) GoString() string {
	return s.String()
}

func (s *ModifyHttp2EnableResponse) SetHeaders(v map[string]*string) *ModifyHttp2EnableResponse {
	s.Headers = v
	return s
}

func (s *ModifyHttp2EnableResponse) SetStatusCode(v int32) *ModifyHttp2EnableResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyHttp2EnableResponse) SetBody(v *ModifyHttp2EnableResponseBody) *ModifyHttp2EnableResponse {
	s.Body = v
	return s
}

type ModifyInstanceRemarkRequest struct {
	// The ID of the instance.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The description of the instance.
	//
	// The value can contain letters, digits, and some special characters, such as`, . + - * / _` The value can be up to 500 characters in length.
	Remark *string `json:"Remark,omitempty" xml:"Remark,omitempty"`
}

func (s ModifyInstanceRemarkRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyInstanceRemarkRequest) GoString() string {
	return s.String()
}

func (s *ModifyInstanceRemarkRequest) SetInstanceId(v string) *ModifyInstanceRemarkRequest {
	s.InstanceId = &v
	return s
}

func (s *ModifyInstanceRemarkRequest) SetRemark(v string) *ModifyInstanceRemarkRequest {
	s.Remark = &v
	return s
}

type ModifyInstanceRemarkResponseBody struct {
	// The ID of the request, which is used to locate and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyInstanceRemarkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyInstanceRemarkResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyInstanceRemarkResponseBody) SetRequestId(v string) *ModifyInstanceRemarkResponseBody {
	s.RequestId = &v
	return s
}

type ModifyInstanceRemarkResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyInstanceRemarkResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyInstanceRemarkResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyInstanceRemarkResponse) GoString() string {
	return s.String()
}

func (s *ModifyInstanceRemarkResponse) SetHeaders(v map[string]*string) *ModifyInstanceRemarkResponse {
	s.Headers = v
	return s
}

func (s *ModifyInstanceRemarkResponse) SetStatusCode(v int32) *ModifyInstanceRemarkResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyInstanceRemarkResponse) SetBody(v *ModifyInstanceRemarkResponseBody) *ModifyInstanceRemarkResponse {
	s.Body = v
	return s
}

type ModifyNetworkRuleAttributeRequest struct {
	// The session persistence settings of the port forwarding rule. This parameter is a JSON string. The string contains the following fields:
	//
	// *   **PersistenceTimeout**: The timeout period of session persistence. This field is required and must be of the integer type. Valid values: **30** to **3600**. Unit: seconds. Default value: **0**. A value of 0 indicates that session persistence is disabled.
	Config *string `json:"Config,omitempty" xml:"Config,omitempty"`
	// The forwarding protocol. Valid values:
	//
	// *   **tcp**
	// *   **udp**
	ForwardProtocol *string `json:"ForwardProtocol,omitempty" xml:"ForwardProtocol,omitempty"`
	// The forwarding port.
	FrontendPort *int32 `json:"FrontendPort,omitempty" xml:"FrontendPort,omitempty"`
	// The ID of the instance.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s ModifyNetworkRuleAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyNetworkRuleAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyNetworkRuleAttributeRequest) SetConfig(v string) *ModifyNetworkRuleAttributeRequest {
	s.Config = &v
	return s
}

func (s *ModifyNetworkRuleAttributeRequest) SetForwardProtocol(v string) *ModifyNetworkRuleAttributeRequest {
	s.ForwardProtocol = &v
	return s
}

func (s *ModifyNetworkRuleAttributeRequest) SetFrontendPort(v int32) *ModifyNetworkRuleAttributeRequest {
	s.FrontendPort = &v
	return s
}

func (s *ModifyNetworkRuleAttributeRequest) SetInstanceId(v string) *ModifyNetworkRuleAttributeRequest {
	s.InstanceId = &v
	return s
}

type ModifyNetworkRuleAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyNetworkRuleAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyNetworkRuleAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyNetworkRuleAttributeResponseBody) SetRequestId(v string) *ModifyNetworkRuleAttributeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyNetworkRuleAttributeResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyNetworkRuleAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyNetworkRuleAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyNetworkRuleAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyNetworkRuleAttributeResponse) SetHeaders(v map[string]*string) *ModifyNetworkRuleAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyNetworkRuleAttributeResponse) SetStatusCode(v int32) *ModifyNetworkRuleAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyNetworkRuleAttributeResponse) SetBody(v *ModifyNetworkRuleAttributeResponseBody) *ModifyNetworkRuleAttributeResponse {
	s.Body = v
	return s
}

type ModifyOcspStatusRequest struct {
	// The domain name for which you want to configure the Static Page Caching policy.
	//
	// > You can call the [DescribeDomains](~~91724~~) operation to query all the domain names that are added to Anti-DDoS Pro or Anti-DDoS Premium.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// Specifies whether to enable the OCSP feature. Valid values:
	//
	// *   **1**: yes
	// *   **0**: no
	Enable *int32 `json:"Enable,omitempty" xml:"Enable,omitempty"`
}

func (s ModifyOcspStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyOcspStatusRequest) GoString() string {
	return s.String()
}

func (s *ModifyOcspStatusRequest) SetDomain(v string) *ModifyOcspStatusRequest {
	s.Domain = &v
	return s
}

func (s *ModifyOcspStatusRequest) SetEnable(v int32) *ModifyOcspStatusRequest {
	s.Enable = &v
	return s
}

type ModifyOcspStatusResponseBody struct {
	// The ID of the request, which is used to locate and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyOcspStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyOcspStatusResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyOcspStatusResponseBody) SetRequestId(v string) *ModifyOcspStatusResponseBody {
	s.RequestId = &v
	return s
}

type ModifyOcspStatusResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyOcspStatusResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyOcspStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyOcspStatusResponse) GoString() string {
	return s.String()
}

func (s *ModifyOcspStatusResponse) SetHeaders(v map[string]*string) *ModifyOcspStatusResponse {
	s.Headers = v
	return s
}

func (s *ModifyOcspStatusResponse) SetStatusCode(v int32) *ModifyOcspStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyOcspStatusResponse) SetBody(v *ModifyOcspStatusResponseBody) *ModifyOcspStatusResponse {
	s.Body = v
	return s
}

type ModifyPortRequest struct {
	// The port of the origin server. Valid values: **0** to **65535**.
	BackendPort *string `json:"BackendPort,omitempty" xml:"BackendPort,omitempty"`
	// The forwarding port. Valid values: **0** to **65535**.
	FrontendPort *string `json:"FrontendPort,omitempty" xml:"FrontendPort,omitempty"`
	// The type of the protocol. Valid values:
	//
	// *   **tcp**
	// *   **udp**
	FrontendProtocol *string `json:"FrontendProtocol,omitempty" xml:"FrontendProtocol,omitempty"`
	// The ID of the Anti-DDoS Pro or Anti-DDoS Premium instance to which the port forwarding rule belongs.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// An array that consists of the IP addresses of origin servers.
	RealServers []*string `json:"RealServers,omitempty" xml:"RealServers,omitempty" type:"Repeated"`
}

func (s ModifyPortRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyPortRequest) GoString() string {
	return s.String()
}

func (s *ModifyPortRequest) SetBackendPort(v string) *ModifyPortRequest {
	s.BackendPort = &v
	return s
}

func (s *ModifyPortRequest) SetFrontendPort(v string) *ModifyPortRequest {
	s.FrontendPort = &v
	return s
}

func (s *ModifyPortRequest) SetFrontendProtocol(v string) *ModifyPortRequest {
	s.FrontendProtocol = &v
	return s
}

func (s *ModifyPortRequest) SetInstanceId(v string) *ModifyPortRequest {
	s.InstanceId = &v
	return s
}

func (s *ModifyPortRequest) SetRealServers(v []*string) *ModifyPortRequest {
	s.RealServers = v
	return s
}

type ModifyPortResponseBody struct {
	// The ID of the request, which is used to locate and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyPortResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyPortResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyPortResponseBody) SetRequestId(v string) *ModifyPortResponseBody {
	s.RequestId = &v
	return s
}

type ModifyPortResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyPortResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyPortResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyPortResponse) GoString() string {
	return s.String()
}

func (s *ModifyPortResponse) SetHeaders(v map[string]*string) *ModifyPortResponse {
	s.Headers = v
	return s
}

func (s *ModifyPortResponse) SetStatusCode(v int32) *ModifyPortResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyPortResponse) SetBody(v *ModifyPortResponseBody) *ModifyPortResponse {
	s.Body = v
	return s
}

type ModifyPortAutoCcStatusRequest struct {
	// The ID of the instance.
	//
	// > You can call the [DescribeInstanceIds](~~157459~~) operation to query the IDs of all instances.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The mode of the Intelligent Protection policy. Valid values:
	//
	// *   **normal**
	// *   **loose**
	// *   **strict**
	Mode *string `json:"Mode,omitempty" xml:"Mode,omitempty"`
	// Specifies the status of the Intelligent Protection policy. Valid values:
	//
	// *   **on**: enables the policy.
	// *   **off**: disables the policy.
	Switch *string `json:"Switch,omitempty" xml:"Switch,omitempty"`
}

func (s ModifyPortAutoCcStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyPortAutoCcStatusRequest) GoString() string {
	return s.String()
}

func (s *ModifyPortAutoCcStatusRequest) SetInstanceId(v string) *ModifyPortAutoCcStatusRequest {
	s.InstanceId = &v
	return s
}

func (s *ModifyPortAutoCcStatusRequest) SetMode(v string) *ModifyPortAutoCcStatusRequest {
	s.Mode = &v
	return s
}

func (s *ModifyPortAutoCcStatusRequest) SetSwitch(v string) *ModifyPortAutoCcStatusRequest {
	s.Switch = &v
	return s
}

type ModifyPortAutoCcStatusResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyPortAutoCcStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyPortAutoCcStatusResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyPortAutoCcStatusResponseBody) SetRequestId(v string) *ModifyPortAutoCcStatusResponseBody {
	s.RequestId = &v
	return s
}

type ModifyPortAutoCcStatusResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyPortAutoCcStatusResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyPortAutoCcStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyPortAutoCcStatusResponse) GoString() string {
	return s.String()
}

func (s *ModifyPortAutoCcStatusResponse) SetHeaders(v map[string]*string) *ModifyPortAutoCcStatusResponse {
	s.Headers = v
	return s
}

func (s *ModifyPortAutoCcStatusResponse) SetStatusCode(v int32) *ModifyPortAutoCcStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyPortAutoCcStatusResponse) SetBody(v *ModifyPortAutoCcStatusResponseBody) *ModifyPortAutoCcStatusResponse {
	s.Body = v
	return s
}

type ModifyQpsModeRequest struct {
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	Mode       *string `json:"Mode,omitempty" xml:"Mode,omitempty"`
}

func (s ModifyQpsModeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyQpsModeRequest) GoString() string {
	return s.String()
}

func (s *ModifyQpsModeRequest) SetInstanceId(v string) *ModifyQpsModeRequest {
	s.InstanceId = &v
	return s
}

func (s *ModifyQpsModeRequest) SetMode(v string) *ModifyQpsModeRequest {
	s.Mode = &v
	return s
}

type ModifyQpsModeResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyQpsModeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyQpsModeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyQpsModeResponseBody) SetRequestId(v string) *ModifyQpsModeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyQpsModeResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyQpsModeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyQpsModeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyQpsModeResponse) GoString() string {
	return s.String()
}

func (s *ModifyQpsModeResponse) SetHeaders(v map[string]*string) *ModifyQpsModeResponse {
	s.Headers = v
	return s
}

func (s *ModifyQpsModeResponse) SetStatusCode(v int32) *ModifyQpsModeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyQpsModeResponse) SetBody(v *ModifyQpsModeResponseBody) *ModifyQpsModeResponse {
	s.Body = v
	return s
}

type ModifySceneDefensePolicyRequest struct {
	// The end time of the policy. The value is a UNIX timestamp. Unit: milliseconds.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The name of the policy.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the policy that you want to modify.
	//
	// > You can call the [DescribeSceneDefensePolicies](~~159382~~) operation to query the IDs of all policies.
	PolicyId *string `json:"PolicyId,omitempty" xml:"PolicyId,omitempty"`
	// The start time of the policy. The value is a UNIX timestamp. Unit: milliseconds.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The template of the policy. Valid values:
	//
	// *   **promotion**: important activity
	// *   **bypass**: all traffic forwarded
	Template *string `json:"Template,omitempty" xml:"Template,omitempty"`
}

func (s ModifySceneDefensePolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifySceneDefensePolicyRequest) GoString() string {
	return s.String()
}

func (s *ModifySceneDefensePolicyRequest) SetEndTime(v int64) *ModifySceneDefensePolicyRequest {
	s.EndTime = &v
	return s
}

func (s *ModifySceneDefensePolicyRequest) SetName(v string) *ModifySceneDefensePolicyRequest {
	s.Name = &v
	return s
}

func (s *ModifySceneDefensePolicyRequest) SetPolicyId(v string) *ModifySceneDefensePolicyRequest {
	s.PolicyId = &v
	return s
}

func (s *ModifySceneDefensePolicyRequest) SetStartTime(v int64) *ModifySceneDefensePolicyRequest {
	s.StartTime = &v
	return s
}

func (s *ModifySceneDefensePolicyRequest) SetTemplate(v string) *ModifySceneDefensePolicyRequest {
	s.Template = &v
	return s
}

type ModifySceneDefensePolicyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ModifySceneDefensePolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifySceneDefensePolicyResponseBody) GoString() string {
	return s.String()
}

func (s *ModifySceneDefensePolicyResponseBody) SetRequestId(v string) *ModifySceneDefensePolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifySceneDefensePolicyResponseBody) SetSuccess(v bool) *ModifySceneDefensePolicyResponseBody {
	s.Success = &v
	return s
}

type ModifySceneDefensePolicyResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifySceneDefensePolicyResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifySceneDefensePolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifySceneDefensePolicyResponse) GoString() string {
	return s.String()
}

func (s *ModifySceneDefensePolicyResponse) SetHeaders(v map[string]*string) *ModifySceneDefensePolicyResponse {
	s.Headers = v
	return s
}

func (s *ModifySceneDefensePolicyResponse) SetStatusCode(v int32) *ModifySceneDefensePolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifySceneDefensePolicyResponse) SetBody(v *ModifySceneDefensePolicyResponseBody) *ModifySceneDefensePolicyResponse {
	s.Body = v
	return s
}

type ModifySchedulerRuleRequest struct {
	// The details of the CDN interaction rule. This parameter is a JSON string. The string contains the following fields:
	//
	// *   **ParamType**: the type of the scheduling rule. This field is required and must be of the string type. Set the value to **cdn**. This indicates that you want to modify a CDN interaction rule.
	//
	// *   **ParamData**: the values of parameters that you want to modify for the CDN interaction rule. This field is required and must be of the map type. The ParamData parameter contains the following parameters:
	//
	//     *   **Domain**: the accelerated domain in CDN. This parameter is required and must be of the string type.
	//     *   **Cname**: the CNAME that is assigned to the accelerated domain. This parameter is required and must be of the string type.
	//     *   **AccessQps**: the queries per second (QPS) threshold that is used to switch service traffic to Anti-DDoS Pro or Anti-DDoS Premium. This parameter is required and must be of the integer type.
	//     *   **UpstreamQps**: the QPS threshold that is used to switch service traffic to CDN. This parameter is optional and must be of the integer type.
	Param *string `json:"Param,omitempty" xml:"Param,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The name of the rule that you want to modify.
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	// The type of the rule. Valid values:
	//
	// *   **2**: tiered protection
	// *   **3**: network acceleration
	// *   **5**: Alibaba Cloud CDN (CDN) interaction
	// *   **6**: cloud service interaction
	RuleType *int32 `json:"RuleType,omitempty" xml:"RuleType,omitempty"`
	// The details of the scheduling rule. This parameter is a JSON string. The string contains the following fields:
	//
	// *   **Type**: the address type of the interaction resource that you want to use in the scheduling rule. This field is required and must be of the string type. Valid values:
	//
	//     *   **A**: IP address
	//     *   **CNAME**: domain name
	//
	// *   **Value**: the address of the interaction resource that you want to use in the scheduling rule. This field is required and must be of the string type.
	//
	// *   **Priority**: the priority of the scheduling rule. This field is required and must be of the integer type. Valid values: **0** to **100**. A larger value indicates a higher priority.
	//
	// *   **ValueType**: the type of the interaction resource that you want to use in the scheduling rule. This field is required and must be of the integer type. Valid values:
	//
	//     *   **1**: the IP address of the Anti-DDoS Pro or Anti-DDoS Premium instance
	//     *   **2**: the IP address of the interaction resource in the tiered protection scenario
	//     *   **3**: the IP address that is used to accelerate access in the network acceleration scenario
	//     *   **5**: the domain name that is configured in Alibaba Cloud CDN (CDN) in the CDN interaction scenario
	//     *   **6** the IP address of the interaction resource in the cloud service interaction scenario
	//
	// *   **RegionId**: the region where the interaction resource is deployed. This parameter must be specified when **ValueType** is set to **2**. The value must be of the string type.
	Rules *string `json:"Rules,omitempty" xml:"Rules,omitempty"`
}

func (s ModifySchedulerRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifySchedulerRuleRequest) GoString() string {
	return s.String()
}

func (s *ModifySchedulerRuleRequest) SetParam(v string) *ModifySchedulerRuleRequest {
	s.Param = &v
	return s
}

func (s *ModifySchedulerRuleRequest) SetResourceGroupId(v string) *ModifySchedulerRuleRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ModifySchedulerRuleRequest) SetRuleName(v string) *ModifySchedulerRuleRequest {
	s.RuleName = &v
	return s
}

func (s *ModifySchedulerRuleRequest) SetRuleType(v int32) *ModifySchedulerRuleRequest {
	s.RuleType = &v
	return s
}

func (s *ModifySchedulerRuleRequest) SetRules(v string) *ModifySchedulerRuleRequest {
	s.Rules = &v
	return s
}

type ModifySchedulerRuleResponseBody struct {
	// The CNAME that is assigned by Sec-Traffic Manager for the scheduling rule.
	//
	// > To enable the scheduling rule, you must map the domain name of the service to the CNAME.
	Cname *string `json:"Cname,omitempty" xml:"Cname,omitempty"`
	// The ID of the request, which is used to locate and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The name of the rule.
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
}

func (s ModifySchedulerRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifySchedulerRuleResponseBody) GoString() string {
	return s.String()
}

func (s *ModifySchedulerRuleResponseBody) SetCname(v string) *ModifySchedulerRuleResponseBody {
	s.Cname = &v
	return s
}

func (s *ModifySchedulerRuleResponseBody) SetRequestId(v string) *ModifySchedulerRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifySchedulerRuleResponseBody) SetRuleName(v string) *ModifySchedulerRuleResponseBody {
	s.RuleName = &v
	return s
}

type ModifySchedulerRuleResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifySchedulerRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifySchedulerRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifySchedulerRuleResponse) GoString() string {
	return s.String()
}

func (s *ModifySchedulerRuleResponse) SetHeaders(v map[string]*string) *ModifySchedulerRuleResponse {
	s.Headers = v
	return s
}

func (s *ModifySchedulerRuleResponse) SetStatusCode(v int32) *ModifySchedulerRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifySchedulerRuleResponse) SetBody(v *ModifySchedulerRuleResponseBody) *ModifySchedulerRuleResponse {
	s.Body = v
	return s
}

type ModifyTlsConfigRequest struct {
	// The details of the TLS policy. The value is a JSON string that contains the following fields:
	//
	// *   **ssl_protocols**: the version of TLS. This field is required. Data type: string. Valid values:
	//
	//     *   **tls1.0**: TLS 1.0 and later
	//     *   **tls1.1**: TLS 1.1 and later
	//     *   **tls1.2**: TLS 1.2 and later
	//
	// *   **ssl_ciphers**: the type of the cipher suite. This field is required. Data type: string. Valid values:
	//
	//     *   **all**: all cipher suites, which include strong and weak cipher suites
	//     *   **improved**: enhanced cipher suites
	//     *   **strong**: strong cipher suites
	//     *   **default**: default cipher suites, which include only strong cipher suites
	Config *string `json:"Config,omitempty" xml:"Config,omitempty"`
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s ModifyTlsConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyTlsConfigRequest) GoString() string {
	return s.String()
}

func (s *ModifyTlsConfigRequest) SetConfig(v string) *ModifyTlsConfigRequest {
	s.Config = &v
	return s
}

func (s *ModifyTlsConfigRequest) SetDomain(v string) *ModifyTlsConfigRequest {
	s.Domain = &v
	return s
}

func (s *ModifyTlsConfigRequest) SetResourceGroupId(v string) *ModifyTlsConfigRequest {
	s.ResourceGroupId = &v
	return s
}

type ModifyTlsConfigResponseBody struct {
	// The ID of the request, which is used to locate and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyTlsConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyTlsConfigResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyTlsConfigResponseBody) SetRequestId(v string) *ModifyTlsConfigResponseBody {
	s.RequestId = &v
	return s
}

type ModifyTlsConfigResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyTlsConfigResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyTlsConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyTlsConfigResponse) GoString() string {
	return s.String()
}

func (s *ModifyTlsConfigResponse) SetHeaders(v map[string]*string) *ModifyTlsConfigResponse {
	s.Headers = v
	return s
}

func (s *ModifyTlsConfigResponse) SetStatusCode(v int32) *ModifyTlsConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyTlsConfigResponse) SetBody(v *ModifyTlsConfigResponseBody) *ModifyTlsConfigResponse {
	s.Body = v
	return s
}

type ModifyWebAIProtectModeRequest struct {
	// The details of the Intelligent Protection policy. This parameter is a JSON string. The string contains the following fields:
	//
	// *   **AiTemplate**: the level of the Intelligent Protection policy. This field is required and must be of the STRING type. Valid values:
	//
	//     *   **level30**: the Low level
	//     *   **level60**: the Normal level
	//     *   **level90**: the Strict level
	//
	// *   **AiMode**: the mode of the Intelligent Protection policy. This field is required and must be of the string type. Valid values:
	//
	//     *   **watch**: the Warning mode
	//     *   **defense**: the Defense mode
	Config *string `json:"Config,omitempty" xml:"Config,omitempty"`
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for a domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s ModifyWebAIProtectModeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebAIProtectModeRequest) GoString() string {
	return s.String()
}

func (s *ModifyWebAIProtectModeRequest) SetConfig(v string) *ModifyWebAIProtectModeRequest {
	s.Config = &v
	return s
}

func (s *ModifyWebAIProtectModeRequest) SetDomain(v string) *ModifyWebAIProtectModeRequest {
	s.Domain = &v
	return s
}

func (s *ModifyWebAIProtectModeRequest) SetResourceGroupId(v string) *ModifyWebAIProtectModeRequest {
	s.ResourceGroupId = &v
	return s
}

type ModifyWebAIProtectModeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyWebAIProtectModeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebAIProtectModeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyWebAIProtectModeResponseBody) SetRequestId(v string) *ModifyWebAIProtectModeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyWebAIProtectModeResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyWebAIProtectModeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyWebAIProtectModeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebAIProtectModeResponse) GoString() string {
	return s.String()
}

func (s *ModifyWebAIProtectModeResponse) SetHeaders(v map[string]*string) *ModifyWebAIProtectModeResponse {
	s.Headers = v
	return s
}

func (s *ModifyWebAIProtectModeResponse) SetStatusCode(v int32) *ModifyWebAIProtectModeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyWebAIProtectModeResponse) SetBody(v *ModifyWebAIProtectModeResponseBody) *ModifyWebAIProtectModeResponse {
	s.Body = v
	return s
}

type ModifyWebAIProtectSwitchRequest struct {
	// The details of the Intelligent Protection policy. This parameter is a JSON string. The string contains the following fields:
	//
	// *   **AiRuleEnable**: the status of the Intelligent Protection policy. This field is required and must be of the integer type. Valid values:
	//
	//     *   **0**: disabled
	//     *   **1**: enabled
	Config *string `json:"Config,omitempty" xml:"Config,omitempty"`
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for a domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s ModifyWebAIProtectSwitchRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebAIProtectSwitchRequest) GoString() string {
	return s.String()
}

func (s *ModifyWebAIProtectSwitchRequest) SetConfig(v string) *ModifyWebAIProtectSwitchRequest {
	s.Config = &v
	return s
}

func (s *ModifyWebAIProtectSwitchRequest) SetDomain(v string) *ModifyWebAIProtectSwitchRequest {
	s.Domain = &v
	return s
}

func (s *ModifyWebAIProtectSwitchRequest) SetResourceGroupId(v string) *ModifyWebAIProtectSwitchRequest {
	s.ResourceGroupId = &v
	return s
}

type ModifyWebAIProtectSwitchResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyWebAIProtectSwitchResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebAIProtectSwitchResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyWebAIProtectSwitchResponseBody) SetRequestId(v string) *ModifyWebAIProtectSwitchResponseBody {
	s.RequestId = &v
	return s
}

type ModifyWebAIProtectSwitchResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyWebAIProtectSwitchResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyWebAIProtectSwitchResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebAIProtectSwitchResponse) GoString() string {
	return s.String()
}

func (s *ModifyWebAIProtectSwitchResponse) SetHeaders(v map[string]*string) *ModifyWebAIProtectSwitchResponse {
	s.Headers = v
	return s
}

func (s *ModifyWebAIProtectSwitchResponse) SetStatusCode(v int32) *ModifyWebAIProtectSwitchResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyWebAIProtectSwitchResponse) SetBody(v *ModifyWebAIProtectSwitchResponseBody) *ModifyWebAIProtectSwitchResponse {
	s.Body = v
	return s
}

type ModifyWebAccessModeRequest struct {
	// The mode in which a website service is added to Anti-DDoS Pro or Anti-DDoS Premium. Valid values:
	//
	// *   **0**: A record mode
	// *   **1**: anti-DDoS mode
	// *   **2**: origin redundancy mode
	AccessMode *int32 `json:"AccessMode,omitempty" xml:"AccessMode,omitempty"`
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
}

func (s ModifyWebAccessModeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebAccessModeRequest) GoString() string {
	return s.String()
}

func (s *ModifyWebAccessModeRequest) SetAccessMode(v int32) *ModifyWebAccessModeRequest {
	s.AccessMode = &v
	return s
}

func (s *ModifyWebAccessModeRequest) SetDomain(v string) *ModifyWebAccessModeRequest {
	s.Domain = &v
	return s
}

type ModifyWebAccessModeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyWebAccessModeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebAccessModeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyWebAccessModeResponseBody) SetRequestId(v string) *ModifyWebAccessModeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyWebAccessModeResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyWebAccessModeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyWebAccessModeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebAccessModeResponse) GoString() string {
	return s.String()
}

func (s *ModifyWebAccessModeResponse) SetHeaders(v map[string]*string) *ModifyWebAccessModeResponse {
	s.Headers = v
	return s
}

func (s *ModifyWebAccessModeResponse) SetStatusCode(v int32) *ModifyWebAccessModeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyWebAccessModeResponse) SetBody(v *ModifyWebAccessModeResponseBody) *ModifyWebAccessModeResponse {
	s.Body = v
	return s
}

type ModifyWebAreaBlockRequest struct {
	// The domain name whose configurations you want to modify.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The regions from which you block requests.
	//
	// > If you do not configure this parameter, the Blocked Regions (Domain Names) policy is disabled.
	Regions []*string `json:"Regions,omitempty" xml:"Regions,omitempty" type:"Repeated"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	//
	// For more information about resource groups, see [Create a resource group](~~94485~~).
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s ModifyWebAreaBlockRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebAreaBlockRequest) GoString() string {
	return s.String()
}

func (s *ModifyWebAreaBlockRequest) SetDomain(v string) *ModifyWebAreaBlockRequest {
	s.Domain = &v
	return s
}

func (s *ModifyWebAreaBlockRequest) SetRegions(v []*string) *ModifyWebAreaBlockRequest {
	s.Regions = v
	return s
}

func (s *ModifyWebAreaBlockRequest) SetResourceGroupId(v string) *ModifyWebAreaBlockRequest {
	s.ResourceGroupId = &v
	return s
}

type ModifyWebAreaBlockResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyWebAreaBlockResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebAreaBlockResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyWebAreaBlockResponseBody) SetRequestId(v string) *ModifyWebAreaBlockResponseBody {
	s.RequestId = &v
	return s
}

type ModifyWebAreaBlockResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyWebAreaBlockResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyWebAreaBlockResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebAreaBlockResponse) GoString() string {
	return s.String()
}

func (s *ModifyWebAreaBlockResponse) SetHeaders(v map[string]*string) *ModifyWebAreaBlockResponse {
	s.Headers = v
	return s
}

func (s *ModifyWebAreaBlockResponse) SetStatusCode(v int32) *ModifyWebAreaBlockResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyWebAreaBlockResponse) SetBody(v *ModifyWebAreaBlockResponseBody) *ModifyWebAreaBlockResponse {
	s.Body = v
	return s
}

type ModifyWebAreaBlockSwitchRequest struct {
	// Specifies whether to enable or disable the Location Blacklist (Domain Names) policy for a domain name. The value is a string that consists of a JSON struct. The JSON struct contains the following parameters:
	//
	// *   **RegionblockEnable**: the status of the Location Blacklist (Domain Names) policy. This parameter is required and must be of the INTEGER type. Valid values:
	//
	//     *   **1**: enables the policy.
	//     *   **0**: disables the policy.
	Config *string `json:"Config,omitempty" xml:"Config,omitempty"`
	// The domain name for which you want to enable or disable the Location Blacklist policy.
	//
	// > You can call the [DescribeDomains](~~91724~~) operation to query all the domain names that are added to Anti-DDoS Pro or Anti-DDoS Premium.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management.
	//
	// If you do not configure this parameter, the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s ModifyWebAreaBlockSwitchRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebAreaBlockSwitchRequest) GoString() string {
	return s.String()
}

func (s *ModifyWebAreaBlockSwitchRequest) SetConfig(v string) *ModifyWebAreaBlockSwitchRequest {
	s.Config = &v
	return s
}

func (s *ModifyWebAreaBlockSwitchRequest) SetDomain(v string) *ModifyWebAreaBlockSwitchRequest {
	s.Domain = &v
	return s
}

func (s *ModifyWebAreaBlockSwitchRequest) SetResourceGroupId(v string) *ModifyWebAreaBlockSwitchRequest {
	s.ResourceGroupId = &v
	return s
}

type ModifyWebAreaBlockSwitchResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyWebAreaBlockSwitchResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebAreaBlockSwitchResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyWebAreaBlockSwitchResponseBody) SetRequestId(v string) *ModifyWebAreaBlockSwitchResponseBody {
	s.RequestId = &v
	return s
}

type ModifyWebAreaBlockSwitchResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyWebAreaBlockSwitchResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyWebAreaBlockSwitchResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebAreaBlockSwitchResponse) GoString() string {
	return s.String()
}

func (s *ModifyWebAreaBlockSwitchResponse) SetHeaders(v map[string]*string) *ModifyWebAreaBlockSwitchResponse {
	s.Headers = v
	return s
}

func (s *ModifyWebAreaBlockSwitchResponse) SetStatusCode(v int32) *ModifyWebAreaBlockSwitchResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyWebAreaBlockSwitchResponse) SetBody(v *ModifyWebAreaBlockSwitchResponseBody) *ModifyWebAreaBlockSwitchResponse {
	s.Body = v
	return s
}

type ModifyWebCCRuleRequest struct {
	Act             *string `json:"Act,omitempty" xml:"Act,omitempty"`
	Count           *int32  `json:"Count,omitempty" xml:"Count,omitempty"`
	Domain          *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	Interval        *int32  `json:"Interval,omitempty" xml:"Interval,omitempty"`
	Mode            *string `json:"Mode,omitempty" xml:"Mode,omitempty"`
	Name            *string `json:"Name,omitempty" xml:"Name,omitempty"`
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	Ttl             *int32  `json:"Ttl,omitempty" xml:"Ttl,omitempty"`
	Uri             *string `json:"Uri,omitempty" xml:"Uri,omitempty"`
}

func (s ModifyWebCCRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebCCRuleRequest) GoString() string {
	return s.String()
}

func (s *ModifyWebCCRuleRequest) SetAct(v string) *ModifyWebCCRuleRequest {
	s.Act = &v
	return s
}

func (s *ModifyWebCCRuleRequest) SetCount(v int32) *ModifyWebCCRuleRequest {
	s.Count = &v
	return s
}

func (s *ModifyWebCCRuleRequest) SetDomain(v string) *ModifyWebCCRuleRequest {
	s.Domain = &v
	return s
}

func (s *ModifyWebCCRuleRequest) SetInterval(v int32) *ModifyWebCCRuleRequest {
	s.Interval = &v
	return s
}

func (s *ModifyWebCCRuleRequest) SetMode(v string) *ModifyWebCCRuleRequest {
	s.Mode = &v
	return s
}

func (s *ModifyWebCCRuleRequest) SetName(v string) *ModifyWebCCRuleRequest {
	s.Name = &v
	return s
}

func (s *ModifyWebCCRuleRequest) SetResourceGroupId(v string) *ModifyWebCCRuleRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ModifyWebCCRuleRequest) SetTtl(v int32) *ModifyWebCCRuleRequest {
	s.Ttl = &v
	return s
}

func (s *ModifyWebCCRuleRequest) SetUri(v string) *ModifyWebCCRuleRequest {
	s.Uri = &v
	return s
}

type ModifyWebCCRuleResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyWebCCRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebCCRuleResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyWebCCRuleResponseBody) SetRequestId(v string) *ModifyWebCCRuleResponseBody {
	s.RequestId = &v
	return s
}

type ModifyWebCCRuleResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyWebCCRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyWebCCRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebCCRuleResponse) GoString() string {
	return s.String()
}

func (s *ModifyWebCCRuleResponse) SetHeaders(v map[string]*string) *ModifyWebCCRuleResponse {
	s.Headers = v
	return s
}

func (s *ModifyWebCCRuleResponse) SetStatusCode(v int32) *ModifyWebCCRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyWebCCRuleResponse) SetBody(v *ModifyWebCCRuleResponseBody) *ModifyWebCCRuleResponse {
	s.Body = v
	return s
}

type ModifyWebCacheCustomRuleRequest struct {
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for the domain name, and the domain name must be associated with an instance that uses the Enhanced function plan. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The details of the custom rule. This parameter is a JSON string. The string contains the following fields:
	//
	// *   **Name**: the name of the rule. This field is required and must be of the string type.
	//
	// *   **Uri**: the path to the cached page. This field is required and must be of the STRING type.
	//
	// *   **Mode**: the cache mode. This field is required and must be of the STRING type. Valid values:
	//
	//     *   **standard**: uses the standard mode.
	//     *   **aggressive**: uses the enhanced mode.
	//     *   **bypass**: No data is cached.
	//
	// *   **CacheTtl**: the expiration time of the page cache. This field is required and must be of the INTEGER type. Unit: seconds.
	Rules *string `json:"Rules,omitempty" xml:"Rules,omitempty"`
}

func (s ModifyWebCacheCustomRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebCacheCustomRuleRequest) GoString() string {
	return s.String()
}

func (s *ModifyWebCacheCustomRuleRequest) SetDomain(v string) *ModifyWebCacheCustomRuleRequest {
	s.Domain = &v
	return s
}

func (s *ModifyWebCacheCustomRuleRequest) SetResourceGroupId(v string) *ModifyWebCacheCustomRuleRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ModifyWebCacheCustomRuleRequest) SetRules(v string) *ModifyWebCacheCustomRuleRequest {
	s.Rules = &v
	return s
}

type ModifyWebCacheCustomRuleResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyWebCacheCustomRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebCacheCustomRuleResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyWebCacheCustomRuleResponseBody) SetRequestId(v string) *ModifyWebCacheCustomRuleResponseBody {
	s.RequestId = &v
	return s
}

type ModifyWebCacheCustomRuleResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyWebCacheCustomRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyWebCacheCustomRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebCacheCustomRuleResponse) GoString() string {
	return s.String()
}

func (s *ModifyWebCacheCustomRuleResponse) SetHeaders(v map[string]*string) *ModifyWebCacheCustomRuleResponse {
	s.Headers = v
	return s
}

func (s *ModifyWebCacheCustomRuleResponse) SetStatusCode(v int32) *ModifyWebCacheCustomRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyWebCacheCustomRuleResponse) SetBody(v *ModifyWebCacheCustomRuleResponseBody) *ModifyWebCacheCustomRuleResponse {
	s.Body = v
	return s
}

type ModifyWebCacheModeRequest struct {
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for the domain name, and the domain name must be associated with an instance that uses the Enhanced function plan. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The cache mode of the Static Page Caching policy. Valid values:
	//
	// *   **standard**: uses the standard cache mode.
	// *   **aggressive**: uses the enhanced cache mode.
	// *   **bypass**: caches no data.
	Mode *string `json:"Mode,omitempty" xml:"Mode,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s ModifyWebCacheModeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebCacheModeRequest) GoString() string {
	return s.String()
}

func (s *ModifyWebCacheModeRequest) SetDomain(v string) *ModifyWebCacheModeRequest {
	s.Domain = &v
	return s
}

func (s *ModifyWebCacheModeRequest) SetMode(v string) *ModifyWebCacheModeRequest {
	s.Mode = &v
	return s
}

func (s *ModifyWebCacheModeRequest) SetResourceGroupId(v string) *ModifyWebCacheModeRequest {
	s.ResourceGroupId = &v
	return s
}

type ModifyWebCacheModeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyWebCacheModeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebCacheModeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyWebCacheModeResponseBody) SetRequestId(v string) *ModifyWebCacheModeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyWebCacheModeResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyWebCacheModeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyWebCacheModeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebCacheModeResponse) GoString() string {
	return s.String()
}

func (s *ModifyWebCacheModeResponse) SetHeaders(v map[string]*string) *ModifyWebCacheModeResponse {
	s.Headers = v
	return s
}

func (s *ModifyWebCacheModeResponse) SetStatusCode(v int32) *ModifyWebCacheModeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyWebCacheModeResponse) SetBody(v *ModifyWebCacheModeResponseBody) *ModifyWebCacheModeResponse {
	s.Body = v
	return s
}

type ModifyWebCacheSwitchRequest struct {
	// The domain name for which you want to configure the Static Page Caching policy.
	//
	// > You can call the [DescribeDomains](~~91724~~) operation to query all the domain names that are added to Anti-DDoS Pro or Anti-DDoS Premium.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// Specifies whether to enable or disable the Static Page Caching policy for a website. Valid values:
	//
	// *   **1**: enables the policy.
	// *   **0**: disables the policy.
	Enable *int32 `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management.
	//
	// If you do not configure this parameter, the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s ModifyWebCacheSwitchRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebCacheSwitchRequest) GoString() string {
	return s.String()
}

func (s *ModifyWebCacheSwitchRequest) SetDomain(v string) *ModifyWebCacheSwitchRequest {
	s.Domain = &v
	return s
}

func (s *ModifyWebCacheSwitchRequest) SetEnable(v int32) *ModifyWebCacheSwitchRequest {
	s.Enable = &v
	return s
}

func (s *ModifyWebCacheSwitchRequest) SetResourceGroupId(v string) *ModifyWebCacheSwitchRequest {
	s.ResourceGroupId = &v
	return s
}

type ModifyWebCacheSwitchResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyWebCacheSwitchResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebCacheSwitchResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyWebCacheSwitchResponseBody) SetRequestId(v string) *ModifyWebCacheSwitchResponseBody {
	s.RequestId = &v
	return s
}

type ModifyWebCacheSwitchResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyWebCacheSwitchResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyWebCacheSwitchResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebCacheSwitchResponse) GoString() string {
	return s.String()
}

func (s *ModifyWebCacheSwitchResponse) SetHeaders(v map[string]*string) *ModifyWebCacheSwitchResponse {
	s.Headers = v
	return s
}

func (s *ModifyWebCacheSwitchResponse) SetStatusCode(v int32) *ModifyWebCacheSwitchResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyWebCacheSwitchResponse) SetBody(v *ModifyWebCacheSwitchResponseBody) *ModifyWebCacheSwitchResponse {
	s.Body = v
	return s
}

type ModifyWebIpSetSwitchRequest struct {
	// The details of the Black Lists and White Lists (Domain Names) policy. This parameter is a JSON string. The string contains the following fields:
	//
	// *   **Bwlist_Enable**: the status of the Black Lists and White Lists (Domain Names) policy. This field is required and must be of the integer type. Valid values:
	//
	//     *   **0**: disabled
	//     *   **1**: enabled
	Config *string `json:"Config,omitempty" xml:"Config,omitempty"`
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s ModifyWebIpSetSwitchRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebIpSetSwitchRequest) GoString() string {
	return s.String()
}

func (s *ModifyWebIpSetSwitchRequest) SetConfig(v string) *ModifyWebIpSetSwitchRequest {
	s.Config = &v
	return s
}

func (s *ModifyWebIpSetSwitchRequest) SetDomain(v string) *ModifyWebIpSetSwitchRequest {
	s.Domain = &v
	return s
}

func (s *ModifyWebIpSetSwitchRequest) SetResourceGroupId(v string) *ModifyWebIpSetSwitchRequest {
	s.ResourceGroupId = &v
	return s
}

type ModifyWebIpSetSwitchResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyWebIpSetSwitchResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebIpSetSwitchResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyWebIpSetSwitchResponseBody) SetRequestId(v string) *ModifyWebIpSetSwitchResponseBody {
	s.RequestId = &v
	return s
}

type ModifyWebIpSetSwitchResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyWebIpSetSwitchResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyWebIpSetSwitchResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebIpSetSwitchResponse) GoString() string {
	return s.String()
}

func (s *ModifyWebIpSetSwitchResponse) SetHeaders(v map[string]*string) *ModifyWebIpSetSwitchResponse {
	s.Headers = v
	return s
}

func (s *ModifyWebIpSetSwitchResponse) SetStatusCode(v int32) *ModifyWebIpSetSwitchResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyWebIpSetSwitchResponse) SetBody(v *ModifyWebIpSetSwitchResponseBody) *ModifyWebIpSetSwitchResponse {
	s.Body = v
	return s
}

type ModifyWebPreciseAccessRuleRequest struct {
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for the domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The validity period of the rule. Unit: seconds. This parameter takes effect only when **action** of a rule is **block**. Access requests that match the rule are blocked within the specified validity period of the rule. If you do not specify this parameter, this rule takes effect all the time.
	Expires *int32 `json:"Expires,omitempty" xml:"Expires,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The settings of the accurate access control rule. This parameter is a JSON string. The following list describes the fields in the value of the parameter:
	//
	// *   **action**: the action that is performed if the rule is matched. This field is required and must be of the string type. Valid values:
	//
	//     *   **accept**: allows the requests that match the rule.
	//     *   **block**: blocks the requests that match the rule.
	//     *   **challenge**: implements a CAPTCHA for the requests that match the rule.
	//
	// *   **name**: the name of the rule. This field is required and must be of the string type.
	//
	// *   **condition**: the match conditions. This field is required and must be of the map type. A match condition contains the following parameters.
	//
	//     **
	//
	//     **Note**The AND logical operator is used to define the relationship among multiple match conditions.
	//
	//     *   **field**: the match field. This parameter is required and must be of the string type.
	//
	//     *   **match_method**: the logical relation. This parameter is required and must be of the string type.
	//
	//         **
	//
	//         **Note**For information about the mappings between the **field** and **match_method** parameters, see the Mappings between the field and match_method parameters table in this topic.
	//
	//     *   **content**: the match content. This parameter is required and must be of the string type.
	//
	// *   **header_name**: the HTTP header. This parameter is optional and must be of the string type. This parameter takes effect only when **field** is **header**.
	Rules *string `json:"Rules,omitempty" xml:"Rules,omitempty"`
}

func (s ModifyWebPreciseAccessRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebPreciseAccessRuleRequest) GoString() string {
	return s.String()
}

func (s *ModifyWebPreciseAccessRuleRequest) SetDomain(v string) *ModifyWebPreciseAccessRuleRequest {
	s.Domain = &v
	return s
}

func (s *ModifyWebPreciseAccessRuleRequest) SetExpires(v int32) *ModifyWebPreciseAccessRuleRequest {
	s.Expires = &v
	return s
}

func (s *ModifyWebPreciseAccessRuleRequest) SetResourceGroupId(v string) *ModifyWebPreciseAccessRuleRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ModifyWebPreciseAccessRuleRequest) SetRules(v string) *ModifyWebPreciseAccessRuleRequest {
	s.Rules = &v
	return s
}

type ModifyWebPreciseAccessRuleResponseBody struct {
	// The ID of the request, which is used to locate and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyWebPreciseAccessRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebPreciseAccessRuleResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyWebPreciseAccessRuleResponseBody) SetRequestId(v string) *ModifyWebPreciseAccessRuleResponseBody {
	s.RequestId = &v
	return s
}

type ModifyWebPreciseAccessRuleResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyWebPreciseAccessRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyWebPreciseAccessRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebPreciseAccessRuleResponse) GoString() string {
	return s.String()
}

func (s *ModifyWebPreciseAccessRuleResponse) SetHeaders(v map[string]*string) *ModifyWebPreciseAccessRuleResponse {
	s.Headers = v
	return s
}

func (s *ModifyWebPreciseAccessRuleResponse) SetStatusCode(v int32) *ModifyWebPreciseAccessRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyWebPreciseAccessRuleResponse) SetBody(v *ModifyWebPreciseAccessRuleResponseBody) *ModifyWebPreciseAccessRuleResponse {
	s.Body = v
	return s
}

type ModifyWebPreciseAccessSwitchRequest struct {
	// The configuration of the Accurate Access Control policy. This parameter is a JSON string. The string contains the following fields:
	//
	// *   **PreciseRuleEnable**: the status of the Accurate Access Control policy. This field is required and must be of the INTEGER type. Valid values:
	//
	//     *   **0**: disables the policy.
	//     *   **1**: enables the policy.
	Config *string `json:"Config,omitempty" xml:"Config,omitempty"`
	// The domain name of the website.
	//
	// > A forwarding rule must be configured for a domain name. You can call the [DescribeDomains](~~91724~~) operation to query all domain names.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The ID of the resource group to which the instance belongs in Resource Management. This parameter is empty by default, which indicates that the instance belongs to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s ModifyWebPreciseAccessSwitchRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebPreciseAccessSwitchRequest) GoString() string {
	return s.String()
}

func (s *ModifyWebPreciseAccessSwitchRequest) SetConfig(v string) *ModifyWebPreciseAccessSwitchRequest {
	s.Config = &v
	return s
}

func (s *ModifyWebPreciseAccessSwitchRequest) SetDomain(v string) *ModifyWebPreciseAccessSwitchRequest {
	s.Domain = &v
	return s
}

func (s *ModifyWebPreciseAccessSwitchRequest) SetResourceGroupId(v string) *ModifyWebPreciseAccessSwitchRequest {
	s.ResourceGroupId = &v
	return s
}

type ModifyWebPreciseAccessSwitchResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyWebPreciseAccessSwitchResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebPreciseAccessSwitchResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyWebPreciseAccessSwitchResponseBody) SetRequestId(v string) *ModifyWebPreciseAccessSwitchResponseBody {
	s.RequestId = &v
	return s
}

type ModifyWebPreciseAccessSwitchResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyWebPreciseAccessSwitchResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyWebPreciseAccessSwitchResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebPreciseAccessSwitchResponse) GoString() string {
	return s.String()
}

func (s *ModifyWebPreciseAccessSwitchResponse) SetHeaders(v map[string]*string) *ModifyWebPreciseAccessSwitchResponse {
	s.Headers = v
	return s
}

func (s *ModifyWebPreciseAccessSwitchResponse) SetStatusCode(v int32) *ModifyWebPreciseAccessSwitchResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyWebPreciseAccessSwitchResponse) SetBody(v *ModifyWebPreciseAccessSwitchResponseBody) *ModifyWebPreciseAccessSwitchResponse {
	s.Body = v
	return s
}

type ModifyWebRuleRequest struct {
	Domain          *string   `json:"Domain,omitempty" xml:"Domain,omitempty"`
	HttpsExt        *string   `json:"HttpsExt,omitempty" xml:"HttpsExt,omitempty"`
	InstanceIds     []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	ProxyTypes      *string   `json:"ProxyTypes,omitempty" xml:"ProxyTypes,omitempty"`
	RealServers     []*string `json:"RealServers,omitempty" xml:"RealServers,omitempty" type:"Repeated"`
	ResourceGroupId *string   `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	RsType          *int32    `json:"RsType,omitempty" xml:"RsType,omitempty"`
}

func (s ModifyWebRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebRuleRequest) GoString() string {
	return s.String()
}

func (s *ModifyWebRuleRequest) SetDomain(v string) *ModifyWebRuleRequest {
	s.Domain = &v
	return s
}

func (s *ModifyWebRuleRequest) SetHttpsExt(v string) *ModifyWebRuleRequest {
	s.HttpsExt = &v
	return s
}

func (s *ModifyWebRuleRequest) SetInstanceIds(v []*string) *ModifyWebRuleRequest {
	s.InstanceIds = v
	return s
}

func (s *ModifyWebRuleRequest) SetProxyTypes(v string) *ModifyWebRuleRequest {
	s.ProxyTypes = &v
	return s
}

func (s *ModifyWebRuleRequest) SetRealServers(v []*string) *ModifyWebRuleRequest {
	s.RealServers = v
	return s
}

func (s *ModifyWebRuleRequest) SetResourceGroupId(v string) *ModifyWebRuleRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ModifyWebRuleRequest) SetRsType(v int32) *ModifyWebRuleRequest {
	s.RsType = &v
	return s
}

type ModifyWebRuleResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyWebRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebRuleResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyWebRuleResponseBody) SetRequestId(v string) *ModifyWebRuleResponseBody {
	s.RequestId = &v
	return s
}

type ModifyWebRuleResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyWebRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyWebRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyWebRuleResponse) GoString() string {
	return s.String()
}

func (s *ModifyWebRuleResponse) SetHeaders(v map[string]*string) *ModifyWebRuleResponse {
	s.Headers = v
	return s
}

func (s *ModifyWebRuleResponse) SetStatusCode(v int32) *ModifyWebRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyWebRuleResponse) SetBody(v *ModifyWebRuleResponseBody) *ModifyWebRuleResponse {
	s.Body = v
	return s
}

type ReleaseInstanceRequest struct {
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
}

func (s ReleaseInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s ReleaseInstanceRequest) GoString() string {
	return s.String()
}

func (s *ReleaseInstanceRequest) SetInstanceId(v string) *ReleaseInstanceRequest {
	s.InstanceId = &v
	return s
}

type ReleaseInstanceResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ReleaseInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ReleaseInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *ReleaseInstanceResponseBody) SetRequestId(v string) *ReleaseInstanceResponseBody {
	s.RequestId = &v
	return s
}

type ReleaseInstanceResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ReleaseInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ReleaseInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s ReleaseInstanceResponse) GoString() string {
	return s.String()
}

func (s *ReleaseInstanceResponse) SetHeaders(v map[string]*string) *ReleaseInstanceResponse {
	s.Headers = v
	return s
}

func (s *ReleaseInstanceResponse) SetStatusCode(v int32) *ReleaseInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *ReleaseInstanceResponse) SetBody(v *ReleaseInstanceResponseBody) *ReleaseInstanceResponse {
	s.Body = v
	return s
}

type SwitchSchedulerRuleRequest struct {
	// The name of the scheduling rule to manage.
	//
	// > You can call the [DescribeSchedulerRules](~~157481~~) operation to query the names of all scheduling rules.
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	// The type of the scheduling rule. Valid values:
	//
	// *   **2**: tiered protection rule
	// *   **3**: network acceleration rule
	// *   **5**: Alibaba Cloud CDN (CDN) interaction rule
	// *   **6**: cloud service interaction rule
	RuleType *int32 `json:"RuleType,omitempty" xml:"RuleType,omitempty"`
	// The configuration that is used to switch service traffic. This parameter is a string that consists of JSON arrays. Each element in a JSON array is a JSON struct that includes the following parameters:
	//
	// *   **Value**: required. The IP address of the associated resource. Data type: string.
	//
	// *   **State**: required. The operation type. Data type: integer. Valid values:
	//
	//     *   **0**: switches service traffic from the associated resource to your Anti-DDoS Pro or Anti-DDoS Premium instance for scrubbing.
	//     *   **1**: switches service traffic back to the associated cloud resource.
	//
	// *   **Interval**: optional. The waiting time that is required before the service traffic is switched back. Unit: minutes. Data type: integer. Usage notes:
	//
	//     *   If the **State** parameter is set to **0**, you must set this parameter to \*\*-1\*\*. Otherwise, the call fails.
	//     *   If the **State** parameter is set to **1**, you do not need to set this parameter.
	SwitchData *string `json:"SwitchData,omitempty" xml:"SwitchData,omitempty"`
}

func (s SwitchSchedulerRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s SwitchSchedulerRuleRequest) GoString() string {
	return s.String()
}

func (s *SwitchSchedulerRuleRequest) SetRuleName(v string) *SwitchSchedulerRuleRequest {
	s.RuleName = &v
	return s
}

func (s *SwitchSchedulerRuleRequest) SetRuleType(v int32) *SwitchSchedulerRuleRequest {
	s.RuleType = &v
	return s
}

func (s *SwitchSchedulerRuleRequest) SetSwitchData(v string) *SwitchSchedulerRuleRequest {
	s.SwitchData = &v
	return s
}

type SwitchSchedulerRuleResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SwitchSchedulerRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SwitchSchedulerRuleResponseBody) GoString() string {
	return s.String()
}

func (s *SwitchSchedulerRuleResponseBody) SetRequestId(v string) *SwitchSchedulerRuleResponseBody {
	s.RequestId = &v
	return s
}

type SwitchSchedulerRuleResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SwitchSchedulerRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SwitchSchedulerRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s SwitchSchedulerRuleResponse) GoString() string {
	return s.String()
}

func (s *SwitchSchedulerRuleResponse) SetHeaders(v map[string]*string) *SwitchSchedulerRuleResponse {
	s.Headers = v
	return s
}

func (s *SwitchSchedulerRuleResponse) SetStatusCode(v int32) *SwitchSchedulerRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *SwitchSchedulerRuleResponse) SetBody(v *SwitchSchedulerRuleResponseBody) *SwitchSchedulerRuleResponse {
	s.Body = v
	return s
}

type Client struct {
	openapi.Client
}

func NewClient(config *openapi.Config) (*Client, error) {
	client := new(Client)
	err := client.Init(config)
	return client, err
}

func (client *Client) Init(config *openapi.Config) (_err error) {
	_err = client.Client.Init(config)
	if _err != nil {
		return _err
	}
	client.EndpointRule = tea.String("regional")
	_err = client.CheckConfig(config)
	if _err != nil {
		return _err
	}
	client.Endpoint, _err = client.GetEndpoint(tea.String("ddoscoo"), client.RegionId, client.EndpointRule, client.Network, client.Suffix, client.EndpointMap, client.Endpoint)
	if _err != nil {
		return _err
	}

	return nil
}

func (client *Client) GetEndpoint(productId *string, regionId *string, endpointRule *string, network *string, suffix *string, endpointMap map[string]*string, endpoint *string) (_result *string, _err error) {
	if !tea.BoolValue(util.Empty(endpoint)) {
		_result = endpoint
		return _result, _err
	}

	if !tea.BoolValue(util.IsUnset(endpointMap)) && !tea.BoolValue(util.Empty(endpointMap[tea.StringValue(regionId)])) {
		_result = endpointMap[tea.StringValue(regionId)]
		return _result, _err
	}

	_body, _err := endpointutil.GetEndpointRules(productId, regionId, endpointRule, network, suffix)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddAutoCcBlacklistWithOptions(request *AddAutoCcBlacklistRequest, runtime *util.RuntimeOptions) (_result *AddAutoCcBlacklistResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Blacklist)) {
		query["Blacklist"] = request.Blacklist
	}

	if !tea.BoolValue(util.IsUnset(request.ExpireTime)) {
		query["ExpireTime"] = request.ExpireTime
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddAutoCcBlacklist"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddAutoCcBlacklistResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddAutoCcBlacklist(request *AddAutoCcBlacklistRequest) (_result *AddAutoCcBlacklistResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddAutoCcBlacklistResponse{}
	_body, _err := client.AddAutoCcBlacklistWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the AddAutoCcWhitelist operation to add IP addresses to the whitelist of an Anti-DDoS Pro or Anti-DDoS Premium instance. This way, the Anti-DDoS Pro or Anti-DDoS Premium instance allows traffic from the IP addresses.
 * By default, the traffic from the IP addresses that you add to the whitelist is always allowed. If you no longer use the whitelist, you can call the [EmptyAutoCcWhitelist](~~157505~~) operation to remove the IP addresses from the whitelist.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request AddAutoCcWhitelistRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddAutoCcWhitelistResponse
 */
func (client *Client) AddAutoCcWhitelistWithOptions(request *AddAutoCcWhitelistRequest, runtime *util.RuntimeOptions) (_result *AddAutoCcWhitelistResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ExpireTime)) {
		query["ExpireTime"] = request.ExpireTime
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Whitelist)) {
		query["Whitelist"] = request.Whitelist
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddAutoCcWhitelist"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddAutoCcWhitelistResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the AddAutoCcWhitelist operation to add IP addresses to the whitelist of an Anti-DDoS Pro or Anti-DDoS Premium instance. This way, the Anti-DDoS Pro or Anti-DDoS Premium instance allows traffic from the IP addresses.
 * By default, the traffic from the IP addresses that you add to the whitelist is always allowed. If you no longer use the whitelist, you can call the [EmptyAutoCcWhitelist](~~157505~~) operation to remove the IP addresses from the whitelist.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request AddAutoCcWhitelistRequest
 * @return AddAutoCcWhitelistResponse
 */
func (client *Client) AddAutoCcWhitelist(request *AddAutoCcWhitelistRequest) (_result *AddAutoCcWhitelistResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddAutoCcWhitelistResponse{}
	_body, _err := client.AddAutoCcWhitelistWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AssociateWebCertWithOptions(request *AssociateWebCertRequest, runtime *util.RuntimeOptions) (_result *AssociateWebCertResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Cert)) {
		query["Cert"] = request.Cert
	}

	if !tea.BoolValue(util.IsUnset(request.CertId)) {
		query["CertId"] = request.CertId
	}

	if !tea.BoolValue(util.IsUnset(request.CertIdentifier)) {
		query["CertIdentifier"] = request.CertIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.CertName)) {
		query["CertName"] = request.CertName
	}

	if !tea.BoolValue(util.IsUnset(request.CertRegion)) {
		query["CertRegion"] = request.CertRegion
	}

	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.Key)) {
		query["Key"] = request.Key
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AssociateWebCert"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AssociateWebCertResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AssociateWebCert(request *AssociateWebCertRequest) (_result *AssociateWebCertResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AssociateWebCertResponse{}
	_body, _err := client.AssociateWebCertWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AttachSceneDefenseObjectWithOptions(request *AttachSceneDefenseObjectRequest, runtime *util.RuntimeOptions) (_result *AttachSceneDefenseObjectResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ObjectType)) {
		query["ObjectType"] = request.ObjectType
	}

	if !tea.BoolValue(util.IsUnset(request.Objects)) {
		query["Objects"] = request.Objects
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyId)) {
		query["PolicyId"] = request.PolicyId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AttachSceneDefenseObject"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AttachSceneDefenseObjectResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AttachSceneDefenseObject(request *AttachSceneDefenseObjectRequest) (_result *AttachSceneDefenseObjectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AttachSceneDefenseObjectResponse{}
	_body, _err := client.AttachSceneDefenseObjectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If multiple origin servers are configured for a website that is added to Anti-DDoS Pro or Anti-DDoS Premium, you can modify the load balancing algorithms for back-to-origin traffic based on back-to-origin policies. The IP hash algorithm is used by default. You can change the algorithm to the round-robin or least response time algorithm. For more information, see the description of the **Policy** parameter in the "Request parameters" section of this topic.
 *
 * @param request ConfigL7RsPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConfigL7RsPolicyResponse
 */
func (client *Client) ConfigL7RsPolicyWithOptions(request *ConfigL7RsPolicyRequest, runtime *util.RuntimeOptions) (_result *ConfigL7RsPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.Policy)) {
		query["Policy"] = request.Policy
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ConfigL7RsPolicy"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ConfigL7RsPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If multiple origin servers are configured for a website that is added to Anti-DDoS Pro or Anti-DDoS Premium, you can modify the load balancing algorithms for back-to-origin traffic based on back-to-origin policies. The IP hash algorithm is used by default. You can change the algorithm to the round-robin or least response time algorithm. For more information, see the description of the **Policy** parameter in the "Request parameters" section of this topic.
 *
 * @param request ConfigL7RsPolicyRequest
 * @return ConfigL7RsPolicyResponse
 */
func (client *Client) ConfigL7RsPolicy(request *ConfigL7RsPolicyRequest) (_result *ConfigL7RsPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ConfigL7RsPolicyResponse{}
	_body, _err := client.ConfigL7RsPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ConfigLayer4RealLimitWithOptions(request *ConfigLayer4RealLimitRequest, runtime *util.RuntimeOptions) (_result *ConfigLayer4RealLimitResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.LimitValue)) {
		query["LimitValue"] = request.LimitValue
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ConfigLayer4RealLimit"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ConfigLayer4RealLimitResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ConfigLayer4RealLimit(request *ConfigLayer4RealLimitRequest) (_result *ConfigLayer4RealLimitResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ConfigLayer4RealLimitResponse{}
	_body, _err := client.ConfigLayer4RealLimitWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ConfigLayer4RemarkWithOptions(request *ConfigLayer4RemarkRequest, runtime *util.RuntimeOptions) (_result *ConfigLayer4RemarkResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Listeners)) {
		query["Listeners"] = request.Listeners
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ConfigLayer4Remark"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ConfigLayer4RemarkResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ConfigLayer4Remark(request *ConfigLayer4RemarkRequest) (_result *ConfigLayer4RemarkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ConfigLayer4RemarkResponse{}
	_body, _err := client.ConfigLayer4RemarkWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ConfigLayer4RuleBakModeWithOptions(request *ConfigLayer4RuleBakModeRequest, runtime *util.RuntimeOptions) (_result *ConfigLayer4RuleBakModeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BakMode)) {
		query["BakMode"] = request.BakMode
	}

	if !tea.BoolValue(util.IsUnset(request.Listeners)) {
		query["Listeners"] = request.Listeners
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ConfigLayer4RuleBakMode"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ConfigLayer4RuleBakModeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ConfigLayer4RuleBakMode(request *ConfigLayer4RuleBakModeRequest) (_result *ConfigLayer4RuleBakModeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ConfigLayer4RuleBakModeResponse{}
	_body, _err := client.ConfigLayer4RuleBakModeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ConfigLayer4RulePolicyWithOptions(request *ConfigLayer4RulePolicyRequest, runtime *util.RuntimeOptions) (_result *ConfigLayer4RulePolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Listeners)) {
		query["Listeners"] = request.Listeners
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ConfigLayer4RulePolicy"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ConfigLayer4RulePolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ConfigLayer4RulePolicy(request *ConfigLayer4RulePolicyRequest) (_result *ConfigLayer4RulePolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ConfigLayer4RulePolicyResponse{}
	_body, _err := client.ConfigLayer4RulePolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ConfigNetworkRegionBlockWithOptions(request *ConfigNetworkRegionBlockRequest, runtime *util.RuntimeOptions) (_result *ConfigNetworkRegionBlockResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Config)) {
		query["Config"] = request.Config
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ConfigNetworkRegionBlock"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ConfigNetworkRegionBlockResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ConfigNetworkRegionBlock(request *ConfigNetworkRegionBlockRequest) (_result *ConfigNetworkRegionBlockResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ConfigNetworkRegionBlockResponse{}
	_body, _err := client.ConfigNetworkRegionBlockWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ConfigNetworkRulesWithOptions(request *ConfigNetworkRulesRequest, runtime *util.RuntimeOptions) (_result *ConfigNetworkRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NetworkRules)) {
		query["NetworkRules"] = request.NetworkRules
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ConfigNetworkRules"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ConfigNetworkRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ConfigNetworkRules(request *ConfigNetworkRulesRequest) (_result *ConfigNetworkRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ConfigNetworkRulesResponse{}
	_body, _err := client.ConfigNetworkRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to configure filtering policies to filter out UDP traffic from specific ports. This helps defend against UDP reflection attacks.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request ConfigUdpReflectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConfigUdpReflectResponse
 */
func (client *Client) ConfigUdpReflectWithOptions(request *ConfigUdpReflectRequest, runtime *util.RuntimeOptions) (_result *ConfigUdpReflectResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Config)) {
		query["Config"] = request.Config
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ConfigUdpReflect"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ConfigUdpReflectResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to configure filtering policies to filter out UDP traffic from specific ports. This helps defend against UDP reflection attacks.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request ConfigUdpReflectRequest
 * @return ConfigUdpReflectResponse
 */
func (client *Client) ConfigUdpReflect(request *ConfigUdpReflectRequest) (_result *ConfigUdpReflectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ConfigUdpReflectResponse{}
	_body, _err := client.ConfigUdpReflectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ConfigWebCCTemplateWithOptions(request *ConfigWebCCTemplateRequest, runtime *util.RuntimeOptions) (_result *ConfigWebCCTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Template)) {
		query["Template"] = request.Template
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ConfigWebCCTemplate"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ConfigWebCCTemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ConfigWebCCTemplate(request *ConfigWebCCTemplateRequest) (_result *ConfigWebCCTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ConfigWebCCTemplateResponse{}
	_body, _err := client.ConfigWebCCTemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ConfigWebIpSetWithOptions(request *ConfigWebIpSetRequest, runtime *util.RuntimeOptions) (_result *ConfigWebIpSetResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BlackList)) {
		query["BlackList"] = request.BlackList
	}

	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.WhiteList)) {
		query["WhiteList"] = request.WhiteList
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ConfigWebIpSet"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ConfigWebIpSetResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ConfigWebIpSet(request *ConfigWebIpSetRequest) (_result *ConfigWebIpSetResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ConfigWebIpSetResponse{}
	_body, _err := client.ConfigWebIpSetWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateAsyncTaskWithOptions(request *CreateAsyncTaskRequest, runtime *util.RuntimeOptions) (_result *CreateAsyncTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskParams)) {
		query["TaskParams"] = request.TaskParams
	}

	if !tea.BoolValue(util.IsUnset(request.TaskType)) {
		query["TaskType"] = request.TaskType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateAsyncTask"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateAsyncTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateAsyncTask(request *CreateAsyncTaskRequest) (_result *CreateAsyncTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateAsyncTaskResponse{}
	_body, _err := client.CreateAsyncTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateDomainResourceWithOptions(request *CreateDomainResourceRequest, runtime *util.RuntimeOptions) (_result *CreateDomainResourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.HttpsExt)) {
		query["HttpsExt"] = request.HttpsExt
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.ProxyTypes)) {
		query["ProxyTypes"] = request.ProxyTypes
	}

	if !tea.BoolValue(util.IsUnset(request.RealServers)) {
		query["RealServers"] = request.RealServers
	}

	if !tea.BoolValue(util.IsUnset(request.RsType)) {
		query["RsType"] = request.RsType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDomainResource"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDomainResourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateDomainResource(request *CreateDomainResourceRequest) (_result *CreateDomainResourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDomainResourceResponse{}
	_body, _err := client.CreateDomainResourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateNetworkRulesWithOptions(request *CreateNetworkRulesRequest, runtime *util.RuntimeOptions) (_result *CreateNetworkRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NetworkRules)) {
		query["NetworkRules"] = request.NetworkRules
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateNetworkRules"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateNetworkRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateNetworkRules(request *CreateNetworkRulesRequest) (_result *CreateNetworkRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateNetworkRulesResponse{}
	_body, _err := client.CreateNetworkRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation by using Terraform. For more information about Terraform, see [What is Terraform?](~~95820~~).
 *
 * @param request CreatePortRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreatePortResponse
 */
func (client *Client) CreatePortWithOptions(request *CreatePortRequest, runtime *util.RuntimeOptions) (_result *CreatePortResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackendPort)) {
		query["BackendPort"] = request.BackendPort
	}

	if !tea.BoolValue(util.IsUnset(request.FrontendPort)) {
		query["FrontendPort"] = request.FrontendPort
	}

	if !tea.BoolValue(util.IsUnset(request.FrontendProtocol)) {
		query["FrontendProtocol"] = request.FrontendProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RealServers)) {
		query["RealServers"] = request.RealServers
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreatePort"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreatePortResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation by using Terraform. For more information about Terraform, see [What is Terraform?](~~95820~~).
 *
 * @param request CreatePortRequest
 * @return CreatePortResponse
 */
func (client *Client) CreatePort(request *CreatePortRequest) (_result *CreatePortResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreatePortResponse{}
	_body, _err := client.CreatePortWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateSceneDefensePolicyWithOptions(request *CreateSceneDefensePolicyRequest, runtime *util.RuntimeOptions) (_result *CreateSceneDefensePolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Template)) {
		query["Template"] = request.Template
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateSceneDefensePolicy"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateSceneDefensePolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateSceneDefensePolicy(request *CreateSceneDefensePolicyRequest) (_result *CreateSceneDefensePolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateSceneDefensePolicyResponse{}
	_body, _err := client.CreateSceneDefensePolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateSchedulerRuleWithOptions(request *CreateSchedulerRuleRequest, runtime *util.RuntimeOptions) (_result *CreateSchedulerRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Param)) {
		query["Param"] = request.Param
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleName)) {
		query["RuleName"] = request.RuleName
	}

	if !tea.BoolValue(util.IsUnset(request.RuleType)) {
		query["RuleType"] = request.RuleType
	}

	if !tea.BoolValue(util.IsUnset(request.Rules)) {
		query["Rules"] = request.Rules
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateSchedulerRule"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateSchedulerRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateSchedulerRule(request *CreateSchedulerRuleRequest) (_result *CreateSchedulerRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateSchedulerRuleResponse{}
	_body, _err := client.CreateSchedulerRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the CreateTagResources operation to add a tag to multiple Anti-DDoS Pro instances at a time.
 * > Anti-DDoS Premium does not support the tag feature.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request CreateTagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTagResourcesResponse
 */
func (client *Client) CreateTagResourcesWithOptions(request *CreateTagResourcesRequest, runtime *util.RuntimeOptions) (_result *CreateTagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceIds)) {
		query["ResourceIds"] = request.ResourceIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateTagResources"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateTagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the CreateTagResources operation to add a tag to multiple Anti-DDoS Pro instances at a time.
 * > Anti-DDoS Premium does not support the tag feature.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request CreateTagResourcesRequest
 * @return CreateTagResourcesResponse
 */
func (client *Client) CreateTagResources(request *CreateTagResourcesRequest) (_result *CreateTagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateTagResourcesResponse{}
	_body, _err := client.CreateTagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateWebCCRuleWithOptions(request *CreateWebCCRuleRequest, runtime *util.RuntimeOptions) (_result *CreateWebCCRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Act)) {
		query["Act"] = request.Act
	}

	if !tea.BoolValue(util.IsUnset(request.Count)) {
		query["Count"] = request.Count
	}

	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.Mode)) {
		query["Mode"] = request.Mode
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Ttl)) {
		query["Ttl"] = request.Ttl
	}

	if !tea.BoolValue(util.IsUnset(request.Uri)) {
		query["Uri"] = request.Uri
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateWebCCRule"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateWebCCRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateWebCCRule(request *CreateWebCCRuleRequest) (_result *CreateWebCCRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateWebCCRuleResponse{}
	_body, _err := client.CreateWebCCRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateWebRuleWithOptions(request *CreateWebRuleRequest, runtime *util.RuntimeOptions) (_result *CreateWebRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DefenseId)) {
		query["DefenseId"] = request.DefenseId
	}

	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.HttpsExt)) {
		query["HttpsExt"] = request.HttpsExt
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RsType)) {
		query["RsType"] = request.RsType
	}

	if !tea.BoolValue(util.IsUnset(request.Rules)) {
		query["Rules"] = request.Rules
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateWebRule"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateWebRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateWebRule(request *CreateWebRuleRequest) (_result *CreateWebRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateWebRuleResponse{}
	_body, _err := client.CreateWebRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteAsyncTaskWithOptions(request *DeleteAsyncTaskRequest, runtime *util.RuntimeOptions) (_result *DeleteAsyncTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAsyncTask"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteAsyncTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteAsyncTask(request *DeleteAsyncTaskRequest) (_result *DeleteAsyncTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAsyncTaskResponse{}
	_body, _err := client.DeleteAsyncTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteAutoCcBlacklistWithOptions(request *DeleteAutoCcBlacklistRequest, runtime *util.RuntimeOptions) (_result *DeleteAutoCcBlacklistResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Blacklist)) {
		query["Blacklist"] = request.Blacklist
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAutoCcBlacklist"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteAutoCcBlacklistResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteAutoCcBlacklist(request *DeleteAutoCcBlacklistRequest) (_result *DeleteAutoCcBlacklistResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAutoCcBlacklistResponse{}
	_body, _err := client.DeleteAutoCcBlacklistWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteAutoCcWhitelistWithOptions(request *DeleteAutoCcWhitelistRequest, runtime *util.RuntimeOptions) (_result *DeleteAutoCcWhitelistResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Whitelist)) {
		query["Whitelist"] = request.Whitelist
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAutoCcWhitelist"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteAutoCcWhitelistResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteAutoCcWhitelist(request *DeleteAutoCcWhitelistRequest) (_result *DeleteAutoCcWhitelistResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAutoCcWhitelistResponse{}
	_body, _err := client.DeleteAutoCcWhitelistWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteDomainResourceWithOptions(request *DeleteDomainResourceRequest, runtime *util.RuntimeOptions) (_result *DeleteDomainResourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDomainResource"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDomainResourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteDomainResource(request *DeleteDomainResourceRequest) (_result *DeleteDomainResourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDomainResourceResponse{}
	_body, _err := client.DeleteDomainResourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteNetworkRuleWithOptions(request *DeleteNetworkRuleRequest, runtime *util.RuntimeOptions) (_result *DeleteNetworkRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NetworkRule)) {
		query["NetworkRule"] = request.NetworkRule
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteNetworkRule"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteNetworkRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteNetworkRule(request *DeleteNetworkRuleRequest) (_result *DeleteNetworkRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteNetworkRuleResponse{}
	_body, _err := client.DeleteNetworkRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * After you delete a port forwarding rule, the Anti-DDoS Pro or Anti-DDoS Premium instance no longer forwards service traffic on the Layer 4 port. Before you delete a specific port forwarding rule, make sure that the service traffic destined for the Layer 4 port is redirected to the origin server. This can prevent negative impacts on your services.
 * > You can call this operation by using Terraform. For more information about Terraform, see [What is Terraform?](~~95820~~).
 *
 * @param request DeletePortRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeletePortResponse
 */
func (client *Client) DeletePortWithOptions(request *DeletePortRequest, runtime *util.RuntimeOptions) (_result *DeletePortResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackendPort)) {
		query["BackendPort"] = request.BackendPort
	}

	if !tea.BoolValue(util.IsUnset(request.FrontendPort)) {
		query["FrontendPort"] = request.FrontendPort
	}

	if !tea.BoolValue(util.IsUnset(request.FrontendProtocol)) {
		query["FrontendProtocol"] = request.FrontendProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RealServers)) {
		query["RealServers"] = request.RealServers
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeletePort"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeletePortResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * After you delete a port forwarding rule, the Anti-DDoS Pro or Anti-DDoS Premium instance no longer forwards service traffic on the Layer 4 port. Before you delete a specific port forwarding rule, make sure that the service traffic destined for the Layer 4 port is redirected to the origin server. This can prevent negative impacts on your services.
 * > You can call this operation by using Terraform. For more information about Terraform, see [What is Terraform?](~~95820~~).
 *
 * @param request DeletePortRequest
 * @return DeletePortResponse
 */
func (client *Client) DeletePort(request *DeletePortRequest) (_result *DeletePortResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeletePortResponse{}
	_body, _err := client.DeletePortWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteSceneDefensePolicyWithOptions(request *DeleteSceneDefensePolicyRequest, runtime *util.RuntimeOptions) (_result *DeleteSceneDefensePolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PolicyId)) {
		query["PolicyId"] = request.PolicyId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSceneDefensePolicy"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteSceneDefensePolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteSceneDefensePolicy(request *DeleteSceneDefensePolicyRequest) (_result *DeleteSceneDefensePolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteSceneDefensePolicyResponse{}
	_body, _err := client.DeleteSceneDefensePolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteSchedulerRuleWithOptions(request *DeleteSchedulerRuleRequest, runtime *util.RuntimeOptions) (_result *DeleteSchedulerRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleName)) {
		query["RuleName"] = request.RuleName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSchedulerRule"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteSchedulerRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteSchedulerRule(request *DeleteSchedulerRuleRequest) (_result *DeleteSchedulerRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteSchedulerRuleResponse{}
	_body, _err := client.DeleteSchedulerRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the DeleteTagResources operation to remove tags from Anti-DDoS Pro instances.
 * > Only Anti-DDoS Pro supports tags.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DeleteTagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTagResourcesResponse
 */
func (client *Client) DeleteTagResourcesWithOptions(request *DeleteTagResourcesRequest, runtime *util.RuntimeOptions) (_result *DeleteTagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.All)) {
		query["All"] = request.All
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceIds)) {
		query["ResourceIds"] = request.ResourceIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TagKey)) {
		query["TagKey"] = request.TagKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteTagResources"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteTagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the DeleteTagResources operation to remove tags from Anti-DDoS Pro instances.
 * > Only Anti-DDoS Pro supports tags.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DeleteTagResourcesRequest
 * @return DeleteTagResourcesResponse
 */
func (client *Client) DeleteTagResources(request *DeleteTagResourcesRequest) (_result *DeleteTagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteTagResourcesResponse{}
	_body, _err := client.DeleteTagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteWebCCRuleWithOptions(request *DeleteWebCCRuleRequest, runtime *util.RuntimeOptions) (_result *DeleteWebCCRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteWebCCRule"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteWebCCRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteWebCCRule(request *DeleteWebCCRuleRequest) (_result *DeleteWebCCRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteWebCCRuleResponse{}
	_body, _err := client.DeleteWebCCRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the DeleteWebCacheCustomRule operation to delete the custom rules of the Static Page Caching policy for a website.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DeleteWebCacheCustomRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteWebCacheCustomRuleResponse
 */
func (client *Client) DeleteWebCacheCustomRuleWithOptions(request *DeleteWebCacheCustomRuleRequest, runtime *util.RuntimeOptions) (_result *DeleteWebCacheCustomRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleNames)) {
		query["RuleNames"] = request.RuleNames
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteWebCacheCustomRule"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteWebCacheCustomRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the DeleteWebCacheCustomRule operation to delete the custom rules of the Static Page Caching policy for a website.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DeleteWebCacheCustomRuleRequest
 * @return DeleteWebCacheCustomRuleResponse
 */
func (client *Client) DeleteWebCacheCustomRule(request *DeleteWebCacheCustomRuleRequest) (_result *DeleteWebCacheCustomRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteWebCacheCustomRuleResponse{}
	_body, _err := client.DeleteWebCacheCustomRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteWebPreciseAccessRuleWithOptions(request *DeleteWebPreciseAccessRuleRequest, runtime *util.RuntimeOptions) (_result *DeleteWebPreciseAccessRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleNames)) {
		query["RuleNames"] = request.RuleNames
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteWebPreciseAccessRule"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteWebPreciseAccessRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteWebPreciseAccessRule(request *DeleteWebPreciseAccessRuleRequest) (_result *DeleteWebPreciseAccessRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteWebPreciseAccessRuleResponse{}
	_body, _err := client.DeleteWebPreciseAccessRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteWebRuleWithOptions(request *DeleteWebRuleRequest, runtime *util.RuntimeOptions) (_result *DeleteWebRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteWebRule"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteWebRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteWebRule(request *DeleteWebRuleRequest) (_result *DeleteWebRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteWebRuleResponse{}
	_body, _err := client.DeleteWebRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the DescribeAsyncTasks operation to query the details of asynchronous export tasks, such as the IDs, start time, end time, status, parameters, and results.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeAsyncTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAsyncTasksResponse
 */
func (client *Client) DescribeAsyncTasksWithOptions(request *DescribeAsyncTasksRequest, runtime *util.RuntimeOptions) (_result *DescribeAsyncTasksResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeAsyncTasks"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeAsyncTasksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the DescribeAsyncTasks operation to query the details of asynchronous export tasks, such as the IDs, start time, end time, status, parameters, and results.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeAsyncTasksRequest
 * @return DescribeAsyncTasksResponse
 */
func (client *Client) DescribeAsyncTasks(request *DescribeAsyncTasksRequest) (_result *DescribeAsyncTasksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeAsyncTasksResponse{}
	_body, _err := client.DescribeAsyncTasksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeAttackAnalysisMaxQpsWithOptions(request *DescribeAttackAnalysisMaxQpsRequest, runtime *util.RuntimeOptions) (_result *DescribeAttackAnalysisMaxQpsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeAttackAnalysisMaxQps"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeAttackAnalysisMaxQpsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeAttackAnalysisMaxQps(request *DescribeAttackAnalysisMaxQpsRequest) (_result *DescribeAttackAnalysisMaxQpsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeAttackAnalysisMaxQpsResponse{}
	_body, _err := client.DescribeAttackAnalysisMaxQpsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeAutoCcBlacklistWithOptions(request *DescribeAutoCcBlacklistRequest, runtime *util.RuntimeOptions) (_result *DescribeAutoCcBlacklistResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.KeyWord)) {
		query["KeyWord"] = request.KeyWord
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeAutoCcBlacklist"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeAutoCcBlacklistResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeAutoCcBlacklist(request *DescribeAutoCcBlacklistRequest) (_result *DescribeAutoCcBlacklistResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeAutoCcBlacklistResponse{}
	_body, _err := client.DescribeAutoCcBlacklistWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeAutoCcListCountWithOptions(request *DescribeAutoCcListCountRequest, runtime *util.RuntimeOptions) (_result *DescribeAutoCcListCountResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.QueryType)) {
		query["QueryType"] = request.QueryType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeAutoCcListCount"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeAutoCcListCountResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeAutoCcListCount(request *DescribeAutoCcListCountRequest) (_result *DescribeAutoCcListCountResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeAutoCcListCountResponse{}
	_body, _err := client.DescribeAutoCcListCountWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeAutoCcWhitelistWithOptions(request *DescribeAutoCcWhitelistRequest, runtime *util.RuntimeOptions) (_result *DescribeAutoCcWhitelistResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.KeyWord)) {
		query["KeyWord"] = request.KeyWord
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeAutoCcWhitelist"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeAutoCcWhitelistResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeAutoCcWhitelist(request *DescribeAutoCcWhitelistRequest) (_result *DescribeAutoCcWhitelistResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeAutoCcWhitelistResponse{}
	_body, _err := client.DescribeAutoCcWhitelistWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeBackSourceCidrWithOptions(request *DescribeBackSourceCidrRequest, runtime *util.RuntimeOptions) (_result *DescribeBackSourceCidrResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IpVersion)) {
		query["IpVersion"] = request.IpVersion
	}

	if !tea.BoolValue(util.IsUnset(request.Line)) {
		query["Line"] = request.Line
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeBackSourceCidr"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeBackSourceCidrResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeBackSourceCidr(request *DescribeBackSourceCidrRequest) (_result *DescribeBackSourceCidrResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeBackSourceCidrResponse{}
	_body, _err := client.DescribeBackSourceCidrWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeBlackholeStatusWithOptions(request *DescribeBlackholeStatusRequest, runtime *util.RuntimeOptions) (_result *DescribeBlackholeStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeBlackholeStatus"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeBlackholeStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeBlackholeStatus(request *DescribeBlackholeStatusRequest) (_result *DescribeBlackholeStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeBlackholeStatusResponse{}
	_body, _err := client.DescribeBlackholeStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation is used to query the Diversion from Origin Server configurations of one or more Anti-DDoS Pro instances.
 * > This operation is suitable only for Anti-DDoS Pro.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeBlockStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBlockStatusResponse
 */
func (client *Client) DescribeBlockStatusWithOptions(request *DescribeBlockStatusRequest, runtime *util.RuntimeOptions) (_result *DescribeBlockStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeBlockStatus"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeBlockStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation is used to query the Diversion from Origin Server configurations of one or more Anti-DDoS Pro instances.
 * > This operation is suitable only for Anti-DDoS Pro.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeBlockStatusRequest
 * @return DescribeBlockStatusResponse
 */
func (client *Client) DescribeBlockStatus(request *DescribeBlockStatusRequest) (_result *DescribeBlockStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeBlockStatusResponse{}
	_body, _err := client.DescribeBlockStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCertsWithOptions(request *DescribeCertsRequest, runtime *util.RuntimeOptions) (_result *DescribeCertsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCerts"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCertsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCerts(request *DescribeCertsRequest) (_result *DescribeCertsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCertsResponse{}
	_body, _err := client.DescribeCertsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCnameReusesWithOptions(request *DescribeCnameReusesRequest, runtime *util.RuntimeOptions) (_result *DescribeCnameReusesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domains)) {
		query["Domains"] = request.Domains
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCnameReuses"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCnameReusesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCnameReuses(request *DescribeCnameReusesRequest) (_result *DescribeCnameReusesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCnameReusesResponse{}
	_body, _err := client.DescribeCnameReusesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDDoSEventsWithOptions(request *DescribeDDoSEventsRequest, runtime *util.RuntimeOptions) (_result *DescribeDDoSEventsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDDoSEvents"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDDoSEventsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDDoSEvents(request *DescribeDDoSEventsRequest) (_result *DescribeDDoSEventsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDDoSEventsResponse{}
	_body, _err := client.DescribeDDoSEventsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the DescribeDDosAllEventList operation to query DDoS attack events within a specific time range by page. The information about a DDoS attack event includes the start time and end time of the attack, attack event type, attacked object, peak bandwidth of attack traffic, and peak packet forwarding rate.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeDDosAllEventListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDDosAllEventListResponse
 */
func (client *Client) DescribeDDosAllEventListWithOptions(request *DescribeDDosAllEventListRequest, runtime *util.RuntimeOptions) (_result *DescribeDDosAllEventListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.EventType)) {
		query["EventType"] = request.EventType
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDDosAllEventList"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDDosAllEventListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the DescribeDDosAllEventList operation to query DDoS attack events within a specific time range by page. The information about a DDoS attack event includes the start time and end time of the attack, attack event type, attacked object, peak bandwidth of attack traffic, and peak packet forwarding rate.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeDDosAllEventListRequest
 * @return DescribeDDosAllEventListResponse
 */
func (client *Client) DescribeDDosAllEventList(request *DescribeDDosAllEventListRequest) (_result *DescribeDDosAllEventListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDDosAllEventListResponse{}
	_body, _err := client.DescribeDDosAllEventListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > This operation is suitable only for volumetric attacks.
 *
 * @param request DescribeDDosEventAreaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDDosEventAreaResponse
 */
func (client *Client) DescribeDDosEventAreaWithOptions(request *DescribeDDosEventAreaRequest, runtime *util.RuntimeOptions) (_result *DescribeDDosEventAreaResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EventType)) {
		query["EventType"] = request.EventType
	}

	if !tea.BoolValue(util.IsUnset(request.Ip)) {
		query["Ip"] = request.Ip
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDDosEventArea"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDDosEventAreaResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > This operation is suitable only for volumetric attacks.
 *
 * @param request DescribeDDosEventAreaRequest
 * @return DescribeDDosEventAreaResponse
 */
func (client *Client) DescribeDDosEventArea(request *DescribeDDosEventAreaRequest) (_result *DescribeDDosEventAreaResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDDosEventAreaResponse{}
	_body, _err := client.DescribeDDosEventAreaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > This operation is suitable only for volumetric attacks.
 *
 * @param request DescribeDDosEventAttackTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDDosEventAttackTypeResponse
 */
func (client *Client) DescribeDDosEventAttackTypeWithOptions(request *DescribeDDosEventAttackTypeRequest, runtime *util.RuntimeOptions) (_result *DescribeDDosEventAttackTypeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EventType)) {
		query["EventType"] = request.EventType
	}

	if !tea.BoolValue(util.IsUnset(request.Ip)) {
		query["Ip"] = request.Ip
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDDosEventAttackType"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDDosEventAttackTypeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > This operation is suitable only for volumetric attacks.
 *
 * @param request DescribeDDosEventAttackTypeRequest
 * @return DescribeDDosEventAttackTypeResponse
 */
func (client *Client) DescribeDDosEventAttackType(request *DescribeDDosEventAttackTypeRequest) (_result *DescribeDDosEventAttackTypeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDDosEventAttackTypeResponse{}
	_body, _err := client.DescribeDDosEventAttackTypeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > This operation is suitable only for volumetric attacks.
 *
 * @param request DescribeDDosEventIspRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDDosEventIspResponse
 */
func (client *Client) DescribeDDosEventIspWithOptions(request *DescribeDDosEventIspRequest, runtime *util.RuntimeOptions) (_result *DescribeDDosEventIspResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EventType)) {
		query["EventType"] = request.EventType
	}

	if !tea.BoolValue(util.IsUnset(request.Ip)) {
		query["Ip"] = request.Ip
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDDosEventIsp"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDDosEventIspResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > This operation is suitable only for volumetric attacks.
 *
 * @param request DescribeDDosEventIspRequest
 * @return DescribeDDosEventIspResponse
 */
func (client *Client) DescribeDDosEventIsp(request *DescribeDDosEventIspRequest) (_result *DescribeDDosEventIspResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDDosEventIspResponse{}
	_body, _err := client.DescribeDDosEventIspWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDDosEventMaxWithOptions(request *DescribeDDosEventMaxRequest, runtime *util.RuntimeOptions) (_result *DescribeDDosEventMaxResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDDosEventMax"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDDosEventMaxResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDDosEventMax(request *DescribeDDosEventMaxRequest) (_result *DescribeDDosEventMaxResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDDosEventMaxResponse{}
	_body, _err := client.DescribeDDosEventMaxWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > This operation is suitable only for volumetric attacks.
 *
 * @param request DescribeDDosEventSrcIpRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDDosEventSrcIpResponse
 */
func (client *Client) DescribeDDosEventSrcIpWithOptions(request *DescribeDDosEventSrcIpRequest, runtime *util.RuntimeOptions) (_result *DescribeDDosEventSrcIpResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EventType)) {
		query["EventType"] = request.EventType
	}

	if !tea.BoolValue(util.IsUnset(request.Ip)) {
		query["Ip"] = request.Ip
	}

	if !tea.BoolValue(util.IsUnset(request.Range)) {
		query["Range"] = request.Range
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDDosEventSrcIp"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDDosEventSrcIpResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > This operation is suitable only for volumetric attacks.
 *
 * @param request DescribeDDosEventSrcIpRequest
 * @return DescribeDDosEventSrcIpResponse
 */
func (client *Client) DescribeDDosEventSrcIp(request *DescribeDDosEventSrcIpRequest) (_result *DescribeDDosEventSrcIpResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDDosEventSrcIpResponse{}
	_body, _err := client.DescribeDDosEventSrcIpWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the DescribeDefenseCountStatistics operation to query the information about advanced mitigation sessions of an Anti-DDoS Premium instance. For example, you can query the number of advanced mitigation sessions that are used within the current calendar month and the number of available global advanced mitigation sessions.
 * > This operation is suitable only for Anti-DDoS Premium.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeDefenseCountStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDefenseCountStatisticsResponse
 */
func (client *Client) DescribeDefenseCountStatisticsWithOptions(request *DescribeDefenseCountStatisticsRequest, runtime *util.RuntimeOptions) (_result *DescribeDefenseCountStatisticsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDefenseCountStatistics"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDefenseCountStatisticsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the DescribeDefenseCountStatistics operation to query the information about advanced mitigation sessions of an Anti-DDoS Premium instance. For example, you can query the number of advanced mitigation sessions that are used within the current calendar month and the number of available global advanced mitigation sessions.
 * > This operation is suitable only for Anti-DDoS Premium.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeDefenseCountStatisticsRequest
 * @return DescribeDefenseCountStatisticsResponse
 */
func (client *Client) DescribeDefenseCountStatistics(request *DescribeDefenseCountStatisticsRequest) (_result *DescribeDefenseCountStatisticsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDefenseCountStatisticsResponse{}
	_body, _err := client.DescribeDefenseCountStatisticsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > This operation is suitable only for Anti-DDoS Premium.
 *
 * @param request DescribeDefenseRecordsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDefenseRecordsResponse
 */
func (client *Client) DescribeDefenseRecordsWithOptions(request *DescribeDefenseRecordsRequest, runtime *util.RuntimeOptions) (_result *DescribeDefenseRecordsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDefenseRecords"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDefenseRecordsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > This operation is suitable only for Anti-DDoS Premium.
 *
 * @param request DescribeDefenseRecordsRequest
 * @return DescribeDefenseRecordsResponse
 */
func (client *Client) DescribeDefenseRecords(request *DescribeDefenseRecordsRequest) (_result *DescribeDefenseRecordsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDefenseRecordsResponse{}
	_body, _err := client.DescribeDefenseRecordsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDomainAttackEventsWithOptions(request *DescribeDomainAttackEventsRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainAttackEventsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainAttackEvents"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainAttackEventsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDomainAttackEvents(request *DescribeDomainAttackEventsRequest) (_result *DescribeDomainAttackEventsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainAttackEventsResponse{}
	_body, _err := client.DescribeDomainAttackEventsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDomainOverviewWithOptions(request *DescribeDomainOverviewRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainOverviewResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainOverview"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainOverviewResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDomainOverview(request *DescribeDomainOverviewRequest) (_result *DescribeDomainOverviewResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainOverviewResponse{}
	_body, _err := client.DescribeDomainOverviewWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDomainQPSListWithOptions(request *DescribeDomainQPSListRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainQPSListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainQPSList"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainQPSListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDomainQPSList(request *DescribeDomainQPSListRequest) (_result *DescribeDomainQPSListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainQPSListResponse{}
	_body, _err := client.DescribeDomainQPSListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the DescribeDomainResource operation to query the configurations of the forwarding rules that you create for a website by page. The configurations include the domain name-related configurations, protocol-related configurations, HTTPS-related configurations, and configurations that are used to mitigate HTTP flood attacks.
 * You can call this operation by using Terraform. For more information about Terraform, see [What is Terraform?](~~95820~~).
 * ### Limits
 * You can call this operation up to 50 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeDomainResourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDomainResourceResponse
 */
func (client *Client) DescribeDomainResourceWithOptions(request *DescribeDomainResourceRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainResourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.QueryDomainPattern)) {
		query["QueryDomainPattern"] = request.QueryDomainPattern
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainResource"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainResourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the DescribeDomainResource operation to query the configurations of the forwarding rules that you create for a website by page. The configurations include the domain name-related configurations, protocol-related configurations, HTTPS-related configurations, and configurations that are used to mitigate HTTP flood attacks.
 * You can call this operation by using Terraform. For more information about Terraform, see [What is Terraform?](~~95820~~).
 * ### Limits
 * You can call this operation up to 50 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeDomainResourceRequest
 * @return DescribeDomainResourceResponse
 */
func (client *Client) DescribeDomainResource(request *DescribeDomainResourceRequest) (_result *DescribeDomainResourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainResourceResponse{}
	_body, _err := client.DescribeDomainResourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDomainSecurityProfileWithOptions(request *DescribeDomainSecurityProfileRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainSecurityProfileResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainSecurityProfile"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainSecurityProfileResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDomainSecurityProfile(request *DescribeDomainSecurityProfileRequest) (_result *DescribeDomainSecurityProfileResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainSecurityProfileResponse{}
	_body, _err := client.DescribeDomainSecurityProfileWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDomainStatusCodeCountWithOptions(request *DescribeDomainStatusCodeCountRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainStatusCodeCountResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainStatusCodeCount"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainStatusCodeCountResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDomainStatusCodeCount(request *DescribeDomainStatusCodeCountRequest) (_result *DescribeDomainStatusCodeCountResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainStatusCodeCountResponse{}
	_body, _err := client.DescribeDomainStatusCodeCountWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDomainStatusCodeListWithOptions(request *DescribeDomainStatusCodeListRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainStatusCodeListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.QueryType)) {
		query["QueryType"] = request.QueryType
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainStatusCodeList"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainStatusCodeListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDomainStatusCodeList(request *DescribeDomainStatusCodeListRequest) (_result *DescribeDomainStatusCodeListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainStatusCodeListResponse{}
	_body, _err := client.DescribeDomainStatusCodeListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDomainTopAttackListWithOptions(request *DescribeDomainTopAttackListRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainTopAttackListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainTopAttackList"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainTopAttackListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDomainTopAttackList(request *DescribeDomainTopAttackListRequest) (_result *DescribeDomainTopAttackListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainTopAttackListResponse{}
	_body, _err := client.DescribeDomainTopAttackListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDomainViewSourceCountriesWithOptions(request *DescribeDomainViewSourceCountriesRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainViewSourceCountriesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainViewSourceCountries"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainViewSourceCountriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDomainViewSourceCountries(request *DescribeDomainViewSourceCountriesRequest) (_result *DescribeDomainViewSourceCountriesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainViewSourceCountriesResponse{}
	_body, _err := client.DescribeDomainViewSourceCountriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDomainViewSourceProvincesWithOptions(request *DescribeDomainViewSourceProvincesRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainViewSourceProvincesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainViewSourceProvinces"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainViewSourceProvincesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDomainViewSourceProvinces(request *DescribeDomainViewSourceProvincesRequest) (_result *DescribeDomainViewSourceProvincesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainViewSourceProvincesResponse{}
	_body, _err := client.DescribeDomainViewSourceProvincesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDomainViewTopCostTimeWithOptions(request *DescribeDomainViewTopCostTimeRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainViewTopCostTimeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Top)) {
		query["Top"] = request.Top
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainViewTopCostTime"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainViewTopCostTimeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDomainViewTopCostTime(request *DescribeDomainViewTopCostTimeRequest) (_result *DescribeDomainViewTopCostTimeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainViewTopCostTimeResponse{}
	_body, _err := client.DescribeDomainViewTopCostTimeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDomainViewTopUrlWithOptions(request *DescribeDomainViewTopUrlRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainViewTopUrlResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Top)) {
		query["Top"] = request.Top
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainViewTopUrl"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainViewTopUrlResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDomainViewTopUrl(request *DescribeDomainViewTopUrlRequest) (_result *DescribeDomainViewTopUrlResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainViewTopUrlResponse{}
	_body, _err := client.DescribeDomainViewTopUrlWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDomainsWithOptions(request *DescribeDomainsRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomains"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDomains(request *DescribeDomainsRequest) (_result *DescribeDomainsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainsResponse{}
	_body, _err := client.DescribeDomainsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > This operation is suitable only for Anti-DDoS Pro.
 *
 * @param request DescribeElasticBandwidthSpecRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeElasticBandwidthSpecResponse
 */
func (client *Client) DescribeElasticBandwidthSpecWithOptions(request *DescribeElasticBandwidthSpecRequest, runtime *util.RuntimeOptions) (_result *DescribeElasticBandwidthSpecResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeElasticBandwidthSpec"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeElasticBandwidthSpecResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > This operation is suitable only for Anti-DDoS Pro.
 *
 * @param request DescribeElasticBandwidthSpecRequest
 * @return DescribeElasticBandwidthSpecResponse
 */
func (client *Client) DescribeElasticBandwidthSpec(request *DescribeElasticBandwidthSpecRequest) (_result *DescribeElasticBandwidthSpecResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeElasticBandwidthSpecResponse{}
	_body, _err := client.DescribeElasticBandwidthSpecWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeElasticQpsWithOptions(request *DescribeElasticQpsRequest, runtime *util.RuntimeOptions) (_result *DescribeElasticQpsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.Ip)) {
		query["Ip"] = request.Ip
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeElasticQps"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeElasticQpsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeElasticQps(request *DescribeElasticQpsRequest) (_result *DescribeElasticQpsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeElasticQpsResponse{}
	_body, _err := client.DescribeElasticQpsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeElasticQpsRecordWithOptions(request *DescribeElasticQpsRecordRequest, runtime *util.RuntimeOptions) (_result *DescribeElasticQpsRecordResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Ip)) {
		query["Ip"] = request.Ip
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeElasticQpsRecord"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeElasticQpsRecordResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeElasticQpsRecord(request *DescribeElasticQpsRecordRequest) (_result *DescribeElasticQpsRecordResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeElasticQpsRecordResponse{}
	_body, _err := client.DescribeElasticQpsRecordWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeHeadersWithOptions(request *DescribeHeadersRequest, runtime *util.RuntimeOptions) (_result *DescribeHeadersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeHeaders"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeHeadersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeHeaders(request *DescribeHeadersRequest) (_result *DescribeHeadersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeHeadersResponse{}
	_body, _err := client.DescribeHeadersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeHealthCheckListWithOptions(request *DescribeHealthCheckListRequest, runtime *util.RuntimeOptions) (_result *DescribeHealthCheckListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NetworkRules)) {
		query["NetworkRules"] = request.NetworkRules
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeHealthCheckList"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeHealthCheckListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeHealthCheckList(request *DescribeHealthCheckListRequest) (_result *DescribeHealthCheckListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeHealthCheckListResponse{}
	_body, _err := client.DescribeHealthCheckListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeHealthCheckStatusWithOptions(request *DescribeHealthCheckStatusRequest, runtime *util.RuntimeOptions) (_result *DescribeHealthCheckStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NetworkRules)) {
		query["NetworkRules"] = request.NetworkRules
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeHealthCheckStatus"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeHealthCheckStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeHealthCheckStatus(request *DescribeHealthCheckStatusRequest) (_result *DescribeHealthCheckStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeHealthCheckStatusResponse{}
	_body, _err := client.DescribeHealthCheckStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the DescribeInstanceDetails operation to query the information about the IP addresses and ISP lines of the instances. The information includes the IP address, status, and protection line.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeInstanceDetailsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInstanceDetailsResponse
 */
func (client *Client) DescribeInstanceDetailsWithOptions(request *DescribeInstanceDetailsRequest, runtime *util.RuntimeOptions) (_result *DescribeInstanceDetailsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeInstanceDetails"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeInstanceDetailsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the DescribeInstanceDetails operation to query the information about the IP addresses and ISP lines of the instances. The information includes the IP address, status, and protection line.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeInstanceDetailsRequest
 * @return DescribeInstanceDetailsResponse
 */
func (client *Client) DescribeInstanceDetails(request *DescribeInstanceDetailsRequest) (_result *DescribeInstanceDetailsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeInstanceDetailsResponse{}
	_body, _err := client.DescribeInstanceDetailsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeInstanceExtWithOptions(request *DescribeInstanceExtRequest, runtime *util.RuntimeOptions) (_result *DescribeInstanceExtResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeInstanceExt"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeInstanceExtResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeInstanceExt(request *DescribeInstanceExtRequest) (_result *DescribeInstanceExtResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeInstanceExtResponse{}
	_body, _err := client.DescribeInstanceExtWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeInstanceIdsWithOptions(request *DescribeInstanceIdsRequest, runtime *util.RuntimeOptions) (_result *DescribeInstanceIdsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Edition)) {
		query["Edition"] = request.Edition
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeInstanceIds"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeInstanceIdsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeInstanceIds(request *DescribeInstanceIdsRequest) (_result *DescribeInstanceIdsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeInstanceIdsResponse{}
	_body, _err := client.DescribeInstanceIdsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the DescribeInstanceSpecs operation to query the specifications of multiple Anti-DDoS Pro or Anti-DDoS Premium instances at a time. The specifications include the clean bandwidth, protection bandwidth, function plan, and the numbers of domain names and ports that can be protected.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeInstanceSpecsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInstanceSpecsResponse
 */
func (client *Client) DescribeInstanceSpecsWithOptions(request *DescribeInstanceSpecsRequest, runtime *util.RuntimeOptions) (_result *DescribeInstanceSpecsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeInstanceSpecs"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeInstanceSpecsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the DescribeInstanceSpecs operation to query the specifications of multiple Anti-DDoS Pro or Anti-DDoS Premium instances at a time. The specifications include the clean bandwidth, protection bandwidth, function plan, and the numbers of domain names and ports that can be protected.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeInstanceSpecsRequest
 * @return DescribeInstanceSpecsResponse
 */
func (client *Client) DescribeInstanceSpecs(request *DescribeInstanceSpecsRequest) (_result *DescribeInstanceSpecsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeInstanceSpecsResponse{}
	_body, _err := client.DescribeInstanceSpecsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeInstanceStatisticsWithOptions(request *DescribeInstanceStatisticsRequest, runtime *util.RuntimeOptions) (_result *DescribeInstanceStatisticsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeInstanceStatistics"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeInstanceStatisticsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeInstanceStatistics(request *DescribeInstanceStatisticsRequest) (_result *DescribeInstanceStatisticsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeInstanceStatisticsResponse{}
	_body, _err := client.DescribeInstanceStatisticsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeInstanceStatusWithOptions(request *DescribeInstanceStatusRequest, runtime *util.RuntimeOptions) (_result *DescribeInstanceStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductType)) {
		query["ProductType"] = request.ProductType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeInstanceStatus"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeInstanceStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeInstanceStatus(request *DescribeInstanceStatusRequest) (_result *DescribeInstanceStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeInstanceStatusResponse{}
	_body, _err := client.DescribeInstanceStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the DescribeInstances operation to query the details of Anti-DDoS Pro or Anti-DDoS Premium instances within the Alibaba Cloud account by page. The details include the ID, mitigation plan, expiration time, and forwarding status.
 *
 * @param request DescribeInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeInstancesResponse
 */
func (client *Client) DescribeInstancesWithOptions(request *DescribeInstancesRequest, runtime *util.RuntimeOptions) (_result *DescribeInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Edition)) {
		query["Edition"] = request.Edition
	}

	if !tea.BoolValue(util.IsUnset(request.Enabled)) {
		query["Enabled"] = request.Enabled
	}

	if !tea.BoolValue(util.IsUnset(request.ExpireEndTime)) {
		query["ExpireEndTime"] = request.ExpireEndTime
	}

	if !tea.BoolValue(util.IsUnset(request.ExpireStartTime)) {
		query["ExpireStartTime"] = request.ExpireStartTime
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.Ip)) {
		query["Ip"] = request.Ip
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Remark)) {
		query["Remark"] = request.Remark
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeInstances"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the DescribeInstances operation to query the details of Anti-DDoS Pro or Anti-DDoS Premium instances within the Alibaba Cloud account by page. The details include the ID, mitigation plan, expiration time, and forwarding status.
 *
 * @param request DescribeInstancesRequest
 * @return DescribeInstancesResponse
 */
func (client *Client) DescribeInstances(request *DescribeInstancesRequest) (_result *DescribeInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeInstancesResponse{}
	_body, _err := client.DescribeInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeL7RsPolicyWithOptions(request *DescribeL7RsPolicyRequest, runtime *util.RuntimeOptions) (_result *DescribeL7RsPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.RealServers)) {
		query["RealServers"] = request.RealServers
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeL7RsPolicy"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeL7RsPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeL7RsPolicy(request *DescribeL7RsPolicyRequest) (_result *DescribeL7RsPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeL7RsPolicyResponse{}
	_body, _err := client.DescribeL7RsPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeLayer4RulePolicyWithOptions(request *DescribeLayer4RulePolicyRequest, runtime *util.RuntimeOptions) (_result *DescribeLayer4RulePolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Listeners)) {
		query["Listeners"] = request.Listeners
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeLayer4RulePolicy"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeLayer4RulePolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeLayer4RulePolicy(request *DescribeLayer4RulePolicyRequest) (_result *DescribeLayer4RulePolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeLayer4RulePolicyResponse{}
	_body, _err := client.DescribeLayer4RulePolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeLogStoreExistStatusWithOptions(request *DescribeLogStoreExistStatusRequest, runtime *util.RuntimeOptions) (_result *DescribeLogStoreExistStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeLogStoreExistStatus"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeLogStoreExistStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeLogStoreExistStatus(request *DescribeLogStoreExistStatusRequest) (_result *DescribeLogStoreExistStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeLogStoreExistStatusResponse{}
	_body, _err := client.DescribeLogStoreExistStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeNetworkRegionBlockWithOptions(request *DescribeNetworkRegionBlockRequest, runtime *util.RuntimeOptions) (_result *DescribeNetworkRegionBlockResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeNetworkRegionBlock"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeNetworkRegionBlockResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeNetworkRegionBlock(request *DescribeNetworkRegionBlockRequest) (_result *DescribeNetworkRegionBlockResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeNetworkRegionBlockResponse{}
	_body, _err := client.DescribeNetworkRegionBlockWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeNetworkRuleAttributesWithOptions(request *DescribeNetworkRuleAttributesRequest, runtime *util.RuntimeOptions) (_result *DescribeNetworkRuleAttributesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NetworkRules)) {
		query["NetworkRules"] = request.NetworkRules
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeNetworkRuleAttributes"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeNetworkRuleAttributesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeNetworkRuleAttributes(request *DescribeNetworkRuleAttributesRequest) (_result *DescribeNetworkRuleAttributesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeNetworkRuleAttributesResponse{}
	_body, _err := client.DescribeNetworkRuleAttributesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeNetworkRulesWithOptions(request *DescribeNetworkRulesRequest, runtime *util.RuntimeOptions) (_result *DescribeNetworkRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ForwardProtocol)) {
		query["ForwardProtocol"] = request.ForwardProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.FrontendPort)) {
		query["FrontendPort"] = request.FrontendPort
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeNetworkRules"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeNetworkRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeNetworkRules(request *DescribeNetworkRulesRequest) (_result *DescribeNetworkRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeNetworkRulesResponse{}
	_body, _err := client.DescribeNetworkRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > This operation is suitable only for Anti-DDoS Pro.
 * You can query operations performed on Anti-DDoS Pro, such as configuring burstable protection bandwidth, deactivating blackhole filtering, configuring the Diversion from Origin Server policy, using Anti-DDoS plans, changing the IP addresses of Elastic Compute Service (ECS) instances, and clearing all logs.
 *
 * @param request DescribeOpEntitiesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeOpEntitiesResponse
 */
func (client *Client) DescribeOpEntitiesWithOptions(request *DescribeOpEntitiesRequest, runtime *util.RuntimeOptions) (_result *DescribeOpEntitiesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.EntityObject)) {
		query["EntityObject"] = request.EntityObject
	}

	if !tea.BoolValue(util.IsUnset(request.EntityType)) {
		query["EntityType"] = request.EntityType
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeOpEntities"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeOpEntitiesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > This operation is suitable only for Anti-DDoS Pro.
 * You can query operations performed on Anti-DDoS Pro, such as configuring burstable protection bandwidth, deactivating blackhole filtering, configuring the Diversion from Origin Server policy, using Anti-DDoS plans, changing the IP addresses of Elastic Compute Service (ECS) instances, and clearing all logs.
 *
 * @param request DescribeOpEntitiesRequest
 * @return DescribeOpEntitiesResponse
 */
func (client *Client) DescribeOpEntities(request *DescribeOpEntitiesRequest) (_result *DescribeOpEntitiesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeOpEntitiesResponse{}
	_body, _err := client.DescribeOpEntitiesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation by using Terraform. For more information about Terraform, see [What is Terraform?](~~95820~~).
 *
 * @param request DescribePortRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePortResponse
 */
func (client *Client) DescribePortWithOptions(request *DescribePortRequest, runtime *util.RuntimeOptions) (_result *DescribePortResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FrontendPort)) {
		query["FrontendPort"] = request.FrontendPort
	}

	if !tea.BoolValue(util.IsUnset(request.FrontendProtocol)) {
		query["FrontendProtocol"] = request.FrontendProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePort"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePortResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation by using Terraform. For more information about Terraform, see [What is Terraform?](~~95820~~).
 *
 * @param request DescribePortRequest
 * @return DescribePortResponse
 */
func (client *Client) DescribePort(request *DescribePortRequest) (_result *DescribePortResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePortResponse{}
	_body, _err := client.DescribePortWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to query the peak bandwidth and peak packet rate of attack traffic on one or more Anti-DDoS Pro or Anti-DDoS Premium instances within a specific period of time.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribePortAttackMaxFlowRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePortAttackMaxFlowResponse
 */
func (client *Client) DescribePortAttackMaxFlowWithOptions(request *DescribePortAttackMaxFlowRequest, runtime *util.RuntimeOptions) (_result *DescribePortAttackMaxFlowResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePortAttackMaxFlow"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePortAttackMaxFlowResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to query the peak bandwidth and peak packet rate of attack traffic on one or more Anti-DDoS Pro or Anti-DDoS Premium instances within a specific period of time.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribePortAttackMaxFlowRequest
 * @return DescribePortAttackMaxFlowResponse
 */
func (client *Client) DescribePortAttackMaxFlow(request *DescribePortAttackMaxFlowRequest) (_result *DescribePortAttackMaxFlowResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePortAttackMaxFlowResponse{}
	_body, _err := client.DescribePortAttackMaxFlowWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribePortAutoCcStatusWithOptions(request *DescribePortAutoCcStatusRequest, runtime *util.RuntimeOptions) (_result *DescribePortAutoCcStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePortAutoCcStatus"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePortAutoCcStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribePortAutoCcStatus(request *DescribePortAutoCcStatusRequest) (_result *DescribePortAutoCcStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePortAutoCcStatusResponse{}
	_body, _err := client.DescribePortAutoCcStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribePortCcAttackTopIPWithOptions(request *DescribePortCcAttackTopIPRequest, runtime *util.RuntimeOptions) (_result *DescribePortCcAttackTopIPResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Ip)) {
		query["Ip"] = request.Ip
	}

	if !tea.BoolValue(util.IsUnset(request.Limit)) {
		query["Limit"] = request.Limit
	}

	if !tea.BoolValue(util.IsUnset(request.Port)) {
		query["Port"] = request.Port
	}

	if !tea.BoolValue(util.IsUnset(request.StartTimestamp)) {
		query["StartTimestamp"] = request.StartTimestamp
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePortCcAttackTopIP"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePortCcAttackTopIPResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribePortCcAttackTopIP(request *DescribePortCcAttackTopIPRequest) (_result *DescribePortCcAttackTopIPResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePortCcAttackTopIPResponse{}
	_body, _err := client.DescribePortCcAttackTopIPWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribePortConnsCountWithOptions(request *DescribePortConnsCountRequest, runtime *util.RuntimeOptions) (_result *DescribePortConnsCountResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.Port)) {
		query["Port"] = request.Port
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePortConnsCount"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePortConnsCountResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribePortConnsCount(request *DescribePortConnsCountRequest) (_result *DescribePortConnsCountResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePortConnsCountResponse{}
	_body, _err := client.DescribePortConnsCountWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribePortConnsListWithOptions(request *DescribePortConnsListRequest, runtime *util.RuntimeOptions) (_result *DescribePortConnsListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.Port)) {
		query["Port"] = request.Port
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePortConnsList"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePortConnsListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribePortConnsList(request *DescribePortConnsListRequest) (_result *DescribePortConnsListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePortConnsListResponse{}
	_body, _err := client.DescribePortConnsListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribePortFlowListWithOptions(request *DescribePortFlowListRequest, runtime *util.RuntimeOptions) (_result *DescribePortFlowListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePortFlowList"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePortFlowListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribePortFlowList(request *DescribePortFlowListRequest) (_result *DescribePortFlowListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePortFlowListResponse{}
	_body, _err := client.DescribePortFlowListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribePortMaxConnsWithOptions(request *DescribePortMaxConnsRequest, runtime *util.RuntimeOptions) (_result *DescribePortMaxConnsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePortMaxConns"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePortMaxConnsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribePortMaxConns(request *DescribePortMaxConnsRequest) (_result *DescribePortMaxConnsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePortMaxConnsResponse{}
	_body, _err := client.DescribePortMaxConnsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribePortViewSourceCountriesWithOptions(request *DescribePortViewSourceCountriesRequest, runtime *util.RuntimeOptions) (_result *DescribePortViewSourceCountriesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePortViewSourceCountries"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePortViewSourceCountriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribePortViewSourceCountries(request *DescribePortViewSourceCountriesRequest) (_result *DescribePortViewSourceCountriesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePortViewSourceCountriesResponse{}
	_body, _err := client.DescribePortViewSourceCountriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the DescribePortViewSourceIsps operation to query the ISPs from which requests are sent to one or more Anti-DDoS Pro or Anti-DDoS Premium instances within a specific period of time.
 * > The data returned for this operation cannot reflect the actual traffic volume because Layer 4 identity authentication algorithms are updated for Anti-DDoS Pro and Anti-DDoS Premium. You can call this operation to calculate only the proportion of requests sent from different ISPs. If you want to query the request traffic volume, we recommend that you call the [DescribePortFlowList](~~157460~~) operation.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribePortViewSourceIspsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePortViewSourceIspsResponse
 */
func (client *Client) DescribePortViewSourceIspsWithOptions(request *DescribePortViewSourceIspsRequest, runtime *util.RuntimeOptions) (_result *DescribePortViewSourceIspsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePortViewSourceIsps"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePortViewSourceIspsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the DescribePortViewSourceIsps operation to query the ISPs from which requests are sent to one or more Anti-DDoS Pro or Anti-DDoS Premium instances within a specific period of time.
 * > The data returned for this operation cannot reflect the actual traffic volume because Layer 4 identity authentication algorithms are updated for Anti-DDoS Pro and Anti-DDoS Premium. You can call this operation to calculate only the proportion of requests sent from different ISPs. If you want to query the request traffic volume, we recommend that you call the [DescribePortFlowList](~~157460~~) operation.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribePortViewSourceIspsRequest
 * @return DescribePortViewSourceIspsResponse
 */
func (client *Client) DescribePortViewSourceIsps(request *DescribePortViewSourceIspsRequest) (_result *DescribePortViewSourceIspsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePortViewSourceIspsResponse{}
	_body, _err := client.DescribePortViewSourceIspsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribePortViewSourceProvincesWithOptions(request *DescribePortViewSourceProvincesRequest, runtime *util.RuntimeOptions) (_result *DescribePortViewSourceProvincesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePortViewSourceProvinces"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePortViewSourceProvincesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribePortViewSourceProvinces(request *DescribePortViewSourceProvincesRequest) (_result *DescribePortViewSourceProvincesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePortViewSourceProvincesResponse{}
	_body, _err := client.DescribePortViewSourceProvincesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the DescribeSceneDefenseObjects operation to query the protected objects of a scenario-specific custom policy.
 * Before you call this operation, make sure that you have created a scenario-specific custom policy by calling the [CreateSceneDefensePolicy](~~159779~~) operation.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeSceneDefenseObjectsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSceneDefenseObjectsResponse
 */
func (client *Client) DescribeSceneDefenseObjectsWithOptions(request *DescribeSceneDefenseObjectsRequest, runtime *util.RuntimeOptions) (_result *DescribeSceneDefenseObjectsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PolicyId)) {
		query["PolicyId"] = request.PolicyId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeSceneDefenseObjects"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeSceneDefenseObjectsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the DescribeSceneDefenseObjects operation to query the protected objects of a scenario-specific custom policy.
 * Before you call this operation, make sure that you have created a scenario-specific custom policy by calling the [CreateSceneDefensePolicy](~~159779~~) operation.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeSceneDefenseObjectsRequest
 * @return DescribeSceneDefenseObjectsResponse
 */
func (client *Client) DescribeSceneDefenseObjects(request *DescribeSceneDefenseObjectsRequest) (_result *DescribeSceneDefenseObjectsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeSceneDefenseObjectsResponse{}
	_body, _err := client.DescribeSceneDefenseObjectsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the DescribeSceneDefensePolicies operation to query the configurations of a scenario-specific custom policy that is created. For example, you can query the status, protected objects, and protection rules of the policy.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeSceneDefensePoliciesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSceneDefensePoliciesResponse
 */
func (client *Client) DescribeSceneDefensePoliciesWithOptions(request *DescribeSceneDefensePoliciesRequest, runtime *util.RuntimeOptions) (_result *DescribeSceneDefensePoliciesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.Template)) {
		query["Template"] = request.Template
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeSceneDefensePolicies"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeSceneDefensePoliciesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the DescribeSceneDefensePolicies operation to query the configurations of a scenario-specific custom policy that is created. For example, you can query the status, protected objects, and protection rules of the policy.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeSceneDefensePoliciesRequest
 * @return DescribeSceneDefensePoliciesResponse
 */
func (client *Client) DescribeSceneDefensePolicies(request *DescribeSceneDefensePoliciesRequest) (_result *DescribeSceneDefensePoliciesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeSceneDefensePoliciesResponse{}
	_body, _err := client.DescribeSceneDefensePoliciesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeSchedulerRulesWithOptions(request *DescribeSchedulerRulesRequest, runtime *util.RuntimeOptions) (_result *DescribeSchedulerRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleName)) {
		query["RuleName"] = request.RuleName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeSchedulerRules"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeSchedulerRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeSchedulerRules(request *DescribeSchedulerRulesRequest) (_result *DescribeSchedulerRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeSchedulerRulesResponse{}
	_body, _err := client.DescribeSchedulerRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeSlaEventListWithOptions(request *DescribeSlaEventListRequest, runtime *util.RuntimeOptions) (_result *DescribeSlaEventListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Ip)) {
		query["Ip"] = request.Ip
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["Page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeSlaEventList"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeSlaEventListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeSlaEventList(request *DescribeSlaEventListRequest) (_result *DescribeSlaEventListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeSlaEventListResponse{}
	_body, _err := client.DescribeSlaEventListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeSlsAuthStatusWithOptions(request *DescribeSlsAuthStatusRequest, runtime *util.RuntimeOptions) (_result *DescribeSlsAuthStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeSlsAuthStatus"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeSlsAuthStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeSlsAuthStatus(request *DescribeSlsAuthStatusRequest) (_result *DescribeSlsAuthStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeSlsAuthStatusResponse{}
	_body, _err := client.DescribeSlsAuthStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeSlsLogstoreInfoWithOptions(request *DescribeSlsLogstoreInfoRequest, runtime *util.RuntimeOptions) (_result *DescribeSlsLogstoreInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeSlsLogstoreInfo"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeSlsLogstoreInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeSlsLogstoreInfo(request *DescribeSlsLogstoreInfoRequest) (_result *DescribeSlsLogstoreInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeSlsLogstoreInfoResponse{}
	_body, _err := client.DescribeSlsLogstoreInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeSlsOpenStatusWithOptions(request *DescribeSlsOpenStatusRequest, runtime *util.RuntimeOptions) (_result *DescribeSlsOpenStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeSlsOpenStatus"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeSlsOpenStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeSlsOpenStatus(request *DescribeSlsOpenStatusRequest) (_result *DescribeSlsOpenStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeSlsOpenStatusResponse{}
	_body, _err := client.DescribeSlsOpenStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the DescribeStsGrantStatus operation to query whether Anti-DDoS Pro or Anti-DDoS Premium of the current Alibaba Cloud account is authorized to access other cloud services.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeStsGrantStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeStsGrantStatusResponse
 */
func (client *Client) DescribeStsGrantStatusWithOptions(request *DescribeStsGrantStatusRequest, runtime *util.RuntimeOptions) (_result *DescribeStsGrantStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Role)) {
		query["Role"] = request.Role
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeStsGrantStatus"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeStsGrantStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the DescribeStsGrantStatus operation to query whether Anti-DDoS Pro or Anti-DDoS Premium of the current Alibaba Cloud account is authorized to access other cloud services.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeStsGrantStatusRequest
 * @return DescribeStsGrantStatusResponse
 */
func (client *Client) DescribeStsGrantStatus(request *DescribeStsGrantStatusRequest) (_result *DescribeStsGrantStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeStsGrantStatusResponse{}
	_body, _err := client.DescribeStsGrantStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the DescribeSystemLog operation to query the system logs of Anti-DDoS Pro or Anti-DDoS Premium. The system logs contain only billing logs for the burstable clean bandwidth.
 * If you have enabled the burstable clean bandwidth feature, you can call this operation to query the details of the bills of the burstable clean bandwidth.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeSystemLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSystemLogResponse
 */
func (client *Client) DescribeSystemLogWithOptions(request *DescribeSystemLogRequest, runtime *util.RuntimeOptions) (_result *DescribeSystemLogResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.EntityObject)) {
		query["EntityObject"] = request.EntityObject
	}

	if !tea.BoolValue(util.IsUnset(request.EntityType)) {
		query["EntityType"] = request.EntityType
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeSystemLog"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeSystemLogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the DescribeSystemLog operation to query the system logs of Anti-DDoS Pro or Anti-DDoS Premium. The system logs contain only billing logs for the burstable clean bandwidth.
 * If you have enabled the burstable clean bandwidth feature, you can call this operation to query the details of the bills of the burstable clean bandwidth.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeSystemLogRequest
 * @return DescribeSystemLogResponse
 */
func (client *Client) DescribeSystemLog(request *DescribeSystemLogRequest) (_result *DescribeSystemLogResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeSystemLogResponse{}
	_body, _err := client.DescribeSystemLogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to query all tag keys and the Anti-DDoS Pro instances to which the tag keys are added by page.
 * > The tag feature is suitable only for Anti-DDoS Pro.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeTagKeysRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTagKeysResponse
 */
func (client *Client) DescribeTagKeysWithOptions(request *DescribeTagKeysRequest, runtime *util.RuntimeOptions) (_result *DescribeTagKeysResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeTagKeys"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeTagKeysResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to query all tag keys and the Anti-DDoS Pro instances to which the tag keys are added by page.
 * > The tag feature is suitable only for Anti-DDoS Pro.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeTagKeysRequest
 * @return DescribeTagKeysResponse
 */
func (client *Client) DescribeTagKeys(request *DescribeTagKeysRequest) (_result *DescribeTagKeysResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeTagKeysResponse{}
	_body, _err := client.DescribeTagKeysWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the DescribeTagResources operation to query the information about the tags that are added to an Anti-DDoS Pro instance.
 * > Only Anti-DDoS Pro supports tags.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeTagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTagResourcesResponse
 */
func (client *Client) DescribeTagResourcesWithOptions(request *DescribeTagResourcesRequest, runtime *util.RuntimeOptions) (_result *DescribeTagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceIds)) {
		query["ResourceIds"] = request.ResourceIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeTagResources"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeTagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the DescribeTagResources operation to query the information about the tags that are added to an Anti-DDoS Pro instance.
 * > Only Anti-DDoS Pro supports tags.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeTagResourcesRequest
 * @return DescribeTagResourcesResponse
 */
func (client *Client) DescribeTagResources(request *DescribeTagResourcesRequest) (_result *DescribeTagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeTagResourcesResponse{}
	_body, _err := client.DescribeTagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeTotalAttackMaxFlowWithOptions(request *DescribeTotalAttackMaxFlowRequest, runtime *util.RuntimeOptions) (_result *DescribeTotalAttackMaxFlowResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeTotalAttackMaxFlow"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeTotalAttackMaxFlowResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeTotalAttackMaxFlow(request *DescribeTotalAttackMaxFlowRequest) (_result *DescribeTotalAttackMaxFlowResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeTotalAttackMaxFlowResponse{}
	_body, _err := client.DescribeTotalAttackMaxFlowWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeUdpReflectWithOptions(request *DescribeUdpReflectRequest, runtime *util.RuntimeOptions) (_result *DescribeUdpReflectResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeUdpReflect"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeUdpReflectResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeUdpReflect(request *DescribeUdpReflectRequest) (_result *DescribeUdpReflectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeUdpReflectResponse{}
	_body, _err := client.DescribeUdpReflectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeUnBlackholeCountWithOptions(request *DescribeUnBlackholeCountRequest, runtime *util.RuntimeOptions) (_result *DescribeUnBlackholeCountResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeUnBlackholeCount"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeUnBlackholeCountResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeUnBlackholeCount(request *DescribeUnBlackholeCountRequest) (_result *DescribeUnBlackholeCountResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeUnBlackholeCountResponse{}
	_body, _err := client.DescribeUnBlackholeCountWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > This operation is suitable only for Anti-DDoS Pro.
 *
 * @param request DescribeUnBlockCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeUnBlockCountResponse
 */
func (client *Client) DescribeUnBlockCountWithOptions(request *DescribeUnBlockCountRequest, runtime *util.RuntimeOptions) (_result *DescribeUnBlockCountResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeUnBlockCount"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeUnBlockCountResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > This operation is suitable only for Anti-DDoS Pro.
 *
 * @param request DescribeUnBlockCountRequest
 * @return DescribeUnBlockCountResponse
 */
func (client *Client) DescribeUnBlockCount(request *DescribeUnBlockCountRequest) (_result *DescribeUnBlockCountResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeUnBlockCountResponse{}
	_body, _err := client.DescribeUnBlockCountWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the DescribeWebAccessLogDispatchStatus operation to check whether the log analysis feature is enabled for all domain names that are added to your Anti-DDoS Pro or Anti-DDoS Premium instance.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeWebAccessLogDispatchStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebAccessLogDispatchStatusResponse
 */
func (client *Client) DescribeWebAccessLogDispatchStatusWithOptions(request *DescribeWebAccessLogDispatchStatusRequest, runtime *util.RuntimeOptions) (_result *DescribeWebAccessLogDispatchStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeWebAccessLogDispatchStatus"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeWebAccessLogDispatchStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the DescribeWebAccessLogDispatchStatus operation to check whether the log analysis feature is enabled for all domain names that are added to your Anti-DDoS Pro or Anti-DDoS Premium instance.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeWebAccessLogDispatchStatusRequest
 * @return DescribeWebAccessLogDispatchStatusResponse
 */
func (client *Client) DescribeWebAccessLogDispatchStatus(request *DescribeWebAccessLogDispatchStatusRequest) (_result *DescribeWebAccessLogDispatchStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeWebAccessLogDispatchStatusResponse{}
	_body, _err := client.DescribeWebAccessLogDispatchStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeWebAccessLogEmptyCountWithOptions(request *DescribeWebAccessLogEmptyCountRequest, runtime *util.RuntimeOptions) (_result *DescribeWebAccessLogEmptyCountResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeWebAccessLogEmptyCount"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeWebAccessLogEmptyCountResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeWebAccessLogEmptyCount(request *DescribeWebAccessLogEmptyCountRequest) (_result *DescribeWebAccessLogEmptyCountResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeWebAccessLogEmptyCountResponse{}
	_body, _err := client.DescribeWebAccessLogEmptyCountWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeWebAccessLogStatusWithOptions(request *DescribeWebAccessLogStatusRequest, runtime *util.RuntimeOptions) (_result *DescribeWebAccessLogStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeWebAccessLogStatus"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeWebAccessLogStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeWebAccessLogStatus(request *DescribeWebAccessLogStatusRequest) (_result *DescribeWebAccessLogStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeWebAccessLogStatusResponse{}
	_body, _err := client.DescribeWebAccessLogStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeWebAccessModeWithOptions(request *DescribeWebAccessModeRequest, runtime *util.RuntimeOptions) (_result *DescribeWebAccessModeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domains)) {
		query["Domains"] = request.Domains
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeWebAccessMode"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeWebAccessModeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeWebAccessMode(request *DescribeWebAccessModeRequest) (_result *DescribeWebAccessModeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeWebAccessModeResponse{}
	_body, _err := client.DescribeWebAccessModeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeWebAreaBlockConfigsWithOptions(request *DescribeWebAreaBlockConfigsRequest, runtime *util.RuntimeOptions) (_result *DescribeWebAreaBlockConfigsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domains)) {
		query["Domains"] = request.Domains
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeWebAreaBlockConfigs"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeWebAreaBlockConfigsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeWebAreaBlockConfigs(request *DescribeWebAreaBlockConfigsRequest) (_result *DescribeWebAreaBlockConfigsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeWebAreaBlockConfigsResponse{}
	_body, _err := client.DescribeWebAreaBlockConfigsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeWebCCRulesWithOptions(request *DescribeWebCCRulesRequest, runtime *util.RuntimeOptions) (_result *DescribeWebCCRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeWebCCRules"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeWebCCRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeWebCCRules(request *DescribeWebCCRulesRequest) (_result *DescribeWebCCRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeWebCCRulesResponse{}
	_body, _err := client.DescribeWebCCRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the DescribeWebCacheConfigs operation to query the Static Page Caching configurations of websites. The configurations include cache modes and custom caching rules.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeWebCacheConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeWebCacheConfigsResponse
 */
func (client *Client) DescribeWebCacheConfigsWithOptions(request *DescribeWebCacheConfigsRequest, runtime *util.RuntimeOptions) (_result *DescribeWebCacheConfigsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domains)) {
		query["Domains"] = request.Domains
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeWebCacheConfigs"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeWebCacheConfigsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the DescribeWebCacheConfigs operation to query the Static Page Caching configurations of websites. The configurations include cache modes and custom caching rules.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request DescribeWebCacheConfigsRequest
 * @return DescribeWebCacheConfigsResponse
 */
func (client *Client) DescribeWebCacheConfigs(request *DescribeWebCacheConfigsRequest) (_result *DescribeWebCacheConfigsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeWebCacheConfigsResponse{}
	_body, _err := client.DescribeWebCacheConfigsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeWebCcProtectSwitchWithOptions(request *DescribeWebCcProtectSwitchRequest, runtime *util.RuntimeOptions) (_result *DescribeWebCcProtectSwitchResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domains)) {
		query["Domains"] = request.Domains
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeWebCcProtectSwitch"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeWebCcProtectSwitchResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeWebCcProtectSwitch(request *DescribeWebCcProtectSwitchRequest) (_result *DescribeWebCcProtectSwitchResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeWebCcProtectSwitchResponse{}
	_body, _err := client.DescribeWebCcProtectSwitchWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeWebCustomPortsWithOptions(request *DescribeWebCustomPortsRequest, runtime *util.RuntimeOptions) (_result *DescribeWebCustomPortsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeWebCustomPorts"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeWebCustomPortsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeWebCustomPorts(request *DescribeWebCustomPortsRequest) (_result *DescribeWebCustomPortsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeWebCustomPortsResponse{}
	_body, _err := client.DescribeWebCustomPortsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeWebInstanceRelationsWithOptions(request *DescribeWebInstanceRelationsRequest, runtime *util.RuntimeOptions) (_result *DescribeWebInstanceRelationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domains)) {
		query["Domains"] = request.Domains
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeWebInstanceRelations"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeWebInstanceRelationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeWebInstanceRelations(request *DescribeWebInstanceRelationsRequest) (_result *DescribeWebInstanceRelationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeWebInstanceRelationsResponse{}
	_body, _err := client.DescribeWebInstanceRelationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeWebPreciseAccessRuleWithOptions(request *DescribeWebPreciseAccessRuleRequest, runtime *util.RuntimeOptions) (_result *DescribeWebPreciseAccessRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domains)) {
		query["Domains"] = request.Domains
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeWebPreciseAccessRule"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeWebPreciseAccessRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeWebPreciseAccessRule(request *DescribeWebPreciseAccessRuleRequest) (_result *DescribeWebPreciseAccessRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeWebPreciseAccessRuleResponse{}
	_body, _err := client.DescribeWebPreciseAccessRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeWebReportTopIpWithOptions(request *DescribeWebReportTopIpRequest, runtime *util.RuntimeOptions) (_result *DescribeWebReportTopIpResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.QueryType)) {
		query["QueryType"] = request.QueryType
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Top)) {
		query["Top"] = request.Top
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeWebReportTopIp"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeWebReportTopIpResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeWebReportTopIp(request *DescribeWebReportTopIpRequest) (_result *DescribeWebReportTopIpResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeWebReportTopIpResponse{}
	_body, _err := client.DescribeWebReportTopIpWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeWebRulesWithOptions(request *DescribeWebRulesRequest, runtime *util.RuntimeOptions) (_result *DescribeWebRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Cname)) {
		query["Cname"] = request.Cname
	}

	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.QueryDomainPattern)) {
		query["QueryDomainPattern"] = request.QueryDomainPattern
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeWebRules"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeWebRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeWebRules(request *DescribeWebRulesRequest) (_result *DescribeWebRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeWebRulesResponse{}
	_body, _err := client.DescribeWebRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DetachSceneDefenseObjectWithOptions(request *DetachSceneDefenseObjectRequest, runtime *util.RuntimeOptions) (_result *DetachSceneDefenseObjectResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ObjectType)) {
		query["ObjectType"] = request.ObjectType
	}

	if !tea.BoolValue(util.IsUnset(request.Objects)) {
		query["Objects"] = request.Objects
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyId)) {
		query["PolicyId"] = request.PolicyId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DetachSceneDefenseObject"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DetachSceneDefenseObjectResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DetachSceneDefenseObject(request *DetachSceneDefenseObjectRequest) (_result *DetachSceneDefenseObjectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DetachSceneDefenseObjectResponse{}
	_body, _err := client.DetachSceneDefenseObjectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DisableSceneDefensePolicyWithOptions(request *DisableSceneDefensePolicyRequest, runtime *util.RuntimeOptions) (_result *DisableSceneDefensePolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PolicyId)) {
		query["PolicyId"] = request.PolicyId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DisableSceneDefensePolicy"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DisableSceneDefensePolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DisableSceneDefensePolicy(request *DisableSceneDefensePolicyRequest) (_result *DisableSceneDefensePolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DisableSceneDefensePolicyResponse{}
	_body, _err := client.DisableSceneDefensePolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DisableWebAccessLogConfigWithOptions(request *DisableWebAccessLogConfigRequest, runtime *util.RuntimeOptions) (_result *DisableWebAccessLogConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DisableWebAccessLogConfig"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DisableWebAccessLogConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DisableWebAccessLogConfig(request *DisableWebAccessLogConfigRequest) (_result *DisableWebAccessLogConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DisableWebAccessLogConfigResponse{}
	_body, _err := client.DisableWebAccessLogConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DisableWebCCWithOptions(request *DisableWebCCRequest, runtime *util.RuntimeOptions) (_result *DisableWebCCResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DisableWebCC"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DisableWebCCResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DisableWebCC(request *DisableWebCCRequest) (_result *DisableWebCCResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DisableWebCCResponse{}
	_body, _err := client.DisableWebCCWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DisableWebCCRuleWithOptions(request *DisableWebCCRuleRequest, runtime *util.RuntimeOptions) (_result *DisableWebCCRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DisableWebCCRule"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DisableWebCCRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DisableWebCCRule(request *DisableWebCCRuleRequest) (_result *DisableWebCCRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DisableWebCCRuleResponse{}
	_body, _err := client.DisableWebCCRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) EmptyAutoCcBlacklistWithOptions(request *EmptyAutoCcBlacklistRequest, runtime *util.RuntimeOptions) (_result *EmptyAutoCcBlacklistResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EmptyAutoCcBlacklist"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EmptyAutoCcBlacklistResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) EmptyAutoCcBlacklist(request *EmptyAutoCcBlacklistRequest) (_result *EmptyAutoCcBlacklistResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EmptyAutoCcBlacklistResponse{}
	_body, _err := client.EmptyAutoCcBlacklistWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) EmptyAutoCcWhitelistWithOptions(request *EmptyAutoCcWhitelistRequest, runtime *util.RuntimeOptions) (_result *EmptyAutoCcWhitelistResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EmptyAutoCcWhitelist"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EmptyAutoCcWhitelistResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) EmptyAutoCcWhitelist(request *EmptyAutoCcWhitelistRequest) (_result *EmptyAutoCcWhitelistResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EmptyAutoCcWhitelistResponse{}
	_body, _err := client.EmptyAutoCcWhitelistWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) EmptySlsLogstoreWithOptions(request *EmptySlsLogstoreRequest, runtime *util.RuntimeOptions) (_result *EmptySlsLogstoreResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EmptySlsLogstore"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EmptySlsLogstoreResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) EmptySlsLogstore(request *EmptySlsLogstoreRequest) (_result *EmptySlsLogstoreResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EmptySlsLogstoreResponse{}
	_body, _err := client.EmptySlsLogstoreWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) EnableSceneDefensePolicyWithOptions(request *EnableSceneDefensePolicyRequest, runtime *util.RuntimeOptions) (_result *EnableSceneDefensePolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PolicyId)) {
		query["PolicyId"] = request.PolicyId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EnableSceneDefensePolicy"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EnableSceneDefensePolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) EnableSceneDefensePolicy(request *EnableSceneDefensePolicyRequest) (_result *EnableSceneDefensePolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EnableSceneDefensePolicyResponse{}
	_body, _err := client.EnableSceneDefensePolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) EnableWebAccessLogConfigWithOptions(request *EnableWebAccessLogConfigRequest, runtime *util.RuntimeOptions) (_result *EnableWebAccessLogConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EnableWebAccessLogConfig"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EnableWebAccessLogConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) EnableWebAccessLogConfig(request *EnableWebAccessLogConfigRequest) (_result *EnableWebAccessLogConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EnableWebAccessLogConfigResponse{}
	_body, _err := client.EnableWebAccessLogConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) EnableWebCCWithOptions(request *EnableWebCCRequest, runtime *util.RuntimeOptions) (_result *EnableWebCCResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EnableWebCC"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EnableWebCCResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) EnableWebCC(request *EnableWebCCRequest) (_result *EnableWebCCResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EnableWebCCResponse{}
	_body, _err := client.EnableWebCCWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) EnableWebCCRuleWithOptions(request *EnableWebCCRuleRequest, runtime *util.RuntimeOptions) (_result *EnableWebCCRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EnableWebCCRule"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EnableWebCCRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) EnableWebCCRule(request *EnableWebCCRuleRequest) (_result *EnableWebCCRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EnableWebCCRuleResponse{}
	_body, _err := client.EnableWebCCRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can switch between the metering methods of the burstable clean bandwidth feature. The new metering method takes effect from 00:00 on the first day of the next month. You can change the metering method up to three times each calendar month. The most recent metering method that you select takes effect in the next month. You cannot change the metering method on the last day of each calendar month.
 *
 * @param request ModifyBizBandWidthModeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyBizBandWidthModeResponse
 */
func (client *Client) ModifyBizBandWidthModeWithOptions(request *ModifyBizBandWidthModeRequest, runtime *util.RuntimeOptions) (_result *ModifyBizBandWidthModeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Mode)) {
		query["Mode"] = request.Mode
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyBizBandWidthMode"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyBizBandWidthModeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can switch between the metering methods of the burstable clean bandwidth feature. The new metering method takes effect from 00:00 on the first day of the next month. You can change the metering method up to three times each calendar month. The most recent metering method that you select takes effect in the next month. You cannot change the metering method on the last day of each calendar month.
 *
 * @param request ModifyBizBandWidthModeRequest
 * @return ModifyBizBandWidthModeResponse
 */
func (client *Client) ModifyBizBandWidthMode(request *ModifyBizBandWidthModeRequest) (_result *ModifyBizBandWidthModeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyBizBandWidthModeResponse{}
	_body, _err := client.ModifyBizBandWidthModeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyBlackholeStatusWithOptions(request *ModifyBlackholeStatusRequest, runtime *util.RuntimeOptions) (_result *ModifyBlackholeStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BlackholeStatus)) {
		query["BlackholeStatus"] = request.BlackholeStatus
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyBlackholeStatus"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyBlackholeStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyBlackholeStatus(request *ModifyBlackholeStatusRequest) (_result *ModifyBlackholeStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyBlackholeStatusResponse{}
	_body, _err := client.ModifyBlackholeStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > This operation is suitable only for Anti-DDoS Pro.
 *
 * @param request ModifyBlockStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyBlockStatusResponse
 */
func (client *Client) ModifyBlockStatusWithOptions(request *ModifyBlockStatusRequest, runtime *util.RuntimeOptions) (_result *ModifyBlockStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Duration)) {
		query["Duration"] = request.Duration
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Lines)) {
		query["Lines"] = request.Lines
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyBlockStatus"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyBlockStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > This operation is suitable only for Anti-DDoS Pro.
 *
 * @param request ModifyBlockStatusRequest
 * @return ModifyBlockStatusResponse
 */
func (client *Client) ModifyBlockStatus(request *ModifyBlockStatusRequest) (_result *ModifyBlockStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyBlockStatusResponse{}
	_body, _err := client.ModifyBlockStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > This operation is suitable only for Anti-DDoS Premium.
 *
 * @param request ModifyCnameReuseRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyCnameReuseResponse
 */
func (client *Client) ModifyCnameReuseWithOptions(request *ModifyCnameReuseRequest, runtime *util.RuntimeOptions) (_result *ModifyCnameReuseResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Cname)) {
		query["Cname"] = request.Cname
	}

	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.Enable)) {
		query["Enable"] = request.Enable
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyCnameReuse"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyCnameReuseResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > This operation is suitable only for Anti-DDoS Premium.
 *
 * @param request ModifyCnameReuseRequest
 * @return ModifyCnameReuseResponse
 */
func (client *Client) ModifyCnameReuse(request *ModifyCnameReuseRequest) (_result *ModifyCnameReuseResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyCnameReuseResponse{}
	_body, _err := client.ModifyCnameReuseWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyDomainResourceWithOptions(request *ModifyDomainResourceRequest, runtime *util.RuntimeOptions) (_result *ModifyDomainResourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.HttpsExt)) {
		query["HttpsExt"] = request.HttpsExt
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.ProxyTypes)) {
		query["ProxyTypes"] = request.ProxyTypes
	}

	if !tea.BoolValue(util.IsUnset(request.RealServers)) {
		query["RealServers"] = request.RealServers
	}

	if !tea.BoolValue(util.IsUnset(request.RsType)) {
		query["RsType"] = request.RsType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyDomainResource"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyDomainResourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyDomainResource(request *ModifyDomainResourceRequest) (_result *ModifyDomainResourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyDomainResourceResponse{}
	_body, _err := client.ModifyDomainResourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > This operation is suitable only for Anti-DDoS Pro.
 *
 * @param request ModifyElasticBandWidthRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyElasticBandWidthResponse
 */
func (client *Client) ModifyElasticBandWidthWithOptions(request *ModifyElasticBandWidthRequest, runtime *util.RuntimeOptions) (_result *ModifyElasticBandWidthResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ElasticBandwidth)) {
		query["ElasticBandwidth"] = request.ElasticBandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyElasticBandWidth"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyElasticBandWidthResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > This operation is suitable only for Anti-DDoS Pro.
 *
 * @param request ModifyElasticBandWidthRequest
 * @return ModifyElasticBandWidthResponse
 */
func (client *Client) ModifyElasticBandWidth(request *ModifyElasticBandWidthRequest) (_result *ModifyElasticBandWidthResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyElasticBandWidthResponse{}
	_body, _err := client.ModifyElasticBandWidthWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call this operation, make sure that you have fully understood the billing method and [pricing](https://help.aliyun.com/document_detail/283754.html) of the burstable clean bandwidth feature. After you call this operation for the first time, the modification immediately takes effect.
 *
 * @param request ModifyElasticBizBandWidthRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyElasticBizBandWidthResponse
 */
func (client *Client) ModifyElasticBizBandWidthWithOptions(request *ModifyElasticBizBandWidthRequest, runtime *util.RuntimeOptions) (_result *ModifyElasticBizBandWidthResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ElasticBizBandwidth)) {
		query["ElasticBizBandwidth"] = request.ElasticBizBandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Mode)) {
		query["Mode"] = request.Mode
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyElasticBizBandWidth"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyElasticBizBandWidthResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call this operation, make sure that you have fully understood the billing method and [pricing](https://help.aliyun.com/document_detail/283754.html) of the burstable clean bandwidth feature. After you call this operation for the first time, the modification immediately takes effect.
 *
 * @param request ModifyElasticBizBandWidthRequest
 * @return ModifyElasticBizBandWidthResponse
 */
func (client *Client) ModifyElasticBizBandWidth(request *ModifyElasticBizBandWidthRequest) (_result *ModifyElasticBizBandWidthResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyElasticBizBandWidthResponse{}
	_body, _err := client.ModifyElasticBizBandWidthWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyElasticBizQpsWithOptions(request *ModifyElasticBizQpsRequest, runtime *util.RuntimeOptions) (_result *ModifyElasticBizQpsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Mode)) {
		query["Mode"] = request.Mode
	}

	if !tea.BoolValue(util.IsUnset(request.OpsElasticQps)) {
		query["OpsElasticQps"] = request.OpsElasticQps
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyElasticBizQps"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyElasticBizQpsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyElasticBizQps(request *ModifyElasticBizQpsRequest) (_result *ModifyElasticBizQpsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyElasticBizQpsResponse{}
	_body, _err := client.ModifyElasticBizQpsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyFullLogTtlWithOptions(request *ModifyFullLogTtlRequest, runtime *util.RuntimeOptions) (_result *ModifyFullLogTtlResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Ttl)) {
		query["Ttl"] = request.Ttl
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyFullLogTtl"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyFullLogTtlResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyFullLogTtl(request *ModifyFullLogTtlRequest) (_result *ModifyFullLogTtlResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyFullLogTtlResponse{}
	_body, _err := client.ModifyFullLogTtlWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyHeadersWithOptions(request *ModifyHeadersRequest, runtime *util.RuntimeOptions) (_result *ModifyHeadersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CustomHeaders)) {
		query["CustomHeaders"] = request.CustomHeaders
	}

	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyHeaders"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyHeadersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyHeaders(request *ModifyHeadersRequest) (_result *ModifyHeadersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyHeadersResponse{}
	_body, _err := client.ModifyHeadersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyHealthCheckConfigWithOptions(request *ModifyHealthCheckConfigRequest, runtime *util.RuntimeOptions) (_result *ModifyHealthCheckConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ForwardProtocol)) {
		query["ForwardProtocol"] = request.ForwardProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.FrontendPort)) {
		query["FrontendPort"] = request.FrontendPort
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheck)) {
		query["HealthCheck"] = request.HealthCheck
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyHealthCheckConfig"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyHealthCheckConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyHealthCheckConfig(request *ModifyHealthCheckConfigRequest) (_result *ModifyHealthCheckConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyHealthCheckConfigResponse{}
	_body, _err := client.ModifyHealthCheckConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > This operation is suitable only for Anti-DDoS Pro.
 *
 * @param request ModifyHttp2EnableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyHttp2EnableResponse
 */
func (client *Client) ModifyHttp2EnableWithOptions(request *ModifyHttp2EnableRequest, runtime *util.RuntimeOptions) (_result *ModifyHttp2EnableResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.Enable)) {
		query["Enable"] = request.Enable
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyHttp2Enable"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyHttp2EnableResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > This operation is suitable only for Anti-DDoS Pro.
 *
 * @param request ModifyHttp2EnableRequest
 * @return ModifyHttp2EnableResponse
 */
func (client *Client) ModifyHttp2Enable(request *ModifyHttp2EnableRequest) (_result *ModifyHttp2EnableResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyHttp2EnableResponse{}
	_body, _err := client.ModifyHttp2EnableWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyInstanceRemarkWithOptions(request *ModifyInstanceRemarkRequest, runtime *util.RuntimeOptions) (_result *ModifyInstanceRemarkResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Remark)) {
		query["Remark"] = request.Remark
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyInstanceRemark"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyInstanceRemarkResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyInstanceRemark(request *ModifyInstanceRemarkRequest) (_result *ModifyInstanceRemarkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyInstanceRemarkResponse{}
	_body, _err := client.ModifyInstanceRemarkWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyNetworkRuleAttributeWithOptions(request *ModifyNetworkRuleAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyNetworkRuleAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Config)) {
		query["Config"] = request.Config
	}

	if !tea.BoolValue(util.IsUnset(request.ForwardProtocol)) {
		query["ForwardProtocol"] = request.ForwardProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.FrontendPort)) {
		query["FrontendPort"] = request.FrontendPort
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyNetworkRuleAttribute"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyNetworkRuleAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyNetworkRuleAttribute(request *ModifyNetworkRuleAttributeRequest) (_result *ModifyNetworkRuleAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyNetworkRuleAttributeResponse{}
	_body, _err := client.ModifyNetworkRuleAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This feature is available only for a website that supports HTTPS. If HTTPS is selected for Protocol, we recommend that you enable this feature.
 *
 * @param request ModifyOcspStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyOcspStatusResponse
 */
func (client *Client) ModifyOcspStatusWithOptions(request *ModifyOcspStatusRequest, runtime *util.RuntimeOptions) (_result *ModifyOcspStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.Enable)) {
		query["Enable"] = request.Enable
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyOcspStatus"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyOcspStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This feature is available only for a website that supports HTTPS. If HTTPS is selected for Protocol, we recommend that you enable this feature.
 *
 * @param request ModifyOcspStatusRequest
 * @return ModifyOcspStatusResponse
 */
func (client *Client) ModifyOcspStatus(request *ModifyOcspStatusRequest) (_result *ModifyOcspStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyOcspStatusResponse{}
	_body, _err := client.ModifyOcspStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the ModifyPort operation by using Terraform. For more information about Terraform, see [What is Terraform?](~~95820~~).
 *
 * @param request ModifyPortRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyPortResponse
 */
func (client *Client) ModifyPortWithOptions(request *ModifyPortRequest, runtime *util.RuntimeOptions) (_result *ModifyPortResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackendPort)) {
		query["BackendPort"] = request.BackendPort
	}

	if !tea.BoolValue(util.IsUnset(request.FrontendPort)) {
		query["FrontendPort"] = request.FrontendPort
	}

	if !tea.BoolValue(util.IsUnset(request.FrontendProtocol)) {
		query["FrontendProtocol"] = request.FrontendProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RealServers)) {
		query["RealServers"] = request.RealServers
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyPort"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyPortResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the ModifyPort operation by using Terraform. For more information about Terraform, see [What is Terraform?](~~95820~~).
 *
 * @param request ModifyPortRequest
 * @return ModifyPortResponse
 */
func (client *Client) ModifyPort(request *ModifyPortRequest) (_result *ModifyPortResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyPortResponse{}
	_body, _err := client.ModifyPortWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyPortAutoCcStatusWithOptions(request *ModifyPortAutoCcStatusRequest, runtime *util.RuntimeOptions) (_result *ModifyPortAutoCcStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Mode)) {
		query["Mode"] = request.Mode
	}

	if !tea.BoolValue(util.IsUnset(request.Switch)) {
		query["Switch"] = request.Switch
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyPortAutoCcStatus"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyPortAutoCcStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyPortAutoCcStatus(request *ModifyPortAutoCcStatusRequest) (_result *ModifyPortAutoCcStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyPortAutoCcStatusResponse{}
	_body, _err := client.ModifyPortAutoCcStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyQpsModeWithOptions(request *ModifyQpsModeRequest, runtime *util.RuntimeOptions) (_result *ModifyQpsModeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Mode)) {
		query["Mode"] = request.Mode
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyQpsMode"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyQpsModeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyQpsMode(request *ModifyQpsModeRequest) (_result *ModifyQpsModeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyQpsModeResponse{}
	_body, _err := client.ModifyQpsModeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifySceneDefensePolicyWithOptions(request *ModifySceneDefensePolicyRequest, runtime *util.RuntimeOptions) (_result *ModifySceneDefensePolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyId)) {
		query["PolicyId"] = request.PolicyId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Template)) {
		query["Template"] = request.Template
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifySceneDefensePolicy"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifySceneDefensePolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifySceneDefensePolicy(request *ModifySceneDefensePolicyRequest) (_result *ModifySceneDefensePolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifySceneDefensePolicyResponse{}
	_body, _err := client.ModifySceneDefensePolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifySchedulerRuleWithOptions(request *ModifySchedulerRuleRequest, runtime *util.RuntimeOptions) (_result *ModifySchedulerRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Param)) {
		query["Param"] = request.Param
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleName)) {
		query["RuleName"] = request.RuleName
	}

	if !tea.BoolValue(util.IsUnset(request.RuleType)) {
		query["RuleType"] = request.RuleType
	}

	if !tea.BoolValue(util.IsUnset(request.Rules)) {
		query["Rules"] = request.Rules
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifySchedulerRule"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifySchedulerRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifySchedulerRule(request *ModifySchedulerRuleRequest) (_result *ModifySchedulerRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifySchedulerRuleResponse{}
	_body, _err := client.ModifySchedulerRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyTlsConfigWithOptions(request *ModifyTlsConfigRequest, runtime *util.RuntimeOptions) (_result *ModifyTlsConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Config)) {
		query["Config"] = request.Config
	}

	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyTlsConfig"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyTlsConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyTlsConfig(request *ModifyTlsConfigRequest) (_result *ModifyTlsConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyTlsConfigResponse{}
	_body, _err := client.ModifyTlsConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyWebAIProtectModeWithOptions(request *ModifyWebAIProtectModeRequest, runtime *util.RuntimeOptions) (_result *ModifyWebAIProtectModeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Config)) {
		query["Config"] = request.Config
	}

	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyWebAIProtectMode"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyWebAIProtectModeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyWebAIProtectMode(request *ModifyWebAIProtectModeRequest) (_result *ModifyWebAIProtectModeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyWebAIProtectModeResponse{}
	_body, _err := client.ModifyWebAIProtectModeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyWebAIProtectSwitchWithOptions(request *ModifyWebAIProtectSwitchRequest, runtime *util.RuntimeOptions) (_result *ModifyWebAIProtectSwitchResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Config)) {
		query["Config"] = request.Config
	}

	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyWebAIProtectSwitch"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyWebAIProtectSwitchResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyWebAIProtectSwitch(request *ModifyWebAIProtectSwitchRequest) (_result *ModifyWebAIProtectSwitchResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyWebAIProtectSwitchResponse{}
	_body, _err := client.ModifyWebAIProtectSwitchWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyWebAccessModeWithOptions(request *ModifyWebAccessModeRequest, runtime *util.RuntimeOptions) (_result *ModifyWebAccessModeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccessMode)) {
		query["AccessMode"] = request.AccessMode
	}

	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyWebAccessMode"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyWebAccessModeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyWebAccessMode(request *ModifyWebAccessModeRequest) (_result *ModifyWebAccessModeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyWebAccessModeResponse{}
	_body, _err := client.ModifyWebAccessModeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyWebAreaBlockWithOptions(request *ModifyWebAreaBlockRequest, runtime *util.RuntimeOptions) (_result *ModifyWebAreaBlockResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.Regions)) {
		query["Regions"] = request.Regions
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyWebAreaBlock"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyWebAreaBlockResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyWebAreaBlock(request *ModifyWebAreaBlockRequest) (_result *ModifyWebAreaBlockResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyWebAreaBlockResponse{}
	_body, _err := client.ModifyWebAreaBlockWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the ModifyWebAreaBlockSwitch operation to enable or disable the Location Blacklist (Domain Names) policy for a domain name.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request ModifyWebAreaBlockSwitchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebAreaBlockSwitchResponse
 */
func (client *Client) ModifyWebAreaBlockSwitchWithOptions(request *ModifyWebAreaBlockSwitchRequest, runtime *util.RuntimeOptions) (_result *ModifyWebAreaBlockSwitchResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Config)) {
		query["Config"] = request.Config
	}

	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyWebAreaBlockSwitch"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyWebAreaBlockSwitchResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the ModifyWebAreaBlockSwitch operation to enable or disable the Location Blacklist (Domain Names) policy for a domain name.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request ModifyWebAreaBlockSwitchRequest
 * @return ModifyWebAreaBlockSwitchResponse
 */
func (client *Client) ModifyWebAreaBlockSwitch(request *ModifyWebAreaBlockSwitchRequest) (_result *ModifyWebAreaBlockSwitchResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyWebAreaBlockSwitchResponse{}
	_body, _err := client.ModifyWebAreaBlockSwitchWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyWebCCRuleWithOptions(request *ModifyWebCCRuleRequest, runtime *util.RuntimeOptions) (_result *ModifyWebCCRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Act)) {
		query["Act"] = request.Act
	}

	if !tea.BoolValue(util.IsUnset(request.Count)) {
		query["Count"] = request.Count
	}

	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.Mode)) {
		query["Mode"] = request.Mode
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Ttl)) {
		query["Ttl"] = request.Ttl
	}

	if !tea.BoolValue(util.IsUnset(request.Uri)) {
		query["Uri"] = request.Uri
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyWebCCRule"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyWebCCRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyWebCCRule(request *ModifyWebCCRuleRequest) (_result *ModifyWebCCRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyWebCCRuleResponse{}
	_body, _err := client.ModifyWebCCRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyWebCacheCustomRuleWithOptions(request *ModifyWebCacheCustomRuleRequest, runtime *util.RuntimeOptions) (_result *ModifyWebCacheCustomRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Rules)) {
		query["Rules"] = request.Rules
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyWebCacheCustomRule"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyWebCacheCustomRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyWebCacheCustomRule(request *ModifyWebCacheCustomRuleRequest) (_result *ModifyWebCacheCustomRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyWebCacheCustomRuleResponse{}
	_body, _err := client.ModifyWebCacheCustomRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyWebCacheModeWithOptions(request *ModifyWebCacheModeRequest, runtime *util.RuntimeOptions) (_result *ModifyWebCacheModeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.Mode)) {
		query["Mode"] = request.Mode
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyWebCacheMode"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyWebCacheModeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyWebCacheMode(request *ModifyWebCacheModeRequest) (_result *ModifyWebCacheModeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyWebCacheModeResponse{}
	_body, _err := client.ModifyWebCacheModeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the ModifyWebCacheSwitch operation to enable or disable the Static Page Caching policy for a website.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request ModifyWebCacheSwitchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyWebCacheSwitchResponse
 */
func (client *Client) ModifyWebCacheSwitchWithOptions(request *ModifyWebCacheSwitchRequest, runtime *util.RuntimeOptions) (_result *ModifyWebCacheSwitchResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.Enable)) {
		query["Enable"] = request.Enable
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyWebCacheSwitch"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyWebCacheSwitchResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the ModifyWebCacheSwitch operation to enable or disable the Static Page Caching policy for a website.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request ModifyWebCacheSwitchRequest
 * @return ModifyWebCacheSwitchResponse
 */
func (client *Client) ModifyWebCacheSwitch(request *ModifyWebCacheSwitchRequest) (_result *ModifyWebCacheSwitchResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyWebCacheSwitchResponse{}
	_body, _err := client.ModifyWebCacheSwitchWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyWebIpSetSwitchWithOptions(request *ModifyWebIpSetSwitchRequest, runtime *util.RuntimeOptions) (_result *ModifyWebIpSetSwitchResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Config)) {
		query["Config"] = request.Config
	}

	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyWebIpSetSwitch"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyWebIpSetSwitchResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyWebIpSetSwitch(request *ModifyWebIpSetSwitchRequest) (_result *ModifyWebIpSetSwitchResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyWebIpSetSwitchResponse{}
	_body, _err := client.ModifyWebIpSetSwitchWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyWebPreciseAccessRuleWithOptions(request *ModifyWebPreciseAccessRuleRequest, runtime *util.RuntimeOptions) (_result *ModifyWebPreciseAccessRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.Expires)) {
		query["Expires"] = request.Expires
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Rules)) {
		query["Rules"] = request.Rules
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyWebPreciseAccessRule"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyWebPreciseAccessRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyWebPreciseAccessRule(request *ModifyWebPreciseAccessRuleRequest) (_result *ModifyWebPreciseAccessRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyWebPreciseAccessRuleResponse{}
	_body, _err := client.ModifyWebPreciseAccessRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyWebPreciseAccessSwitchWithOptions(request *ModifyWebPreciseAccessSwitchRequest, runtime *util.RuntimeOptions) (_result *ModifyWebPreciseAccessSwitchResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Config)) {
		query["Config"] = request.Config
	}

	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyWebPreciseAccessSwitch"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyWebPreciseAccessSwitchResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyWebPreciseAccessSwitch(request *ModifyWebPreciseAccessSwitchRequest) (_result *ModifyWebPreciseAccessSwitchResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyWebPreciseAccessSwitchResponse{}
	_body, _err := client.ModifyWebPreciseAccessSwitchWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyWebRuleWithOptions(request *ModifyWebRuleRequest, runtime *util.RuntimeOptions) (_result *ModifyWebRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.HttpsExt)) {
		query["HttpsExt"] = request.HttpsExt
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.ProxyTypes)) {
		query["ProxyTypes"] = request.ProxyTypes
	}

	if !tea.BoolValue(util.IsUnset(request.RealServers)) {
		query["RealServers"] = request.RealServers
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RsType)) {
		query["RsType"] = request.RsType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyWebRule"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyWebRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyWebRule(request *ModifyWebRuleRequest) (_result *ModifyWebRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyWebRuleResponse{}
	_body, _err := client.ModifyWebRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the request, which is used to locate and troubleshoot issues.
 *
 * @param request ReleaseInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReleaseInstanceResponse
 */
func (client *Client) ReleaseInstanceWithOptions(request *ReleaseInstanceRequest, runtime *util.RuntimeOptions) (_result *ReleaseInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ReleaseInstance"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ReleaseInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the request, which is used to locate and troubleshoot issues.
 *
 * @param request ReleaseInstanceRequest
 * @return ReleaseInstanceResponse
 */
func (client *Client) ReleaseInstance(request *ReleaseInstanceRequest) (_result *ReleaseInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ReleaseInstanceResponse{}
	_body, _err := client.ReleaseInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the SwitchSchedulerRule operation to modify the resources to which service traffic is switched for a scheduling rule. For example, you can switch service traffic to an Anti-DDoS Pro or Anti-DDoS Premium instance for scrubbing or switch the service traffic back to the associated cloud resources.
 * Before you call this operation, you must have created a scheduling rule by calling the [CreateSchedulerRule](~~157479~~) operation.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request SwitchSchedulerRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SwitchSchedulerRuleResponse
 */
func (client *Client) SwitchSchedulerRuleWithOptions(request *SwitchSchedulerRuleRequest, runtime *util.RuntimeOptions) (_result *SwitchSchedulerRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RuleName)) {
		query["RuleName"] = request.RuleName
	}

	if !tea.BoolValue(util.IsUnset(request.RuleType)) {
		query["RuleType"] = request.RuleType
	}

	if !tea.BoolValue(util.IsUnset(request.SwitchData)) {
		query["SwitchData"] = request.SwitchData
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SwitchSchedulerRule"),
		Version:     tea.String("2020-01-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SwitchSchedulerRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the SwitchSchedulerRule operation to modify the resources to which service traffic is switched for a scheduling rule. For example, you can switch service traffic to an Anti-DDoS Pro or Anti-DDoS Premium instance for scrubbing or switch the service traffic back to the associated cloud resources.
 * Before you call this operation, you must have created a scheduling rule by calling the [CreateSchedulerRule](~~157479~~) operation.
 * ### Limits
 * You can call this operation up to 10 times per second per account. If the number of the calls per second exceeds the limit, throttling is triggered. As a result, your business may be affected. We recommend that you take note of the limit when you call this operation.
 *
 * @param request SwitchSchedulerRuleRequest
 * @return SwitchSchedulerRuleResponse
 */
func (client *Client) SwitchSchedulerRule(request *SwitchSchedulerRuleRequest) (_result *SwitchSchedulerRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SwitchSchedulerRuleResponse{}
	_body, _err := client.SwitchSchedulerRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}
