// This file is auto-generated, don't edit it. Thanks.
/**
 *
 */
package client

import (
	openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
	endpointutil "github.com/alibabacloud-go/endpoint-util/service"
	openapiutil "github.com/alibabacloud-go/openapi-util/service"
	util "github.com/alibabacloud-go/tea-utils/v2/service"
	"github.com/alibabacloud-go/tea/tea"
)

type AppConfig struct {
	Command            *string                      `json:"Command,omitempty" xml:"Command,omitempty"`
	CommandArgs        []*string                    `json:"CommandArgs,omitempty" xml:"CommandArgs,omitempty" type:"Repeated"`
	ConfigMountDescs   []*AppConfigConfigMountDescs `json:"ConfigMountDescs,omitempty" xml:"ConfigMountDescs,omitempty" type:"Repeated"`
	DeployAcrossNodes  *bool                        `json:"DeployAcrossNodes,omitempty" xml:"DeployAcrossNodes,omitempty"`
	DeployAcrossZones  *bool                        `json:"DeployAcrossZones,omitempty" xml:"DeployAcrossZones,omitempty"`
	EmptyDirs          []*AppConfigEmptyDirs        `json:"EmptyDirs,omitempty" xml:"EmptyDirs,omitempty" type:"Repeated"`
	EnableAhas         *bool                        `json:"EnableAhas,omitempty" xml:"EnableAhas,omitempty"`
	EnvFroms           []*AppConfigEnvFroms         `json:"EnvFroms,omitempty" xml:"EnvFroms,omitempty" type:"Repeated"`
	Envs               []*AppConfigEnvs             `json:"Envs,omitempty" xml:"Envs,omitempty" type:"Repeated"`
	ImageConfig        *AppConfigImageConfig        `json:"ImageConfig,omitempty" xml:"ImageConfig,omitempty" type:"Struct"`
	IsMultilingualApp  *bool                        `json:"IsMultilingualApp,omitempty" xml:"IsMultilingualApp,omitempty"`
	JavaStartUpConfig  *string                      `json:"JavaStartUpConfig,omitempty" xml:"JavaStartUpConfig,omitempty"`
	LimitCpu           *string                      `json:"LimitCpu,omitempty" xml:"LimitCpu,omitempty"`
	LimitMem           *string                      `json:"LimitMem,omitempty" xml:"LimitMem,omitempty"`
	Liveness           *string                      `json:"Liveness,omitempty" xml:"Liveness,omitempty"`
	LocalVolumes       []*AppConfigLocalVolumes     `json:"LocalVolumes,omitempty" xml:"LocalVolumes,omitempty" type:"Repeated"`
	NasId              *string                      `json:"NasId,omitempty" xml:"NasId,omitempty"`
	NasMountDescs      []*AppConfigNasMountDescs    `json:"NasMountDescs,omitempty" xml:"NasMountDescs,omitempty" type:"Repeated"`
	NasStorageType     *string                      `json:"NasStorageType,omitempty" xml:"NasStorageType,omitempty"`
	PackageConfig      *AppConfigPackageConfig      `json:"PackageConfig,omitempty" xml:"PackageConfig,omitempty" type:"Struct"`
	PostStart          *string                      `json:"PostStart,omitempty" xml:"PostStart,omitempty"`
	PreStop            *string                      `json:"PreStop,omitempty" xml:"PreStop,omitempty"`
	PvcMountDescs      []*AppConfigPvcMountDescs    `json:"PvcMountDescs,omitempty" xml:"PvcMountDescs,omitempty" type:"Repeated"`
	Readiness          *string                      `json:"Readiness,omitempty" xml:"Readiness,omitempty"`
	Replicas           *int64                       `json:"Replicas,omitempty" xml:"Replicas,omitempty"`
	RequestCpu         *string                      `json:"RequestCpu,omitempty" xml:"RequestCpu,omitempty"`
	RequestMem         *string                      `json:"RequestMem,omitempty" xml:"RequestMem,omitempty"`
	RuntimeClassName   *string                      `json:"RuntimeClassName,omitempty" xml:"RuntimeClassName,omitempty"`
	SlsConfigs         []*AppConfigSlsConfigs       `json:"SlsConfigs,omitempty" xml:"SlsConfigs,omitempty" type:"Repeated"`
	WebContainerConfig *AppConfigWebContainerConfig `json:"WebContainerConfig,omitempty" xml:"WebContainerConfig,omitempty" type:"Struct"`
}

func (s AppConfig) String() string {
	return tea.Prettify(s)
}

func (s AppConfig) GoString() string {
	return s.String()
}

func (s *AppConfig) SetCommand(v string) *AppConfig {
	s.Command = &v
	return s
}

func (s *AppConfig) SetCommandArgs(v []*string) *AppConfig {
	s.CommandArgs = v
	return s
}

func (s *AppConfig) SetConfigMountDescs(v []*AppConfigConfigMountDescs) *AppConfig {
	s.ConfigMountDescs = v
	return s
}

func (s *AppConfig) SetDeployAcrossNodes(v bool) *AppConfig {
	s.DeployAcrossNodes = &v
	return s
}

func (s *AppConfig) SetDeployAcrossZones(v bool) *AppConfig {
	s.DeployAcrossZones = &v
	return s
}

func (s *AppConfig) SetEmptyDirs(v []*AppConfigEmptyDirs) *AppConfig {
	s.EmptyDirs = v
	return s
}

func (s *AppConfig) SetEnableAhas(v bool) *AppConfig {
	s.EnableAhas = &v
	return s
}

func (s *AppConfig) SetEnvFroms(v []*AppConfigEnvFroms) *AppConfig {
	s.EnvFroms = v
	return s
}

func (s *AppConfig) SetEnvs(v []*AppConfigEnvs) *AppConfig {
	s.Envs = v
	return s
}

func (s *AppConfig) SetImageConfig(v *AppConfigImageConfig) *AppConfig {
	s.ImageConfig = v
	return s
}

func (s *AppConfig) SetIsMultilingualApp(v bool) *AppConfig {
	s.IsMultilingualApp = &v
	return s
}

func (s *AppConfig) SetJavaStartUpConfig(v string) *AppConfig {
	s.JavaStartUpConfig = &v
	return s
}

func (s *AppConfig) SetLimitCpu(v string) *AppConfig {
	s.LimitCpu = &v
	return s
}

func (s *AppConfig) SetLimitMem(v string) *AppConfig {
	s.LimitMem = &v
	return s
}

func (s *AppConfig) SetLiveness(v string) *AppConfig {
	s.Liveness = &v
	return s
}

func (s *AppConfig) SetLocalVolumes(v []*AppConfigLocalVolumes) *AppConfig {
	s.LocalVolumes = v
	return s
}

func (s *AppConfig) SetNasId(v string) *AppConfig {
	s.NasId = &v
	return s
}

func (s *AppConfig) SetNasMountDescs(v []*AppConfigNasMountDescs) *AppConfig {
	s.NasMountDescs = v
	return s
}

func (s *AppConfig) SetNasStorageType(v string) *AppConfig {
	s.NasStorageType = &v
	return s
}

func (s *AppConfig) SetPackageConfig(v *AppConfigPackageConfig) *AppConfig {
	s.PackageConfig = v
	return s
}

func (s *AppConfig) SetPostStart(v string) *AppConfig {
	s.PostStart = &v
	return s
}

func (s *AppConfig) SetPreStop(v string) *AppConfig {
	s.PreStop = &v
	return s
}

func (s *AppConfig) SetPvcMountDescs(v []*AppConfigPvcMountDescs) *AppConfig {
	s.PvcMountDescs = v
	return s
}

func (s *AppConfig) SetReadiness(v string) *AppConfig {
	s.Readiness = &v
	return s
}

func (s *AppConfig) SetReplicas(v int64) *AppConfig {
	s.Replicas = &v
	return s
}

func (s *AppConfig) SetRequestCpu(v string) *AppConfig {
	s.RequestCpu = &v
	return s
}

func (s *AppConfig) SetRequestMem(v string) *AppConfig {
	s.RequestMem = &v
	return s
}

func (s *AppConfig) SetRuntimeClassName(v string) *AppConfig {
	s.RuntimeClassName = &v
	return s
}

func (s *AppConfig) SetSlsConfigs(v []*AppConfigSlsConfigs) *AppConfig {
	s.SlsConfigs = v
	return s
}

func (s *AppConfig) SetWebContainerConfig(v *AppConfigWebContainerConfig) *AppConfig {
	s.WebContainerConfig = v
	return s
}

type AppConfigConfigMountDescs struct {
	MountItems []*AppConfigConfigMountDescsMountItems `json:"MountItems,omitempty" xml:"MountItems,omitempty" type:"Repeated"`
	MountPath  *string                                `json:"MountPath,omitempty" xml:"MountPath,omitempty"`
	Name       *string                                `json:"Name,omitempty" xml:"Name,omitempty"`
	Type       *string                                `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s AppConfigConfigMountDescs) String() string {
	return tea.Prettify(s)
}

func (s AppConfigConfigMountDescs) GoString() string {
	return s.String()
}

func (s *AppConfigConfigMountDescs) SetMountItems(v []*AppConfigConfigMountDescsMountItems) *AppConfigConfigMountDescs {
	s.MountItems = v
	return s
}

func (s *AppConfigConfigMountDescs) SetMountPath(v string) *AppConfigConfigMountDescs {
	s.MountPath = &v
	return s
}

func (s *AppConfigConfigMountDescs) SetName(v string) *AppConfigConfigMountDescs {
	s.Name = &v
	return s
}

func (s *AppConfigConfigMountDescs) SetType(v string) *AppConfigConfigMountDescs {
	s.Type = &v
	return s
}

type AppConfigConfigMountDescsMountItems struct {
	Key  *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s AppConfigConfigMountDescsMountItems) String() string {
	return tea.Prettify(s)
}

func (s AppConfigConfigMountDescsMountItems) GoString() string {
	return s.String()
}

func (s *AppConfigConfigMountDescsMountItems) SetKey(v string) *AppConfigConfigMountDescsMountItems {
	s.Key = &v
	return s
}

func (s *AppConfigConfigMountDescsMountItems) SetPath(v string) *AppConfigConfigMountDescsMountItems {
	s.Path = &v
	return s
}

type AppConfigEmptyDirs struct {
	MountPath   *string `json:"MountPath,omitempty" xml:"MountPath,omitempty"`
	Name        *string `json:"Name,omitempty" xml:"Name,omitempty"`
	ReadOnly    *bool   `json:"ReadOnly,omitempty" xml:"ReadOnly,omitempty"`
	SubPathExpr *string `json:"SubPathExpr,omitempty" xml:"SubPathExpr,omitempty"`
}

func (s AppConfigEmptyDirs) String() string {
	return tea.Prettify(s)
}

func (s AppConfigEmptyDirs) GoString() string {
	return s.String()
}

func (s *AppConfigEmptyDirs) SetMountPath(v string) *AppConfigEmptyDirs {
	s.MountPath = &v
	return s
}

func (s *AppConfigEmptyDirs) SetName(v string) *AppConfigEmptyDirs {
	s.Name = &v
	return s
}

func (s *AppConfigEmptyDirs) SetReadOnly(v bool) *AppConfigEmptyDirs {
	s.ReadOnly = &v
	return s
}

func (s *AppConfigEmptyDirs) SetSubPathExpr(v string) *AppConfigEmptyDirs {
	s.SubPathExpr = &v
	return s
}

type AppConfigEnvFroms struct {
	ConfigMapRef *string `json:"ConfigMapRef,omitempty" xml:"ConfigMapRef,omitempty"`
	SecretRef    *string `json:"SecretRef,omitempty" xml:"SecretRef,omitempty"`
}

func (s AppConfigEnvFroms) String() string {
	return tea.Prettify(s)
}

func (s AppConfigEnvFroms) GoString() string {
	return s.String()
}

func (s *AppConfigEnvFroms) SetConfigMapRef(v string) *AppConfigEnvFroms {
	s.ConfigMapRef = &v
	return s
}

func (s *AppConfigEnvFroms) SetSecretRef(v string) *AppConfigEnvFroms {
	s.SecretRef = &v
	return s
}

type AppConfigEnvs struct {
	Name      *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Value     *string `json:"Value,omitempty" xml:"Value,omitempty"`
	ValueFrom *string `json:"ValueFrom,omitempty" xml:"ValueFrom,omitempty"`
}

func (s AppConfigEnvs) String() string {
	return tea.Prettify(s)
}

func (s AppConfigEnvs) GoString() string {
	return s.String()
}

func (s *AppConfigEnvs) SetName(v string) *AppConfigEnvs {
	s.Name = &v
	return s
}

func (s *AppConfigEnvs) SetValue(v string) *AppConfigEnvs {
	s.Value = &v
	return s
}

func (s *AppConfigEnvs) SetValueFrom(v string) *AppConfigEnvs {
	s.ValueFrom = &v
	return s
}

type AppConfigImageConfig struct {
	ContainerRegistryId *string `json:"ContainerRegistryId,omitempty" xml:"ContainerRegistryId,omitempty"`
	CrInstanceId        *string `json:"CrInstanceId,omitempty" xml:"CrInstanceId,omitempty"`
	CrRegionId          *string `json:"CrRegionId,omitempty" xml:"CrRegionId,omitempty"`
	ImageUrl            *string `json:"ImageUrl,omitempty" xml:"ImageUrl,omitempty"`
}

func (s AppConfigImageConfig) String() string {
	return tea.Prettify(s)
}

func (s AppConfigImageConfig) GoString() string {
	return s.String()
}

func (s *AppConfigImageConfig) SetContainerRegistryId(v string) *AppConfigImageConfig {
	s.ContainerRegistryId = &v
	return s
}

func (s *AppConfigImageConfig) SetCrInstanceId(v string) *AppConfigImageConfig {
	s.CrInstanceId = &v
	return s
}

func (s *AppConfigImageConfig) SetCrRegionId(v string) *AppConfigImageConfig {
	s.CrRegionId = &v
	return s
}

func (s *AppConfigImageConfig) SetImageUrl(v string) *AppConfigImageConfig {
	s.ImageUrl = &v
	return s
}

type AppConfigLocalVolumes struct {
	MountPath *string `json:"MountPath,omitempty" xml:"MountPath,omitempty"`
	Name      *string `json:"Name,omitempty" xml:"Name,omitempty"`
	NodePath  *string `json:"NodePath,omitempty" xml:"NodePath,omitempty"`
	OpsAuth   *int64  `json:"OpsAuth,omitempty" xml:"OpsAuth,omitempty"`
	Type      *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s AppConfigLocalVolumes) String() string {
	return tea.Prettify(s)
}

func (s AppConfigLocalVolumes) GoString() string {
	return s.String()
}

func (s *AppConfigLocalVolumes) SetMountPath(v string) *AppConfigLocalVolumes {
	s.MountPath = &v
	return s
}

func (s *AppConfigLocalVolumes) SetName(v string) *AppConfigLocalVolumes {
	s.Name = &v
	return s
}

func (s *AppConfigLocalVolumes) SetNodePath(v string) *AppConfigLocalVolumes {
	s.NodePath = &v
	return s
}

func (s *AppConfigLocalVolumes) SetOpsAuth(v int64) *AppConfigLocalVolumes {
	s.OpsAuth = &v
	return s
}

func (s *AppConfigLocalVolumes) SetType(v string) *AppConfigLocalVolumes {
	s.Type = &v
	return s
}

type AppConfigNasMountDescs struct {
	MountPath *string `json:"MountPath,omitempty" xml:"MountPath,omitempty"`
	NasPath   *string `json:"NasPath,omitempty" xml:"NasPath,omitempty"`
}

func (s AppConfigNasMountDescs) String() string {
	return tea.Prettify(s)
}

func (s AppConfigNasMountDescs) GoString() string {
	return s.String()
}

func (s *AppConfigNasMountDescs) SetMountPath(v string) *AppConfigNasMountDescs {
	s.MountPath = &v
	return s
}

func (s *AppConfigNasMountDescs) SetNasPath(v string) *AppConfigNasMountDescs {
	s.NasPath = &v
	return s
}

type AppConfigPackageConfig struct {
	EdasContainerVersion *string `json:"EdasContainerVersion,omitempty" xml:"EdasContainerVersion,omitempty"`
	Jdk                  *string `json:"Jdk,omitempty" xml:"Jdk,omitempty"`
	PackageType          *string `json:"PackageType,omitempty" xml:"PackageType,omitempty"`
	PackageUrl           *string `json:"PackageUrl,omitempty" xml:"PackageUrl,omitempty"`
	PackageVersion       *string `json:"PackageVersion,omitempty" xml:"PackageVersion,omitempty"`
	Timezone             *string `json:"Timezone,omitempty" xml:"Timezone,omitempty"`
	UriEncoding          *string `json:"UriEncoding,omitempty" xml:"UriEncoding,omitempty"`
	UseBodyEncoding      *bool   `json:"UseBodyEncoding,omitempty" xml:"UseBodyEncoding,omitempty"`
	WebContainer         *string `json:"WebContainer,omitempty" xml:"WebContainer,omitempty"`
}

func (s AppConfigPackageConfig) String() string {
	return tea.Prettify(s)
}

func (s AppConfigPackageConfig) GoString() string {
	return s.String()
}

func (s *AppConfigPackageConfig) SetEdasContainerVersion(v string) *AppConfigPackageConfig {
	s.EdasContainerVersion = &v
	return s
}

func (s *AppConfigPackageConfig) SetJdk(v string) *AppConfigPackageConfig {
	s.Jdk = &v
	return s
}

func (s *AppConfigPackageConfig) SetPackageType(v string) *AppConfigPackageConfig {
	s.PackageType = &v
	return s
}

func (s *AppConfigPackageConfig) SetPackageUrl(v string) *AppConfigPackageConfig {
	s.PackageUrl = &v
	return s
}

func (s *AppConfigPackageConfig) SetPackageVersion(v string) *AppConfigPackageConfig {
	s.PackageVersion = &v
	return s
}

func (s *AppConfigPackageConfig) SetTimezone(v string) *AppConfigPackageConfig {
	s.Timezone = &v
	return s
}

func (s *AppConfigPackageConfig) SetUriEncoding(v string) *AppConfigPackageConfig {
	s.UriEncoding = &v
	return s
}

func (s *AppConfigPackageConfig) SetUseBodyEncoding(v bool) *AppConfigPackageConfig {
	s.UseBodyEncoding = &v
	return s
}

func (s *AppConfigPackageConfig) SetWebContainer(v string) *AppConfigPackageConfig {
	s.WebContainer = &v
	return s
}

type AppConfigPvcMountDescs struct {
	MountPaths []*AppConfigPvcMountDescsMountPaths `json:"MountPaths,omitempty" xml:"MountPaths,omitempty" type:"Repeated"`
	PvcName    *string                             `json:"PvcName,omitempty" xml:"PvcName,omitempty"`
}

func (s AppConfigPvcMountDescs) String() string {
	return tea.Prettify(s)
}

func (s AppConfigPvcMountDescs) GoString() string {
	return s.String()
}

func (s *AppConfigPvcMountDescs) SetMountPaths(v []*AppConfigPvcMountDescsMountPaths) *AppConfigPvcMountDescs {
	s.MountPaths = v
	return s
}

func (s *AppConfigPvcMountDescs) SetPvcName(v string) *AppConfigPvcMountDescs {
	s.PvcName = &v
	return s
}

type AppConfigPvcMountDescsMountPaths struct {
	MountPath   *string `json:"MountPath,omitempty" xml:"MountPath,omitempty"`
	ReadOnly    *bool   `json:"ReadOnly,omitempty" xml:"ReadOnly,omitempty"`
	SubPathExpr *string `json:"SubPathExpr,omitempty" xml:"SubPathExpr,omitempty"`
}

func (s AppConfigPvcMountDescsMountPaths) String() string {
	return tea.Prettify(s)
}

func (s AppConfigPvcMountDescsMountPaths) GoString() string {
	return s.String()
}

func (s *AppConfigPvcMountDescsMountPaths) SetMountPath(v string) *AppConfigPvcMountDescsMountPaths {
	s.MountPath = &v
	return s
}

func (s *AppConfigPvcMountDescsMountPaths) SetReadOnly(v bool) *AppConfigPvcMountDescsMountPaths {
	s.ReadOnly = &v
	return s
}

func (s *AppConfigPvcMountDescsMountPaths) SetSubPathExpr(v string) *AppConfigPvcMountDescsMountPaths {
	s.SubPathExpr = &v
	return s
}

type AppConfigSlsConfigs struct {
	LogDir   *string `json:"LogDir,omitempty" xml:"LogDir,omitempty"`
	Logstore *string `json:"Logstore,omitempty" xml:"Logstore,omitempty"`
	Project  *string `json:"Project,omitempty" xml:"Project,omitempty"`
	Type     *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s AppConfigSlsConfigs) String() string {
	return tea.Prettify(s)
}

func (s AppConfigSlsConfigs) GoString() string {
	return s.String()
}

func (s *AppConfigSlsConfigs) SetLogDir(v string) *AppConfigSlsConfigs {
	s.LogDir = &v
	return s
}

func (s *AppConfigSlsConfigs) SetLogstore(v string) *AppConfigSlsConfigs {
	s.Logstore = &v
	return s
}

func (s *AppConfigSlsConfigs) SetProject(v string) *AppConfigSlsConfigs {
	s.Project = &v
	return s
}

func (s *AppConfigSlsConfigs) SetType(v string) *AppConfigSlsConfigs {
	s.Type = &v
	return s
}

type AppConfigWebContainerConfig struct {
	ConnectorType        *string `json:"ConnectorType,omitempty" xml:"ConnectorType,omitempty"`
	ContextInputType     *string `json:"ContextInputType,omitempty" xml:"ContextInputType,omitempty"`
	ContextPath          *string `json:"ContextPath,omitempty" xml:"ContextPath,omitempty"`
	HttpPort             *int64  `json:"HttpPort,omitempty" xml:"HttpPort,omitempty"`
	MaxThreads           *int64  `json:"MaxThreads,omitempty" xml:"MaxThreads,omitempty"`
	ServerXml            *string `json:"ServerXml,omitempty" xml:"ServerXml,omitempty"`
	UriEncoding          *string `json:"UriEncoding,omitempty" xml:"UriEncoding,omitempty"`
	UseAdvancedServerXml *bool   `json:"UseAdvancedServerXml,omitempty" xml:"UseAdvancedServerXml,omitempty"`
	UseBodyEncoding      *bool   `json:"UseBodyEncoding,omitempty" xml:"UseBodyEncoding,omitempty"`
	UseDefaultConfig     *bool   `json:"UseDefaultConfig,omitempty" xml:"UseDefaultConfig,omitempty"`
}

func (s AppConfigWebContainerConfig) String() string {
	return tea.Prettify(s)
}

func (s AppConfigWebContainerConfig) GoString() string {
	return s.String()
}

func (s *AppConfigWebContainerConfig) SetConnectorType(v string) *AppConfigWebContainerConfig {
	s.ConnectorType = &v
	return s
}

func (s *AppConfigWebContainerConfig) SetContextInputType(v string) *AppConfigWebContainerConfig {
	s.ContextInputType = &v
	return s
}

func (s *AppConfigWebContainerConfig) SetContextPath(v string) *AppConfigWebContainerConfig {
	s.ContextPath = &v
	return s
}

func (s *AppConfigWebContainerConfig) SetHttpPort(v int64) *AppConfigWebContainerConfig {
	s.HttpPort = &v
	return s
}

func (s *AppConfigWebContainerConfig) SetMaxThreads(v int64) *AppConfigWebContainerConfig {
	s.MaxThreads = &v
	return s
}

func (s *AppConfigWebContainerConfig) SetServerXml(v string) *AppConfigWebContainerConfig {
	s.ServerXml = &v
	return s
}

func (s *AppConfigWebContainerConfig) SetUriEncoding(v string) *AppConfigWebContainerConfig {
	s.UriEncoding = &v
	return s
}

func (s *AppConfigWebContainerConfig) SetUseAdvancedServerXml(v bool) *AppConfigWebContainerConfig {
	s.UseAdvancedServerXml = &v
	return s
}

func (s *AppConfigWebContainerConfig) SetUseBodyEncoding(v bool) *AppConfigWebContainerConfig {
	s.UseBodyEncoding = &v
	return s
}

func (s *AppConfigWebContainerConfig) SetUseDefaultConfig(v bool) *AppConfigWebContainerConfig {
	s.UseDefaultConfig = &v
	return s
}

type AbortAndRollbackChangeOrderRequest struct {
	// The ID of the change process.
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
}

func (s AbortAndRollbackChangeOrderRequest) String() string {
	return tea.Prettify(s)
}

func (s AbortAndRollbackChangeOrderRequest) GoString() string {
	return s.String()
}

func (s *AbortAndRollbackChangeOrderRequest) SetChangeOrderId(v string) *AbortAndRollbackChangeOrderRequest {
	s.ChangeOrderId = &v
	return s
}

type AbortAndRollbackChangeOrderResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The information about the change process.
	Data *AbortAndRollbackChangeOrderResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code that is returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the trace.
	TraceId *string `json:"TraceId,omitempty" xml:"TraceId,omitempty"`
}

func (s AbortAndRollbackChangeOrderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AbortAndRollbackChangeOrderResponseBody) GoString() string {
	return s.String()
}

func (s *AbortAndRollbackChangeOrderResponseBody) SetCode(v int32) *AbortAndRollbackChangeOrderResponseBody {
	s.Code = &v
	return s
}

func (s *AbortAndRollbackChangeOrderResponseBody) SetData(v *AbortAndRollbackChangeOrderResponseBodyData) *AbortAndRollbackChangeOrderResponseBody {
	s.Data = v
	return s
}

func (s *AbortAndRollbackChangeOrderResponseBody) SetErrorCode(v string) *AbortAndRollbackChangeOrderResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *AbortAndRollbackChangeOrderResponseBody) SetMessage(v string) *AbortAndRollbackChangeOrderResponseBody {
	s.Message = &v
	return s
}

func (s *AbortAndRollbackChangeOrderResponseBody) SetRequestId(v string) *AbortAndRollbackChangeOrderResponseBody {
	s.RequestId = &v
	return s
}

func (s *AbortAndRollbackChangeOrderResponseBody) SetTraceId(v string) *AbortAndRollbackChangeOrderResponseBody {
	s.TraceId = &v
	return s
}

type AbortAndRollbackChangeOrderResponseBodyData struct {
	// The ID of the change process.
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
}

func (s AbortAndRollbackChangeOrderResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s AbortAndRollbackChangeOrderResponseBodyData) GoString() string {
	return s.String()
}

func (s *AbortAndRollbackChangeOrderResponseBodyData) SetChangeOrderId(v string) *AbortAndRollbackChangeOrderResponseBodyData {
	s.ChangeOrderId = &v
	return s
}

type AbortAndRollbackChangeOrderResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *AbortAndRollbackChangeOrderResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AbortAndRollbackChangeOrderResponse) String() string {
	return tea.Prettify(s)
}

func (s AbortAndRollbackChangeOrderResponse) GoString() string {
	return s.String()
}

func (s *AbortAndRollbackChangeOrderResponse) SetHeaders(v map[string]*string) *AbortAndRollbackChangeOrderResponse {
	s.Headers = v
	return s
}

func (s *AbortAndRollbackChangeOrderResponse) SetStatusCode(v int32) *AbortAndRollbackChangeOrderResponse {
	s.StatusCode = &v
	return s
}

func (s *AbortAndRollbackChangeOrderResponse) SetBody(v *AbortAndRollbackChangeOrderResponseBody) *AbortAndRollbackChangeOrderResponse {
	s.Body = v
	return s
}

type AbortChangeOrderRequest struct {
	// The ID of the change process. You can call the [GetChangeOrderInfo](~~62072~~) operation to query the change process ID.
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
}

func (s AbortChangeOrderRequest) String() string {
	return tea.Prettify(s)
}

func (s AbortChangeOrderRequest) GoString() string {
	return s.String()
}

func (s *AbortChangeOrderRequest) SetChangeOrderId(v string) *AbortChangeOrderRequest {
	s.ChangeOrderId = &v
	return s
}

type AbortChangeOrderResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The change process.
	Data *AbortChangeOrderResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code that is returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the trace.
	TraceId *string `json:"TraceId,omitempty" xml:"TraceId,omitempty"`
}

func (s AbortChangeOrderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AbortChangeOrderResponseBody) GoString() string {
	return s.String()
}

func (s *AbortChangeOrderResponseBody) SetCode(v int32) *AbortChangeOrderResponseBody {
	s.Code = &v
	return s
}

func (s *AbortChangeOrderResponseBody) SetData(v *AbortChangeOrderResponseBodyData) *AbortChangeOrderResponseBody {
	s.Data = v
	return s
}

func (s *AbortChangeOrderResponseBody) SetErrorCode(v string) *AbortChangeOrderResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *AbortChangeOrderResponseBody) SetMessage(v string) *AbortChangeOrderResponseBody {
	s.Message = &v
	return s
}

func (s *AbortChangeOrderResponseBody) SetRequestId(v string) *AbortChangeOrderResponseBody {
	s.RequestId = &v
	return s
}

func (s *AbortChangeOrderResponseBody) SetTraceId(v string) *AbortChangeOrderResponseBody {
	s.TraceId = &v
	return s
}

type AbortChangeOrderResponseBodyData struct {
	// The ID of the change process.
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
}

func (s AbortChangeOrderResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s AbortChangeOrderResponseBodyData) GoString() string {
	return s.String()
}

func (s *AbortChangeOrderResponseBodyData) SetChangeOrderId(v string) *AbortChangeOrderResponseBodyData {
	s.ChangeOrderId = &v
	return s
}

type AbortChangeOrderResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *AbortChangeOrderResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AbortChangeOrderResponse) String() string {
	return tea.Prettify(s)
}

func (s AbortChangeOrderResponse) GoString() string {
	return s.String()
}

func (s *AbortChangeOrderResponse) SetHeaders(v map[string]*string) *AbortChangeOrderResponse {
	s.Headers = v
	return s
}

func (s *AbortChangeOrderResponse) SetStatusCode(v int32) *AbortChangeOrderResponse {
	s.StatusCode = &v
	return s
}

func (s *AbortChangeOrderResponse) SetBody(v *AbortChangeOrderResponseBody) *AbortChangeOrderResponse {
	s.Body = v
	return s
}

type AddLogPathRequest struct {
	// The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The absolute path of the log directory that you want to add. The value must start and end with a forward slash (`/`) and must contain `/log` or `/logs`. The following directories are the default log directories in Enterprise Distributed Application Service (EDAS):
	//
	// *   /home/admin/edas-container/logs/
	// *   /home/admin/taobao-tomcat-7.0.59/logs/
	// *   /home/admin/taobao-tomcat-production-7.0.59.3/logs/
	// *   /home/admin/taobao-tomcat-production-7.0.70/logs/
	// *   /home/admin/edas-agent/logs/
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s AddLogPathRequest) String() string {
	return tea.Prettify(s)
}

func (s AddLogPathRequest) GoString() string {
	return s.String()
}

func (s *AddLogPathRequest) SetAppId(v string) *AddLogPathRequest {
	s.AppId = &v
	return s
}

func (s *AddLogPathRequest) SetPath(v string) *AddLogPathRequest {
	s.Path = &v
	return s
}

type AddLogPathResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddLogPathResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddLogPathResponseBody) GoString() string {
	return s.String()
}

func (s *AddLogPathResponseBody) SetCode(v int32) *AddLogPathResponseBody {
	s.Code = &v
	return s
}

func (s *AddLogPathResponseBody) SetMessage(v string) *AddLogPathResponseBody {
	s.Message = &v
	return s
}

func (s *AddLogPathResponseBody) SetRequestId(v string) *AddLogPathResponseBody {
	s.RequestId = &v
	return s
}

type AddLogPathResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *AddLogPathResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AddLogPathResponse) String() string {
	return tea.Prettify(s)
}

func (s AddLogPathResponse) GoString() string {
	return s.String()
}

func (s *AddLogPathResponse) SetHeaders(v map[string]*string) *AddLogPathResponse {
	s.Headers = v
	return s
}

func (s *AddLogPathResponse) SetStatusCode(v int32) *AddLogPathResponse {
	s.StatusCode = &v
	return s
}

func (s *AddLogPathResponse) SetBody(v *AddLogPathResponseBody) *AddLogPathResponse {
	s.Body = v
	return s
}

type AuthorizeApplicationRequest struct {
	// The ID of the application. You can specify multiple IDs. Separate multiple IDs with semicolons (;). If you leave this parameter empty, the permissions on the application are revoked.
	AppIds *string `json:"AppIds,omitempty" xml:"AppIds,omitempty"`
	// The ID of the RAM user to be authorized. The value of the parameter is in the `sub-account name@primary account UID` format.
	TargetUserId *string `json:"TargetUserId,omitempty" xml:"TargetUserId,omitempty"`
}

func (s AuthorizeApplicationRequest) String() string {
	return tea.Prettify(s)
}

func (s AuthorizeApplicationRequest) GoString() string {
	return s.String()
}

func (s *AuthorizeApplicationRequest) SetAppIds(v string) *AuthorizeApplicationRequest {
	s.AppIds = &v
	return s
}

func (s *AuthorizeApplicationRequest) SetTargetUserId(v string) *AuthorizeApplicationRequest {
	s.TargetUserId = &v
	return s
}

type AuthorizeApplicationResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AuthorizeApplicationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AuthorizeApplicationResponseBody) GoString() string {
	return s.String()
}

func (s *AuthorizeApplicationResponseBody) SetCode(v int32) *AuthorizeApplicationResponseBody {
	s.Code = &v
	return s
}

func (s *AuthorizeApplicationResponseBody) SetMessage(v string) *AuthorizeApplicationResponseBody {
	s.Message = &v
	return s
}

func (s *AuthorizeApplicationResponseBody) SetRequestId(v string) *AuthorizeApplicationResponseBody {
	s.RequestId = &v
	return s
}

type AuthorizeApplicationResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *AuthorizeApplicationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AuthorizeApplicationResponse) String() string {
	return tea.Prettify(s)
}

func (s AuthorizeApplicationResponse) GoString() string {
	return s.String()
}

func (s *AuthorizeApplicationResponse) SetHeaders(v map[string]*string) *AuthorizeApplicationResponse {
	s.Headers = v
	return s
}

func (s *AuthorizeApplicationResponse) SetStatusCode(v int32) *AuthorizeApplicationResponse {
	s.StatusCode = &v
	return s
}

func (s *AuthorizeApplicationResponse) SetBody(v *AuthorizeApplicationResponseBody) *AuthorizeApplicationResponse {
	s.Body = v
	return s
}

type AuthorizeResourceGroupRequest struct {
	// The ID of the resource group. You can call the ListResourceGroup operation to query the resource group ID. For more information, see [ListResourceGroup](~~62055~~).
	//
	// You can specify multiple resource group IDs. Separate multiple resource group IDs with semicolons (;).
	ResourceGroupIds *string `json:"ResourceGroupIds,omitempty" xml:"ResourceGroupIds,omitempty"`
	// The ID of the RAM user to be authorized.
	TargetUserId *string `json:"TargetUserId,omitempty" xml:"TargetUserId,omitempty"`
}

func (s AuthorizeResourceGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s AuthorizeResourceGroupRequest) GoString() string {
	return s.String()
}

func (s *AuthorizeResourceGroupRequest) SetResourceGroupIds(v string) *AuthorizeResourceGroupRequest {
	s.ResourceGroupIds = &v
	return s
}

func (s *AuthorizeResourceGroupRequest) SetTargetUserId(v string) *AuthorizeResourceGroupRequest {
	s.TargetUserId = &v
	return s
}

type AuthorizeResourceGroupResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AuthorizeResourceGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AuthorizeResourceGroupResponseBody) GoString() string {
	return s.String()
}

func (s *AuthorizeResourceGroupResponseBody) SetCode(v int32) *AuthorizeResourceGroupResponseBody {
	s.Code = &v
	return s
}

func (s *AuthorizeResourceGroupResponseBody) SetMessage(v string) *AuthorizeResourceGroupResponseBody {
	s.Message = &v
	return s
}

func (s *AuthorizeResourceGroupResponseBody) SetRequestId(v string) *AuthorizeResourceGroupResponseBody {
	s.RequestId = &v
	return s
}

type AuthorizeResourceGroupResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *AuthorizeResourceGroupResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AuthorizeResourceGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s AuthorizeResourceGroupResponse) GoString() string {
	return s.String()
}

func (s *AuthorizeResourceGroupResponse) SetHeaders(v map[string]*string) *AuthorizeResourceGroupResponse {
	s.Headers = v
	return s
}

func (s *AuthorizeResourceGroupResponse) SetStatusCode(v int32) *AuthorizeResourceGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *AuthorizeResourceGroupResponse) SetBody(v *AuthorizeResourceGroupResponseBody) *AuthorizeResourceGroupResponse {
	s.Body = v
	return s
}

type AuthorizeRoleRequest struct {
	// The ID of the role to be assigned. If you want to assign multiple roles to the specified RAM user, separate the IDs of the roles with semicolons (;). If you leave this parameter empty, the roles assigned to the specified RAM user are revoked.
	RoleIds *string `json:"RoleIds,omitempty" xml:"RoleIds,omitempty"`
	// The ID of the RAM user to which you want to assign the roles.
	TargetUserId *string `json:"TargetUserId,omitempty" xml:"TargetUserId,omitempty"`
}

func (s AuthorizeRoleRequest) String() string {
	return tea.Prettify(s)
}

func (s AuthorizeRoleRequest) GoString() string {
	return s.String()
}

func (s *AuthorizeRoleRequest) SetRoleIds(v string) *AuthorizeRoleRequest {
	s.RoleIds = &v
	return s
}

func (s *AuthorizeRoleRequest) SetTargetUserId(v string) *AuthorizeRoleRequest {
	s.TargetUserId = &v
	return s
}

type AuthorizeRoleResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AuthorizeRoleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AuthorizeRoleResponseBody) GoString() string {
	return s.String()
}

func (s *AuthorizeRoleResponseBody) SetCode(v int32) *AuthorizeRoleResponseBody {
	s.Code = &v
	return s
}

func (s *AuthorizeRoleResponseBody) SetMessage(v string) *AuthorizeRoleResponseBody {
	s.Message = &v
	return s
}

func (s *AuthorizeRoleResponseBody) SetRequestId(v string) *AuthorizeRoleResponseBody {
	s.RequestId = &v
	return s
}

type AuthorizeRoleResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *AuthorizeRoleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AuthorizeRoleResponse) String() string {
	return tea.Prettify(s)
}

func (s AuthorizeRoleResponse) GoString() string {
	return s.String()
}

func (s *AuthorizeRoleResponse) SetHeaders(v map[string]*string) *AuthorizeRoleResponse {
	s.Headers = v
	return s
}

func (s *AuthorizeRoleResponse) SetStatusCode(v int32) *AuthorizeRoleResponse {
	s.StatusCode = &v
	return s
}

func (s *AuthorizeRoleResponse) SetBody(v *AuthorizeRoleResponseBody) *AuthorizeRoleResponse {
	s.Body = v
	return s
}

type BindEcsSlbRequest struct {
	// The ID of the application. You can query the application ID by calling the ListApplication operation. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the instance group whose application you want to bind. You can call the ListDeployGroup operation to query the group ID. For more information, see [ListDeployGroup](~~62077~~).
	DeployGroupId *string `json:"DeployGroupId,omitempty" xml:"DeployGroupId,omitempty"`
	// The health check URL.
	ListenerHealthCheckUrl *string `json:"ListenerHealthCheckUrl,omitempty" xml:"ListenerHealthCheckUrl,omitempty"`
	// The listener port for the SLB instance.
	ListenerPort *int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	// The listener protocol for the SLB instance.
	ListenerProtocol *string `json:"ListenerProtocol,omitempty" xml:"ListenerProtocol,omitempty"`
	// The ID of the SLB instance.
	SlbId *string `json:"SlbId,omitempty" xml:"SlbId,omitempty"`
	// The forwarding rule of the SLB listener.
	VForwardingUrlRule *string `json:"VForwardingUrlRule,omitempty" xml:"VForwardingUrlRule,omitempty"`
	// The ID of the vServer group for the SLB instance.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
	// The name of the vServer group.
	VServerGroupName *string `json:"VServerGroupName,omitempty" xml:"VServerGroupName,omitempty"`
}

func (s BindEcsSlbRequest) String() string {
	return tea.Prettify(s)
}

func (s BindEcsSlbRequest) GoString() string {
	return s.String()
}

func (s *BindEcsSlbRequest) SetAppId(v string) *BindEcsSlbRequest {
	s.AppId = &v
	return s
}

func (s *BindEcsSlbRequest) SetDeployGroupId(v string) *BindEcsSlbRequest {
	s.DeployGroupId = &v
	return s
}

func (s *BindEcsSlbRequest) SetListenerHealthCheckUrl(v string) *BindEcsSlbRequest {
	s.ListenerHealthCheckUrl = &v
	return s
}

func (s *BindEcsSlbRequest) SetListenerPort(v int32) *BindEcsSlbRequest {
	s.ListenerPort = &v
	return s
}

func (s *BindEcsSlbRequest) SetListenerProtocol(v string) *BindEcsSlbRequest {
	s.ListenerProtocol = &v
	return s
}

func (s *BindEcsSlbRequest) SetSlbId(v string) *BindEcsSlbRequest {
	s.SlbId = &v
	return s
}

func (s *BindEcsSlbRequest) SetVForwardingUrlRule(v string) *BindEcsSlbRequest {
	s.VForwardingUrlRule = &v
	return s
}

func (s *BindEcsSlbRequest) SetVServerGroupId(v string) *BindEcsSlbRequest {
	s.VServerGroupId = &v
	return s
}

func (s *BindEcsSlbRequest) SetVServerGroupName(v string) *BindEcsSlbRequest {
	s.VServerGroupName = &v
	return s
}

type BindEcsSlbResponseBody struct {
	// The change process ID for this operation.
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BindEcsSlbResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BindEcsSlbResponseBody) GoString() string {
	return s.String()
}

func (s *BindEcsSlbResponseBody) SetChangeOrderId(v string) *BindEcsSlbResponseBody {
	s.ChangeOrderId = &v
	return s
}

func (s *BindEcsSlbResponseBody) SetCode(v int32) *BindEcsSlbResponseBody {
	s.Code = &v
	return s
}

func (s *BindEcsSlbResponseBody) SetMessage(v string) *BindEcsSlbResponseBody {
	s.Message = &v
	return s
}

func (s *BindEcsSlbResponseBody) SetRequestId(v string) *BindEcsSlbResponseBody {
	s.RequestId = &v
	return s
}

type BindEcsSlbResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *BindEcsSlbResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s BindEcsSlbResponse) String() string {
	return tea.Prettify(s)
}

func (s BindEcsSlbResponse) GoString() string {
	return s.String()
}

func (s *BindEcsSlbResponse) SetHeaders(v map[string]*string) *BindEcsSlbResponse {
	s.Headers = v
	return s
}

func (s *BindEcsSlbResponse) SetStatusCode(v int32) *BindEcsSlbResponse {
	s.StatusCode = &v
	return s
}

func (s *BindEcsSlbResponse) SetBody(v *BindEcsSlbResponseBody) *BindEcsSlbResponse {
	s.Body = v
	return s
}

type BindK8sSlbRequest struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The frontend port. Valid values: 1 to 65535.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The scheduling algorithm for the SLB instance. If you do not specify this parameter, the default value rr is used. Valid values:
	//
	// *   wrr: weighted round-robin scheduling. Backend servers that have higher weights receive more requests than those that have lower weights.
	// *   rr: round-robin scheduling. Requests are sequentially distributed to backend servers.
	Scheduler *string `json:"Scheduler,omitempty" xml:"Scheduler,omitempty"`
	// The information about the ports. This parameter is required if you want to configure multi-port mappings or use a protocol other than TCP. You must set this parameter to a JSON array. Example: \[{"targetPort":8080,"port":82,"loadBalancerProtocol":"TCP"},{"port":81,"certId":"1362469756373809\_16c185d6fa2\_1914500329\_-xxxxxxx","targetPort":8181,"lo adBalancerProtocol":"HTTPS"}]
	//
	// *   port: The frontend port. Valid values: 1 to 65535. This parameter is required. Each port must be unique.
	// *   targetPort: The backend port. Valid values: 1 to 65535. This parameter is required.
	// *   loadBalancerProtocol: This parameter is required. Valid values: TCP and HTTPS. If the HTTP protocol is used, set this parameter to TCP.
	// *   certId: the ID of the certificate. This parameter is required if the HTTPS protocol is used. You can purchase an SLB instance in the SLB console.
	//
	// > The ServicePortInfos parameter is specified to support multi-port mappings. If you want this parameter to take effect, make sure that you have set the AppId, ClusterId, Type, and SlbId parameters.
	ServicePortInfos *string `json:"ServicePortInfos,omitempty" xml:"ServicePortInfos,omitempty"`
	// The ID of the SLB instance. If you leave this parameter empty, Enterprise Distributed Application Service (EDAS) automatically purchases an SLB instance.
	SlbId *string `json:"SlbId,omitempty" xml:"SlbId,omitempty"`
	// The protocol used by the SLB instance. Valid values: TCP, HTTP, and HTTPS.
	SlbProtocol *string `json:"SlbProtocol,omitempty" xml:"SlbProtocol,omitempty"`
	// The instance type of the SLB instance. Valid values:
	//
	// *   slb.s1.small
	// *   slb.s2.small
	// *   slb.s2.medium
	// *   slb.s3.small
	// *   slb.s3.medium
	// *   slb.s3.large
	Specification *string `json:"Specification,omitempty" xml:"Specification,omitempty"`
	// The backend port, which is also the service port of the application. Valid values: 1 to 65535.
	TargetPort *string `json:"TargetPort,omitempty" xml:"TargetPort,omitempty"`
	// The type of the SLB instance. Valid values:
	//
	// *   internet: Internet-facing SLB instance
	// *   intranet: internal-facing SLB instance
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s BindK8sSlbRequest) String() string {
	return tea.Prettify(s)
}

func (s BindK8sSlbRequest) GoString() string {
	return s.String()
}

func (s *BindK8sSlbRequest) SetAppId(v string) *BindK8sSlbRequest {
	s.AppId = &v
	return s
}

func (s *BindK8sSlbRequest) SetClusterId(v string) *BindK8sSlbRequest {
	s.ClusterId = &v
	return s
}

func (s *BindK8sSlbRequest) SetPort(v string) *BindK8sSlbRequest {
	s.Port = &v
	return s
}

func (s *BindK8sSlbRequest) SetScheduler(v string) *BindK8sSlbRequest {
	s.Scheduler = &v
	return s
}

func (s *BindK8sSlbRequest) SetServicePortInfos(v string) *BindK8sSlbRequest {
	s.ServicePortInfos = &v
	return s
}

func (s *BindK8sSlbRequest) SetSlbId(v string) *BindK8sSlbRequest {
	s.SlbId = &v
	return s
}

func (s *BindK8sSlbRequest) SetSlbProtocol(v string) *BindK8sSlbRequest {
	s.SlbProtocol = &v
	return s
}

func (s *BindK8sSlbRequest) SetSpecification(v string) *BindK8sSlbRequest {
	s.Specification = &v
	return s
}

func (s *BindK8sSlbRequest) SetTargetPort(v string) *BindK8sSlbRequest {
	s.TargetPort = &v
	return s
}

func (s *BindK8sSlbRequest) SetType(v string) *BindK8sSlbRequest {
	s.Type = &v
	return s
}

type BindK8sSlbResponseBody struct {
	// The ID of the change process.
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BindK8sSlbResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BindK8sSlbResponseBody) GoString() string {
	return s.String()
}

func (s *BindK8sSlbResponseBody) SetChangeOrderId(v string) *BindK8sSlbResponseBody {
	s.ChangeOrderId = &v
	return s
}

func (s *BindK8sSlbResponseBody) SetCode(v int32) *BindK8sSlbResponseBody {
	s.Code = &v
	return s
}

func (s *BindK8sSlbResponseBody) SetMessage(v string) *BindK8sSlbResponseBody {
	s.Message = &v
	return s
}

func (s *BindK8sSlbResponseBody) SetRequestId(v string) *BindK8sSlbResponseBody {
	s.RequestId = &v
	return s
}

type BindK8sSlbResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *BindK8sSlbResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s BindK8sSlbResponse) String() string {
	return tea.Prettify(s)
}

func (s BindK8sSlbResponse) GoString() string {
	return s.String()
}

func (s *BindK8sSlbResponse) SetHeaders(v map[string]*string) *BindK8sSlbResponse {
	s.Headers = v
	return s
}

func (s *BindK8sSlbResponse) SetStatusCode(v int32) *BindK8sSlbResponse {
	s.StatusCode = &v
	return s
}

func (s *BindK8sSlbResponse) SetBody(v *BindK8sSlbResponseBody) *BindK8sSlbResponse {
	s.Body = v
	return s
}

type BindSlbRequest struct {
	// The ID of the EDAS application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The listener port for the SLB instance.
	ListenerPort *int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	// The ID of the SLB instance.
	SlbId *string `json:"SlbId,omitempty" xml:"SlbId,omitempty"`
	// The IP address of the SLB instance.
	SlbIp *string `json:"SlbIp,omitempty" xml:"SlbIp,omitempty"`
	// The type of the SLB instance. Valid values:
	//
	// *   internet: Internet-facing SLB instance
	// *   intranet: internal-facing SLB instance
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The ID of the vServer group for the internal-facing SLB instance.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
}

func (s BindSlbRequest) String() string {
	return tea.Prettify(s)
}

func (s BindSlbRequest) GoString() string {
	return s.String()
}

func (s *BindSlbRequest) SetAppId(v string) *BindSlbRequest {
	s.AppId = &v
	return s
}

func (s *BindSlbRequest) SetListenerPort(v int32) *BindSlbRequest {
	s.ListenerPort = &v
	return s
}

func (s *BindSlbRequest) SetSlbId(v string) *BindSlbRequest {
	s.SlbId = &v
	return s
}

func (s *BindSlbRequest) SetSlbIp(v string) *BindSlbRequest {
	s.SlbIp = &v
	return s
}

func (s *BindSlbRequest) SetType(v string) *BindSlbRequest {
	s.Type = &v
	return s
}

func (s *BindSlbRequest) SetVServerGroupId(v string) *BindSlbRequest {
	s.VServerGroupId = &v
	return s
}

type BindSlbResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data that is returned.
	Data *BindSlbResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BindSlbResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BindSlbResponseBody) GoString() string {
	return s.String()
}

func (s *BindSlbResponseBody) SetCode(v int32) *BindSlbResponseBody {
	s.Code = &v
	return s
}

func (s *BindSlbResponseBody) SetData(v *BindSlbResponseBodyData) *BindSlbResponseBody {
	s.Data = v
	return s
}

func (s *BindSlbResponseBody) SetMessage(v string) *BindSlbResponseBody {
	s.Message = &v
	return s
}

func (s *BindSlbResponseBody) SetRequestId(v string) *BindSlbResponseBody {
	s.RequestId = &v
	return s
}

type BindSlbResponseBodyData struct {
	// The ID of the Internet-facing SLB instance.
	ExtSlbId *string `json:"ExtSlbId,omitempty" xml:"ExtSlbId,omitempty"`
	// The IP address of the Internet-facing SLB instance.
	ExtSlbIp *string `json:"ExtSlbIp,omitempty" xml:"ExtSlbIp,omitempty"`
	// The name of the Internet-facing SLB instance.
	ExtSlbName *string `json:"ExtSlbName,omitempty" xml:"ExtSlbName,omitempty"`
	// The ID of the vServer group for the Internet-facing SLB instance.
	ExtVServerGroupId *string `json:"ExtVServerGroupId,omitempty" xml:"ExtVServerGroupId,omitempty"`
	// The ID of the internal-facing SLB instance.
	SlbId *string `json:"SlbId,omitempty" xml:"SlbId,omitempty"`
	// The IP address of the internal-facing SLB instance.
	SlbIp *string `json:"SlbIp,omitempty" xml:"SlbIp,omitempty"`
	// The name of the internal-facing SLB instance.
	SlbName *string `json:"SlbName,omitempty" xml:"SlbName,omitempty"`
	// The listener port for the SLB instance.
	SlbPort *int32 `json:"SlbPort,omitempty" xml:"SlbPort,omitempty"`
	// The ID of the vServer group for the internal-facing SLB instance.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
}

func (s BindSlbResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s BindSlbResponseBodyData) GoString() string {
	return s.String()
}

func (s *BindSlbResponseBodyData) SetExtSlbId(v string) *BindSlbResponseBodyData {
	s.ExtSlbId = &v
	return s
}

func (s *BindSlbResponseBodyData) SetExtSlbIp(v string) *BindSlbResponseBodyData {
	s.ExtSlbIp = &v
	return s
}

func (s *BindSlbResponseBodyData) SetExtSlbName(v string) *BindSlbResponseBodyData {
	s.ExtSlbName = &v
	return s
}

func (s *BindSlbResponseBodyData) SetExtVServerGroupId(v string) *BindSlbResponseBodyData {
	s.ExtVServerGroupId = &v
	return s
}

func (s *BindSlbResponseBodyData) SetSlbId(v string) *BindSlbResponseBodyData {
	s.SlbId = &v
	return s
}

func (s *BindSlbResponseBodyData) SetSlbIp(v string) *BindSlbResponseBodyData {
	s.SlbIp = &v
	return s
}

func (s *BindSlbResponseBodyData) SetSlbName(v string) *BindSlbResponseBodyData {
	s.SlbName = &v
	return s
}

func (s *BindSlbResponseBodyData) SetSlbPort(v int32) *BindSlbResponseBodyData {
	s.SlbPort = &v
	return s
}

func (s *BindSlbResponseBodyData) SetVServerGroupId(v string) *BindSlbResponseBodyData {
	s.VServerGroupId = &v
	return s
}

type BindSlbResponse struct {
	Headers    map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *BindSlbResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s BindSlbResponse) String() string {
	return tea.Prettify(s)
}

func (s BindSlbResponse) GoString() string {
	return s.String()
}

func (s *BindSlbResponse) SetHeaders(v map[string]*string) *BindSlbResponse {
	s.Headers = v
	return s
}

func (s *BindSlbResponse) SetStatusCode(v int32) *BindSlbResponse {
	s.StatusCode = &v
	return s
}

func (s *BindSlbResponse) SetBody(v *BindSlbResponseBody) *BindSlbResponse {
	s.Body = v
	return s
}

type ChangeDeployGroupRequest struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the elastic compute component (ECC) that corresponds to the ECS instance for which you want to change the application instance group. You can call the ListApplicationEcc operation to query the ECC ID. For more information, see [ListApplicationEcc](~~199277~~).
	//
	// > You can change the application instance group for only one ECS instance at a time.
	EccInfo *string `json:"EccInfo,omitempty" xml:"EccInfo,omitempty"`
	// Specifies whether to forcibly change the application instance group if the deployment package version of the ECC is different from that of the application instance group.
	ForceStatus *bool `json:"ForceStatus,omitempty" xml:"ForceStatus,omitempty"`
	// The name of the application instance group. Examples: group_a and group_b. The parameter value for the default application instance group is `_DEFAULT_GROUP`. The name can be up to 64 characters in length.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
}

func (s ChangeDeployGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s ChangeDeployGroupRequest) GoString() string {
	return s.String()
}

func (s *ChangeDeployGroupRequest) SetAppId(v string) *ChangeDeployGroupRequest {
	s.AppId = &v
	return s
}

func (s *ChangeDeployGroupRequest) SetEccInfo(v string) *ChangeDeployGroupRequest {
	s.EccInfo = &v
	return s
}

func (s *ChangeDeployGroupRequest) SetForceStatus(v bool) *ChangeDeployGroupRequest {
	s.ForceStatus = &v
	return s
}

func (s *ChangeDeployGroupRequest) SetGroupName(v string) *ChangeDeployGroupRequest {
	s.GroupName = &v
	return s
}

type ChangeDeployGroupResponseBody struct {
	// The ID of the change process.
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ChangeDeployGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ChangeDeployGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ChangeDeployGroupResponseBody) SetChangeOrderId(v string) *ChangeDeployGroupResponseBody {
	s.ChangeOrderId = &v
	return s
}

func (s *ChangeDeployGroupResponseBody) SetCode(v int32) *ChangeDeployGroupResponseBody {
	s.Code = &v
	return s
}

func (s *ChangeDeployGroupResponseBody) SetMessage(v string) *ChangeDeployGroupResponseBody {
	s.Message = &v
	return s
}

func (s *ChangeDeployGroupResponseBody) SetRequestId(v string) *ChangeDeployGroupResponseBody {
	s.RequestId = &v
	return s
}

type ChangeDeployGroupResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ChangeDeployGroupResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ChangeDeployGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ChangeDeployGroupResponse) GoString() string {
	return s.String()
}

func (s *ChangeDeployGroupResponse) SetHeaders(v map[string]*string) *ChangeDeployGroupResponse {
	s.Headers = v
	return s
}

func (s *ChangeDeployGroupResponse) SetStatusCode(v int32) *ChangeDeployGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ChangeDeployGroupResponse) SetBody(v *ChangeDeployGroupResponseBody) *ChangeDeployGroupResponse {
	s.Body = v
	return s
}

type ContinuePipelineRequest struct {
	// Specifies whether to release the next batch. Valid values:
	//
	// *   true: releases the next batch.
	// *   false: does not release the next batch.
	Confirm *bool `json:"Confirm,omitempty" xml:"Confirm,omitempty"`
	// The ID of the change process. You can call the GetChangeOrderInfo operation to query the ID of the change process that corresponds to a specific batch. For more information, see [GetChangeOrderInfo](~~62072~~).
	PipelineId *string `json:"PipelineId,omitempty" xml:"PipelineId,omitempty"`
}

func (s ContinuePipelineRequest) String() string {
	return tea.Prettify(s)
}

func (s ContinuePipelineRequest) GoString() string {
	return s.String()
}

func (s *ContinuePipelineRequest) SetConfirm(v bool) *ContinuePipelineRequest {
	s.Confirm = &v
	return s
}

func (s *ContinuePipelineRequest) SetPipelineId(v string) *ContinuePipelineRequest {
	s.PipelineId = &v
	return s
}

type ContinuePipelineResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ContinuePipelineResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ContinuePipelineResponseBody) GoString() string {
	return s.String()
}

func (s *ContinuePipelineResponseBody) SetCode(v int32) *ContinuePipelineResponseBody {
	s.Code = &v
	return s
}

func (s *ContinuePipelineResponseBody) SetMessage(v string) *ContinuePipelineResponseBody {
	s.Message = &v
	return s
}

func (s *ContinuePipelineResponseBody) SetRequestId(v string) *ContinuePipelineResponseBody {
	s.RequestId = &v
	return s
}

type ContinuePipelineResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ContinuePipelineResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ContinuePipelineResponse) String() string {
	return tea.Prettify(s)
}

func (s ContinuePipelineResponse) GoString() string {
	return s.String()
}

func (s *ContinuePipelineResponse) SetHeaders(v map[string]*string) *ContinuePipelineResponse {
	s.Headers = v
	return s
}

func (s *ContinuePipelineResponse) SetStatusCode(v int32) *ContinuePipelineResponse {
	s.StatusCode = &v
	return s
}

func (s *ContinuePipelineResponse) SetBody(v *ContinuePipelineResponseBody) *ContinuePipelineResponse {
	s.Body = v
	return s
}

type ConvertK8sResourceRequest struct {
	// The ID of the cluster. You can call the ListCluster operation to query the cluster ID. For more information, see [ListCluster](~~154995~~).
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The namespace.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The name of the resource.
	ResourceName *string `json:"ResourceName,omitempty" xml:"ResourceName,omitempty"`
	// The type of the resource that is used. Set the value to deployment.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s ConvertK8sResourceRequest) String() string {
	return tea.Prettify(s)
}

func (s ConvertK8sResourceRequest) GoString() string {
	return s.String()
}

func (s *ConvertK8sResourceRequest) SetClusterId(v string) *ConvertK8sResourceRequest {
	s.ClusterId = &v
	return s
}

func (s *ConvertK8sResourceRequest) SetNamespace(v string) *ConvertK8sResourceRequest {
	s.Namespace = &v
	return s
}

func (s *ConvertK8sResourceRequest) SetResourceName(v string) *ConvertK8sResourceRequest {
	s.ResourceName = &v
	return s
}

func (s *ConvertK8sResourceRequest) SetResourceType(v string) *ConvertK8sResourceRequest {
	s.ResourceType = &v
	return s
}

type ConvertK8sResourceResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ConvertK8sResourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ConvertK8sResourceResponseBody) GoString() string {
	return s.String()
}

func (s *ConvertK8sResourceResponseBody) SetCode(v int32) *ConvertK8sResourceResponseBody {
	s.Code = &v
	return s
}

func (s *ConvertK8sResourceResponseBody) SetMessage(v string) *ConvertK8sResourceResponseBody {
	s.Message = &v
	return s
}

func (s *ConvertK8sResourceResponseBody) SetRequestId(v string) *ConvertK8sResourceResponseBody {
	s.RequestId = &v
	return s
}

type ConvertK8sResourceResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ConvertK8sResourceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ConvertK8sResourceResponse) String() string {
	return tea.Prettify(s)
}

func (s ConvertK8sResourceResponse) GoString() string {
	return s.String()
}

func (s *ConvertK8sResourceResponse) SetHeaders(v map[string]*string) *ConvertK8sResourceResponse {
	s.Headers = v
	return s
}

func (s *ConvertK8sResourceResponse) SetStatusCode(v int32) *ConvertK8sResourceResponse {
	s.StatusCode = &v
	return s
}

func (s *ConvertK8sResourceResponse) SetBody(v *ConvertK8sResourceResponseBody) *ConvertK8sResourceResponse {
	s.Body = v
	return s
}

type CreateApplicationScalingRuleRequest struct {
	// The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplicationlink](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// Configure custom elastic behavior, refer to the example for specific data structure.
	ScalingBehaviour *string `json:"ScalingBehaviour,omitempty" xml:"ScalingBehaviour,omitempty"`
	// Specifies whether to enable the auto scaling policy. Valid values:
	//
	// *   **true**: enables the auto scaling policy.
	// *   **false**: disables the auto scaling policy.
	ScalingRuleEnable *bool `json:"ScalingRuleEnable,omitempty" xml:"ScalingRuleEnable,omitempty"`
	// This parameter is deprecated.
	ScalingRuleMetric *string `json:"ScalingRuleMetric,omitempty" xml:"ScalingRuleMetric,omitempty"`
	// The name of the auto scaling policy. The name must start with a lowercase letter, and can contain lowercase letters, digits, and hyphens (-). The name must be 1 to 32 characters in length.
	ScalingRuleName *string `json:"ScalingRuleName,omitempty" xml:"ScalingRuleName,omitempty"`
	// This parameter is deprecated.
	ScalingRuleTimer *string `json:"ScalingRuleTimer,omitempty" xml:"ScalingRuleTimer,omitempty"`
	// The trigger policy for the auto scaling policy. Set the value in the JSON format by using the ScalingRuleTriggerDTO class. For more information, see Additional information about request parameters.
	ScalingRuleTrigger *string `json:"ScalingRuleTrigger,omitempty" xml:"ScalingRuleTrigger,omitempty"`
	// The type of the auto scaling policy. Set the value to **trigger**.
	ScalingRuleType *string `json:"ScalingRuleType,omitempty" xml:"ScalingRuleType,omitempty"`
}

func (s CreateApplicationScalingRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateApplicationScalingRuleRequest) GoString() string {
	return s.String()
}

func (s *CreateApplicationScalingRuleRequest) SetAppId(v string) *CreateApplicationScalingRuleRequest {
	s.AppId = &v
	return s
}

func (s *CreateApplicationScalingRuleRequest) SetScalingBehaviour(v string) *CreateApplicationScalingRuleRequest {
	s.ScalingBehaviour = &v
	return s
}

func (s *CreateApplicationScalingRuleRequest) SetScalingRuleEnable(v bool) *CreateApplicationScalingRuleRequest {
	s.ScalingRuleEnable = &v
	return s
}

func (s *CreateApplicationScalingRuleRequest) SetScalingRuleMetric(v string) *CreateApplicationScalingRuleRequest {
	s.ScalingRuleMetric = &v
	return s
}

func (s *CreateApplicationScalingRuleRequest) SetScalingRuleName(v string) *CreateApplicationScalingRuleRequest {
	s.ScalingRuleName = &v
	return s
}

func (s *CreateApplicationScalingRuleRequest) SetScalingRuleTimer(v string) *CreateApplicationScalingRuleRequest {
	s.ScalingRuleTimer = &v
	return s
}

func (s *CreateApplicationScalingRuleRequest) SetScalingRuleTrigger(v string) *CreateApplicationScalingRuleRequest {
	s.ScalingRuleTrigger = &v
	return s
}

func (s *CreateApplicationScalingRuleRequest) SetScalingRuleType(v string) *CreateApplicationScalingRuleRequest {
	s.ScalingRuleType = &v
	return s
}

type CreateApplicationScalingRuleResponseBody struct {
	// The information about the auto scaling policy.
	AppScalingRule *CreateApplicationScalingRuleResponseBodyAppScalingRule `json:"AppScalingRule,omitempty" xml:"AppScalingRule,omitempty" type:"Struct"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateApplicationScalingRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateApplicationScalingRuleResponseBody) GoString() string {
	return s.String()
}

func (s *CreateApplicationScalingRuleResponseBody) SetAppScalingRule(v *CreateApplicationScalingRuleResponseBodyAppScalingRule) *CreateApplicationScalingRuleResponseBody {
	s.AppScalingRule = v
	return s
}

func (s *CreateApplicationScalingRuleResponseBody) SetCode(v int32) *CreateApplicationScalingRuleResponseBody {
	s.Code = &v
	return s
}

func (s *CreateApplicationScalingRuleResponseBody) SetMessage(v string) *CreateApplicationScalingRuleResponseBody {
	s.Message = &v
	return s
}

func (s *CreateApplicationScalingRuleResponseBody) SetRequestId(v string) *CreateApplicationScalingRuleResponseBody {
	s.RequestId = &v
	return s
}

type CreateApplicationScalingRuleResponseBodyAppScalingRule struct {
	// The ID of the application to which the auto scaling policy belongs.
	AppId     *string                                                          `json:"AppId,omitempty" xml:"AppId,omitempty"`
	Behaviour *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour `json:"Behaviour,omitempty" xml:"Behaviour,omitempty" type:"Struct"`
	// The timestamp when the auto scaling policy was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The timestamp when the auto scaling policy was last disabled. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	LastDisableTime *int64 `json:"LastDisableTime,omitempty" xml:"LastDisableTime,omitempty"`
	// This parameter is deprecated.
	MaxReplicas *int32 `json:"MaxReplicas,omitempty" xml:"MaxReplicas,omitempty"`
	// This parameter is deprecated.
	Metric *CreateApplicationScalingRuleResponseBodyAppScalingRuleMetric `json:"Metric,omitempty" xml:"Metric,omitempty" type:"Struct"`
	// This parameter is deprecated.
	MinReplicas *int32 `json:"MinReplicas,omitempty" xml:"MinReplicas,omitempty"`
	// Indicates whether the auto scaling policy is enabled. Valid values:
	//
	// *   **true**: The auto scaling policy is enabled.
	// *   **false**: The auto scaling policy is disabled.
	ScaleRuleEnabled *bool `json:"ScaleRuleEnabled,omitempty" xml:"ScaleRuleEnabled,omitempty"`
	// The name of the auto scaling policy.
	ScaleRuleName *string `json:"ScaleRuleName,omitempty" xml:"ScaleRuleName,omitempty"`
	// The type of the auto scaling policy. The value is trigger.
	ScaleRuleType *string `json:"ScaleRuleType,omitempty" xml:"ScaleRuleType,omitempty"`
	// The configurations of the trigger.
	Trigger *CreateApplicationScalingRuleResponseBodyAppScalingRuleTrigger `json:"Trigger,omitempty" xml:"Trigger,omitempty" type:"Struct"`
	// The timestamp when the auto scaling policy was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s CreateApplicationScalingRuleResponseBodyAppScalingRule) String() string {
	return tea.Prettify(s)
}

func (s CreateApplicationScalingRuleResponseBodyAppScalingRule) GoString() string {
	return s.String()
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRule) SetAppId(v string) *CreateApplicationScalingRuleResponseBodyAppScalingRule {
	s.AppId = &v
	return s
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRule) SetBehaviour(v *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour) *CreateApplicationScalingRuleResponseBodyAppScalingRule {
	s.Behaviour = v
	return s
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRule) SetCreateTime(v int64) *CreateApplicationScalingRuleResponseBodyAppScalingRule {
	s.CreateTime = &v
	return s
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRule) SetLastDisableTime(v int64) *CreateApplicationScalingRuleResponseBodyAppScalingRule {
	s.LastDisableTime = &v
	return s
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRule) SetMaxReplicas(v int32) *CreateApplicationScalingRuleResponseBodyAppScalingRule {
	s.MaxReplicas = &v
	return s
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRule) SetMetric(v *CreateApplicationScalingRuleResponseBodyAppScalingRuleMetric) *CreateApplicationScalingRuleResponseBodyAppScalingRule {
	s.Metric = v
	return s
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRule) SetMinReplicas(v int32) *CreateApplicationScalingRuleResponseBodyAppScalingRule {
	s.MinReplicas = &v
	return s
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRule) SetScaleRuleEnabled(v bool) *CreateApplicationScalingRuleResponseBodyAppScalingRule {
	s.ScaleRuleEnabled = &v
	return s
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRule) SetScaleRuleName(v string) *CreateApplicationScalingRuleResponseBodyAppScalingRule {
	s.ScaleRuleName = &v
	return s
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRule) SetScaleRuleType(v string) *CreateApplicationScalingRuleResponseBodyAppScalingRule {
	s.ScaleRuleType = &v
	return s
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRule) SetTrigger(v *CreateApplicationScalingRuleResponseBodyAppScalingRuleTrigger) *CreateApplicationScalingRuleResponseBodyAppScalingRule {
	s.Trigger = v
	return s
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRule) SetUpdateTime(v int64) *CreateApplicationScalingRuleResponseBodyAppScalingRule {
	s.UpdateTime = &v
	return s
}

type CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour struct {
	// 弹性缩容行为配置。
	ScaleDown *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown `json:"ScaleDown,omitempty" xml:"ScaleDown,omitempty" type:"Struct"`
	// 弹性扩容行为配置。
	ScaleUp *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp `json:"ScaleUp,omitempty" xml:"ScaleUp,omitempty" type:"Struct"`
}

func (s CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour) String() string {
	return tea.Prettify(s)
}

func (s CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour) GoString() string {
	return s.String()
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour) SetScaleDown(v *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown) *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour {
	s.ScaleDown = v
	return s
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour) SetScaleUp(v *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp) *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour {
	s.ScaleUp = v
	return s
}

type CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown struct {
	// 策略配置。
	Policies []*CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies `json:"Policies,omitempty" xml:"Policies,omitempty" type:"Repeated"`
	// 弹性缩容步长策略，可选值Max、Min、Disable。
	SelectPolicy *string `json:"SelectPolicy,omitempty" xml:"SelectPolicy,omitempty"`
	// 缩容冷却时间。取值范围[0, 3600]，单位为秒。默认为300秒。
	StabilizationWindowSeconds *int32 `json:"StabilizationWindowSeconds,omitempty" xml:"StabilizationWindowSeconds,omitempty"`
}

func (s CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown) String() string {
	return tea.Prettify(s)
}

func (s CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown) GoString() string {
	return s.String()
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown) SetPolicies(v []*CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies) *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown {
	s.Policies = v
	return s
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown) SetSelectPolicy(v string) *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown {
	s.SelectPolicy = &v
	return s
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown) SetStabilizationWindowSeconds(v int32) *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown {
	s.StabilizationWindowSeconds = &v
	return s
}

type CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies struct {
	// 检查执行的周期，取值范围[0, 1800]，单位为秒。
	PeriodSeconds *int32 `json:"PeriodSeconds,omitempty" xml:"PeriodSeconds,omitempty"`
	// 策略类型，可为Pods或Percent。
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// 弹性行为的策略值，大于零的整数。若策略类型为Pods，则该值表示Pods数量；若策略类型为Percent，则该值表示百分比，允许超过100%。
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies) String() string {
	return tea.Prettify(s)
}

func (s CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies) GoString() string {
	return s.String()
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies) SetPeriodSeconds(v int32) *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies {
	s.PeriodSeconds = &v
	return s
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies) SetType(v string) *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies {
	s.Type = &v
	return s
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies) SetValue(v string) *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies {
	s.Value = &v
	return s
}

type CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp struct {
	// 策略配置。
	Policies []*CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies `json:"Policies,omitempty" xml:"Policies,omitempty" type:"Repeated"`
	// 弹性扩容步长策略，可选值Max、Min、Disable。
	SelectPolicy *string `json:"SelectPolicy,omitempty" xml:"SelectPolicy,omitempty"`
	// 扩容冷却时间。取值范围[0, 3600]，单位为秒。默认为0秒。
	StabilizationWindowSeconds *int32 `json:"StabilizationWindowSeconds,omitempty" xml:"StabilizationWindowSeconds,omitempty"`
}

func (s CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp) String() string {
	return tea.Prettify(s)
}

func (s CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp) GoString() string {
	return s.String()
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp) SetPolicies(v []*CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies) *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp {
	s.Policies = v
	return s
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp) SetSelectPolicy(v string) *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp {
	s.SelectPolicy = &v
	return s
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp) SetStabilizationWindowSeconds(v int32) *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp {
	s.StabilizationWindowSeconds = &v
	return s
}

type CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies struct {
	// 检查执行的周期，取值范围[0, 1800]，单位为秒。
	PeriodSeconds *int32 `json:"PeriodSeconds,omitempty" xml:"PeriodSeconds,omitempty"`
	// 策略类型，可为Pods或Percent。
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// 弹性行为的策略值，大于零的整数。若策略类型为Pods，则该值表示Pods数量；若策略类型为Percent，则该值表示百分比，允许超过100%。
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies) String() string {
	return tea.Prettify(s)
}

func (s CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies) GoString() string {
	return s.String()
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies) SetPeriodSeconds(v int32) *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies {
	s.PeriodSeconds = &v
	return s
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies) SetType(v string) *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies {
	s.Type = &v
	return s
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies) SetValue(v string) *CreateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies {
	s.Value = &v
	return s
}

type CreateApplicationScalingRuleResponseBodyAppScalingRuleMetric struct {
	// This parameter is deprecated.
	MaxReplicas *int32 `json:"MaxReplicas,omitempty" xml:"MaxReplicas,omitempty"`
	// This parameter is deprecated.
	Metrics []*CreateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics `json:"Metrics,omitempty" xml:"Metrics,omitempty" type:"Repeated"`
	// This parameter is deprecated.
	MinReplicas *int32 `json:"MinReplicas,omitempty" xml:"MinReplicas,omitempty"`
}

func (s CreateApplicationScalingRuleResponseBodyAppScalingRuleMetric) String() string {
	return tea.Prettify(s)
}

func (s CreateApplicationScalingRuleResponseBodyAppScalingRuleMetric) GoString() string {
	return s.String()
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRuleMetric) SetMaxReplicas(v int32) *CreateApplicationScalingRuleResponseBodyAppScalingRuleMetric {
	s.MaxReplicas = &v
	return s
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRuleMetric) SetMetrics(v []*CreateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics) *CreateApplicationScalingRuleResponseBodyAppScalingRuleMetric {
	s.Metrics = v
	return s
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRuleMetric) SetMinReplicas(v int32) *CreateApplicationScalingRuleResponseBodyAppScalingRuleMetric {
	s.MinReplicas = &v
	return s
}

type CreateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics struct {
	// This parameter is deprecated.
	MetricTargetAverageUtilization *int32 `json:"MetricTargetAverageUtilization,omitempty" xml:"MetricTargetAverageUtilization,omitempty"`
	// This parameter is deprecated.
	MetricType *string `json:"MetricType,omitempty" xml:"MetricType,omitempty"`
}

func (s CreateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics) String() string {
	return tea.Prettify(s)
}

func (s CreateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics) GoString() string {
	return s.String()
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics) SetMetricTargetAverageUtilization(v int32) *CreateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics {
	s.MetricTargetAverageUtilization = &v
	return s
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics) SetMetricType(v string) *CreateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics {
	s.MetricType = &v
	return s
}

type CreateApplicationScalingRuleResponseBodyAppScalingRuleTrigger struct {
	// The maximum number of replicas. The maximum value is 1000.
	MaxReplicas *int32 `json:"MaxReplicas,omitempty" xml:"MaxReplicas,omitempty"`
	// The minimum number of replicas. The minimum value is 0.
	MinReplicas *int32 `json:"MinReplicas,omitempty" xml:"MinReplicas,omitempty"`
	// The list of triggers.
	Triggers []*CreateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers `json:"Triggers,omitempty" xml:"Triggers,omitempty" type:"Repeated"`
}

func (s CreateApplicationScalingRuleResponseBodyAppScalingRuleTrigger) String() string {
	return tea.Prettify(s)
}

func (s CreateApplicationScalingRuleResponseBodyAppScalingRuleTrigger) GoString() string {
	return s.String()
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRuleTrigger) SetMaxReplicas(v int32) *CreateApplicationScalingRuleResponseBodyAppScalingRuleTrigger {
	s.MaxReplicas = &v
	return s
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRuleTrigger) SetMinReplicas(v int32) *CreateApplicationScalingRuleResponseBodyAppScalingRuleTrigger {
	s.MinReplicas = &v
	return s
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRuleTrigger) SetTriggers(v []*CreateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers) *CreateApplicationScalingRuleResponseBodyAppScalingRuleTrigger {
	s.Triggers = v
	return s
}

type CreateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers struct {
	// The metadata of the trigger.
	MetaData *string `json:"MetaData,omitempty" xml:"MetaData,omitempty"`
	// The name of the trigger.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of the trigger. Valid values: cron and app_metric.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers) String() string {
	return tea.Prettify(s)
}

func (s CreateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers) GoString() string {
	return s.String()
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers) SetMetaData(v string) *CreateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers {
	s.MetaData = &v
	return s
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers) SetName(v string) *CreateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers {
	s.Name = &v
	return s
}

func (s *CreateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers) SetType(v string) *CreateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers {
	s.Type = &v
	return s
}

type CreateApplicationScalingRuleResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateApplicationScalingRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateApplicationScalingRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateApplicationScalingRuleResponse) GoString() string {
	return s.String()
}

func (s *CreateApplicationScalingRuleResponse) SetHeaders(v map[string]*string) *CreateApplicationScalingRuleResponse {
	s.Headers = v
	return s
}

func (s *CreateApplicationScalingRuleResponse) SetStatusCode(v int32) *CreateApplicationScalingRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateApplicationScalingRuleResponse) SetBody(v *CreateApplicationScalingRuleResponseBody) *CreateApplicationScalingRuleResponse {
	s.Body = v
	return s
}

type CreateConfigTemplateRequest struct {
	// The content of the configuration template. The value must be in the format that is specified by the Format parameter.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The description of the configuration template. The description can be up to 255 characters in length.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The data format of the configuration template. Valid values:
	//
	// *   JSON: JSON format
	// *   XML: XML format
	// *   YAML: YAML format
	// *   Properties: .properties format
	// *   KeyValue: key-value pairs
	// *   Custom: custom format
	Format *string `json:"Format,omitempty" xml:"Format,omitempty"`
	// The name of the configuration template. The name can be up to 64 characters in length.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s CreateConfigTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateConfigTemplateRequest) GoString() string {
	return s.String()
}

func (s *CreateConfigTemplateRequest) SetContent(v string) *CreateConfigTemplateRequest {
	s.Content = &v
	return s
}

func (s *CreateConfigTemplateRequest) SetDescription(v string) *CreateConfigTemplateRequest {
	s.Description = &v
	return s
}

func (s *CreateConfigTemplateRequest) SetFormat(v string) *CreateConfigTemplateRequest {
	s.Format = &v
	return s
}

func (s *CreateConfigTemplateRequest) SetName(v string) *CreateConfigTemplateRequest {
	s.Name = &v
	return s
}

type CreateConfigTemplateResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned.
	Data *CreateConfigTemplateResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateConfigTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateConfigTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *CreateConfigTemplateResponseBody) SetCode(v int32) *CreateConfigTemplateResponseBody {
	s.Code = &v
	return s
}

func (s *CreateConfigTemplateResponseBody) SetData(v *CreateConfigTemplateResponseBodyData) *CreateConfigTemplateResponseBody {
	s.Data = v
	return s
}

func (s *CreateConfigTemplateResponseBody) SetMessage(v string) *CreateConfigTemplateResponseBody {
	s.Message = &v
	return s
}

func (s *CreateConfigTemplateResponseBody) SetRequestId(v string) *CreateConfigTemplateResponseBody {
	s.RequestId = &v
	return s
}

type CreateConfigTemplateResponseBodyData struct {
	// The ID of the template.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s CreateConfigTemplateResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateConfigTemplateResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateConfigTemplateResponseBodyData) SetId(v int64) *CreateConfigTemplateResponseBodyData {
	s.Id = &v
	return s
}

type CreateConfigTemplateResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateConfigTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateConfigTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateConfigTemplateResponse) GoString() string {
	return s.String()
}

func (s *CreateConfigTemplateResponse) SetHeaders(v map[string]*string) *CreateConfigTemplateResponse {
	s.Headers = v
	return s
}

func (s *CreateConfigTemplateResponse) SetStatusCode(v int32) *CreateConfigTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateConfigTemplateResponse) SetBody(v *CreateConfigTemplateResponseBody) *CreateConfigTemplateResponse {
	s.Body = v
	return s
}

type CreateIDCImportCommandRequest struct {
	// The cluster ID. You can call the ListCluster operation to query the cluster ID. For more information, see [ListCluster](~~154995~~).
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
}

func (s CreateIDCImportCommandRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateIDCImportCommandRequest) GoString() string {
	return s.String()
}

func (s *CreateIDCImportCommandRequest) SetClusterId(v string) *CreateIDCImportCommandRequest {
	s.ClusterId = &v
	return s
}

type CreateIDCImportCommandResponseBody struct {
	// The HTTP status code.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The generated import command.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateIDCImportCommandResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateIDCImportCommandResponseBody) GoString() string {
	return s.String()
}

func (s *CreateIDCImportCommandResponseBody) SetCode(v string) *CreateIDCImportCommandResponseBody {
	s.Code = &v
	return s
}

func (s *CreateIDCImportCommandResponseBody) SetData(v string) *CreateIDCImportCommandResponseBody {
	s.Data = &v
	return s
}

func (s *CreateIDCImportCommandResponseBody) SetMessage(v string) *CreateIDCImportCommandResponseBody {
	s.Message = &v
	return s
}

func (s *CreateIDCImportCommandResponseBody) SetRequestId(v string) *CreateIDCImportCommandResponseBody {
	s.RequestId = &v
	return s
}

type CreateIDCImportCommandResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateIDCImportCommandResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateIDCImportCommandResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateIDCImportCommandResponse) GoString() string {
	return s.String()
}

func (s *CreateIDCImportCommandResponse) SetHeaders(v map[string]*string) *CreateIDCImportCommandResponse {
	s.Headers = v
	return s
}

func (s *CreateIDCImportCommandResponse) SetStatusCode(v int32) *CreateIDCImportCommandResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateIDCImportCommandResponse) SetBody(v *CreateIDCImportCommandResponseBody) *CreateIDCImportCommandResponse {
	s.Body = v
	return s
}

type CreateK8sConfigMapRequest struct {
	// The ID of the Kubernetes cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The data of the ConfigMap. The value must be a JSON array string.
	Data map[string]interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	// The name of the ConfigMap. The name must start with a letter, and can contain digits, letters, and hyphens (-). It can be up to 63 characters in length.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace of the Kubernetes cluster.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
}

func (s CreateK8sConfigMapRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateK8sConfigMapRequest) GoString() string {
	return s.String()
}

func (s *CreateK8sConfigMapRequest) SetClusterId(v string) *CreateK8sConfigMapRequest {
	s.ClusterId = &v
	return s
}

func (s *CreateK8sConfigMapRequest) SetData(v map[string]interface{}) *CreateK8sConfigMapRequest {
	s.Data = v
	return s
}

func (s *CreateK8sConfigMapRequest) SetName(v string) *CreateK8sConfigMapRequest {
	s.Name = &v
	return s
}

func (s *CreateK8sConfigMapRequest) SetNamespace(v string) *CreateK8sConfigMapRequest {
	s.Namespace = &v
	return s
}

type CreateK8sConfigMapResponseBody struct {
	// The HTTP status code.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateK8sConfigMapResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateK8sConfigMapResponseBody) GoString() string {
	return s.String()
}

func (s *CreateK8sConfigMapResponseBody) SetCode(v int32) *CreateK8sConfigMapResponseBody {
	s.Code = &v
	return s
}

func (s *CreateK8sConfigMapResponseBody) SetMessage(v string) *CreateK8sConfigMapResponseBody {
	s.Message = &v
	return s
}

func (s *CreateK8sConfigMapResponseBody) SetRequestId(v string) *CreateK8sConfigMapResponseBody {
	s.RequestId = &v
	return s
}

type CreateK8sConfigMapResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateK8sConfigMapResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateK8sConfigMapResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateK8sConfigMapResponse) GoString() string {
	return s.String()
}

func (s *CreateK8sConfigMapResponse) SetHeaders(v map[string]*string) *CreateK8sConfigMapResponse {
	s.Headers = v
	return s
}

func (s *CreateK8sConfigMapResponse) SetStatusCode(v int32) *CreateK8sConfigMapResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateK8sConfigMapResponse) SetBody(v *CreateK8sConfigMapResponseBody) *CreateK8sConfigMapResponse {
	s.Body = v
	return s
}

type CreateK8sIngressRuleRequest struct {
	// The annotations.
	Annotations *string `json:"Annotations,omitempty" xml:"Annotations,omitempty"`
	// The ID of the Kubernetes cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The routing rules of the Ingress. Set this parameter to a JSON string in the following format:
	//
	//     {
	//       "rules": [
	//         {
	//           "host": "abc.com",
	//           "secretName": "tls-secret",
	//           "paths": [
	//             {
	//               "path": "/path",
	//               "backend": {
	//                 "servicePort": 80,
	//                 "serviceName": "xxx"
	//               }
	//             }
	//           ]
	//         }
	//       ]
	//     }
	//
	// Parameter description:
	//
	// *   rules: the list of routing rules.
	// *   host: the domain name to be accessed.
	// *   secretName: the name of the Secret that stores the information about the Transport Layer Security (TLS) certificate. The certificate is required if you need to use the HTTPS protocol.
	// *   paths: the list of paths to be accessed.
	// *   path: the path to be accessed.
	// *   backend: the configuration of the backend service. You can specify a service that is created in the Enterprise Distributed Application Service (EDAS) console.
	// *   serviceName: the name of the backend service.
	// *   servicePort: the port of the backend service.
	IngressConf map[string]interface{} `json:"IngressConf,omitempty" xml:"IngressConf,omitempty"`
	// The labels.
	Labels *string `json:"Labels,omitempty" xml:"Labels,omitempty"`
	// The name of the Ingress. The name can contain lowercase letters, digits, and hyphens (-). It must start with a lowercase letter but cannot end with a hyphen (-). The name can be up to 63 characters in length.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace of the Kubernetes cluster.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
}

func (s CreateK8sIngressRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateK8sIngressRuleRequest) GoString() string {
	return s.String()
}

func (s *CreateK8sIngressRuleRequest) SetAnnotations(v string) *CreateK8sIngressRuleRequest {
	s.Annotations = &v
	return s
}

func (s *CreateK8sIngressRuleRequest) SetClusterId(v string) *CreateK8sIngressRuleRequest {
	s.ClusterId = &v
	return s
}

func (s *CreateK8sIngressRuleRequest) SetIngressConf(v map[string]interface{}) *CreateK8sIngressRuleRequest {
	s.IngressConf = v
	return s
}

func (s *CreateK8sIngressRuleRequest) SetLabels(v string) *CreateK8sIngressRuleRequest {
	s.Labels = &v
	return s
}

func (s *CreateK8sIngressRuleRequest) SetName(v string) *CreateK8sIngressRuleRequest {
	s.Name = &v
	return s
}

func (s *CreateK8sIngressRuleRequest) SetNamespace(v string) *CreateK8sIngressRuleRequest {
	s.Namespace = &v
	return s
}

type CreateK8sIngressRuleResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
}

func (s CreateK8sIngressRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateK8sIngressRuleResponseBody) GoString() string {
	return s.String()
}

func (s *CreateK8sIngressRuleResponseBody) SetCode(v int32) *CreateK8sIngressRuleResponseBody {
	s.Code = &v
	return s
}

func (s *CreateK8sIngressRuleResponseBody) SetMessage(v string) *CreateK8sIngressRuleResponseBody {
	s.Message = &v
	return s
}

type CreateK8sIngressRuleResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateK8sIngressRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateK8sIngressRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateK8sIngressRuleResponse) GoString() string {
	return s.String()
}

func (s *CreateK8sIngressRuleResponse) SetHeaders(v map[string]*string) *CreateK8sIngressRuleResponse {
	s.Headers = v
	return s
}

func (s *CreateK8sIngressRuleResponse) SetStatusCode(v int32) *CreateK8sIngressRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateK8sIngressRuleResponse) SetBody(v *CreateK8sIngressRuleResponseBody) *CreateK8sIngressRuleResponse {
	s.Body = v
	return s
}

type CreateK8sSecretRequest struct {
	// Specifies whether the data has been encoded in Base64. Valid values: true and false.
	Base64Encoded *bool `json:"Base64Encoded,omitempty" xml:"Base64Encoded,omitempty"`
	// The certificate ID provided by Alibaba Cloud Certificate Management Service.
	CertId *string `json:"CertId,omitempty" xml:"CertId,omitempty"`
	// The region in which the certificate is stored.
	CertRegionId *string `json:"CertRegionId,omitempty" xml:"CertRegionId,omitempty"`
	// The cluster ID.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The data of the Secret. The value must be a JSON array that contains the following information:
	//
	// *   Key: Secret key
	// *   Value: Secret value
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The name of the Secret. The name must start with a letter, and can contain digits, letters, and hyphens (-). It can be up to 63 characters in length.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace of the Kubernetes cluster.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The Secret type. Valid values:
	//
	// *   Opaque: user-defined data
	// *   kubernetes.io/tls: Transport Layer Security (TLS) certificate
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateK8sSecretRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateK8sSecretRequest) GoString() string {
	return s.String()
}

func (s *CreateK8sSecretRequest) SetBase64Encoded(v bool) *CreateK8sSecretRequest {
	s.Base64Encoded = &v
	return s
}

func (s *CreateK8sSecretRequest) SetCertId(v string) *CreateK8sSecretRequest {
	s.CertId = &v
	return s
}

func (s *CreateK8sSecretRequest) SetCertRegionId(v string) *CreateK8sSecretRequest {
	s.CertRegionId = &v
	return s
}

func (s *CreateK8sSecretRequest) SetClusterId(v string) *CreateK8sSecretRequest {
	s.ClusterId = &v
	return s
}

func (s *CreateK8sSecretRequest) SetData(v string) *CreateK8sSecretRequest {
	s.Data = &v
	return s
}

func (s *CreateK8sSecretRequest) SetName(v string) *CreateK8sSecretRequest {
	s.Name = &v
	return s
}

func (s *CreateK8sSecretRequest) SetNamespace(v string) *CreateK8sSecretRequest {
	s.Namespace = &v
	return s
}

func (s *CreateK8sSecretRequest) SetType(v string) *CreateK8sSecretRequest {
	s.Type = &v
	return s
}

type CreateK8sSecretResponseBody struct {
	// The HTTP status code.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateK8sSecretResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateK8sSecretResponseBody) GoString() string {
	return s.String()
}

func (s *CreateK8sSecretResponseBody) SetCode(v int32) *CreateK8sSecretResponseBody {
	s.Code = &v
	return s
}

func (s *CreateK8sSecretResponseBody) SetMessage(v string) *CreateK8sSecretResponseBody {
	s.Message = &v
	return s
}

func (s *CreateK8sSecretResponseBody) SetRequestId(v string) *CreateK8sSecretResponseBody {
	s.RequestId = &v
	return s
}

type CreateK8sSecretResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateK8sSecretResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateK8sSecretResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateK8sSecretResponse) GoString() string {
	return s.String()
}

func (s *CreateK8sSecretResponse) SetHeaders(v map[string]*string) *CreateK8sSecretResponse {
	s.Headers = v
	return s
}

func (s *CreateK8sSecretResponse) SetStatusCode(v int32) *CreateK8sSecretResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateK8sSecretResponse) SetBody(v *CreateK8sSecretResponseBody) *CreateK8sSecretResponse {
	s.Body = v
	return s
}

type CreateK8sServiceRequest struct {
	// The application ID.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The policy used for external traffic management. Valid values:
	//
	// *   Local: The network traffic can be routed to pods on the node where the Service is deployed.
	// *   Cluster: The network traffic can be routed to pods on other nodes in the cluster.
	//
	// Default value: Local.
	ExternalTrafficPolicy *string `json:"ExternalTrafficPolicy,omitempty" xml:"ExternalTrafficPolicy,omitempty"`
	// The name of the Kubernetes Service.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The port mapping of the Kubernetes Service. Set this parameter to a JSON array. The following parameters are included in the configurations:
	//
	// *   **protocol**: the protocol used by the Service. Valid values: TCP and UDP. This parameter is mandatory.
	// *   **port**: the frontend service port. Valid values: 1 to 65535. This parameter is mandatory.
	// *   **targetPort**: the backend container port. Valid values: 1 to 65535. This parameter is mandatory.
	//
	// Example: `[{"protocol": "TCP", "port": 80, "targetPort": 8080},{"protocol": "TCP", "port": 81, "targetPort": 8081}]`
	ServicePorts map[string]interface{} `json:"ServicePorts,omitempty" xml:"ServicePorts,omitempty"`
	// The type of the Kubernetes Service. Set the value to ClusterIP.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateK8sServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateK8sServiceRequest) GoString() string {
	return s.String()
}

func (s *CreateK8sServiceRequest) SetAppId(v string) *CreateK8sServiceRequest {
	s.AppId = &v
	return s
}

func (s *CreateK8sServiceRequest) SetExternalTrafficPolicy(v string) *CreateK8sServiceRequest {
	s.ExternalTrafficPolicy = &v
	return s
}

func (s *CreateK8sServiceRequest) SetName(v string) *CreateK8sServiceRequest {
	s.Name = &v
	return s
}

func (s *CreateK8sServiceRequest) SetServicePorts(v map[string]interface{}) *CreateK8sServiceRequest {
	s.ServicePorts = v
	return s
}

func (s *CreateK8sServiceRequest) SetType(v string) *CreateK8sServiceRequest {
	s.Type = &v
	return s
}

type CreateK8sServiceResponseBody struct {
	// The change process ID.
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	// The HTTP status code.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateK8sServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateK8sServiceResponseBody) GoString() string {
	return s.String()
}

func (s *CreateK8sServiceResponseBody) SetChangeOrderId(v string) *CreateK8sServiceResponseBody {
	s.ChangeOrderId = &v
	return s
}

func (s *CreateK8sServiceResponseBody) SetCode(v int32) *CreateK8sServiceResponseBody {
	s.Code = &v
	return s
}

func (s *CreateK8sServiceResponseBody) SetMessage(v string) *CreateK8sServiceResponseBody {
	s.Message = &v
	return s
}

func (s *CreateK8sServiceResponseBody) SetRequestId(v string) *CreateK8sServiceResponseBody {
	s.RequestId = &v
	return s
}

type CreateK8sServiceResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateK8sServiceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateK8sServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateK8sServiceResponse) GoString() string {
	return s.String()
}

func (s *CreateK8sServiceResponse) SetHeaders(v map[string]*string) *CreateK8sServiceResponse {
	s.Headers = v
	return s
}

func (s *CreateK8sServiceResponse) SetStatusCode(v int32) *CreateK8sServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateK8sServiceResponse) SetBody(v *CreateK8sServiceResponseBody) *CreateK8sServiceResponse {
	s.Body = v
	return s
}

type DeleteApplicationRequest struct {
	// The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
}

func (s DeleteApplicationRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteApplicationRequest) GoString() string {
	return s.String()
}

func (s *DeleteApplicationRequest) SetAppId(v string) *DeleteApplicationRequest {
	s.AppId = &v
	return s
}

type DeleteApplicationResponseBody struct {
	// The ID of the change process.
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteApplicationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteApplicationResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteApplicationResponseBody) SetChangeOrderId(v string) *DeleteApplicationResponseBody {
	s.ChangeOrderId = &v
	return s
}

func (s *DeleteApplicationResponseBody) SetCode(v int32) *DeleteApplicationResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteApplicationResponseBody) SetMessage(v string) *DeleteApplicationResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteApplicationResponseBody) SetRequestId(v string) *DeleteApplicationResponseBody {
	s.RequestId = &v
	return s
}

type DeleteApplicationResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteApplicationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteApplicationResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteApplicationResponse) GoString() string {
	return s.String()
}

func (s *DeleteApplicationResponse) SetHeaders(v map[string]*string) *DeleteApplicationResponse {
	s.Headers = v
	return s
}

func (s *DeleteApplicationResponse) SetStatusCode(v int32) *DeleteApplicationResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteApplicationResponse) SetBody(v *DeleteApplicationResponseBody) *DeleteApplicationResponse {
	s.Body = v
	return s
}

type DeleteApplicationScalingRuleRequest struct {
	// The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the auto scaling policy.
	ScalingRuleName *string `json:"ScalingRuleName,omitempty" xml:"ScalingRuleName,omitempty"`
}

func (s DeleteApplicationScalingRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteApplicationScalingRuleRequest) GoString() string {
	return s.String()
}

func (s *DeleteApplicationScalingRuleRequest) SetAppId(v string) *DeleteApplicationScalingRuleRequest {
	s.AppId = &v
	return s
}

func (s *DeleteApplicationScalingRuleRequest) SetScalingRuleName(v string) *DeleteApplicationScalingRuleRequest {
	s.ScalingRuleName = &v
	return s
}

type DeleteApplicationScalingRuleResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteApplicationScalingRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteApplicationScalingRuleResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteApplicationScalingRuleResponseBody) SetRequestId(v string) *DeleteApplicationScalingRuleResponseBody {
	s.RequestId = &v
	return s
}

type DeleteApplicationScalingRuleResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteApplicationScalingRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteApplicationScalingRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteApplicationScalingRuleResponse) GoString() string {
	return s.String()
}

func (s *DeleteApplicationScalingRuleResponse) SetHeaders(v map[string]*string) *DeleteApplicationScalingRuleResponse {
	s.Headers = v
	return s
}

func (s *DeleteApplicationScalingRuleResponse) SetStatusCode(v int32) *DeleteApplicationScalingRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteApplicationScalingRuleResponse) SetBody(v *DeleteApplicationScalingRuleResponseBody) *DeleteApplicationScalingRuleResponse {
	s.Body = v
	return s
}

type DeleteClusterRequest struct {
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The type of the cluster ID. Valid values:
	//
	// *   0: specifies the ID of the cluster in Enterprise Distributed Application Service (EDAS).
	// *   1: specifies the ID of the ACK cluster.
	Mode *int32 `json:"Mode,omitempty" xml:"Mode,omitempty"`
}

func (s DeleteClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteClusterRequest) GoString() string {
	return s.String()
}

func (s *DeleteClusterRequest) SetClusterId(v string) *DeleteClusterRequest {
	s.ClusterId = &v
	return s
}

func (s *DeleteClusterRequest) SetMode(v int32) *DeleteClusterRequest {
	s.Mode = &v
	return s
}

type DeleteClusterResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// Indicates whether the cluster is deleted. Valid values:
	//
	// *   true: The cluster is deleted.
	// *   false: The cluster is not deleted.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteClusterResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteClusterResponseBody) SetCode(v int32) *DeleteClusterResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteClusterResponseBody) SetData(v bool) *DeleteClusterResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteClusterResponseBody) SetMessage(v string) *DeleteClusterResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteClusterResponseBody) SetRequestId(v string) *DeleteClusterResponseBody {
	s.RequestId = &v
	return s
}

type DeleteClusterResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteClusterResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteClusterResponse) GoString() string {
	return s.String()
}

func (s *DeleteClusterResponse) SetHeaders(v map[string]*string) *DeleteClusterResponse {
	s.Headers = v
	return s
}

func (s *DeleteClusterResponse) SetStatusCode(v int32) *DeleteClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteClusterResponse) SetBody(v *DeleteClusterResponseBody) *DeleteClusterResponse {
	s.Body = v
	return s
}

type DeleteClusterMemberRequest struct {
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The member ID of the ECS instance that you want to remove from the cluster.
	ClusterMemberId *string `json:"ClusterMemberId,omitempty" xml:"ClusterMemberId,omitempty"`
}

func (s DeleteClusterMemberRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteClusterMemberRequest) GoString() string {
	return s.String()
}

func (s *DeleteClusterMemberRequest) SetClusterId(v string) *DeleteClusterMemberRequest {
	s.ClusterId = &v
	return s
}

func (s *DeleteClusterMemberRequest) SetClusterMemberId(v string) *DeleteClusterMemberRequest {
	s.ClusterMemberId = &v
	return s
}

type DeleteClusterMemberResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// Indicates whether the request is successful.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteClusterMemberResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteClusterMemberResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteClusterMemberResponseBody) SetCode(v int32) *DeleteClusterMemberResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteClusterMemberResponseBody) SetData(v bool) *DeleteClusterMemberResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteClusterMemberResponseBody) SetMessage(v string) *DeleteClusterMemberResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteClusterMemberResponseBody) SetRequestId(v string) *DeleteClusterMemberResponseBody {
	s.RequestId = &v
	return s
}

type DeleteClusterMemberResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteClusterMemberResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteClusterMemberResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteClusterMemberResponse) GoString() string {
	return s.String()
}

func (s *DeleteClusterMemberResponse) SetHeaders(v map[string]*string) *DeleteClusterMemberResponse {
	s.Headers = v
	return s
}

func (s *DeleteClusterMemberResponse) SetStatusCode(v int32) *DeleteClusterMemberResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteClusterMemberResponse) SetBody(v *DeleteClusterMemberResponseBody) *DeleteClusterMemberResponse {
	s.Body = v
	return s
}

type DeleteConfigTemplateRequest struct {
	// The ID of the configuration template.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
}

func (s DeleteConfigTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteConfigTemplateRequest) GoString() string {
	return s.String()
}

func (s *DeleteConfigTemplateRequest) SetId(v int64) *DeleteConfigTemplateRequest {
	s.Id = &v
	return s
}

type DeleteConfigTemplateResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteConfigTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteConfigTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteConfigTemplateResponseBody) SetCode(v int32) *DeleteConfigTemplateResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteConfigTemplateResponseBody) SetMessage(v string) *DeleteConfigTemplateResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteConfigTemplateResponseBody) SetRequestId(v string) *DeleteConfigTemplateResponseBody {
	s.RequestId = &v
	return s
}

type DeleteConfigTemplateResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteConfigTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteConfigTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteConfigTemplateResponse) GoString() string {
	return s.String()
}

func (s *DeleteConfigTemplateResponse) SetHeaders(v map[string]*string) *DeleteConfigTemplateResponse {
	s.Headers = v
	return s
}

func (s *DeleteConfigTemplateResponse) SetStatusCode(v int32) *DeleteConfigTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteConfigTemplateResponse) SetBody(v *DeleteConfigTemplateResponseBody) *DeleteConfigTemplateResponse {
	s.Body = v
	return s
}

type DeleteDeployGroupRequest struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the instance group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
}

func (s DeleteDeployGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDeployGroupRequest) GoString() string {
	return s.String()
}

func (s *DeleteDeployGroupRequest) SetAppId(v string) *DeleteDeployGroupRequest {
	s.AppId = &v
	return s
}

func (s *DeleteDeployGroupRequest) SetGroupName(v string) *DeleteDeployGroupRequest {
	s.GroupName = &v
	return s
}

type DeleteDeployGroupResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data that is returned.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDeployGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDeployGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDeployGroupResponseBody) SetCode(v int32) *DeleteDeployGroupResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteDeployGroupResponseBody) SetData(v string) *DeleteDeployGroupResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteDeployGroupResponseBody) SetMessage(v string) *DeleteDeployGroupResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteDeployGroupResponseBody) SetRequestId(v string) *DeleteDeployGroupResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDeployGroupResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteDeployGroupResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteDeployGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDeployGroupResponse) GoString() string {
	return s.String()
}

func (s *DeleteDeployGroupResponse) SetHeaders(v map[string]*string) *DeleteDeployGroupResponse {
	s.Headers = v
	return s
}

func (s *DeleteDeployGroupResponse) SetStatusCode(v int32) *DeleteDeployGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDeployGroupResponse) SetBody(v *DeleteDeployGroupResponseBody) *DeleteDeployGroupResponse {
	s.Body = v
	return s
}

type DeleteEcuRequest struct {
	// The unique ID of the ECU to be deleted.
	EcuId *string `json:"EcuId,omitempty" xml:"EcuId,omitempty"`
}

func (s DeleteEcuRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteEcuRequest) GoString() string {
	return s.String()
}

func (s *DeleteEcuRequest) SetEcuId(v string) *DeleteEcuRequest {
	s.EcuId = &v
	return s
}

type DeleteEcuResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data that indicates whether the ECU is deleted. A value of `OK` indicates that the ECU is deleted.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteEcuResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteEcuResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteEcuResponseBody) SetCode(v int32) *DeleteEcuResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteEcuResponseBody) SetData(v string) *DeleteEcuResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteEcuResponseBody) SetMessage(v string) *DeleteEcuResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteEcuResponseBody) SetRequestId(v string) *DeleteEcuResponseBody {
	s.RequestId = &v
	return s
}

type DeleteEcuResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteEcuResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteEcuResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteEcuResponse) GoString() string {
	return s.String()
}

func (s *DeleteEcuResponse) SetHeaders(v map[string]*string) *DeleteEcuResponse {
	s.Headers = v
	return s
}

func (s *DeleteEcuResponse) SetStatusCode(v int32) *DeleteEcuResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteEcuResponse) SetBody(v *DeleteEcuResponseBody) *DeleteEcuResponse {
	s.Body = v
	return s
}

type DeleteK8sApplicationRequest struct {
	// The ID of the application that you want to delete. You can call the ListApplication operation to query the application ID.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// Specifies whether to forcibly delete the application and disable application deletion protection.
	Force *bool `json:"Force,omitempty" xml:"Force,omitempty"`
}

func (s DeleteK8sApplicationRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteK8sApplicationRequest) GoString() string {
	return s.String()
}

func (s *DeleteK8sApplicationRequest) SetAppId(v string) *DeleteK8sApplicationRequest {
	s.AppId = &v
	return s
}

func (s *DeleteK8sApplicationRequest) SetForce(v bool) *DeleteK8sApplicationRequest {
	s.Force = &v
	return s
}

type DeleteK8sApplicationResponseBody struct {
	// The ID of the change process for this operation. If an instance on which the application is deployed is running or a Server Load Balancer (SLB) instance is bound to the application, this operation generates a change process ID and deletes the application. You can call the GetChangeOrderInfo operation to query the progress of this operation. You can determine whether the operation is successful based on the value of the Code parameter.
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteK8sApplicationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteK8sApplicationResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteK8sApplicationResponseBody) SetChangeOrderId(v string) *DeleteK8sApplicationResponseBody {
	s.ChangeOrderId = &v
	return s
}

func (s *DeleteK8sApplicationResponseBody) SetCode(v int32) *DeleteK8sApplicationResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteK8sApplicationResponseBody) SetMessage(v string) *DeleteK8sApplicationResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteK8sApplicationResponseBody) SetRequestId(v string) *DeleteK8sApplicationResponseBody {
	s.RequestId = &v
	return s
}

type DeleteK8sApplicationResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteK8sApplicationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteK8sApplicationResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteK8sApplicationResponse) GoString() string {
	return s.String()
}

func (s *DeleteK8sApplicationResponse) SetHeaders(v map[string]*string) *DeleteK8sApplicationResponse {
	s.Headers = v
	return s
}

func (s *DeleteK8sApplicationResponse) SetStatusCode(v int32) *DeleteK8sApplicationResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteK8sApplicationResponse) SetBody(v *DeleteK8sApplicationResponseBody) *DeleteK8sApplicationResponse {
	s.Body = v
	return s
}

type DeleteK8sConfigMapRequest struct {
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the ConfigMap. The name must start with a letter, and can contain digits, letters, and hyphens (-). It can be up to 63 characters in length.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace of the Kubernetes cluster.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
}

func (s DeleteK8sConfigMapRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteK8sConfigMapRequest) GoString() string {
	return s.String()
}

func (s *DeleteK8sConfigMapRequest) SetClusterId(v string) *DeleteK8sConfigMapRequest {
	s.ClusterId = &v
	return s
}

func (s *DeleteK8sConfigMapRequest) SetName(v string) *DeleteK8sConfigMapRequest {
	s.Name = &v
	return s
}

func (s *DeleteK8sConfigMapRequest) SetNamespace(v string) *DeleteK8sConfigMapRequest {
	s.Namespace = &v
	return s
}

type DeleteK8sConfigMapResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteK8sConfigMapResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteK8sConfigMapResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteK8sConfigMapResponseBody) SetCode(v int32) *DeleteK8sConfigMapResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteK8sConfigMapResponseBody) SetMessage(v string) *DeleteK8sConfigMapResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteK8sConfigMapResponseBody) SetRequestId(v string) *DeleteK8sConfigMapResponseBody {
	s.RequestId = &v
	return s
}

type DeleteK8sConfigMapResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteK8sConfigMapResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteK8sConfigMapResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteK8sConfigMapResponse) GoString() string {
	return s.String()
}

func (s *DeleteK8sConfigMapResponse) SetHeaders(v map[string]*string) *DeleteK8sConfigMapResponse {
	s.Headers = v
	return s
}

func (s *DeleteK8sConfigMapResponse) SetStatusCode(v int32) *DeleteK8sConfigMapResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteK8sConfigMapResponse) SetBody(v *DeleteK8sConfigMapResponseBody) *DeleteK8sConfigMapResponse {
	s.Body = v
	return s
}

type DeleteK8sIngressRuleRequest struct {
	// The ID of the Kubernetes cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the Ingress. The name can contain lowercase letters, digits, and hyphens (-). It must start with a lowercase letter but cannot end with a hyphen (-). The name can be up to 63 characters in length.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace of the Kubernetes cluster.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
}

func (s DeleteK8sIngressRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteK8sIngressRuleRequest) GoString() string {
	return s.String()
}

func (s *DeleteK8sIngressRuleRequest) SetClusterId(v string) *DeleteK8sIngressRuleRequest {
	s.ClusterId = &v
	return s
}

func (s *DeleteK8sIngressRuleRequest) SetName(v string) *DeleteK8sIngressRuleRequest {
	s.Name = &v
	return s
}

func (s *DeleteK8sIngressRuleRequest) SetNamespace(v string) *DeleteK8sIngressRuleRequest {
	s.Namespace = &v
	return s
}

type DeleteK8sIngressRuleResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
}

func (s DeleteK8sIngressRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteK8sIngressRuleResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteK8sIngressRuleResponseBody) SetCode(v int32) *DeleteK8sIngressRuleResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteK8sIngressRuleResponseBody) SetMessage(v string) *DeleteK8sIngressRuleResponseBody {
	s.Message = &v
	return s
}

type DeleteK8sIngressRuleResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteK8sIngressRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteK8sIngressRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteK8sIngressRuleResponse) GoString() string {
	return s.String()
}

func (s *DeleteK8sIngressRuleResponse) SetHeaders(v map[string]*string) *DeleteK8sIngressRuleResponse {
	s.Headers = v
	return s
}

func (s *DeleteK8sIngressRuleResponse) SetStatusCode(v int32) *DeleteK8sIngressRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteK8sIngressRuleResponse) SetBody(v *DeleteK8sIngressRuleResponseBody) *DeleteK8sIngressRuleResponse {
	s.Body = v
	return s
}

type DeleteK8sSecretRequest struct {
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the Secret. The name must start with a letter, and can contain digits, letters, and hyphens (-). It can be up to 63 characters in length.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace of the Kubernetes cluster.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
}

func (s DeleteK8sSecretRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteK8sSecretRequest) GoString() string {
	return s.String()
}

func (s *DeleteK8sSecretRequest) SetClusterId(v string) *DeleteK8sSecretRequest {
	s.ClusterId = &v
	return s
}

func (s *DeleteK8sSecretRequest) SetName(v string) *DeleteK8sSecretRequest {
	s.Name = &v
	return s
}

func (s *DeleteK8sSecretRequest) SetNamespace(v string) *DeleteK8sSecretRequest {
	s.Namespace = &v
	return s
}

type DeleteK8sSecretResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteK8sSecretResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteK8sSecretResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteK8sSecretResponseBody) SetCode(v int32) *DeleteK8sSecretResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteK8sSecretResponseBody) SetMessage(v string) *DeleteK8sSecretResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteK8sSecretResponseBody) SetRequestId(v string) *DeleteK8sSecretResponseBody {
	s.RequestId = &v
	return s
}

type DeleteK8sSecretResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteK8sSecretResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteK8sSecretResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteK8sSecretResponse) GoString() string {
	return s.String()
}

func (s *DeleteK8sSecretResponse) SetHeaders(v map[string]*string) *DeleteK8sSecretResponse {
	s.Headers = v
	return s
}

func (s *DeleteK8sSecretResponse) SetStatusCode(v int32) *DeleteK8sSecretResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteK8sSecretResponse) SetBody(v *DeleteK8sSecretResponseBody) *DeleteK8sSecretResponse {
	s.Body = v
	return s
}

type DeleteK8sServiceRequest struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the service.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s DeleteK8sServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteK8sServiceRequest) GoString() string {
	return s.String()
}

func (s *DeleteK8sServiceRequest) SetAppId(v string) *DeleteK8sServiceRequest {
	s.AppId = &v
	return s
}

func (s *DeleteK8sServiceRequest) SetName(v string) *DeleteK8sServiceRequest {
	s.Name = &v
	return s
}

type DeleteK8sServiceResponseBody struct {
	// The ID of the change process.
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteK8sServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteK8sServiceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteK8sServiceResponseBody) SetChangeOrderId(v string) *DeleteK8sServiceResponseBody {
	s.ChangeOrderId = &v
	return s
}

func (s *DeleteK8sServiceResponseBody) SetCode(v int32) *DeleteK8sServiceResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteK8sServiceResponseBody) SetMessage(v string) *DeleteK8sServiceResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteK8sServiceResponseBody) SetRequestId(v string) *DeleteK8sServiceResponseBody {
	s.RequestId = &v
	return s
}

type DeleteK8sServiceResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteK8sServiceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteK8sServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteK8sServiceResponse) GoString() string {
	return s.String()
}

func (s *DeleteK8sServiceResponse) SetHeaders(v map[string]*string) *DeleteK8sServiceResponse {
	s.Headers = v
	return s
}

func (s *DeleteK8sServiceResponse) SetStatusCode(v int32) *DeleteK8sServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteK8sServiceResponse) SetBody(v *DeleteK8sServiceResponseBody) *DeleteK8sServiceResponse {
	s.Body = v
	return s
}

type DeleteLogPathRequest struct {
	// The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The absolute path of the log directory that you want to remove. The value must start and end with a forward slash (`/`) and must contain `/log` or `/logs`. The following directories are the default log directories in Enterprise Distributed Application Service (EDAS):
	//
	// *   /home/admin/edas-container/logs/
	// *   /home/admin/taobao-tomcat-7.0.59/logs/
	// *   /home/admin/taobao-tomcat-production-7.0.59.3/logs/
	// *   /home/admin/taobao-tomcat-production-7.0.70/logs/
	// *   /home/admin/edas-agent/logs/
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s DeleteLogPathRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteLogPathRequest) GoString() string {
	return s.String()
}

func (s *DeleteLogPathRequest) SetAppId(v string) *DeleteLogPathRequest {
	s.AppId = &v
	return s
}

func (s *DeleteLogPathRequest) SetPath(v string) *DeleteLogPathRequest {
	s.Path = &v
	return s
}

type DeleteLogPathResponseBody struct {
	// The HTTP status code that is returned.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteLogPathResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteLogPathResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteLogPathResponseBody) SetCode(v string) *DeleteLogPathResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteLogPathResponseBody) SetMessage(v string) *DeleteLogPathResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteLogPathResponseBody) SetRequestId(v string) *DeleteLogPathResponseBody {
	s.RequestId = &v
	return s
}

type DeleteLogPathResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteLogPathResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteLogPathResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteLogPathResponse) GoString() string {
	return s.String()
}

func (s *DeleteLogPathResponse) SetHeaders(v map[string]*string) *DeleteLogPathResponse {
	s.Headers = v
	return s
}

func (s *DeleteLogPathResponse) SetStatusCode(v int32) *DeleteLogPathResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteLogPathResponse) SetBody(v *DeleteLogPathResponseBody) *DeleteLogPathResponse {
	s.Body = v
	return s
}

type DeleteRoleRequest struct {
	// The ID of the RAM role.
	RoleId *int32 `json:"RoleId,omitempty" xml:"RoleId,omitempty"`
}

func (s DeleteRoleRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteRoleRequest) GoString() string {
	return s.String()
}

func (s *DeleteRoleRequest) SetRoleId(v int32) *DeleteRoleRequest {
	s.RoleId = &v
	return s
}

type DeleteRoleResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteRoleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteRoleResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteRoleResponseBody) SetCode(v int32) *DeleteRoleResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteRoleResponseBody) SetMessage(v string) *DeleteRoleResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteRoleResponseBody) SetRequestId(v string) *DeleteRoleResponseBody {
	s.RequestId = &v
	return s
}

type DeleteRoleResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteRoleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteRoleResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteRoleResponse) GoString() string {
	return s.String()
}

func (s *DeleteRoleResponse) SetHeaders(v map[string]*string) *DeleteRoleResponse {
	s.Headers = v
	return s
}

func (s *DeleteRoleResponse) SetStatusCode(v int32) *DeleteRoleResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteRoleResponse) SetBody(v *DeleteRoleResponseBody) *DeleteRoleResponse {
	s.Body = v
	return s
}

type DeleteServiceGroupRequest struct {
	// The ID of the service group that you want to delete.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
}

func (s DeleteServiceGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteServiceGroupRequest) GoString() string {
	return s.String()
}

func (s *DeleteServiceGroupRequest) SetGroupId(v string) *DeleteServiceGroupRequest {
	s.GroupId = &v
	return s
}

type DeleteServiceGroupResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteServiceGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteServiceGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteServiceGroupResponseBody) SetCode(v int32) *DeleteServiceGroupResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteServiceGroupResponseBody) SetMessage(v string) *DeleteServiceGroupResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteServiceGroupResponseBody) SetRequestId(v string) *DeleteServiceGroupResponseBody {
	s.RequestId = &v
	return s
}

type DeleteServiceGroupResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteServiceGroupResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteServiceGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteServiceGroupResponse) GoString() string {
	return s.String()
}

func (s *DeleteServiceGroupResponse) SetHeaders(v map[string]*string) *DeleteServiceGroupResponse {
	s.Headers = v
	return s
}

func (s *DeleteServiceGroupResponse) SetStatusCode(v int32) *DeleteServiceGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteServiceGroupResponse) SetBody(v *DeleteServiceGroupResponseBody) *DeleteServiceGroupResponse {
	s.Body = v
	return s
}

type DeleteSwimmingLaneRequest struct {
	// The ID of the lane.
	LaneId *int64 `json:"LaneId,omitempty" xml:"LaneId,omitempty"`
}

func (s DeleteSwimmingLaneRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSwimmingLaneRequest) GoString() string {
	return s.String()
}

func (s *DeleteSwimmingLaneRequest) SetLaneId(v int64) *DeleteSwimmingLaneRequest {
	s.LaneId = &v
	return s
}

type DeleteSwimmingLaneResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// Indicates whether the lane is deleted.
	Data *int32 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteSwimmingLaneResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteSwimmingLaneResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSwimmingLaneResponseBody) SetCode(v int32) *DeleteSwimmingLaneResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteSwimmingLaneResponseBody) SetData(v int32) *DeleteSwimmingLaneResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteSwimmingLaneResponseBody) SetMessage(v string) *DeleteSwimmingLaneResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteSwimmingLaneResponseBody) SetRequestId(v string) *DeleteSwimmingLaneResponseBody {
	s.RequestId = &v
	return s
}

type DeleteSwimmingLaneResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteSwimmingLaneResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteSwimmingLaneResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSwimmingLaneResponse) GoString() string {
	return s.String()
}

func (s *DeleteSwimmingLaneResponse) SetHeaders(v map[string]*string) *DeleteSwimmingLaneResponse {
	s.Headers = v
	return s
}

func (s *DeleteSwimmingLaneResponse) SetStatusCode(v int32) *DeleteSwimmingLaneResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSwimmingLaneResponse) SetBody(v *DeleteSwimmingLaneResponseBody) *DeleteSwimmingLaneResponse {
	s.Body = v
	return s
}

type DeleteUserDefineRegionRequest struct {
	// The unique ID of the custom namespace. You can call the ListUserDefineRegion operation to query the ID. For more information, see [ListUserDefineRegion](~~149377~~).
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The tag of the custom namespace.
	RegionTag *string `json:"RegionTag,omitempty" xml:"RegionTag,omitempty"`
}

func (s DeleteUserDefineRegionRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteUserDefineRegionRequest) GoString() string {
	return s.String()
}

func (s *DeleteUserDefineRegionRequest) SetId(v int64) *DeleteUserDefineRegionRequest {
	s.Id = &v
	return s
}

func (s *DeleteUserDefineRegionRequest) SetRegionTag(v string) *DeleteUserDefineRegionRequest {
	s.RegionTag = &v
	return s
}

type DeleteUserDefineRegionResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The custom namespace.
	RegionDefine *DeleteUserDefineRegionResponseBodyRegionDefine `json:"RegionDefine,omitempty" xml:"RegionDefine,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteUserDefineRegionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteUserDefineRegionResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteUserDefineRegionResponseBody) SetCode(v int32) *DeleteUserDefineRegionResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteUserDefineRegionResponseBody) SetMessage(v string) *DeleteUserDefineRegionResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteUserDefineRegionResponseBody) SetRegionDefine(v *DeleteUserDefineRegionResponseBodyRegionDefine) *DeleteUserDefineRegionResponseBody {
	s.RegionDefine = v
	return s
}

func (s *DeleteUserDefineRegionResponseBody) SetRequestId(v string) *DeleteUserDefineRegionResponseBody {
	s.RequestId = &v
	return s
}

type DeleteUserDefineRegionResponseBodyRegionDefine struct {
	// The ID of the region to which the custom namespace belongs.
	BelongRegion *string `json:"BelongRegion,omitempty" xml:"BelongRegion,omitempty"`
	// The description of the custom namespace.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The unique identifier of the custom namespace.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the custom namespace. The ID cannot be changed after the custom namespace is created. The format is `region ID:custom namespace ID`.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The name of the custom namespace.
	RegionName *string `json:"RegionName,omitempty" xml:"RegionName,omitempty"`
	// The ID of the Alibaba Cloud account to which the custom namespace belongs.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s DeleteUserDefineRegionResponseBodyRegionDefine) String() string {
	return tea.Prettify(s)
}

func (s DeleteUserDefineRegionResponseBodyRegionDefine) GoString() string {
	return s.String()
}

func (s *DeleteUserDefineRegionResponseBodyRegionDefine) SetBelongRegion(v string) *DeleteUserDefineRegionResponseBodyRegionDefine {
	s.BelongRegion = &v
	return s
}

func (s *DeleteUserDefineRegionResponseBodyRegionDefine) SetDescription(v string) *DeleteUserDefineRegionResponseBodyRegionDefine {
	s.Description = &v
	return s
}

func (s *DeleteUserDefineRegionResponseBodyRegionDefine) SetId(v int64) *DeleteUserDefineRegionResponseBodyRegionDefine {
	s.Id = &v
	return s
}

func (s *DeleteUserDefineRegionResponseBodyRegionDefine) SetRegionId(v string) *DeleteUserDefineRegionResponseBodyRegionDefine {
	s.RegionId = &v
	return s
}

func (s *DeleteUserDefineRegionResponseBodyRegionDefine) SetRegionName(v string) *DeleteUserDefineRegionResponseBodyRegionDefine {
	s.RegionName = &v
	return s
}

func (s *DeleteUserDefineRegionResponseBodyRegionDefine) SetUserId(v string) *DeleteUserDefineRegionResponseBodyRegionDefine {
	s.UserId = &v
	return s
}

type DeleteUserDefineRegionResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteUserDefineRegionResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteUserDefineRegionResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteUserDefineRegionResponse) GoString() string {
	return s.String()
}

func (s *DeleteUserDefineRegionResponse) SetHeaders(v map[string]*string) *DeleteUserDefineRegionResponse {
	s.Headers = v
	return s
}

func (s *DeleteUserDefineRegionResponse) SetStatusCode(v int32) *DeleteUserDefineRegionResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteUserDefineRegionResponse) SetBody(v *DeleteUserDefineRegionResponseBody) *DeleteUserDefineRegionResponse {
	s.Body = v
	return s
}

type DeployApplicationRequest struct {
	// The environment variables of the application. Specify each environment variable by using two key-value pairs. Example: `{"name":"x","value":"y"},{"name":"x2","value":"y2"}`. The `keys` of the two key-value pairs are `name` and `value`.
	AppEnv *string `json:"AppEnv,omitempty" xml:"AppEnv,omitempty"`
	// The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](~~423162~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The number of batches per instance group.
	//
	// *   If you specify an ID when you set the GroupId parameter, the application is deployed to the specified instance group. The minimum number of batches that can be specified is 1. The maximum number of batches is the maximum number of ECS instances in the Normal state in the instance group. The actual value falls in the range of \[1, specified number]. The specified number of batches equals the number of ECS instances in the specified instance group.
	// *   If you set the GroupId parameter to all, the application is deployed to all instance groups. The minimum number of batches that can be specified is 1. The maximum number of batches is the number of ECS instances in the instance group that has the largest number of ECS instances in the Normal state.
	Batch *int32 `json:"Batch,omitempty" xml:"Batch,omitempty"`
	// The wait time between deployment batches for the application. Unit: minutes.
	//
	// *   Default value: 0. If no wait time between deployment batches is needed, set this parameter to 0.
	// *   Maximum value: 5.
	//
	// If many deployment batches are needed, we recommend that you specify a small value for this parameter. Otherwise, the application deployment is time-consuming.
	BatchWaitTime *int32 `json:"BatchWaitTime,omitempty" xml:"BatchWaitTime,omitempty"`
	// The build package number of EDAS Container.
	//
	// *   You do not need to set the parameter if you do not need to change the EDAS Container version during the deployment.
	// *   Set the parameter if you need to update the EDAS Container version of the application during the deployment.
	//
	// You can query the build package number by using one of the following methods:
	//
	// *   Call the ListBuildPack operation. For more information, see [ListBuildPack](~~149391~~).
	// *   Obtain the value in the **Build package number** column of the [Release notes for EDAS Container](~~92614~~) topic. For example, `59` indicates `EDAS Container 3.5.8`.
	BuildPackId *int64 `json:"BuildPackId,omitempty" xml:"BuildPackId,omitempty"`
	// The IDs of the components used by the application. The parameter is not applicable to High-Speed Framework (HSF) applications. You can call the ListComponents operation to query the component IDs. For more information, see [ListComponents](~~423223~~).
	//
	// *   If you have specified the component IDs when you create the application, you do not need to set the parameter when you deploy the application.
	// *   Set the parameter if you need to update the component versions for the application during the deployment.
	//
	// Valid values for common application components:
	//
	// *   4: Apache Tomcat 7.0.91
	// *   7: Apache Tomcat 8.5.42
	// *   5: OpenJDK 1.8.x
	// *   6: OpenJDK 1.7.x
	//
	// For more information, see the Common application parameters section of the [InsertApplication](~~423185~~) topic.
	ComponentIds *string `json:"ComponentIds,omitempty" xml:"ComponentIds,omitempty"`
	// The deployment mode of the application. Valid values: `url` and `image`. The image value is deprecated. You can deploy an application to a Swarm cluster only by using an image.``
	DeployType *string `json:"DeployType,omitempty" xml:"DeployType,omitempty"`
	// The description of the application deployment.
	Desc *string `json:"Desc,omitempty" xml:"Desc,omitempty"`
	// Specifies whether canary release is selected as the deployment method. Valid values:
	//
	// *   true: Canary release is selected.
	//
	//     *   To implement a canary release, specify the GroupId parameter, which specifies the ID of the instance group for the canary release.
	//     *   Canary release can be selected as the deployment method for only one batch.
	//     *   After the canary release is complete, the application is released in regular mode. The Batch parameter specifies the number of batches.
	//
	// *   false: Single-batch release or phased release is selected.
	Gray *bool `json:"Gray,omitempty" xml:"Gray,omitempty"`
	// The ID of the instance group to which the application is deployed. You can call the ListDeployGroup operation to query the ID of the instance group. For more information, see [ListDeployGroup](~~423184~~).
	//
	// Set the parameter to `all` if you want to deploy the application to all instance groups.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The URL of the application image that is used to deploy the application in a Swarm cluster. We recommend that you use an image that is stored in Alibaba Cloud Container Registry. This parameter is deprecated.
	ImageUrl *string `json:"ImageUrl,omitempty" xml:"ImageUrl,omitempty"`
	// The version of the application deployment package. The value can be up to 64 characters in length. We recommend that you use a timestamp.
	PackageVersion *string `json:"PackageVersion,omitempty" xml:"PackageVersion,omitempty"`
	// The mode in which the deployment batches are triggered. Valid values:
	//
	// *   0: automatic.
	// *   1: You must manually trigger the next batch. You can manually click **Proceed to Next Batch** in the console or call the ContinuePipeline operation to proceed to the next batch. We recommend that you choose the automatic mode when you call an API operation to deploy the application. For more information, see [ContinuePipeline](~~126990~~).
	ReleaseType *int64 `json:"ReleaseType,omitempty" xml:"ReleaseType,omitempty"`
	// The canary release policy. For more information about canary release policies, see [DeployK8sApplication](~~423212~~).
	TrafficControlStrategy *string `json:"TrafficControlStrategy,omitempty" xml:"TrafficControlStrategy,omitempty"`
	// The URL of the application deployment package. The package can be a WAR or JAR package. This parameter is required if you set the **DeployType** parameter to `url`. We recommend that you specify the URL of an application deployment package that is stored in an Object Storage Service (OSS) bucket.
	WarUrl *string `json:"WarUrl,omitempty" xml:"WarUrl,omitempty"`
}

func (s DeployApplicationRequest) String() string {
	return tea.Prettify(s)
}

func (s DeployApplicationRequest) GoString() string {
	return s.String()
}

func (s *DeployApplicationRequest) SetAppEnv(v string) *DeployApplicationRequest {
	s.AppEnv = &v
	return s
}

func (s *DeployApplicationRequest) SetAppId(v string) *DeployApplicationRequest {
	s.AppId = &v
	return s
}

func (s *DeployApplicationRequest) SetBatch(v int32) *DeployApplicationRequest {
	s.Batch = &v
	return s
}

func (s *DeployApplicationRequest) SetBatchWaitTime(v int32) *DeployApplicationRequest {
	s.BatchWaitTime = &v
	return s
}

func (s *DeployApplicationRequest) SetBuildPackId(v int64) *DeployApplicationRequest {
	s.BuildPackId = &v
	return s
}

func (s *DeployApplicationRequest) SetComponentIds(v string) *DeployApplicationRequest {
	s.ComponentIds = &v
	return s
}

func (s *DeployApplicationRequest) SetDeployType(v string) *DeployApplicationRequest {
	s.DeployType = &v
	return s
}

func (s *DeployApplicationRequest) SetDesc(v string) *DeployApplicationRequest {
	s.Desc = &v
	return s
}

func (s *DeployApplicationRequest) SetGray(v bool) *DeployApplicationRequest {
	s.Gray = &v
	return s
}

func (s *DeployApplicationRequest) SetGroupId(v string) *DeployApplicationRequest {
	s.GroupId = &v
	return s
}

func (s *DeployApplicationRequest) SetImageUrl(v string) *DeployApplicationRequest {
	s.ImageUrl = &v
	return s
}

func (s *DeployApplicationRequest) SetPackageVersion(v string) *DeployApplicationRequest {
	s.PackageVersion = &v
	return s
}

func (s *DeployApplicationRequest) SetReleaseType(v int64) *DeployApplicationRequest {
	s.ReleaseType = &v
	return s
}

func (s *DeployApplicationRequest) SetTrafficControlStrategy(v string) *DeployApplicationRequest {
	s.TrafficControlStrategy = &v
	return s
}

func (s *DeployApplicationRequest) SetWarUrl(v string) *DeployApplicationRequest {
	s.WarUrl = &v
	return s
}

type DeployApplicationResponseBody struct {
	// The change process ID of the application deployment.
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message returned for the request.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeployApplicationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeployApplicationResponseBody) GoString() string {
	return s.String()
}

func (s *DeployApplicationResponseBody) SetChangeOrderId(v string) *DeployApplicationResponseBody {
	s.ChangeOrderId = &v
	return s
}

func (s *DeployApplicationResponseBody) SetCode(v int32) *DeployApplicationResponseBody {
	s.Code = &v
	return s
}

func (s *DeployApplicationResponseBody) SetMessage(v string) *DeployApplicationResponseBody {
	s.Message = &v
	return s
}

func (s *DeployApplicationResponseBody) SetRequestId(v string) *DeployApplicationResponseBody {
	s.RequestId = &v
	return s
}

type DeployApplicationResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeployApplicationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeployApplicationResponse) String() string {
	return tea.Prettify(s)
}

func (s DeployApplicationResponse) GoString() string {
	return s.String()
}

func (s *DeployApplicationResponse) SetHeaders(v map[string]*string) *DeployApplicationResponse {
	s.Headers = v
	return s
}

func (s *DeployApplicationResponse) SetStatusCode(v int32) *DeployApplicationResponse {
	s.StatusCode = &v
	return s
}

func (s *DeployApplicationResponse) SetBody(v *DeployApplicationResponseBody) *DeployApplicationResponse {
	s.Body = v
	return s
}

type DeployK8sApplicationRequest struct {
	// The annotation of an application pod.
	Annotations *string `json:"Annotations,omitempty" xml:"Annotations,omitempty"`
	// The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The argument array in the container start-up command. Set this parameter to a JSON array in the format of `\["args1","args2"\]`, where each key is set to a string. If you want to cancel this configuration, set this parameter to an empty JSON array in the format of `"\[\]"`.
	Args *string `json:"Args,omitempty" xml:"Args,omitempty"`
	// The timeout period for an at-a-time release. Unit: seconds.
	BatchTimeout *int32 `json:"BatchTimeout,omitempty" xml:"BatchTimeout,omitempty"`
	// The minimum time interval for the phased release of pods. For more information, see [minReadySeconds](https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#min-ready-seconds).
	BatchWaitTime *int32 `json:"BatchWaitTime,omitempty" xml:"BatchWaitTime,omitempty"`
	// The build package number of EDAS Container.
	//
	// *   You do not need to set the parameter if you do not need to change the EDAS Container version during the deployment.
	// *   Set the parameter if you need to update the EDAS Container version of the application during the deployment.
	//
	// You can query the build package number by using one of the following methods:
	//
	// *   Call the ListBuildPack operation. For more information, see [ListBuildPack](~~423222~~).
	// *   Obtain the value in the **Build package number** column of the [Release notes for EDAS Container](~~92614~~) topic. For example, `59` indicates `EDAS Container 3.5.8`.
	BuildPackId  *string `json:"BuildPackId,omitempty" xml:"BuildPackId,omitempty"`
	CanaryRuleId *string `json:"CanaryRuleId,omitempty" xml:"CanaryRuleId,omitempty"`
	// The description of the change process.
	ChangeOrderDesc *string `json:"ChangeOrderDesc,omitempty" xml:"ChangeOrderDesc,omitempty"`
	// The commands that you run to start the container.
	//
	// > If you want to cancel this configuration, set this parameter to an empty string in the format of `""`.
	Command *string `json:"Command,omitempty" xml:"Command,omitempty"`
	// The configuration for mounting a Kubernetes ConfigMap or Secret to a directory in an elastic container instance. The following parameters are included in the configuration:
	//
	// *   name: the name of the Kubernetes ConfigMap or Secret.
	// *   type: the type of the API object that you want to mount. You can mount a Kubernetes ConfigMap or Secret.
	// *   mountPath: the mount path. The mount path must be an absolute path that starts with a forward slash (/).
	ConfigMountDescs *string `json:"ConfigMountDescs,omitempty" xml:"ConfigMountDescs,omitempty"`
	// The maximum number of CPU cores allowed for each application instance when the application is running. Unit: cores. Value 0 indicates that no limit is set on CPU cores.
	CpuLimit *int32 `json:"CpuLimit,omitempty" xml:"CpuLimit,omitempty"`
	// The number of CPU cores requested for each application instance when the application is running. Unit: cores. We recommend that you set this parameter. Value 0 indicates that no limit is set on CPU cores.
	//
	// > You must set this parameter together with the CpuLimit parameter. Make sure that the value of this parameter does not exceed that of the CpuLimit parameter.
	CpuRequest *int32 `json:"CpuRequest,omitempty" xml:"CpuRequest,omitempty"`
	// The affinity configuration of the pod. This parameter takes effect only if both the DeployAcrossNodes and DeployAcrossZones parameters are set to false.
	CustomAffinity     *string `json:"CustomAffinity,omitempty" xml:"CustomAffinity,omitempty"`
	CustomAgentVersion *string `json:"CustomAgentVersion,omitempty" xml:"CustomAgentVersion,omitempty"`
	// The scheduling tolerance configuration of the pod. This parameter takes effect only if both the DeployAcrossNodes and DeployAcrossZones parameters are set to false.
	CustomTolerations *string `json:"CustomTolerations,omitempty" xml:"CustomTolerations,omitempty"`
	// Specifies whether to distribute application instances to multiple nodes. Value true indicates that application instances are distrubuted across zones. Other values indicate that application instances are not distributed across zones.
	DeployAcrossNodes *string `json:"DeployAcrossNodes,omitempty" xml:"DeployAcrossNodes,omitempty"`
	// Specifies whether to distribute application instances across zones. Value true indicates that application instances are distrubuted across zones. Other values indicate that application instances are not distributed across zones.
	DeployAcrossZones *string `json:"DeployAcrossZones,omitempty" xml:"DeployAcrossZones,omitempty"`
	// The version of EDAS Container on which the deployment package of the application depends. This parameter is applicable to High-Speed Service Framework (HSF) applications that you deploy by using WAR packages. This parameter is unavailable if you deploy applications by using images.
	EdasContainerVersion *string `json:"EdasContainerVersion,omitempty" xml:"EdasContainerVersion,omitempty"`
	// The configuration for mounting a Kubernetes emptyDir volume to a directory in an elastic container instance. The following parameters are included in the configuration:
	//
	// *   mountPath: The mount path in the container. This parameter is required.
	// *   readOnly: (Optional) The mount mode. Value true indicates the read-only mode. Value false indicates the read and write mode. Default value: false.
	// *   subPathExpr: (Optional) The regular expression that is used to match the subdirectory.
	EmptyDirs *string `json:"EmptyDirs,omitempty" xml:"EmptyDirs,omitempty"`
	// Specifies whether to enable access to Application High Availability Service (AHAS).
	EnableAhas *bool `json:"EnableAhas,omitempty" xml:"EnableAhas,omitempty"`
	// Specifies whether to enable the empty list protection feature. Valid values:
	//
	// *   true: enables the empty list protection feature.
	// *   false: disables the empty list protection feature.
	EnableEmptyPushReject *bool `json:"EnableEmptyPushReject,omitempty" xml:"EnableEmptyPushReject,omitempty"`
	// Specifies whether to enable graceful start rules. Valid values:
	//
	// *   true: enables graceful start rules.
	// *   false: disables graceful start rules.
	EnableLosslessRule *bool `json:"EnableLosslessRule,omitempty" xml:"EnableLosslessRule,omitempty"`
	// The Kubernetes environment variables that are configured in EnvFrom mode. A ConfigMap or Secret is mounted to a directory. Each key corresponds to a file in the directory, and the content of the file is the value of the key.
	//
	// This parameter contains the following parameters:
	//
	// *   configMapRef: the ConfigMap that is referenced. The following parameter is contained:
	//
	//     *   name: the name of the ConfigMap.
	//
	// *   secretRef: the Secret that is referenced. The following parameter is contained:
	//
	//     *   name: the name of the Secret.
	EnvFroms *string `json:"EnvFroms,omitempty" xml:"EnvFroms,omitempty"`
	// The environment variables that are used to deploy the application. Set this parameter to a JSON array. Valid values: regular environment variables, Kubernetes ConfigMap environment variables, and Kubernetes Secret environment variables. Specify regular environment variables in the following format:
	//
	// `{"name":"x", "value": "y"}`
	//
	// Specify Kubernetes ConfigMap environment variables in the following format to reference values from ConfigMaps:
	//
	// `{ "name": "x2", "valueFrom": { "configMapKeyRef": { "name": "my-config", "key": "y2" } } }`
	//
	// Specify Kubernetes Secret environment variables in the following format to reference values from Secrets:
	//
	// `{ "name": "x3", "valueFrom": { "secretKeyRef": { "name": "my-secret", "key": "y3" } } }`
	//
	// >  If you want to cancel this configuration, set this parameter to an empty JSON array, which is in the format of "\[]".
	Envs *string `json:"Envs,omitempty" xml:"Envs,omitempty"`
	// The absolute URL of the image. This parameter setting overwrites the setting of the ImageTag parameter.
	Image          *string `json:"Image,omitempty" xml:"Image,omitempty"`
	ImagePlatforms *string `json:"ImagePlatforms,omitempty" xml:"ImagePlatforms,omitempty"`
	// The tag of the image.
	ImageTag       *string `json:"ImageTag,omitempty" xml:"ImageTag,omitempty"`
	InitContainers *string `json:"InitContainers,omitempty" xml:"InitContainers,omitempty"`
	// The version of the Java Development Kit (JDK) on which the deployment package of the application depends. Open JDK 7 and Open JDK 8 are supported. This parameter is unavailable if you deploy applications by using images.
	JDK *string `json:"JDK,omitempty" xml:"JDK,omitempty"`
	// The configuration of Java startup parameters for a Java application. These startup parameters involve the memory, application, garbage collection (GC) policy, tools, service registration and discovery, and custom configurations. Proper parameter settings help reduce the GC overheads, shorten the server response time, and improve the throughput. Set this parameter to a JSON string. In the example, original indicates the configuration value, and startup indicates a startup parameter. The system automatically concatenates all startup values as the settings of Java startup parameters for the application. To delete this configuration, leave the parameter value empty by entering `""` or `"{}"`.
	JavaStartUpConfig *string `json:"JavaStartUpConfig,omitempty" xml:"JavaStartUpConfig,omitempty"`
	// The label of an application pod.
	Labels *string `json:"Labels,omitempty" xml:"Labels,omitempty"`
	// The maximum size of space required by ephemeral storage. Unit: GB. Value 0 indicates that no limit is set on the ephemeral storage space.
	LimitEphemeralStorage *int32 `json:"LimitEphemeralStorage,omitempty" xml:"LimitEphemeralStorage,omitempty"`
	// The configuration for the liveness check on the container. Example: `{"failureThreshold": 3,"initialDelaySeconds": 5,"successThreshold": 1,"timeoutSeconds": 1,"tcpSocket":{"host":"", "port":8080}}`. If you want to cancel this configuration, set this parameter to `""` or `{}`. If you do not specify this parameter, this configuration is ignored.
	Liveness *string `json:"Liveness,omitempty" xml:"Liveness,omitempty"`
	// The configurations that are used when the host files are mounted to the container on which the application is running. Example: `\[{"type":"","nodePath":"/localfiles","mountPath":"/app/files"},{"type":"Directory","nodePath":"/mnt","mountPath":"/app/storage"}\]`. The nodePath parameter specifies the host path, the mountPath parameter specifies the path within the container, and the type parameter specifies the mounting type.
	LocalVolume *string `json:"LocalVolume,omitempty" xml:"LocalVolume,omitempty"`
	// Specifies whether to enable Graceful Rolling Release and configure Complete Service Registration before Readiness Probing. Valid values:
	//
	// *   true: If you turn on the switch, the system uses the /health path and provides port 55199 for the health check. The system does not intrude into the application. When the service is registered, the system returns HTTP 200 status code. Otherwise, the system returns HTTP 500 status code.
	//
	// > If you set both the LosslessRuleRelated parameter and this parameter to true, the operation checks whether the service prefetching is complete.
	//
	// *   false: If you turn off the switch, the system does not provide a port to check whether the service is registered.
	LosslessRuleAligned *bool `json:"LosslessRuleAligned,omitempty" xml:"LosslessRuleAligned,omitempty"`
	// The delay of service registration. Valid values: 0 to 86400. Unit: seconds.
	LosslessRuleDelayTime *int32 `json:"LosslessRuleDelayTime,omitempty" xml:"LosslessRuleDelayTime,omitempty"`
	// The number of prefetching curves. Valid values: 0 to 20. The default value is 2, which is suitable for common prefetching scenarios. This value indicates that the received traffic amount of the provider during prefetching is displayed as a quadratic curve.
	LosslessRuleFuncType *int32 `json:"LosslessRuleFuncType,omitempty" xml:"LosslessRuleFuncType,omitempty"`
	// Specifies whether to enable Graceful Rolling Release and configure Complete Service Prefetching before Readiness Probing. Valid values:
	//
	// *   true: If you turn on the switch, the system uses the /health path and provides port 55199 for the health check. The system does not intrude into the application. When service prefetching is complete, the system returns HTTP 200 status code. Otherwise, the system returns HTTP 500 status code.
	// *   false: If you turn off the switch, the system does not provide a port to check whether service prefetching is complete.
	LosslessRuleRelated *bool `json:"LosslessRuleRelated,omitempty" xml:"LosslessRuleRelated,omitempty"`
	// The service prefetching duration. Valid values: 0 to 86400. Unit: seconds.
	LosslessRuleWarmupTime *int32 `json:"LosslessRuleWarmupTime,omitempty" xml:"LosslessRuleWarmupTime,omitempty"`
	// The maximum number of CPU cores allowed. Unit: cores. Value 0 indicates that no limit is set on CPU cores.
	McpuLimit *int32 `json:"McpuLimit,omitempty" xml:"McpuLimit,omitempty"`
	// The minimum number of CPU cores required. Unit: cores. Value 0 indicates that no limit is set on CPU cores.
	//
	// > You must set this parameter together with the CpuLimit parameter. Make sure that the value of this parameter does not exceed that of the CpuLimit parameter.
	McpuRequest *int32 `json:"McpuRequest,omitempty" xml:"McpuRequest,omitempty"`
	// The maximum size of memory allowed for each application instance when the application is running. Unit: MB. Value 0 indicates that no limit is set on the memory size.
	MemoryLimit *int32 `json:"MemoryLimit,omitempty" xml:"MemoryLimit,omitempty"`
	// The size of memory requested for each application instance when the application is running. Unit: MB. We recommend that you set this parameter. If you do not want to apply for a memory quota, set this parameter to 0.
	//
	// > You must set this parameter together with the MemoryLimit parameter. Make sure that the value of this parameter does not exceed that of the MemoryLimit parameter.
	MemoryRequest *int32 `json:"MemoryRequest,omitempty" xml:"MemoryRequest,omitempty"`
	// The description of the NAS mounting configuration. Set this parameter to a serialized JSON string. Example: `\[{"nasPath": "/k8s","mountPath": "/mnt"},{"nasPath": "/files","mountPath": "/app/files"}\]`. The nasPath parameter specifies the file storage path, and the mountPath parameter specifies the path to mount the file system to the container in which the application is running.
	MountDescs *string `json:"MountDescs,omitempty" xml:"MountDescs,omitempty"`
	// The ID of the Apsara File Storage NAS (NAS) file system mounted to the container in which the application is running. The NAS file system must be in the same region as the cluster. The NAS file system must have an available mount target, or have a mount target on the vSwitch in the virtual private cloud (VPC) in which the application resides. If you do not specify this parameter but specify the MountDescs parameter, a NAS file system is automatically purchased and mounted to the vSwitch in the VPC.
	NasId *string `json:"NasId,omitempty" xml:"NasId,omitempty"`
	// The URL of the deployment package. This parameter is required if you use a FatJar or WAR package to deploy the application.
	//
	// > The version of EDAS SDK for Java or Python must be V2.44.0 or later.
	PackageUrl *string `json:"PackageUrl,omitempty" xml:"PackageUrl,omitempty"`
	// The version of the deployment package. This parameter is required if you use a FatJar or WAR package to deploy the application. You must specify a version.
	//
	// > The version of EDAS SDK for Java or Python must be V2.44.0 or later.
	PackageVersion *string `json:"PackageVersion,omitempty" xml:"PackageVersion,omitempty"`
	// The version ID of the deployment package.
	PackageVersionId *string `json:"PackageVersionId,omitempty" xml:"PackageVersionId,omitempty"`
	// The post-start script. Example: `{"exec":{"command":\["cat","/etc/group"\]}}`. If you want to cancel this configuration, set this parameter to `""` or `{}`. If you do not specify this parameter, this configuration is ignored.
	PostStart *string `json:"PostStart,omitempty" xml:"PostStart,omitempty"`
	// The pre-stop script. Example: `{"tcpSocket":{"host":"", "port":8080}}`. If you want to cancel this configuration, set this parameter to `""` or `{}`. If you do not specify this parameter, this configuration is ignored.
	PreStop *string `json:"PreStop,omitempty" xml:"PreStop,omitempty"`
	// The configuration for mounting a Kubernetes PersistentVolumeClaim (PVC) to a directory in an elastic container instance. The following parameters are included in the configuration:
	//
	// *   pvcName: the name of the PVC. Make sure that the volume exists and is in the Bound state.
	//
	// *   mountPaths: the directory to which you want to mount the PVC. You can configure multiple directories. You can set the following two parameters for each mount directory:
	//
	//     *   mountPath: the mount path. The mount path must be an absolute path that starts with a forward slash (/).
	//     *   readOnly: the mount mode. Value true indicates the read-only mode. Value false indicates the read and write mode. Default value: false.
	PvcMountDescs *string `json:"PvcMountDescs,omitempty" xml:"PvcMountDescs,omitempty"`
	// The configuration for the readiness check on the container. If the check fails, the traffic that passes through the Kubernetes service is not transmitted to the container. Example: `{"failureThreshold": 3,"initialDelaySeconds": 5,"successThreshold": 1,"timeoutSeconds": 1,"httpGet": {"path": "/consumer","port": 8080,"scheme": "HTTP","httpHeaders": \[{"name": "test","value": "testvalue"}\]}}`. If you want to cancel this configuration, set this parameter to `""` or `{}`. If you do not specify this parameter, this configuration is ignored.
	Readiness *string `json:"Readiness,omitempty" xml:"Readiness,omitempty"`
	// The number of application instances. The minimum value is 0.
	Replicas *int32 `json:"Replicas,omitempty" xml:"Replicas,omitempty"`
	// The minimum size of space required by ephemeral storage. Unit: GB. Value 0 indicates that no limit is set on the ephemeral storage space.
	RequestsEphemeralStorage *int32 `json:"RequestsEphemeralStorage,omitempty" xml:"RequestsEphemeralStorage,omitempty"`
	// The type of the container runtime. Valid values:
	//
	// *   runc: standard container runtime
	// *   runv: sandboxed container runtime
	//
	// This parameter is applicable only to clusters that use sandboxed containers.
	RuntimeClassName *string `json:"RuntimeClassName,omitempty" xml:"RuntimeClassName,omitempty"`
	Sidecars         *string `json:"Sidecars,omitempty" xml:"Sidecars,omitempty"`
	// The Logstore configuration. If you want to cancel this configuration, leave the parameter value empty by entering `""` or `"{}"`.
	//
	// *   The following parameters are included in the configuration:
	//
	//     *   type: the collection type. Set this parameter to file to specify the file type. Set this parameter to stdout to specify the standard output type.
	//
	//     *   logstore: the name of the Logstore. Make sure that the name of the Logstore is unique in the cluster. The name must comply with the following rules:
	//
	//         *   The name can contain only lowercase letters, digits, hyphens (-), and underscores (\_).
	//         *   The name must start and end with a lowercase letter or a digit.
	//         *   The name must be 3 to 63 characters in length. If you leave this parameter empty, the system automatically generates a name.
	//
	//     *   logDir: If the standard output type is used, the collection path is stdout.log. If the file type is used, the collection path is the path of the collected file. Wildcards (\*) are supported. The collection path must match the following regular expression: `^/(.+)/(.*)^/$`.
	SlsConfigs *string `json:"SlsConfigs,omitempty" xml:"SlsConfigs,omitempty"`
	Startup    *string `json:"Startup,omitempty" xml:"Startup,omitempty"`
	// The storage type of the NAS file system.
	//
	// *   Valid values for General-purpose NAS file systems: Capacity and Performance.
	// *   Valid values for Extreme NAS file systems: standard and advance.
	//
	// You can set this parameter only to Performance.
	StorageType          *string `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
	TerminateGracePeriod *int32  `json:"TerminateGracePeriod,omitempty" xml:"TerminateGracePeriod,omitempty"`
	// The traffic adjustment policy for a canary release.
	TrafficControlStrategy *string `json:"TrafficControlStrategy,omitempty" xml:"TrafficControlStrategy,omitempty"`
	// The phased release policy.
	//
	// *   Example 1: One instance for a canary release + Two subsequent batches + Automatic batching + 1-minute batch interval.
	//
	// `{"type":"GrayBatchUpdate","batchUpdate":{"batch":2,"releaseType":"auto","batchWaitTime":1},"grayUpdate":{"gray":1}}`
	//
	// *   Example 2: One instance for a canary release + Two subsequent batches + Manual batching.
	//
	// `{"type":"GrayBatchUpdate","batchUpdate":{"batch":2,"releaseType":"manual"},"grayUpdate":{"gray":1}}`
	//
	// *   Example 3: Two batches + Automatic batching + 0-minute batch interval.
	//
	// `{"type":"BatchUpdate","batchUpdate":{"batch":2,"releaseType":"auto","batchWaitTime":0}}`
	UpdateStrategy *string `json:"UpdateStrategy,omitempty" xml:"UpdateStrategy,omitempty"`
	// The URI encoding scheme. Valid values: ISO-8859-1, GBK, GB2312, and UTF-8.
	//
	// > If you do not specify this parameter in the application configurations, the default URI encoding scheme in the Tomcat container is applied.
	UriEncoding *string `json:"UriEncoding,omitempty" xml:"UriEncoding,omitempty"`
	// Specifies whether to use the encoding scheme specified in the request body for URI query parameters.
	//
	// > If this parameter is not specified in application configuration, the default value false is applied.
	UseBodyEncoding  *bool   `json:"UseBodyEncoding,omitempty" xml:"UseBodyEncoding,omitempty"`
	UserBaseImageUrl *string `json:"UserBaseImageUrl,omitempty" xml:"UserBaseImageUrl,omitempty"`
	// The data volume.
	VolumesStr *string `json:"VolumesStr,omitempty" xml:"VolumesStr,omitempty"`
	// The version of the Tomcat container on which the deployment package of the application depends. This parameter is applicable to Spring Cloud and Dubbo applications that you deploy by using WAR packages. This parameter is unavailable if you deploy applications by using images.
	WebContainer *string `json:"WebContainer,omitempty" xml:"WebContainer,omitempty"`
	// The Tomcat container configuration. If you want to cancel this configuration, set this parameter to `""` or `"{}"`. The following parameters are included in the configuration:
	//
	// *   useDefaultConfig: specifies whether to use the default configuration. Value true indicates to use the default configuration. Value false indicates to use the custom configuration. If the default configuration is used, the following parameters do not take effect.
	//
	// *   contextInputType: the type of the access path for the application. Valid values:
	//
	//     *   war: The access path for the application is the name of the WAR package. You do not need to specify a custom path.
	//     *   root: The access path for the application is /. You do not need to specify a custom path.
	//     *   custom: If you select this option, you must specify a custom path for the contextPath parameter.
	//
	// *   contextPath: the custom access path for the application. This parameter is required only when you set the contextInputType parameter to custom.
	//
	// *   httpPort: the port number. The port number ranges from 1024 to 65535. Though the admin permissions are configured for the container, the root permissions are required to perform operations on ports whose number is less than 1024. Enter a value that ranges from 1025 to 65535 because the container has only the admin permissions. If you do not configure this parameter, the default port number 8080 is used.
	//
	// *   maxThreads: the maximum number of connections in the connection pool. Default value: 400.
	//
	//     **
	//
	//     **Note**This parameter greatly affects the application performance. We recommend that you set this parameter under professional guidance.
	//
	// *   uriEncoding: the URI encoding scheme in the Tomcat container. Valid values: UTF-8, ISO-8859-1, GBK, and GB2312. If you do not specify this parameter, the default value ISO-8859-1 is used.
	//
	// *   useBodyEncoding: specifies whether to use the encoding scheme specified in the request body for URI query parameters.
	//
	// *   useAdvancedServerXml: specifies whether to use advanced configurations to customize the `server.xml` file. If the preceding parameter types and specific parameters cannot meet your requirements, you can use advanced configurations to customize the `server.xml` file of Tomcat.
	//
	// *   serverXml: the content of the `server.xml` file customized by using advanced configurations. This parameter takes effect only when you set the useAdvancedServerXml parameter to true.
	WebContainerConfig *string `json:"WebContainerConfig,omitempty" xml:"WebContainerConfig,omitempty"`
}

func (s DeployK8sApplicationRequest) String() string {
	return tea.Prettify(s)
}

func (s DeployK8sApplicationRequest) GoString() string {
	return s.String()
}

func (s *DeployK8sApplicationRequest) SetAnnotations(v string) *DeployK8sApplicationRequest {
	s.Annotations = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetAppId(v string) *DeployK8sApplicationRequest {
	s.AppId = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetArgs(v string) *DeployK8sApplicationRequest {
	s.Args = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetBatchTimeout(v int32) *DeployK8sApplicationRequest {
	s.BatchTimeout = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetBatchWaitTime(v int32) *DeployK8sApplicationRequest {
	s.BatchWaitTime = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetBuildPackId(v string) *DeployK8sApplicationRequest {
	s.BuildPackId = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetCanaryRuleId(v string) *DeployK8sApplicationRequest {
	s.CanaryRuleId = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetChangeOrderDesc(v string) *DeployK8sApplicationRequest {
	s.ChangeOrderDesc = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetCommand(v string) *DeployK8sApplicationRequest {
	s.Command = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetConfigMountDescs(v string) *DeployK8sApplicationRequest {
	s.ConfigMountDescs = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetCpuLimit(v int32) *DeployK8sApplicationRequest {
	s.CpuLimit = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetCpuRequest(v int32) *DeployK8sApplicationRequest {
	s.CpuRequest = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetCustomAffinity(v string) *DeployK8sApplicationRequest {
	s.CustomAffinity = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetCustomAgentVersion(v string) *DeployK8sApplicationRequest {
	s.CustomAgentVersion = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetCustomTolerations(v string) *DeployK8sApplicationRequest {
	s.CustomTolerations = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetDeployAcrossNodes(v string) *DeployK8sApplicationRequest {
	s.DeployAcrossNodes = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetDeployAcrossZones(v string) *DeployK8sApplicationRequest {
	s.DeployAcrossZones = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetEdasContainerVersion(v string) *DeployK8sApplicationRequest {
	s.EdasContainerVersion = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetEmptyDirs(v string) *DeployK8sApplicationRequest {
	s.EmptyDirs = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetEnableAhas(v bool) *DeployK8sApplicationRequest {
	s.EnableAhas = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetEnableEmptyPushReject(v bool) *DeployK8sApplicationRequest {
	s.EnableEmptyPushReject = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetEnableLosslessRule(v bool) *DeployK8sApplicationRequest {
	s.EnableLosslessRule = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetEnvFroms(v string) *DeployK8sApplicationRequest {
	s.EnvFroms = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetEnvs(v string) *DeployK8sApplicationRequest {
	s.Envs = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetImage(v string) *DeployK8sApplicationRequest {
	s.Image = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetImagePlatforms(v string) *DeployK8sApplicationRequest {
	s.ImagePlatforms = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetImageTag(v string) *DeployK8sApplicationRequest {
	s.ImageTag = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetInitContainers(v string) *DeployK8sApplicationRequest {
	s.InitContainers = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetJDK(v string) *DeployK8sApplicationRequest {
	s.JDK = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetJavaStartUpConfig(v string) *DeployK8sApplicationRequest {
	s.JavaStartUpConfig = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetLabels(v string) *DeployK8sApplicationRequest {
	s.Labels = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetLimitEphemeralStorage(v int32) *DeployK8sApplicationRequest {
	s.LimitEphemeralStorage = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetLiveness(v string) *DeployK8sApplicationRequest {
	s.Liveness = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetLocalVolume(v string) *DeployK8sApplicationRequest {
	s.LocalVolume = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetLosslessRuleAligned(v bool) *DeployK8sApplicationRequest {
	s.LosslessRuleAligned = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetLosslessRuleDelayTime(v int32) *DeployK8sApplicationRequest {
	s.LosslessRuleDelayTime = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetLosslessRuleFuncType(v int32) *DeployK8sApplicationRequest {
	s.LosslessRuleFuncType = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetLosslessRuleRelated(v bool) *DeployK8sApplicationRequest {
	s.LosslessRuleRelated = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetLosslessRuleWarmupTime(v int32) *DeployK8sApplicationRequest {
	s.LosslessRuleWarmupTime = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetMcpuLimit(v int32) *DeployK8sApplicationRequest {
	s.McpuLimit = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetMcpuRequest(v int32) *DeployK8sApplicationRequest {
	s.McpuRequest = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetMemoryLimit(v int32) *DeployK8sApplicationRequest {
	s.MemoryLimit = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetMemoryRequest(v int32) *DeployK8sApplicationRequest {
	s.MemoryRequest = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetMountDescs(v string) *DeployK8sApplicationRequest {
	s.MountDescs = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetNasId(v string) *DeployK8sApplicationRequest {
	s.NasId = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetPackageUrl(v string) *DeployK8sApplicationRequest {
	s.PackageUrl = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetPackageVersion(v string) *DeployK8sApplicationRequest {
	s.PackageVersion = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetPackageVersionId(v string) *DeployK8sApplicationRequest {
	s.PackageVersionId = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetPostStart(v string) *DeployK8sApplicationRequest {
	s.PostStart = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetPreStop(v string) *DeployK8sApplicationRequest {
	s.PreStop = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetPvcMountDescs(v string) *DeployK8sApplicationRequest {
	s.PvcMountDescs = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetReadiness(v string) *DeployK8sApplicationRequest {
	s.Readiness = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetReplicas(v int32) *DeployK8sApplicationRequest {
	s.Replicas = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetRequestsEphemeralStorage(v int32) *DeployK8sApplicationRequest {
	s.RequestsEphemeralStorage = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetRuntimeClassName(v string) *DeployK8sApplicationRequest {
	s.RuntimeClassName = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetSidecars(v string) *DeployK8sApplicationRequest {
	s.Sidecars = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetSlsConfigs(v string) *DeployK8sApplicationRequest {
	s.SlsConfigs = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetStartup(v string) *DeployK8sApplicationRequest {
	s.Startup = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetStorageType(v string) *DeployK8sApplicationRequest {
	s.StorageType = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetTerminateGracePeriod(v int32) *DeployK8sApplicationRequest {
	s.TerminateGracePeriod = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetTrafficControlStrategy(v string) *DeployK8sApplicationRequest {
	s.TrafficControlStrategy = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetUpdateStrategy(v string) *DeployK8sApplicationRequest {
	s.UpdateStrategy = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetUriEncoding(v string) *DeployK8sApplicationRequest {
	s.UriEncoding = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetUseBodyEncoding(v bool) *DeployK8sApplicationRequest {
	s.UseBodyEncoding = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetUserBaseImageUrl(v string) *DeployK8sApplicationRequest {
	s.UserBaseImageUrl = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetVolumesStr(v string) *DeployK8sApplicationRequest {
	s.VolumesStr = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetWebContainer(v string) *DeployK8sApplicationRequest {
	s.WebContainer = &v
	return s
}

func (s *DeployK8sApplicationRequest) SetWebContainerConfig(v string) *DeployK8sApplicationRequest {
	s.WebContainerConfig = &v
	return s
}

type DeployK8sApplicationResponseBody struct {
	// The ID of the change process. You can call the GetChangeOrderInfo operation to query the change process ID. For more information, see [GetChangeOrderInfo](~~62072~~).
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeployK8sApplicationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeployK8sApplicationResponseBody) GoString() string {
	return s.String()
}

func (s *DeployK8sApplicationResponseBody) SetChangeOrderId(v string) *DeployK8sApplicationResponseBody {
	s.ChangeOrderId = &v
	return s
}

func (s *DeployK8sApplicationResponseBody) SetCode(v int32) *DeployK8sApplicationResponseBody {
	s.Code = &v
	return s
}

func (s *DeployK8sApplicationResponseBody) SetMessage(v string) *DeployK8sApplicationResponseBody {
	s.Message = &v
	return s
}

func (s *DeployK8sApplicationResponseBody) SetRequestId(v string) *DeployK8sApplicationResponseBody {
	s.RequestId = &v
	return s
}

type DeployK8sApplicationResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeployK8sApplicationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeployK8sApplicationResponse) String() string {
	return tea.Prettify(s)
}

func (s DeployK8sApplicationResponse) GoString() string {
	return s.String()
}

func (s *DeployK8sApplicationResponse) SetHeaders(v map[string]*string) *DeployK8sApplicationResponse {
	s.Headers = v
	return s
}

func (s *DeployK8sApplicationResponse) SetStatusCode(v int32) *DeployK8sApplicationResponse {
	s.StatusCode = &v
	return s
}

func (s *DeployK8sApplicationResponse) SetBody(v *DeployK8sApplicationResponseBody) *DeployK8sApplicationResponse {
	s.Body = v
	return s
}

type DescribeAppInstanceListRequest struct {
	// The ID of the application. You can call the ListApplication operation to query the ID of the application. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// Specifies whether to return the information about the node in which the pod resides.
	//
	// *   `true`: returns the information about the node in which the pod resides
	// *   `false`: does not return the information about the node in which the pod resides
	WithNodeInfo *bool `json:"WithNodeInfo,omitempty" xml:"WithNodeInfo,omitempty"`
}

func (s DescribeAppInstanceListRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeAppInstanceListRequest) GoString() string {
	return s.String()
}

func (s *DescribeAppInstanceListRequest) SetAppId(v string) *DescribeAppInstanceListRequest {
	s.AppId = &v
	return s
}

func (s *DescribeAppInstanceListRequest) SetWithNodeInfo(v bool) *DescribeAppInstanceListRequest {
	s.WithNodeInfo = &v
	return s
}

type DescribeAppInstanceListResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The application instances.
	InstanceList []*DescribeAppInstanceListResponseBodyInstanceList `json:"InstanceList,omitempty" xml:"InstanceList,omitempty" type:"Repeated"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeAppInstanceListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeAppInstanceListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAppInstanceListResponseBody) SetCode(v int32) *DescribeAppInstanceListResponseBody {
	s.Code = &v
	return s
}

func (s *DescribeAppInstanceListResponseBody) SetInstanceList(v []*DescribeAppInstanceListResponseBodyInstanceList) *DescribeAppInstanceListResponseBody {
	s.InstanceList = v
	return s
}

func (s *DescribeAppInstanceListResponseBody) SetMessage(v string) *DescribeAppInstanceListResponseBody {
	s.Message = &v
	return s
}

func (s *DescribeAppInstanceListResponseBody) SetRequestId(v string) *DescribeAppInstanceListResponseBody {
	s.RequestId = &v
	return s
}

type DescribeAppInstanceListResponseBodyInstanceList struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// Indicates whether the application was released in canary release mode.
	//
	// *   `true`: The application was released in canary release mode.
	// *   `false`: The application was not released in canary release mode
	Canary *bool `json:"Canary,omitempty" xml:"Canary,omitempty"`
	// The ID of the instance group to which the application is deployed.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the instance group to which the application is deployed.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The labels of the node. The value is a JSON string.
	NodeLabels *string `json:"NodeLabels,omitempty" xml:"NodeLabels,omitempty"`
	// The name of the node.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The information about the pod. The value is a JSON string.
	PodRaw *string `json:"PodRaw,omitempty" xml:"PodRaw,omitempty"`
	// The deployment package version of the node.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s DescribeAppInstanceListResponseBodyInstanceList) String() string {
	return tea.Prettify(s)
}

func (s DescribeAppInstanceListResponseBodyInstanceList) GoString() string {
	return s.String()
}

func (s *DescribeAppInstanceListResponseBodyInstanceList) SetAppId(v string) *DescribeAppInstanceListResponseBodyInstanceList {
	s.AppId = &v
	return s
}

func (s *DescribeAppInstanceListResponseBodyInstanceList) SetCanary(v bool) *DescribeAppInstanceListResponseBodyInstanceList {
	s.Canary = &v
	return s
}

func (s *DescribeAppInstanceListResponseBodyInstanceList) SetGroupId(v string) *DescribeAppInstanceListResponseBodyInstanceList {
	s.GroupId = &v
	return s
}

func (s *DescribeAppInstanceListResponseBodyInstanceList) SetGroupName(v string) *DescribeAppInstanceListResponseBodyInstanceList {
	s.GroupName = &v
	return s
}

func (s *DescribeAppInstanceListResponseBodyInstanceList) SetNodeLabels(v string) *DescribeAppInstanceListResponseBodyInstanceList {
	s.NodeLabels = &v
	return s
}

func (s *DescribeAppInstanceListResponseBodyInstanceList) SetNodeName(v string) *DescribeAppInstanceListResponseBodyInstanceList {
	s.NodeName = &v
	return s
}

func (s *DescribeAppInstanceListResponseBodyInstanceList) SetPodRaw(v string) *DescribeAppInstanceListResponseBodyInstanceList {
	s.PodRaw = &v
	return s
}

func (s *DescribeAppInstanceListResponseBodyInstanceList) SetVersion(v string) *DescribeAppInstanceListResponseBodyInstanceList {
	s.Version = &v
	return s
}

type DescribeAppInstanceListResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeAppInstanceListResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeAppInstanceListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeAppInstanceListResponse) GoString() string {
	return s.String()
}

func (s *DescribeAppInstanceListResponse) SetHeaders(v map[string]*string) *DescribeAppInstanceListResponse {
	s.Headers = v
	return s
}

func (s *DescribeAppInstanceListResponse) SetStatusCode(v int32) *DescribeAppInstanceListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAppInstanceListResponse) SetBody(v *DescribeAppInstanceListResponseBody) *DescribeAppInstanceListResponse {
	s.Body = v
	return s
}

type DescribeApplicationScalingRulesRequest struct {
	// The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
}

func (s DescribeApplicationScalingRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeApplicationScalingRulesRequest) GoString() string {
	return s.String()
}

func (s *DescribeApplicationScalingRulesRequest) SetAppId(v string) *DescribeApplicationScalingRulesRequest {
	s.AppId = &v
	return s
}

type DescribeApplicationScalingRulesResponseBody struct {
	// The auto scaling policies of the application.
	AppScalingRules *DescribeApplicationScalingRulesResponseBodyAppScalingRules `json:"AppScalingRules,omitempty" xml:"AppScalingRules,omitempty" type:"Struct"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeApplicationScalingRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeApplicationScalingRulesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeApplicationScalingRulesResponseBody) SetAppScalingRules(v *DescribeApplicationScalingRulesResponseBodyAppScalingRules) *DescribeApplicationScalingRulesResponseBody {
	s.AppScalingRules = v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBody) SetCode(v int32) *DescribeApplicationScalingRulesResponseBody {
	s.Code = &v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBody) SetMessage(v string) *DescribeApplicationScalingRulesResponseBody {
	s.Message = &v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBody) SetRequestId(v string) *DescribeApplicationScalingRulesResponseBody {
	s.RequestId = &v
	return s
}

type DescribeApplicationScalingRulesResponseBodyAppScalingRules struct {
	// The page number of the returned page.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The number of auto scaling policies returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The information about auto scaling policies.
	Result []*DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// The total number of auto scaling policies.
	TotalSize *int64 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s DescribeApplicationScalingRulesResponseBodyAppScalingRules) String() string {
	return tea.Prettify(s)
}

func (s DescribeApplicationScalingRulesResponseBodyAppScalingRules) GoString() string {
	return s.String()
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRules) SetCurrentPage(v int32) *DescribeApplicationScalingRulesResponseBodyAppScalingRules {
	s.CurrentPage = &v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRules) SetPageSize(v int32) *DescribeApplicationScalingRulesResponseBodyAppScalingRules {
	s.PageSize = &v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRules) SetResult(v []*DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult) *DescribeApplicationScalingRulesResponseBodyAppScalingRules {
	s.Result = v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRules) SetTotalSize(v int64) *DescribeApplicationScalingRulesResponseBodyAppScalingRules {
	s.TotalSize = &v
	return s
}

type DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult struct {
	// The ID of the application to which the auto scaling policy belongs.
	AppId     *string                                                                    `json:"AppId,omitempty" xml:"AppId,omitempty"`
	Behaviour *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviour `json:"Behaviour,omitempty" xml:"Behaviour,omitempty" type:"Struct"`
	// The time when the auto scaling policy was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The time when the auto scaling policy was last disabled. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	LastDisableTime *int64 `json:"LastDisableTime,omitempty" xml:"LastDisableTime,omitempty"`
	// This parameter is deprecated.
	MaxReplicas *int32 `json:"MaxReplicas,omitempty" xml:"MaxReplicas,omitempty"`
	// This parameter is deprecated.
	Metric *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetric `json:"Metric,omitempty" xml:"Metric,omitempty" type:"Struct"`
	// This parameter is deprecated.
	MinReplicas *int32 `json:"MinReplicas,omitempty" xml:"MinReplicas,omitempty"`
	// Indicates whether the auto scaling policy is enabled. Valid values:
	//
	// *   **true**: The auto scaling policy is enabled.
	// *   **false**: The auto scaling policy is disabled.
	ScaleRuleEnabled *bool `json:"ScaleRuleEnabled,omitempty" xml:"ScaleRuleEnabled,omitempty"`
	// The name of the auto scaling policy.
	ScaleRuleName *string `json:"ScaleRuleName,omitempty" xml:"ScaleRuleName,omitempty"`
	// The type of the auto scaling policy. The value is fixed to trigger.
	ScaleRuleType *string `json:"ScaleRuleType,omitempty" xml:"ScaleRuleType,omitempty"`
	// The configurations of the trigger.
	Trigger *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTrigger `json:"Trigger,omitempty" xml:"Trigger,omitempty" type:"Struct"`
	// The time when the auto scaling policy was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult) String() string {
	return tea.Prettify(s)
}

func (s DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult) GoString() string {
	return s.String()
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult) SetAppId(v string) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult {
	s.AppId = &v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult) SetBehaviour(v *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviour) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult {
	s.Behaviour = v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult) SetCreateTime(v int64) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult {
	s.CreateTime = &v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult) SetLastDisableTime(v int64) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult {
	s.LastDisableTime = &v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult) SetMaxReplicas(v int32) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult {
	s.MaxReplicas = &v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult) SetMetric(v *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetric) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult {
	s.Metric = v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult) SetMinReplicas(v int32) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult {
	s.MinReplicas = &v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult) SetScaleRuleEnabled(v bool) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult {
	s.ScaleRuleEnabled = &v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult) SetScaleRuleName(v string) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult {
	s.ScaleRuleName = &v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult) SetScaleRuleType(v string) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult {
	s.ScaleRuleType = &v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult) SetTrigger(v *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTrigger) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult {
	s.Trigger = v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult) SetUpdateTime(v int64) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResult {
	s.UpdateTime = &v
	return s
}

type DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviour struct {
	ScaleDown *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDown `json:"ScaleDown,omitempty" xml:"ScaleDown,omitempty" type:"Struct"`
	ScaleUp   *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUp   `json:"ScaleUp,omitempty" xml:"ScaleUp,omitempty" type:"Struct"`
}

func (s DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviour) String() string {
	return tea.Prettify(s)
}

func (s DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviour) GoString() string {
	return s.String()
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviour) SetScaleDown(v *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDown) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviour {
	s.ScaleDown = v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviour) SetScaleUp(v *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUp) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviour {
	s.ScaleUp = v
	return s
}

type DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDown struct {
	Policies                   []*DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDownPolicies `json:"Policies,omitempty" xml:"Policies,omitempty" type:"Repeated"`
	SelectPolicy               *string                                                                                       `json:"SelectPolicy,omitempty" xml:"SelectPolicy,omitempty"`
	StabilizationWindowSeconds *int32                                                                                        `json:"StabilizationWindowSeconds,omitempty" xml:"StabilizationWindowSeconds,omitempty"`
}

func (s DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDown) String() string {
	return tea.Prettify(s)
}

func (s DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDown) GoString() string {
	return s.String()
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDown) SetPolicies(v []*DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDownPolicies) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDown {
	s.Policies = v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDown) SetSelectPolicy(v string) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDown {
	s.SelectPolicy = &v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDown) SetStabilizationWindowSeconds(v int32) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDown {
	s.StabilizationWindowSeconds = &v
	return s
}

type DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDownPolicies struct {
	PeriodSeconds *int32  `json:"PeriodSeconds,omitempty" xml:"PeriodSeconds,omitempty"`
	Type          *string `json:"Type,omitempty" xml:"Type,omitempty"`
	Value         *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDownPolicies) String() string {
	return tea.Prettify(s)
}

func (s DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDownPolicies) GoString() string {
	return s.String()
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDownPolicies) SetPeriodSeconds(v int32) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDownPolicies {
	s.PeriodSeconds = &v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDownPolicies) SetType(v string) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDownPolicies {
	s.Type = &v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDownPolicies) SetValue(v string) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleDownPolicies {
	s.Value = &v
	return s
}

type DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUp struct {
	Policies                   []*DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUpPolicies `json:"Policies,omitempty" xml:"Policies,omitempty" type:"Repeated"`
	SelectPolicy               *string                                                                                     `json:"SelectPolicy,omitempty" xml:"SelectPolicy,omitempty"`
	StabilizationWindowSeconds *int32                                                                                      `json:"StabilizationWindowSeconds,omitempty" xml:"StabilizationWindowSeconds,omitempty"`
}

func (s DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUp) String() string {
	return tea.Prettify(s)
}

func (s DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUp) GoString() string {
	return s.String()
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUp) SetPolicies(v []*DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUpPolicies) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUp {
	s.Policies = v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUp) SetSelectPolicy(v string) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUp {
	s.SelectPolicy = &v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUp) SetStabilizationWindowSeconds(v int32) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUp {
	s.StabilizationWindowSeconds = &v
	return s
}

type DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUpPolicies struct {
	PeriodSeconds *int32  `json:"PeriodSeconds,omitempty" xml:"PeriodSeconds,omitempty"`
	Type          *string `json:"Type,omitempty" xml:"Type,omitempty"`
	Value         *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUpPolicies) String() string {
	return tea.Prettify(s)
}

func (s DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUpPolicies) GoString() string {
	return s.String()
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUpPolicies) SetPeriodSeconds(v int32) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUpPolicies {
	s.PeriodSeconds = &v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUpPolicies) SetType(v string) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUpPolicies {
	s.Type = &v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUpPolicies) SetValue(v string) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultBehaviourScaleUpPolicies {
	s.Value = &v
	return s
}

type DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetric struct {
	// This parameter is deprecated.
	MaxReplicas *int32 `json:"MaxReplicas,omitempty" xml:"MaxReplicas,omitempty"`
	// This parameter is deprecated.
	Metrics []*DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetricMetrics `json:"Metrics,omitempty" xml:"Metrics,omitempty" type:"Repeated"`
	// This parameter is deprecated.
	MinReplicas *int32 `json:"MinReplicas,omitempty" xml:"MinReplicas,omitempty"`
}

func (s DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetric) String() string {
	return tea.Prettify(s)
}

func (s DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetric) GoString() string {
	return s.String()
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetric) SetMaxReplicas(v int32) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetric {
	s.MaxReplicas = &v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetric) SetMetrics(v []*DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetricMetrics) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetric {
	s.Metrics = v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetric) SetMinReplicas(v int32) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetric {
	s.MinReplicas = &v
	return s
}

type DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetricMetrics struct {
	// This parameter is deprecated.
	MetricTargetAverageUtilization *int32 `json:"MetricTargetAverageUtilization,omitempty" xml:"MetricTargetAverageUtilization,omitempty"`
	// This parameter is deprecated.
	MetricType *string `json:"MetricType,omitempty" xml:"MetricType,omitempty"`
}

func (s DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetricMetrics) String() string {
	return tea.Prettify(s)
}

func (s DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetricMetrics) GoString() string {
	return s.String()
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetricMetrics) SetMetricTargetAverageUtilization(v int32) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetricMetrics {
	s.MetricTargetAverageUtilization = &v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetricMetrics) SetMetricType(v string) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultMetricMetrics {
	s.MetricType = &v
	return s
}

type DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTrigger struct {
	// The maximum number of replicas. The upper limit is 1000.
	MaxReplicas *int32 `json:"MaxReplicas,omitempty" xml:"MaxReplicas,omitempty"`
	// The minimum number of replicas. The lower limit is 0.
	MinReplicas *int32 `json:"MinReplicas,omitempty" xml:"MinReplicas,omitempty"`
	// The configurations of the trigger.
	Triggers []*DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTriggerTriggers `json:"Triggers,omitempty" xml:"Triggers,omitempty" type:"Repeated"`
}

func (s DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTrigger) String() string {
	return tea.Prettify(s)
}

func (s DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTrigger) GoString() string {
	return s.String()
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTrigger) SetMaxReplicas(v int32) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTrigger {
	s.MaxReplicas = &v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTrigger) SetMinReplicas(v int32) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTrigger {
	s.MinReplicas = &v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTrigger) SetTriggers(v []*DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTriggerTriggers) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTrigger {
	s.Triggers = v
	return s
}

type DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTriggerTriggers struct {
	// The metadata of the trigger.
	MetaData *string `json:"MetaData,omitempty" xml:"MetaData,omitempty"`
	// The name of the trigger.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of the trigger. Valid values: cron and app_metric.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTriggerTriggers) String() string {
	return tea.Prettify(s)
}

func (s DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTriggerTriggers) GoString() string {
	return s.String()
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTriggerTriggers) SetMetaData(v string) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTriggerTriggers {
	s.MetaData = &v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTriggerTriggers) SetName(v string) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTriggerTriggers {
	s.Name = &v
	return s
}

func (s *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTriggerTriggers) SetType(v string) *DescribeApplicationScalingRulesResponseBodyAppScalingRulesResultTriggerTriggers {
	s.Type = &v
	return s
}

type DescribeApplicationScalingRulesResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeApplicationScalingRulesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeApplicationScalingRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeApplicationScalingRulesResponse) GoString() string {
	return s.String()
}

func (s *DescribeApplicationScalingRulesResponse) SetHeaders(v map[string]*string) *DescribeApplicationScalingRulesResponse {
	s.Headers = v
	return s
}

func (s *DescribeApplicationScalingRulesResponse) SetStatusCode(v int32) *DescribeApplicationScalingRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeApplicationScalingRulesResponse) SetBody(v *DescribeApplicationScalingRulesResponseBody) *DescribeApplicationScalingRulesResponse {
	s.Body = v
	return s
}

type DisableApplicationScalingRuleRequest struct {
	// The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the auto scaling policy.
	ScalingRuleName *string `json:"ScalingRuleName,omitempty" xml:"ScalingRuleName,omitempty"`
}

func (s DisableApplicationScalingRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s DisableApplicationScalingRuleRequest) GoString() string {
	return s.String()
}

func (s *DisableApplicationScalingRuleRequest) SetAppId(v string) *DisableApplicationScalingRuleRequest {
	s.AppId = &v
	return s
}

func (s *DisableApplicationScalingRuleRequest) SetScalingRuleName(v string) *DisableApplicationScalingRuleRequest {
	s.ScalingRuleName = &v
	return s
}

type DisableApplicationScalingRuleResponseBody struct {
	// The information about the auto scaling policy.
	AppScalingRule *DisableApplicationScalingRuleResponseBodyAppScalingRule `json:"AppScalingRule,omitempty" xml:"AppScalingRule,omitempty" type:"Struct"`
	// The HTTP status code.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DisableApplicationScalingRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DisableApplicationScalingRuleResponseBody) GoString() string {
	return s.String()
}

func (s *DisableApplicationScalingRuleResponseBody) SetAppScalingRule(v *DisableApplicationScalingRuleResponseBodyAppScalingRule) *DisableApplicationScalingRuleResponseBody {
	s.AppScalingRule = v
	return s
}

func (s *DisableApplicationScalingRuleResponseBody) SetCode(v int32) *DisableApplicationScalingRuleResponseBody {
	s.Code = &v
	return s
}

func (s *DisableApplicationScalingRuleResponseBody) SetMessage(v string) *DisableApplicationScalingRuleResponseBody {
	s.Message = &v
	return s
}

func (s *DisableApplicationScalingRuleResponseBody) SetRequestId(v string) *DisableApplicationScalingRuleResponseBody {
	s.RequestId = &v
	return s
}

type DisableApplicationScalingRuleResponseBodyAppScalingRule struct {
	// The ID of the application to which the auto scaling policy belongs.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The time when the auto scaling policy was created.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The time when the auto scaling policy was last disabled.
	LastDisableTime *int64 `json:"LastDisableTime,omitempty" xml:"LastDisableTime,omitempty"`
	// This parameter is deprecated.
	MaxReplicas *int32 `json:"MaxReplicas,omitempty" xml:"MaxReplicas,omitempty"`
	// This parameter is deprecated.
	Metric *DisableApplicationScalingRuleResponseBodyAppScalingRuleMetric `json:"Metric,omitempty" xml:"Metric,omitempty" type:"Struct"`
	// This parameter is deprecated.
	MinReplicas *int32 `json:"MinReplicas,omitempty" xml:"MinReplicas,omitempty"`
	// Indicates whether the auto scaling policy is enabled. Valid values:
	//
	// *   **true**: The auto scaling policy is enabled.
	// *   **false**: The auto scaling policy is disabled.
	ScaleRuleEnabled *bool `json:"ScaleRuleEnabled,omitempty" xml:"ScaleRuleEnabled,omitempty"`
	// The name of the auto scaling policy.
	ScaleRuleName *string `json:"ScaleRuleName,omitempty" xml:"ScaleRuleName,omitempty"`
	// The type of the auto scaling policy. The value is fixed to trigger.
	ScaleRuleType *string `json:"ScaleRuleType,omitempty" xml:"ScaleRuleType,omitempty"`
	// The configurations of the trigger.
	Trigger *DisableApplicationScalingRuleResponseBodyAppScalingRuleTrigger `json:"Trigger,omitempty" xml:"Trigger,omitempty" type:"Struct"`
	// The time when the auto scaling policy was last modified.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s DisableApplicationScalingRuleResponseBodyAppScalingRule) String() string {
	return tea.Prettify(s)
}

func (s DisableApplicationScalingRuleResponseBodyAppScalingRule) GoString() string {
	return s.String()
}

func (s *DisableApplicationScalingRuleResponseBodyAppScalingRule) SetAppId(v string) *DisableApplicationScalingRuleResponseBodyAppScalingRule {
	s.AppId = &v
	return s
}

func (s *DisableApplicationScalingRuleResponseBodyAppScalingRule) SetCreateTime(v int64) *DisableApplicationScalingRuleResponseBodyAppScalingRule {
	s.CreateTime = &v
	return s
}

func (s *DisableApplicationScalingRuleResponseBodyAppScalingRule) SetLastDisableTime(v int64) *DisableApplicationScalingRuleResponseBodyAppScalingRule {
	s.LastDisableTime = &v
	return s
}

func (s *DisableApplicationScalingRuleResponseBodyAppScalingRule) SetMaxReplicas(v int32) *DisableApplicationScalingRuleResponseBodyAppScalingRule {
	s.MaxReplicas = &v
	return s
}

func (s *DisableApplicationScalingRuleResponseBodyAppScalingRule) SetMetric(v *DisableApplicationScalingRuleResponseBodyAppScalingRuleMetric) *DisableApplicationScalingRuleResponseBodyAppScalingRule {
	s.Metric = v
	return s
}

func (s *DisableApplicationScalingRuleResponseBodyAppScalingRule) SetMinReplicas(v int32) *DisableApplicationScalingRuleResponseBodyAppScalingRule {
	s.MinReplicas = &v
	return s
}

func (s *DisableApplicationScalingRuleResponseBodyAppScalingRule) SetScaleRuleEnabled(v bool) *DisableApplicationScalingRuleResponseBodyAppScalingRule {
	s.ScaleRuleEnabled = &v
	return s
}

func (s *DisableApplicationScalingRuleResponseBodyAppScalingRule) SetScaleRuleName(v string) *DisableApplicationScalingRuleResponseBodyAppScalingRule {
	s.ScaleRuleName = &v
	return s
}

func (s *DisableApplicationScalingRuleResponseBodyAppScalingRule) SetScaleRuleType(v string) *DisableApplicationScalingRuleResponseBodyAppScalingRule {
	s.ScaleRuleType = &v
	return s
}

func (s *DisableApplicationScalingRuleResponseBodyAppScalingRule) SetTrigger(v *DisableApplicationScalingRuleResponseBodyAppScalingRuleTrigger) *DisableApplicationScalingRuleResponseBodyAppScalingRule {
	s.Trigger = v
	return s
}

func (s *DisableApplicationScalingRuleResponseBodyAppScalingRule) SetUpdateTime(v int64) *DisableApplicationScalingRuleResponseBodyAppScalingRule {
	s.UpdateTime = &v
	return s
}

type DisableApplicationScalingRuleResponseBodyAppScalingRuleMetric struct {
	// This parameter is deprecated.
	MaxReplicas *int32 `json:"MaxReplicas,omitempty" xml:"MaxReplicas,omitempty"`
	// This parameter is deprecated.
	Metrics []*DisableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics `json:"Metrics,omitempty" xml:"Metrics,omitempty" type:"Repeated"`
	// This parameter is deprecated.
	MinReplicas *int32 `json:"MinReplicas,omitempty" xml:"MinReplicas,omitempty"`
}

func (s DisableApplicationScalingRuleResponseBodyAppScalingRuleMetric) String() string {
	return tea.Prettify(s)
}

func (s DisableApplicationScalingRuleResponseBodyAppScalingRuleMetric) GoString() string {
	return s.String()
}

func (s *DisableApplicationScalingRuleResponseBodyAppScalingRuleMetric) SetMaxReplicas(v int32) *DisableApplicationScalingRuleResponseBodyAppScalingRuleMetric {
	s.MaxReplicas = &v
	return s
}

func (s *DisableApplicationScalingRuleResponseBodyAppScalingRuleMetric) SetMetrics(v []*DisableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics) *DisableApplicationScalingRuleResponseBodyAppScalingRuleMetric {
	s.Metrics = v
	return s
}

func (s *DisableApplicationScalingRuleResponseBodyAppScalingRuleMetric) SetMinReplicas(v int32) *DisableApplicationScalingRuleResponseBodyAppScalingRuleMetric {
	s.MinReplicas = &v
	return s
}

type DisableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics struct {
	// This parameter is deprecated.
	MetricTargetAverageUtilization *int32 `json:"MetricTargetAverageUtilization,omitempty" xml:"MetricTargetAverageUtilization,omitempty"`
	// This parameter is deprecated.
	MetricType *string `json:"MetricType,omitempty" xml:"MetricType,omitempty"`
}

func (s DisableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics) String() string {
	return tea.Prettify(s)
}

func (s DisableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics) GoString() string {
	return s.String()
}

func (s *DisableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics) SetMetricTargetAverageUtilization(v int32) *DisableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics {
	s.MetricTargetAverageUtilization = &v
	return s
}

func (s *DisableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics) SetMetricType(v string) *DisableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics {
	s.MetricType = &v
	return s
}

type DisableApplicationScalingRuleResponseBodyAppScalingRuleTrigger struct {
	// The maximum number of replicas. The upper limit is 1000.
	MaxReplicas *int32 `json:"MaxReplicas,omitempty" xml:"MaxReplicas,omitempty"`
	// The minimum number of replicas. The lower limit is 0.
	MinReplicas *int32 `json:"MinReplicas,omitempty" xml:"MinReplicas,omitempty"`
	// The information about the trigger.
	Triggers []*DisableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers `json:"Triggers,omitempty" xml:"Triggers,omitempty" type:"Repeated"`
}

func (s DisableApplicationScalingRuleResponseBodyAppScalingRuleTrigger) String() string {
	return tea.Prettify(s)
}

func (s DisableApplicationScalingRuleResponseBodyAppScalingRuleTrigger) GoString() string {
	return s.String()
}

func (s *DisableApplicationScalingRuleResponseBodyAppScalingRuleTrigger) SetMaxReplicas(v int32) *DisableApplicationScalingRuleResponseBodyAppScalingRuleTrigger {
	s.MaxReplicas = &v
	return s
}

func (s *DisableApplicationScalingRuleResponseBodyAppScalingRuleTrigger) SetMinReplicas(v int32) *DisableApplicationScalingRuleResponseBodyAppScalingRuleTrigger {
	s.MinReplicas = &v
	return s
}

func (s *DisableApplicationScalingRuleResponseBodyAppScalingRuleTrigger) SetTriggers(v []*DisableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers) *DisableApplicationScalingRuleResponseBodyAppScalingRuleTrigger {
	s.Triggers = v
	return s
}

type DisableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers struct {
	// The metadata of the trigger.
	MetaData *string `json:"MetaData,omitempty" xml:"MetaData,omitempty"`
	// The name of the trigger.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of the trigger. Valid values: cron and app_metric.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DisableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers) String() string {
	return tea.Prettify(s)
}

func (s DisableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers) GoString() string {
	return s.String()
}

func (s *DisableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers) SetMetaData(v string) *DisableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers {
	s.MetaData = &v
	return s
}

func (s *DisableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers) SetName(v string) *DisableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers {
	s.Name = &v
	return s
}

func (s *DisableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers) SetType(v string) *DisableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers {
	s.Type = &v
	return s
}

type DisableApplicationScalingRuleResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DisableApplicationScalingRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DisableApplicationScalingRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s DisableApplicationScalingRuleResponse) GoString() string {
	return s.String()
}

func (s *DisableApplicationScalingRuleResponse) SetHeaders(v map[string]*string) *DisableApplicationScalingRuleResponse {
	s.Headers = v
	return s
}

func (s *DisableApplicationScalingRuleResponse) SetStatusCode(v int32) *DisableApplicationScalingRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *DisableApplicationScalingRuleResponse) SetBody(v *DisableApplicationScalingRuleResponseBody) *DisableApplicationScalingRuleResponse {
	s.Body = v
	return s
}

type EnableApplicationScalingRuleRequest struct {
	// The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the auto scaling policy.
	ScalingRuleName *string `json:"ScalingRuleName,omitempty" xml:"ScalingRuleName,omitempty"`
}

func (s EnableApplicationScalingRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s EnableApplicationScalingRuleRequest) GoString() string {
	return s.String()
}

func (s *EnableApplicationScalingRuleRequest) SetAppId(v string) *EnableApplicationScalingRuleRequest {
	s.AppId = &v
	return s
}

func (s *EnableApplicationScalingRuleRequest) SetScalingRuleName(v string) *EnableApplicationScalingRuleRequest {
	s.ScalingRuleName = &v
	return s
}

type EnableApplicationScalingRuleResponseBody struct {
	// The information about the auto scaling policy.
	AppScalingRule *EnableApplicationScalingRuleResponseBodyAppScalingRule `json:"AppScalingRule,omitempty" xml:"AppScalingRule,omitempty" type:"Struct"`
	// The HTTP status code.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s EnableApplicationScalingRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EnableApplicationScalingRuleResponseBody) GoString() string {
	return s.String()
}

func (s *EnableApplicationScalingRuleResponseBody) SetAppScalingRule(v *EnableApplicationScalingRuleResponseBodyAppScalingRule) *EnableApplicationScalingRuleResponseBody {
	s.AppScalingRule = v
	return s
}

func (s *EnableApplicationScalingRuleResponseBody) SetCode(v int32) *EnableApplicationScalingRuleResponseBody {
	s.Code = &v
	return s
}

func (s *EnableApplicationScalingRuleResponseBody) SetMessage(v string) *EnableApplicationScalingRuleResponseBody {
	s.Message = &v
	return s
}

func (s *EnableApplicationScalingRuleResponseBody) SetRequestId(v string) *EnableApplicationScalingRuleResponseBody {
	s.RequestId = &v
	return s
}

type EnableApplicationScalingRuleResponseBodyAppScalingRule struct {
	// The ID of the application to which the auto scaling policy belongs.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The time when the auto scaling policy was created.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The time when the auto scaling policy was last disabled.
	LastDisableTime *int64 `json:"LastDisableTime,omitempty" xml:"LastDisableTime,omitempty"`
	// This parameter is deprecated.
	MaxReplicas *int32 `json:"MaxReplicas,omitempty" xml:"MaxReplicas,omitempty"`
	// This parameter is deprecated.
	Metric *EnableApplicationScalingRuleResponseBodyAppScalingRuleMetric `json:"Metric,omitempty" xml:"Metric,omitempty" type:"Struct"`
	// This parameter is deprecated.
	MinReplicas *int32 `json:"MinReplicas,omitempty" xml:"MinReplicas,omitempty"`
	// Indicates whether the auto scaling policy is enabled. Valid values:
	//
	// *   **true**: The auto scaling policy is enabled.
	// *   **false**: The auto scaling policy is disabled.
	ScaleRuleEnabled *bool `json:"ScaleRuleEnabled,omitempty" xml:"ScaleRuleEnabled,omitempty"`
	// The name of the auto scaling policy.
	ScaleRuleName *string `json:"ScaleRuleName,omitempty" xml:"ScaleRuleName,omitempty"`
	// The type of the auto scaling policy. The value is fixed to trigger.
	ScaleRuleType *string `json:"ScaleRuleType,omitempty" xml:"ScaleRuleType,omitempty"`
	// The configurations of the trigger.
	Trigger *EnableApplicationScalingRuleResponseBodyAppScalingRuleTrigger `json:"Trigger,omitempty" xml:"Trigger,omitempty" type:"Struct"`
	// The time when the auto scaling policy was last modified.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s EnableApplicationScalingRuleResponseBodyAppScalingRule) String() string {
	return tea.Prettify(s)
}

func (s EnableApplicationScalingRuleResponseBodyAppScalingRule) GoString() string {
	return s.String()
}

func (s *EnableApplicationScalingRuleResponseBodyAppScalingRule) SetAppId(v string) *EnableApplicationScalingRuleResponseBodyAppScalingRule {
	s.AppId = &v
	return s
}

func (s *EnableApplicationScalingRuleResponseBodyAppScalingRule) SetCreateTime(v int64) *EnableApplicationScalingRuleResponseBodyAppScalingRule {
	s.CreateTime = &v
	return s
}

func (s *EnableApplicationScalingRuleResponseBodyAppScalingRule) SetLastDisableTime(v int64) *EnableApplicationScalingRuleResponseBodyAppScalingRule {
	s.LastDisableTime = &v
	return s
}

func (s *EnableApplicationScalingRuleResponseBodyAppScalingRule) SetMaxReplicas(v int32) *EnableApplicationScalingRuleResponseBodyAppScalingRule {
	s.MaxReplicas = &v
	return s
}

func (s *EnableApplicationScalingRuleResponseBodyAppScalingRule) SetMetric(v *EnableApplicationScalingRuleResponseBodyAppScalingRuleMetric) *EnableApplicationScalingRuleResponseBodyAppScalingRule {
	s.Metric = v
	return s
}

func (s *EnableApplicationScalingRuleResponseBodyAppScalingRule) SetMinReplicas(v int32) *EnableApplicationScalingRuleResponseBodyAppScalingRule {
	s.MinReplicas = &v
	return s
}

func (s *EnableApplicationScalingRuleResponseBodyAppScalingRule) SetScaleRuleEnabled(v bool) *EnableApplicationScalingRuleResponseBodyAppScalingRule {
	s.ScaleRuleEnabled = &v
	return s
}

func (s *EnableApplicationScalingRuleResponseBodyAppScalingRule) SetScaleRuleName(v string) *EnableApplicationScalingRuleResponseBodyAppScalingRule {
	s.ScaleRuleName = &v
	return s
}

func (s *EnableApplicationScalingRuleResponseBodyAppScalingRule) SetScaleRuleType(v string) *EnableApplicationScalingRuleResponseBodyAppScalingRule {
	s.ScaleRuleType = &v
	return s
}

func (s *EnableApplicationScalingRuleResponseBodyAppScalingRule) SetTrigger(v *EnableApplicationScalingRuleResponseBodyAppScalingRuleTrigger) *EnableApplicationScalingRuleResponseBodyAppScalingRule {
	s.Trigger = v
	return s
}

func (s *EnableApplicationScalingRuleResponseBodyAppScalingRule) SetUpdateTime(v int64) *EnableApplicationScalingRuleResponseBodyAppScalingRule {
	s.UpdateTime = &v
	return s
}

type EnableApplicationScalingRuleResponseBodyAppScalingRuleMetric struct {
	// This parameter is deprecated.
	MaxReplicas *int32 `json:"MaxReplicas,omitempty" xml:"MaxReplicas,omitempty"`
	// This parameter is deprecated.
	Metrics []*EnableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics `json:"Metrics,omitempty" xml:"Metrics,omitempty" type:"Repeated"`
	// This parameter is deprecated.
	MinReplicas *int32 `json:"MinReplicas,omitempty" xml:"MinReplicas,omitempty"`
}

func (s EnableApplicationScalingRuleResponseBodyAppScalingRuleMetric) String() string {
	return tea.Prettify(s)
}

func (s EnableApplicationScalingRuleResponseBodyAppScalingRuleMetric) GoString() string {
	return s.String()
}

func (s *EnableApplicationScalingRuleResponseBodyAppScalingRuleMetric) SetMaxReplicas(v int32) *EnableApplicationScalingRuleResponseBodyAppScalingRuleMetric {
	s.MaxReplicas = &v
	return s
}

func (s *EnableApplicationScalingRuleResponseBodyAppScalingRuleMetric) SetMetrics(v []*EnableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics) *EnableApplicationScalingRuleResponseBodyAppScalingRuleMetric {
	s.Metrics = v
	return s
}

func (s *EnableApplicationScalingRuleResponseBodyAppScalingRuleMetric) SetMinReplicas(v int32) *EnableApplicationScalingRuleResponseBodyAppScalingRuleMetric {
	s.MinReplicas = &v
	return s
}

type EnableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics struct {
	// This parameter is deprecated.
	MetricTargetAverageUtilization *int32 `json:"MetricTargetAverageUtilization,omitempty" xml:"MetricTargetAverageUtilization,omitempty"`
	// This parameter is deprecated.
	MetricType *string `json:"MetricType,omitempty" xml:"MetricType,omitempty"`
}

func (s EnableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics) String() string {
	return tea.Prettify(s)
}

func (s EnableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics) GoString() string {
	return s.String()
}

func (s *EnableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics) SetMetricTargetAverageUtilization(v int32) *EnableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics {
	s.MetricTargetAverageUtilization = &v
	return s
}

func (s *EnableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics) SetMetricType(v string) *EnableApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics {
	s.MetricType = &v
	return s
}

type EnableApplicationScalingRuleResponseBodyAppScalingRuleTrigger struct {
	// The maximum number of replicas. The upper limit is 1000.
	MaxReplicas *int32 `json:"MaxReplicas,omitempty" xml:"MaxReplicas,omitempty"`
	// The minimum number of replicas. The lower limit is 0.
	MinReplicas *int32 `json:"MinReplicas,omitempty" xml:"MinReplicas,omitempty"`
	// The list of triggers.
	Triggers []*EnableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers `json:"Triggers,omitempty" xml:"Triggers,omitempty" type:"Repeated"`
}

func (s EnableApplicationScalingRuleResponseBodyAppScalingRuleTrigger) String() string {
	return tea.Prettify(s)
}

func (s EnableApplicationScalingRuleResponseBodyAppScalingRuleTrigger) GoString() string {
	return s.String()
}

func (s *EnableApplicationScalingRuleResponseBodyAppScalingRuleTrigger) SetMaxReplicas(v int32) *EnableApplicationScalingRuleResponseBodyAppScalingRuleTrigger {
	s.MaxReplicas = &v
	return s
}

func (s *EnableApplicationScalingRuleResponseBodyAppScalingRuleTrigger) SetMinReplicas(v int32) *EnableApplicationScalingRuleResponseBodyAppScalingRuleTrigger {
	s.MinReplicas = &v
	return s
}

func (s *EnableApplicationScalingRuleResponseBodyAppScalingRuleTrigger) SetTriggers(v []*EnableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers) *EnableApplicationScalingRuleResponseBodyAppScalingRuleTrigger {
	s.Triggers = v
	return s
}

type EnableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers struct {
	// The metadata of the trigger.
	MetaData *string `json:"MetaData,omitempty" xml:"MetaData,omitempty"`
	// The name of the trigger.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of the trigger. Valid values: cron and app_metric.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s EnableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers) String() string {
	return tea.Prettify(s)
}

func (s EnableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers) GoString() string {
	return s.String()
}

func (s *EnableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers) SetMetaData(v string) *EnableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers {
	s.MetaData = &v
	return s
}

func (s *EnableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers) SetName(v string) *EnableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers {
	s.Name = &v
	return s
}

func (s *EnableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers) SetType(v string) *EnableApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers {
	s.Type = &v
	return s
}

type EnableApplicationScalingRuleResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *EnableApplicationScalingRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s EnableApplicationScalingRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s EnableApplicationScalingRuleResponse) GoString() string {
	return s.String()
}

func (s *EnableApplicationScalingRuleResponse) SetHeaders(v map[string]*string) *EnableApplicationScalingRuleResponse {
	s.Headers = v
	return s
}

func (s *EnableApplicationScalingRuleResponse) SetStatusCode(v int32) *EnableApplicationScalingRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *EnableApplicationScalingRuleResponse) SetBody(v *EnableApplicationScalingRuleResponseBody) *EnableApplicationScalingRuleResponse {
	s.Body = v
	return s
}

type GetAppDeploymentRequest struct {
	// The ID of the application. You can call the ListApplication operation to query the application ID.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
}

func (s GetAppDeploymentRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAppDeploymentRequest) GoString() string {
	return s.String()
}

func (s *GetAppDeploymentRequest) SetAppId(v string) *GetAppDeploymentRequest {
	s.AppId = &v
	return s
}

type GetAppDeploymentResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The information about the Deployment of the application. The value is a JSON string.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetAppDeploymentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAppDeploymentResponseBody) GoString() string {
	return s.String()
}

func (s *GetAppDeploymentResponseBody) SetCode(v int32) *GetAppDeploymentResponseBody {
	s.Code = &v
	return s
}

func (s *GetAppDeploymentResponseBody) SetData(v string) *GetAppDeploymentResponseBody {
	s.Data = &v
	return s
}

func (s *GetAppDeploymentResponseBody) SetMessage(v string) *GetAppDeploymentResponseBody {
	s.Message = &v
	return s
}

func (s *GetAppDeploymentResponseBody) SetRequestId(v string) *GetAppDeploymentResponseBody {
	s.RequestId = &v
	return s
}

type GetAppDeploymentResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetAppDeploymentResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetAppDeploymentResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAppDeploymentResponse) GoString() string {
	return s.String()
}

func (s *GetAppDeploymentResponse) SetHeaders(v map[string]*string) *GetAppDeploymentResponse {
	s.Headers = v
	return s
}

func (s *GetAppDeploymentResponse) SetStatusCode(v int32) *GetAppDeploymentResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAppDeploymentResponse) SetBody(v *GetAppDeploymentResponseBody) *GetAppDeploymentResponse {
	s.Body = v
	return s
}

type GetApplicationRequest struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
}

func (s GetApplicationRequest) String() string {
	return tea.Prettify(s)
}

func (s GetApplicationRequest) GoString() string {
	return s.String()
}

func (s *GetApplicationRequest) SetAppId(v string) *GetApplicationRequest {
	s.AppId = &v
	return s
}

type GetApplicationResponseBody struct {
	// The details of the application.
	Application *GetApplicationResponseBodyApplication `json:"Application,omitempty" xml:"Application,omitempty" type:"Struct"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetApplicationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetApplicationResponseBody) GoString() string {
	return s.String()
}

func (s *GetApplicationResponseBody) SetApplication(v *GetApplicationResponseBodyApplication) *GetApplicationResponseBody {
	s.Application = v
	return s
}

func (s *GetApplicationResponseBody) SetCode(v int32) *GetApplicationResponseBody {
	s.Code = &v
	return s
}

func (s *GetApplicationResponseBody) SetMessage(v string) *GetApplicationResponseBody {
	s.Message = &v
	return s
}

func (s *GetApplicationResponseBody) SetRequestId(v string) *GetApplicationResponseBody {
	s.RequestId = &v
	return s
}

type GetApplicationResponseBodyApplication struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The current status of the Kubernetes application, which is used to determine whether the application is in a stable state. If the application is in an unstable state, related configuration operations are prohibited. Valid values:
	//
	// *   ready: The application is in the ready state and can be changed.
	// *   progressive: The application is being changed.
	// *   pending: The application change is blocked.
	// *   failed: The application fails to be changed.
	//
	// In these states, ready is a stable state and other states are unstable.
	AppPhase *string `json:"AppPhase,omitempty" xml:"AppPhase,omitempty"`
	// The deployment type of the application. Valid values:
	//
	// *   War: The application is deployed by using a WAR package.
	// *   FatJar: The application is deployed by using a JAR package.
	// *   Empty: The application is not deployed.
	ApplicationType *string `json:"ApplicationType,omitempty" xml:"ApplicationType,omitempty"`
	// The build package number of Enterprise Distributed Application Service (EDAS) Container.
	BuildPackageId *int64 `json:"BuildPackageId,omitempty" xml:"BuildPackageId,omitempty"`
	// The ID of the ECS cluster in which the application is deployed.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The type of the cluster. Valid values:
	//
	// *   0: regular Docker cluster
	// *   1: Swarm cluster
	// *   2: ECS cluster
	// *   3: Kubernetes cluster
	// *   4: cluster in which Pandora automatically registers applications
	ClusterType *string `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The number of CPU cores.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The time when the application was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The description of the application.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether the application is a Docker application. Valid values:
	//
	// *   false: The application is not a Docker application.
	// *   true: The application is a Docker application.
	Dockerize *bool `json:"Dockerize,omitempty" xml:"Dockerize,omitempty"`
	// The email address of the account.
	Email *string `json:"Email,omitempty" xml:"Email,omitempty"`
	// Indicates whether the port health check is enabled. Valid values:
	//
	// *   true: The port health check is enabled.
	// *   false: The port health check is disabled.
	//
	// If the port health check is enabled, EDAS checks whether a port exists during application startup. If the port exists, the application is considered to have started.
	EnablePortCheck *bool `json:"EnablePortCheck,omitempty" xml:"EnablePortCheck,omitempty"`
	// Indicates whether the URL health check is enabled. Valid values:
	//
	// *   true: The URL health check is enabled.
	// *   false: The URL health check is disabled.
	//
	// If the URL health check is enabled, EDAS attempts to detect the specified URL during application startup. If EDAS detects the specified URL, the application is considered to have started.
	EnableUrlCheck *bool `json:"EnableUrlCheck,omitempty" xml:"EnableUrlCheck,omitempty"`
	// The ID of the Internet-facing SLB instance that is bound to the application.
	ExtSlbId *string `json:"ExtSlbId,omitempty" xml:"ExtSlbId,omitempty"`
	// The IP address of the Internet-facing Server Load Balancer (SLB) instance that is bound to the application.
	ExtSlbIp *string `json:"ExtSlbIp,omitempty" xml:"ExtSlbIp,omitempty"`
	// The name of the Internet-facing SLB instance that is bound to the application.
	ExtSlbName       *string `json:"ExtSlbName,omitempty" xml:"ExtSlbName,omitempty"`
	HaveManageAccess *string `json:"HaveManageAccess,omitempty" xml:"HaveManageAccess,omitempty"`
	// The health check URL of the application.
	HealthCheckUrl *string `json:"HealthCheckUrl,omitempty" xml:"HealthCheckUrl,omitempty"`
	// The number of instances deployed with the application.
	InstanceCount *int32 `json:"InstanceCount,omitempty" xml:"InstanceCount,omitempty"`
	// The memory size of the application instance. Unit: MB.
	Memory *int32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// The name of the application.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace to which the application belongs.
	NameSpace *string `json:"NameSpace,omitempty" xml:"NameSpace,omitempty"`
	// The ID of the user who created the application.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The service port of the application.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The ID of the region in which the application is deployed.
	RegionId        *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The number of running instances for the application.
	RunningInstanceCount *int32 `json:"RunningInstanceCount,omitempty" xml:"RunningInstanceCount,omitempty"`
	// The ID of the internal-facing SLB instance that is bound to the application.
	SlbId *string `json:"SlbId,omitempty" xml:"SlbId,omitempty"`
	// The information about the internal-facing SLB instance that is bound to the application.
	SlbInfo *string `json:"SlbInfo,omitempty" xml:"SlbInfo,omitempty"`
	// The IP address of the internal-facing SLB instance that is bound to the application.
	SlbIp *string `json:"SlbIp,omitempty" xml:"SlbIp,omitempty"`
	// The name of the internal-facing SLB instance that is bound to the application.
	SlbName *string `json:"SlbName,omitempty" xml:"SlbName,omitempty"`
	// The port of the internal-facing SLB instance that is bound to the application.
	SlbPort *int32 `json:"SlbPort,omitempty" xml:"SlbPort,omitempty"`
	// The ID of the Alibaba Cloud account.
	UserId       *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	WorkloadType *string `json:"WorkloadType,omitempty" xml:"WorkloadType,omitempty"`
}

func (s GetApplicationResponseBodyApplication) String() string {
	return tea.Prettify(s)
}

func (s GetApplicationResponseBodyApplication) GoString() string {
	return s.String()
}

func (s *GetApplicationResponseBodyApplication) SetAppId(v string) *GetApplicationResponseBodyApplication {
	s.AppId = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetAppPhase(v string) *GetApplicationResponseBodyApplication {
	s.AppPhase = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetApplicationType(v string) *GetApplicationResponseBodyApplication {
	s.ApplicationType = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetBuildPackageId(v int64) *GetApplicationResponseBodyApplication {
	s.BuildPackageId = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetClusterId(v string) *GetApplicationResponseBodyApplication {
	s.ClusterId = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetClusterType(v string) *GetApplicationResponseBodyApplication {
	s.ClusterType = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetCpu(v int32) *GetApplicationResponseBodyApplication {
	s.Cpu = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetCreateTime(v int64) *GetApplicationResponseBodyApplication {
	s.CreateTime = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetDescription(v string) *GetApplicationResponseBodyApplication {
	s.Description = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetDockerize(v bool) *GetApplicationResponseBodyApplication {
	s.Dockerize = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetEmail(v string) *GetApplicationResponseBodyApplication {
	s.Email = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetEnablePortCheck(v bool) *GetApplicationResponseBodyApplication {
	s.EnablePortCheck = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetEnableUrlCheck(v bool) *GetApplicationResponseBodyApplication {
	s.EnableUrlCheck = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetExtSlbId(v string) *GetApplicationResponseBodyApplication {
	s.ExtSlbId = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetExtSlbIp(v string) *GetApplicationResponseBodyApplication {
	s.ExtSlbIp = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetExtSlbName(v string) *GetApplicationResponseBodyApplication {
	s.ExtSlbName = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetHaveManageAccess(v string) *GetApplicationResponseBodyApplication {
	s.HaveManageAccess = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetHealthCheckUrl(v string) *GetApplicationResponseBodyApplication {
	s.HealthCheckUrl = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetInstanceCount(v int32) *GetApplicationResponseBodyApplication {
	s.InstanceCount = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetMemory(v int32) *GetApplicationResponseBodyApplication {
	s.Memory = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetName(v string) *GetApplicationResponseBodyApplication {
	s.Name = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetNameSpace(v string) *GetApplicationResponseBodyApplication {
	s.NameSpace = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetOwner(v string) *GetApplicationResponseBodyApplication {
	s.Owner = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetPort(v int32) *GetApplicationResponseBodyApplication {
	s.Port = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetRegionId(v string) *GetApplicationResponseBodyApplication {
	s.RegionId = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetResourceGroupId(v string) *GetApplicationResponseBodyApplication {
	s.ResourceGroupId = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetRunningInstanceCount(v int32) *GetApplicationResponseBodyApplication {
	s.RunningInstanceCount = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetSlbId(v string) *GetApplicationResponseBodyApplication {
	s.SlbId = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetSlbInfo(v string) *GetApplicationResponseBodyApplication {
	s.SlbInfo = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetSlbIp(v string) *GetApplicationResponseBodyApplication {
	s.SlbIp = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetSlbName(v string) *GetApplicationResponseBodyApplication {
	s.SlbName = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetSlbPort(v int32) *GetApplicationResponseBodyApplication {
	s.SlbPort = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetUserId(v string) *GetApplicationResponseBodyApplication {
	s.UserId = &v
	return s
}

func (s *GetApplicationResponseBodyApplication) SetWorkloadType(v string) *GetApplicationResponseBodyApplication {
	s.WorkloadType = &v
	return s
}

type GetApplicationResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetApplicationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetApplicationResponse) String() string {
	return tea.Prettify(s)
}

func (s GetApplicationResponse) GoString() string {
	return s.String()
}

func (s *GetApplicationResponse) SetHeaders(v map[string]*string) *GetApplicationResponse {
	s.Headers = v
	return s
}

func (s *GetApplicationResponse) SetStatusCode(v int32) *GetApplicationResponse {
	s.StatusCode = &v
	return s
}

func (s *GetApplicationResponse) SetBody(v *GetApplicationResponseBody) *GetApplicationResponse {
	s.Body = v
	return s
}

type GetChangeOrderInfoRequest struct {
	// The ID of the change process.
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
}

func (s GetChangeOrderInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s GetChangeOrderInfoRequest) GoString() string {
	return s.String()
}

func (s *GetChangeOrderInfoRequest) SetChangeOrderId(v string) *GetChangeOrderInfoRequest {
	s.ChangeOrderId = &v
	return s
}

type GetChangeOrderInfoResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The details about the change process.
	ChangeOrderInfo *GetChangeOrderInfoResponseBodyChangeOrderInfo `json:"changeOrderInfo,omitempty" xml:"changeOrderInfo,omitempty" type:"Struct"`
}

func (s GetChangeOrderInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetChangeOrderInfoResponseBody) GoString() string {
	return s.String()
}

func (s *GetChangeOrderInfoResponseBody) SetCode(v int32) *GetChangeOrderInfoResponseBody {
	s.Code = &v
	return s
}

func (s *GetChangeOrderInfoResponseBody) SetMessage(v string) *GetChangeOrderInfoResponseBody {
	s.Message = &v
	return s
}

func (s *GetChangeOrderInfoResponseBody) SetRequestId(v string) *GetChangeOrderInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetChangeOrderInfoResponseBody) SetChangeOrderInfo(v *GetChangeOrderInfoResponseBodyChangeOrderInfo) *GetChangeOrderInfoResponseBody {
	s.ChangeOrderInfo = v
	return s
}

type GetChangeOrderInfoResponseBodyChangeOrderInfo struct {
	// The number of batches for the change.
	BatchCount *int32 `json:"BatchCount,omitempty" xml:"BatchCount,omitempty"`
	// Indicates whether the change for the next batch is automatically or manually triggered when phased release is performed. Valid values:
	//
	// *   Automatic: The change for the next batch is automatically triggered.
	// *   Manual: The change for the next batch is manually triggered.
	BatchType *string `json:"BatchType,omitempty" xml:"BatchType,omitempty"`
	// The description of the change process.
	ChangeOrderDescription *string `json:"ChangeOrderDescription,omitempty" xml:"ChangeOrderDescription,omitempty"`
	// The ID of the change process.
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	// The type of the change process.
	CoType *string `json:"CoType,omitempty" xml:"CoType,omitempty"`
	// The time when the change process is created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The person in charge of the change process.
	CreateUserId *string `json:"CreateUserId,omitempty" xml:"CreateUserId,omitempty"`
	// The description of the change process.
	Desc *string `json:"Desc,omitempty" xml:"Desc,omitempty"`
	// The information about the batches of the change task.
	PipelineInfoList *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoList `json:"PipelineInfoList,omitempty" xml:"PipelineInfoList,omitempty" type:"Struct"`
	// The state of the change process. Valid values:
	//
	// *   0: ready
	// *   1: in progress
	// *   2: successful
	// *   3: failed
	// *   6: terminated
	// *   7: partially executed
	// *   8: wait for manual confirmation to trigger the next batch during a manual phased release
	// *   9: wait to trigger the next batch during an automatic phased release
	// *   10: failed due to a system exception
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// Indicates whether rollbacks are allowed. Valid values:
	//
	// *   true: Rollbacks are allowed.
	// *   false: Rollbacks are not allowed.
	SupportRollback *bool                                                 `json:"SupportRollback,omitempty" xml:"SupportRollback,omitempty"`
	Targets         *GetChangeOrderInfoResponseBodyChangeOrderInfoTargets `json:"Targets,omitempty" xml:"Targets,omitempty" type:"Struct"`
	// The throttling rules.
	TrafficControl *GetChangeOrderInfoResponseBodyChangeOrderInfoTrafficControl `json:"TrafficControl,omitempty" xml:"TrafficControl,omitempty" type:"Struct"`
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfo) String() string {
	return tea.Prettify(s)
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfo) GoString() string {
	return s.String()
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfo) SetBatchCount(v int32) *GetChangeOrderInfoResponseBodyChangeOrderInfo {
	s.BatchCount = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfo) SetBatchType(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfo {
	s.BatchType = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfo) SetChangeOrderDescription(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfo {
	s.ChangeOrderDescription = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfo) SetChangeOrderId(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfo {
	s.ChangeOrderId = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfo) SetCoType(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfo {
	s.CoType = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfo) SetCreateTime(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfo {
	s.CreateTime = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfo) SetCreateUserId(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfo {
	s.CreateUserId = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfo) SetDesc(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfo {
	s.Desc = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfo) SetPipelineInfoList(v *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoList) *GetChangeOrderInfoResponseBodyChangeOrderInfo {
	s.PipelineInfoList = v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfo) SetStatus(v int32) *GetChangeOrderInfoResponseBodyChangeOrderInfo {
	s.Status = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfo) SetSupportRollback(v bool) *GetChangeOrderInfoResponseBodyChangeOrderInfo {
	s.SupportRollback = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfo) SetTargets(v *GetChangeOrderInfoResponseBodyChangeOrderInfoTargets) *GetChangeOrderInfoResponseBodyChangeOrderInfo {
	s.Targets = v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfo) SetTrafficControl(v *GetChangeOrderInfoResponseBodyChangeOrderInfoTrafficControl) *GetChangeOrderInfoResponseBodyChangeOrderInfo {
	s.TrafficControl = v
	return s
}

type GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoList struct {
	PipelineInfo []*GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo `json:"PipelineInfo,omitempty" xml:"PipelineInfo,omitempty" type:"Repeated"`
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoList) String() string {
	return tea.Prettify(s)
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoList) GoString() string {
	return s.String()
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoList) SetPipelineInfo(v []*GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoList {
	s.PipelineInfo = v
	return s
}

type GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo struct {
	// The ID of each batch for the change during the phased release.
	PipelineId *string `json:"PipelineId,omitempty" xml:"PipelineId,omitempty"`
	// The name of the batch.
	PipelineName *string `json:"PipelineName,omitempty" xml:"PipelineName,omitempty"`
	// The state of the change task. Valid values:
	//
	// *   0: ready
	// *   1: in progress
	// *   2: successful
	// *   3: failed
	// *   6: terminated
	// *   8: wait for manual confirmation to trigger the next batch during a manual phased release
	// *   9: wait to trigger the next batch during an automatic phased release
	// *   10: failed due to a system exception
	PipelineStatus *int32 `json:"PipelineStatus,omitempty" xml:"PipelineStatus,omitempty"`
	// The execution results in each stage.
	StageDetailList *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailList `json:"StageDetailList,omitempty" xml:"StageDetailList,omitempty" type:"Struct"`
	// The stages of the change process.
	StageList *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageList `json:"StageList,omitempty" xml:"StageList,omitempty" type:"Struct"`
	// The time when the change task was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The time when the change task was updated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo) String() string {
	return tea.Prettify(s)
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo) GoString() string {
	return s.String()
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo) SetPipelineId(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo {
	s.PipelineId = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo) SetPipelineName(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo {
	s.PipelineName = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo) SetPipelineStatus(v int32) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo {
	s.PipelineStatus = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo) SetStageDetailList(v *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailList) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo {
	s.StageDetailList = v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo) SetStageList(v *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageList) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo {
	s.StageList = v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo) SetStartTime(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo {
	s.StartTime = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo) SetUpdateTime(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfo {
	s.UpdateTime = &v
	return s
}

type GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailList struct {
	StageDetailDTO []*GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO `json:"StageDetailDTO,omitempty" xml:"StageDetailDTO,omitempty" type:"Repeated"`
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailList) String() string {
	return tea.Prettify(s)
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailList) GoString() string {
	return s.String()
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailList) SetStageDetailDTO(v []*GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailList {
	s.StageDetailDTO = v
	return s
}

type GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO struct {
	// The ID of the stage.
	StageId *string `json:"StageId,omitempty" xml:"StageId,omitempty"`
	// The name of the stage.
	StageName *string `json:"StageName,omitempty" xml:"StageName,omitempty"`
	// The status of the stage. Valid values:
	//
	// *   0: ready
	// *   1: in progress
	// *   2: successful
	// *   3: failed
	// *   6: terminated
	// *   8: wait for manual confirmation to trigger the next batch during a manual phased release
	// *   9: wait to trigger the next batch during an automatic phased release
	// *   10: failed due to a system exception
	StageStatus *int32 `json:"StageStatus,omitempty" xml:"StageStatus,omitempty"`
	// The information about the task.
	TaskList *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskList `json:"TaskList,omitempty" xml:"TaskList,omitempty" type:"Struct"`
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO) String() string {
	return tea.Prettify(s)
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO) GoString() string {
	return s.String()
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO) SetStageId(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO {
	s.StageId = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO) SetStageName(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO {
	s.StageName = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO) SetStageStatus(v int32) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO {
	s.StageStatus = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO) SetTaskList(v *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskList) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTO {
	s.TaskList = v
	return s
}

type GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskList struct {
	TaskInfoDTO []*GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO `json:"TaskInfoDTO,omitempty" xml:"TaskInfoDTO,omitempty" type:"Repeated"`
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskList) String() string {
	return tea.Prettify(s)
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskList) GoString() string {
	return s.String()
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskList) SetTaskInfoDTO(v []*GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskList {
	s.TaskInfoDTO = v
	return s
}

type GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO struct {
	// The type of the retry policy. Value 0 indicates no retry, value 1 indicates automatic retry, and value 2 indicates manual retry.
	RetryType *int32 `json:"RetryType,omitempty" xml:"RetryType,omitempty"`
	// Indicates whether errors that occur in the change process are ignored. Valid values:``
	//
	// *   true: Errors that occur in the change process are ignored. This parameter can be set to true only when URL health checks are performed.
	// *   false: Errors that occur in the change process are not ignored.
	ShowManualIgnorance *bool `json:"ShowManualIgnorance,omitempty" xml:"ShowManualIgnorance,omitempty"`
	// Error codes
	TaskErrorCode *string `json:"TaskErrorCode,omitempty" xml:"TaskErrorCode,omitempty"`
	// Indicates whether the task is error-tolerant. If the task can tolerate errors, the errors that occur in the change process are ignored and the next task is executed.
	//
	// *   0: The task is not error-tolerant.
	// *   1: The task is error-tolerant.
	TaskErrorIgnorance *int32 `json:"TaskErrorIgnorance,omitempty" xml:"TaskErrorIgnorance,omitempty"`
	// The error message for the task.
	TaskErrorMessage *string `json:"TaskErrorMessage,omitempty" xml:"TaskErrorMessage,omitempty"`
	// The ID of the task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// Task information
	TaskMessage *string `json:"TaskMessage,omitempty" xml:"TaskMessage,omitempty"`
	// The name of the task.
	TaskName *string `json:"TaskName,omitempty" xml:"TaskName,omitempty"`
	// The state of the task. Valid values:
	//
	// *   0: ready
	// *   1: in progress
	// *   2: successful
	// *   3: failed
	// *   6: terminated
	// *   8: wait for manual confirmation to trigger the next batch during a manual phased release
	// *   9: wait to trigger the next batch during an automatic phased release
	// *   10: failed due to a system exception
	TaskStatus *string `json:"TaskStatus,omitempty" xml:"TaskStatus,omitempty"`
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO) String() string {
	return tea.Prettify(s)
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO) GoString() string {
	return s.String()
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO) SetRetryType(v int32) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO {
	s.RetryType = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO) SetShowManualIgnorance(v bool) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO {
	s.ShowManualIgnorance = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO) SetTaskErrorCode(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO {
	s.TaskErrorCode = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO) SetTaskErrorIgnorance(v int32) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO {
	s.TaskErrorIgnorance = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO) SetTaskErrorMessage(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO {
	s.TaskErrorMessage = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO) SetTaskId(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO {
	s.TaskId = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO) SetTaskMessage(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO {
	s.TaskMessage = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO) SetTaskName(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO {
	s.TaskName = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO) SetTaskStatus(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageDetailListStageDetailDTOTaskListTaskInfoDTO {
	s.TaskStatus = &v
	return s
}

type GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageList struct {
	StageInfoDTO []*GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO `json:"StageInfoDTO,omitempty" xml:"StageInfoDTO,omitempty" type:"Repeated"`
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageList) String() string {
	return tea.Prettify(s)
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageList) GoString() string {
	return s.String()
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageList) SetStageInfoDTO(v []*GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageList {
	s.StageInfoDTO = v
	return s
}

type GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO struct {
	// The ID of the stage.
	StageId *string `json:"StageId,omitempty" xml:"StageId,omitempty"`
	// The name of the stage.
	StageName *string `json:"StageName,omitempty" xml:"StageName,omitempty"`
	// The results of the task executed in the stage.
	StageResultDTO *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTO `json:"StageResultDTO,omitempty" xml:"StageResultDTO,omitempty" type:"Struct"`
	// The state of the stage. Valid values:
	//
	// *   0: ready
	// *   1: in progress
	// *   2: successful
	// *   3: failed
	// *   6: terminated
	// *   8: wait for manual confirmation to trigger the next batch during a manual phased release
	// *   9: wait to trigger the next batch during an automatic phased release
	// *   10: failed due to a system exception
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO) String() string {
	return tea.Prettify(s)
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO) GoString() string {
	return s.String()
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO) SetStageId(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO {
	s.StageId = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO) SetStageName(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO {
	s.StageName = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO) SetStageResultDTO(v *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTO) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO {
	s.StageResultDTO = v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO) SetStatus(v int32) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTO {
	s.Status = &v
	return s
}

type GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTO struct {
	// The results of the task executed on each Elastic Compute Service (ECS) instance in each stage.
	InstanceDTOList *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOList `json:"InstanceDTOList,omitempty" xml:"InstanceDTOList,omitempty" type:"Struct"`
	// The results of tasks executed in each service-oriented stage.
	ServiceStage *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOServiceStage `json:"ServiceStage,omitempty" xml:"ServiceStage,omitempty" type:"Struct"`
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTO) String() string {
	return tea.Prettify(s)
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTO) GoString() string {
	return s.String()
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTO) SetInstanceDTOList(v *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOList) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTO {
	s.InstanceDTOList = v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTO) SetServiceStage(v *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOServiceStage) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTO {
	s.ServiceStage = v
	return s
}

type GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOList struct {
	InstanceDTO []*GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO `json:"InstanceDTO,omitempty" xml:"InstanceDTO,omitempty" type:"Repeated"`
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOList) String() string {
	return tea.Prettify(s)
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOList) GoString() string {
	return s.String()
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOList) SetInstanceDTO(v []*GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOList {
	s.InstanceDTO = v
	return s
}

type GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO struct {
	// The IP address of the ECS instance.
	InstanceIp *string `json:"InstanceIp,omitempty" xml:"InstanceIp,omitempty"`
	// The name of the ECS instance.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// The results of the task executed on the ECS instance in each stage.
	InstanceStageDTOList *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOList `json:"InstanceStageDTOList,omitempty" xml:"InstanceStageDTOList,omitempty" type:"Struct"`
	// The name of the node.
	PodName *string `json:"PodName,omitempty" xml:"PodName,omitempty"`
	// The state of the pod.
	PodStatus *string `json:"PodStatus,omitempty" xml:"PodStatus,omitempty"`
	// The running state. Valid values:
	//
	// *   0: ready
	// *   1: in progress
	// *   2: successful
	// *   3: failed
	// *   6: terminated
	// *   8: wait for manual confirmation to trigger the next batch during a manual phased release
	// *   9: wait to trigger the next batch during an automatic phased release
	// *   10: failed due to a system exception
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO) String() string {
	return tea.Prettify(s)
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO) GoString() string {
	return s.String()
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO) SetInstanceIp(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO {
	s.InstanceIp = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO) SetInstanceName(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO {
	s.InstanceName = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO) SetInstanceStageDTOList(v *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOList) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO {
	s.InstanceStageDTOList = v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO) SetPodName(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO {
	s.PodName = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO) SetPodStatus(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO {
	s.PodStatus = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO) SetStatus(v int32) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTO {
	s.Status = &v
	return s
}

type GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOList struct {
	InstanceStageDTO []*GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO `json:"InstanceStageDTO,omitempty" xml:"InstanceStageDTO,omitempty" type:"Repeated"`
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOList) String() string {
	return tea.Prettify(s)
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOList) GoString() string {
	return s.String()
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOList) SetInstanceStageDTO(v []*GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOList {
	s.InstanceStageDTO = v
	return s
}

type GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO struct {
	// The time when the execution stopped.
	FinishTime *string `json:"FinishTime,omitempty" xml:"FinishTime,omitempty"`
	// The ID of the stage.
	StageId *string `json:"StageId,omitempty" xml:"StageId,omitempty"`
	// The information about the stage.
	StageMessage *string `json:"StageMessage,omitempty" xml:"StageMessage,omitempty"`
	// The name of the stage.
	StageName *string `json:"StageName,omitempty" xml:"StageName,omitempty"`
	// The time when the execution was started.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The state of the stage. Valid values:
	//
	// *   0: ready
	// *   1: in progress
	// *   2: successful
	// *   3: failed
	// *   6: terminated
	// *   8: wait for manual confirmation to trigger the next batch during a manual phased release
	// *   9: wait to trigger the next batch during an automatic phased release
	// *   10: failed due to a system exception
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO) String() string {
	return tea.Prettify(s)
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO) GoString() string {
	return s.String()
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO) SetFinishTime(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO {
	s.FinishTime = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO) SetStageId(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO {
	s.StageId = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO) SetStageMessage(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO {
	s.StageMessage = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO) SetStageName(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO {
	s.StageName = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO) SetStartTime(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO {
	s.StartTime = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO) SetStatus(v int32) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOInstanceDTOListInstanceDTOInstanceStageDTOListInstanceStageDTO {
	s.Status = &v
	return s
}

type GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOServiceStage struct {
	// The execution result in the stage.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the stage.
	StageId *string `json:"StageId,omitempty" xml:"StageId,omitempty"`
	// Phase Name
	StageName *string `json:"StageName,omitempty" xml:"StageName,omitempty"`
	// The running state. Valid values:
	//
	// *   0: ready
	// *   1: in progress
	// *   2: successful
	// *   3: failed
	// *   6: terminated
	// *   8: wait for manual confirmation to trigger the next batch during a manual phased release
	// *   9: wait to trigger the next batch during an automatic phased release
	// *   10: failed due to a system exception
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOServiceStage) String() string {
	return tea.Prettify(s)
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOServiceStage) GoString() string {
	return s.String()
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOServiceStage) SetMessage(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOServiceStage {
	s.Message = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOServiceStage) SetStageId(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOServiceStage {
	s.StageId = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOServiceStage) SetStageName(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOServiceStage {
	s.StageName = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOServiceStage) SetStatus(v int32) *GetChangeOrderInfoResponseBodyChangeOrderInfoPipelineInfoListPipelineInfoStageListStageInfoDTOStageResultDTOServiceStage {
	s.Status = &v
	return s
}

type GetChangeOrderInfoResponseBodyChangeOrderInfoTargets struct {
	Items []*string `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoTargets) String() string {
	return tea.Prettify(s)
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoTargets) GoString() string {
	return s.String()
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoTargets) SetItems(v []*string) *GetChangeOrderInfoResponseBodyChangeOrderInfoTargets {
	s.Items = v
	return s
}

type GetChangeOrderInfoResponseBodyChangeOrderInfoTrafficControl struct {
	// The route forwarding policy.
	Routes *string `json:"Routes,omitempty" xml:"Routes,omitempty"`
	// The traffic routing rules.
	Rules *string `json:"Rules,omitempty" xml:"Rules,omitempty"`
	// The description of throttling rules.
	Tips *string `json:"Tips,omitempty" xml:"Tips,omitempty"`
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoTrafficControl) String() string {
	return tea.Prettify(s)
}

func (s GetChangeOrderInfoResponseBodyChangeOrderInfoTrafficControl) GoString() string {
	return s.String()
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoTrafficControl) SetRoutes(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfoTrafficControl {
	s.Routes = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoTrafficControl) SetRules(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfoTrafficControl {
	s.Rules = &v
	return s
}

func (s *GetChangeOrderInfoResponseBodyChangeOrderInfoTrafficControl) SetTips(v string) *GetChangeOrderInfoResponseBodyChangeOrderInfoTrafficControl {
	s.Tips = &v
	return s
}

type GetChangeOrderInfoResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetChangeOrderInfoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetChangeOrderInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s GetChangeOrderInfoResponse) GoString() string {
	return s.String()
}

func (s *GetChangeOrderInfoResponse) SetHeaders(v map[string]*string) *GetChangeOrderInfoResponse {
	s.Headers = v
	return s
}

func (s *GetChangeOrderInfoResponse) SetStatusCode(v int32) *GetChangeOrderInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *GetChangeOrderInfoResponse) SetBody(v *GetChangeOrderInfoResponseBody) *GetChangeOrderInfoResponse {
	s.Body = v
	return s
}

type GetClusterRequest struct {
	// The ID of the cluster in Enterprise Distributed Application Service (EDAS). You can call the ListCluster operation to query the cluster ID. For more information, see [ListCluster](~~154995~~).
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
}

func (s GetClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s GetClusterRequest) GoString() string {
	return s.String()
}

func (s *GetClusterRequest) SetClusterId(v string) *GetClusterRequest {
	s.ClusterId = &v
	return s
}

type GetClusterResponseBody struct {
	// The information about the cluster.
	Cluster *GetClusterResponseBodyCluster `json:"Cluster,omitempty" xml:"Cluster,omitempty" type:"Struct"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The detailed information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetClusterResponseBody) GoString() string {
	return s.String()
}

func (s *GetClusterResponseBody) SetCluster(v *GetClusterResponseBodyCluster) *GetClusterResponseBody {
	s.Cluster = v
	return s
}

func (s *GetClusterResponseBody) SetCode(v int32) *GetClusterResponseBody {
	s.Code = &v
	return s
}

func (s *GetClusterResponseBody) SetMessage(v string) *GetClusterResponseBody {
	s.Message = &v
	return s
}

func (s *GetClusterResponseBody) SetRequestId(v string) *GetClusterResponseBody {
	s.RequestId = &v
	return s
}

type GetClusterResponseBodyCluster struct {
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The import status of the cluster. Valid values:
	//
	// *   1: The cluster is imported.
	// *   2: The cluster fails to be imported.
	// *   3: The cluster is being imported.
	// *   4: The cluster is deleted.
	// *   0: The cluster is not imported.
	ClusterImportStatus *int32 `json:"ClusterImportStatus,omitempty" xml:"ClusterImportStatus,omitempty"`
	// The name of the cluster.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The type of the cluster. Valid values:
	//
	// *   0: regular Docker cluster
	// *   1: Swarm cluster
	// *   2: Elastic Compute Service (ECS) cluster
	// *   3: self-managed Kubernetes cluster in EDAS
	// *   4: cluster in which Pandora automatically registers applications
	// *   5: ACK cluster
	ClusterType *int32 `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The total number of CPU cores.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The number of used CPU cores.
	CpuUsed *int32 `json:"CpuUsed,omitempty" xml:"CpuUsed,omitempty"`
	// The time when the cluster was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the Container Service for Kubernetes (ACK) cluster.
	CsClusterId *string `json:"CsClusterId,omitempty" xml:"CsClusterId,omitempty"`
	// The description of the cluster.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The provider of Infrastructure as a Service (IaaS) resources used in the cluster.
	IaasProvider *string `json:"IaasProvider,omitempty" xml:"IaasProvider,omitempty"`
	// The total size of memory. Unit: MB.
	Mem *int32 `json:"Mem,omitempty" xml:"Mem,omitempty"`
	// The size of used memory. Unit: MB.
	MemUsed *int32 `json:"MemUsed,omitempty" xml:"MemUsed,omitempty"`
	// The network type of the cluster. Valid values:
	//
	// *   1: classic network
	// *   2: virtual private cloud (VPC)
	NetworkMode *int32 `json:"NetworkMode,omitempty" xml:"NetworkMode,omitempty"`
	// The number of ECS instances.
	NodeNum *int32 `json:"NodeNum,omitempty" xml:"NodeNum,omitempty"`
	// The overcommit ratio supported by a Docker cluster. Valid values:
	//
	// *   1: 1:1, which means that resources are not overcommitted.
	// *   2: 1:2, which means that resources are overcommitted by 1:2.
	// *   4: 1:4, which means that resources are overcommitted by 1:4.
	// *   8: 1:8, which means that resources are overcommitted by 1:8.
	OversoldFactor *int32 `json:"OversoldFactor,omitempty" xml:"OversoldFactor,omitempty"`
	// The ID of the region where the cluster resides.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The subtype of the Kubernetes cluster. Valid values: ManagedKubernetes, Ask, and ExternalKubernetes. ManagedKubernetes refers to the ACK cluster. Ask refers to the Serverless Kubernetes (ASK) cluster. ExternalKubernetes refers to the external cluster.
	SubClusterType *string `json:"SubClusterType,omitempty" xml:"SubClusterType,omitempty"`
	// The time when the cluster was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The ID of the virtual private cloud (VPC).
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s GetClusterResponseBodyCluster) String() string {
	return tea.Prettify(s)
}

func (s GetClusterResponseBodyCluster) GoString() string {
	return s.String()
}

func (s *GetClusterResponseBodyCluster) SetClusterId(v string) *GetClusterResponseBodyCluster {
	s.ClusterId = &v
	return s
}

func (s *GetClusterResponseBodyCluster) SetClusterImportStatus(v int32) *GetClusterResponseBodyCluster {
	s.ClusterImportStatus = &v
	return s
}

func (s *GetClusterResponseBodyCluster) SetClusterName(v string) *GetClusterResponseBodyCluster {
	s.ClusterName = &v
	return s
}

func (s *GetClusterResponseBodyCluster) SetClusterType(v int32) *GetClusterResponseBodyCluster {
	s.ClusterType = &v
	return s
}

func (s *GetClusterResponseBodyCluster) SetCpu(v int32) *GetClusterResponseBodyCluster {
	s.Cpu = &v
	return s
}

func (s *GetClusterResponseBodyCluster) SetCpuUsed(v int32) *GetClusterResponseBodyCluster {
	s.CpuUsed = &v
	return s
}

func (s *GetClusterResponseBodyCluster) SetCreateTime(v int64) *GetClusterResponseBodyCluster {
	s.CreateTime = &v
	return s
}

func (s *GetClusterResponseBodyCluster) SetCsClusterId(v string) *GetClusterResponseBodyCluster {
	s.CsClusterId = &v
	return s
}

func (s *GetClusterResponseBodyCluster) SetDescription(v string) *GetClusterResponseBodyCluster {
	s.Description = &v
	return s
}

func (s *GetClusterResponseBodyCluster) SetIaasProvider(v string) *GetClusterResponseBodyCluster {
	s.IaasProvider = &v
	return s
}

func (s *GetClusterResponseBodyCluster) SetMem(v int32) *GetClusterResponseBodyCluster {
	s.Mem = &v
	return s
}

func (s *GetClusterResponseBodyCluster) SetMemUsed(v int32) *GetClusterResponseBodyCluster {
	s.MemUsed = &v
	return s
}

func (s *GetClusterResponseBodyCluster) SetNetworkMode(v int32) *GetClusterResponseBodyCluster {
	s.NetworkMode = &v
	return s
}

func (s *GetClusterResponseBodyCluster) SetNodeNum(v int32) *GetClusterResponseBodyCluster {
	s.NodeNum = &v
	return s
}

func (s *GetClusterResponseBodyCluster) SetOversoldFactor(v int32) *GetClusterResponseBodyCluster {
	s.OversoldFactor = &v
	return s
}

func (s *GetClusterResponseBodyCluster) SetRegionId(v string) *GetClusterResponseBodyCluster {
	s.RegionId = &v
	return s
}

func (s *GetClusterResponseBodyCluster) SetSubClusterType(v string) *GetClusterResponseBodyCluster {
	s.SubClusterType = &v
	return s
}

func (s *GetClusterResponseBodyCluster) SetUpdateTime(v int64) *GetClusterResponseBodyCluster {
	s.UpdateTime = &v
	return s
}

func (s *GetClusterResponseBodyCluster) SetVpcId(v string) *GetClusterResponseBodyCluster {
	s.VpcId = &v
	return s
}

type GetClusterResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetClusterResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s GetClusterResponse) GoString() string {
	return s.String()
}

func (s *GetClusterResponse) SetHeaders(v map[string]*string) *GetClusterResponse {
	s.Headers = v
	return s
}

func (s *GetClusterResponse) SetStatusCode(v int32) *GetClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *GetClusterResponse) SetBody(v *GetClusterResponseBody) *GetClusterResponse {
	s.Body = v
	return s
}

type GetContainerConfigurationRequest struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the instance group.
	//
	// *   If this parameter is specified, this operation queries the Tomcat configuration of the instance group.
	// *   If this parameter is not specified, this operation queries the Tomcat configuration of the application.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
}

func (s GetContainerConfigurationRequest) String() string {
	return tea.Prettify(s)
}

func (s GetContainerConfigurationRequest) GoString() string {
	return s.String()
}

func (s *GetContainerConfigurationRequest) SetAppId(v string) *GetContainerConfigurationRequest {
	s.AppId = &v
	return s
}

func (s *GetContainerConfigurationRequest) SetGroupId(v string) *GetContainerConfigurationRequest {
	s.GroupId = &v
	return s
}

type GetContainerConfigurationResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The Tomcat configuration.
	ContainerConfiguration *GetContainerConfigurationResponseBodyContainerConfiguration `json:"ContainerConfiguration,omitempty" xml:"ContainerConfiguration,omitempty" type:"Struct"`
	// The message returned for the request.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetContainerConfigurationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetContainerConfigurationResponseBody) GoString() string {
	return s.String()
}

func (s *GetContainerConfigurationResponseBody) SetCode(v int32) *GetContainerConfigurationResponseBody {
	s.Code = &v
	return s
}

func (s *GetContainerConfigurationResponseBody) SetContainerConfiguration(v *GetContainerConfigurationResponseBodyContainerConfiguration) *GetContainerConfigurationResponseBody {
	s.ContainerConfiguration = v
	return s
}

func (s *GetContainerConfigurationResponseBody) SetMessage(v string) *GetContainerConfigurationResponseBody {
	s.Message = &v
	return s
}

func (s *GetContainerConfigurationResponseBody) SetRequestId(v string) *GetContainerConfigurationResponseBody {
	s.RequestId = &v
	return s
}

type GetContainerConfigurationResponseBodyContainerConfiguration struct {
	// The context path of the Tomcat container.
	ContextPath *string `json:"ContextPath,omitempty" xml:"ContextPath,omitempty"`
	// The application port number for the Tomcat container. The value specified in the application configuration is returned.
	HttpPort *int32 `json:"HttpPort,omitempty" xml:"HttpPort,omitempty"`
	// The maximum number of threads in the Tomcat container.
	//
	// *   If no instance group is specified, the configuration of the application is returned.
	// *   If no application is specified, the default configuration is returned.
	MaxThreads *int32 `json:"MaxThreads,omitempty" xml:"MaxThreads,omitempty"`
	// The Uniform Resource Identifier (URI) encoding scheme. Valid values: ISO-8859-1, GBK, GB2312, and UTF-8.
	//
	// *   If no instance group is specified, the configuration of the application is returned.
	// *   If no application is specified, the default configuration is returned.
	URIEncoding *string `json:"URIEncoding,omitempty" xml:"URIEncoding,omitempty"`
	// Indicates whether useBodyEncodingForURI is enabled in the Tomcat container.
	//
	// *   If no instance group is specified, the configuration of the application is returned.
	// *   If no application is specified, the default configuration is returned.
	UseBodyEncoding *bool `json:"UseBodyEncoding,omitempty" xml:"UseBodyEncoding,omitempty"`
}

func (s GetContainerConfigurationResponseBodyContainerConfiguration) String() string {
	return tea.Prettify(s)
}

func (s GetContainerConfigurationResponseBodyContainerConfiguration) GoString() string {
	return s.String()
}

func (s *GetContainerConfigurationResponseBodyContainerConfiguration) SetContextPath(v string) *GetContainerConfigurationResponseBodyContainerConfiguration {
	s.ContextPath = &v
	return s
}

func (s *GetContainerConfigurationResponseBodyContainerConfiguration) SetHttpPort(v int32) *GetContainerConfigurationResponseBodyContainerConfiguration {
	s.HttpPort = &v
	return s
}

func (s *GetContainerConfigurationResponseBodyContainerConfiguration) SetMaxThreads(v int32) *GetContainerConfigurationResponseBodyContainerConfiguration {
	s.MaxThreads = &v
	return s
}

func (s *GetContainerConfigurationResponseBodyContainerConfiguration) SetURIEncoding(v string) *GetContainerConfigurationResponseBodyContainerConfiguration {
	s.URIEncoding = &v
	return s
}

func (s *GetContainerConfigurationResponseBodyContainerConfiguration) SetUseBodyEncoding(v bool) *GetContainerConfigurationResponseBodyContainerConfiguration {
	s.UseBodyEncoding = &v
	return s
}

type GetContainerConfigurationResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetContainerConfigurationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetContainerConfigurationResponse) String() string {
	return tea.Prettify(s)
}

func (s GetContainerConfigurationResponse) GoString() string {
	return s.String()
}

func (s *GetContainerConfigurationResponse) SetHeaders(v map[string]*string) *GetContainerConfigurationResponse {
	s.Headers = v
	return s
}

func (s *GetContainerConfigurationResponse) SetStatusCode(v int32) *GetContainerConfigurationResponse {
	s.StatusCode = &v
	return s
}

func (s *GetContainerConfigurationResponse) SetBody(v *GetContainerConfigurationResponseBody) *GetContainerConfigurationResponse {
	s.Body = v
	return s
}

type GetJavaStartUpConfigRequest struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
}

func (s GetJavaStartUpConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s GetJavaStartUpConfigRequest) GoString() string {
	return s.String()
}

func (s *GetJavaStartUpConfigRequest) SetAppId(v string) *GetJavaStartUpConfigRequest {
	s.AppId = &v
	return s
}

type GetJavaStartUpConfigResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The configuration of Java startup parameters.
	JavaStartUpConfig *GetJavaStartUpConfigResponseBodyJavaStartUpConfig `json:"JavaStartUpConfig,omitempty" xml:"JavaStartUpConfig,omitempty" type:"Struct"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetJavaStartUpConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetJavaStartUpConfigResponseBody) GoString() string {
	return s.String()
}

func (s *GetJavaStartUpConfigResponseBody) SetCode(v int32) *GetJavaStartUpConfigResponseBody {
	s.Code = &v
	return s
}

func (s *GetJavaStartUpConfigResponseBody) SetJavaStartUpConfig(v *GetJavaStartUpConfigResponseBodyJavaStartUpConfig) *GetJavaStartUpConfigResponseBody {
	s.JavaStartUpConfig = v
	return s
}

func (s *GetJavaStartUpConfigResponseBody) SetMessage(v string) *GetJavaStartUpConfigResponseBody {
	s.Message = &v
	return s
}

func (s *GetJavaStartUpConfigResponseBody) SetRequestId(v string) *GetJavaStartUpConfigResponseBody {
	s.RequestId = &v
	return s
}

type GetJavaStartUpConfigResponseBodyJavaStartUpConfig struct {
	// The displayed startup parameter configuration.
	OriginalConfigs *string `json:"OriginalConfigs,omitempty" xml:"OriginalConfigs,omitempty"`
	// The effective startup parameter configuration.
	StartUpArgs *string `json:"StartUpArgs,omitempty" xml:"StartUpArgs,omitempty"`
}

func (s GetJavaStartUpConfigResponseBodyJavaStartUpConfig) String() string {
	return tea.Prettify(s)
}

func (s GetJavaStartUpConfigResponseBodyJavaStartUpConfig) GoString() string {
	return s.String()
}

func (s *GetJavaStartUpConfigResponseBodyJavaStartUpConfig) SetOriginalConfigs(v string) *GetJavaStartUpConfigResponseBodyJavaStartUpConfig {
	s.OriginalConfigs = &v
	return s
}

func (s *GetJavaStartUpConfigResponseBodyJavaStartUpConfig) SetStartUpArgs(v string) *GetJavaStartUpConfigResponseBodyJavaStartUpConfig {
	s.StartUpArgs = &v
	return s
}

type GetJavaStartUpConfigResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetJavaStartUpConfigResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetJavaStartUpConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s GetJavaStartUpConfigResponse) GoString() string {
	return s.String()
}

func (s *GetJavaStartUpConfigResponse) SetHeaders(v map[string]*string) *GetJavaStartUpConfigResponse {
	s.Headers = v
	return s
}

func (s *GetJavaStartUpConfigResponse) SetStatusCode(v int32) *GetJavaStartUpConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *GetJavaStartUpConfigResponse) SetBody(v *GetJavaStartUpConfigResponseBody) *GetJavaStartUpConfigResponse {
	s.Body = v
	return s
}

type GetJvmConfigurationRequest struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the instance group.
	//
	// *   If an ID is specified, this operation queries the JVM configuration information of the instance group.
	// *   If an ID is not specified, this operation queries the JVM configuration information of the application.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
}

func (s GetJvmConfigurationRequest) String() string {
	return tea.Prettify(s)
}

func (s GetJvmConfigurationRequest) GoString() string {
	return s.String()
}

func (s *GetJvmConfigurationRequest) SetAppId(v string) *GetJvmConfigurationRequest {
	s.AppId = &v
	return s
}

func (s *GetJvmConfigurationRequest) SetGroupId(v string) *GetJvmConfigurationRequest {
	s.GroupId = &v
	return s
}

type GetJvmConfigurationResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The JVM configuration of the application or instance group.
	JvmConfiguration *GetJvmConfigurationResponseBodyJvmConfiguration `json:"JvmConfiguration,omitempty" xml:"JvmConfiguration,omitempty" type:"Struct"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetJvmConfigurationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetJvmConfigurationResponseBody) GoString() string {
	return s.String()
}

func (s *GetJvmConfigurationResponseBody) SetCode(v int32) *GetJvmConfigurationResponseBody {
	s.Code = &v
	return s
}

func (s *GetJvmConfigurationResponseBody) SetJvmConfiguration(v *GetJvmConfigurationResponseBodyJvmConfiguration) *GetJvmConfigurationResponseBody {
	s.JvmConfiguration = v
	return s
}

func (s *GetJvmConfigurationResponseBody) SetMessage(v string) *GetJvmConfigurationResponseBody {
	s.Message = &v
	return s
}

func (s *GetJvmConfigurationResponseBody) SetRequestId(v string) *GetJvmConfigurationResponseBody {
	s.RequestId = &v
	return s
}

type GetJvmConfigurationResponseBodyJvmConfiguration struct {
	// The maximum size of the heap memory. Unit: MB.
	MaxHeapSize *int32 `json:"MaxHeapSize,omitempty" xml:"MaxHeapSize,omitempty"`
	// The size of the permanent generation heap memory. Unit: MB.
	MaxPermSize *int32 `json:"MaxPermSize,omitempty" xml:"MaxPermSize,omitempty"`
	// The initial size of the heap memory. Unit: MB.
	MinHeapSize *int32 `json:"MinHeapSize,omitempty" xml:"MinHeapSize,omitempty"`
	// The custom parameter.
	Options *string `json:"Options,omitempty" xml:"Options,omitempty"`
}

func (s GetJvmConfigurationResponseBodyJvmConfiguration) String() string {
	return tea.Prettify(s)
}

func (s GetJvmConfigurationResponseBodyJvmConfiguration) GoString() string {
	return s.String()
}

func (s *GetJvmConfigurationResponseBodyJvmConfiguration) SetMaxHeapSize(v int32) *GetJvmConfigurationResponseBodyJvmConfiguration {
	s.MaxHeapSize = &v
	return s
}

func (s *GetJvmConfigurationResponseBodyJvmConfiguration) SetMaxPermSize(v int32) *GetJvmConfigurationResponseBodyJvmConfiguration {
	s.MaxPermSize = &v
	return s
}

func (s *GetJvmConfigurationResponseBodyJvmConfiguration) SetMinHeapSize(v int32) *GetJvmConfigurationResponseBodyJvmConfiguration {
	s.MinHeapSize = &v
	return s
}

func (s *GetJvmConfigurationResponseBodyJvmConfiguration) SetOptions(v string) *GetJvmConfigurationResponseBodyJvmConfiguration {
	s.Options = &v
	return s
}

type GetJvmConfigurationResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetJvmConfigurationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetJvmConfigurationResponse) String() string {
	return tea.Prettify(s)
}

func (s GetJvmConfigurationResponse) GoString() string {
	return s.String()
}

func (s *GetJvmConfigurationResponse) SetHeaders(v map[string]*string) *GetJvmConfigurationResponse {
	s.Headers = v
	return s
}

func (s *GetJvmConfigurationResponse) SetStatusCode(v int32) *GetJvmConfigurationResponse {
	s.StatusCode = &v
	return s
}

func (s *GetJvmConfigurationResponse) SetBody(v *GetJvmConfigurationResponseBody) *GetJvmConfigurationResponse {
	s.Body = v
	return s
}

type GetK8sAppPrecheckResultRequest struct {
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The ID of the cluster in Enterprise Distributed Application Service (EDAS).
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The namespace of the Kubernetes cluster.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
}

func (s GetK8sAppPrecheckResultRequest) String() string {
	return tea.Prettify(s)
}

func (s GetK8sAppPrecheckResultRequest) GoString() string {
	return s.String()
}

func (s *GetK8sAppPrecheckResultRequest) SetAppName(v string) *GetK8sAppPrecheckResultRequest {
	s.AppName = &v
	return s
}

func (s *GetK8sAppPrecheckResultRequest) SetClusterId(v string) *GetK8sAppPrecheckResultRequest {
	s.ClusterId = &v
	return s
}

func (s *GetK8sAppPrecheckResultRequest) SetNamespace(v string) *GetK8sAppPrecheckResultRequest {
	s.Namespace = &v
	return s
}

type GetK8sAppPrecheckResultResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data that is returned.
	Data *GetK8sAppPrecheckResultResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetK8sAppPrecheckResultResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetK8sAppPrecheckResultResponseBody) GoString() string {
	return s.String()
}

func (s *GetK8sAppPrecheckResultResponseBody) SetCode(v int32) *GetK8sAppPrecheckResultResponseBody {
	s.Code = &v
	return s
}

func (s *GetK8sAppPrecheckResultResponseBody) SetData(v *GetK8sAppPrecheckResultResponseBodyData) *GetK8sAppPrecheckResultResponseBody {
	s.Data = v
	return s
}

func (s *GetK8sAppPrecheckResultResponseBody) SetMessage(v string) *GetK8sAppPrecheckResultResponseBody {
	s.Message = &v
	return s
}

func (s *GetK8sAppPrecheckResultResponseBody) SetRequestId(v string) *GetK8sAppPrecheckResultResponseBody {
	s.RequestId = &v
	return s
}

type GetK8sAppPrecheckResultResponseBodyData struct {
	// The precheck result for the application change.
	JobResults []*GetK8sAppPrecheckResultResponseBodyDataJobResults `json:"JobResults,omitempty" xml:"JobResults,omitempty" type:"Repeated"`
	// The reason why the application failed the precheck. This parameter is left empty when the application passed the precheck.
	Reason *string `json:"Reason,omitempty" xml:"Reason,omitempty"`
	// The precheck state for the application change. Valid values:
	//
	// *   checking: The application is being prechecked.
	// *   pass: The application passed the precheck.
	// *   failed: The application failed the precheck.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetK8sAppPrecheckResultResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetK8sAppPrecheckResultResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetK8sAppPrecheckResultResponseBodyData) SetJobResults(v []*GetK8sAppPrecheckResultResponseBodyDataJobResults) *GetK8sAppPrecheckResultResponseBodyData {
	s.JobResults = v
	return s
}

func (s *GetK8sAppPrecheckResultResponseBodyData) SetReason(v string) *GetK8sAppPrecheckResultResponseBodyData {
	s.Reason = &v
	return s
}

func (s *GetK8sAppPrecheckResultResponseBodyData) SetStatus(v string) *GetK8sAppPrecheckResultResponseBodyData {
	s.Status = &v
	return s
}

type GetK8sAppPrecheckResultResponseBodyDataJobResults struct {
	// Specifies whether the precheck of the item was interrupted:
	//
	// *   true: The precheck of the item was interrupted.
	// *   false: The precheck of the item was not interrupted.
	Interrupted *bool `json:"Interrupted,omitempty" xml:"Interrupted,omitempty"`
	// The name of the precheck item.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Indicates whether the precheck item passed the precheck:
	//
	// *   true: The precheck item passed the precheck.
	// *   false: The precheck item failed the precheck.
	Pass *bool `json:"Pass,omitempty" xml:"Pass,omitempty"`
	// The reason why the precheck item failed the precheck or the precheck of the item was interrupted. This parameter is left empty when the application passed the precheck.
	Reason *string `json:"Reason,omitempty" xml:"Reason,omitempty"`
}

func (s GetK8sAppPrecheckResultResponseBodyDataJobResults) String() string {
	return tea.Prettify(s)
}

func (s GetK8sAppPrecheckResultResponseBodyDataJobResults) GoString() string {
	return s.String()
}

func (s *GetK8sAppPrecheckResultResponseBodyDataJobResults) SetInterrupted(v bool) *GetK8sAppPrecheckResultResponseBodyDataJobResults {
	s.Interrupted = &v
	return s
}

func (s *GetK8sAppPrecheckResultResponseBodyDataJobResults) SetName(v string) *GetK8sAppPrecheckResultResponseBodyDataJobResults {
	s.Name = &v
	return s
}

func (s *GetK8sAppPrecheckResultResponseBodyDataJobResults) SetPass(v bool) *GetK8sAppPrecheckResultResponseBodyDataJobResults {
	s.Pass = &v
	return s
}

func (s *GetK8sAppPrecheckResultResponseBodyDataJobResults) SetReason(v string) *GetK8sAppPrecheckResultResponseBodyDataJobResults {
	s.Reason = &v
	return s
}

type GetK8sAppPrecheckResultResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetK8sAppPrecheckResultResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetK8sAppPrecheckResultResponse) String() string {
	return tea.Prettify(s)
}

func (s GetK8sAppPrecheckResultResponse) GoString() string {
	return s.String()
}

func (s *GetK8sAppPrecheckResultResponse) SetHeaders(v map[string]*string) *GetK8sAppPrecheckResultResponse {
	s.Headers = v
	return s
}

func (s *GetK8sAppPrecheckResultResponse) SetStatusCode(v int32) *GetK8sAppPrecheckResultResponse {
	s.StatusCode = &v
	return s
}

func (s *GetK8sAppPrecheckResultResponse) SetBody(v *GetK8sAppPrecheckResultResponseBody) *GetK8sAppPrecheckResultResponse {
	s.Body = v
	return s
}

type GetK8sApplicationRequest struct {
	// The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The source from which data is queried.
	//
	// *   If you leave this parameter empty, a common query is performed.
	// *   If you set the value to deploy, you query application information from the deployment page.
	From *string `json:"From,omitempty" xml:"From,omitempty"`
}

func (s GetK8sApplicationRequest) String() string {
	return tea.Prettify(s)
}

func (s GetK8sApplicationRequest) GoString() string {
	return s.String()
}

func (s *GetK8sApplicationRequest) SetAppId(v string) *GetK8sApplicationRequest {
	s.AppId = &v
	return s
}

func (s *GetK8sApplicationRequest) SetFrom(v string) *GetK8sApplicationRequest {
	s.From = &v
	return s
}

type GetK8sApplicationResponseBody struct {
	// The information about the application.
	Applcation *GetK8sApplicationResponseBodyApplcation `json:"Applcation,omitempty" xml:"Applcation,omitempty" type:"Struct"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetK8sApplicationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetK8sApplicationResponseBody) GoString() string {
	return s.String()
}

func (s *GetK8sApplicationResponseBody) SetApplcation(v *GetK8sApplicationResponseBodyApplcation) *GetK8sApplicationResponseBody {
	s.Applcation = v
	return s
}

func (s *GetK8sApplicationResponseBody) SetCode(v int32) *GetK8sApplicationResponseBody {
	s.Code = &v
	return s
}

func (s *GetK8sApplicationResponseBody) SetMessage(v string) *GetK8sApplicationResponseBody {
	s.Message = &v
	return s
}

func (s *GetK8sApplicationResponseBody) SetRequestId(v string) *GetK8sApplicationResponseBody {
	s.RequestId = &v
	return s
}

type GetK8sApplicationResponseBodyApplcation struct {
	// The basic information about the application.
	App *GetK8sApplicationResponseBodyApplcationApp `json:"App,omitempty" xml:"App,omitempty" type:"Struct"`
	// The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The configurations.
	Conf *GetK8sApplicationResponseBodyApplcationConf `json:"Conf,omitempty" xml:"Conf,omitempty" type:"Struct"`
	// The information about the instance group in which the application is deployed.
	DeployGroups *GetK8sApplicationResponseBodyApplcationDeployGroups `json:"DeployGroups,omitempty" xml:"DeployGroups,omitempty" type:"Struct"`
	// The information about the image.
	ImageInfo *GetK8sApplicationResponseBodyApplcationImageInfo `json:"ImageInfo,omitempty" xml:"ImageInfo,omitempty" type:"Struct"`
	// The information about the latest version.
	LatestVersion *GetK8sApplicationResponseBodyApplcationLatestVersion `json:"LatestVersion,omitempty" xml:"LatestVersion,omitempty" type:"Struct"`
}

func (s GetK8sApplicationResponseBodyApplcation) String() string {
	return tea.Prettify(s)
}

func (s GetK8sApplicationResponseBodyApplcation) GoString() string {
	return s.String()
}

func (s *GetK8sApplicationResponseBodyApplcation) SetApp(v *GetK8sApplicationResponseBodyApplcationApp) *GetK8sApplicationResponseBodyApplcation {
	s.App = v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcation) SetAppId(v string) *GetK8sApplicationResponseBodyApplcation {
	s.AppId = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcation) SetConf(v *GetK8sApplicationResponseBodyApplcationConf) *GetK8sApplicationResponseBodyApplcation {
	s.Conf = v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcation) SetDeployGroups(v *GetK8sApplicationResponseBodyApplcationDeployGroups) *GetK8sApplicationResponseBodyApplcation {
	s.DeployGroups = v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcation) SetImageInfo(v *GetK8sApplicationResponseBodyApplcationImageInfo) *GetK8sApplicationResponseBodyApplcation {
	s.ImageInfo = v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcation) SetLatestVersion(v *GetK8sApplicationResponseBodyApplcationLatestVersion) *GetK8sApplicationResponseBodyApplcation {
	s.LatestVersion = v
	return s
}

type GetK8sApplicationResponseBodyApplcationApp struct {
	// The annotation of an application pod.
	Annotations *string `json:"Annotations,omitempty" xml:"Annotations,omitempty"`
	// The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	ApplicationName *string `json:"ApplicationName,omitempty" xml:"ApplicationName,omitempty"`
	// The type of the application.
	ApplicationType *string `json:"ApplicationType,omitempty" xml:"ApplicationType,omitempty"`
	// The build package number of Enterprise Distributed Application Service (EDAS) Container.
	BuildpackId *int32 `json:"BuildpackId,omitempty" xml:"BuildpackId,omitempty"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The startup command.
	Cmd *string `json:"Cmd,omitempty" xml:"Cmd,omitempty"`
	// The list of commands.
	CmdArgs *GetK8sApplicationResponseBodyApplcationAppCmdArgs `json:"CmdArgs,omitempty" xml:"CmdArgs,omitempty" type:"Struct"`
	// The ID of the cluster to which the container belongs.
	CsClusterId *string `json:"CsClusterId,omitempty" xml:"CsClusterId,omitempty"`
	// The deployment type of the application. Example: Image.
	DeployType *string `json:"DeployType,omitempty" xml:"DeployType,omitempty"`
	// The application type. Valid values:
	//
	// *   General: native Java application
	// *   Pandora: Pandora application
	// *   Multilingual: multilingual application
	DevelopType *string `json:"DevelopType,omitempty" xml:"DevelopType,omitempty"`
	// The version of EDAS Container.
	EdasContainerVersion *string `json:"EdasContainerVersion,omitempty" xml:"EdasContainerVersion,omitempty"`
	// Indicates whether the Empty List Protection feature is enabled for the application.
	EnableEmptyPushReject *bool `json:"EnableEmptyPushReject,omitempty" xml:"EnableEmptyPushReject,omitempty"`
	// Indicates whether the Graceful Release feature is enabled for the application.
	EnableLosslessRule *bool `json:"EnableLosslessRule,omitempty" xml:"EnableLosslessRule,omitempty"`
	// The list of environment variables.
	EnvList *GetK8sApplicationResponseBodyApplcationAppEnvList `json:"EnvList,omitempty" xml:"EnvList,omitempty" type:"Struct"`
	// The feature annotations. Possible values:
	//
	// *   base.combination.edas: enables EDAS integrated management solution.
	// *   base.combination.arms: enables ARMS monitoring.
	// *   base.combination.mse: enables MSE microservices governance.
	// *   base.combination.none: enables lifecycle management.
	FeatureAnnotations *string `json:"FeatureAnnotations,omitempty" xml:"FeatureAnnotations,omitempty"`
	// The number of application instances.
	Instances *int32 `json:"Instances,omitempty" xml:"Instances,omitempty"`
	// The number of application instances before the last auto scaling operation.
	InstancesBeforeScaling *int32 `json:"InstancesBeforeScaling,omitempty" xml:"InstancesBeforeScaling,omitempty"`
	// The namespace of the Kubernetes cluster.
	K8sNamespace *string `json:"K8sNamespace,omitempty" xml:"K8sNamespace,omitempty"`
	// The label of an application pod.
	Labels *string `json:"Labels,omitempty" xml:"Labels,omitempty"`
	// The maximum number of CPU cores allowed. Unit: millicores. 1,000 millicores equal one CPU core.
	LimitCpuM *int32 `json:"LimitCpuM,omitempty" xml:"LimitCpuM,omitempty"`
	// The maximum size of space required by ephemeral storage. Unit: GB. Value 0 indicates that no limit is set on the space size.
	LimitEphemeralStorage *string `json:"LimitEphemeralStorage,omitempty" xml:"LimitEphemeralStorage,omitempty"`
	// The maximum size of the memory allowed. Unit: MiB.
	LimitMem *int32 `json:"LimitMem,omitempty" xml:"LimitMem,omitempty"`
	// Indicates whether the Graceful Rolling Release and Configure Complete Service Registration before Readiness Probing feature is enabled for the application.
	LosslessRuleAligned *bool `json:"LosslessRuleAligned,omitempty" xml:"LosslessRuleAligned,omitempty"`
	// The delay of service registration. Unit: seconds.
	LosslessRuleDelayTime *int32 `json:"LosslessRuleDelayTime,omitempty" xml:"LosslessRuleDelayTime,omitempty"`
	// The number of prefetching curves.
	LosslessRuleFuncType *int32 `json:"LosslessRuleFuncType,omitempty" xml:"LosslessRuleFuncType,omitempty"`
	// Indicates whether the Graceful Rolling Release and Configure Complete Service Prefetching before Readiness Probing feature is enabled for the application.
	LosslessRuleRelated *bool `json:"LosslessRuleRelated,omitempty" xml:"LosslessRuleRelated,omitempty"`
	// The service prefetching duration. Unit: seconds.
	LosslessRuleWarmupTime *int32 `json:"LosslessRuleWarmupTime,omitempty" xml:"LosslessRuleWarmupTime,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The number of requested CPU cores. Unit: millicores. 1,000 millicores equal one CPU core.
	RequestCpuM *int32 `json:"RequestCpuM,omitempty" xml:"RequestCpuM,omitempty"`
	// The size of space reserved for ephemeral storage resources. Unit: GB. Value 0 indicates that no limit is set on the space size.
	RequestEphemeralStorage *string `json:"RequestEphemeralStorage,omitempty" xml:"RequestEphemeralStorage,omitempty"`
	// The size of the reserved memory. Unit: MiB.
	RequestMem *int32 `json:"RequestMem,omitempty" xml:"RequestMem,omitempty"`
	// The configuration information about the Server Load Balancer (SLB).
	SlbInfo *string `json:"SlbInfo,omitempty" xml:"SlbInfo,omitempty"`
	// The version of Apache Tomcat.
	TomcatVersion *string `json:"TomcatVersion,omitempty" xml:"TomcatVersion,omitempty"`
	// The workload type. Valid values: Deployment and StatefulSet. If you do not specify this parameter, Deployment is used.
	WorkloadType *string `json:"WorkloadType,omitempty" xml:"WorkloadType,omitempty"`
}

func (s GetK8sApplicationResponseBodyApplcationApp) String() string {
	return tea.Prettify(s)
}

func (s GetK8sApplicationResponseBodyApplcationApp) GoString() string {
	return s.String()
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetAnnotations(v string) *GetK8sApplicationResponseBodyApplcationApp {
	s.Annotations = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetAppId(v string) *GetK8sApplicationResponseBodyApplcationApp {
	s.AppId = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetApplicationName(v string) *GetK8sApplicationResponseBodyApplcationApp {
	s.ApplicationName = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetApplicationType(v string) *GetK8sApplicationResponseBodyApplcationApp {
	s.ApplicationType = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetBuildpackId(v int32) *GetK8sApplicationResponseBodyApplcationApp {
	s.BuildpackId = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetClusterId(v string) *GetK8sApplicationResponseBodyApplcationApp {
	s.ClusterId = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetCmd(v string) *GetK8sApplicationResponseBodyApplcationApp {
	s.Cmd = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetCmdArgs(v *GetK8sApplicationResponseBodyApplcationAppCmdArgs) *GetK8sApplicationResponseBodyApplcationApp {
	s.CmdArgs = v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetCsClusterId(v string) *GetK8sApplicationResponseBodyApplcationApp {
	s.CsClusterId = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetDeployType(v string) *GetK8sApplicationResponseBodyApplcationApp {
	s.DeployType = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetDevelopType(v string) *GetK8sApplicationResponseBodyApplcationApp {
	s.DevelopType = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetEdasContainerVersion(v string) *GetK8sApplicationResponseBodyApplcationApp {
	s.EdasContainerVersion = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetEnableEmptyPushReject(v bool) *GetK8sApplicationResponseBodyApplcationApp {
	s.EnableEmptyPushReject = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetEnableLosslessRule(v bool) *GetK8sApplicationResponseBodyApplcationApp {
	s.EnableLosslessRule = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetEnvList(v *GetK8sApplicationResponseBodyApplcationAppEnvList) *GetK8sApplicationResponseBodyApplcationApp {
	s.EnvList = v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetFeatureAnnotations(v string) *GetK8sApplicationResponseBodyApplcationApp {
	s.FeatureAnnotations = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetInstances(v int32) *GetK8sApplicationResponseBodyApplcationApp {
	s.Instances = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetInstancesBeforeScaling(v int32) *GetK8sApplicationResponseBodyApplcationApp {
	s.InstancesBeforeScaling = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetK8sNamespace(v string) *GetK8sApplicationResponseBodyApplcationApp {
	s.K8sNamespace = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetLabels(v string) *GetK8sApplicationResponseBodyApplcationApp {
	s.Labels = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetLimitCpuM(v int32) *GetK8sApplicationResponseBodyApplcationApp {
	s.LimitCpuM = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetLimitEphemeralStorage(v string) *GetK8sApplicationResponseBodyApplcationApp {
	s.LimitEphemeralStorage = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetLimitMem(v int32) *GetK8sApplicationResponseBodyApplcationApp {
	s.LimitMem = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetLosslessRuleAligned(v bool) *GetK8sApplicationResponseBodyApplcationApp {
	s.LosslessRuleAligned = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetLosslessRuleDelayTime(v int32) *GetK8sApplicationResponseBodyApplcationApp {
	s.LosslessRuleDelayTime = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetLosslessRuleFuncType(v int32) *GetK8sApplicationResponseBodyApplcationApp {
	s.LosslessRuleFuncType = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetLosslessRuleRelated(v bool) *GetK8sApplicationResponseBodyApplcationApp {
	s.LosslessRuleRelated = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetLosslessRuleWarmupTime(v int32) *GetK8sApplicationResponseBodyApplcationApp {
	s.LosslessRuleWarmupTime = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetRegionId(v string) *GetK8sApplicationResponseBodyApplcationApp {
	s.RegionId = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetRequestCpuM(v int32) *GetK8sApplicationResponseBodyApplcationApp {
	s.RequestCpuM = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetRequestEphemeralStorage(v string) *GetK8sApplicationResponseBodyApplcationApp {
	s.RequestEphemeralStorage = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetRequestMem(v int32) *GetK8sApplicationResponseBodyApplcationApp {
	s.RequestMem = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetSlbInfo(v string) *GetK8sApplicationResponseBodyApplcationApp {
	s.SlbInfo = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetTomcatVersion(v string) *GetK8sApplicationResponseBodyApplcationApp {
	s.TomcatVersion = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationApp) SetWorkloadType(v string) *GetK8sApplicationResponseBodyApplcationApp {
	s.WorkloadType = &v
	return s
}

type GetK8sApplicationResponseBodyApplcationAppCmdArgs struct {
	CmdArg []*string `json:"CmdArg,omitempty" xml:"CmdArg,omitempty" type:"Repeated"`
}

func (s GetK8sApplicationResponseBodyApplcationAppCmdArgs) String() string {
	return tea.Prettify(s)
}

func (s GetK8sApplicationResponseBodyApplcationAppCmdArgs) GoString() string {
	return s.String()
}

func (s *GetK8sApplicationResponseBodyApplcationAppCmdArgs) SetCmdArg(v []*string) *GetK8sApplicationResponseBodyApplcationAppCmdArgs {
	s.CmdArg = v
	return s
}

type GetK8sApplicationResponseBodyApplcationAppEnvList struct {
	Env []*GetK8sApplicationResponseBodyApplcationAppEnvListEnv `json:"Env,omitempty" xml:"Env,omitempty" type:"Repeated"`
}

func (s GetK8sApplicationResponseBodyApplcationAppEnvList) String() string {
	return tea.Prettify(s)
}

func (s GetK8sApplicationResponseBodyApplcationAppEnvList) GoString() string {
	return s.String()
}

func (s *GetK8sApplicationResponseBodyApplcationAppEnvList) SetEnv(v []*GetK8sApplicationResponseBodyApplcationAppEnvListEnv) *GetK8sApplicationResponseBodyApplcationAppEnvList {
	s.Env = v
	return s
}

type GetK8sApplicationResponseBodyApplcationAppEnvListEnv struct {
	// The name of the environment variable.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The value of the environment variable.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetK8sApplicationResponseBodyApplcationAppEnvListEnv) String() string {
	return tea.Prettify(s)
}

func (s GetK8sApplicationResponseBodyApplcationAppEnvListEnv) GoString() string {
	return s.String()
}

func (s *GetK8sApplicationResponseBodyApplcationAppEnvListEnv) SetName(v string) *GetK8sApplicationResponseBodyApplcationAppEnvListEnv {
	s.Name = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationAppEnvListEnv) SetValue(v string) *GetK8sApplicationResponseBodyApplcationAppEnvListEnv {
	s.Value = &v
	return s
}

type GetK8sApplicationResponseBodyApplcationConf struct {
	// The affinity configuration of the pod.
	Affinity *string `json:"Affinity,omitempty" xml:"Affinity,omitempty"`
	// Indicates whether the application is connected to Application High Availability Service (AHAS).
	AhasEnabled *bool `json:"AhasEnabled,omitempty" xml:"AhasEnabled,omitempty"`
	// Indicates whether the application instances are deployed across nodes.
	//
	// *   Value `true` indicates that the application instances are deployed across nodes.
	// *   Other values indicate that the application instances are not deployed across nodes.
	DeployAcrossNodes *string `json:"DeployAcrossNodes,omitempty" xml:"DeployAcrossNodes,omitempty"`
	// Indicates whether the application instances are deployed across zones.
	//
	// *   Value `true` indicates that the application instances are deployed across zones.
	// *   Other values indicate that the application instances are not deployed across zones.
	DeployAcrossZones *string `json:"DeployAcrossZones,omitempty" xml:"DeployAcrossZones,omitempty"`
	// The startup parameters for a JAR application. This parameter is deprecated.
	JarStartArgs *string `json:"JarStartArgs,omitempty" xml:"JarStartArgs,omitempty"`
	// The startup options for a JAR application. This parameter is deprecated.
	JarStartOptions *string `json:"JarStartOptions,omitempty" xml:"JarStartOptions,omitempty"`
	// The startup command.
	K8sCmd *string `json:"K8sCmd,omitempty" xml:"K8sCmd,omitempty"`
	// The parameters of the startup command.
	K8sCmdArgs *string `json:"K8sCmdArgs,omitempty" xml:"K8sCmdArgs,omitempty"`
	// The information about the local storage.
	K8sLocalvolumeInfo *string `json:"K8sLocalvolumeInfo,omitempty" xml:"K8sLocalvolumeInfo,omitempty"`
	// The information about the Apsara File Storage NAS (NAS) storage.
	K8sNasInfo *string `json:"K8sNasInfo,omitempty" xml:"K8sNasInfo,omitempty"`
	// The information about the storage.
	K8sVolumeInfo *string `json:"K8sVolumeInfo,omitempty" xml:"K8sVolumeInfo,omitempty"`
	// The information about the liveness check on the container.
	Liveness *string `json:"Liveness,omitempty" xml:"Liveness,omitempty"`
	// The script executed after the container is started.
	PostStart *string `json:"PostStart,omitempty" xml:"PostStart,omitempty"`
	// The script executed before the container is stopped.
	PreStop *string `json:"PreStop,omitempty" xml:"PreStop,omitempty"`
	// The information about the readiness check on the container.
	Readiness *string `json:"Readiness,omitempty" xml:"Readiness,omitempty"`
	// The type of the container runtime. This parameter is applicable only to clusters that use sandboxed containers.
	RuntimeClassName *string `json:"RuntimeClassName,omitempty" xml:"RuntimeClassName,omitempty"`
	// The scheduling tolerance configuration of the pod.
	Tolerations *string `json:"Tolerations,omitempty" xml:"Tolerations,omitempty"`
	// The URL of the base image. If you use a custom Java Development Kit (JDK) runtime, you must specify this parameter.
	UserBaseImageUrl *string `json:"UserBaseImageUrl,omitempty" xml:"UserBaseImageUrl,omitempty"`
}

func (s GetK8sApplicationResponseBodyApplcationConf) String() string {
	return tea.Prettify(s)
}

func (s GetK8sApplicationResponseBodyApplcationConf) GoString() string {
	return s.String()
}

func (s *GetK8sApplicationResponseBodyApplcationConf) SetAffinity(v string) *GetK8sApplicationResponseBodyApplcationConf {
	s.Affinity = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationConf) SetAhasEnabled(v bool) *GetK8sApplicationResponseBodyApplcationConf {
	s.AhasEnabled = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationConf) SetDeployAcrossNodes(v string) *GetK8sApplicationResponseBodyApplcationConf {
	s.DeployAcrossNodes = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationConf) SetDeployAcrossZones(v string) *GetK8sApplicationResponseBodyApplcationConf {
	s.DeployAcrossZones = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationConf) SetJarStartArgs(v string) *GetK8sApplicationResponseBodyApplcationConf {
	s.JarStartArgs = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationConf) SetJarStartOptions(v string) *GetK8sApplicationResponseBodyApplcationConf {
	s.JarStartOptions = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationConf) SetK8sCmd(v string) *GetK8sApplicationResponseBodyApplcationConf {
	s.K8sCmd = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationConf) SetK8sCmdArgs(v string) *GetK8sApplicationResponseBodyApplcationConf {
	s.K8sCmdArgs = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationConf) SetK8sLocalvolumeInfo(v string) *GetK8sApplicationResponseBodyApplcationConf {
	s.K8sLocalvolumeInfo = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationConf) SetK8sNasInfo(v string) *GetK8sApplicationResponseBodyApplcationConf {
	s.K8sNasInfo = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationConf) SetK8sVolumeInfo(v string) *GetK8sApplicationResponseBodyApplcationConf {
	s.K8sVolumeInfo = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationConf) SetLiveness(v string) *GetK8sApplicationResponseBodyApplcationConf {
	s.Liveness = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationConf) SetPostStart(v string) *GetK8sApplicationResponseBodyApplcationConf {
	s.PostStart = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationConf) SetPreStop(v string) *GetK8sApplicationResponseBodyApplcationConf {
	s.PreStop = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationConf) SetReadiness(v string) *GetK8sApplicationResponseBodyApplcationConf {
	s.Readiness = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationConf) SetRuntimeClassName(v string) *GetK8sApplicationResponseBodyApplcationConf {
	s.RuntimeClassName = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationConf) SetTolerations(v string) *GetK8sApplicationResponseBodyApplcationConf {
	s.Tolerations = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationConf) SetUserBaseImageUrl(v string) *GetK8sApplicationResponseBodyApplcationConf {
	s.UserBaseImageUrl = &v
	return s
}

type GetK8sApplicationResponseBodyApplcationDeployGroups struct {
	DeployGroup []*GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroup `json:"DeployGroup,omitempty" xml:"DeployGroup,omitempty" type:"Repeated"`
}

func (s GetK8sApplicationResponseBodyApplcationDeployGroups) String() string {
	return tea.Prettify(s)
}

func (s GetK8sApplicationResponseBodyApplcationDeployGroups) GoString() string {
	return s.String()
}

func (s *GetK8sApplicationResponseBodyApplcationDeployGroups) SetDeployGroup(v []*GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroup) *GetK8sApplicationResponseBodyApplcationDeployGroups {
	s.DeployGroup = v
	return s
}

type GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroup struct {
	// The information about the component.
	Components *GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponents `json:"Components,omitempty" xml:"Components,omitempty" type:"Struct"`
	// The environment variable. This parameter is different from the EnvList parameter. This parameter specifies the referenced configuration of the ConfigMap or Secret.
	Env *string `json:"Env,omitempty" xml:"Env,omitempty"`
	// The source of the environment variable.
	EnvFrom *string `json:"EnvFrom,omitempty" xml:"EnvFrom,omitempty"`
}

func (s GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroup) String() string {
	return tea.Prettify(s)
}

func (s GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroup) GoString() string {
	return s.String()
}

func (s *GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroup) SetComponents(v *GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponents) *GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroup {
	s.Components = v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroup) SetEnv(v string) *GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroup {
	s.Env = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroup) SetEnvFrom(v string) *GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroup {
	s.EnvFrom = &v
	return s
}

type GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponents struct {
	Components []*GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponentsComponents `json:"Components,omitempty" xml:"Components,omitempty" type:"Repeated"`
}

func (s GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponents) String() string {
	return tea.Prettify(s)
}

func (s GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponents) GoString() string {
	return s.String()
}

func (s *GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponents) SetComponents(v []*GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponentsComponents) *GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponents {
	s.Components = v
	return s
}

type GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponentsComponents struct {
	// The component ID.
	ComponentId *string `json:"ComponentId,omitempty" xml:"ComponentId,omitempty"`
	// The keyword that is included in the component name.
	ComponentKey *string `json:"ComponentKey,omitempty" xml:"ComponentKey,omitempty"`
	// The component type. Valid values:
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponentsComponents) String() string {
	return tea.Prettify(s)
}

func (s GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponentsComponents) GoString() string {
	return s.String()
}

func (s *GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponentsComponents) SetComponentId(v string) *GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponentsComponents {
	s.ComponentId = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponentsComponents) SetComponentKey(v string) *GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponentsComponents {
	s.ComponentKey = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponentsComponents) SetType(v string) *GetK8sApplicationResponseBodyApplcationDeployGroupsDeployGroupComponentsComponents {
	s.Type = &v
	return s
}

type GetK8sApplicationResponseBodyApplcationImageInfo struct {
	// The URL of the image.
	ImageUrl *string `json:"ImageUrl,omitempty" xml:"ImageUrl,omitempty"`
	// The region ID of the image repository.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the image repository.
	RepoId *string `json:"RepoId,omitempty" xml:"RepoId,omitempty"`
	// The name of the image repository.
	RepoName *string `json:"RepoName,omitempty" xml:"RepoName,omitempty"`
	// The namespace to which the image repository belongs.
	RepoNamespace *string `json:"RepoNamespace,omitempty" xml:"RepoNamespace,omitempty"`
	// The source type of the image repository.
	RepoOriginType *string `json:"RepoOriginType,omitempty" xml:"RepoOriginType,omitempty"`
	// The tag of the image.
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
}

func (s GetK8sApplicationResponseBodyApplcationImageInfo) String() string {
	return tea.Prettify(s)
}

func (s GetK8sApplicationResponseBodyApplcationImageInfo) GoString() string {
	return s.String()
}

func (s *GetK8sApplicationResponseBodyApplcationImageInfo) SetImageUrl(v string) *GetK8sApplicationResponseBodyApplcationImageInfo {
	s.ImageUrl = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationImageInfo) SetRegionId(v string) *GetK8sApplicationResponseBodyApplcationImageInfo {
	s.RegionId = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationImageInfo) SetRepoId(v string) *GetK8sApplicationResponseBodyApplcationImageInfo {
	s.RepoId = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationImageInfo) SetRepoName(v string) *GetK8sApplicationResponseBodyApplcationImageInfo {
	s.RepoName = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationImageInfo) SetRepoNamespace(v string) *GetK8sApplicationResponseBodyApplcationImageInfo {
	s.RepoNamespace = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationImageInfo) SetRepoOriginType(v string) *GetK8sApplicationResponseBodyApplcationImageInfo {
	s.RepoOriginType = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationImageInfo) SetTag(v string) *GetK8sApplicationResponseBodyApplcationImageInfo {
	s.Tag = &v
	return s
}

type GetK8sApplicationResponseBodyApplcationLatestVersion struct {
	// The version of the deployment package.
	PackageVersion *string `json:"PackageVersion,omitempty" xml:"PackageVersion,omitempty"`
	// The URL of the deployment package. This parameter is required if you use a FatJar or WAR package to deploy the application.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
	// The URL of the deployment package. This parameter is required if you use a FatJar or WAR package to deploy the application.
	WarUrl *string `json:"WarUrl,omitempty" xml:"WarUrl,omitempty"`
}

func (s GetK8sApplicationResponseBodyApplcationLatestVersion) String() string {
	return tea.Prettify(s)
}

func (s GetK8sApplicationResponseBodyApplcationLatestVersion) GoString() string {
	return s.String()
}

func (s *GetK8sApplicationResponseBodyApplcationLatestVersion) SetPackageVersion(v string) *GetK8sApplicationResponseBodyApplcationLatestVersion {
	s.PackageVersion = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationLatestVersion) SetUrl(v string) *GetK8sApplicationResponseBodyApplcationLatestVersion {
	s.Url = &v
	return s
}

func (s *GetK8sApplicationResponseBodyApplcationLatestVersion) SetWarUrl(v string) *GetK8sApplicationResponseBodyApplcationLatestVersion {
	s.WarUrl = &v
	return s
}

type GetK8sApplicationResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetK8sApplicationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetK8sApplicationResponse) String() string {
	return tea.Prettify(s)
}

func (s GetK8sApplicationResponse) GoString() string {
	return s.String()
}

func (s *GetK8sApplicationResponse) SetHeaders(v map[string]*string) *GetK8sApplicationResponse {
	s.Headers = v
	return s
}

func (s *GetK8sApplicationResponse) SetStatusCode(v int32) *GetK8sApplicationResponse {
	s.StatusCode = &v
	return s
}

func (s *GetK8sApplicationResponse) SetBody(v *GetK8sApplicationResponseBody) *GetK8sApplicationResponse {
	s.Body = v
	return s
}

type GetK8sClusterRequest struct {
	// The type of the Kubernetes cluster. Valid values:
	//
	// *   5: ACK cluster
	// *   7: self-managed Kubernetes cluster
	ClusterType *int32 `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The number of the page to return. Default value: 1.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The number of entries to return on each page. Default value: 1000.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region.
	RegionTag *string `json:"RegionTag,omitempty" xml:"RegionTag,omitempty"`
	// The subtype of the cluster. Valid values:
	//
	// *   Ask: Serverless Kubernetes cluster
	// *   ManagedKubernetes: ACK cluster
	SubClusterType *string `json:"SubClusterType,omitempty" xml:"SubClusterType,omitempty"`
}

func (s GetK8sClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s GetK8sClusterRequest) GoString() string {
	return s.String()
}

func (s *GetK8sClusterRequest) SetClusterType(v int32) *GetK8sClusterRequest {
	s.ClusterType = &v
	return s
}

func (s *GetK8sClusterRequest) SetCurrentPage(v int32) *GetK8sClusterRequest {
	s.CurrentPage = &v
	return s
}

func (s *GetK8sClusterRequest) SetPageSize(v int32) *GetK8sClusterRequest {
	s.PageSize = &v
	return s
}

func (s *GetK8sClusterRequest) SetRegionTag(v string) *GetK8sClusterRequest {
	s.RegionTag = &v
	return s
}

func (s *GetK8sClusterRequest) SetSubClusterType(v string) *GetK8sClusterRequest {
	s.SubClusterType = &v
	return s
}

type GetK8sClusterResponseBody struct {
	// The cluster data that is returned by page.
	ClusterPage *GetK8sClusterResponseBodyClusterPage `json:"ClusterPage,omitempty" xml:"ClusterPage,omitempty" type:"Struct"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetK8sClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetK8sClusterResponseBody) GoString() string {
	return s.String()
}

func (s *GetK8sClusterResponseBody) SetClusterPage(v *GetK8sClusterResponseBodyClusterPage) *GetK8sClusterResponseBody {
	s.ClusterPage = v
	return s
}

func (s *GetK8sClusterResponseBody) SetCode(v int32) *GetK8sClusterResponseBody {
	s.Code = &v
	return s
}

func (s *GetK8sClusterResponseBody) SetMessage(v string) *GetK8sClusterResponseBody {
	s.Message = &v
	return s
}

func (s *GetK8sClusterResponseBody) SetRequestId(v string) *GetK8sClusterResponseBody {
	s.RequestId = &v
	return s
}

type GetK8sClusterResponseBodyClusterPage struct {
	// The list of clusters.
	ClusterList *GetK8sClusterResponseBodyClusterPageClusterList `json:"ClusterList,omitempty" xml:"ClusterList,omitempty" type:"Struct"`
	// The number of the returned page. Default value: 1.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The number of entries returned per page. Default value: 1000.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of pages that are returned.
	TotalSize *int32 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s GetK8sClusterResponseBodyClusterPage) String() string {
	return tea.Prettify(s)
}

func (s GetK8sClusterResponseBodyClusterPage) GoString() string {
	return s.String()
}

func (s *GetK8sClusterResponseBodyClusterPage) SetClusterList(v *GetK8sClusterResponseBodyClusterPageClusterList) *GetK8sClusterResponseBodyClusterPage {
	s.ClusterList = v
	return s
}

func (s *GetK8sClusterResponseBodyClusterPage) SetCurrentPage(v int32) *GetK8sClusterResponseBodyClusterPage {
	s.CurrentPage = &v
	return s
}

func (s *GetK8sClusterResponseBodyClusterPage) SetPageSize(v int32) *GetK8sClusterResponseBodyClusterPage {
	s.PageSize = &v
	return s
}

func (s *GetK8sClusterResponseBodyClusterPage) SetTotalSize(v int32) *GetK8sClusterResponseBodyClusterPage {
	s.TotalSize = &v
	return s
}

type GetK8sClusterResponseBodyClusterPageClusterList struct {
	Cluster []*GetK8sClusterResponseBodyClusterPageClusterListCluster `json:"Cluster,omitempty" xml:"Cluster,omitempty" type:"Repeated"`
}

func (s GetK8sClusterResponseBodyClusterPageClusterList) String() string {
	return tea.Prettify(s)
}

func (s GetK8sClusterResponseBodyClusterPageClusterList) GoString() string {
	return s.String()
}

func (s *GetK8sClusterResponseBodyClusterPageClusterList) SetCluster(v []*GetK8sClusterResponseBodyClusterPageClusterListCluster) *GetK8sClusterResponseBodyClusterPageClusterList {
	s.Cluster = v
	return s
}

type GetK8sClusterResponseBodyClusterPageClusterListCluster struct {
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The import state of the cluster. Valid values:
	//
	// *   0: The cluster is not imported.
	// *   1: The cluster is imported.
	// *   2: The cluster fails to be imported.
	// *   3: The cluster is being imported.
	// *   4: The cluster is deleted.
	ClusterImportStatus *int32 `json:"ClusterImportStatus,omitempty" xml:"ClusterImportStatus,omitempty"`
	// The name of the cluster.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The status of the cluster. Valid values:
	//
	// *   1: The cluster runs as expected.
	// *   2: The cluster does not run as expected.
	// *   3: The cluster is offline.
	ClusterStatus *int32 `json:"ClusterStatus,omitempty" xml:"ClusterStatus,omitempty"`
	// The type of the cluster. Valid values:
	//
	// *   2: Elastic Compute Service (ECS) cluster
	// *   5: ACK cluster or Serverless Kubernetes cluster
	ClusterType *int32 `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The total number of CPU cores.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The ID of the ACK cluster.
	CsClusterId *string `json:"CsClusterId,omitempty" xml:"CsClusterId,omitempty"`
	// The state of the ACK cluster. Valid values:
	//
	// *   initial: The cluster is being initialized.
	// *   failed: The cluster fails to be created.
	// *   running: The cluster is running.
	// *   updating: The cluster is being updated.
	// *   scaling: The cluster is being scaled out.
	// *   removing: Nodes are being removed from the cluster.
	// *   upgrading: The cluster is being upgraded.
	// *   deleting: The cluster is being deleted.
	// *   delete_failed: The cluster fails to be deleted.
	// *   deleted: The cluster is deleted. The deleted cluster is invisible to users.
	CsClusterStatus *string `json:"CsClusterStatus,omitempty" xml:"CsClusterStatus,omitempty"`
	// The description of the cluster.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The total size of memory. Unit: MB.
	Mem *int32 `json:"Mem,omitempty" xml:"Mem,omitempty"`
	// The network type of the cluster. Valid values:
	//
	// *   1: classic network
	// *   2: VPC
	NetworkMode *int32 `json:"NetworkMode,omitempty" xml:"NetworkMode,omitempty"`
	// The number of nodes.
	NodeNum *int32 `json:"NodeNum,omitempty" xml:"NodeNum,omitempty"`
	// The ID of the namespace.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The subtype of the cluster. Valid values:
	//
	// *   Ask: Serverless Kubernetes cluster
	// *   ManagedKubernetes: ACK cluster
	SubClusterType *string `json:"SubClusterType,omitempty" xml:"SubClusterType,omitempty"`
	// The CIDR block of the subnet.
	SubNetCidr *string `json:"SubNetCidr,omitempty" xml:"SubNetCidr,omitempty"`
	// The ID of the virtual private cloud (VPC).
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The ID of the vSwitch.
	VswitchId *string `json:"VswitchId,omitempty" xml:"VswitchId,omitempty"`
}

func (s GetK8sClusterResponseBodyClusterPageClusterListCluster) String() string {
	return tea.Prettify(s)
}

func (s GetK8sClusterResponseBodyClusterPageClusterListCluster) GoString() string {
	return s.String()
}

func (s *GetK8sClusterResponseBodyClusterPageClusterListCluster) SetClusterId(v string) *GetK8sClusterResponseBodyClusterPageClusterListCluster {
	s.ClusterId = &v
	return s
}

func (s *GetK8sClusterResponseBodyClusterPageClusterListCluster) SetClusterImportStatus(v int32) *GetK8sClusterResponseBodyClusterPageClusterListCluster {
	s.ClusterImportStatus = &v
	return s
}

func (s *GetK8sClusterResponseBodyClusterPageClusterListCluster) SetClusterName(v string) *GetK8sClusterResponseBodyClusterPageClusterListCluster {
	s.ClusterName = &v
	return s
}

func (s *GetK8sClusterResponseBodyClusterPageClusterListCluster) SetClusterStatus(v int32) *GetK8sClusterResponseBodyClusterPageClusterListCluster {
	s.ClusterStatus = &v
	return s
}

func (s *GetK8sClusterResponseBodyClusterPageClusterListCluster) SetClusterType(v int32) *GetK8sClusterResponseBodyClusterPageClusterListCluster {
	s.ClusterType = &v
	return s
}

func (s *GetK8sClusterResponseBodyClusterPageClusterListCluster) SetCpu(v int32) *GetK8sClusterResponseBodyClusterPageClusterListCluster {
	s.Cpu = &v
	return s
}

func (s *GetK8sClusterResponseBodyClusterPageClusterListCluster) SetCsClusterId(v string) *GetK8sClusterResponseBodyClusterPageClusterListCluster {
	s.CsClusterId = &v
	return s
}

func (s *GetK8sClusterResponseBodyClusterPageClusterListCluster) SetCsClusterStatus(v string) *GetK8sClusterResponseBodyClusterPageClusterListCluster {
	s.CsClusterStatus = &v
	return s
}

func (s *GetK8sClusterResponseBodyClusterPageClusterListCluster) SetDescription(v string) *GetK8sClusterResponseBodyClusterPageClusterListCluster {
	s.Description = &v
	return s
}

func (s *GetK8sClusterResponseBodyClusterPageClusterListCluster) SetMem(v int32) *GetK8sClusterResponseBodyClusterPageClusterListCluster {
	s.Mem = &v
	return s
}

func (s *GetK8sClusterResponseBodyClusterPageClusterListCluster) SetNetworkMode(v int32) *GetK8sClusterResponseBodyClusterPageClusterListCluster {
	s.NetworkMode = &v
	return s
}

func (s *GetK8sClusterResponseBodyClusterPageClusterListCluster) SetNodeNum(v int32) *GetK8sClusterResponseBodyClusterPageClusterListCluster {
	s.NodeNum = &v
	return s
}

func (s *GetK8sClusterResponseBodyClusterPageClusterListCluster) SetRegionId(v string) *GetK8sClusterResponseBodyClusterPageClusterListCluster {
	s.RegionId = &v
	return s
}

func (s *GetK8sClusterResponseBodyClusterPageClusterListCluster) SetSubClusterType(v string) *GetK8sClusterResponseBodyClusterPageClusterListCluster {
	s.SubClusterType = &v
	return s
}

func (s *GetK8sClusterResponseBodyClusterPageClusterListCluster) SetSubNetCidr(v string) *GetK8sClusterResponseBodyClusterPageClusterListCluster {
	s.SubNetCidr = &v
	return s
}

func (s *GetK8sClusterResponseBodyClusterPageClusterListCluster) SetVpcId(v string) *GetK8sClusterResponseBodyClusterPageClusterListCluster {
	s.VpcId = &v
	return s
}

func (s *GetK8sClusterResponseBodyClusterPageClusterListCluster) SetVswitchId(v string) *GetK8sClusterResponseBodyClusterPageClusterListCluster {
	s.VswitchId = &v
	return s
}

type GetK8sClusterResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetK8sClusterResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetK8sClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s GetK8sClusterResponse) GoString() string {
	return s.String()
}

func (s *GetK8sClusterResponse) SetHeaders(v map[string]*string) *GetK8sClusterResponse {
	s.Headers = v
	return s
}

func (s *GetK8sClusterResponse) SetStatusCode(v int32) *GetK8sClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *GetK8sClusterResponse) SetBody(v *GetK8sClusterResponseBody) *GetK8sClusterResponse {
	s.Body = v
	return s
}

type GetK8sServicesRequest struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
}

func (s GetK8sServicesRequest) String() string {
	return tea.Prettify(s)
}

func (s GetK8sServicesRequest) GoString() string {
	return s.String()
}

func (s *GetK8sServicesRequest) SetAppId(v string) *GetK8sServicesRequest {
	s.AppId = &v
	return s
}

type GetK8sServicesResponseBody struct {
	// The ID of the change process.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of services in the Kubernetes cluster.
	Services []*GetK8sServicesResponseBodyServices `json:"Services,omitempty" xml:"Services,omitempty" type:"Repeated"`
}

func (s GetK8sServicesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetK8sServicesResponseBody) GoString() string {
	return s.String()
}

func (s *GetK8sServicesResponseBody) SetCode(v int32) *GetK8sServicesResponseBody {
	s.Code = &v
	return s
}

func (s *GetK8sServicesResponseBody) SetMessage(v string) *GetK8sServicesResponseBody {
	s.Message = &v
	return s
}

func (s *GetK8sServicesResponseBody) SetRequestId(v string) *GetK8sServicesResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetK8sServicesResponseBody) SetServices(v []*GetK8sServicesResponseBodyServices) *GetK8sServicesResponseBody {
	s.Services = v
	return s
}

type GetK8sServicesResponseBodyServices struct {
	// The IP address of the service in the Kubernetes cluster.
	ClusterIP *string `json:"ClusterIP,omitempty" xml:"ClusterIP,omitempty"`
	// The name of the service.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The mapping of service ports.
	ServicePorts []*GetK8sServicesResponseBodyServicesServicePorts `json:"ServicePorts,omitempty" xml:"ServicePorts,omitempty" type:"Repeated"`
	// The type of the service.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetK8sServicesResponseBodyServices) String() string {
	return tea.Prettify(s)
}

func (s GetK8sServicesResponseBodyServices) GoString() string {
	return s.String()
}

func (s *GetK8sServicesResponseBodyServices) SetClusterIP(v string) *GetK8sServicesResponseBodyServices {
	s.ClusterIP = &v
	return s
}

func (s *GetK8sServicesResponseBodyServices) SetName(v string) *GetK8sServicesResponseBodyServices {
	s.Name = &v
	return s
}

func (s *GetK8sServicesResponseBodyServices) SetServicePorts(v []*GetK8sServicesResponseBodyServicesServicePorts) *GetK8sServicesResponseBodyServices {
	s.ServicePorts = v
	return s
}

func (s *GetK8sServicesResponseBodyServices) SetType(v string) *GetK8sServicesResponseBodyServices {
	s.Type = &v
	return s
}

type GetK8sServicesResponseBodyServicesServicePorts struct {
	// The port of the node.
	NodePort *int32 `json:"NodePort,omitempty" xml:"NodePort,omitempty"`
	// The frontend service port.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The protocol of the service.
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The backend container port.
	TargetPort *string `json:"TargetPort,omitempty" xml:"TargetPort,omitempty"`
}

func (s GetK8sServicesResponseBodyServicesServicePorts) String() string {
	return tea.Prettify(s)
}

func (s GetK8sServicesResponseBodyServicesServicePorts) GoString() string {
	return s.String()
}

func (s *GetK8sServicesResponseBodyServicesServicePorts) SetNodePort(v int32) *GetK8sServicesResponseBodyServicesServicePorts {
	s.NodePort = &v
	return s
}

func (s *GetK8sServicesResponseBodyServicesServicePorts) SetPort(v int32) *GetK8sServicesResponseBodyServicesServicePorts {
	s.Port = &v
	return s
}

func (s *GetK8sServicesResponseBodyServicesServicePorts) SetProtocol(v string) *GetK8sServicesResponseBodyServicesServicePorts {
	s.Protocol = &v
	return s
}

func (s *GetK8sServicesResponseBodyServicesServicePorts) SetTargetPort(v string) *GetK8sServicesResponseBodyServicesServicePorts {
	s.TargetPort = &v
	return s
}

type GetK8sServicesResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetK8sServicesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetK8sServicesResponse) String() string {
	return tea.Prettify(s)
}

func (s GetK8sServicesResponse) GoString() string {
	return s.String()
}

func (s *GetK8sServicesResponse) SetHeaders(v map[string]*string) *GetK8sServicesResponse {
	s.Headers = v
	return s
}

func (s *GetK8sServicesResponse) SetStatusCode(v int32) *GetK8sServicesResponse {
	s.StatusCode = &v
	return s
}

func (s *GetK8sServicesResponse) SetBody(v *GetK8sServicesResponseBody) *GetK8sServicesResponse {
	s.Body = v
	return s
}

type GetPackageStorageCredentialResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The STS credential.
	Credential *GetPackageStorageCredentialResponseBodyCredential `json:"Credential,omitempty" xml:"Credential,omitempty" type:"Struct"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetPackageStorageCredentialResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetPackageStorageCredentialResponseBody) GoString() string {
	return s.String()
}

func (s *GetPackageStorageCredentialResponseBody) SetCode(v int32) *GetPackageStorageCredentialResponseBody {
	s.Code = &v
	return s
}

func (s *GetPackageStorageCredentialResponseBody) SetCredential(v *GetPackageStorageCredentialResponseBodyCredential) *GetPackageStorageCredentialResponseBody {
	s.Credential = v
	return s
}

func (s *GetPackageStorageCredentialResponseBody) SetMessage(v string) *GetPackageStorageCredentialResponseBody {
	s.Message = &v
	return s
}

func (s *GetPackageStorageCredentialResponseBody) SetRequestId(v string) *GetPackageStorageCredentialResponseBody {
	s.RequestId = &v
	return s
}

type GetPackageStorageCredentialResponseBodyCredential struct {
	// The AccessKey ID of your account.
	AccessKeyId *string `json:"AccessKeyId,omitempty" xml:"AccessKeyId,omitempty"`
	// The AccessKey secret of your account.
	AccessKeySecret *string `json:"AccessKeySecret,omitempty" xml:"AccessKeySecret,omitempty"`
	// The name of the OSS bucket.
	Bucket *string `json:"Bucket,omitempty" xml:"Bucket,omitempty"`
	// The time when the STS credential expires. Example: 2019-11-10T07:20:19Z.
	Expiration *string `json:"Expiration,omitempty" xml:"Expiration,omitempty"`
	// The object key prefix in Object Storage Service (OSS).
	KeyPrefix *string `json:"KeyPrefix,omitempty" xml:"KeyPrefix,omitempty"`
	// The private endpoint of OSS.
	OssInternalEndpoint *string `json:"OssInternalEndpoint,omitempty" xml:"OssInternalEndpoint,omitempty"`
	// The public endpoint of OSS.
	OssPublicEndpoint *string `json:"OssPublicEndpoint,omitempty" xml:"OssPublicEndpoint,omitempty"`
	// The VPC endpoint of OSS.
	OssVpcEndpoint *string `json:"OssVpcEndpoint,omitempty" xml:"OssVpcEndpoint,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The security token issued by STS.
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s GetPackageStorageCredentialResponseBodyCredential) String() string {
	return tea.Prettify(s)
}

func (s GetPackageStorageCredentialResponseBodyCredential) GoString() string {
	return s.String()
}

func (s *GetPackageStorageCredentialResponseBodyCredential) SetAccessKeyId(v string) *GetPackageStorageCredentialResponseBodyCredential {
	s.AccessKeyId = &v
	return s
}

func (s *GetPackageStorageCredentialResponseBodyCredential) SetAccessKeySecret(v string) *GetPackageStorageCredentialResponseBodyCredential {
	s.AccessKeySecret = &v
	return s
}

func (s *GetPackageStorageCredentialResponseBodyCredential) SetBucket(v string) *GetPackageStorageCredentialResponseBodyCredential {
	s.Bucket = &v
	return s
}

func (s *GetPackageStorageCredentialResponseBodyCredential) SetExpiration(v string) *GetPackageStorageCredentialResponseBodyCredential {
	s.Expiration = &v
	return s
}

func (s *GetPackageStorageCredentialResponseBodyCredential) SetKeyPrefix(v string) *GetPackageStorageCredentialResponseBodyCredential {
	s.KeyPrefix = &v
	return s
}

func (s *GetPackageStorageCredentialResponseBodyCredential) SetOssInternalEndpoint(v string) *GetPackageStorageCredentialResponseBodyCredential {
	s.OssInternalEndpoint = &v
	return s
}

func (s *GetPackageStorageCredentialResponseBodyCredential) SetOssPublicEndpoint(v string) *GetPackageStorageCredentialResponseBodyCredential {
	s.OssPublicEndpoint = &v
	return s
}

func (s *GetPackageStorageCredentialResponseBodyCredential) SetOssVpcEndpoint(v string) *GetPackageStorageCredentialResponseBodyCredential {
	s.OssVpcEndpoint = &v
	return s
}

func (s *GetPackageStorageCredentialResponseBodyCredential) SetRegionId(v string) *GetPackageStorageCredentialResponseBodyCredential {
	s.RegionId = &v
	return s
}

func (s *GetPackageStorageCredentialResponseBodyCredential) SetSecurityToken(v string) *GetPackageStorageCredentialResponseBodyCredential {
	s.SecurityToken = &v
	return s
}

type GetPackageStorageCredentialResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetPackageStorageCredentialResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetPackageStorageCredentialResponse) String() string {
	return tea.Prettify(s)
}

func (s GetPackageStorageCredentialResponse) GoString() string {
	return s.String()
}

func (s *GetPackageStorageCredentialResponse) SetHeaders(v map[string]*string) *GetPackageStorageCredentialResponse {
	s.Headers = v
	return s
}

func (s *GetPackageStorageCredentialResponse) SetStatusCode(v int32) *GetPackageStorageCredentialResponse {
	s.StatusCode = &v
	return s
}

func (s *GetPackageStorageCredentialResponse) SetBody(v *GetPackageStorageCredentialResponseBody) *GetPackageStorageCredentialResponse {
	s.Body = v
	return s
}

type GetScalingRulesRequest struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the instance group to which the application is deployed.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The type of the scaling rule. You can leave this parameter empty. Valid values:
	//
	// *   SCALE_IN: scale-in rules
	// *   SCALE_OUT: scale-out rules
	Mode *string `json:"Mode,omitempty" xml:"Mode,omitempty"`
}

func (s GetScalingRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s GetScalingRulesRequest) GoString() string {
	return s.String()
}

func (s *GetScalingRulesRequest) SetAppId(v string) *GetScalingRulesRequest {
	s.AppId = &v
	return s
}

func (s *GetScalingRulesRequest) SetGroupId(v string) *GetScalingRulesRequest {
	s.GroupId = &v
	return s
}

func (s *GetScalingRulesRequest) SetMode(v string) *GetScalingRulesRequest {
	s.Mode = &v
	return s
}

type GetScalingRulesResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data that is returned.
	Data *GetScalingRulesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The time when the scaling rule was last updated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s GetScalingRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetScalingRulesResponseBody) GoString() string {
	return s.String()
}

func (s *GetScalingRulesResponseBody) SetCode(v int32) *GetScalingRulesResponseBody {
	s.Code = &v
	return s
}

func (s *GetScalingRulesResponseBody) SetData(v *GetScalingRulesResponseBodyData) *GetScalingRulesResponseBody {
	s.Data = v
	return s
}

func (s *GetScalingRulesResponseBody) SetMessage(v string) *GetScalingRulesResponseBody {
	s.Message = &v
	return s
}

func (s *GetScalingRulesResponseBody) SetRequestId(v string) *GetScalingRulesResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetScalingRulesResponseBody) SetUpdateTime(v int64) *GetScalingRulesResponseBody {
	s.UpdateTime = &v
	return s
}

type GetScalingRulesResponseBodyData struct {
	// The type of the cluster. Valid values:
	//
	// *   0: regular Docker cluster
	// *   1: Swarm cluster (deprecated)
	// *   2: Elastic Compute Service (ECS) cluster
	// *   3: self-managed Kubernetes cluster in EDAS
	// *   4: cluster in which Pandora automatically registers applications
	// *   5: Container Service for Kubernetes (ACK) clusters
	ClusterType *int32 `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The overcommit ratio supported by a Docker cluster. Valid values:
	//
	// *   1: 1:1, which means that resources are not overcommitted.
	// *   2: 1:2, which means that resources are overcommitted by 1:2.
	// *   4: 1:4, which means that resources are overcommitted by 1:4.
	// *   8: 1:8, which means that resources are overcommitted by 1:8.
	OversoldFactor *int32 `json:"OversoldFactor,omitempty" xml:"OversoldFactor,omitempty"`
	// The array data of the scaling rule.
	RuleList *GetScalingRulesResponseBodyDataRuleList `json:"RuleList,omitempty" xml:"RuleList,omitempty" type:"Struct"`
	// The time when the scaling rule was last updated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The ID of the virtual private cloud (VPC).
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s GetScalingRulesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetScalingRulesResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetScalingRulesResponseBodyData) SetClusterType(v int32) *GetScalingRulesResponseBodyData {
	s.ClusterType = &v
	return s
}

func (s *GetScalingRulesResponseBodyData) SetOversoldFactor(v int32) *GetScalingRulesResponseBodyData {
	s.OversoldFactor = &v
	return s
}

func (s *GetScalingRulesResponseBodyData) SetRuleList(v *GetScalingRulesResponseBodyDataRuleList) *GetScalingRulesResponseBodyData {
	s.RuleList = v
	return s
}

func (s *GetScalingRulesResponseBodyData) SetUpdateTime(v int64) *GetScalingRulesResponseBodyData {
	s.UpdateTime = &v
	return s
}

func (s *GetScalingRulesResponseBodyData) SetVpcId(v string) *GetScalingRulesResponseBodyData {
	s.VpcId = &v
	return s
}

type GetScalingRulesResponseBodyDataRuleList struct {
	Rule []*GetScalingRulesResponseBodyDataRuleListRule `json:"Rule,omitempty" xml:"Rule,omitempty" type:"Repeated"`
}

func (s GetScalingRulesResponseBodyDataRuleList) String() string {
	return tea.Prettify(s)
}

func (s GetScalingRulesResponseBodyDataRuleList) GoString() string {
	return s.String()
}

func (s *GetScalingRulesResponseBodyDataRuleList) SetRule(v []*GetScalingRulesResponseBodyDataRuleListRule) *GetScalingRulesResponseBodyDataRuleList {
	s.Rule = v
	return s
}

type GetScalingRulesResponseBodyDataRuleListRule struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The relationship among the conditions that trigger the scaling rule.
	//
	// *   OR: one of the conditions
	// *   AND: all conditions
	Cond *string `json:"Cond,omitempty" xml:"Cond,omitempty"`
	// The minimum CPU utilization that triggers the scaling rule.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The time when the scaling rule was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The duration of the scaling rule. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	Duration *int32 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// Indicates whether scale-ins or scale-outs are allowed. Valid values:
	//
	// *   true: Scale-ins or scale-outs are allowed.
	// *   false: Scale-ins or scale-outs are disallowed.
	Enable *bool `json:"Enable,omitempty" xml:"Enable,omitempty"`
	// The ID of the instance group to which the application is deployed.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The maximum number of instances in the group when a scale-out is performed, or the minimum number of instances in the group when a scale-in is performed.
	InstNum *int32 `json:"InstNum,omitempty" xml:"InstNum,omitempty"`
	// The system load that triggers the scaling rule. The system load is evaluated based on the number of processes that are being executed by CPUs and the number of processes that wait to be executed by CPUs.
	LoadNum *int32 `json:"LoadNum,omitempty" xml:"LoadNum,omitempty"`
	// The type of the metric.
	MetricType *string `json:"MetricType,omitempty" xml:"MetricType,omitempty"`
	// The type of the scaling rule. Valid values:
	//
	// *   SCALE_IN: scale-in rules
	// *   SCALE_OUT: scale-out rules
	Mode *string `json:"Mode,omitempty" xml:"Mode,omitempty"`
	// The policy of auto scaling across multiple zones. Valid values:
	//
	// *   PRIORITY: The vSwitch that is first selected has the highest priority.
	// *   BALANCE: This policy evenly distributes instances across zones in which the vSwitches reside.
	MultiAzPolicy *string `json:"MultiAzPolicy,omitempty" xml:"MultiAzPolicy,omitempty"`
	// The source of the instance that you want to add during a scale-out. Valid values:
	//
	// *   NEW: Elastic resources are used.
	// *   AVAILABLE: The existing resources are used.
	// *   AVAILABLE_FIRST: The existing resources are used first.
	ResourceFrom *string `json:"ResourceFrom,omitempty" xml:"ResourceFrom,omitempty"`
	// The service latency that triggers the scaling rule. Unit: milliseconds.
	Rt *int32 `json:"Rt,omitempty" xml:"Rt,omitempty"`
	// The ID of the specification.
	SpecId *string `json:"SpecId,omitempty" xml:"SpecId,omitempty"`
	// The number of instances that are added during each scale-out or removed during each scale-in.
	Step *int32 `json:"Step,omitempty" xml:"Step,omitempty"`
	// The ID of the launch template.
	TemplateId *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The version of the launch template.
	TemplateVersion *int32 `json:"TemplateVersion,omitempty" xml:"TemplateVersion,omitempty"`
	// The time when the scaling rule was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The IDs of the vSwitches. The IDs of multiple vSwitches are separated by commas (,).
	VSwitchIds *string `json:"VSwitchIds,omitempty" xml:"VSwitchIds,omitempty"`
	// The ID of the VPC.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s GetScalingRulesResponseBodyDataRuleListRule) String() string {
	return tea.Prettify(s)
}

func (s GetScalingRulesResponseBodyDataRuleListRule) GoString() string {
	return s.String()
}

func (s *GetScalingRulesResponseBodyDataRuleListRule) SetAppId(v string) *GetScalingRulesResponseBodyDataRuleListRule {
	s.AppId = &v
	return s
}

func (s *GetScalingRulesResponseBodyDataRuleListRule) SetCond(v string) *GetScalingRulesResponseBodyDataRuleListRule {
	s.Cond = &v
	return s
}

func (s *GetScalingRulesResponseBodyDataRuleListRule) SetCpu(v int32) *GetScalingRulesResponseBodyDataRuleListRule {
	s.Cpu = &v
	return s
}

func (s *GetScalingRulesResponseBodyDataRuleListRule) SetCreateTime(v int64) *GetScalingRulesResponseBodyDataRuleListRule {
	s.CreateTime = &v
	return s
}

func (s *GetScalingRulesResponseBodyDataRuleListRule) SetDuration(v int32) *GetScalingRulesResponseBodyDataRuleListRule {
	s.Duration = &v
	return s
}

func (s *GetScalingRulesResponseBodyDataRuleListRule) SetEnable(v bool) *GetScalingRulesResponseBodyDataRuleListRule {
	s.Enable = &v
	return s
}

func (s *GetScalingRulesResponseBodyDataRuleListRule) SetGroupId(v string) *GetScalingRulesResponseBodyDataRuleListRule {
	s.GroupId = &v
	return s
}

func (s *GetScalingRulesResponseBodyDataRuleListRule) SetInstNum(v int32) *GetScalingRulesResponseBodyDataRuleListRule {
	s.InstNum = &v
	return s
}

func (s *GetScalingRulesResponseBodyDataRuleListRule) SetLoadNum(v int32) *GetScalingRulesResponseBodyDataRuleListRule {
	s.LoadNum = &v
	return s
}

func (s *GetScalingRulesResponseBodyDataRuleListRule) SetMetricType(v string) *GetScalingRulesResponseBodyDataRuleListRule {
	s.MetricType = &v
	return s
}

func (s *GetScalingRulesResponseBodyDataRuleListRule) SetMode(v string) *GetScalingRulesResponseBodyDataRuleListRule {
	s.Mode = &v
	return s
}

func (s *GetScalingRulesResponseBodyDataRuleListRule) SetMultiAzPolicy(v string) *GetScalingRulesResponseBodyDataRuleListRule {
	s.MultiAzPolicy = &v
	return s
}

func (s *GetScalingRulesResponseBodyDataRuleListRule) SetResourceFrom(v string) *GetScalingRulesResponseBodyDataRuleListRule {
	s.ResourceFrom = &v
	return s
}

func (s *GetScalingRulesResponseBodyDataRuleListRule) SetRt(v int32) *GetScalingRulesResponseBodyDataRuleListRule {
	s.Rt = &v
	return s
}

func (s *GetScalingRulesResponseBodyDataRuleListRule) SetSpecId(v string) *GetScalingRulesResponseBodyDataRuleListRule {
	s.SpecId = &v
	return s
}

func (s *GetScalingRulesResponseBodyDataRuleListRule) SetStep(v int32) *GetScalingRulesResponseBodyDataRuleListRule {
	s.Step = &v
	return s
}

func (s *GetScalingRulesResponseBodyDataRuleListRule) SetTemplateId(v string) *GetScalingRulesResponseBodyDataRuleListRule {
	s.TemplateId = &v
	return s
}

func (s *GetScalingRulesResponseBodyDataRuleListRule) SetTemplateVersion(v int32) *GetScalingRulesResponseBodyDataRuleListRule {
	s.TemplateVersion = &v
	return s
}

func (s *GetScalingRulesResponseBodyDataRuleListRule) SetUpdateTime(v int64) *GetScalingRulesResponseBodyDataRuleListRule {
	s.UpdateTime = &v
	return s
}

func (s *GetScalingRulesResponseBodyDataRuleListRule) SetVSwitchIds(v string) *GetScalingRulesResponseBodyDataRuleListRule {
	s.VSwitchIds = &v
	return s
}

func (s *GetScalingRulesResponseBodyDataRuleListRule) SetVpcId(v string) *GetScalingRulesResponseBodyDataRuleListRule {
	s.VpcId = &v
	return s
}

type GetScalingRulesResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetScalingRulesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetScalingRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s GetScalingRulesResponse) GoString() string {
	return s.String()
}

func (s *GetScalingRulesResponse) SetHeaders(v map[string]*string) *GetScalingRulesResponse {
	s.Headers = v
	return s
}

func (s *GetScalingRulesResponse) SetStatusCode(v int32) *GetScalingRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *GetScalingRulesResponse) SetBody(v *GetScalingRulesResponseBody) *GetScalingRulesResponse {
	s.Body = v
	return s
}

type GetSecureTokenRequest struct {
	// The ID of the namespace, such as cn-beijing or cn-beijing:prod````.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
}

func (s GetSecureTokenRequest) String() string {
	return tea.Prettify(s)
}

func (s GetSecureTokenRequest) GoString() string {
	return s.String()
}

func (s *GetSecureTokenRequest) SetNamespaceId(v string) *GetSecureTokenRequest {
	s.NamespaceId = &v
	return s
}

type GetSecureTokenResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message returned for the request.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned security token.
	SecureToken *GetSecureTokenResponseBodySecureToken `json:"SecureToken,omitempty" xml:"SecureToken,omitempty" type:"Struct"`
}

func (s GetSecureTokenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetSecureTokenResponseBody) GoString() string {
	return s.String()
}

func (s *GetSecureTokenResponseBody) SetCode(v int32) *GetSecureTokenResponseBody {
	s.Code = &v
	return s
}

func (s *GetSecureTokenResponseBody) SetMessage(v string) *GetSecureTokenResponseBody {
	s.Message = &v
	return s
}

func (s *GetSecureTokenResponseBody) SetRequestId(v string) *GetSecureTokenResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetSecureTokenResponseBody) SetSecureToken(v *GetSecureTokenResponseBodySecureToken) *GetSecureTokenResponseBody {
	s.SecureToken = v
	return s
}

type GetSecureTokenResponseBodySecureToken struct {
	// The AccessKey ID used in the namespace.
	AccessKey *string `json:"AccessKey,omitempty" xml:"AccessKey,omitempty"`
	// The address of Address Server associated with the namespace.
	AddressServerHost *string `json:"AddressServerHost,omitempty" xml:"AddressServerHost,omitempty"`
	// The ID of the region.
	BelongRegion *string `json:"BelongRegion,omitempty" xml:"BelongRegion,omitempty"`
	// The description of the namespace.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the Alibaba Cloud account that activated Enterprise Distributed Application Service (EDAS).
	EdasId *string `json:"EdasId,omitempty" xml:"EdasId,omitempty"`
	// The ID of the security token.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the MSE instance.
	MseInstanceId *string `json:"MseInstanceId,omitempty" xml:"MseInstanceId,omitempty"`
	// The public endpoint of the MSE registry.
	MseInternetAddress *string `json:"MseInternetAddress,omitempty" xml:"MseInternetAddress,omitempty"`
	// The private endpoint of the MSE registry.
	MseIntranetAddress *string `json:"MseIntranetAddress,omitempty" xml:"MseIntranetAddress,omitempty"`
	// The type of the Microservices Engine (MSE) registry.
	//
	// *   default: the shared registry of EDAS
	// *   exclusive_mse: MSE Nacos registry
	MseRegistryType *string `json:"MseRegistryType,omitempty" xml:"MseRegistryType,omitempty"`
	// The ID of the region where the namespace resides.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The name of the region where the namespace resides.
	RegionName *string `json:"RegionName,omitempty" xml:"RegionName,omitempty"`
	// The AccessKey secret used in the namespace.
	SecretKey *string `json:"SecretKey,omitempty" xml:"SecretKey,omitempty"`
	// The tenant ID of the namespace.
	TenantId *string `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
	// The ID of the user.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s GetSecureTokenResponseBodySecureToken) String() string {
	return tea.Prettify(s)
}

func (s GetSecureTokenResponseBodySecureToken) GoString() string {
	return s.String()
}

func (s *GetSecureTokenResponseBodySecureToken) SetAccessKey(v string) *GetSecureTokenResponseBodySecureToken {
	s.AccessKey = &v
	return s
}

func (s *GetSecureTokenResponseBodySecureToken) SetAddressServerHost(v string) *GetSecureTokenResponseBodySecureToken {
	s.AddressServerHost = &v
	return s
}

func (s *GetSecureTokenResponseBodySecureToken) SetBelongRegion(v string) *GetSecureTokenResponseBodySecureToken {
	s.BelongRegion = &v
	return s
}

func (s *GetSecureTokenResponseBodySecureToken) SetDescription(v string) *GetSecureTokenResponseBodySecureToken {
	s.Description = &v
	return s
}

func (s *GetSecureTokenResponseBodySecureToken) SetEdasId(v string) *GetSecureTokenResponseBodySecureToken {
	s.EdasId = &v
	return s
}

func (s *GetSecureTokenResponseBodySecureToken) SetId(v int64) *GetSecureTokenResponseBodySecureToken {
	s.Id = &v
	return s
}

func (s *GetSecureTokenResponseBodySecureToken) SetMseInstanceId(v string) *GetSecureTokenResponseBodySecureToken {
	s.MseInstanceId = &v
	return s
}

func (s *GetSecureTokenResponseBodySecureToken) SetMseInternetAddress(v string) *GetSecureTokenResponseBodySecureToken {
	s.MseInternetAddress = &v
	return s
}

func (s *GetSecureTokenResponseBodySecureToken) SetMseIntranetAddress(v string) *GetSecureTokenResponseBodySecureToken {
	s.MseIntranetAddress = &v
	return s
}

func (s *GetSecureTokenResponseBodySecureToken) SetMseRegistryType(v string) *GetSecureTokenResponseBodySecureToken {
	s.MseRegistryType = &v
	return s
}

func (s *GetSecureTokenResponseBodySecureToken) SetRegionId(v string) *GetSecureTokenResponseBodySecureToken {
	s.RegionId = &v
	return s
}

func (s *GetSecureTokenResponseBodySecureToken) SetRegionName(v string) *GetSecureTokenResponseBodySecureToken {
	s.RegionName = &v
	return s
}

func (s *GetSecureTokenResponseBodySecureToken) SetSecretKey(v string) *GetSecureTokenResponseBodySecureToken {
	s.SecretKey = &v
	return s
}

func (s *GetSecureTokenResponseBodySecureToken) SetTenantId(v string) *GetSecureTokenResponseBodySecureToken {
	s.TenantId = &v
	return s
}

func (s *GetSecureTokenResponseBodySecureToken) SetUserId(v string) *GetSecureTokenResponseBodySecureToken {
	s.UserId = &v
	return s
}

type GetSecureTokenResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetSecureTokenResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetSecureTokenResponse) String() string {
	return tea.Prettify(s)
}

func (s GetSecureTokenResponse) GoString() string {
	return s.String()
}

func (s *GetSecureTokenResponse) SetHeaders(v map[string]*string) *GetSecureTokenResponse {
	s.Headers = v
	return s
}

func (s *GetSecureTokenResponse) SetStatusCode(v int32) *GetSecureTokenResponse {
	s.StatusCode = &v
	return s
}

func (s *GetSecureTokenResponse) SetBody(v *GetSecureTokenResponseBody) *GetSecureTokenResponse {
	s.Body = v
	return s
}

type GetServiceConsumersPageRequest struct {
	// The ID of the application.
	AppId *string `json:"appId,omitempty" xml:"appId,omitempty"`
	// The service group.
	Group *string `json:"group,omitempty" xml:"group,omitempty"`
	// The IP address of the service provider. Fuzzy searches are supported.
	Ip *string `json:"ip,omitempty" xml:"ip,omitempty"`
	// The ID of the namespace.
	Namespace *string `json:"namespace,omitempty" xml:"namespace,omitempty"`
	// The source of the data. Valid values:
	//
	// *   agent: Use this value if you use the service query feature of the latest version to pass the query result.
	// *   registry: Use this value if you use the service query feature of the earlier version to pass the query result.
	Origin *string `json:"origin,omitempty" xml:"origin,omitempty"`
	// The number of the page to return.
	Page *int32 `json:"page,omitempty" xml:"page,omitempty"`
	// The ID of the region.
	Region *string `json:"region,omitempty" xml:"region,omitempty"`
	// The type of the service registry. This parameter is deprecated. You can ignore it.
	RegistryType *string `json:"registryType,omitempty" xml:"registryType,omitempty"`
	// The ID of the service. This parameter is deprecated. You can ignore it.
	ServiceId *string `json:"serviceId,omitempty" xml:"serviceId,omitempty"`
	// The name of the service.
	ServiceName *string `json:"serviceName,omitempty" xml:"serviceName,omitempty"`
	// The type of the service.
	ServiceType *string `json:"serviceType,omitempty" xml:"serviceType,omitempty"`
	// The version of the service.
	ServiceVersion *string `json:"serviceVersion,omitempty" xml:"serviceVersion,omitempty"`
	// The number of entries returned per page.
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
	// The source of the service. Set the value to edas.
	Source *string `json:"source,omitempty" xml:"source,omitempty"`
}

func (s GetServiceConsumersPageRequest) String() string {
	return tea.Prettify(s)
}

func (s GetServiceConsumersPageRequest) GoString() string {
	return s.String()
}

func (s *GetServiceConsumersPageRequest) SetAppId(v string) *GetServiceConsumersPageRequest {
	s.AppId = &v
	return s
}

func (s *GetServiceConsumersPageRequest) SetGroup(v string) *GetServiceConsumersPageRequest {
	s.Group = &v
	return s
}

func (s *GetServiceConsumersPageRequest) SetIp(v string) *GetServiceConsumersPageRequest {
	s.Ip = &v
	return s
}

func (s *GetServiceConsumersPageRequest) SetNamespace(v string) *GetServiceConsumersPageRequest {
	s.Namespace = &v
	return s
}

func (s *GetServiceConsumersPageRequest) SetOrigin(v string) *GetServiceConsumersPageRequest {
	s.Origin = &v
	return s
}

func (s *GetServiceConsumersPageRequest) SetPage(v int32) *GetServiceConsumersPageRequest {
	s.Page = &v
	return s
}

func (s *GetServiceConsumersPageRequest) SetRegion(v string) *GetServiceConsumersPageRequest {
	s.Region = &v
	return s
}

func (s *GetServiceConsumersPageRequest) SetRegistryType(v string) *GetServiceConsumersPageRequest {
	s.RegistryType = &v
	return s
}

func (s *GetServiceConsumersPageRequest) SetServiceId(v string) *GetServiceConsumersPageRequest {
	s.ServiceId = &v
	return s
}

func (s *GetServiceConsumersPageRequest) SetServiceName(v string) *GetServiceConsumersPageRequest {
	s.ServiceName = &v
	return s
}

func (s *GetServiceConsumersPageRequest) SetServiceType(v string) *GetServiceConsumersPageRequest {
	s.ServiceType = &v
	return s
}

func (s *GetServiceConsumersPageRequest) SetServiceVersion(v string) *GetServiceConsumersPageRequest {
	s.ServiceVersion = &v
	return s
}

func (s *GetServiceConsumersPageRequest) SetSize(v int32) *GetServiceConsumersPageRequest {
	s.Size = &v
	return s
}

func (s *GetServiceConsumersPageRequest) SetSource(v string) *GetServiceConsumersPageRequest {
	s.Source = &v
	return s
}

type GetServiceConsumersPageResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data that is returned.
	Data *GetServiceConsumersPageResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The message that is returned for the request.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetServiceConsumersPageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetServiceConsumersPageResponseBody) GoString() string {
	return s.String()
}

func (s *GetServiceConsumersPageResponseBody) SetCode(v int32) *GetServiceConsumersPageResponseBody {
	s.Code = &v
	return s
}

func (s *GetServiceConsumersPageResponseBody) SetData(v *GetServiceConsumersPageResponseBodyData) *GetServiceConsumersPageResponseBody {
	s.Data = v
	return s
}

func (s *GetServiceConsumersPageResponseBody) SetMessage(v string) *GetServiceConsumersPageResponseBody {
	s.Message = &v
	return s
}

func (s *GetServiceConsumersPageResponseBody) SetSuccess(v bool) *GetServiceConsumersPageResponseBody {
	s.Success = &v
	return s
}

type GetServiceConsumersPageResponseBodyData struct {
	// The data array that is returned.
	Content []*GetServiceConsumersPageResponseBodyDataContent `json:"Content,omitempty" xml:"Content,omitempty" type:"Repeated"`
	// The number of entries to return on each page.
	Size *int32 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The total number of returned entries.
	TotalElements *int32 `json:"TotalElements,omitempty" xml:"TotalElements,omitempty"`
	// The total number of returned pages.
	TotalPages *int32 `json:"TotalPages,omitempty" xml:"TotalPages,omitempty"`
}

func (s GetServiceConsumersPageResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetServiceConsumersPageResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetServiceConsumersPageResponseBodyData) SetContent(v []*GetServiceConsumersPageResponseBodyDataContent) *GetServiceConsumersPageResponseBodyData {
	s.Content = v
	return s
}

func (s *GetServiceConsumersPageResponseBodyData) SetSize(v int32) *GetServiceConsumersPageResponseBodyData {
	s.Size = &v
	return s
}

func (s *GetServiceConsumersPageResponseBodyData) SetTotalElements(v int32) *GetServiceConsumersPageResponseBodyData {
	s.TotalElements = &v
	return s
}

func (s *GetServiceConsumersPageResponseBodyData) SetTotalPages(v int32) *GetServiceConsumersPageResponseBodyData {
	s.TotalPages = &v
	return s
}

type GetServiceConsumersPageResponseBodyDataContent struct {
	// The name of the service consumer.
	EdasAppName *string `json:"EdasAppName,omitempty" xml:"EdasAppName,omitempty"`
	// The ID of the service consumer.
	EdassAppId *string `json:"EdassAppId,omitempty" xml:"EdassAppId,omitempty"`
	// The IP address of the service consumer.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
}

func (s GetServiceConsumersPageResponseBodyDataContent) String() string {
	return tea.Prettify(s)
}

func (s GetServiceConsumersPageResponseBodyDataContent) GoString() string {
	return s.String()
}

func (s *GetServiceConsumersPageResponseBodyDataContent) SetEdasAppName(v string) *GetServiceConsumersPageResponseBodyDataContent {
	s.EdasAppName = &v
	return s
}

func (s *GetServiceConsumersPageResponseBodyDataContent) SetEdassAppId(v string) *GetServiceConsumersPageResponseBodyDataContent {
	s.EdassAppId = &v
	return s
}

func (s *GetServiceConsumersPageResponseBodyDataContent) SetIp(v string) *GetServiceConsumersPageResponseBodyDataContent {
	s.Ip = &v
	return s
}

type GetServiceConsumersPageResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetServiceConsumersPageResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetServiceConsumersPageResponse) String() string {
	return tea.Prettify(s)
}

func (s GetServiceConsumersPageResponse) GoString() string {
	return s.String()
}

func (s *GetServiceConsumersPageResponse) SetHeaders(v map[string]*string) *GetServiceConsumersPageResponse {
	s.Headers = v
	return s
}

func (s *GetServiceConsumersPageResponse) SetStatusCode(v int32) *GetServiceConsumersPageResponse {
	s.StatusCode = &v
	return s
}

func (s *GetServiceConsumersPageResponse) SetBody(v *GetServiceConsumersPageResponseBody) *GetServiceConsumersPageResponse {
	s.Body = v
	return s
}

type GetServiceDetailRequest struct {
	// The ID of the application.
	AppId *string `json:"appId,omitempty" xml:"appId,omitempty"`
	// The group to which the service belongs.
	Group *string `json:"group,omitempty" xml:"group,omitempty"`
	// The IP address of the service provider. Fuzzy searches are supported.
	Ip *string `json:"ip,omitempty" xml:"ip,omitempty"`
	// The ID of the namespace.
	Namespace *string `json:"namespace,omitempty" xml:"namespace,omitempty"`
	// The source of the data. Valid values:
	//
	// *   agent: Use this value if you use the service query feature of the latest version to pass the query result.
	// *   registry: Use this value if you use the service query feature of the earlier version to pass the query result.
	Origin *string `json:"origin,omitempty" xml:"origin,omitempty"`
	// The region ID of the service.
	Region *string `json:"region,omitempty" xml:"region,omitempty"`
	// The type of the service registry. This parameter is deprecated. You can ignore it.
	RegistryType *string `json:"registryType,omitempty" xml:"registryType,omitempty"`
	// The ID of the service. This parameter is deprecated. You can ignore it.
	ServiceId *string `json:"serviceId,omitempty" xml:"serviceId,omitempty"`
	// The name of the service.
	ServiceName *string `json:"serviceName,omitempty" xml:"serviceName,omitempty"`
	// The type of the service. Valid values:
	//
	// *   dubbo
	// *   springCloud
	// *   hsf
	// *   istio
	ServiceType *string `json:"serviceType,omitempty" xml:"serviceType,omitempty"`
	// The version of the service.
	ServiceVersion *string `json:"serviceVersion,omitempty" xml:"serviceVersion,omitempty"`
	// The source of the service. Set the value to edas.
	Source *string `json:"source,omitempty" xml:"source,omitempty"`
}

func (s GetServiceDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetServiceDetailRequest) GoString() string {
	return s.String()
}

func (s *GetServiceDetailRequest) SetAppId(v string) *GetServiceDetailRequest {
	s.AppId = &v
	return s
}

func (s *GetServiceDetailRequest) SetGroup(v string) *GetServiceDetailRequest {
	s.Group = &v
	return s
}

func (s *GetServiceDetailRequest) SetIp(v string) *GetServiceDetailRequest {
	s.Ip = &v
	return s
}

func (s *GetServiceDetailRequest) SetNamespace(v string) *GetServiceDetailRequest {
	s.Namespace = &v
	return s
}

func (s *GetServiceDetailRequest) SetOrigin(v string) *GetServiceDetailRequest {
	s.Origin = &v
	return s
}

func (s *GetServiceDetailRequest) SetRegion(v string) *GetServiceDetailRequest {
	s.Region = &v
	return s
}

func (s *GetServiceDetailRequest) SetRegistryType(v string) *GetServiceDetailRequest {
	s.RegistryType = &v
	return s
}

func (s *GetServiceDetailRequest) SetServiceId(v string) *GetServiceDetailRequest {
	s.ServiceId = &v
	return s
}

func (s *GetServiceDetailRequest) SetServiceName(v string) *GetServiceDetailRequest {
	s.ServiceName = &v
	return s
}

func (s *GetServiceDetailRequest) SetServiceType(v string) *GetServiceDetailRequest {
	s.ServiceType = &v
	return s
}

func (s *GetServiceDetailRequest) SetServiceVersion(v string) *GetServiceDetailRequest {
	s.ServiceVersion = &v
	return s
}

func (s *GetServiceDetailRequest) SetSource(v string) *GetServiceDetailRequest {
	s.Source = &v
	return s
}

type GetServiceDetailResponseBody struct {
	// The HTTP status code returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data structure.
	Data *GetServiceDetailResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The message returned for the request.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Indicates whether the call was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetServiceDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetServiceDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetServiceDetailResponseBody) SetCode(v int32) *GetServiceDetailResponseBody {
	s.Code = &v
	return s
}

func (s *GetServiceDetailResponseBody) SetData(v *GetServiceDetailResponseBodyData) *GetServiceDetailResponseBody {
	s.Data = v
	return s
}

func (s *GetServiceDetailResponseBody) SetMessage(v string) *GetServiceDetailResponseBody {
	s.Message = &v
	return s
}

func (s *GetServiceDetailResponseBody) SetSuccess(v bool) *GetServiceDetailResponseBody {
	s.Success = &v
	return s
}

type GetServiceDetailResponseBodyData struct {
	// The name of the Dubbo application.
	DubboApplicationName *string `json:"DubboApplicationName,omitempty" xml:"DubboApplicationName,omitempty"`
	// The name of the Enterprise Distributed Application Service (EDAS) application.
	EdasAppName *string `json:"EdasAppName,omitempty" xml:"EdasAppName,omitempty"`
	// The group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The metadata.
	Metadata *string `json:"Metadata,omitempty" xml:"Metadata,omitempty"`
	// The methods.
	Methods []*GetServiceDetailResponseBodyDataMethods `json:"Methods,omitempty" xml:"Methods,omitempty" type:"Repeated"`
	// The type of the service registry.
	RegistryType *string `json:"RegistryType,omitempty" xml:"RegistryType,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The type of the service.
	ServiceType *string `json:"ServiceType,omitempty" xml:"ServiceType,omitempty"`
	// The name of the Spring application.
	SpringApplicationName *string `json:"SpringApplicationName,omitempty" xml:"SpringApplicationName,omitempty"`
	// The version number.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s GetServiceDetailResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetServiceDetailResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetServiceDetailResponseBodyData) SetDubboApplicationName(v string) *GetServiceDetailResponseBodyData {
	s.DubboApplicationName = &v
	return s
}

func (s *GetServiceDetailResponseBodyData) SetEdasAppName(v string) *GetServiceDetailResponseBodyData {
	s.EdasAppName = &v
	return s
}

func (s *GetServiceDetailResponseBodyData) SetGroup(v string) *GetServiceDetailResponseBodyData {
	s.Group = &v
	return s
}

func (s *GetServiceDetailResponseBodyData) SetMetadata(v string) *GetServiceDetailResponseBodyData {
	s.Metadata = &v
	return s
}

func (s *GetServiceDetailResponseBodyData) SetMethods(v []*GetServiceDetailResponseBodyDataMethods) *GetServiceDetailResponseBodyData {
	s.Methods = v
	return s
}

func (s *GetServiceDetailResponseBodyData) SetRegistryType(v string) *GetServiceDetailResponseBodyData {
	s.RegistryType = &v
	return s
}

func (s *GetServiceDetailResponseBodyData) SetServiceName(v string) *GetServiceDetailResponseBodyData {
	s.ServiceName = &v
	return s
}

func (s *GetServiceDetailResponseBodyData) SetServiceType(v string) *GetServiceDetailResponseBodyData {
	s.ServiceType = &v
	return s
}

func (s *GetServiceDetailResponseBodyData) SetSpringApplicationName(v string) *GetServiceDetailResponseBodyData {
	s.SpringApplicationName = &v
	return s
}

func (s *GetServiceDetailResponseBodyData) SetVersion(v string) *GetServiceDetailResponseBodyData {
	s.Version = &v
	return s
}

type GetServiceDetailResponseBodyDataMethods struct {
	// The controllers.
	MethodController *string `json:"MethodController,omitempty" xml:"MethodController,omitempty"`
	// The name of the service.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The specific name.
	NameDetail *string `json:"NameDetail,omitempty" xml:"NameDetail,omitempty"`
	// The parameter definitions.
	ParameterDefinitions *string `json:"ParameterDefinitions,omitempty" xml:"ParameterDefinitions,omitempty"`
	// The parameter details.
	ParameterDetails *string `json:"ParameterDetails,omitempty" xml:"ParameterDetails,omitempty"`
	// The parameter names.
	ParameterNames *string `json:"ParameterNames,omitempty" xml:"ParameterNames,omitempty"`
	// The parameter types.
	ParameterTypes *string `json:"ParameterTypes,omitempty" xml:"ParameterTypes,omitempty"`
	// The method paths.
	Paths *string `json:"Paths,omitempty" xml:"Paths,omitempty"`
	// The request methods.
	RequestMethods *string `json:"RequestMethods,omitempty" xml:"RequestMethods,omitempty"`
	// The definition of the value returned by the method.
	ReturnDefinition *GetServiceDetailResponseBodyDataMethodsReturnDefinition `json:"ReturnDefinition,omitempty" xml:"ReturnDefinition,omitempty" type:"Struct"`
	// The response details.
	ReturnDetails *string `json:"ReturnDetails,omitempty" xml:"ReturnDetails,omitempty"`
	// The type of the response.
	ReturnType *string `json:"ReturnType,omitempty" xml:"ReturnType,omitempty"`
}

func (s GetServiceDetailResponseBodyDataMethods) String() string {
	return tea.Prettify(s)
}

func (s GetServiceDetailResponseBodyDataMethods) GoString() string {
	return s.String()
}

func (s *GetServiceDetailResponseBodyDataMethods) SetMethodController(v string) *GetServiceDetailResponseBodyDataMethods {
	s.MethodController = &v
	return s
}

func (s *GetServiceDetailResponseBodyDataMethods) SetName(v string) *GetServiceDetailResponseBodyDataMethods {
	s.Name = &v
	return s
}

func (s *GetServiceDetailResponseBodyDataMethods) SetNameDetail(v string) *GetServiceDetailResponseBodyDataMethods {
	s.NameDetail = &v
	return s
}

func (s *GetServiceDetailResponseBodyDataMethods) SetParameterDefinitions(v string) *GetServiceDetailResponseBodyDataMethods {
	s.ParameterDefinitions = &v
	return s
}

func (s *GetServiceDetailResponseBodyDataMethods) SetParameterDetails(v string) *GetServiceDetailResponseBodyDataMethods {
	s.ParameterDetails = &v
	return s
}

func (s *GetServiceDetailResponseBodyDataMethods) SetParameterNames(v string) *GetServiceDetailResponseBodyDataMethods {
	s.ParameterNames = &v
	return s
}

func (s *GetServiceDetailResponseBodyDataMethods) SetParameterTypes(v string) *GetServiceDetailResponseBodyDataMethods {
	s.ParameterTypes = &v
	return s
}

func (s *GetServiceDetailResponseBodyDataMethods) SetPaths(v string) *GetServiceDetailResponseBodyDataMethods {
	s.Paths = &v
	return s
}

func (s *GetServiceDetailResponseBodyDataMethods) SetRequestMethods(v string) *GetServiceDetailResponseBodyDataMethods {
	s.RequestMethods = &v
	return s
}

func (s *GetServiceDetailResponseBodyDataMethods) SetReturnDefinition(v *GetServiceDetailResponseBodyDataMethodsReturnDefinition) *GetServiceDetailResponseBodyDataMethods {
	s.ReturnDefinition = v
	return s
}

func (s *GetServiceDetailResponseBodyDataMethods) SetReturnDetails(v string) *GetServiceDetailResponseBodyDataMethods {
	s.ReturnDetails = &v
	return s
}

func (s *GetServiceDetailResponseBodyDataMethods) SetReturnType(v string) *GetServiceDetailResponseBodyDataMethods {
	s.ReturnType = &v
	return s
}

type GetServiceDetailResponseBodyDataMethodsReturnDefinition struct {
	// The ID of the return value.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The type of the response.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetServiceDetailResponseBodyDataMethodsReturnDefinition) String() string {
	return tea.Prettify(s)
}

func (s GetServiceDetailResponseBodyDataMethodsReturnDefinition) GoString() string {
	return s.String()
}

func (s *GetServiceDetailResponseBodyDataMethodsReturnDefinition) SetId(v string) *GetServiceDetailResponseBodyDataMethodsReturnDefinition {
	s.Id = &v
	return s
}

func (s *GetServiceDetailResponseBodyDataMethodsReturnDefinition) SetType(v string) *GetServiceDetailResponseBodyDataMethodsReturnDefinition {
	s.Type = &v
	return s
}

type GetServiceDetailResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetServiceDetailResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetServiceDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetServiceDetailResponse) GoString() string {
	return s.String()
}

func (s *GetServiceDetailResponse) SetHeaders(v map[string]*string) *GetServiceDetailResponse {
	s.Headers = v
	return s
}

func (s *GetServiceDetailResponse) SetStatusCode(v int32) *GetServiceDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetServiceDetailResponse) SetBody(v *GetServiceDetailResponseBody) *GetServiceDetailResponse {
	s.Body = v
	return s
}

type GetServiceListPageRequest struct {
	// The namespace.
	Namespace *string `json:"namespace,omitempty" xml:"namespace,omitempty"`
	// The source of the data. Valid values:
	//
	// *   `agent`: Use this value if you use the service query feature of the latest version to pass the query result.
	// *   `registry`: Use this value if you use the service query feature of the earlier version to pass the query result.
	Origin *string `json:"origin,omitempty" xml:"origin,omitempty"`
	// The number of the page to return. Pages start from Page 0.
	Page *int32 `json:"page,omitempty" xml:"page,omitempty"`
	// The ID of the region.
	Region *string `json:"region,omitempty" xml:"region,omitempty"`
	// The type of the service. Valid values:
	//
	// *   `app`: searches by application.
	// *   `service`: searches by service.
	// *   `providerIp`: searches by IP address.
	SearchType *string `json:"searchType,omitempty" xml:"searchType,omitempty"`
	// The keyword used for the search.
	//
	// *   Set this parameter to the ID of the application if you set the searchType parameter to app.``
	// *   Set this parameter to the name of the service if you set the serachType parameter to service.``
	// *   Set this parameter to the IP address of the application if you set the searchType parameter to providerIp.
	SearchValue *string `json:"searchValue,omitempty" xml:"searchValue,omitempty"`
	// The type of the service. Valid values:
	//
	// *   `dubbo`
	// *   `springCloud`
	// *   `hsf`
	// *   `istio`
	ServiceType *string `json:"serviceType,omitempty" xml:"serviceType,omitempty"`
	// Specifies the provider side or the consumer side. Valid values:
	//
	// *   provider
	// *   consumer
	Side *string `json:"side,omitempty" xml:"side,omitempty"`
	// The number of entries to return on each page.
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
}

func (s GetServiceListPageRequest) String() string {
	return tea.Prettify(s)
}

func (s GetServiceListPageRequest) GoString() string {
	return s.String()
}

func (s *GetServiceListPageRequest) SetNamespace(v string) *GetServiceListPageRequest {
	s.Namespace = &v
	return s
}

func (s *GetServiceListPageRequest) SetOrigin(v string) *GetServiceListPageRequest {
	s.Origin = &v
	return s
}

func (s *GetServiceListPageRequest) SetPage(v int32) *GetServiceListPageRequest {
	s.Page = &v
	return s
}

func (s *GetServiceListPageRequest) SetRegion(v string) *GetServiceListPageRequest {
	s.Region = &v
	return s
}

func (s *GetServiceListPageRequest) SetSearchType(v string) *GetServiceListPageRequest {
	s.SearchType = &v
	return s
}

func (s *GetServiceListPageRequest) SetSearchValue(v string) *GetServiceListPageRequest {
	s.SearchValue = &v
	return s
}

func (s *GetServiceListPageRequest) SetServiceType(v string) *GetServiceListPageRequest {
	s.ServiceType = &v
	return s
}

func (s *GetServiceListPageRequest) SetSide(v string) *GetServiceListPageRequest {
	s.Side = &v
	return s
}

func (s *GetServiceListPageRequest) SetSize(v int32) *GetServiceListPageRequest {
	s.Size = &v
	return s
}

type GetServiceListPageResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *GetServiceListPageResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The message that is returned for the request.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetServiceListPageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetServiceListPageResponseBody) GoString() string {
	return s.String()
}

func (s *GetServiceListPageResponseBody) SetCode(v int32) *GetServiceListPageResponseBody {
	s.Code = &v
	return s
}

func (s *GetServiceListPageResponseBody) SetData(v *GetServiceListPageResponseBodyData) *GetServiceListPageResponseBody {
	s.Data = v
	return s
}

func (s *GetServiceListPageResponseBody) SetMessage(v string) *GetServiceListPageResponseBody {
	s.Message = &v
	return s
}

func (s *GetServiceListPageResponseBody) SetSuccess(v bool) *GetServiceListPageResponseBody {
	s.Success = &v
	return s
}

type GetServiceListPageResponseBodyData struct {
	// The data array that is returned.
	Content []*GetServiceListPageResponseBodyDataContent `json:"Content,omitempty" xml:"Content,omitempty" type:"Repeated"`
	// The number of entries returned per page.
	Size *int32 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The total number of returned entries.
	TotalElements *int32 `json:"TotalElements,omitempty" xml:"TotalElements,omitempty"`
	// The total number of returned pages.
	TotalPages *int32 `json:"TotalPages,omitempty" xml:"TotalPages,omitempty"`
}

func (s GetServiceListPageResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetServiceListPageResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetServiceListPageResponseBodyData) SetContent(v []*GetServiceListPageResponseBodyDataContent) *GetServiceListPageResponseBodyData {
	s.Content = v
	return s
}

func (s *GetServiceListPageResponseBodyData) SetSize(v int32) *GetServiceListPageResponseBodyData {
	s.Size = &v
	return s
}

func (s *GetServiceListPageResponseBodyData) SetTotalElements(v int32) *GetServiceListPageResponseBodyData {
	s.TotalElements = &v
	return s
}

func (s *GetServiceListPageResponseBodyData) SetTotalPages(v int32) *GetServiceListPageResponseBodyData {
	s.TotalPages = &v
	return s
}

type GetServiceListPageResponseBodyDataContent struct {
	// The ID of the application.
	EdasAppId *string `json:"EdasAppId,omitempty" xml:"EdasAppId,omitempty"`
	// The name of the application.
	EdasAppName *string `json:"EdasAppName,omitempty" xml:"EdasAppName,omitempty"`
	// The service group.
	Group *string `json:"Group,omitempty" xml:"Group,omitempty"`
	// The number of instances.
	InstanceNum *int32 `json:"InstanceNum,omitempty" xml:"InstanceNum,omitempty"`
	// The type of the service registry.
	RegisterType *string `json:"RegisterType,omitempty" xml:"RegisterType,omitempty"`
	// The ID of the service.
	ServiceId *string `json:"ServiceId,omitempty" xml:"ServiceId,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The version number.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s GetServiceListPageResponseBodyDataContent) String() string {
	return tea.Prettify(s)
}

func (s GetServiceListPageResponseBodyDataContent) GoString() string {
	return s.String()
}

func (s *GetServiceListPageResponseBodyDataContent) SetEdasAppId(v string) *GetServiceListPageResponseBodyDataContent {
	s.EdasAppId = &v
	return s
}

func (s *GetServiceListPageResponseBodyDataContent) SetEdasAppName(v string) *GetServiceListPageResponseBodyDataContent {
	s.EdasAppName = &v
	return s
}

func (s *GetServiceListPageResponseBodyDataContent) SetGroup(v string) *GetServiceListPageResponseBodyDataContent {
	s.Group = &v
	return s
}

func (s *GetServiceListPageResponseBodyDataContent) SetInstanceNum(v int32) *GetServiceListPageResponseBodyDataContent {
	s.InstanceNum = &v
	return s
}

func (s *GetServiceListPageResponseBodyDataContent) SetRegisterType(v string) *GetServiceListPageResponseBodyDataContent {
	s.RegisterType = &v
	return s
}

func (s *GetServiceListPageResponseBodyDataContent) SetServiceId(v string) *GetServiceListPageResponseBodyDataContent {
	s.ServiceId = &v
	return s
}

func (s *GetServiceListPageResponseBodyDataContent) SetServiceName(v string) *GetServiceListPageResponseBodyDataContent {
	s.ServiceName = &v
	return s
}

func (s *GetServiceListPageResponseBodyDataContent) SetVersion(v string) *GetServiceListPageResponseBodyDataContent {
	s.Version = &v
	return s
}

type GetServiceListPageResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetServiceListPageResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetServiceListPageResponse) String() string {
	return tea.Prettify(s)
}

func (s GetServiceListPageResponse) GoString() string {
	return s.String()
}

func (s *GetServiceListPageResponse) SetHeaders(v map[string]*string) *GetServiceListPageResponse {
	s.Headers = v
	return s
}

func (s *GetServiceListPageResponse) SetStatusCode(v int32) *GetServiceListPageResponse {
	s.StatusCode = &v
	return s
}

func (s *GetServiceListPageResponse) SetBody(v *GetServiceListPageResponseBody) *GetServiceListPageResponse {
	s.Body = v
	return s
}

type GetServiceMethodPageRequest struct {
	// The ID of the application.
	AppId *string `json:"appId,omitempty" xml:"appId,omitempty"`
	// The group to which the service belongs.
	Group *string `json:"group,omitempty" xml:"group,omitempty"`
	// The IP address of the service.
	Ip *string `json:"ip,omitempty" xml:"ip,omitempty"`
	// The controller method.
	MethodController *string `json:"methodController,omitempty" xml:"methodController,omitempty"`
	// The name of the method.
	Name *string `json:"name,omitempty" xml:"name,omitempty"`
	// The ID of the namespace.
	Namespace *string `json:"namespace,omitempty" xml:"namespace,omitempty"`
	// The source of the data. Valid values:
	//
	// *   agent: Use this value if you use the service query feature of the latest version to pass the query result.
	// *   registry: Use this value if you use the service query feature of the earlier version to pass the query result.
	Origin *string `json:"origin,omitempty" xml:"origin,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"pageNumber,omitempty" xml:"pageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"pageSize,omitempty" xml:"pageSize,omitempty"`
	// The request path.
	Path *string `json:"path,omitempty" xml:"path,omitempty"`
	// The ID of the region.
	Region *string `json:"region,omitempty" xml:"region,omitempty"`
	// The type of the service registry.
	RegistryType *string `json:"registryType,omitempty" xml:"registryType,omitempty"`
	// The ID of the service.
	ServiceId *string `json:"serviceId,omitempty" xml:"serviceId,omitempty"`
	// The name of the service.
	ServiceName *string `json:"serviceName,omitempty" xml:"serviceName,omitempty"`
	// The type of the service. Valid values:
	//
	// *   dubbo: Dubbo service
	// *   springCloud: Spring Cloud service
	// *   hsf: High-speed Service Framework (HSF) service
	ServiceType *string `json:"serviceType,omitempty" xml:"serviceType,omitempty"`
	// The version of the service.
	ServiceVersion *string `json:"serviceVersion,omitempty" xml:"serviceVersion,omitempty"`
	// The source of the service. Set the value to edas.
	Source *string `json:"source,omitempty" xml:"source,omitempty"`
}

func (s GetServiceMethodPageRequest) String() string {
	return tea.Prettify(s)
}

func (s GetServiceMethodPageRequest) GoString() string {
	return s.String()
}

func (s *GetServiceMethodPageRequest) SetAppId(v string) *GetServiceMethodPageRequest {
	s.AppId = &v
	return s
}

func (s *GetServiceMethodPageRequest) SetGroup(v string) *GetServiceMethodPageRequest {
	s.Group = &v
	return s
}

func (s *GetServiceMethodPageRequest) SetIp(v string) *GetServiceMethodPageRequest {
	s.Ip = &v
	return s
}

func (s *GetServiceMethodPageRequest) SetMethodController(v string) *GetServiceMethodPageRequest {
	s.MethodController = &v
	return s
}

func (s *GetServiceMethodPageRequest) SetName(v string) *GetServiceMethodPageRequest {
	s.Name = &v
	return s
}

func (s *GetServiceMethodPageRequest) SetNamespace(v string) *GetServiceMethodPageRequest {
	s.Namespace = &v
	return s
}

func (s *GetServiceMethodPageRequest) SetOrigin(v string) *GetServiceMethodPageRequest {
	s.Origin = &v
	return s
}

func (s *GetServiceMethodPageRequest) SetPageNumber(v int32) *GetServiceMethodPageRequest {
	s.PageNumber = &v
	return s
}

func (s *GetServiceMethodPageRequest) SetPageSize(v int32) *GetServiceMethodPageRequest {
	s.PageSize = &v
	return s
}

func (s *GetServiceMethodPageRequest) SetPath(v string) *GetServiceMethodPageRequest {
	s.Path = &v
	return s
}

func (s *GetServiceMethodPageRequest) SetRegion(v string) *GetServiceMethodPageRequest {
	s.Region = &v
	return s
}

func (s *GetServiceMethodPageRequest) SetRegistryType(v string) *GetServiceMethodPageRequest {
	s.RegistryType = &v
	return s
}

func (s *GetServiceMethodPageRequest) SetServiceId(v string) *GetServiceMethodPageRequest {
	s.ServiceId = &v
	return s
}

func (s *GetServiceMethodPageRequest) SetServiceName(v string) *GetServiceMethodPageRequest {
	s.ServiceName = &v
	return s
}

func (s *GetServiceMethodPageRequest) SetServiceType(v string) *GetServiceMethodPageRequest {
	s.ServiceType = &v
	return s
}

func (s *GetServiceMethodPageRequest) SetServiceVersion(v string) *GetServiceMethodPageRequest {
	s.ServiceVersion = &v
	return s
}

func (s *GetServiceMethodPageRequest) SetSource(v string) *GetServiceMethodPageRequest {
	s.Source = &v
	return s
}

type GetServiceMethodPageResponseBody struct {
	// The HTTP status code that is returned.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data that is returned.
	Data *GetServiceMethodPageResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code that is returned.
	HttpCode *string `json:"HttpCode,omitempty" xml:"HttpCode,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetServiceMethodPageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetServiceMethodPageResponseBody) GoString() string {
	return s.String()
}

func (s *GetServiceMethodPageResponseBody) SetCode(v string) *GetServiceMethodPageResponseBody {
	s.Code = &v
	return s
}

func (s *GetServiceMethodPageResponseBody) SetData(v *GetServiceMethodPageResponseBodyData) *GetServiceMethodPageResponseBody {
	s.Data = v
	return s
}

func (s *GetServiceMethodPageResponseBody) SetHttpCode(v string) *GetServiceMethodPageResponseBody {
	s.HttpCode = &v
	return s
}

func (s *GetServiceMethodPageResponseBody) SetMessage(v string) *GetServiceMethodPageResponseBody {
	s.Message = &v
	return s
}

func (s *GetServiceMethodPageResponseBody) SetRequestId(v string) *GetServiceMethodPageResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetServiceMethodPageResponseBody) SetSuccess(v bool) *GetServiceMethodPageResponseBody {
	s.Success = &v
	return s
}

type GetServiceMethodPageResponseBodyData struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The data about the method.
	Result []*GetServiceMethodPageResponseBodyDataResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// The total number of entries.
	TotalSize *int32 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s GetServiceMethodPageResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetServiceMethodPageResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetServiceMethodPageResponseBodyData) SetPageNumber(v int32) *GetServiceMethodPageResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *GetServiceMethodPageResponseBodyData) SetPageSize(v int32) *GetServiceMethodPageResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *GetServiceMethodPageResponseBodyData) SetResult(v []*GetServiceMethodPageResponseBodyDataResult) *GetServiceMethodPageResponseBodyData {
	s.Result = v
	return s
}

func (s *GetServiceMethodPageResponseBodyData) SetTotalSize(v int32) *GetServiceMethodPageResponseBodyData {
	s.TotalSize = &v
	return s
}

type GetServiceMethodPageResponseBodyDataResult struct {
	// The method.
	MethodController *string `json:"MethodController,omitempty" xml:"MethodController,omitempty"`
	// The name of the method.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The details of the method.
	NameDetail *string `json:"NameDetail,omitempty" xml:"NameDetail,omitempty"`
	// The definition of the parameter.
	ParameterDefinitions *string `json:"ParameterDefinitions,omitempty" xml:"ParameterDefinitions,omitempty"`
	// The details of the parameters.
	ParameterDetails *string `json:"ParameterDetails,omitempty" xml:"ParameterDetails,omitempty"`
	// The name of the parameter.
	ParameterNames *string `json:"ParameterNames,omitempty" xml:"ParameterNames,omitempty"`
	// The data type of the parameter.
	ParameterTypes *string `json:"ParameterTypes,omitempty" xml:"ParameterTypes,omitempty"`
	// The method path.
	Paths *string `json:"Paths,omitempty" xml:"Paths,omitempty"`
	// The request method.
	RequestMethods *string `json:"RequestMethods,omitempty" xml:"RequestMethods,omitempty"`
	// The return value.
	ReturnDefinition *GetServiceMethodPageResponseBodyDataResultReturnDefinition `json:"ReturnDefinition,omitempty" xml:"ReturnDefinition,omitempty" type:"Struct"`
	// The details of the response.
	ReturnDetails *string `json:"ReturnDetails,omitempty" xml:"ReturnDetails,omitempty"`
	// The data format of the response.
	ReturnType *string `json:"ReturnType,omitempty" xml:"ReturnType,omitempty"`
}

func (s GetServiceMethodPageResponseBodyDataResult) String() string {
	return tea.Prettify(s)
}

func (s GetServiceMethodPageResponseBodyDataResult) GoString() string {
	return s.String()
}

func (s *GetServiceMethodPageResponseBodyDataResult) SetMethodController(v string) *GetServiceMethodPageResponseBodyDataResult {
	s.MethodController = &v
	return s
}

func (s *GetServiceMethodPageResponseBodyDataResult) SetName(v string) *GetServiceMethodPageResponseBodyDataResult {
	s.Name = &v
	return s
}

func (s *GetServiceMethodPageResponseBodyDataResult) SetNameDetail(v string) *GetServiceMethodPageResponseBodyDataResult {
	s.NameDetail = &v
	return s
}

func (s *GetServiceMethodPageResponseBodyDataResult) SetParameterDefinitions(v string) *GetServiceMethodPageResponseBodyDataResult {
	s.ParameterDefinitions = &v
	return s
}

func (s *GetServiceMethodPageResponseBodyDataResult) SetParameterDetails(v string) *GetServiceMethodPageResponseBodyDataResult {
	s.ParameterDetails = &v
	return s
}

func (s *GetServiceMethodPageResponseBodyDataResult) SetParameterNames(v string) *GetServiceMethodPageResponseBodyDataResult {
	s.ParameterNames = &v
	return s
}

func (s *GetServiceMethodPageResponseBodyDataResult) SetParameterTypes(v string) *GetServiceMethodPageResponseBodyDataResult {
	s.ParameterTypes = &v
	return s
}

func (s *GetServiceMethodPageResponseBodyDataResult) SetPaths(v string) *GetServiceMethodPageResponseBodyDataResult {
	s.Paths = &v
	return s
}

func (s *GetServiceMethodPageResponseBodyDataResult) SetRequestMethods(v string) *GetServiceMethodPageResponseBodyDataResult {
	s.RequestMethods = &v
	return s
}

func (s *GetServiceMethodPageResponseBodyDataResult) SetReturnDefinition(v *GetServiceMethodPageResponseBodyDataResultReturnDefinition) *GetServiceMethodPageResponseBodyDataResult {
	s.ReturnDefinition = v
	return s
}

func (s *GetServiceMethodPageResponseBodyDataResult) SetReturnDetails(v string) *GetServiceMethodPageResponseBodyDataResult {
	s.ReturnDetails = &v
	return s
}

func (s *GetServiceMethodPageResponseBodyDataResult) SetReturnType(v string) *GetServiceMethodPageResponseBodyDataResult {
	s.ReturnType = &v
	return s
}

type GetServiceMethodPageResponseBodyDataResultReturnDefinition struct {
	// The ID of the return value.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The data format of the response.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetServiceMethodPageResponseBodyDataResultReturnDefinition) String() string {
	return tea.Prettify(s)
}

func (s GetServiceMethodPageResponseBodyDataResultReturnDefinition) GoString() string {
	return s.String()
}

func (s *GetServiceMethodPageResponseBodyDataResultReturnDefinition) SetId(v string) *GetServiceMethodPageResponseBodyDataResultReturnDefinition {
	s.Id = &v
	return s
}

func (s *GetServiceMethodPageResponseBodyDataResultReturnDefinition) SetType(v string) *GetServiceMethodPageResponseBodyDataResultReturnDefinition {
	s.Type = &v
	return s
}

type GetServiceMethodPageResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetServiceMethodPageResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetServiceMethodPageResponse) String() string {
	return tea.Prettify(s)
}

func (s GetServiceMethodPageResponse) GoString() string {
	return s.String()
}

func (s *GetServiceMethodPageResponse) SetHeaders(v map[string]*string) *GetServiceMethodPageResponse {
	s.Headers = v
	return s
}

func (s *GetServiceMethodPageResponse) SetStatusCode(v int32) *GetServiceMethodPageResponse {
	s.StatusCode = &v
	return s
}

func (s *GetServiceMethodPageResponse) SetBody(v *GetServiceMethodPageResponseBody) *GetServiceMethodPageResponse {
	s.Body = v
	return s
}

type GetServiceProvidersPageRequest struct {
	// The ID of the application.
	AppId *string `json:"appId,omitempty" xml:"appId,omitempty"`
	// The group to which the service belongs.
	Group *string `json:"group,omitempty" xml:"group,omitempty"`
	// The IP address of the service provider. Fuzzy searches are supported.
	Ip *string `json:"ip,omitempty" xml:"ip,omitempty"`
	// The ID of the namespace.
	Namespace *string `json:"namespace,omitempty" xml:"namespace,omitempty"`
	// The source of data. Valid values:
	//
	// *   agent: Use this value if you use the service query feature of the latest version to pass the query result.
	// *   registry: Use this value if you use the service query feature of the earlier version to pass the query result.
	Origin *string `json:"origin,omitempty" xml:"origin,omitempty"`
	// The number of the page to return. Pages start from Page 0.
	Page *int32 `json:"page,omitempty" xml:"page,omitempty"`
	// The ID of the region.
	Region *string `json:"region,omitempty" xml:"region,omitempty"`
	// The type of the service registry. This parameter is deprecated. You can ignore it.
	RegistryType *string `json:"registryType,omitempty" xml:"registryType,omitempty"`
	// The ID of the service. This parameter is deprecated. You can ignore it.
	ServiceId *string `json:"serviceId,omitempty" xml:"serviceId,omitempty"`
	// The name of the service.
	ServiceName *string `json:"serviceName,omitempty" xml:"serviceName,omitempty"`
	// The type of the service. Valid values:
	//
	// *   dubbo: Dubbo service
	// *   springCloud: Spring Cloud service
	// *   hsf: High-speed Service Framework (HSF) service
	ServiceType *string `json:"serviceType,omitempty" xml:"serviceType,omitempty"`
	// The version of the service.
	ServiceVersion *string `json:"serviceVersion,omitempty" xml:"serviceVersion,omitempty"`
	// The number of entries to return on each page.
	Size *int32 `json:"size,omitempty" xml:"size,omitempty"`
	// The source of the service. Set the value to edas.
	Source *string `json:"source,omitempty" xml:"source,omitempty"`
}

func (s GetServiceProvidersPageRequest) String() string {
	return tea.Prettify(s)
}

func (s GetServiceProvidersPageRequest) GoString() string {
	return s.String()
}

func (s *GetServiceProvidersPageRequest) SetAppId(v string) *GetServiceProvidersPageRequest {
	s.AppId = &v
	return s
}

func (s *GetServiceProvidersPageRequest) SetGroup(v string) *GetServiceProvidersPageRequest {
	s.Group = &v
	return s
}

func (s *GetServiceProvidersPageRequest) SetIp(v string) *GetServiceProvidersPageRequest {
	s.Ip = &v
	return s
}

func (s *GetServiceProvidersPageRequest) SetNamespace(v string) *GetServiceProvidersPageRequest {
	s.Namespace = &v
	return s
}

func (s *GetServiceProvidersPageRequest) SetOrigin(v string) *GetServiceProvidersPageRequest {
	s.Origin = &v
	return s
}

func (s *GetServiceProvidersPageRequest) SetPage(v int32) *GetServiceProvidersPageRequest {
	s.Page = &v
	return s
}

func (s *GetServiceProvidersPageRequest) SetRegion(v string) *GetServiceProvidersPageRequest {
	s.Region = &v
	return s
}

func (s *GetServiceProvidersPageRequest) SetRegistryType(v string) *GetServiceProvidersPageRequest {
	s.RegistryType = &v
	return s
}

func (s *GetServiceProvidersPageRequest) SetServiceId(v string) *GetServiceProvidersPageRequest {
	s.ServiceId = &v
	return s
}

func (s *GetServiceProvidersPageRequest) SetServiceName(v string) *GetServiceProvidersPageRequest {
	s.ServiceName = &v
	return s
}

func (s *GetServiceProvidersPageRequest) SetServiceType(v string) *GetServiceProvidersPageRequest {
	s.ServiceType = &v
	return s
}

func (s *GetServiceProvidersPageRequest) SetServiceVersion(v string) *GetServiceProvidersPageRequest {
	s.ServiceVersion = &v
	return s
}

func (s *GetServiceProvidersPageRequest) SetSize(v int32) *GetServiceProvidersPageRequest {
	s.Size = &v
	return s
}

func (s *GetServiceProvidersPageRequest) SetSource(v string) *GetServiceProvidersPageRequest {
	s.Source = &v
	return s
}

type GetServiceProvidersPageResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data structure.
	Data *GetServiceProvidersPageResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The message returned for the request.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetServiceProvidersPageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetServiceProvidersPageResponseBody) GoString() string {
	return s.String()
}

func (s *GetServiceProvidersPageResponseBody) SetCode(v int32) *GetServiceProvidersPageResponseBody {
	s.Code = &v
	return s
}

func (s *GetServiceProvidersPageResponseBody) SetData(v *GetServiceProvidersPageResponseBodyData) *GetServiceProvidersPageResponseBody {
	s.Data = v
	return s
}

func (s *GetServiceProvidersPageResponseBody) SetMessage(v string) *GetServiceProvidersPageResponseBody {
	s.Message = &v
	return s
}

func (s *GetServiceProvidersPageResponseBody) SetSuccess(v bool) *GetServiceProvidersPageResponseBody {
	s.Success = &v
	return s
}

type GetServiceProvidersPageResponseBodyData struct {
	// The data array returned.
	Content []*GetServiceProvidersPageResponseBodyDataContent `json:"Content,omitempty" xml:"Content,omitempty" type:"Repeated"`
	// The number of entries returned per page.
	Size *int32 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The total number of returned entries.
	TotalElements *int32 `json:"TotalElements,omitempty" xml:"TotalElements,omitempty"`
	// The total number of returned pages.
	TotalPages *int32 `json:"TotalPages,omitempty" xml:"TotalPages,omitempty"`
}

func (s GetServiceProvidersPageResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetServiceProvidersPageResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetServiceProvidersPageResponseBodyData) SetContent(v []*GetServiceProvidersPageResponseBodyDataContent) *GetServiceProvidersPageResponseBodyData {
	s.Content = v
	return s
}

func (s *GetServiceProvidersPageResponseBodyData) SetSize(v int32) *GetServiceProvidersPageResponseBodyData {
	s.Size = &v
	return s
}

func (s *GetServiceProvidersPageResponseBodyData) SetTotalElements(v int32) *GetServiceProvidersPageResponseBodyData {
	s.TotalElements = &v
	return s
}

func (s *GetServiceProvidersPageResponseBodyData) SetTotalPages(v int32) *GetServiceProvidersPageResponseBodyData {
	s.TotalPages = &v
	return s
}

type GetServiceProvidersPageResponseBodyDataContent struct {
	// The remarks of the service provider.
	Iannotations *string `json:"Iannotations,omitempty" xml:"Iannotations,omitempty"`
	// The IP address of the service provider.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The port number of the service provider.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The serialization type.
	SerializeType *string `json:"SerializeType,omitempty" xml:"SerializeType,omitempty"`
	// The service timeout period.
	Timeout *string `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
}

func (s GetServiceProvidersPageResponseBodyDataContent) String() string {
	return tea.Prettify(s)
}

func (s GetServiceProvidersPageResponseBodyDataContent) GoString() string {
	return s.String()
}

func (s *GetServiceProvidersPageResponseBodyDataContent) SetIannotations(v string) *GetServiceProvidersPageResponseBodyDataContent {
	s.Iannotations = &v
	return s
}

func (s *GetServiceProvidersPageResponseBodyDataContent) SetIp(v string) *GetServiceProvidersPageResponseBodyDataContent {
	s.Ip = &v
	return s
}

func (s *GetServiceProvidersPageResponseBodyDataContent) SetPort(v string) *GetServiceProvidersPageResponseBodyDataContent {
	s.Port = &v
	return s
}

func (s *GetServiceProvidersPageResponseBodyDataContent) SetSerializeType(v string) *GetServiceProvidersPageResponseBodyDataContent {
	s.SerializeType = &v
	return s
}

func (s *GetServiceProvidersPageResponseBodyDataContent) SetTimeout(v string) *GetServiceProvidersPageResponseBodyDataContent {
	s.Timeout = &v
	return s
}

type GetServiceProvidersPageResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetServiceProvidersPageResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetServiceProvidersPageResponse) String() string {
	return tea.Prettify(s)
}

func (s GetServiceProvidersPageResponse) GoString() string {
	return s.String()
}

func (s *GetServiceProvidersPageResponse) SetHeaders(v map[string]*string) *GetServiceProvidersPageResponse {
	s.Headers = v
	return s
}

func (s *GetServiceProvidersPageResponse) SetStatusCode(v int32) *GetServiceProvidersPageResponse {
	s.StatusCode = &v
	return s
}

func (s *GetServiceProvidersPageResponse) SetBody(v *GetServiceProvidersPageResponseBody) *GetServiceProvidersPageResponse {
	s.Body = v
	return s
}

type GetWebContainerConfigRequest struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
}

func (s GetWebContainerConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s GetWebContainerConfigRequest) GoString() string {
	return s.String()
}

func (s *GetWebContainerConfigRequest) SetAppId(v string) *GetWebContainerConfigRequest {
	s.AppId = &v
	return s
}

type GetWebContainerConfigResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The Tomcat configurations of the application.
	WebContainerConfig *GetWebContainerConfigResponseBodyWebContainerConfig `json:"WebContainerConfig,omitempty" xml:"WebContainerConfig,omitempty" type:"Struct"`
}

func (s GetWebContainerConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetWebContainerConfigResponseBody) GoString() string {
	return s.String()
}

func (s *GetWebContainerConfigResponseBody) SetCode(v int32) *GetWebContainerConfigResponseBody {
	s.Code = &v
	return s
}

func (s *GetWebContainerConfigResponseBody) SetMessage(v string) *GetWebContainerConfigResponseBody {
	s.Message = &v
	return s
}

func (s *GetWebContainerConfigResponseBody) SetRequestId(v string) *GetWebContainerConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetWebContainerConfigResponseBody) SetWebContainerConfig(v *GetWebContainerConfigResponseBodyWebContainerConfig) *GetWebContainerConfigResponseBody {
	s.WebContainerConfig = v
	return s
}

type GetWebContainerConfigResponseBodyWebContainerConfig struct {
	// The type of the context path.
	ContextInputType *string `json:"ContextInputType,omitempty" xml:"ContextInputType,omitempty"`
	// The context path.
	ContextPath *string `json:"ContextPath,omitempty" xml:"ContextPath,omitempty"`
	// The HTTP service port.
	HttpPort *int32 `json:"HttpPort,omitempty" xml:"HttpPort,omitempty"`
	// The maximum number of threads.
	MaxThreads *int32 `json:"MaxThreads,omitempty" xml:"MaxThreads,omitempty"`
	// The content of the server.xml file customized by using advanced configurations.
	ServerXml *string `json:"ServerXml,omitempty" xml:"ServerXml,omitempty"`
	// The URI encoding scheme.
	UriEncoding *string `json:"UriEncoding,omitempty" xml:"UriEncoding,omitempty"`
	// Indicates whether advanced configurations are used to customize the server.xml file.
	UseAdvancedServerXml *bool `json:"UseAdvancedServerXml,omitempty" xml:"UseAdvancedServerXml,omitempty"`
	// Indicates whether the encoding scheme specified in the request body is used for uniform resource identifier (URI) query parameters.
	UseBodyEncoding *bool `json:"UseBodyEncoding,omitempty" xml:"UseBodyEncoding,omitempty"`
	// Indicates whether the default configurations are used.
	UseDefaultConfig *bool `json:"UseDefaultConfig,omitempty" xml:"UseDefaultConfig,omitempty"`
}

func (s GetWebContainerConfigResponseBodyWebContainerConfig) String() string {
	return tea.Prettify(s)
}

func (s GetWebContainerConfigResponseBodyWebContainerConfig) GoString() string {
	return s.String()
}

func (s *GetWebContainerConfigResponseBodyWebContainerConfig) SetContextInputType(v string) *GetWebContainerConfigResponseBodyWebContainerConfig {
	s.ContextInputType = &v
	return s
}

func (s *GetWebContainerConfigResponseBodyWebContainerConfig) SetContextPath(v string) *GetWebContainerConfigResponseBodyWebContainerConfig {
	s.ContextPath = &v
	return s
}

func (s *GetWebContainerConfigResponseBodyWebContainerConfig) SetHttpPort(v int32) *GetWebContainerConfigResponseBodyWebContainerConfig {
	s.HttpPort = &v
	return s
}

func (s *GetWebContainerConfigResponseBodyWebContainerConfig) SetMaxThreads(v int32) *GetWebContainerConfigResponseBodyWebContainerConfig {
	s.MaxThreads = &v
	return s
}

func (s *GetWebContainerConfigResponseBodyWebContainerConfig) SetServerXml(v string) *GetWebContainerConfigResponseBodyWebContainerConfig {
	s.ServerXml = &v
	return s
}

func (s *GetWebContainerConfigResponseBodyWebContainerConfig) SetUriEncoding(v string) *GetWebContainerConfigResponseBodyWebContainerConfig {
	s.UriEncoding = &v
	return s
}

func (s *GetWebContainerConfigResponseBodyWebContainerConfig) SetUseAdvancedServerXml(v bool) *GetWebContainerConfigResponseBodyWebContainerConfig {
	s.UseAdvancedServerXml = &v
	return s
}

func (s *GetWebContainerConfigResponseBodyWebContainerConfig) SetUseBodyEncoding(v bool) *GetWebContainerConfigResponseBodyWebContainerConfig {
	s.UseBodyEncoding = &v
	return s
}

func (s *GetWebContainerConfigResponseBodyWebContainerConfig) SetUseDefaultConfig(v bool) *GetWebContainerConfigResponseBodyWebContainerConfig {
	s.UseDefaultConfig = &v
	return s
}

type GetWebContainerConfigResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetWebContainerConfigResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetWebContainerConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s GetWebContainerConfigResponse) GoString() string {
	return s.String()
}

func (s *GetWebContainerConfigResponse) SetHeaders(v map[string]*string) *GetWebContainerConfigResponse {
	s.Headers = v
	return s
}

func (s *GetWebContainerConfigResponse) SetStatusCode(v int32) *GetWebContainerConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *GetWebContainerConfigResponse) SetBody(v *GetWebContainerConfigResponseBody) *GetWebContainerConfigResponse {
	s.Body = v
	return s
}

type ImportK8sClusterRequest struct {
	// The ID of the ACK cluster or serverless Kubernetes cluster. You can obtain the cluster ID by calling the GetK8sCluster operation. For more information, see [GetK8sCluster](~~181437~~).
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// Specifies whether to enable the integration with Alibaba Cloud Service Mesh (ASM). Valid values:
	//
	// *   true: Enables the integration with ASM.
	// *   false: Disables the integration with ASM.
	EnableAsm *bool `json:"EnableAsm,omitempty" xml:"EnableAsm,omitempty"`
	// You can ignore this parameter.
	Mode *int32 `json:"Mode,omitempty" xml:"Mode,omitempty"`
	// The ID of the namespace. It is in the format of `Region ID:Identifier of the microservices namespace`. Example: `cn-hangzhou:doc`.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
}

func (s ImportK8sClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s ImportK8sClusterRequest) GoString() string {
	return s.String()
}

func (s *ImportK8sClusterRequest) SetClusterId(v string) *ImportK8sClusterRequest {
	s.ClusterId = &v
	return s
}

func (s *ImportK8sClusterRequest) SetEnableAsm(v bool) *ImportK8sClusterRequest {
	s.EnableAsm = &v
	return s
}

func (s *ImportK8sClusterRequest) SetMode(v int32) *ImportK8sClusterRequest {
	s.Mode = &v
	return s
}

func (s *ImportK8sClusterRequest) SetNamespaceId(v string) *ImportK8sClusterRequest {
	s.NamespaceId = &v
	return s
}

type ImportK8sClusterResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The ID of the cluster in EDAS.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ImportK8sClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ImportK8sClusterResponseBody) GoString() string {
	return s.String()
}

func (s *ImportK8sClusterResponseBody) SetCode(v int32) *ImportK8sClusterResponseBody {
	s.Code = &v
	return s
}

func (s *ImportK8sClusterResponseBody) SetData(v string) *ImportK8sClusterResponseBody {
	s.Data = &v
	return s
}

func (s *ImportK8sClusterResponseBody) SetMessage(v string) *ImportK8sClusterResponseBody {
	s.Message = &v
	return s
}

func (s *ImportK8sClusterResponseBody) SetRequestId(v string) *ImportK8sClusterResponseBody {
	s.RequestId = &v
	return s
}

type ImportK8sClusterResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ImportK8sClusterResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ImportK8sClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s ImportK8sClusterResponse) GoString() string {
	return s.String()
}

func (s *ImportK8sClusterResponse) SetHeaders(v map[string]*string) *ImportK8sClusterResponse {
	s.Headers = v
	return s
}

func (s *ImportK8sClusterResponse) SetStatusCode(v int32) *ImportK8sClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *ImportK8sClusterResponse) SetBody(v *ImportK8sClusterResponseBody) *ImportK8sClusterResponse {
	s.Body = v
	return s
}

type InsertApplicationRequest struct {
	// The name of the application. The name can contain only digits, letters, hyphens (-), and underscores (\_) and must start with a letter. The name can be up to 36 characters in length.
	ApplicationName *string `json:"ApplicationName,omitempty" xml:"ApplicationName,omitempty"`
	// The build package number of EDAS Container. This parameter is required if you create a High-Speed Service Framework (HSF) application. You can query the build package number by using one of the following methods:
	//
	// *   Call the ListBuildPack operation. For more information, see [ListBuildPack](~~149391~~).
	// *   Obtain the value in the **Build package number** column of the [Release notes for EDAS Container](~~92614~~) topic.
	BuildPackId *int32 `json:"BuildPackId,omitempty" xml:"BuildPackId,omitempty"`
	// The ID of the ECS cluster in which you want to create the application. If you specify an ID, the application is created in the specified ECS cluster. If you leave this parameter empty, the application is created in the default cluster. We recommend that you specify this parameter.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The ID of the application component. You can call the ListComponents operation to query the component IDs. For more information, see [ListComponents](~~97502~~).
	//
	// This parameter is required if the application runs in Apache Tomcat or in a standard Java application runtime environment. The Apache Tomcat application runtime environment is applicable to Dubbo applications that are deployed by using WAR packages. A standard Java application runtime environment is applicable to Spring Boot or Spring Cloud applications that are deployed by using JAR packages.
	//
	// Valid values for common application components:
	//
	// *   4: Apache Tomcat 7.0.91
	// *   7: Apache Tomcat 8.5.42
	// *   5: OpenJDK 1.8.x
	// *   6: OpenJDK 1.7.x
	//
	// This parameter is available only for Java SDK 2.57.3 or later, or Python SDK 2.57.3 or later. Assume that you use an SDK that is not provided by EDAS, for example, aliyun-python-sdk-core, aliyun-java-sdk-core, and Alibaba Cloud CLI. In this case, you can directly specify this parameter.
	ComponentIds *string `json:"ComponentIds,omitempty" xml:"ComponentIds,omitempty"`
	// The number of CPU cores that can be used by the application container in a Swarm cluster. \*\*This parameter is deprecated.\*\*
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The description of the application.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The value of `ecu_id` of the ECS instance to be added during scale-out. The ECU ID is the unique identity for an ECS instance that is imported to EDAS. Separate multiple values of `ecu_id` with commas (,). You can call the ListScaleOutEcu operation to query the value of `ecu_id`. For more information, see [ListScaleOutEcu](~~149371~~).
	EcuInfo *string `json:"EcuInfo,omitempty" xml:"EcuInfo,omitempty"`
	// Specifies whether to enable the port health check. Valid values:
	//
	// *   **true**: enable the port health check.
	// *   **false**: does not enable the port health check.
	EnablePortCheck *bool `json:"EnablePortCheck,omitempty" xml:"EnablePortCheck,omitempty"`
	// Specifies whether to enable the URL health check. Valid values:
	//
	// *   **true**: enables the URL health check.
	// *   **false**: does not enable the URL health check.
	EnableUrlCheck *bool `json:"EnableUrlCheck,omitempty" xml:"EnableUrlCheck,omitempty"`
	// The health check URL of the application.
	HealthCheckURL *string `json:"HealthCheckURL,omitempty" xml:"HealthCheckURL,omitempty"`
	// The health check URL of the application. This parameter is equivalent to the HealthCheckURL parameter.
	HealthCheckUrl *string `json:"HealthCheckUrl,omitempty" xml:"HealthCheckUrl,omitempty"`
	// The script to mount. Set the value in the JSON format. Example: `[{"ignoreFail":false,"name":"postprepareInstanceEnvironmentOnScaleOut","script":"ls"},{"ignoreFail":true,"name":"postdeleteInstanceDataOnScaleIn","script":""},{"ignoreFail":true,"name":"prestartInstance","script":""},{"ignoreFail":true,"name":"poststartInstance","script":""},{"ignoreFail":true,"name":"prestopInstance","script":""},{"ignoreFail":true,"name":"poststopInstance","script":""}]`
	Hooks *string `json:"Hooks,omitempty" xml:"Hooks,omitempty"`
	// The version of the Java Development Kit (JDK) used to deploy the application. **This parameter is deprecated.
	Jdk *string `json:"Jdk,omitempty" xml:"Jdk,omitempty"`
	// The custom parameters.
	JvmOptions *string `json:"JvmOptions,omitempty" xml:"JvmOptions,omitempty"`
	// The ID of the microservices namespace. To query the ID of a microservices namespace, you can choose **Resource Management** > **Microservice Namespaces** in the left-side navigation pane of the EDAS console or call the ListUserDefineRegion operation. For more information, see [ListUserDefineRegion](~~149377~~).
	//
	// *   This parameter is required if the cluster you specify is not deployed in the default microservices namespace. Otherwise, the message `application regionId is different with cluster regionId!` appears.
	// *   If the cluster you specify is deployed in the default microservices namespace, you do not need to specify this parameter. Set this parameter to the ID of the microservices namespace in which the cluster you specify is deployed.
	LogicalRegionId *string `json:"LogicalRegionId,omitempty" xml:"LogicalRegionId,omitempty"`
	// The maximum size of the heap memory. Unit: MB.
	MaxHeapSize *int32 `json:"MaxHeapSize,omitempty" xml:"MaxHeapSize,omitempty"`
	// The size of the permanent generation heap memory. Unit: MB.
	MaxPermSize *int32 `json:"MaxPermSize,omitempty" xml:"MaxPermSize,omitempty"`
	// The memory size that can be used by the application container in a Swarm cluster. \*\*This parameter is deprecated.\*\*
	Mem *int32 `json:"Mem,omitempty" xml:"Mem,omitempty"`
	// The initial size of the heap memory. Unit: MB.
	MinHeapSize *int32 `json:"MinHeapSize,omitempty" xml:"MinHeapSize,omitempty"`
	// The type of the application deployment package. Valid values: war and jar.
	PackageType *string `json:"PackageType,omitempty" xml:"PackageType,omitempty"`
	// The reserved port for the application. \*\*This parameter is deprecated.\*\*
	ReservedPortStr *string `json:"ReservedPortStr,omitempty" xml:"ReservedPortStr,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The version of Apache Tomcat. **This parameter is deprecated.
	WebContainer *string `json:"WebContainer,omitempty" xml:"WebContainer,omitempty"`
}

func (s InsertApplicationRequest) String() string {
	return tea.Prettify(s)
}

func (s InsertApplicationRequest) GoString() string {
	return s.String()
}

func (s *InsertApplicationRequest) SetApplicationName(v string) *InsertApplicationRequest {
	s.ApplicationName = &v
	return s
}

func (s *InsertApplicationRequest) SetBuildPackId(v int32) *InsertApplicationRequest {
	s.BuildPackId = &v
	return s
}

func (s *InsertApplicationRequest) SetClusterId(v string) *InsertApplicationRequest {
	s.ClusterId = &v
	return s
}

func (s *InsertApplicationRequest) SetComponentIds(v string) *InsertApplicationRequest {
	s.ComponentIds = &v
	return s
}

func (s *InsertApplicationRequest) SetCpu(v int32) *InsertApplicationRequest {
	s.Cpu = &v
	return s
}

func (s *InsertApplicationRequest) SetDescription(v string) *InsertApplicationRequest {
	s.Description = &v
	return s
}

func (s *InsertApplicationRequest) SetEcuInfo(v string) *InsertApplicationRequest {
	s.EcuInfo = &v
	return s
}

func (s *InsertApplicationRequest) SetEnablePortCheck(v bool) *InsertApplicationRequest {
	s.EnablePortCheck = &v
	return s
}

func (s *InsertApplicationRequest) SetEnableUrlCheck(v bool) *InsertApplicationRequest {
	s.EnableUrlCheck = &v
	return s
}

func (s *InsertApplicationRequest) SetHealthCheckURL(v string) *InsertApplicationRequest {
	s.HealthCheckURL = &v
	return s
}

func (s *InsertApplicationRequest) SetHealthCheckUrl(v string) *InsertApplicationRequest {
	s.HealthCheckUrl = &v
	return s
}

func (s *InsertApplicationRequest) SetHooks(v string) *InsertApplicationRequest {
	s.Hooks = &v
	return s
}

func (s *InsertApplicationRequest) SetJdk(v string) *InsertApplicationRequest {
	s.Jdk = &v
	return s
}

func (s *InsertApplicationRequest) SetJvmOptions(v string) *InsertApplicationRequest {
	s.JvmOptions = &v
	return s
}

func (s *InsertApplicationRequest) SetLogicalRegionId(v string) *InsertApplicationRequest {
	s.LogicalRegionId = &v
	return s
}

func (s *InsertApplicationRequest) SetMaxHeapSize(v int32) *InsertApplicationRequest {
	s.MaxHeapSize = &v
	return s
}

func (s *InsertApplicationRequest) SetMaxPermSize(v int32) *InsertApplicationRequest {
	s.MaxPermSize = &v
	return s
}

func (s *InsertApplicationRequest) SetMem(v int32) *InsertApplicationRequest {
	s.Mem = &v
	return s
}

func (s *InsertApplicationRequest) SetMinHeapSize(v int32) *InsertApplicationRequest {
	s.MinHeapSize = &v
	return s
}

func (s *InsertApplicationRequest) SetPackageType(v string) *InsertApplicationRequest {
	s.PackageType = &v
	return s
}

func (s *InsertApplicationRequest) SetReservedPortStr(v string) *InsertApplicationRequest {
	s.ReservedPortStr = &v
	return s
}

func (s *InsertApplicationRequest) SetResourceGroupId(v string) *InsertApplicationRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *InsertApplicationRequest) SetWebContainer(v string) *InsertApplicationRequest {
	s.WebContainer = &v
	return s
}

type InsertApplicationResponseBody struct {
	// The information about the created application.
	ApplicationInfo *InsertApplicationResponseBodyApplicationInfo `json:"ApplicationInfo,omitempty" xml:"ApplicationInfo,omitempty" type:"Struct"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s InsertApplicationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s InsertApplicationResponseBody) GoString() string {
	return s.String()
}

func (s *InsertApplicationResponseBody) SetApplicationInfo(v *InsertApplicationResponseBodyApplicationInfo) *InsertApplicationResponseBody {
	s.ApplicationInfo = v
	return s
}

func (s *InsertApplicationResponseBody) SetCode(v int32) *InsertApplicationResponseBody {
	s.Code = &v
	return s
}

func (s *InsertApplicationResponseBody) SetMessage(v string) *InsertApplicationResponseBody {
	s.Message = &v
	return s
}

func (s *InsertApplicationResponseBody) SetRequestId(v string) *InsertApplicationResponseBody {
	s.RequestId = &v
	return s
}

type InsertApplicationResponseBodyApplicationInfo struct {
	// The ID of the application. The ID is the unique identifier of the application in EDAS.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The ID of the change process.
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	// Indicates whether the application is a Docker application. Valid values:
	//
	// *   **true**: The application is a Docker application.
	// *   **false**: The application is not a Docker application.
	Dockerize *bool `json:"Dockerize,omitempty" xml:"Dockerize,omitempty"`
	// The owner of the application. The owner is the user who created the application.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The port used by the created application. Default value: 8080. You can call the UpdateContainerConfiguration operation to change the port. For more information, see [UpdateContainerConfiguration](~~149403~~).
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The name of the region.
	RegionName *string `json:"RegionName,omitempty" xml:"RegionName,omitempty"`
	// The ID of the user who created the application.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s InsertApplicationResponseBodyApplicationInfo) String() string {
	return tea.Prettify(s)
}

func (s InsertApplicationResponseBodyApplicationInfo) GoString() string {
	return s.String()
}

func (s *InsertApplicationResponseBodyApplicationInfo) SetAppId(v string) *InsertApplicationResponseBodyApplicationInfo {
	s.AppId = &v
	return s
}

func (s *InsertApplicationResponseBodyApplicationInfo) SetAppName(v string) *InsertApplicationResponseBodyApplicationInfo {
	s.AppName = &v
	return s
}

func (s *InsertApplicationResponseBodyApplicationInfo) SetChangeOrderId(v string) *InsertApplicationResponseBodyApplicationInfo {
	s.ChangeOrderId = &v
	return s
}

func (s *InsertApplicationResponseBodyApplicationInfo) SetDockerize(v bool) *InsertApplicationResponseBodyApplicationInfo {
	s.Dockerize = &v
	return s
}

func (s *InsertApplicationResponseBodyApplicationInfo) SetOwner(v string) *InsertApplicationResponseBodyApplicationInfo {
	s.Owner = &v
	return s
}

func (s *InsertApplicationResponseBodyApplicationInfo) SetPort(v int32) *InsertApplicationResponseBodyApplicationInfo {
	s.Port = &v
	return s
}

func (s *InsertApplicationResponseBodyApplicationInfo) SetRegionName(v string) *InsertApplicationResponseBodyApplicationInfo {
	s.RegionName = &v
	return s
}

func (s *InsertApplicationResponseBodyApplicationInfo) SetUserId(v string) *InsertApplicationResponseBodyApplicationInfo {
	s.UserId = &v
	return s
}

type InsertApplicationResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *InsertApplicationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s InsertApplicationResponse) String() string {
	return tea.Prettify(s)
}

func (s InsertApplicationResponse) GoString() string {
	return s.String()
}

func (s *InsertApplicationResponse) SetHeaders(v map[string]*string) *InsertApplicationResponse {
	s.Headers = v
	return s
}

func (s *InsertApplicationResponse) SetStatusCode(v int32) *InsertApplicationResponse {
	s.StatusCode = &v
	return s
}

func (s *InsertApplicationResponse) SetBody(v *InsertApplicationResponseBody) *InsertApplicationResponse {
	s.Body = v
	return s
}

type InsertClusterRequest struct {
	// The name of the cluster.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The type of the cluster. Valid values:
	//
	// *   2: Elastic Compute Service (ECS) cluster
	// *   3: self-managed Kubernetes cluster in Enterprise Distributed Application Service (EDAS)
	// *   5: Kubernetes cluster
	ClusterType *int32 `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The provider of Infrastructure as a Service (IaaS) resources that are used in the cluster.
	//
	// When you use Alibaba Cloud, set the value to `ALIYUN`. The value is case-sensitive.
	IaasProvider *string `json:"IaasProvider,omitempty" xml:"IaasProvider,omitempty"`
	// The ID of the custom namespace. The ID is in the `physical region ID:custom namespace identifier` format. Example: `cn-hangzhou:test`.
	LogicalRegionId *string `json:"LogicalRegionId,omitempty" xml:"LogicalRegionId,omitempty"`
	// The network type of the cluster. Valid values:
	//
	// *   1: classic network
	// *   2: virtual private cloud (VPC)
	NetworkMode *int32 `json:"NetworkMode,omitempty" xml:"NetworkMode,omitempty"`
	// **This parameter is deprecated.** The CPU overcommit ratio supported by a Docker cluster. Valid values:
	//
	// *   2: 1:2, which means that resources are overcommitted by 1:2.
	// *   4: 1:4, which means that resources are overcommitted by 1:4.
	// *   8: 1:8, which means that resources are overcommitted by 1:8.
	OversoldFactor *int32 `json:"OversoldFactor,omitempty" xml:"OversoldFactor,omitempty"`
	// The ID of the VPC. This parameter is required if you set the NetworkMode parameter to 2.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s InsertClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s InsertClusterRequest) GoString() string {
	return s.String()
}

func (s *InsertClusterRequest) SetClusterName(v string) *InsertClusterRequest {
	s.ClusterName = &v
	return s
}

func (s *InsertClusterRequest) SetClusterType(v int32) *InsertClusterRequest {
	s.ClusterType = &v
	return s
}

func (s *InsertClusterRequest) SetIaasProvider(v string) *InsertClusterRequest {
	s.IaasProvider = &v
	return s
}

func (s *InsertClusterRequest) SetLogicalRegionId(v string) *InsertClusterRequest {
	s.LogicalRegionId = &v
	return s
}

func (s *InsertClusterRequest) SetNetworkMode(v int32) *InsertClusterRequest {
	s.NetworkMode = &v
	return s
}

func (s *InsertClusterRequest) SetOversoldFactor(v int32) *InsertClusterRequest {
	s.OversoldFactor = &v
	return s
}

func (s *InsertClusterRequest) SetVpcId(v string) *InsertClusterRequest {
	s.VpcId = &v
	return s
}

type InsertClusterResponseBody struct {
	// The information about the cluster that was created.
	Cluster *InsertClusterResponseBodyCluster `json:"Cluster,omitempty" xml:"Cluster,omitempty" type:"Struct"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s InsertClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s InsertClusterResponseBody) GoString() string {
	return s.String()
}

func (s *InsertClusterResponseBody) SetCluster(v *InsertClusterResponseBodyCluster) *InsertClusterResponseBody {
	s.Cluster = v
	return s
}

func (s *InsertClusterResponseBody) SetCode(v int32) *InsertClusterResponseBody {
	s.Code = &v
	return s
}

func (s *InsertClusterResponseBody) SetMessage(v string) *InsertClusterResponseBody {
	s.Message = &v
	return s
}

func (s *InsertClusterResponseBody) SetRequestId(v string) *InsertClusterResponseBody {
	s.RequestId = &v
	return s
}

type InsertClusterResponseBodyCluster struct {
	// The ID of cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the cluster.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The type of the cluster. Valid values:
	//
	// *   2: ECS cluster
	// *   3: self-managed Kubernetes cluster in EDAS
	// *   5: Kubernetes cluster
	ClusterType *int32 `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The provider of the IaaS resources that are used in the cluster.
	IaasProvider *string `json:"IaasProvider,omitempty" xml:"IaasProvider,omitempty"`
	// The network type of the cluster. Valid values:
	//
	// *   1: classic network
	// *   2\. VPC
	NetworkMode *int32 `json:"NetworkMode,omitempty" xml:"NetworkMode,omitempty"`
	// **This parameter is deprecated.** The CPU overcommit ratio supported by the Docker cluster. Valid values:
	//
	// *   2: 1:2, which means that resources are overcommitted by 1:2.
	// *   4: 1:4, which means that resources are overcommitted by 1:4.
	// *   8: 1:8, which means that resources are overcommitted by 1:8.
	OversoldFactor *int32 `json:"OversoldFactor,omitempty" xml:"OversoldFactor,omitempty"`
	// The ID of the region in which the cluster resides.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the VPC.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s InsertClusterResponseBodyCluster) String() string {
	return tea.Prettify(s)
}

func (s InsertClusterResponseBodyCluster) GoString() string {
	return s.String()
}

func (s *InsertClusterResponseBodyCluster) SetClusterId(v string) *InsertClusterResponseBodyCluster {
	s.ClusterId = &v
	return s
}

func (s *InsertClusterResponseBodyCluster) SetClusterName(v string) *InsertClusterResponseBodyCluster {
	s.ClusterName = &v
	return s
}

func (s *InsertClusterResponseBodyCluster) SetClusterType(v int32) *InsertClusterResponseBodyCluster {
	s.ClusterType = &v
	return s
}

func (s *InsertClusterResponseBodyCluster) SetIaasProvider(v string) *InsertClusterResponseBodyCluster {
	s.IaasProvider = &v
	return s
}

func (s *InsertClusterResponseBodyCluster) SetNetworkMode(v int32) *InsertClusterResponseBodyCluster {
	s.NetworkMode = &v
	return s
}

func (s *InsertClusterResponseBodyCluster) SetOversoldFactor(v int32) *InsertClusterResponseBodyCluster {
	s.OversoldFactor = &v
	return s
}

func (s *InsertClusterResponseBodyCluster) SetRegionId(v string) *InsertClusterResponseBodyCluster {
	s.RegionId = &v
	return s
}

func (s *InsertClusterResponseBodyCluster) SetVpcId(v string) *InsertClusterResponseBodyCluster {
	s.VpcId = &v
	return s
}

type InsertClusterResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *InsertClusterResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s InsertClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s InsertClusterResponse) GoString() string {
	return s.String()
}

func (s *InsertClusterResponse) SetHeaders(v map[string]*string) *InsertClusterResponse {
	s.Headers = v
	return s
}

func (s *InsertClusterResponse) SetStatusCode(v int32) *InsertClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *InsertClusterResponse) SetBody(v *InsertClusterResponseBody) *InsertClusterResponse {
	s.Body = v
	return s
}

type InsertClusterMemberRequest struct {
	// The ID of the cluster into which you want to import ECS instances.
	ClusterId *string `json:"clusterId,omitempty" xml:"clusterId,omitempty"`
	// The ID of the ECS instance that you want to import into the cluster. Separate multiple IDs with commas (,).
	InstanceIds *string `json:"instanceIds,omitempty" xml:"instanceIds,omitempty"`
	// The logon password of the ECS instance that you want to import into the cluster.
	Password *string `json:"password,omitempty" xml:"password,omitempty"`
}

func (s InsertClusterMemberRequest) String() string {
	return tea.Prettify(s)
}

func (s InsertClusterMemberRequest) GoString() string {
	return s.String()
}

func (s *InsertClusterMemberRequest) SetClusterId(v string) *InsertClusterMemberRequest {
	s.ClusterId = &v
	return s
}

func (s *InsertClusterMemberRequest) SetInstanceIds(v string) *InsertClusterMemberRequest {
	s.InstanceIds = &v
	return s
}

func (s *InsertClusterMemberRequest) SetPassword(v string) *InsertClusterMemberRequest {
	s.Password = &v
	return s
}

type InsertClusterMemberResponseBody struct {
	// The HTTP status code.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned for the request.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The additional information returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s InsertClusterMemberResponseBody) String() string {
	return tea.Prettify(s)
}

func (s InsertClusterMemberResponseBody) GoString() string {
	return s.String()
}

func (s *InsertClusterMemberResponseBody) SetCode(v int32) *InsertClusterMemberResponseBody {
	s.Code = &v
	return s
}

func (s *InsertClusterMemberResponseBody) SetData(v string) *InsertClusterMemberResponseBody {
	s.Data = &v
	return s
}

func (s *InsertClusterMemberResponseBody) SetMessage(v string) *InsertClusterMemberResponseBody {
	s.Message = &v
	return s
}

func (s *InsertClusterMemberResponseBody) SetRequestId(v string) *InsertClusterMemberResponseBody {
	s.RequestId = &v
	return s
}

type InsertClusterMemberResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *InsertClusterMemberResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s InsertClusterMemberResponse) String() string {
	return tea.Prettify(s)
}

func (s InsertClusterMemberResponse) GoString() string {
	return s.String()
}

func (s *InsertClusterMemberResponse) SetHeaders(v map[string]*string) *InsertClusterMemberResponse {
	s.Headers = v
	return s
}

func (s *InsertClusterMemberResponse) SetStatusCode(v int32) *InsertClusterMemberResponse {
	s.StatusCode = &v
	return s
}

func (s *InsertClusterMemberResponse) SetBody(v *InsertClusterMemberResponseBody) *InsertClusterMemberResponse {
	s.Body = v
	return s
}

type InsertDeployGroupRequest struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the instance group. The name can be up to 64 characters in length.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The version of the initial deployment package associated with the instance group. You can call the ListHistoryDeployVersion operation to query the version. For more information, see [ListHistoryDeployVersion](~~149392~~).
	InitPackageVersionId *string `json:"InitPackageVersionId,omitempty" xml:"InitPackageVersionId,omitempty"`
}

func (s InsertDeployGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s InsertDeployGroupRequest) GoString() string {
	return s.String()
}

func (s *InsertDeployGroupRequest) SetAppId(v string) *InsertDeployGroupRequest {
	s.AppId = &v
	return s
}

func (s *InsertDeployGroupRequest) SetGroupName(v string) *InsertDeployGroupRequest {
	s.GroupName = &v
	return s
}

func (s *InsertDeployGroupRequest) SetInitPackageVersionId(v string) *InsertDeployGroupRequest {
	s.InitPackageVersionId = &v
	return s
}

type InsertDeployGroupResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The information about the instance group.
	DeployGroupEntity *InsertDeployGroupResponseBodyDeployGroupEntity `json:"DeployGroupEntity,omitempty" xml:"DeployGroupEntity,omitempty" type:"Struct"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s InsertDeployGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s InsertDeployGroupResponseBody) GoString() string {
	return s.String()
}

func (s *InsertDeployGroupResponseBody) SetCode(v int32) *InsertDeployGroupResponseBody {
	s.Code = &v
	return s
}

func (s *InsertDeployGroupResponseBody) SetDeployGroupEntity(v *InsertDeployGroupResponseBodyDeployGroupEntity) *InsertDeployGroupResponseBody {
	s.DeployGroupEntity = v
	return s
}

func (s *InsertDeployGroupResponseBody) SetMessage(v string) *InsertDeployGroupResponseBody {
	s.Message = &v
	return s
}

func (s *InsertDeployGroupResponseBody) SetRequestId(v string) *InsertDeployGroupResponseBody {
	s.RequestId = &v
	return s
}

type InsertDeployGroupResponseBodyDeployGroupEntity struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The version of the deployment package for the application.
	//
	// *   If the application is deployed, a string of random numbers is returned.
	// *   If the application is not deployed, the return value is empty.
	AppVersionId *string `json:"AppVersionId,omitempty" xml:"AppVersionId,omitempty"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The time when the instance group was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The name of the instance group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The type of the instance group. Valid values:
	//
	// *   0: the default group.
	// *   1: a group for which canary traffic management is not enabled.
	// *   2: a group for which canary traffic management is enabled.
	GroupType *int32 `json:"GroupType,omitempty" xml:"GroupType,omitempty"`
	// The ID of the instance group.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The version of the deployment package that was used to deploy an application in the instance group.
	//
	// *   If an application is deployed in the instance group, a string of random numbers is returned.
	// *   If no application is deployed in the instance group, the return value is empty.
	PackageVersionId *string `json:"PackageVersionId,omitempty" xml:"PackageVersionId,omitempty"`
	// The time when the instance group was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s InsertDeployGroupResponseBodyDeployGroupEntity) String() string {
	return tea.Prettify(s)
}

func (s InsertDeployGroupResponseBodyDeployGroupEntity) GoString() string {
	return s.String()
}

func (s *InsertDeployGroupResponseBodyDeployGroupEntity) SetAppId(v string) *InsertDeployGroupResponseBodyDeployGroupEntity {
	s.AppId = &v
	return s
}

func (s *InsertDeployGroupResponseBodyDeployGroupEntity) SetAppVersionId(v string) *InsertDeployGroupResponseBodyDeployGroupEntity {
	s.AppVersionId = &v
	return s
}

func (s *InsertDeployGroupResponseBodyDeployGroupEntity) SetClusterId(v string) *InsertDeployGroupResponseBodyDeployGroupEntity {
	s.ClusterId = &v
	return s
}

func (s *InsertDeployGroupResponseBodyDeployGroupEntity) SetCreateTime(v int64) *InsertDeployGroupResponseBodyDeployGroupEntity {
	s.CreateTime = &v
	return s
}

func (s *InsertDeployGroupResponseBodyDeployGroupEntity) SetGroupName(v string) *InsertDeployGroupResponseBodyDeployGroupEntity {
	s.GroupName = &v
	return s
}

func (s *InsertDeployGroupResponseBodyDeployGroupEntity) SetGroupType(v int32) *InsertDeployGroupResponseBodyDeployGroupEntity {
	s.GroupType = &v
	return s
}

func (s *InsertDeployGroupResponseBodyDeployGroupEntity) SetId(v string) *InsertDeployGroupResponseBodyDeployGroupEntity {
	s.Id = &v
	return s
}

func (s *InsertDeployGroupResponseBodyDeployGroupEntity) SetPackageVersionId(v string) *InsertDeployGroupResponseBodyDeployGroupEntity {
	s.PackageVersionId = &v
	return s
}

func (s *InsertDeployGroupResponseBodyDeployGroupEntity) SetUpdateTime(v int64) *InsertDeployGroupResponseBodyDeployGroupEntity {
	s.UpdateTime = &v
	return s
}

type InsertDeployGroupResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *InsertDeployGroupResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s InsertDeployGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s InsertDeployGroupResponse) GoString() string {
	return s.String()
}

func (s *InsertDeployGroupResponse) SetHeaders(v map[string]*string) *InsertDeployGroupResponse {
	s.Headers = v
	return s
}

func (s *InsertDeployGroupResponse) SetStatusCode(v int32) *InsertDeployGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *InsertDeployGroupResponse) SetBody(v *InsertDeployGroupResponseBody) *InsertDeployGroupResponse {
	s.Body = v
	return s
}

type InsertK8sApplicationRequest struct {
	// The annotation of an application pod.
	Annotations *string `json:"Annotations,omitempty" xml:"Annotations,omitempty"`
	// The application configuration when the application template is used. Set this parameter to a JSON array.
	AppConfig *string `json:"AppConfig,omitempty" xml:"AppConfig,omitempty"`
	// The name of the application. The name must start with a letter, and can contain digits, letters, and hyphens (-). It can be up to 36 characters in length.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The name of the template used to create the application. If you specify an application template when you create an application, the application template and the AppConfig parameter are used to configure the application. Other configurations are ignored.
	AppTemplateName *string `json:"AppTemplateName,omitempty" xml:"AppTemplateName,omitempty"`
	// The description of the application.
	ApplicationDescription *string `json:"ApplicationDescription,omitempty" xml:"ApplicationDescription,omitempty"`
	// The version of `EDAS Container`. The value of this parameter conflicts with that of the `EdasContainerVersion` parameter. We recommend that you use the `EdasContainerVersion` parameter.
	BuildPackId *string `json:"BuildPackId,omitempty" xml:"BuildPackId,omitempty"`
	// The ID of the cluster. You can call the ListCluster operation to query the cluster ID. For more information, see [ListCluster](~~154995~~).
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The application startup command. If you specify this parameter, the value of this parameter will replace the startup command in the image.
	Command *string `json:"Command,omitempty" xml:"Command,omitempty"`
	// The arguments in the command. The parameter value is a JSON array of strings. An example is `[{"argument":"-c"},{"argument":"test"}]`, where `-c` and `test` are two arguments that can be set.
	CommandArgs *string `json:"CommandArgs,omitempty" xml:"CommandArgs,omitempty"`
	// The configuration for mounting a Kubernetes ConfigMap or Secret to a directory in an elastic container instance. The following parameters are included in the configuration:
	//
	// *   name: the name of the Kubernetes ConfigMap or Secret.
	// *   type: the type of the API object that you want to mount. You can mount a Kubernetes ConfigMap or Secret.
	// *   mountPath: the mount path. The mount path must be an absolute path that starts with a forward slash (/).
	ConfigMountDescs *string `json:"ConfigMountDescs,omitempty" xml:"ConfigMountDescs,omitempty"`
	// The ID of the repository used to build the image repository. If this parameter is left empty, the default repository provided by EDAS is used. Only the default repository provided by EDAS is supported.
	ContainerRegistryId *string `json:"ContainerRegistryId,omitempty" xml:"ContainerRegistryId,omitempty"`
	// The ID of the cluster. This parameter is required only when you create the application in a cluster that has not been imported.
	CsClusterId *string `json:"CsClusterId,omitempty" xml:"CsClusterId,omitempty"`
	// The custom affinity.
	CustomAffinity     *string `json:"CustomAffinity,omitempty" xml:"CustomAffinity,omitempty"`
	CustomAgentVersion *string `json:"CustomAgentVersion,omitempty" xml:"CustomAgentVersion,omitempty"`
	// The custom tolerances.
	CustomTolerations *string `json:"CustomTolerations,omitempty" xml:"CustomTolerations,omitempty"`
	// Specifies whether to distribute application instances across nodes. Value `true` indicates that application instances are distributed across nodes. Other values indicate that application instances are not distributed across nodes.
	DeployAcrossNodes *string `json:"DeployAcrossNodes,omitempty" xml:"DeployAcrossNodes,omitempty"`
	// Specifies whether to distribute application instances across zones. Value `true` indicates that application instances are distributed across zones. Other values indicate that application instances are not distributed across zones.
	DeployAcrossZones *string `json:"DeployAcrossZones,omitempty" xml:"DeployAcrossZones,omitempty"`
	// The version of `EDAS Container` on which the deployment package of the application depends.
	//
	// > This parameter is unavailable if you deploy applications by using images.
	EdasContainerVersion *string `json:"EdasContainerVersion,omitempty" xml:"EdasContainerVersion,omitempty"`
	// The configuration for mounting a Kubernetes emptyDir volume to a directory in an elastic container instance. The following parameters are included in the configuration:
	//
	// *   mountPath: The mount path in the container. This parameter is required.
	// *   readOnly: (Optional) The mount mode. Value true indicates the read-only mode. Value false indicates the read and write mode. Default value: false.
	// *   subPathExpr: (Optional) The regular expression that is used to match the subdirectory.
	EmptyDirs *string `json:"EmptyDirs,omitempty" xml:"EmptyDirs,omitempty"`
	// Specifies whether to enable access to Application High Availability Service (AHAS). Valid values:
	//
	// *   true: enables access to AHAS.
	// *   false: does not enable access to AHAS.
	EnableAhas *bool `json:"EnableAhas,omitempty" xml:"EnableAhas,omitempty"`
	// Specifies whether to activate Alibaba Cloud Service Mesh (ASM). Set this parameter to true only when you create the application in a cluster that has not been imported and you need to use ASM.
	EnableAsm *bool `json:"EnableAsm,omitempty" xml:"EnableAsm,omitempty"`
	// Specifies whether to enable the empty list protection feature. Valid values:
	//
	// *   true: enables the empty list protection feature.
	// *   false: disables the empty list protection feature.
	EnableEmptyPushReject *bool `json:"EnableEmptyPushReject,omitempty" xml:"EnableEmptyPushReject,omitempty"`
	// Specifies whether to enable graceful start rules. Valid values:
	//
	// *   true: enables graceful start rules.
	// *   false: disables graceful start rules.
	EnableLosslessRule *bool `json:"EnableLosslessRule,omitempty" xml:"EnableLosslessRule,omitempty"`
	// The Kubernetes environment variables that are configured in EnvFrom mode. A ConfigMap or Secret is mounted to a directory. Each key corresponds to a file in the directory, and the content of the file is the value of the key.
	//
	// The following parameters are included in the configuration:
	//
	// *   configMapRef: the ConfigMap that is referenced. The following parameter is contained:
	//
	//     *   name: the name of the ConfigMap.
	//
	// *   secretRef: the Secret that is referenced. The following parameter is contained:
	//
	//     *   name: the name of the Secret.
	EnvFroms *string `json:"EnvFroms,omitempty" xml:"EnvFroms,omitempty"`
	// The environment variables that are used to deploy the application. The value must be a JSON array. Valid values: regular environment variables, Kubernetes ConfigMap environment variables, or Kubernetes Secret environment variables. Specify regular environment variables in the following format:
	//
	// `{"name":"x", "value": "y"}`
	//
	// Specify Kubernetes ConfigMap environment variables in the following format to reference values from ConfigMaps:
	//
	// `{ "name": "x2", "valueFrom": { "configMapKeyRef": { "name": "my-config", "key": "y2" } } }`
	//
	// Specify Kubernetes Secret environment variables in the following format to reference values from Secrets:
	//
	// `{ "name": "x3", "valueFrom": { "secretKeyRef": { "name": "my-secret", "key": "y3" } } }`
	//
	// >  If you want to cancel this configuration, set this parameter to an empty JSON array in the format of "\[]".
	Envs           *string `json:"Envs,omitempty" xml:"Envs,omitempty"`
	FeatureConfig  *string `json:"FeatureConfig,omitempty" xml:"FeatureConfig,omitempty"`
	ImagePlatforms *string `json:"ImagePlatforms,omitempty" xml:"ImagePlatforms,omitempty"`
	// The URL of the image. This parameter is required if you set the `PackageType` parameter to `Image`.
	ImageUrl       *string `json:"ImageUrl,omitempty" xml:"ImageUrl,omitempty"`
	InitContainers *string `json:"InitContainers,omitempty" xml:"InitContainers,omitempty"`
	// The ID of the Internet-facing SLB instance. If you do not specify this parameter, EDAS automatically purchases a new SLB instance for you.
	InternetSlbId *string `json:"InternetSlbId,omitempty" xml:"InternetSlbId,omitempty"`
	// The frontend port of the Internet-facing SLB instance. Valid values: 1 to 65535.
	InternetSlbPort *int32 `json:"InternetSlbPort,omitempty" xml:"InternetSlbPort,omitempty"`
	// The protocol used by the Internet-facing SLB instance. Valid values: TCP, HTTP, and HTTPS.
	InternetSlbProtocol *string `json:"InternetSlbProtocol,omitempty" xml:"InternetSlbProtocol,omitempty"`
	// The backend port of the internal-facing SLB instance. This port also serves as the service port of the application. Valid values: 1 to 65535.
	InternetTargetPort *int32 `json:"InternetTargetPort,omitempty" xml:"InternetTargetPort,omitempty"`
	// The ID of the internal-facing SLB instance. If you do not specify this parameter, Enterprise Distributed Application Service (EDAS) automatically purchases a new SLB instance for you.
	IntranetSlbId *string `json:"IntranetSlbId,omitempty" xml:"IntranetSlbId,omitempty"`
	// The frontend port of the internal-facing SLB instance. Valid values: 1 to 65535.
	IntranetSlbPort *int32 `json:"IntranetSlbPort,omitempty" xml:"IntranetSlbPort,omitempty"`
	// The protocol used by the internal-facing SLB instance. Valid values: TCP, HTTP, and HTTPS.
	IntranetSlbProtocol *string `json:"IntranetSlbProtocol,omitempty" xml:"IntranetSlbProtocol,omitempty"`
	// The backend port of the internal-facing Server Load Balancer (SLB) instance. This port also serves as the service port of the application. Valid values: 1 to 65535.
	IntranetTargetPort *int32 `json:"IntranetTargetPort,omitempty" xml:"IntranetTargetPort,omitempty"`
	// Specifies whether the application is a multi-language application.
	IsMultilingualApp *bool `json:"IsMultilingualApp,omitempty" xml:"IsMultilingualApp,omitempty"`
	// The version of the Java Development Kit (JDK) on which the deployment package of the application depends. Valid values: Open JDK 7 and Open JDK 8. This parameter is unavailable if you deploy applications by using images.
	JDK *string `json:"JDK,omitempty" xml:"JDK,omitempty"`
	// The configuration of Java startup parameters for a Java application. These startup parameters involve the memory, application, garbage collection (GC) policy, tools, service registration and discovery, and custom configurations. Appropriate parameter settings help reduce the GC overheads, shorten the server response time, and improve the throughput. Set this parameter to a JSON string. In the example, original indicates the configuration value, and startup indicates a startup parameter. The system automatically concatenates all startup values as the settings of Java startup parameters for the application. To delete this configuration, leave the parameter value empty by entering `""` or `"{}"`. The following parameters are included in the configuration:
	//
	// *   InitialHeapSize: the initial size of the heap memory.
	// *   MaxHeapSize: the maximum size of the heap memory.
	// *   CustomParams: the custom parameters, such as JVM -D parameters.
	// *   Other parameters: You can view the JSON structure submitted by the frontend.
	JavaStartUpConfig *string `json:"JavaStartUpConfig,omitempty" xml:"JavaStartUpConfig,omitempty"`
	// The label of an application pod.
	Labels *string `json:"Labels,omitempty" xml:"Labels,omitempty"`
	// The maximum number of CPU cores allowed for each application instance when the application is running. Unit: cores. If the LimitmCpu parameter is specified, you can ignore this parameter.
	LimitCpu *int32 `json:"LimitCpu,omitempty" xml:"LimitCpu,omitempty"`
	// The maximum size of space required by ephemeral storage. Unit: GB. Value 0 indicates that no limit is set on the space size.
	LimitEphemeralStorage *int32 `json:"LimitEphemeralStorage,omitempty" xml:"LimitEphemeralStorage,omitempty"`
	// The maximum size of memory allowed for each application instance when the application is running. Unit: MB. The value of LimitMem must be greater than that of RequestsMem.
	LimitMem *int32 `json:"LimitMem,omitempty" xml:"LimitMem,omitempty"`
	// The maximum number of CPU cores allowed for each application instance when the application is running. Unit: millicores. Value 0 indicates that no limit is set on CPU cores.
	LimitmCpu *int32 `json:"LimitmCpu,omitempty" xml:"LimitmCpu,omitempty"`
	// The configuration for the liveness check on the container. Example: `{"failureThreshold": 3,"initialDelaySeconds": 5,"successThreshold": 1,"timeoutSeconds": 1,"tcpSocket":{"host":"", "port":8080}}`.
	//
	// If you want to cancel this configuration, leave the parameter value empty by entering `""` or `{}`. If you do not specify this parameter, this configuration is ignored.
	Liveness *string `json:"Liveness,omitempty" xml:"Liveness,omitempty"`
	// The configurations that are used when the host files are mounted to the container on which the application is running. Example: `\[{"type":"","nodePath":"/localfiles","mountPath":"/app/files"},{"type":"Directory","nodePath":"/mnt","mountPath":"/app/storage"}\]`. Description:
	//
	// *   `nodePath`: the host path.
	// *   `mountPath`: the path in the container.
	// *   `type`: the mounting type.
	LocalVolume *string `json:"LocalVolume,omitempty" xml:"LocalVolume,omitempty"`
	// The ID of the EDAS namespace. This parameter is required for a non-default namespace.
	LogicalRegionId *string `json:"LogicalRegionId,omitempty" xml:"LogicalRegionId,omitempty"`
	// Specifies whether to enable the graceful rolling deployment mode and ensure that the service is registered before the readiness check. Valid values:
	//
	// *   true: provides port 55199 and the /health path for the health check in a non-intrusive manner. When the service is registered, the system returns HTTP 200 status code. Otherwise, the system returns HTTP 500 status code.
	//
	//     **
	//
	//     **Note**If you set both the `LosslessRuleRelated` parameter and this parameter to `true`, the operation checks whether the service prefetching is complete.
	//
	// *   false: does not check whether the service is registered.
	LosslessRuleAligned *bool `json:"LosslessRuleAligned,omitempty" xml:"LosslessRuleAligned,omitempty"`
	// The delay of service registration. Valid values: 0 to 86400. Unit: seconds.
	LosslessRuleDelayTime *int32 `json:"LosslessRuleDelayTime,omitempty" xml:"LosslessRuleDelayTime,omitempty"`
	// The number of prefetching curves. Valid values: 0 to 20. The default value is 2, which is suitable for common prefetching scenarios. This value indicates that the received traffic of the provider during prefetching is displayed as a quadratic curve.
	LosslessRuleFuncType *int32 `json:"LosslessRuleFuncType,omitempty" xml:"LosslessRuleFuncType,omitempty"`
	// Specifies whether to enable the graceful rolling deployment mode and ensure that the service prefetching is complete before the readiness check. Valid values:
	//
	// *   true: provides port 55199 and the /health path for the health check in a non-intrusive manner. When the service prefetching is complete, the system returns HTTP 200 status code. Otherwise, the system returns HTTP 500 status code.
	// *   false: does not check whether the service prefetching is complete.
	LosslessRuleRelated *bool `json:"LosslessRuleRelated,omitempty" xml:"LosslessRuleRelated,omitempty"`
	// The service prefetching duration. Valid values: 0 to 86400. Unit: seconds.
	LosslessRuleWarmupTime *int32 `json:"LosslessRuleWarmupTime,omitempty" xml:"LosslessRuleWarmupTime,omitempty"`
	// The description of the NAS mounting configuration. Set this parameter to a serialized JSON string. Example: `\[{"nasPath": "/k8s","mountPath": "/mnt"},{"nasPath": "/files","mountPath": "/app/files"}\]`. The `nasPath` parameter specifies the file storage path, and the `mountPath` parameter specifies the path to mount the file system to the container where the application is running.
	MountDescs *string `json:"MountDescs,omitempty" xml:"MountDescs,omitempty"`
	// The namespace of the Kubernetes cluster. This parameter specifies the Kubernetes namespace in which your application is deployed. By default, the default namespace is used.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The ID of the Network Attached Storage (NAS) file system that you want to mount to the application. If you do not specify this parameter but specify the MountDescs parameter, a NAS file system is automatically purchased and mounted to the vSwitch in the VPC.
	NasId *string `json:"NasId,omitempty" xml:"NasId,omitempty"`
	// The type of the deployment package. Valid values: FatJar, WAR, and Image.
	PackageType *string `json:"PackageType,omitempty" xml:"PackageType,omitempty"`
	// The URL of the deployment package. This parameter is required if you use a FatJar or WAR package to deploy the application.
	//
	// > The version of EDAS SDK for Java or Python must be V2.44.0 or later.
	PackageUrl *string `json:"PackageUrl,omitempty" xml:"PackageUrl,omitempty"`
	// The version of the deployment package. This parameter is required if you use a FatJar or WAR package to deploy the application. You must specify a version.
	//
	// > The version of EDAS SDK for Java or Python must be V2.44.0 or later.
	PackageVersion *string `json:"PackageVersion,omitempty" xml:"PackageVersion,omitempty"`
	// The post-start script. Example: `{"exec":{"command":\["cat","/etc/group"\]}}`.
	//
	// If you want to cancel this configuration, leave this parameter empty by setting it to `""` or `{}`. If you do not specify this parameter, this configuration is ignored.
	PostStart *string `json:"PostStart,omitempty" xml:"PostStart,omitempty"`
	// The pre-stop script. Example: `{"tcpSocket":{"host":"", "port":8080}}`.
	//
	// If you want to cancel this configuration, leave this parameter empty by setting it to `""` or `{}`. If you do not specify this parameter, this configuration is ignored.
	PreStop *string `json:"PreStop,omitempty" xml:"PreStop,omitempty"`
	// The configuration for mounting a Kubernetes PersistentVolumeClaim (PVC) volume to a directory in an elastic container instance. The following parameters are included in the configuration:
	//
	// *   pvcName: the name of the PVC volume. Make sure that the PVC volume is an existing volume and is in the Bound state.
	//
	// *   mountPaths: the directory to which you want to mount the PVC volume. You can configure multiple directories. You can set the following two parameters for each mount directory:
	//
	//     *   mountPath: the mount path. The mount path must be an absolute path that starts with a forward slash (/).
	//     *   readOnly: the mount mode. Value true indicates the read-only mode. Value false indicates the read and write mode. Default value: false.
	PvcMountDescs *string `json:"PvcMountDescs,omitempty" xml:"PvcMountDescs,omitempty"`
	// The configuration for the readiness check on the container. If the check fails, the traffic that passes through the Kubernetes Service is not transmitted to the container. Example: \`{"failureThreshold": 3,"initialDelaySeconds": 5,"successThreshold": 1,"timeoutSeconds": 1,"httpGet": {"path": "/consumer","port": 8080,"scheme": "HTTP","httpHeaders": \\[{"name": "test","value": "testvalue"}\\]}}\`.``
	//
	// If you want to cancel this configuration, leave the parameter value empty by entering `""` or `{}`. If you do not specify this parameter, this configuration is ignored.
	Readiness *string `json:"Readiness,omitempty" xml:"Readiness,omitempty"`
	// The number of application instances.
	Replicas *int32 `json:"Replicas,omitempty" xml:"Replicas,omitempty"`
	// The ID of the image repository.
	RepoId *string `json:"RepoId,omitempty" xml:"RepoId,omitempty"`
	// The maximum number of CPU cores allowed for each application instance when the application is created. Unit: cores. Value 0 indicates that no limit is set on CPU cores. If the RequestsmCpu parameter is specified, the value of the RequestsmCpu parameter is used. You can ignore this parameter.
	RequestsCpu *int32 `json:"RequestsCpu,omitempty" xml:"RequestsCpu,omitempty"`
	// The minimum size of space required by ephemeral storage. Unit: GB. Value 0 indicates that no limit is set on the space size.
	RequestsEphemeralStorage *int32 `json:"RequestsEphemeralStorage,omitempty" xml:"RequestsEphemeralStorage,omitempty"`
	// The maximum size of memory allowed for each application instance when the application is created. Unit: MB. Value 0 indicates that no limit is set on the memory size. The value of RequestsMem cannot be greater than that of LimitMem.
	RequestsMem *int32 `json:"RequestsMem,omitempty" xml:"RequestsMem,omitempty"`
	// The maximum number of CPU cores allowed for each application instance when the application is created. Unit: millicores.
	RequestsmCpu *int32 `json:"RequestsmCpu,omitempty" xml:"RequestsmCpu,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The type of the container runtime. This parameter is applicable only to clusters that use sandboxed containers.
	RuntimeClassName *string `json:"RuntimeClassName,omitempty" xml:"RuntimeClassName,omitempty"`
	// The name of the credential that is used to pull the images specified by the user. You must configure the Secret.
	SecretName *string `json:"SecretName,omitempty" xml:"SecretName,omitempty"`
	// The configurations of services in a Kubernetes cluster.
	ServiceConfigs *string `json:"ServiceConfigs,omitempty" xml:"ServiceConfigs,omitempty"`
	Sidecars       *string `json:"Sidecars,omitempty" xml:"Sidecars,omitempty"`
	// The Logstore configuration. To delete this configuration, leave the parameter value empty by entering `""` or `"{}"`.
	//
	// *   The following parameters are included in the configuration:
	//
	//     *   type: the collection type. Set this parameter to file to specify the file type. Set this parameter to stdout to specify the standard output type.
	//
	//     *   logstore: the name of the Logstore. Make sure that the name of the Logstore is unique in the cluster. The name must comply with the following rules:
	//
	//         *   The name can contain only lowercase letters, digits, hyphens (-), and underscores (\_).
	//         *   The name must start and end with a lowercase letter or a digit.
	//         *   The name must be 3 to 63 characters in length. If you leave this parameter empty, the system automatically generates a name.
	//
	//     *   LogDir: If the standard output type is used, the collection path is stdout.log. If the file type is used, the collection path is the path of the collected file. Wildcards (\*) are supported. The collection path must match the following regular expression: `^/(.+)/(.*)^/$`.
	SlsConfigs *string `json:"SlsConfigs,omitempty" xml:"SlsConfigs,omitempty"`
	Startup    *string `json:"Startup,omitempty" xml:"Startup,omitempty"`
	// The storage type of the NAS file system.
	//
	// *   Valid values for General-purpose NAS file systems: Capacity and Performance.
	// *   Valid values for Extreme NAS file systems: Standard and Advance.
	//
	// You can set this parameter only to Performance.
	StorageType          *string `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
	TerminateGracePeriod *int32  `json:"TerminateGracePeriod,omitempty" xml:"TerminateGracePeriod,omitempty"`
	// The timeout period of the change process. Valid values: 1 to 1800. Unit: seconds. If you do not specify this Unidentifiedparameter, the default value 1800 is used.
	Timeout *int32 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
	// The URI encoding scheme. Valid values: ISO-8859-1, GBK, GB2312, and UTF-8.
	//
	// > If you do not specify this parameter in the application configurations, the default URI encoding scheme in the Tomcat container is applied.
	UriEncoding *string `json:"UriEncoding,omitempty" xml:"UriEncoding,omitempty"`
	// Specifies whether to use the encoding scheme specified in the request body for URI query parameters.
	//
	// > If this parameter is not specified in application configuration, the default value false is applied.
	UseBodyEncoding  *bool   `json:"UseBodyEncoding,omitempty" xml:"UseBodyEncoding,omitempty"`
	UserBaseImageUrl *string `json:"UserBaseImageUrl,omitempty" xml:"UserBaseImageUrl,omitempty"`
	// The version of the Tomcat container on which the deployment package of the application depends. This parameter is applicable to Spring Cloud and Dubbo applications that you deploy by using WAR packages. This parameter is unavailable if you deploy applications by using images.
	WebContainer *string `json:"WebContainer,omitempty" xml:"WebContainer,omitempty"`
	// The configuration of the Tomcat container. If you want to cancel this configuration, set this parameter to "" or "{}". The following parameters are included in the configuration:
	//
	// *   useDefaultConfig: specifies whether to use the default configuration. Value true indicates that the default configuration is used. Value false indicates that the custom configuration is used. If the default configuration is used, the following parameters do not take effect:
	//
	// *   contextInputType: the type of the access path for the application. Valid values:
	//
	//     *   war: The access path is the name of the WAR package. You do not need to specify a custom path.
	//     *   root: The access path for the application is `/`. You do not need to specify a custom path.
	//     *   custom: If you select this option, you must specify a custom path for the contextPath parameter.
	//
	// *   contextPath: the custom access path for the application. This parameter is required only when you set the contextInputType parameter to custom.
	//
	// *   httpPort: the port number. The port number ranges from 1024 to 65535. Though the admin permissions are configured for the container, the root permissions are required to perform operations on ports whose number is less than 1024. Enter a value that ranges from 1024 to 65535 because the container has only the admin permissions. If you do not configure this parameter, the default port number 8080 is used.
	//
	// *   maxThreads: the maximum number of connections in the connection pool. Default value: 400.
	//
	//     **
	//
	//     **Note**This parameter significantly affects application performance. We recommend that you consult with technical support before you set this parameter.
	//
	// *   uriEncoding: the URI encoding scheme in the Tomcat container. Valid values: UTF-8, ISO-8859-1, GBK, and GB2312. If you do not specify this parameter, the default value ISO-8859-1 is used.
	//
	// *   useBodyEncoding: specifies whether to use the encoding scheme specified in the request body for URI query parameters.
	//
	// *   useAdvancedServerXml: specifies whether to use advanced configurations to customize the server.xml file. If the preceding parameter types and specific parameters cannot meet your requirements, you can use advanced configurations to customize the server.xml file of Tomcat.
	//
	// *   serverXml: the content of the server.xml file customized by using advanced configurations. This parameter takes effect only when you set the useAdvancedServerXml parameter to true.
	WebContainerConfig *string `json:"WebContainerConfig,omitempty" xml:"WebContainerConfig,omitempty"`
	WorkloadType       *string `json:"WorkloadType,omitempty" xml:"WorkloadType,omitempty"`
}

func (s InsertK8sApplicationRequest) String() string {
	return tea.Prettify(s)
}

func (s InsertK8sApplicationRequest) GoString() string {
	return s.String()
}

func (s *InsertK8sApplicationRequest) SetAnnotations(v string) *InsertK8sApplicationRequest {
	s.Annotations = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetAppConfig(v string) *InsertK8sApplicationRequest {
	s.AppConfig = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetAppName(v string) *InsertK8sApplicationRequest {
	s.AppName = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetAppTemplateName(v string) *InsertK8sApplicationRequest {
	s.AppTemplateName = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetApplicationDescription(v string) *InsertK8sApplicationRequest {
	s.ApplicationDescription = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetBuildPackId(v string) *InsertK8sApplicationRequest {
	s.BuildPackId = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetClusterId(v string) *InsertK8sApplicationRequest {
	s.ClusterId = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetCommand(v string) *InsertK8sApplicationRequest {
	s.Command = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetCommandArgs(v string) *InsertK8sApplicationRequest {
	s.CommandArgs = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetConfigMountDescs(v string) *InsertK8sApplicationRequest {
	s.ConfigMountDescs = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetContainerRegistryId(v string) *InsertK8sApplicationRequest {
	s.ContainerRegistryId = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetCsClusterId(v string) *InsertK8sApplicationRequest {
	s.CsClusterId = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetCustomAffinity(v string) *InsertK8sApplicationRequest {
	s.CustomAffinity = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetCustomAgentVersion(v string) *InsertK8sApplicationRequest {
	s.CustomAgentVersion = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetCustomTolerations(v string) *InsertK8sApplicationRequest {
	s.CustomTolerations = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetDeployAcrossNodes(v string) *InsertK8sApplicationRequest {
	s.DeployAcrossNodes = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetDeployAcrossZones(v string) *InsertK8sApplicationRequest {
	s.DeployAcrossZones = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetEdasContainerVersion(v string) *InsertK8sApplicationRequest {
	s.EdasContainerVersion = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetEmptyDirs(v string) *InsertK8sApplicationRequest {
	s.EmptyDirs = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetEnableAhas(v bool) *InsertK8sApplicationRequest {
	s.EnableAhas = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetEnableAsm(v bool) *InsertK8sApplicationRequest {
	s.EnableAsm = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetEnableEmptyPushReject(v bool) *InsertK8sApplicationRequest {
	s.EnableEmptyPushReject = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetEnableLosslessRule(v bool) *InsertK8sApplicationRequest {
	s.EnableLosslessRule = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetEnvFroms(v string) *InsertK8sApplicationRequest {
	s.EnvFroms = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetEnvs(v string) *InsertK8sApplicationRequest {
	s.Envs = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetFeatureConfig(v string) *InsertK8sApplicationRequest {
	s.FeatureConfig = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetImagePlatforms(v string) *InsertK8sApplicationRequest {
	s.ImagePlatforms = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetImageUrl(v string) *InsertK8sApplicationRequest {
	s.ImageUrl = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetInitContainers(v string) *InsertK8sApplicationRequest {
	s.InitContainers = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetInternetSlbId(v string) *InsertK8sApplicationRequest {
	s.InternetSlbId = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetInternetSlbPort(v int32) *InsertK8sApplicationRequest {
	s.InternetSlbPort = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetInternetSlbProtocol(v string) *InsertK8sApplicationRequest {
	s.InternetSlbProtocol = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetInternetTargetPort(v int32) *InsertK8sApplicationRequest {
	s.InternetTargetPort = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetIntranetSlbId(v string) *InsertK8sApplicationRequest {
	s.IntranetSlbId = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetIntranetSlbPort(v int32) *InsertK8sApplicationRequest {
	s.IntranetSlbPort = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetIntranetSlbProtocol(v string) *InsertK8sApplicationRequest {
	s.IntranetSlbProtocol = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetIntranetTargetPort(v int32) *InsertK8sApplicationRequest {
	s.IntranetTargetPort = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetIsMultilingualApp(v bool) *InsertK8sApplicationRequest {
	s.IsMultilingualApp = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetJDK(v string) *InsertK8sApplicationRequest {
	s.JDK = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetJavaStartUpConfig(v string) *InsertK8sApplicationRequest {
	s.JavaStartUpConfig = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetLabels(v string) *InsertK8sApplicationRequest {
	s.Labels = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetLimitCpu(v int32) *InsertK8sApplicationRequest {
	s.LimitCpu = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetLimitEphemeralStorage(v int32) *InsertK8sApplicationRequest {
	s.LimitEphemeralStorage = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetLimitMem(v int32) *InsertK8sApplicationRequest {
	s.LimitMem = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetLimitmCpu(v int32) *InsertK8sApplicationRequest {
	s.LimitmCpu = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetLiveness(v string) *InsertK8sApplicationRequest {
	s.Liveness = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetLocalVolume(v string) *InsertK8sApplicationRequest {
	s.LocalVolume = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetLogicalRegionId(v string) *InsertK8sApplicationRequest {
	s.LogicalRegionId = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetLosslessRuleAligned(v bool) *InsertK8sApplicationRequest {
	s.LosslessRuleAligned = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetLosslessRuleDelayTime(v int32) *InsertK8sApplicationRequest {
	s.LosslessRuleDelayTime = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetLosslessRuleFuncType(v int32) *InsertK8sApplicationRequest {
	s.LosslessRuleFuncType = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetLosslessRuleRelated(v bool) *InsertK8sApplicationRequest {
	s.LosslessRuleRelated = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetLosslessRuleWarmupTime(v int32) *InsertK8sApplicationRequest {
	s.LosslessRuleWarmupTime = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetMountDescs(v string) *InsertK8sApplicationRequest {
	s.MountDescs = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetNamespace(v string) *InsertK8sApplicationRequest {
	s.Namespace = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetNasId(v string) *InsertK8sApplicationRequest {
	s.NasId = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetPackageType(v string) *InsertK8sApplicationRequest {
	s.PackageType = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetPackageUrl(v string) *InsertK8sApplicationRequest {
	s.PackageUrl = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetPackageVersion(v string) *InsertK8sApplicationRequest {
	s.PackageVersion = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetPostStart(v string) *InsertK8sApplicationRequest {
	s.PostStart = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetPreStop(v string) *InsertK8sApplicationRequest {
	s.PreStop = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetPvcMountDescs(v string) *InsertK8sApplicationRequest {
	s.PvcMountDescs = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetReadiness(v string) *InsertK8sApplicationRequest {
	s.Readiness = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetReplicas(v int32) *InsertK8sApplicationRequest {
	s.Replicas = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetRepoId(v string) *InsertK8sApplicationRequest {
	s.RepoId = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetRequestsCpu(v int32) *InsertK8sApplicationRequest {
	s.RequestsCpu = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetRequestsEphemeralStorage(v int32) *InsertK8sApplicationRequest {
	s.RequestsEphemeralStorage = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetRequestsMem(v int32) *InsertK8sApplicationRequest {
	s.RequestsMem = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetRequestsmCpu(v int32) *InsertK8sApplicationRequest {
	s.RequestsmCpu = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetResourceGroupId(v string) *InsertK8sApplicationRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetRuntimeClassName(v string) *InsertK8sApplicationRequest {
	s.RuntimeClassName = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetSecretName(v string) *InsertK8sApplicationRequest {
	s.SecretName = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetServiceConfigs(v string) *InsertK8sApplicationRequest {
	s.ServiceConfigs = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetSidecars(v string) *InsertK8sApplicationRequest {
	s.Sidecars = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetSlsConfigs(v string) *InsertK8sApplicationRequest {
	s.SlsConfigs = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetStartup(v string) *InsertK8sApplicationRequest {
	s.Startup = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetStorageType(v string) *InsertK8sApplicationRequest {
	s.StorageType = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetTerminateGracePeriod(v int32) *InsertK8sApplicationRequest {
	s.TerminateGracePeriod = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetTimeout(v int32) *InsertK8sApplicationRequest {
	s.Timeout = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetUriEncoding(v string) *InsertK8sApplicationRequest {
	s.UriEncoding = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetUseBodyEncoding(v bool) *InsertK8sApplicationRequest {
	s.UseBodyEncoding = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetUserBaseImageUrl(v string) *InsertK8sApplicationRequest {
	s.UserBaseImageUrl = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetWebContainer(v string) *InsertK8sApplicationRequest {
	s.WebContainer = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetWebContainerConfig(v string) *InsertK8sApplicationRequest {
	s.WebContainerConfig = &v
	return s
}

func (s *InsertK8sApplicationRequest) SetWorkloadType(v string) *InsertK8sApplicationRequest {
	s.WorkloadType = &v
	return s
}

type InsertK8sApplicationResponseBody struct {
	// The details of the application.
	ApplicationInfo *InsertK8sApplicationResponseBodyApplicationInfo `json:"ApplicationInfo,omitempty" xml:"ApplicationInfo,omitempty" type:"Struct"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s InsertK8sApplicationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s InsertK8sApplicationResponseBody) GoString() string {
	return s.String()
}

func (s *InsertK8sApplicationResponseBody) SetApplicationInfo(v *InsertK8sApplicationResponseBodyApplicationInfo) *InsertK8sApplicationResponseBody {
	s.ApplicationInfo = v
	return s
}

func (s *InsertK8sApplicationResponseBody) SetCode(v int32) *InsertK8sApplicationResponseBody {
	s.Code = &v
	return s
}

func (s *InsertK8sApplicationResponseBody) SetMessage(v string) *InsertK8sApplicationResponseBody {
	s.Message = &v
	return s
}

func (s *InsertK8sApplicationResponseBody) SetRequestId(v string) *InsertK8sApplicationResponseBody {
	s.RequestId = &v
	return s
}

type InsertK8sApplicationResponseBodyApplicationInfo struct {
	// The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The ID of the change process. You can call the GetChangeOrderInfo operation to query the change process ID. For more information, see [GetChangeOrderInfo](~~62072~~).
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	// The type of the cluster. Valid values:
	//
	// *   0: regular Docker cluster
	// *   1: Swarm cluster (discontinued)
	// *   2: Elastic Compute Service (ECS) cluster
	// *   3: self-managed Kubernetes cluster in EDAS (discontinued)
	// *   4: cluster in which Pandora automatically registers applications
	// *   5: ACK cluster and serverless Kubernetes cluster
	ClusterType *int32 `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// Indicates whether the application is a Docker application.
	//
	// *   true: The application is a Docker application.
	// *   false: The application is not a Docker application.
	Dockerize *bool `json:"Dockerize,omitempty" xml:"Dockerize,omitempty"`
	// The ID of the user to which the application belongs. This ID is generated by EDAS.
	EdasId *string `json:"EdasId,omitempty" xml:"EdasId,omitempty"`
	// The owner of the application.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the Alibaba Cloud account to which the application belongs.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s InsertK8sApplicationResponseBodyApplicationInfo) String() string {
	return tea.Prettify(s)
}

func (s InsertK8sApplicationResponseBodyApplicationInfo) GoString() string {
	return s.String()
}

func (s *InsertK8sApplicationResponseBodyApplicationInfo) SetAppId(v string) *InsertK8sApplicationResponseBodyApplicationInfo {
	s.AppId = &v
	return s
}

func (s *InsertK8sApplicationResponseBodyApplicationInfo) SetAppName(v string) *InsertK8sApplicationResponseBodyApplicationInfo {
	s.AppName = &v
	return s
}

func (s *InsertK8sApplicationResponseBodyApplicationInfo) SetChangeOrderId(v string) *InsertK8sApplicationResponseBodyApplicationInfo {
	s.ChangeOrderId = &v
	return s
}

func (s *InsertK8sApplicationResponseBodyApplicationInfo) SetClusterType(v int32) *InsertK8sApplicationResponseBodyApplicationInfo {
	s.ClusterType = &v
	return s
}

func (s *InsertK8sApplicationResponseBodyApplicationInfo) SetDockerize(v bool) *InsertK8sApplicationResponseBodyApplicationInfo {
	s.Dockerize = &v
	return s
}

func (s *InsertK8sApplicationResponseBodyApplicationInfo) SetEdasId(v string) *InsertK8sApplicationResponseBodyApplicationInfo {
	s.EdasId = &v
	return s
}

func (s *InsertK8sApplicationResponseBodyApplicationInfo) SetOwner(v string) *InsertK8sApplicationResponseBodyApplicationInfo {
	s.Owner = &v
	return s
}

func (s *InsertK8sApplicationResponseBodyApplicationInfo) SetRegionId(v string) *InsertK8sApplicationResponseBodyApplicationInfo {
	s.RegionId = &v
	return s
}

func (s *InsertK8sApplicationResponseBodyApplicationInfo) SetUserId(v string) *InsertK8sApplicationResponseBodyApplicationInfo {
	s.UserId = &v
	return s
}

type InsertK8sApplicationResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *InsertK8sApplicationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s InsertK8sApplicationResponse) String() string {
	return tea.Prettify(s)
}

func (s InsertK8sApplicationResponse) GoString() string {
	return s.String()
}

func (s *InsertK8sApplicationResponse) SetHeaders(v map[string]*string) *InsertK8sApplicationResponse {
	s.Headers = v
	return s
}

func (s *InsertK8sApplicationResponse) SetStatusCode(v int32) *InsertK8sApplicationResponse {
	s.StatusCode = &v
	return s
}

func (s *InsertK8sApplicationResponse) SetBody(v *InsertK8sApplicationResponseBody) *InsertK8sApplicationResponse {
	s.Body = v
	return s
}

type InsertOrUpdateRegionRequest struct {
	// Specifies whether to enable remote debugging. Valid values:
	//
	// *   true: enables remote debugging.
	// *   false: disables remote debugging.
	DebugEnable *bool `json:"DebugEnable,omitempty" xml:"DebugEnable,omitempty"`
	// The description of the namespace. The description can be up to 128 characters in length.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Specifies whether to create or modify the namespace. If this parameter is left empty or is set to 0, the namespace is created. Otherwise, the namespace is modified.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the MSE registry.
	MseInstanceId *string `json:"MseInstanceId,omitempty" xml:"MseInstanceId,omitempty"`
	// The name of the namespace. The name can be up to 63 characters in length.
	RegionName *string `json:"RegionName,omitempty" xml:"RegionName,omitempty"`
	// The ID of the namespace.
	//
	// *   The ID of a custom namespace is in the `Region ID:Namespace identifier` format. Example: cn-beijing:tdy218.
	// *   The ID of the default namespace is in the `region ID` format. Example: cn-beijing.
	RegionTag *string `json:"RegionTag,omitempty" xml:"RegionTag,omitempty"`
	// The type of the registry.
	//
	// *   default: the shared registry of Enterprise Distributed Application Service (EDAS)
	// *   exclusive_mse: a Microservices Engine (MSE) registry
	RegistryType *string `json:"RegistryType,omitempty" xml:"RegistryType,omitempty"`
}

func (s InsertOrUpdateRegionRequest) String() string {
	return tea.Prettify(s)
}

func (s InsertOrUpdateRegionRequest) GoString() string {
	return s.String()
}

func (s *InsertOrUpdateRegionRequest) SetDebugEnable(v bool) *InsertOrUpdateRegionRequest {
	s.DebugEnable = &v
	return s
}

func (s *InsertOrUpdateRegionRequest) SetDescription(v string) *InsertOrUpdateRegionRequest {
	s.Description = &v
	return s
}

func (s *InsertOrUpdateRegionRequest) SetId(v int64) *InsertOrUpdateRegionRequest {
	s.Id = &v
	return s
}

func (s *InsertOrUpdateRegionRequest) SetMseInstanceId(v string) *InsertOrUpdateRegionRequest {
	s.MseInstanceId = &v
	return s
}

func (s *InsertOrUpdateRegionRequest) SetRegionName(v string) *InsertOrUpdateRegionRequest {
	s.RegionName = &v
	return s
}

func (s *InsertOrUpdateRegionRequest) SetRegionTag(v string) *InsertOrUpdateRegionRequest {
	s.RegionTag = &v
	return s
}

func (s *InsertOrUpdateRegionRequest) SetRegistryType(v string) *InsertOrUpdateRegionRequest {
	s.RegistryType = &v
	return s
}

type InsertOrUpdateRegionResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the custom namespace.
	UserDefineRegionEntity *InsertOrUpdateRegionResponseBodyUserDefineRegionEntity `json:"UserDefineRegionEntity,omitempty" xml:"UserDefineRegionEntity,omitempty" type:"Struct"`
}

func (s InsertOrUpdateRegionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s InsertOrUpdateRegionResponseBody) GoString() string {
	return s.String()
}

func (s *InsertOrUpdateRegionResponseBody) SetCode(v int32) *InsertOrUpdateRegionResponseBody {
	s.Code = &v
	return s
}

func (s *InsertOrUpdateRegionResponseBody) SetMessage(v string) *InsertOrUpdateRegionResponseBody {
	s.Message = &v
	return s
}

func (s *InsertOrUpdateRegionResponseBody) SetRequestId(v string) *InsertOrUpdateRegionResponseBody {
	s.RequestId = &v
	return s
}

func (s *InsertOrUpdateRegionResponseBody) SetUserDefineRegionEntity(v *InsertOrUpdateRegionResponseBodyUserDefineRegionEntity) *InsertOrUpdateRegionResponseBody {
	s.UserDefineRegionEntity = v
	return s
}

type InsertOrUpdateRegionResponseBodyUserDefineRegionEntity struct {
	// The ID of the region to which the namespace belongs.
	BelongRegion *string `json:"BelongRegion,omitempty" xml:"BelongRegion,omitempty"`
	// Indicates whether remote debugging is enabled. Valid values:
	//
	// *   true: Remote debugging is enabled.
	// *   false: Remote debugging is disabled.
	DebugEnable *bool `json:"DebugEnable,omitempty" xml:"DebugEnable,omitempty"`
	// The description of the namespace.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether the namespace is created or modified. If this parameter is left empty or 0 is returned, the namespace is created. Otherwise, the namespace is modified.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the namespace.
	//
	// *   The ID of a custom namespace is in the `region ID:namespace identifier` format. Example: cn-beijing:tdy218.
	// *   The ID of the default namespace is in the `region ID` format. Example: cn-beijing.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The name of the namespace.
	RegionName *string `json:"RegionName,omitempty" xml:"RegionName,omitempty"`
	// The ID of the Alibaba Cloud account to which the custom namespace belongs.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s InsertOrUpdateRegionResponseBodyUserDefineRegionEntity) String() string {
	return tea.Prettify(s)
}

func (s InsertOrUpdateRegionResponseBodyUserDefineRegionEntity) GoString() string {
	return s.String()
}

func (s *InsertOrUpdateRegionResponseBodyUserDefineRegionEntity) SetBelongRegion(v string) *InsertOrUpdateRegionResponseBodyUserDefineRegionEntity {
	s.BelongRegion = &v
	return s
}

func (s *InsertOrUpdateRegionResponseBodyUserDefineRegionEntity) SetDebugEnable(v bool) *InsertOrUpdateRegionResponseBodyUserDefineRegionEntity {
	s.DebugEnable = &v
	return s
}

func (s *InsertOrUpdateRegionResponseBodyUserDefineRegionEntity) SetDescription(v string) *InsertOrUpdateRegionResponseBodyUserDefineRegionEntity {
	s.Description = &v
	return s
}

func (s *InsertOrUpdateRegionResponseBodyUserDefineRegionEntity) SetId(v int64) *InsertOrUpdateRegionResponseBodyUserDefineRegionEntity {
	s.Id = &v
	return s
}

func (s *InsertOrUpdateRegionResponseBodyUserDefineRegionEntity) SetRegionId(v string) *InsertOrUpdateRegionResponseBodyUserDefineRegionEntity {
	s.RegionId = &v
	return s
}

func (s *InsertOrUpdateRegionResponseBodyUserDefineRegionEntity) SetRegionName(v string) *InsertOrUpdateRegionResponseBodyUserDefineRegionEntity {
	s.RegionName = &v
	return s
}

func (s *InsertOrUpdateRegionResponseBodyUserDefineRegionEntity) SetUserId(v string) *InsertOrUpdateRegionResponseBodyUserDefineRegionEntity {
	s.UserId = &v
	return s
}

type InsertOrUpdateRegionResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *InsertOrUpdateRegionResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s InsertOrUpdateRegionResponse) String() string {
	return tea.Prettify(s)
}

func (s InsertOrUpdateRegionResponse) GoString() string {
	return s.String()
}

func (s *InsertOrUpdateRegionResponse) SetHeaders(v map[string]*string) *InsertOrUpdateRegionResponse {
	s.Headers = v
	return s
}

func (s *InsertOrUpdateRegionResponse) SetStatusCode(v int32) *InsertOrUpdateRegionResponse {
	s.StatusCode = &v
	return s
}

func (s *InsertOrUpdateRegionResponse) SetBody(v *InsertOrUpdateRegionResponseBody) *InsertOrUpdateRegionResponse {
	s.Body = v
	return s
}

type InsertRoleRequest struct {
	// The set of permissions to be granted to the role. The value is in the format of `Permission group ID 1:Permission serial number 1;...;Permission group ID n:Permission serial number n`. Example: `1:1;1:2;2:1;2:2`. For more information about permission groups and permission serial numbers, see [ListAuthority](~~149409~~).
	ActionData *string `json:"ActionData,omitempty" xml:"ActionData,omitempty"`
	// The name of the role.
	RoleName *string `json:"RoleName,omitempty" xml:"RoleName,omitempty"`
}

func (s InsertRoleRequest) String() string {
	return tea.Prettify(s)
}

func (s InsertRoleRequest) GoString() string {
	return s.String()
}

func (s *InsertRoleRequest) SetActionData(v string) *InsertRoleRequest {
	s.ActionData = &v
	return s
}

func (s *InsertRoleRequest) SetRoleName(v string) *InsertRoleRequest {
	s.RoleName = &v
	return s
}

type InsertRoleResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the role.
	RoleId *int32 `json:"RoleId,omitempty" xml:"RoleId,omitempty"`
}

func (s InsertRoleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s InsertRoleResponseBody) GoString() string {
	return s.String()
}

func (s *InsertRoleResponseBody) SetCode(v int32) *InsertRoleResponseBody {
	s.Code = &v
	return s
}

func (s *InsertRoleResponseBody) SetMessage(v string) *InsertRoleResponseBody {
	s.Message = &v
	return s
}

func (s *InsertRoleResponseBody) SetRequestId(v string) *InsertRoleResponseBody {
	s.RequestId = &v
	return s
}

func (s *InsertRoleResponseBody) SetRoleId(v int32) *InsertRoleResponseBody {
	s.RoleId = &v
	return s
}

type InsertRoleResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *InsertRoleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s InsertRoleResponse) String() string {
	return tea.Prettify(s)
}

func (s InsertRoleResponse) GoString() string {
	return s.String()
}

func (s *InsertRoleResponse) SetHeaders(v map[string]*string) *InsertRoleResponse {
	s.Headers = v
	return s
}

func (s *InsertRoleResponse) SetStatusCode(v int32) *InsertRoleResponse {
	s.StatusCode = &v
	return s
}

func (s *InsertRoleResponse) SetBody(v *InsertRoleResponseBody) *InsertRoleResponse {
	s.Body = v
	return s
}

type InsertServiceGroupRequest struct {
	// The name of the service group that you want to create.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
}

func (s InsertServiceGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s InsertServiceGroupRequest) GoString() string {
	return s.String()
}

func (s *InsertServiceGroupRequest) SetGroupName(v string) *InsertServiceGroupRequest {
	s.GroupName = &v
	return s
}

type InsertServiceGroupResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s InsertServiceGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s InsertServiceGroupResponseBody) GoString() string {
	return s.String()
}

func (s *InsertServiceGroupResponseBody) SetCode(v int32) *InsertServiceGroupResponseBody {
	s.Code = &v
	return s
}

func (s *InsertServiceGroupResponseBody) SetMessage(v string) *InsertServiceGroupResponseBody {
	s.Message = &v
	return s
}

func (s *InsertServiceGroupResponseBody) SetRequestId(v string) *InsertServiceGroupResponseBody {
	s.RequestId = &v
	return s
}

type InsertServiceGroupResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *InsertServiceGroupResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s InsertServiceGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s InsertServiceGroupResponse) GoString() string {
	return s.String()
}

func (s *InsertServiceGroupResponse) SetHeaders(v map[string]*string) *InsertServiceGroupResponse {
	s.Headers = v
	return s
}

func (s *InsertServiceGroupResponse) SetStatusCode(v int32) *InsertServiceGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *InsertServiceGroupResponse) SetBody(v *InsertServiceGroupResponseBody) *InsertServiceGroupResponse {
	s.Body = v
	return s
}

type InsertSwimmingLaneRequest struct {
	// The information about applications related to the lane.
	AppInfos *string `json:"AppInfos,omitempty" xml:"AppInfos,omitempty"`
	// Specifies whether to enable the throttling rule.
	EnableRules *bool `json:"EnableRules,omitempty" xml:"EnableRules,omitempty"`
	// The throttling conditions.
	EntryRules *string `json:"EntryRules,omitempty" xml:"EntryRules,omitempty"`
	// The ID of the lane group.
	GroupId *int64 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The ID of the custom namespace. The ID is in the `physical region ID:custom namespace identifier` format. Example: `cn-hangzhou:test`.
	LogicalRegionId *string `json:"LogicalRegionId,omitempty" xml:"LogicalRegionId,omitempty"`
	// The name of the lane.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The tag.
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
}

func (s InsertSwimmingLaneRequest) String() string {
	return tea.Prettify(s)
}

func (s InsertSwimmingLaneRequest) GoString() string {
	return s.String()
}

func (s *InsertSwimmingLaneRequest) SetAppInfos(v string) *InsertSwimmingLaneRequest {
	s.AppInfos = &v
	return s
}

func (s *InsertSwimmingLaneRequest) SetEnableRules(v bool) *InsertSwimmingLaneRequest {
	s.EnableRules = &v
	return s
}

func (s *InsertSwimmingLaneRequest) SetEntryRules(v string) *InsertSwimmingLaneRequest {
	s.EntryRules = &v
	return s
}

func (s *InsertSwimmingLaneRequest) SetGroupId(v int64) *InsertSwimmingLaneRequest {
	s.GroupId = &v
	return s
}

func (s *InsertSwimmingLaneRequest) SetLogicalRegionId(v string) *InsertSwimmingLaneRequest {
	s.LogicalRegionId = &v
	return s
}

func (s *InsertSwimmingLaneRequest) SetName(v string) *InsertSwimmingLaneRequest {
	s.Name = &v
	return s
}

func (s *InsertSwimmingLaneRequest) SetTag(v string) *InsertSwimmingLaneRequest {
	s.Tag = &v
	return s
}

type InsertSwimmingLaneResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data that is returned.
	Data *InsertSwimmingLaneResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s InsertSwimmingLaneResponseBody) String() string {
	return tea.Prettify(s)
}

func (s InsertSwimmingLaneResponseBody) GoString() string {
	return s.String()
}

func (s *InsertSwimmingLaneResponseBody) SetCode(v int32) *InsertSwimmingLaneResponseBody {
	s.Code = &v
	return s
}

func (s *InsertSwimmingLaneResponseBody) SetData(v *InsertSwimmingLaneResponseBodyData) *InsertSwimmingLaneResponseBody {
	s.Data = v
	return s
}

func (s *InsertSwimmingLaneResponseBody) SetMessage(v string) *InsertSwimmingLaneResponseBody {
	s.Message = &v
	return s
}

func (s *InsertSwimmingLaneResponseBody) SetRequestId(v string) *InsertSwimmingLaneResponseBody {
	s.RequestId = &v
	return s
}

type InsertSwimmingLaneResponseBodyData struct {
	// The applications that are associated with lanes.
	AppInfos *string `json:"AppInfos,omitempty" xml:"AppInfos,omitempty"`
	// The throttling rule for the lane.
	//
	// priority: the priority of the throttling rule for the lane. Valid values: 1 to 100.
	//
	// path: the path that is matched by the throttling rule for the lane.
	//
	// restItems: conditions to be met.
	//
	// condition: the relationship among the conditions to be met.
	//
	// *   AND: all conditions
	// *   OR: one of the conditions
	//
	// restItems.type: the type of the rule. Valid values:
	//
	// *   header: matches by request header.
	// *   cookie: matches by request cookie.
	// *   param: matches by request parameters.
	//
	// restItems.name: the key that matches the rule.
	//
	// restItems.value: the value that matches the rule.
	//
	// restItems.cond: the condition that matches the rule. Valid values:
	//
	// *   "==": The parameter value is equal to the value that you enter in the Value field.
	// *   "!=": The parameter value is not equal to the value that you enter in the Value field.
	// *   ">": The parameter value is greater than the value that you enter in the Value field.
	// *   "<": The parameter value is less than the value that you enter in the Value field.
	// *   ">=": The parameter value is greater than or equal to the value that you enter in the Value field.
	// *   "<=": The parameter value is less than or equal to the value that you enter in the Value field.
	// *   "in": The parameter value is within the values that you enter in the Value field.
	//
	// restItems.operator: the type of the value. Valid values:
	//
	// *   rawvalue: the initial value
	// *   mod: the reminder obtained by performing modulo operation
	// *   list: the value from the list
	EntryRule *string `json:"EntryRule,omitempty" xml:"EntryRule,omitempty"`
	// The ID of the lane group.
	GroupId *int64 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The ID of the lane.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the lane.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The association relationships between lanes and applications.
	SwimmingLaneAppRelationShipList []*InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList `json:"SwimmingLaneAppRelationShipList,omitempty" xml:"SwimmingLaneAppRelationShipList,omitempty" type:"Repeated"`
	// The tag of the lane.
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
}

func (s InsertSwimmingLaneResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s InsertSwimmingLaneResponseBodyData) GoString() string {
	return s.String()
}

func (s *InsertSwimmingLaneResponseBodyData) SetAppInfos(v string) *InsertSwimmingLaneResponseBodyData {
	s.AppInfos = &v
	return s
}

func (s *InsertSwimmingLaneResponseBodyData) SetEntryRule(v string) *InsertSwimmingLaneResponseBodyData {
	s.EntryRule = &v
	return s
}

func (s *InsertSwimmingLaneResponseBodyData) SetGroupId(v int64) *InsertSwimmingLaneResponseBodyData {
	s.GroupId = &v
	return s
}

func (s *InsertSwimmingLaneResponseBodyData) SetId(v int64) *InsertSwimmingLaneResponseBodyData {
	s.Id = &v
	return s
}

func (s *InsertSwimmingLaneResponseBodyData) SetName(v string) *InsertSwimmingLaneResponseBodyData {
	s.Name = &v
	return s
}

func (s *InsertSwimmingLaneResponseBodyData) SetNamespaceId(v string) *InsertSwimmingLaneResponseBodyData {
	s.NamespaceId = &v
	return s
}

func (s *InsertSwimmingLaneResponseBodyData) SetSwimmingLaneAppRelationShipList(v []*InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList) *InsertSwimmingLaneResponseBodyData {
	s.SwimmingLaneAppRelationShipList = v
	return s
}

func (s *InsertSwimmingLaneResponseBodyData) SetTag(v string) *InsertSwimmingLaneResponseBodyData {
	s.Tag = &v
	return s
}

type InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The ID of the lane.
	LaneId *int64 `json:"LaneId,omitempty" xml:"LaneId,omitempty"`
	// The association rule.
	Rules *string `json:"Rules,omitempty" xml:"Rules,omitempty"`
}

func (s InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList) String() string {
	return tea.Prettify(s)
}

func (s InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList) GoString() string {
	return s.String()
}

func (s *InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList) SetAppId(v string) *InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList {
	s.AppId = &v
	return s
}

func (s *InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList) SetAppName(v string) *InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList {
	s.AppName = &v
	return s
}

func (s *InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList) SetLaneId(v int64) *InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList {
	s.LaneId = &v
	return s
}

func (s *InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList) SetRules(v string) *InsertSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList {
	s.Rules = &v
	return s
}

type InsertSwimmingLaneResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *InsertSwimmingLaneResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s InsertSwimmingLaneResponse) String() string {
	return tea.Prettify(s)
}

func (s InsertSwimmingLaneResponse) GoString() string {
	return s.String()
}

func (s *InsertSwimmingLaneResponse) SetHeaders(v map[string]*string) *InsertSwimmingLaneResponse {
	s.Headers = v
	return s
}

func (s *InsertSwimmingLaneResponse) SetStatusCode(v int32) *InsertSwimmingLaneResponse {
	s.StatusCode = &v
	return s
}

func (s *InsertSwimmingLaneResponse) SetBody(v *InsertSwimmingLaneResponseBody) *InsertSwimmingLaneResponse {
	s.Body = v
	return s
}

type InsertSwimmingLaneGroupRequest struct {
	// IDs of all applications that are related to the lane group. Separate multiple applications with commas (,).
	AppIds *string `json:"AppIds,omitempty" xml:"AppIds,omitempty"`
	// The ingress application. The application is in the EDAS:{application ID} format.
	EntryApp *string `json:"EntryApp,omitempty" xml:"EntryApp,omitempty"`
	// The ID of the custom namespace. The ID is in the physical region ID:custom namespace identifier format. Example: cn-hangzhou:test.
	LogicalRegionId *string `json:"LogicalRegionId,omitempty" xml:"LogicalRegionId,omitempty"`
	// The name of the lane group.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s InsertSwimmingLaneGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s InsertSwimmingLaneGroupRequest) GoString() string {
	return s.String()
}

func (s *InsertSwimmingLaneGroupRequest) SetAppIds(v string) *InsertSwimmingLaneGroupRequest {
	s.AppIds = &v
	return s
}

func (s *InsertSwimmingLaneGroupRequest) SetEntryApp(v string) *InsertSwimmingLaneGroupRequest {
	s.EntryApp = &v
	return s
}

func (s *InsertSwimmingLaneGroupRequest) SetLogicalRegionId(v string) *InsertSwimmingLaneGroupRequest {
	s.LogicalRegionId = &v
	return s
}

func (s *InsertSwimmingLaneGroupRequest) SetName(v string) *InsertSwimmingLaneGroupRequest {
	s.Name = &v
	return s
}

type InsertSwimmingLaneGroupResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data that is returned.
	Data *InsertSwimmingLaneGroupResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s InsertSwimmingLaneGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s InsertSwimmingLaneGroupResponseBody) GoString() string {
	return s.String()
}

func (s *InsertSwimmingLaneGroupResponseBody) SetCode(v int32) *InsertSwimmingLaneGroupResponseBody {
	s.Code = &v
	return s
}

func (s *InsertSwimmingLaneGroupResponseBody) SetData(v *InsertSwimmingLaneGroupResponseBodyData) *InsertSwimmingLaneGroupResponseBody {
	s.Data = v
	return s
}

func (s *InsertSwimmingLaneGroupResponseBody) SetMessage(v string) *InsertSwimmingLaneGroupResponseBody {
	s.Message = &v
	return s
}

func (s *InsertSwimmingLaneGroupResponseBody) SetRequestId(v string) *InsertSwimmingLaneGroupResponseBody {
	s.RequestId = &v
	return s
}

type InsertSwimmingLaneGroupResponseBodyData struct {
	// The list of all applications that are related to the lane group.
	ApplicationList *InsertSwimmingLaneGroupResponseBodyDataApplicationList `json:"ApplicationList,omitempty" xml:"ApplicationList,omitempty" type:"Struct"`
	// The information about the Enterprise Distributed Application Service (EDAS) ingress gateway.
	EntryApplication *InsertSwimmingLaneGroupResponseBodyDataEntryApplication `json:"EntryApplication,omitempty" xml:"EntryApplication,omitempty" type:"Struct"`
	// The ID of the lane group.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the lane group.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
}

func (s InsertSwimmingLaneGroupResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s InsertSwimmingLaneGroupResponseBodyData) GoString() string {
	return s.String()
}

func (s *InsertSwimmingLaneGroupResponseBodyData) SetApplicationList(v *InsertSwimmingLaneGroupResponseBodyDataApplicationList) *InsertSwimmingLaneGroupResponseBodyData {
	s.ApplicationList = v
	return s
}

func (s *InsertSwimmingLaneGroupResponseBodyData) SetEntryApplication(v *InsertSwimmingLaneGroupResponseBodyDataEntryApplication) *InsertSwimmingLaneGroupResponseBodyData {
	s.EntryApplication = v
	return s
}

func (s *InsertSwimmingLaneGroupResponseBodyData) SetId(v int64) *InsertSwimmingLaneGroupResponseBodyData {
	s.Id = &v
	return s
}

func (s *InsertSwimmingLaneGroupResponseBodyData) SetName(v string) *InsertSwimmingLaneGroupResponseBodyData {
	s.Name = &v
	return s
}

func (s *InsertSwimmingLaneGroupResponseBodyData) SetNamespaceId(v string) *InsertSwimmingLaneGroupResponseBodyData {
	s.NamespaceId = &v
	return s
}

type InsertSwimmingLaneGroupResponseBodyDataApplicationList struct {
	Application []*InsertSwimmingLaneGroupResponseBodyDataApplicationListApplication `json:"Application,omitempty" xml:"Application,omitempty" type:"Repeated"`
}

func (s InsertSwimmingLaneGroupResponseBodyDataApplicationList) String() string {
	return tea.Prettify(s)
}

func (s InsertSwimmingLaneGroupResponseBodyDataApplicationList) GoString() string {
	return s.String()
}

func (s *InsertSwimmingLaneGroupResponseBodyDataApplicationList) SetApplication(v []*InsertSwimmingLaneGroupResponseBodyDataApplicationListApplication) *InsertSwimmingLaneGroupResponseBodyDataApplicationList {
	s.Application = v
	return s
}

type InsertSwimmingLaneGroupResponseBodyDataApplicationListApplication struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
}

func (s InsertSwimmingLaneGroupResponseBodyDataApplicationListApplication) String() string {
	return tea.Prettify(s)
}

func (s InsertSwimmingLaneGroupResponseBodyDataApplicationListApplication) GoString() string {
	return s.String()
}

func (s *InsertSwimmingLaneGroupResponseBodyDataApplicationListApplication) SetAppId(v string) *InsertSwimmingLaneGroupResponseBodyDataApplicationListApplication {
	s.AppId = &v
	return s
}

func (s *InsertSwimmingLaneGroupResponseBodyDataApplicationListApplication) SetAppName(v string) *InsertSwimmingLaneGroupResponseBodyDataApplicationListApplication {
	s.AppName = &v
	return s
}

type InsertSwimmingLaneGroupResponseBodyDataEntryApplication struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
}

func (s InsertSwimmingLaneGroupResponseBodyDataEntryApplication) String() string {
	return tea.Prettify(s)
}

func (s InsertSwimmingLaneGroupResponseBodyDataEntryApplication) GoString() string {
	return s.String()
}

func (s *InsertSwimmingLaneGroupResponseBodyDataEntryApplication) SetAppId(v string) *InsertSwimmingLaneGroupResponseBodyDataEntryApplication {
	s.AppId = &v
	return s
}

func (s *InsertSwimmingLaneGroupResponseBodyDataEntryApplication) SetAppName(v string) *InsertSwimmingLaneGroupResponseBodyDataEntryApplication {
	s.AppName = &v
	return s
}

type InsertSwimmingLaneGroupResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *InsertSwimmingLaneGroupResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s InsertSwimmingLaneGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s InsertSwimmingLaneGroupResponse) GoString() string {
	return s.String()
}

func (s *InsertSwimmingLaneGroupResponse) SetHeaders(v map[string]*string) *InsertSwimmingLaneGroupResponse {
	s.Headers = v
	return s
}

func (s *InsertSwimmingLaneGroupResponse) SetStatusCode(v int32) *InsertSwimmingLaneGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *InsertSwimmingLaneGroupResponse) SetBody(v *InsertSwimmingLaneGroupResponseBody) *InsertSwimmingLaneGroupResponse {
	s.Body = v
	return s
}

type InstallAgentRequest struct {
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// This parameter is discontinued.
	DoAsync *bool `json:"DoAsync,omitempty" xml:"DoAsync,omitempty"`
	// The ID of the ECS instance. Separate multiple IDs with commas (,). Example: instanceId1,instanceId2.
	InstanceIds *string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty"`
}

func (s InstallAgentRequest) String() string {
	return tea.Prettify(s)
}

func (s InstallAgentRequest) GoString() string {
	return s.String()
}

func (s *InstallAgentRequest) SetClusterId(v string) *InstallAgentRequest {
	s.ClusterId = &v
	return s
}

func (s *InstallAgentRequest) SetDoAsync(v bool) *InstallAgentRequest {
	s.DoAsync = &v
	return s
}

func (s *InstallAgentRequest) SetInstanceIds(v string) *InstallAgentRequest {
	s.InstanceIds = &v
	return s
}

type InstallAgentResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The execution result.
	ExecutionResultList *InstallAgentResponseBodyExecutionResultList `json:"ExecutionResultList,omitempty" xml:"ExecutionResultList,omitempty" type:"Struct"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s InstallAgentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s InstallAgentResponseBody) GoString() string {
	return s.String()
}

func (s *InstallAgentResponseBody) SetCode(v int32) *InstallAgentResponseBody {
	s.Code = &v
	return s
}

func (s *InstallAgentResponseBody) SetExecutionResultList(v *InstallAgentResponseBodyExecutionResultList) *InstallAgentResponseBody {
	s.ExecutionResultList = v
	return s
}

func (s *InstallAgentResponseBody) SetMessage(v string) *InstallAgentResponseBody {
	s.Message = &v
	return s
}

func (s *InstallAgentResponseBody) SetRequestId(v string) *InstallAgentResponseBody {
	s.RequestId = &v
	return s
}

type InstallAgentResponseBodyExecutionResultList struct {
	ExecutionResult []*InstallAgentResponseBodyExecutionResultListExecutionResult `json:"ExecutionResult,omitempty" xml:"ExecutionResult,omitempty" type:"Repeated"`
}

func (s InstallAgentResponseBodyExecutionResultList) String() string {
	return tea.Prettify(s)
}

func (s InstallAgentResponseBodyExecutionResultList) GoString() string {
	return s.String()
}

func (s *InstallAgentResponseBodyExecutionResultList) SetExecutionResult(v []*InstallAgentResponseBodyExecutionResultListExecutionResult) *InstallAgentResponseBodyExecutionResultList {
	s.ExecutionResult = v
	return s
}

type InstallAgentResponseBodyExecutionResultListExecutionResult struct {
	// The time when the installation was complete.
	FinishedTime *string `json:"FinishedTime,omitempty" xml:"FinishedTime,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The state of the installation.
	InvokeRecordStatus *string `json:"InvokeRecordStatus,omitempty" xml:"InvokeRecordStatus,omitempty"`
	// The state of the installation command.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// Indicates whether the installation was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s InstallAgentResponseBodyExecutionResultListExecutionResult) String() string {
	return tea.Prettify(s)
}

func (s InstallAgentResponseBodyExecutionResultListExecutionResult) GoString() string {
	return s.String()
}

func (s *InstallAgentResponseBodyExecutionResultListExecutionResult) SetFinishedTime(v string) *InstallAgentResponseBodyExecutionResultListExecutionResult {
	s.FinishedTime = &v
	return s
}

func (s *InstallAgentResponseBodyExecutionResultListExecutionResult) SetInstanceId(v string) *InstallAgentResponseBodyExecutionResultListExecutionResult {
	s.InstanceId = &v
	return s
}

func (s *InstallAgentResponseBodyExecutionResultListExecutionResult) SetInvokeRecordStatus(v string) *InstallAgentResponseBodyExecutionResultListExecutionResult {
	s.InvokeRecordStatus = &v
	return s
}

func (s *InstallAgentResponseBodyExecutionResultListExecutionResult) SetStatus(v string) *InstallAgentResponseBodyExecutionResultListExecutionResult {
	s.Status = &v
	return s
}

func (s *InstallAgentResponseBodyExecutionResultListExecutionResult) SetSuccess(v bool) *InstallAgentResponseBodyExecutionResultListExecutionResult {
	s.Success = &v
	return s
}

type InstallAgentResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *InstallAgentResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s InstallAgentResponse) String() string {
	return tea.Prettify(s)
}

func (s InstallAgentResponse) GoString() string {
	return s.String()
}

func (s *InstallAgentResponse) SetHeaders(v map[string]*string) *InstallAgentResponse {
	s.Headers = v
	return s
}

func (s *InstallAgentResponse) SetStatusCode(v int32) *InstallAgentResponse {
	s.StatusCode = &v
	return s
}

func (s *InstallAgentResponse) SetBody(v *InstallAgentResponseBody) *InstallAgentResponse {
	s.Body = v
	return s
}

type ListAliyunRegionResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The details of the regions.
	RegionEntityList *ListAliyunRegionResponseBodyRegionEntityList `json:"RegionEntityList,omitempty" xml:"RegionEntityList,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListAliyunRegionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAliyunRegionResponseBody) GoString() string {
	return s.String()
}

func (s *ListAliyunRegionResponseBody) SetCode(v int32) *ListAliyunRegionResponseBody {
	s.Code = &v
	return s
}

func (s *ListAliyunRegionResponseBody) SetMessage(v string) *ListAliyunRegionResponseBody {
	s.Message = &v
	return s
}

func (s *ListAliyunRegionResponseBody) SetRegionEntityList(v *ListAliyunRegionResponseBodyRegionEntityList) *ListAliyunRegionResponseBody {
	s.RegionEntityList = v
	return s
}

func (s *ListAliyunRegionResponseBody) SetRequestId(v string) *ListAliyunRegionResponseBody {
	s.RequestId = &v
	return s
}

type ListAliyunRegionResponseBodyRegionEntityList struct {
	RegionEntity []*ListAliyunRegionResponseBodyRegionEntityListRegionEntity `json:"RegionEntity,omitempty" xml:"RegionEntity,omitempty" type:"Repeated"`
}

func (s ListAliyunRegionResponseBodyRegionEntityList) String() string {
	return tea.Prettify(s)
}

func (s ListAliyunRegionResponseBodyRegionEntityList) GoString() string {
	return s.String()
}

func (s *ListAliyunRegionResponseBodyRegionEntityList) SetRegionEntity(v []*ListAliyunRegionResponseBodyRegionEntityListRegionEntity) *ListAliyunRegionResponseBodyRegionEntityList {
	s.RegionEntity = v
	return s
}

type ListAliyunRegionResponseBodyRegionEntityListRegionEntity struct {
	// The ID of the region.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the region.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s ListAliyunRegionResponseBodyRegionEntityListRegionEntity) String() string {
	return tea.Prettify(s)
}

func (s ListAliyunRegionResponseBodyRegionEntityListRegionEntity) GoString() string {
	return s.String()
}

func (s *ListAliyunRegionResponseBodyRegionEntityListRegionEntity) SetId(v string) *ListAliyunRegionResponseBodyRegionEntityListRegionEntity {
	s.Id = &v
	return s
}

func (s *ListAliyunRegionResponseBodyRegionEntityListRegionEntity) SetName(v string) *ListAliyunRegionResponseBodyRegionEntityListRegionEntity {
	s.Name = &v
	return s
}

type ListAliyunRegionResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListAliyunRegionResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListAliyunRegionResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAliyunRegionResponse) GoString() string {
	return s.String()
}

func (s *ListAliyunRegionResponse) SetHeaders(v map[string]*string) *ListAliyunRegionResponse {
	s.Headers = v
	return s
}

func (s *ListAliyunRegionResponse) SetStatusCode(v int32) *ListAliyunRegionResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAliyunRegionResponse) SetBody(v *ListAliyunRegionResponseBody) *ListAliyunRegionResponse {
	s.Body = v
	return s
}

type ListApplicationRequest struct {
	// The application IDs.
	AppIds *string `json:"AppIds,omitempty" xml:"AppIds,omitempty"`
	// The name of the application. Specify this parameter if you want to filter applications by application name.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The cluster ID. Specify this parameter if you want to filter applications by cluster.
	ClusterId   *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	CurrentPage *int32  `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The namespace ID. Specify this parameter if you want to filter applications by namespace.
	LogicalRegionId *string `json:"LogicalRegionId,omitempty" xml:"LogicalRegionId,omitempty"`
	// The ID of the namespace that you use in the exact search to filter applications.
	LogicalRegionIdFilter *string `json:"LogicalRegionIdFilter,omitempty" xml:"LogicalRegionIdFilter,omitempty"`
	PageSize              *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the resource group. Specify this parameter if you want to filter applications by resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s ListApplicationRequest) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationRequest) GoString() string {
	return s.String()
}

func (s *ListApplicationRequest) SetAppIds(v string) *ListApplicationRequest {
	s.AppIds = &v
	return s
}

func (s *ListApplicationRequest) SetAppName(v string) *ListApplicationRequest {
	s.AppName = &v
	return s
}

func (s *ListApplicationRequest) SetClusterId(v string) *ListApplicationRequest {
	s.ClusterId = &v
	return s
}

func (s *ListApplicationRequest) SetCurrentPage(v int32) *ListApplicationRequest {
	s.CurrentPage = &v
	return s
}

func (s *ListApplicationRequest) SetLogicalRegionId(v string) *ListApplicationRequest {
	s.LogicalRegionId = &v
	return s
}

func (s *ListApplicationRequest) SetLogicalRegionIdFilter(v string) *ListApplicationRequest {
	s.LogicalRegionIdFilter = &v
	return s
}

func (s *ListApplicationRequest) SetPageSize(v int32) *ListApplicationRequest {
	s.PageSize = &v
	return s
}

func (s *ListApplicationRequest) SetResourceGroupId(v string) *ListApplicationRequest {
	s.ResourceGroupId = &v
	return s
}

type ListApplicationResponseBody struct {
	// The information about applications.
	ApplicationList *ListApplicationResponseBodyApplicationList `json:"ApplicationList,omitempty" xml:"ApplicationList,omitempty" type:"Struct"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListApplicationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationResponseBody) GoString() string {
	return s.String()
}

func (s *ListApplicationResponseBody) SetApplicationList(v *ListApplicationResponseBodyApplicationList) *ListApplicationResponseBody {
	s.ApplicationList = v
	return s
}

func (s *ListApplicationResponseBody) SetCode(v int32) *ListApplicationResponseBody {
	s.Code = &v
	return s
}

func (s *ListApplicationResponseBody) SetMessage(v string) *ListApplicationResponseBody {
	s.Message = &v
	return s
}

func (s *ListApplicationResponseBody) SetRequestId(v string) *ListApplicationResponseBody {
	s.RequestId = &v
	return s
}

type ListApplicationResponseBodyApplicationList struct {
	Application []*ListApplicationResponseBodyApplicationListApplication `json:"Application,omitempty" xml:"Application,omitempty" type:"Repeated"`
}

func (s ListApplicationResponseBodyApplicationList) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationResponseBodyApplicationList) GoString() string {
	return s.String()
}

func (s *ListApplicationResponseBodyApplicationList) SetApplication(v []*ListApplicationResponseBodyApplicationListApplication) *ListApplicationResponseBodyApplicationList {
	s.Application = v
	return s
}

type ListApplicationResponseBodyApplicationListApplication struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The deployment type of the application. Valid values:
	//
	// *   War: The application is deployed by using a WAR package.
	// *   FatJar: The application is deployed by using a JAR package.
	// *   Image: The application is deployed by using an image.
	// *   If this parameter is empty, the application is not deployed.
	ApplicationType *string `json:"ApplicationType,omitempty" xml:"ApplicationType,omitempty"`
	// The build package number of Enterprise Distributed Application Service (EDAS) Container.
	BuildPackageId *int64 `json:"BuildPackageId,omitempty" xml:"BuildPackageId,omitempty"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The type of the cluster in which the application is deployed. Valid values:
	//
	// *   **2**: Elastic Compute Service (ECS) cluster
	// *   **3**: self-managed Kubernetes cluster in EDAS
	// *   **5**: Container Service for Kubernetes (ACK) cluster
	ClusterType *int32 `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The time when the application was created.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The IP address of the Internet-facing SLB instance.
	ExtSlbIp *string `json:"ExtSlbIp,omitempty" xml:"ExtSlbIp,omitempty"`
	// The listener port of the Internet-facing SLB instance.
	ExtSlbListenerPort *int32 `json:"ExtSlbListenerPort,omitempty" xml:"ExtSlbListenerPort,omitempty"`
	// The number of application instances.
	Instances *int32 `json:"Instances,omitempty" xml:"Instances,omitempty"`
	// The namespace of the Kubernetes cluster.
	K8sNamespace *string `json:"K8sNamespace,omitempty" xml:"K8sNamespace,omitempty"`
	// The name of the application.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the microservices namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The service port of the application.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The region ID of the application.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The number of running application instances.
	RunningInstanceCount *int32 `json:"RunningInstanceCount,omitempty" xml:"RunningInstanceCount,omitempty"`
	// The IP address of the internal-facing Server Load Balancer (SLB) instance.
	SlbIp *string `json:"SlbIp,omitempty" xml:"SlbIp,omitempty"`
	// The listener port of the internal-facing SLB instance.
	SlbListenerPort *int32 `json:"SlbListenerPort,omitempty" xml:"SlbListenerPort,omitempty"`
	// The port of the internal-facing SLB instance.
	SlbPort *int32 `json:"SlbPort,omitempty" xml:"SlbPort,omitempty"`
	// The state of the application. Valid values:
	//
	// *   RUNNING: The application is running.
	// *   STOPPED: The application is stopped.
	// *   DEPLOYING: The application is being deployed.
	// *   DELETING: The application is being deleted.
	State *string `json:"State,omitempty" xml:"State,omitempty"`
}

func (s ListApplicationResponseBodyApplicationListApplication) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationResponseBodyApplicationListApplication) GoString() string {
	return s.String()
}

func (s *ListApplicationResponseBodyApplicationListApplication) SetAppId(v string) *ListApplicationResponseBodyApplicationListApplication {
	s.AppId = &v
	return s
}

func (s *ListApplicationResponseBodyApplicationListApplication) SetApplicationType(v string) *ListApplicationResponseBodyApplicationListApplication {
	s.ApplicationType = &v
	return s
}

func (s *ListApplicationResponseBodyApplicationListApplication) SetBuildPackageId(v int64) *ListApplicationResponseBodyApplicationListApplication {
	s.BuildPackageId = &v
	return s
}

func (s *ListApplicationResponseBodyApplicationListApplication) SetClusterId(v string) *ListApplicationResponseBodyApplicationListApplication {
	s.ClusterId = &v
	return s
}

func (s *ListApplicationResponseBodyApplicationListApplication) SetClusterType(v int32) *ListApplicationResponseBodyApplicationListApplication {
	s.ClusterType = &v
	return s
}

func (s *ListApplicationResponseBodyApplicationListApplication) SetCreateTime(v int64) *ListApplicationResponseBodyApplicationListApplication {
	s.CreateTime = &v
	return s
}

func (s *ListApplicationResponseBodyApplicationListApplication) SetExtSlbIp(v string) *ListApplicationResponseBodyApplicationListApplication {
	s.ExtSlbIp = &v
	return s
}

func (s *ListApplicationResponseBodyApplicationListApplication) SetExtSlbListenerPort(v int32) *ListApplicationResponseBodyApplicationListApplication {
	s.ExtSlbListenerPort = &v
	return s
}

func (s *ListApplicationResponseBodyApplicationListApplication) SetInstances(v int32) *ListApplicationResponseBodyApplicationListApplication {
	s.Instances = &v
	return s
}

func (s *ListApplicationResponseBodyApplicationListApplication) SetK8sNamespace(v string) *ListApplicationResponseBodyApplicationListApplication {
	s.K8sNamespace = &v
	return s
}

func (s *ListApplicationResponseBodyApplicationListApplication) SetName(v string) *ListApplicationResponseBodyApplicationListApplication {
	s.Name = &v
	return s
}

func (s *ListApplicationResponseBodyApplicationListApplication) SetNamespaceId(v string) *ListApplicationResponseBodyApplicationListApplication {
	s.NamespaceId = &v
	return s
}

func (s *ListApplicationResponseBodyApplicationListApplication) SetPort(v int32) *ListApplicationResponseBodyApplicationListApplication {
	s.Port = &v
	return s
}

func (s *ListApplicationResponseBodyApplicationListApplication) SetRegionId(v string) *ListApplicationResponseBodyApplicationListApplication {
	s.RegionId = &v
	return s
}

func (s *ListApplicationResponseBodyApplicationListApplication) SetResourceGroupId(v string) *ListApplicationResponseBodyApplicationListApplication {
	s.ResourceGroupId = &v
	return s
}

func (s *ListApplicationResponseBodyApplicationListApplication) SetRunningInstanceCount(v int32) *ListApplicationResponseBodyApplicationListApplication {
	s.RunningInstanceCount = &v
	return s
}

func (s *ListApplicationResponseBodyApplicationListApplication) SetSlbIp(v string) *ListApplicationResponseBodyApplicationListApplication {
	s.SlbIp = &v
	return s
}

func (s *ListApplicationResponseBodyApplicationListApplication) SetSlbListenerPort(v int32) *ListApplicationResponseBodyApplicationListApplication {
	s.SlbListenerPort = &v
	return s
}

func (s *ListApplicationResponseBodyApplicationListApplication) SetSlbPort(v int32) *ListApplicationResponseBodyApplicationListApplication {
	s.SlbPort = &v
	return s
}

func (s *ListApplicationResponseBodyApplicationListApplication) SetState(v string) *ListApplicationResponseBodyApplicationListApplication {
	s.State = &v
	return s
}

type ListApplicationResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListApplicationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListApplicationResponse) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationResponse) GoString() string {
	return s.String()
}

func (s *ListApplicationResponse) SetHeaders(v map[string]*string) *ListApplicationResponse {
	s.Headers = v
	return s
}

func (s *ListApplicationResponse) SetStatusCode(v int32) *ListApplicationResponse {
	s.StatusCode = &v
	return s
}

func (s *ListApplicationResponse) SetBody(v *ListApplicationResponseBody) *ListApplicationResponse {
	s.Body = v
	return s
}

type ListApplicationEcuRequest struct {
	// The ID of the application whose ECUs you want to query. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the microservices namespace.
	LogicalRegionId *string `json:"LogicalRegionId,omitempty" xml:"LogicalRegionId,omitempty"`
}

func (s ListApplicationEcuRequest) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationEcuRequest) GoString() string {
	return s.String()
}

func (s *ListApplicationEcuRequest) SetAppId(v string) *ListApplicationEcuRequest {
	s.AppId = &v
	return s
}

func (s *ListApplicationEcuRequest) SetLogicalRegionId(v string) *ListApplicationEcuRequest {
	s.LogicalRegionId = &v
	return s
}

type ListApplicationEcuResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The information about ECUs.
	EcuInfoList *ListApplicationEcuResponseBodyEcuInfoList `json:"EcuInfoList,omitempty" xml:"EcuInfoList,omitempty" type:"Struct"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListApplicationEcuResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationEcuResponseBody) GoString() string {
	return s.String()
}

func (s *ListApplicationEcuResponseBody) SetCode(v int32) *ListApplicationEcuResponseBody {
	s.Code = &v
	return s
}

func (s *ListApplicationEcuResponseBody) SetEcuInfoList(v *ListApplicationEcuResponseBodyEcuInfoList) *ListApplicationEcuResponseBody {
	s.EcuInfoList = v
	return s
}

func (s *ListApplicationEcuResponseBody) SetMessage(v string) *ListApplicationEcuResponseBody {
	s.Message = &v
	return s
}

func (s *ListApplicationEcuResponseBody) SetRequestId(v string) *ListApplicationEcuResponseBody {
	s.RequestId = &v
	return s
}

type ListApplicationEcuResponseBodyEcuInfoList struct {
	EcuEntity []*ListApplicationEcuResponseBodyEcuInfoListEcuEntity `json:"EcuEntity,omitempty" xml:"EcuEntity,omitempty" type:"Repeated"`
}

func (s ListApplicationEcuResponseBodyEcuInfoList) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationEcuResponseBodyEcuInfoList) GoString() string {
	return s.String()
}

func (s *ListApplicationEcuResponseBodyEcuInfoList) SetEcuEntity(v []*ListApplicationEcuResponseBodyEcuInfoListEcuEntity) *ListApplicationEcuResponseBodyEcuInfoList {
	s.EcuEntity = v
	return s
}

type ListApplicationEcuResponseBodyEcuInfoListEcuEntity struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The number of available CPU cores.
	AvailableCpu *int32 `json:"AvailableCpu,omitempty" xml:"AvailableCpu,omitempty"`
	// The size of available memory. Unit: MB.
	AvailableMem *int32 `json:"AvailableMem,omitempty" xml:"AvailableMem,omitempty"`
	// The total number of CPU cores.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The time when the ECU was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// Indicates whether Docker is installed. Valid values:
	//
	// *   true: Docker is installed.
	// *   false: Docker is not installed.
	DockerEnv *bool `json:"DockerEnv,omitempty" xml:"DockerEnv,omitempty"`
	// The unique ID of the ECU. To query the ID, you can run the `dmidecode` command on the ECS instance that corresponds to the ECU.
	EcuId *string `json:"EcuId,omitempty" xml:"EcuId,omitempty"`
	// The time when the last heartbeat detection was performed. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	HeartbeatTime *int64 `json:"HeartbeatTime,omitempty" xml:"HeartbeatTime,omitempty"`
	// The ID of the Elastic Compute Service (ECS) instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The internal IP address allocated to the ECU.
	IpAddr *string `json:"IpAddr,omitempty" xml:"IpAddr,omitempty"`
	// The total size of memory. Unit: MB.
	Mem *int32 `json:"Mem,omitempty" xml:"Mem,omitempty"`
	// The name of the ECU.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Indicates whether the ECU is online. Valid values:
	//
	// *   true: The ECU is online.
	// *   false: The ECU is offline.
	Online *bool `json:"Online,omitempty" xml:"Online,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The time when the ECU was updated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The ID of the Alibaba Cloud account to which the ECU belongs.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The ID of the virtual private cloud (VPC).
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The ID of the zone.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s ListApplicationEcuResponseBodyEcuInfoListEcuEntity) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationEcuResponseBodyEcuInfoListEcuEntity) GoString() string {
	return s.String()
}

func (s *ListApplicationEcuResponseBodyEcuInfoListEcuEntity) SetAppId(v string) *ListApplicationEcuResponseBodyEcuInfoListEcuEntity {
	s.AppId = &v
	return s
}

func (s *ListApplicationEcuResponseBodyEcuInfoListEcuEntity) SetAvailableCpu(v int32) *ListApplicationEcuResponseBodyEcuInfoListEcuEntity {
	s.AvailableCpu = &v
	return s
}

func (s *ListApplicationEcuResponseBodyEcuInfoListEcuEntity) SetAvailableMem(v int32) *ListApplicationEcuResponseBodyEcuInfoListEcuEntity {
	s.AvailableMem = &v
	return s
}

func (s *ListApplicationEcuResponseBodyEcuInfoListEcuEntity) SetCpu(v int32) *ListApplicationEcuResponseBodyEcuInfoListEcuEntity {
	s.Cpu = &v
	return s
}

func (s *ListApplicationEcuResponseBodyEcuInfoListEcuEntity) SetCreateTime(v int64) *ListApplicationEcuResponseBodyEcuInfoListEcuEntity {
	s.CreateTime = &v
	return s
}

func (s *ListApplicationEcuResponseBodyEcuInfoListEcuEntity) SetDockerEnv(v bool) *ListApplicationEcuResponseBodyEcuInfoListEcuEntity {
	s.DockerEnv = &v
	return s
}

func (s *ListApplicationEcuResponseBodyEcuInfoListEcuEntity) SetEcuId(v string) *ListApplicationEcuResponseBodyEcuInfoListEcuEntity {
	s.EcuId = &v
	return s
}

func (s *ListApplicationEcuResponseBodyEcuInfoListEcuEntity) SetHeartbeatTime(v int64) *ListApplicationEcuResponseBodyEcuInfoListEcuEntity {
	s.HeartbeatTime = &v
	return s
}

func (s *ListApplicationEcuResponseBodyEcuInfoListEcuEntity) SetInstanceId(v string) *ListApplicationEcuResponseBodyEcuInfoListEcuEntity {
	s.InstanceId = &v
	return s
}

func (s *ListApplicationEcuResponseBodyEcuInfoListEcuEntity) SetIpAddr(v string) *ListApplicationEcuResponseBodyEcuInfoListEcuEntity {
	s.IpAddr = &v
	return s
}

func (s *ListApplicationEcuResponseBodyEcuInfoListEcuEntity) SetMem(v int32) *ListApplicationEcuResponseBodyEcuInfoListEcuEntity {
	s.Mem = &v
	return s
}

func (s *ListApplicationEcuResponseBodyEcuInfoListEcuEntity) SetName(v string) *ListApplicationEcuResponseBodyEcuInfoListEcuEntity {
	s.Name = &v
	return s
}

func (s *ListApplicationEcuResponseBodyEcuInfoListEcuEntity) SetOnline(v bool) *ListApplicationEcuResponseBodyEcuInfoListEcuEntity {
	s.Online = &v
	return s
}

func (s *ListApplicationEcuResponseBodyEcuInfoListEcuEntity) SetRegionId(v string) *ListApplicationEcuResponseBodyEcuInfoListEcuEntity {
	s.RegionId = &v
	return s
}

func (s *ListApplicationEcuResponseBodyEcuInfoListEcuEntity) SetUpdateTime(v int64) *ListApplicationEcuResponseBodyEcuInfoListEcuEntity {
	s.UpdateTime = &v
	return s
}

func (s *ListApplicationEcuResponseBodyEcuInfoListEcuEntity) SetUserId(v string) *ListApplicationEcuResponseBodyEcuInfoListEcuEntity {
	s.UserId = &v
	return s
}

func (s *ListApplicationEcuResponseBodyEcuInfoListEcuEntity) SetVpcId(v string) *ListApplicationEcuResponseBodyEcuInfoListEcuEntity {
	s.VpcId = &v
	return s
}

func (s *ListApplicationEcuResponseBodyEcuInfoListEcuEntity) SetZoneId(v string) *ListApplicationEcuResponseBodyEcuInfoListEcuEntity {
	s.ZoneId = &v
	return s
}

type ListApplicationEcuResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListApplicationEcuResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListApplicationEcuResponse) String() string {
	return tea.Prettify(s)
}

func (s ListApplicationEcuResponse) GoString() string {
	return s.String()
}

func (s *ListApplicationEcuResponse) SetHeaders(v map[string]*string) *ListApplicationEcuResponse {
	s.Headers = v
	return s
}

func (s *ListApplicationEcuResponse) SetStatusCode(v int32) *ListApplicationEcuResponse {
	s.StatusCode = &v
	return s
}

func (s *ListApplicationEcuResponse) SetBody(v *ListApplicationEcuResponseBody) *ListApplicationEcuResponse {
	s.Body = v
	return s
}

type ListAuthorityResponseBody struct {
	// The permissions.
	AuthorityList *ListAuthorityResponseBodyAuthorityList `json:"AuthorityList,omitempty" xml:"AuthorityList,omitempty" type:"Struct"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListAuthorityResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAuthorityResponseBody) GoString() string {
	return s.String()
}

func (s *ListAuthorityResponseBody) SetAuthorityList(v *ListAuthorityResponseBodyAuthorityList) *ListAuthorityResponseBody {
	s.AuthorityList = v
	return s
}

func (s *ListAuthorityResponseBody) SetCode(v int32) *ListAuthorityResponseBody {
	s.Code = &v
	return s
}

func (s *ListAuthorityResponseBody) SetMessage(v string) *ListAuthorityResponseBody {
	s.Message = &v
	return s
}

func (s *ListAuthorityResponseBody) SetRequestId(v string) *ListAuthorityResponseBody {
	s.RequestId = &v
	return s
}

type ListAuthorityResponseBodyAuthorityList struct {
	Authority []*ListAuthorityResponseBodyAuthorityListAuthority `json:"Authority,omitempty" xml:"Authority,omitempty" type:"Repeated"`
}

func (s ListAuthorityResponseBodyAuthorityList) String() string {
	return tea.Prettify(s)
}

func (s ListAuthorityResponseBodyAuthorityList) GoString() string {
	return s.String()
}

func (s *ListAuthorityResponseBodyAuthorityList) SetAuthority(v []*ListAuthorityResponseBodyAuthorityListAuthority) *ListAuthorityResponseBodyAuthorityList {
	s.Authority = v
	return s
}

type ListAuthorityResponseBodyAuthorityListAuthority struct {
	// The set of permissions.
	ActionList *ListAuthorityResponseBodyAuthorityListAuthorityActionList `json:"ActionList,omitempty" xml:"ActionList,omitempty" type:"Struct"`
	// The description of the permission group.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the permission group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the permission group.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s ListAuthorityResponseBodyAuthorityListAuthority) String() string {
	return tea.Prettify(s)
}

func (s ListAuthorityResponseBodyAuthorityListAuthority) GoString() string {
	return s.String()
}

func (s *ListAuthorityResponseBodyAuthorityListAuthority) SetActionList(v *ListAuthorityResponseBodyAuthorityListAuthorityActionList) *ListAuthorityResponseBodyAuthorityListAuthority {
	s.ActionList = v
	return s
}

func (s *ListAuthorityResponseBodyAuthorityListAuthority) SetDescription(v string) *ListAuthorityResponseBodyAuthorityListAuthority {
	s.Description = &v
	return s
}

func (s *ListAuthorityResponseBodyAuthorityListAuthority) SetGroupId(v string) *ListAuthorityResponseBodyAuthorityListAuthority {
	s.GroupId = &v
	return s
}

func (s *ListAuthorityResponseBodyAuthorityListAuthority) SetName(v string) *ListAuthorityResponseBodyAuthorityListAuthority {
	s.Name = &v
	return s
}

type ListAuthorityResponseBodyAuthorityListAuthorityActionList struct {
	Action []*ListAuthorityResponseBodyAuthorityListAuthorityActionListAction `json:"Action,omitempty" xml:"Action,omitempty" type:"Repeated"`
}

func (s ListAuthorityResponseBodyAuthorityListAuthorityActionList) String() string {
	return tea.Prettify(s)
}

func (s ListAuthorityResponseBodyAuthorityListAuthorityActionList) GoString() string {
	return s.String()
}

func (s *ListAuthorityResponseBodyAuthorityListAuthorityActionList) SetAction(v []*ListAuthorityResponseBodyAuthorityListAuthorityActionListAction) *ListAuthorityResponseBodyAuthorityListAuthorityActionList {
	s.Action = v
	return s
}

type ListAuthorityResponseBodyAuthorityListAuthorityActionListAction struct {
	// The code of the permission.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The description of the permission.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the permission group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the permission.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s ListAuthorityResponseBodyAuthorityListAuthorityActionListAction) String() string {
	return tea.Prettify(s)
}

func (s ListAuthorityResponseBodyAuthorityListAuthorityActionListAction) GoString() string {
	return s.String()
}

func (s *ListAuthorityResponseBodyAuthorityListAuthorityActionListAction) SetCode(v string) *ListAuthorityResponseBodyAuthorityListAuthorityActionListAction {
	s.Code = &v
	return s
}

func (s *ListAuthorityResponseBodyAuthorityListAuthorityActionListAction) SetDescription(v string) *ListAuthorityResponseBodyAuthorityListAuthorityActionListAction {
	s.Description = &v
	return s
}

func (s *ListAuthorityResponseBodyAuthorityListAuthorityActionListAction) SetGroupId(v string) *ListAuthorityResponseBodyAuthorityListAuthorityActionListAction {
	s.GroupId = &v
	return s
}

func (s *ListAuthorityResponseBodyAuthorityListAuthorityActionListAction) SetName(v string) *ListAuthorityResponseBodyAuthorityListAuthorityActionListAction {
	s.Name = &v
	return s
}

type ListAuthorityResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListAuthorityResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListAuthorityResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAuthorityResponse) GoString() string {
	return s.String()
}

func (s *ListAuthorityResponse) SetHeaders(v map[string]*string) *ListAuthorityResponse {
	s.Headers = v
	return s
}

func (s *ListAuthorityResponse) SetStatusCode(v int32) *ListAuthorityResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAuthorityResponse) SetBody(v *ListAuthorityResponseBody) *ListAuthorityResponse {
	s.Body = v
	return s
}

type ListBuildPackResponseBody struct {
	// The returned versions of EDAS Container.
	BuildPackList *ListBuildPackResponseBodyBuildPackList `json:"BuildPackList,omitempty" xml:"BuildPackList,omitempty" type:"Struct"`
	// code
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListBuildPackResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListBuildPackResponseBody) GoString() string {
	return s.String()
}

func (s *ListBuildPackResponseBody) SetBuildPackList(v *ListBuildPackResponseBodyBuildPackList) *ListBuildPackResponseBody {
	s.BuildPackList = v
	return s
}

func (s *ListBuildPackResponseBody) SetCode(v int32) *ListBuildPackResponseBody {
	s.Code = &v
	return s
}

func (s *ListBuildPackResponseBody) SetMessage(v string) *ListBuildPackResponseBody {
	s.Message = &v
	return s
}

func (s *ListBuildPackResponseBody) SetRequestId(v string) *ListBuildPackResponseBody {
	s.RequestId = &v
	return s
}

type ListBuildPackResponseBodyBuildPackList struct {
	BuildPack []*ListBuildPackResponseBodyBuildPackListBuildPack `json:"BuildPack,omitempty" xml:"BuildPack,omitempty" type:"Repeated"`
}

func (s ListBuildPackResponseBodyBuildPackList) String() string {
	return tea.Prettify(s)
}

func (s ListBuildPackResponseBodyBuildPackList) GoString() string {
	return s.String()
}

func (s *ListBuildPackResponseBodyBuildPackList) SetBuildPack(v []*ListBuildPackResponseBodyBuildPackListBuildPack) *ListBuildPackResponseBodyBuildPackList {
	s.BuildPack = v
	return s
}

type ListBuildPackResponseBodyBuildPackListBuildPack struct {
	// The build package number of EDAS Container.
	ConfigId *int64 `json:"ConfigId,omitempty" xml:"ConfigId,omitempty"`
	// Indicates whether the EDAS Container version is disabled. A disabled version cannot be configured for use.
	Disabled *bool `json:"Disabled,omitempty" xml:"Disabled,omitempty"`
	// The features of the EDAS Container version, which are released for public preview.
	Feature *string `json:"Feature,omitempty" xml:"Feature,omitempty"`
	// The ID of the base image that corresponds to EDAS Container.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// Indicates whether EDAS Container supports multitenancy.
	MultipleTenant *bool `json:"MultipleTenant,omitempty" xml:"MultipleTenant,omitempty"`
	// The version of the application.
	PackVersion *string `json:"PackVersion,omitempty" xml:"PackVersion,omitempty"`
	// The description of the Pandora container.
	PandoraDesc *string `json:"PandoraDesc,omitempty" xml:"PandoraDesc,omitempty"`
	// The download URL of the Pandora installer.
	PandoraDownloadUrl *string `json:"PandoraDownloadUrl,omitempty" xml:"PandoraDownloadUrl,omitempty"`
	// The version of the Pandora container.
	PandoraVersion *string `json:"PandoraVersion,omitempty" xml:"PandoraVersion,omitempty"`
	// The description of the plug-in.
	PluginInfo *string `json:"PluginInfo,omitempty" xml:"PluginInfo,omitempty"`
	// The name of the Shell script that runs EDAS Container.
	ScriptName *string `json:"ScriptName,omitempty" xml:"ScriptName,omitempty"`
	// The version of the Shell script that runs EDAS Container.
	ScriptVersion *string `json:"ScriptVersion,omitempty" xml:"ScriptVersion,omitempty"`
	// The features supported by EDAS Container.
	SupportFeatures *string `json:"SupportFeatures,omitempty" xml:"SupportFeatures,omitempty"`
	// The download URL of the Tengine installer.
	TengineDownloadUrl *string `json:"TengineDownloadUrl,omitempty" xml:"TengineDownloadUrl,omitempty"`
	// The ID of the Tengine image that corresponds to EDAS Container.
	TengineImageId *string `json:"TengineImageId,omitempty" xml:"TengineImageId,omitempty"`
	// The description of the Tomcat container.
	TomcatDesc *string `json:"TomcatDesc,omitempty" xml:"TomcatDesc,omitempty"`
	// The download URL of the Tomcat installer.
	TomcatDownloadUrl *string `json:"TomcatDownloadUrl,omitempty" xml:"TomcatDownloadUrl,omitempty"`
	// The directory of the Tomcat container.
	TomcatPath *string `json:"TomcatPath,omitempty" xml:"TomcatPath,omitempty"`
	// The version of the Tomcat container.
	TomcatVersion *string `json:"TomcatVersion,omitempty" xml:"TomcatVersion,omitempty"`
	// Indicates whether EDAS Container supports traffic management.
	WithTengine *bool `json:"WithTengine,omitempty" xml:"WithTengine,omitempty"`
}

func (s ListBuildPackResponseBodyBuildPackListBuildPack) String() string {
	return tea.Prettify(s)
}

func (s ListBuildPackResponseBodyBuildPackListBuildPack) GoString() string {
	return s.String()
}

func (s *ListBuildPackResponseBodyBuildPackListBuildPack) SetConfigId(v int64) *ListBuildPackResponseBodyBuildPackListBuildPack {
	s.ConfigId = &v
	return s
}

func (s *ListBuildPackResponseBodyBuildPackListBuildPack) SetDisabled(v bool) *ListBuildPackResponseBodyBuildPackListBuildPack {
	s.Disabled = &v
	return s
}

func (s *ListBuildPackResponseBodyBuildPackListBuildPack) SetFeature(v string) *ListBuildPackResponseBodyBuildPackListBuildPack {
	s.Feature = &v
	return s
}

func (s *ListBuildPackResponseBodyBuildPackListBuildPack) SetImageId(v string) *ListBuildPackResponseBodyBuildPackListBuildPack {
	s.ImageId = &v
	return s
}

func (s *ListBuildPackResponseBodyBuildPackListBuildPack) SetMultipleTenant(v bool) *ListBuildPackResponseBodyBuildPackListBuildPack {
	s.MultipleTenant = &v
	return s
}

func (s *ListBuildPackResponseBodyBuildPackListBuildPack) SetPackVersion(v string) *ListBuildPackResponseBodyBuildPackListBuildPack {
	s.PackVersion = &v
	return s
}

func (s *ListBuildPackResponseBodyBuildPackListBuildPack) SetPandoraDesc(v string) *ListBuildPackResponseBodyBuildPackListBuildPack {
	s.PandoraDesc = &v
	return s
}

func (s *ListBuildPackResponseBodyBuildPackListBuildPack) SetPandoraDownloadUrl(v string) *ListBuildPackResponseBodyBuildPackListBuildPack {
	s.PandoraDownloadUrl = &v
	return s
}

func (s *ListBuildPackResponseBodyBuildPackListBuildPack) SetPandoraVersion(v string) *ListBuildPackResponseBodyBuildPackListBuildPack {
	s.PandoraVersion = &v
	return s
}

func (s *ListBuildPackResponseBodyBuildPackListBuildPack) SetPluginInfo(v string) *ListBuildPackResponseBodyBuildPackListBuildPack {
	s.PluginInfo = &v
	return s
}

func (s *ListBuildPackResponseBodyBuildPackListBuildPack) SetScriptName(v string) *ListBuildPackResponseBodyBuildPackListBuildPack {
	s.ScriptName = &v
	return s
}

func (s *ListBuildPackResponseBodyBuildPackListBuildPack) SetScriptVersion(v string) *ListBuildPackResponseBodyBuildPackListBuildPack {
	s.ScriptVersion = &v
	return s
}

func (s *ListBuildPackResponseBodyBuildPackListBuildPack) SetSupportFeatures(v string) *ListBuildPackResponseBodyBuildPackListBuildPack {
	s.SupportFeatures = &v
	return s
}

func (s *ListBuildPackResponseBodyBuildPackListBuildPack) SetTengineDownloadUrl(v string) *ListBuildPackResponseBodyBuildPackListBuildPack {
	s.TengineDownloadUrl = &v
	return s
}

func (s *ListBuildPackResponseBodyBuildPackListBuildPack) SetTengineImageId(v string) *ListBuildPackResponseBodyBuildPackListBuildPack {
	s.TengineImageId = &v
	return s
}

func (s *ListBuildPackResponseBodyBuildPackListBuildPack) SetTomcatDesc(v string) *ListBuildPackResponseBodyBuildPackListBuildPack {
	s.TomcatDesc = &v
	return s
}

func (s *ListBuildPackResponseBodyBuildPackListBuildPack) SetTomcatDownloadUrl(v string) *ListBuildPackResponseBodyBuildPackListBuildPack {
	s.TomcatDownloadUrl = &v
	return s
}

func (s *ListBuildPackResponseBodyBuildPackListBuildPack) SetTomcatPath(v string) *ListBuildPackResponseBodyBuildPackListBuildPack {
	s.TomcatPath = &v
	return s
}

func (s *ListBuildPackResponseBodyBuildPackListBuildPack) SetTomcatVersion(v string) *ListBuildPackResponseBodyBuildPackListBuildPack {
	s.TomcatVersion = &v
	return s
}

func (s *ListBuildPackResponseBodyBuildPackListBuildPack) SetWithTengine(v bool) *ListBuildPackResponseBodyBuildPackListBuildPack {
	s.WithTengine = &v
	return s
}

type ListBuildPackResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListBuildPackResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListBuildPackResponse) String() string {
	return tea.Prettify(s)
}

func (s ListBuildPackResponse) GoString() string {
	return s.String()
}

func (s *ListBuildPackResponse) SetHeaders(v map[string]*string) *ListBuildPackResponse {
	s.Headers = v
	return s
}

func (s *ListBuildPackResponse) SetStatusCode(v int32) *ListBuildPackResponse {
	s.StatusCode = &v
	return s
}

func (s *ListBuildPackResponse) SetBody(v *ListBuildPackResponseBody) *ListBuildPackResponse {
	s.Body = v
	return s
}

type ListClusterRequest struct {
	// The ID of the namespace. You can call the ListUserDefineRegion operation to query the namespace ID. For more information, see [ListUserDefineRegion](~~149377~~).
	//
	// *   If this parameter is left empty, the clusters in the default namespace are queried.
	// *   If this parameter is specified, the clusters in the specified namespace are queried.
	LogicalRegionId *string `json:"LogicalRegionId,omitempty" xml:"LogicalRegionId,omitempty"`
	// The ID of the resource group. You can call the ListResourceGroup operation to query the resource group ID. For more information, see [ListResourceGroup](~~62055~~).
	//
	// *   If this parameter is left empty, the clusters in the default resource group are queried.
	// *   If this parameter is specified, the clusters in the specified resource group are queried.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s ListClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s ListClusterRequest) GoString() string {
	return s.String()
}

func (s *ListClusterRequest) SetLogicalRegionId(v string) *ListClusterRequest {
	s.LogicalRegionId = &v
	return s
}

func (s *ListClusterRequest) SetResourceGroupId(v string) *ListClusterRequest {
	s.ResourceGroupId = &v
	return s
}

type ListClusterResponseBody struct {
	// The clusters.
	ClusterList *ListClusterResponseBodyClusterList `json:"ClusterList,omitempty" xml:"ClusterList,omitempty" type:"Struct"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListClusterResponseBody) GoString() string {
	return s.String()
}

func (s *ListClusterResponseBody) SetClusterList(v *ListClusterResponseBodyClusterList) *ListClusterResponseBody {
	s.ClusterList = v
	return s
}

func (s *ListClusterResponseBody) SetCode(v int32) *ListClusterResponseBody {
	s.Code = &v
	return s
}

func (s *ListClusterResponseBody) SetMessage(v string) *ListClusterResponseBody {
	s.Message = &v
	return s
}

func (s *ListClusterResponseBody) SetRequestId(v string) *ListClusterResponseBody {
	s.RequestId = &v
	return s
}

type ListClusterResponseBodyClusterList struct {
	Cluster []*ListClusterResponseBodyClusterListCluster `json:"Cluster,omitempty" xml:"Cluster,omitempty" type:"Repeated"`
}

func (s ListClusterResponseBodyClusterList) String() string {
	return tea.Prettify(s)
}

func (s ListClusterResponseBodyClusterList) GoString() string {
	return s.String()
}

func (s *ListClusterResponseBodyClusterList) SetCluster(v []*ListClusterResponseBodyClusterListCluster) *ListClusterResponseBodyClusterList {
	s.Cluster = v
	return s
}

type ListClusterResponseBodyClusterListCluster struct {
	// The ID of the cluster in EDAS.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the cluster.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The type of the cluster. Valid values:
	//
	// *   0: regular Docker cluster
	// *   1: Swarm cluster
	// *   2: Elastic Compute Service (ECS) cluster
	// *   3: self-managed Kubernetes cluster in Enterprise Distributed Application Service (EDAS)
	// *   4: cluster in which Pandora automatically registers applications
	// *   5: ACK cluster
	ClusterType *int32 `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The total number of CPU cores.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The number of used CPU cores.
	CpuUsed *int32 `json:"CpuUsed,omitempty" xml:"CpuUsed,omitempty"`
	// The timestamp when the cluster was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the cluster in Container Service for Kubernetes (ACK).
	CsClusterId *string `json:"CsClusterId,omitempty" xml:"CsClusterId,omitempty"`
	// The description of the cluster.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The provider of the cluster.
	IaasProvider *string `json:"IaasProvider,omitempty" xml:"IaasProvider,omitempty"`
	// The total size of memory. Unit: MB.
	Mem *int32 `json:"Mem,omitempty" xml:"Mem,omitempty"`
	// The size of used memory. Unit: MB.
	MemUsed *int32 `json:"MemUsed,omitempty" xml:"MemUsed,omitempty"`
	// The network type of the cluster. Valid values:
	//
	// *   1: classic network
	// *   2: virtual private cloud (VPC)
	NetworkMode *int32 `json:"NetworkMode,omitempty" xml:"NetworkMode,omitempty"`
	// The number of instances.
	NodeNum *int32 `json:"NodeNum,omitempty" xml:"NodeNum,omitempty"`
	// The CPU overcommit ratio that is supported by a Docker cluster. Valid values:
	//
	// *   1: 1:1, which means that CPU resources are not overcommitted.
	// *   2: 1:2, which means that CPU resources are overcommitted by 1:2.
	// *   4: 1:4, which means that CPU resources are overcommitted by 1:4.
	// *   8: 1:8, which means that CPU resources are overcommitted by 1:8.
	OversoldFactor *int32 `json:"OversoldFactor,omitempty" xml:"OversoldFactor,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The timestamp when the cluster was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// VPC ID
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s ListClusterResponseBodyClusterListCluster) String() string {
	return tea.Prettify(s)
}

func (s ListClusterResponseBodyClusterListCluster) GoString() string {
	return s.String()
}

func (s *ListClusterResponseBodyClusterListCluster) SetClusterId(v string) *ListClusterResponseBodyClusterListCluster {
	s.ClusterId = &v
	return s
}

func (s *ListClusterResponseBodyClusterListCluster) SetClusterName(v string) *ListClusterResponseBodyClusterListCluster {
	s.ClusterName = &v
	return s
}

func (s *ListClusterResponseBodyClusterListCluster) SetClusterType(v int32) *ListClusterResponseBodyClusterListCluster {
	s.ClusterType = &v
	return s
}

func (s *ListClusterResponseBodyClusterListCluster) SetCpu(v int32) *ListClusterResponseBodyClusterListCluster {
	s.Cpu = &v
	return s
}

func (s *ListClusterResponseBodyClusterListCluster) SetCpuUsed(v int32) *ListClusterResponseBodyClusterListCluster {
	s.CpuUsed = &v
	return s
}

func (s *ListClusterResponseBodyClusterListCluster) SetCreateTime(v int64) *ListClusterResponseBodyClusterListCluster {
	s.CreateTime = &v
	return s
}

func (s *ListClusterResponseBodyClusterListCluster) SetCsClusterId(v string) *ListClusterResponseBodyClusterListCluster {
	s.CsClusterId = &v
	return s
}

func (s *ListClusterResponseBodyClusterListCluster) SetDescription(v string) *ListClusterResponseBodyClusterListCluster {
	s.Description = &v
	return s
}

func (s *ListClusterResponseBodyClusterListCluster) SetIaasProvider(v string) *ListClusterResponseBodyClusterListCluster {
	s.IaasProvider = &v
	return s
}

func (s *ListClusterResponseBodyClusterListCluster) SetMem(v int32) *ListClusterResponseBodyClusterListCluster {
	s.Mem = &v
	return s
}

func (s *ListClusterResponseBodyClusterListCluster) SetMemUsed(v int32) *ListClusterResponseBodyClusterListCluster {
	s.MemUsed = &v
	return s
}

func (s *ListClusterResponseBodyClusterListCluster) SetNetworkMode(v int32) *ListClusterResponseBodyClusterListCluster {
	s.NetworkMode = &v
	return s
}

func (s *ListClusterResponseBodyClusterListCluster) SetNodeNum(v int32) *ListClusterResponseBodyClusterListCluster {
	s.NodeNum = &v
	return s
}

func (s *ListClusterResponseBodyClusterListCluster) SetOversoldFactor(v int32) *ListClusterResponseBodyClusterListCluster {
	s.OversoldFactor = &v
	return s
}

func (s *ListClusterResponseBodyClusterListCluster) SetRegionId(v string) *ListClusterResponseBodyClusterListCluster {
	s.RegionId = &v
	return s
}

func (s *ListClusterResponseBodyClusterListCluster) SetResourceGroupId(v string) *ListClusterResponseBodyClusterListCluster {
	s.ResourceGroupId = &v
	return s
}

func (s *ListClusterResponseBodyClusterListCluster) SetUpdateTime(v int64) *ListClusterResponseBodyClusterListCluster {
	s.UpdateTime = &v
	return s
}

func (s *ListClusterResponseBodyClusterListCluster) SetVpcId(v string) *ListClusterResponseBodyClusterListCluster {
	s.VpcId = &v
	return s
}

type ListClusterResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListClusterResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s ListClusterResponse) GoString() string {
	return s.String()
}

func (s *ListClusterResponse) SetHeaders(v map[string]*string) *ListClusterResponse {
	s.Headers = v
	return s
}

func (s *ListClusterResponse) SetStatusCode(v int32) *ListClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *ListClusterResponse) SetBody(v *ListClusterResponseBody) *ListClusterResponse {
	s.Body = v
	return s
}

type ListClusterMembersRequest struct {
	// The ID of the cluster. You can call the ListCluster operation to query the cluster ID. For more information, see [ListCluster](~~154995~~).
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The number of the page to return. If you do not specify this parameter, the first page is returned.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The number of ECS instances.
	EcsList *string `json:"EcsList,omitempty" xml:"EcsList,omitempty"`
	// The number of ECS instances to return on each page. If you do not specify this parameter, all ECS instances in the specified cluster are returned on one page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s ListClusterMembersRequest) String() string {
	return tea.Prettify(s)
}

func (s ListClusterMembersRequest) GoString() string {
	return s.String()
}

func (s *ListClusterMembersRequest) SetClusterId(v string) *ListClusterMembersRequest {
	s.ClusterId = &v
	return s
}

func (s *ListClusterMembersRequest) SetCurrentPage(v int32) *ListClusterMembersRequest {
	s.CurrentPage = &v
	return s
}

func (s *ListClusterMembersRequest) SetEcsList(v string) *ListClusterMembersRequest {
	s.EcsList = &v
	return s
}

func (s *ListClusterMembersRequest) SetPageSize(v int32) *ListClusterMembersRequest {
	s.PageSize = &v
	return s
}

type ListClusterMembersResponseBody struct {
	// The information about the ECS instances in the cluster.
	ClusterMemberPage *ListClusterMembersResponseBodyClusterMemberPage `json:"ClusterMemberPage,omitempty" xml:"ClusterMemberPage,omitempty" type:"Struct"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListClusterMembersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListClusterMembersResponseBody) GoString() string {
	return s.String()
}

func (s *ListClusterMembersResponseBody) SetClusterMemberPage(v *ListClusterMembersResponseBodyClusterMemberPage) *ListClusterMembersResponseBody {
	s.ClusterMemberPage = v
	return s
}

func (s *ListClusterMembersResponseBody) SetCode(v int32) *ListClusterMembersResponseBody {
	s.Code = &v
	return s
}

func (s *ListClusterMembersResponseBody) SetMessage(v string) *ListClusterMembersResponseBody {
	s.Message = &v
	return s
}

func (s *ListClusterMembersResponseBody) SetRequestId(v string) *ListClusterMembersResponseBody {
	s.RequestId = &v
	return s
}

type ListClusterMembersResponseBodyClusterMemberPage struct {
	// The list of ECS instances in the cluster.
	ClusterMemberList *ListClusterMembersResponseBodyClusterMemberPageClusterMemberList `json:"ClusterMemberList,omitempty" xml:"ClusterMemberList,omitempty" type:"Struct"`
	// The page number of the returned page. If this parameter is not returned, the first page is returned.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The number of ECS instances returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of pages returned when all ECS instances are returned based on the specified PageSize parameter.
	TotalSize *int32 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s ListClusterMembersResponseBodyClusterMemberPage) String() string {
	return tea.Prettify(s)
}

func (s ListClusterMembersResponseBodyClusterMemberPage) GoString() string {
	return s.String()
}

func (s *ListClusterMembersResponseBodyClusterMemberPage) SetClusterMemberList(v *ListClusterMembersResponseBodyClusterMemberPageClusterMemberList) *ListClusterMembersResponseBodyClusterMemberPage {
	s.ClusterMemberList = v
	return s
}

func (s *ListClusterMembersResponseBodyClusterMemberPage) SetCurrentPage(v int32) *ListClusterMembersResponseBodyClusterMemberPage {
	s.CurrentPage = &v
	return s
}

func (s *ListClusterMembersResponseBodyClusterMemberPage) SetPageSize(v int32) *ListClusterMembersResponseBodyClusterMemberPage {
	s.PageSize = &v
	return s
}

func (s *ListClusterMembersResponseBodyClusterMemberPage) SetTotalSize(v int32) *ListClusterMembersResponseBodyClusterMemberPage {
	s.TotalSize = &v
	return s
}

type ListClusterMembersResponseBodyClusterMemberPageClusterMemberList struct {
	ClusterMember []*ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember `json:"ClusterMember,omitempty" xml:"ClusterMember,omitempty" type:"Repeated"`
}

func (s ListClusterMembersResponseBodyClusterMemberPageClusterMemberList) String() string {
	return tea.Prettify(s)
}

func (s ListClusterMembersResponseBodyClusterMemberPageClusterMemberList) GoString() string {
	return s.String()
}

func (s *ListClusterMembersResponseBodyClusterMemberPageClusterMemberList) SetClusterMember(v []*ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember) *ListClusterMembersResponseBodyClusterMemberPageClusterMemberList {
	s.ClusterMember = v
	return s
}

type ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember struct {
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The ID of the ECS instance in the cluster.
	ClusterMemberId *string `json:"ClusterMemberId,omitempty" xml:"ClusterMemberId,omitempty"`
	// The timestamp when the ECS instance was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the ECS instance.
	EcsId *string `json:"EcsId,omitempty" xml:"EcsId,omitempty"`
	// The unique ID of the elastic compute unit (ECU). You can run the `dmidecode` command on the ECS instance to query the ECU ID.
	EcuId *string `json:"EcuId,omitempty" xml:"EcuId,omitempty"`
	// The private IP address for the ECS instance.
	PrivateIp *string `json:"PrivateIp,omitempty" xml:"PrivateIp,omitempty"`
	// The state of the ECS instance. Valid values:
	//
	// *   1: The instance is running.
	// *   0: The instance is being converted.
	// *   \-1: The instance fails to be converted.
	// *   \-2: The instance is offline.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The timestamp when the ECS instance was updated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember) String() string {
	return tea.Prettify(s)
}

func (s ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember) GoString() string {
	return s.String()
}

func (s *ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember) SetClusterId(v string) *ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember {
	s.ClusterId = &v
	return s
}

func (s *ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember) SetClusterMemberId(v string) *ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember {
	s.ClusterMemberId = &v
	return s
}

func (s *ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember) SetCreateTime(v int64) *ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember {
	s.CreateTime = &v
	return s
}

func (s *ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember) SetEcsId(v string) *ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember {
	s.EcsId = &v
	return s
}

func (s *ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember) SetEcuId(v string) *ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember {
	s.EcuId = &v
	return s
}

func (s *ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember) SetPrivateIp(v string) *ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember {
	s.PrivateIp = &v
	return s
}

func (s *ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember) SetStatus(v int32) *ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember {
	s.Status = &v
	return s
}

func (s *ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember) SetUpdateTime(v int64) *ListClusterMembersResponseBodyClusterMemberPageClusterMemberListClusterMember {
	s.UpdateTime = &v
	return s
}

type ListClusterMembersResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListClusterMembersResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListClusterMembersResponse) String() string {
	return tea.Prettify(s)
}

func (s ListClusterMembersResponse) GoString() string {
	return s.String()
}

func (s *ListClusterMembersResponse) SetHeaders(v map[string]*string) *ListClusterMembersResponse {
	s.Headers = v
	return s
}

func (s *ListClusterMembersResponse) SetStatusCode(v int32) *ListClusterMembersResponse {
	s.StatusCode = &v
	return s
}

func (s *ListClusterMembersResponse) SetBody(v *ListClusterMembersResponseBody) *ListClusterMembersResponse {
	s.Body = v
	return s
}

type ListComponentsResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The components.
	ComponentList *ListComponentsResponseBodyComponentList `json:"ComponentList,omitempty" xml:"ComponentList,omitempty" type:"Struct"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
}

func (s ListComponentsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListComponentsResponseBody) GoString() string {
	return s.String()
}

func (s *ListComponentsResponseBody) SetCode(v int32) *ListComponentsResponseBody {
	s.Code = &v
	return s
}

func (s *ListComponentsResponseBody) SetComponentList(v *ListComponentsResponseBodyComponentList) *ListComponentsResponseBody {
	s.ComponentList = v
	return s
}

func (s *ListComponentsResponseBody) SetMessage(v string) *ListComponentsResponseBody {
	s.Message = &v
	return s
}

type ListComponentsResponseBodyComponentList struct {
	Component []*ListComponentsResponseBodyComponentListComponent `json:"Component,omitempty" xml:"Component,omitempty" type:"Repeated"`
}

func (s ListComponentsResponseBodyComponentList) String() string {
	return tea.Prettify(s)
}

func (s ListComponentsResponseBodyComponentList) GoString() string {
	return s.String()
}

func (s *ListComponentsResponseBodyComponentList) SetComponent(v []*ListComponentsResponseBodyComponentListComponent) *ListComponentsResponseBodyComponentList {
	s.Component = v
	return s
}

type ListComponentsResponseBodyComponentListComponent struct {
	// The ID of the component.
	ComponentId *string `json:"ComponentId,omitempty" xml:"ComponentId,omitempty"`
	// The key of the component.
	ComponentKey *string `json:"ComponentKey,omitempty" xml:"ComponentKey,omitempty"`
	// The description of the component.
	Desc *string `json:"Desc,omitempty" xml:"Desc,omitempty"`
	// Indicates whether the component has expired. Valid values:
	//
	// *   false: The component has not expired.
	// *   true: The component has expired.
	Expired *bool `json:"Expired,omitempty" xml:"Expired,omitempty"`
	// The type of the component. Valid values:
	//
	// *   JDK
	// *   TOMCAT
	// *   TENGINE
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The version of the component.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s ListComponentsResponseBodyComponentListComponent) String() string {
	return tea.Prettify(s)
}

func (s ListComponentsResponseBodyComponentListComponent) GoString() string {
	return s.String()
}

func (s *ListComponentsResponseBodyComponentListComponent) SetComponentId(v string) *ListComponentsResponseBodyComponentListComponent {
	s.ComponentId = &v
	return s
}

func (s *ListComponentsResponseBodyComponentListComponent) SetComponentKey(v string) *ListComponentsResponseBodyComponentListComponent {
	s.ComponentKey = &v
	return s
}

func (s *ListComponentsResponseBodyComponentListComponent) SetDesc(v string) *ListComponentsResponseBodyComponentListComponent {
	s.Desc = &v
	return s
}

func (s *ListComponentsResponseBodyComponentListComponent) SetExpired(v bool) *ListComponentsResponseBodyComponentListComponent {
	s.Expired = &v
	return s
}

func (s *ListComponentsResponseBodyComponentListComponent) SetType(v string) *ListComponentsResponseBodyComponentListComponent {
	s.Type = &v
	return s
}

func (s *ListComponentsResponseBodyComponentListComponent) SetVersion(v string) *ListComponentsResponseBodyComponentListComponent {
	s.Version = &v
	return s
}

type ListComponentsResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListComponentsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListComponentsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListComponentsResponse) GoString() string {
	return s.String()
}

func (s *ListComponentsResponse) SetHeaders(v map[string]*string) *ListComponentsResponse {
	s.Headers = v
	return s
}

func (s *ListComponentsResponse) SetStatusCode(v int32) *ListComponentsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListComponentsResponse) SetBody(v *ListComponentsResponseBody) *ListComponentsResponse {
	s.Body = v
	return s
}

type ListConfigTemplatesRequest struct {
	// The number of the page to return. Pages start from Page 1.
	CurrentPage *int64 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The ID of the configuration template.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the configuration template.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The number of entries to return on each page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s ListConfigTemplatesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListConfigTemplatesRequest) GoString() string {
	return s.String()
}

func (s *ListConfigTemplatesRequest) SetCurrentPage(v int64) *ListConfigTemplatesRequest {
	s.CurrentPage = &v
	return s
}

func (s *ListConfigTemplatesRequest) SetId(v int64) *ListConfigTemplatesRequest {
	s.Id = &v
	return s
}

func (s *ListConfigTemplatesRequest) SetName(v string) *ListConfigTemplatesRequest {
	s.Name = &v
	return s
}

func (s *ListConfigTemplatesRequest) SetPageSize(v int64) *ListConfigTemplatesRequest {
	s.PageSize = &v
	return s
}

type ListConfigTemplatesResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The result of the request.
	Data *ListConfigTemplatesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListConfigTemplatesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListConfigTemplatesResponseBody) GoString() string {
	return s.String()
}

func (s *ListConfigTemplatesResponseBody) SetCode(v int32) *ListConfigTemplatesResponseBody {
	s.Code = &v
	return s
}

func (s *ListConfigTemplatesResponseBody) SetData(v *ListConfigTemplatesResponseBodyData) *ListConfigTemplatesResponseBody {
	s.Data = v
	return s
}

func (s *ListConfigTemplatesResponseBody) SetMessage(v string) *ListConfigTemplatesResponseBody {
	s.Message = &v
	return s
}

func (s *ListConfigTemplatesResponseBody) SetRequestId(v string) *ListConfigTemplatesResponseBody {
	s.RequestId = &v
	return s
}

type ListConfigTemplatesResponseBodyData struct {
	// The page number of the returned page.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The configuration templates.
	Result []*ListConfigTemplatesResponseBodyDataResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// The total number of configuration templates.
	TotalSize *int64 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s ListConfigTemplatesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListConfigTemplatesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListConfigTemplatesResponseBodyData) SetCurrentPage(v int32) *ListConfigTemplatesResponseBodyData {
	s.CurrentPage = &v
	return s
}

func (s *ListConfigTemplatesResponseBodyData) SetPageSize(v int32) *ListConfigTemplatesResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListConfigTemplatesResponseBodyData) SetResult(v []*ListConfigTemplatesResponseBodyDataResult) *ListConfigTemplatesResponseBodyData {
	s.Result = v
	return s
}

func (s *ListConfigTemplatesResponseBodyData) SetTotalSize(v int64) *ListConfigTemplatesResponseBodyData {
	s.TotalSize = &v
	return s
}

type ListConfigTemplatesResponseBodyDataResult struct {
	// The content of the configuration template.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The description of the configuration template.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The data format of the configuration template.
	Format *string `json:"Format,omitempty" xml:"Format,omitempty"`
	// The time when the configuration template was created.
	GmtCreate *int64 `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The time when the configuration template was updated.
	GmtModified *int64 `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the configuration template.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the configuration template.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s ListConfigTemplatesResponseBodyDataResult) String() string {
	return tea.Prettify(s)
}

func (s ListConfigTemplatesResponseBodyDataResult) GoString() string {
	return s.String()
}

func (s *ListConfigTemplatesResponseBodyDataResult) SetContent(v string) *ListConfigTemplatesResponseBodyDataResult {
	s.Content = &v
	return s
}

func (s *ListConfigTemplatesResponseBodyDataResult) SetDescription(v string) *ListConfigTemplatesResponseBodyDataResult {
	s.Description = &v
	return s
}

func (s *ListConfigTemplatesResponseBodyDataResult) SetFormat(v string) *ListConfigTemplatesResponseBodyDataResult {
	s.Format = &v
	return s
}

func (s *ListConfigTemplatesResponseBodyDataResult) SetGmtCreate(v int64) *ListConfigTemplatesResponseBodyDataResult {
	s.GmtCreate = &v
	return s
}

func (s *ListConfigTemplatesResponseBodyDataResult) SetGmtModified(v int64) *ListConfigTemplatesResponseBodyDataResult {
	s.GmtModified = &v
	return s
}

func (s *ListConfigTemplatesResponseBodyDataResult) SetId(v string) *ListConfigTemplatesResponseBodyDataResult {
	s.Id = &v
	return s
}

func (s *ListConfigTemplatesResponseBodyDataResult) SetName(v string) *ListConfigTemplatesResponseBodyDataResult {
	s.Name = &v
	return s
}

type ListConfigTemplatesResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListConfigTemplatesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListConfigTemplatesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListConfigTemplatesResponse) GoString() string {
	return s.String()
}

func (s *ListConfigTemplatesResponse) SetHeaders(v map[string]*string) *ListConfigTemplatesResponse {
	s.Headers = v
	return s
}

func (s *ListConfigTemplatesResponse) SetStatusCode(v int32) *ListConfigTemplatesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListConfigTemplatesResponse) SetBody(v *ListConfigTemplatesResponseBody) *ListConfigTemplatesResponse {
	s.Body = v
	return s
}

type ListConsumedServicesRequest struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
}

func (s ListConsumedServicesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListConsumedServicesRequest) GoString() string {
	return s.String()
}

func (s *ListConsumedServicesRequest) SetAppId(v string) *ListConsumedServicesRequest {
	s.AppId = &v
	return s
}

type ListConsumedServicesResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The information about consumed services.
	ConsumedServicesList *ListConsumedServicesResponseBodyConsumedServicesList `json:"ConsumedServicesList,omitempty" xml:"ConsumedServicesList,omitempty" type:"Struct"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListConsumedServicesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListConsumedServicesResponseBody) GoString() string {
	return s.String()
}

func (s *ListConsumedServicesResponseBody) SetCode(v int32) *ListConsumedServicesResponseBody {
	s.Code = &v
	return s
}

func (s *ListConsumedServicesResponseBody) SetConsumedServicesList(v *ListConsumedServicesResponseBodyConsumedServicesList) *ListConsumedServicesResponseBody {
	s.ConsumedServicesList = v
	return s
}

func (s *ListConsumedServicesResponseBody) SetMessage(v string) *ListConsumedServicesResponseBody {
	s.Message = &v
	return s
}

func (s *ListConsumedServicesResponseBody) SetRequestId(v string) *ListConsumedServicesResponseBody {
	s.RequestId = &v
	return s
}

type ListConsumedServicesResponseBodyConsumedServicesList struct {
	ListConsumedServices []*ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices `json:"ListConsumedServices,omitempty" xml:"ListConsumedServices,omitempty" type:"Repeated"`
}

func (s ListConsumedServicesResponseBodyConsumedServicesList) String() string {
	return tea.Prettify(s)
}

func (s ListConsumedServicesResponseBodyConsumedServicesList) GoString() string {
	return s.String()
}

func (s *ListConsumedServicesResponseBodyConsumedServicesList) SetListConsumedServices(v []*ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices) *ListConsumedServicesResponseBodyConsumedServicesList {
	s.ListConsumedServices = v
	return s
}

type ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// Indicates whether the application runs in a Docker container. Valid values:
	//
	// *   true: The application runs in a Docker container.
	// *   false: The application does not run in a Docker container.
	DockerApplication *bool `json:"DockerApplication,omitempty" xml:"DockerApplication,omitempty"`
	// A reserved parameter.
	Group2Ip *string                                                                         `json:"Group2Ip,omitempty" xml:"Group2Ip,omitempty"`
	Groups   *ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesGroups `json:"Groups,omitempty" xml:"Groups,omitempty" type:"Struct"`
	Ips      *ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesIps    `json:"Ips,omitempty" xml:"Ips,omitempty" type:"Struct"`
	// The name of the consumed service.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of the consumed service.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The version of the consumed service.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices) String() string {
	return tea.Prettify(s)
}

func (s ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices) GoString() string {
	return s.String()
}

func (s *ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices) SetAppId(v string) *ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices {
	s.AppId = &v
	return s
}

func (s *ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices) SetDockerApplication(v bool) *ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices {
	s.DockerApplication = &v
	return s
}

func (s *ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices) SetGroup2Ip(v string) *ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices {
	s.Group2Ip = &v
	return s
}

func (s *ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices) SetGroups(v *ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesGroups) *ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices {
	s.Groups = v
	return s
}

func (s *ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices) SetIps(v *ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesIps) *ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices {
	s.Ips = v
	return s
}

func (s *ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices) SetName(v string) *ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices {
	s.Name = &v
	return s
}

func (s *ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices) SetType(v string) *ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices {
	s.Type = &v
	return s
}

func (s *ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices) SetVersion(v string) *ListConsumedServicesResponseBodyConsumedServicesListListConsumedServices {
	s.Version = &v
	return s
}

type ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesGroups struct {
	Group []*string `json:"group,omitempty" xml:"group,omitempty" type:"Repeated"`
}

func (s ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesGroups) String() string {
	return tea.Prettify(s)
}

func (s ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesGroups) GoString() string {
	return s.String()
}

func (s *ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesGroups) SetGroup(v []*string) *ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesGroups {
	s.Group = v
	return s
}

type ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesIps struct {
	Ip []*string `json:"ip,omitempty" xml:"ip,omitempty" type:"Repeated"`
}

func (s ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesIps) String() string {
	return tea.Prettify(s)
}

func (s ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesIps) GoString() string {
	return s.String()
}

func (s *ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesIps) SetIp(v []*string) *ListConsumedServicesResponseBodyConsumedServicesListListConsumedServicesIps {
	s.Ip = v
	return s
}

type ListConsumedServicesResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListConsumedServicesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListConsumedServicesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListConsumedServicesResponse) GoString() string {
	return s.String()
}

func (s *ListConsumedServicesResponse) SetHeaders(v map[string]*string) *ListConsumedServicesResponse {
	s.Headers = v
	return s
}

func (s *ListConsumedServicesResponse) SetStatusCode(v int32) *ListConsumedServicesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListConsumedServicesResponse) SetBody(v *ListConsumedServicesResponseBody) *ListConsumedServicesResponse {
	s.Body = v
	return s
}

type ListConvertableEcuRequest struct {
	// The ID of the cluster. You can call the ListCluster operation to query the cluster ID. For more information, see [ListCluster](~~154995~~).
	ClusterId *string `json:"clusterId,omitempty" xml:"clusterId,omitempty"`
}

func (s ListConvertableEcuRequest) String() string {
	return tea.Prettify(s)
}

func (s ListConvertableEcuRequest) GoString() string {
	return s.String()
}

func (s *ListConvertableEcuRequest) SetClusterId(v string) *ListConvertableEcuRequest {
	s.ClusterId = &v
	return s
}

type ListConvertableEcuResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The ECS instances that can be imported to the cluster.
	InstanceList *ListConvertableEcuResponseBodyInstanceList `json:"InstanceList,omitempty" xml:"InstanceList,omitempty" type:"Struct"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListConvertableEcuResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListConvertableEcuResponseBody) GoString() string {
	return s.String()
}

func (s *ListConvertableEcuResponseBody) SetCode(v int32) *ListConvertableEcuResponseBody {
	s.Code = &v
	return s
}

func (s *ListConvertableEcuResponseBody) SetInstanceList(v *ListConvertableEcuResponseBodyInstanceList) *ListConvertableEcuResponseBody {
	s.InstanceList = v
	return s
}

func (s *ListConvertableEcuResponseBody) SetMessage(v string) *ListConvertableEcuResponseBody {
	s.Message = &v
	return s
}

func (s *ListConvertableEcuResponseBody) SetRequestId(v string) *ListConvertableEcuResponseBody {
	s.RequestId = &v
	return s
}

type ListConvertableEcuResponseBodyInstanceList struct {
	Instance []*ListConvertableEcuResponseBodyInstanceListInstance `json:"Instance,omitempty" xml:"Instance,omitempty" type:"Repeated"`
}

func (s ListConvertableEcuResponseBodyInstanceList) String() string {
	return tea.Prettify(s)
}

func (s ListConvertableEcuResponseBodyInstanceList) GoString() string {
	return s.String()
}

func (s *ListConvertableEcuResponseBodyInstanceList) SetInstance(v []*ListConvertableEcuResponseBodyInstanceListInstance) *ListConvertableEcuResponseBodyInstanceList {
	s.Instance = v
	return s
}

type ListConvertableEcuResponseBodyInstanceListInstance struct {
	// The number of CPU cores of the ECS instance.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The ID of the elastic compute units (ECU).
	EcuId *string `json:"EcuId,omitempty" xml:"EcuId,omitempty"`
	// The elastic IP address (EIP) associated with the ECS instance. The EIP can be changed.
	Eip *string `json:"Eip,omitempty" xml:"Eip,omitempty"`
	// Indicates whether the ECS instance has expired.
	Expired *bool `json:"Expired,omitempty" xml:"Expired,omitempty"`
	// The private IP address of the ECS instance. This parameter is valid only when the ECS instance is deployed in a VPC.
	InnerIp *string `json:"InnerIp,omitempty" xml:"InnerIp,omitempty"`
	// The ID of the ECS instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The name of the ECS instance.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// The size of memory for the ECS instance.
	Mem *int32 `json:"Mem,omitempty" xml:"Mem,omitempty"`
	// The private IP address of the ECS instance. This parameter is valid only when the ECS instance is deployed in a VPC.
	PrivateIp *string `json:"PrivateIp,omitempty" xml:"PrivateIp,omitempty"`
	// The public IP address of the ECS instance. This IP address can be used only by the ECS instance.
	PublicIp *string `json:"PublicIp,omitempty" xml:"PublicIp,omitempty"`
	// The ID of the region where the ECS instance is located.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The state of the instance. Valid values:
	//
	// *   Pending: The instance is being created.
	// *   Running: The instance is running.
	// *   Starting: The instance is being started.
	// *   Stopping: The instance is being stopped.
	// *   Stopped: The instance is stopped.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the virtual private cloud (VPC).
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The name of the VPC.
	VpcName *string `json:"VpcName,omitempty" xml:"VpcName,omitempty"`
}

func (s ListConvertableEcuResponseBodyInstanceListInstance) String() string {
	return tea.Prettify(s)
}

func (s ListConvertableEcuResponseBodyInstanceListInstance) GoString() string {
	return s.String()
}

func (s *ListConvertableEcuResponseBodyInstanceListInstance) SetCpu(v int32) *ListConvertableEcuResponseBodyInstanceListInstance {
	s.Cpu = &v
	return s
}

func (s *ListConvertableEcuResponseBodyInstanceListInstance) SetEcuId(v string) *ListConvertableEcuResponseBodyInstanceListInstance {
	s.EcuId = &v
	return s
}

func (s *ListConvertableEcuResponseBodyInstanceListInstance) SetEip(v string) *ListConvertableEcuResponseBodyInstanceListInstance {
	s.Eip = &v
	return s
}

func (s *ListConvertableEcuResponseBodyInstanceListInstance) SetExpired(v bool) *ListConvertableEcuResponseBodyInstanceListInstance {
	s.Expired = &v
	return s
}

func (s *ListConvertableEcuResponseBodyInstanceListInstance) SetInnerIp(v string) *ListConvertableEcuResponseBodyInstanceListInstance {
	s.InnerIp = &v
	return s
}

func (s *ListConvertableEcuResponseBodyInstanceListInstance) SetInstanceId(v string) *ListConvertableEcuResponseBodyInstanceListInstance {
	s.InstanceId = &v
	return s
}

func (s *ListConvertableEcuResponseBodyInstanceListInstance) SetInstanceName(v string) *ListConvertableEcuResponseBodyInstanceListInstance {
	s.InstanceName = &v
	return s
}

func (s *ListConvertableEcuResponseBodyInstanceListInstance) SetMem(v int32) *ListConvertableEcuResponseBodyInstanceListInstance {
	s.Mem = &v
	return s
}

func (s *ListConvertableEcuResponseBodyInstanceListInstance) SetPrivateIp(v string) *ListConvertableEcuResponseBodyInstanceListInstance {
	s.PrivateIp = &v
	return s
}

func (s *ListConvertableEcuResponseBodyInstanceListInstance) SetPublicIp(v string) *ListConvertableEcuResponseBodyInstanceListInstance {
	s.PublicIp = &v
	return s
}

func (s *ListConvertableEcuResponseBodyInstanceListInstance) SetRegionId(v string) *ListConvertableEcuResponseBodyInstanceListInstance {
	s.RegionId = &v
	return s
}

func (s *ListConvertableEcuResponseBodyInstanceListInstance) SetStatus(v string) *ListConvertableEcuResponseBodyInstanceListInstance {
	s.Status = &v
	return s
}

func (s *ListConvertableEcuResponseBodyInstanceListInstance) SetVpcId(v string) *ListConvertableEcuResponseBodyInstanceListInstance {
	s.VpcId = &v
	return s
}

func (s *ListConvertableEcuResponseBodyInstanceListInstance) SetVpcName(v string) *ListConvertableEcuResponseBodyInstanceListInstance {
	s.VpcName = &v
	return s
}

type ListConvertableEcuResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListConvertableEcuResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListConvertableEcuResponse) String() string {
	return tea.Prettify(s)
}

func (s ListConvertableEcuResponse) GoString() string {
	return s.String()
}

func (s *ListConvertableEcuResponse) SetHeaders(v map[string]*string) *ListConvertableEcuResponse {
	s.Headers = v
	return s
}

func (s *ListConvertableEcuResponse) SetStatusCode(v int32) *ListConvertableEcuResponse {
	s.StatusCode = &v
	return s
}

func (s *ListConvertableEcuResponse) SetBody(v *ListConvertableEcuResponseBody) *ListConvertableEcuResponse {
	s.Body = v
	return s
}

type ListDeployGroupRequest struct {
	// The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
}

func (s ListDeployGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDeployGroupRequest) GoString() string {
	return s.String()
}

func (s *ListDeployGroupRequest) SetAppId(v string) *ListDeployGroupRequest {
	s.AppId = &v
	return s
}

type ListDeployGroupResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The information about the instance group in which the application is deployed.
	DeployGroupList *ListDeployGroupResponseBodyDeployGroupList `json:"DeployGroupList,omitempty" xml:"DeployGroupList,omitempty" type:"Struct"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListDeployGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDeployGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ListDeployGroupResponseBody) SetCode(v int32) *ListDeployGroupResponseBody {
	s.Code = &v
	return s
}

func (s *ListDeployGroupResponseBody) SetDeployGroupList(v *ListDeployGroupResponseBodyDeployGroupList) *ListDeployGroupResponseBody {
	s.DeployGroupList = v
	return s
}

func (s *ListDeployGroupResponseBody) SetMessage(v string) *ListDeployGroupResponseBody {
	s.Message = &v
	return s
}

func (s *ListDeployGroupResponseBody) SetRequestId(v string) *ListDeployGroupResponseBody {
	s.RequestId = &v
	return s
}

type ListDeployGroupResponseBodyDeployGroupList struct {
	DeployGroup []*ListDeployGroupResponseBodyDeployGroupListDeployGroup `json:"DeployGroup,omitempty" xml:"DeployGroup,omitempty" type:"Repeated"`
}

func (s ListDeployGroupResponseBodyDeployGroupList) String() string {
	return tea.Prettify(s)
}

func (s ListDeployGroupResponseBodyDeployGroupList) GoString() string {
	return s.String()
}

func (s *ListDeployGroupResponseBodyDeployGroupList) SetDeployGroup(v []*ListDeployGroupResponseBodyDeployGroupListDeployGroup) *ListDeployGroupResponseBodyDeployGroupList {
	s.DeployGroup = v
	return s
}

type ListDeployGroupResponseBodyDeployGroupListDeployGroup struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the change process for application deployment in the instance group.
	AppVersionId *string `json:"AppVersionId,omitempty" xml:"AppVersionId,omitempty"`
	// The name of the basic component.
	BaseComponentMetaName *string `json:"BaseComponentMetaName,omitempty" xml:"BaseComponentMetaName,omitempty"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the cluster.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The maximum number of CPU cores allowed for each application instance when the application is running.
	CpuLimit *string `json:"CpuLimit,omitempty" xml:"CpuLimit,omitempty"`
	// The number of CPU cores requested for each application instance when the application is running. Unit: cores. Value 0 indicates that no limit is set on CPU cores.
	CpuRequest *string `json:"CpuRequest,omitempty" xml:"CpuRequest,omitempty"`
	// The time when the application was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the Container Service for Kubernetes (ACK) cluster.
	CsClusterId *string `json:"CsClusterId,omitempty" xml:"CsClusterId,omitempty"`
	// The name of the deployment.
	DeploymentName *string `json:"DeploymentName,omitempty" xml:"DeploymentName,omitempty"`
	// The ID of the ACK cluster.
	Env *string `json:"Env,omitempty" xml:"Env,omitempty"`
	// The maximum size of space required by ephemeral storage. Unit: GB. Value 0 indicates that no limit is set on the space size.
	EphemeralStorageLimit *string `json:"EphemeralStorageLimit,omitempty" xml:"EphemeralStorageLimit,omitempty"`
	// The minimum size of space required by ephemeral storage. Unit: GB. Value 0 indicates that no limit is set on the space size.
	EphemeralStorageRequest *string `json:"EphemeralStorageRequest,omitempty" xml:"EphemeralStorageRequest,omitempty"`
	// The ID of the instance group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the instance group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The type of the instance group. Valid values:
	//
	// *   0: default group.
	// *   1: Canary release is disabled for traffic management.
	// *   2: Canary release is enabled for traffic management.
	GroupType *int32 `json:"GroupType,omitempty" xml:"GroupType,omitempty"`
	// The tag.
	Labels *string `json:"Labels,omitempty" xml:"Labels,omitempty"`
	// The time when the application was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	LastUpdateTime *int64 `json:"LastUpdateTime,omitempty" xml:"LastUpdateTime,omitempty"`
	// The maximum size of memory allowed for each application instance when the application is running. Unit: MB. Value 0 indicates that no limit is set on the memory size.
	MemoryLimit *string `json:"MemoryLimit,omitempty" xml:"MemoryLimit,omitempty"`
	// The size of memory requested for each application instance when the application is running. Unit: MB. Value 0 indicates that no limit is set on the memory size.
	MemoryRequest *string `json:"MemoryRequest,omitempty" xml:"MemoryRequest,omitempty"`
	// The namespace.
	NameSpace *string `json:"NameSpace,omitempty" xml:"NameSpace,omitempty"`
	// The external download URL of the deployment package.
	PackagePublicUrl *string `json:"PackagePublicUrl,omitempty" xml:"PackagePublicUrl,omitempty"`
	// The URL of the deployment package.
	PackageUrl *string `json:"PackageUrl,omitempty" xml:"PackageUrl,omitempty"`
	// The version of the deployment package.
	PackageVersion *string `json:"PackageVersion,omitempty" xml:"PackageVersion,omitempty"`
	// The version of the deployment package that was used to deploy an application in the instance group.
	PackageVersionId *string `json:"PackageVersionId,omitempty" xml:"PackageVersionId,omitempty"`
	// The post-start script.
	PostStart *string `json:"PostStart,omitempty" xml:"PostStart,omitempty"`
	// The pre-stop script.
	PreStop *string `json:"PreStop,omitempty" xml:"PreStop,omitempty"`
	// The version of the application. The value progressively increases in the range of 0 to 7.
	Reversion *string `json:"Reversion,omitempty" xml:"Reversion,omitempty"`
	// The ID of the application deployed in the ACK cluster in Enterprise Distributed Application Service (EDAS).
	Selector *string `json:"Selector,omitempty" xml:"Selector,omitempty"`
	// The state of the application instance group. Valid values:
	//
	// *   0: ready
	// *   1: in progress
	// *   2: successful
	// *   3: failed
	// *   6: terminated
	// *   10: failed due to a system exception
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The throttling policy. This parameter is reserved.
	Strategy *string `json:"Strategy,omitempty" xml:"Strategy,omitempty"`
	// The time when the application was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The ID of the vServer group of the Internet-facing SLB instance associated with the instance group.
	VExtServerGroupId *string `json:"VExtServerGroupId,omitempty" xml:"VExtServerGroupId,omitempty"`
	// The ID of the vServer group of the internal-facing Server Load Balancer (SLB) instance associated with the instance group.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
}

func (s ListDeployGroupResponseBodyDeployGroupListDeployGroup) String() string {
	return tea.Prettify(s)
}

func (s ListDeployGroupResponseBodyDeployGroupListDeployGroup) GoString() string {
	return s.String()
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetAppId(v string) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.AppId = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetAppVersionId(v string) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.AppVersionId = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetBaseComponentMetaName(v string) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.BaseComponentMetaName = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetClusterId(v string) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.ClusterId = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetClusterName(v string) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.ClusterName = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetCpuLimit(v string) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.CpuLimit = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetCpuRequest(v string) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.CpuRequest = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetCreateTime(v int64) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.CreateTime = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetCsClusterId(v string) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.CsClusterId = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetDeploymentName(v string) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.DeploymentName = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetEnv(v string) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.Env = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetEphemeralStorageLimit(v string) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.EphemeralStorageLimit = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetEphemeralStorageRequest(v string) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.EphemeralStorageRequest = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetGroupId(v string) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.GroupId = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetGroupName(v string) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.GroupName = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetGroupType(v int32) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.GroupType = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetLabels(v string) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.Labels = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetLastUpdateTime(v int64) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.LastUpdateTime = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetMemoryLimit(v string) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.MemoryLimit = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetMemoryRequest(v string) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.MemoryRequest = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetNameSpace(v string) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.NameSpace = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetPackagePublicUrl(v string) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.PackagePublicUrl = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetPackageUrl(v string) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.PackageUrl = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetPackageVersion(v string) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.PackageVersion = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetPackageVersionId(v string) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.PackageVersionId = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetPostStart(v string) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.PostStart = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetPreStop(v string) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.PreStop = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetReversion(v string) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.Reversion = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetSelector(v string) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.Selector = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetStatus(v string) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.Status = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetStrategy(v string) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.Strategy = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetUpdateTime(v int64) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.UpdateTime = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetVExtServerGroupId(v string) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.VExtServerGroupId = &v
	return s
}

func (s *ListDeployGroupResponseBodyDeployGroupListDeployGroup) SetVServerGroupId(v string) *ListDeployGroupResponseBodyDeployGroupListDeployGroup {
	s.VServerGroupId = &v
	return s
}

type ListDeployGroupResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListDeployGroupResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListDeployGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDeployGroupResponse) GoString() string {
	return s.String()
}

func (s *ListDeployGroupResponse) SetHeaders(v map[string]*string) *ListDeployGroupResponse {
	s.Headers = v
	return s
}

func (s *ListDeployGroupResponse) SetStatusCode(v int32) *ListDeployGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDeployGroupResponse) SetBody(v *ListDeployGroupResponseBody) *ListDeployGroupResponse {
	s.Body = v
	return s
}

type ListEcsNotInClusterRequest struct {
	// The network type. Valid values:
	//
	// *   1: classic network
	// *   2: virtual private cloud (VPC)
	NetworkMode *int32 `json:"NetworkMode,omitempty" xml:"NetworkMode,omitempty"`
	// The ID of the VPC. This parameter is required if the NetworkMode parameter is set to 2.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s ListEcsNotInClusterRequest) String() string {
	return tea.Prettify(s)
}

func (s ListEcsNotInClusterRequest) GoString() string {
	return s.String()
}

func (s *ListEcsNotInClusterRequest) SetNetworkMode(v int32) *ListEcsNotInClusterRequest {
	s.NetworkMode = &v
	return s
}

func (s *ListEcsNotInClusterRequest) SetVpcId(v string) *ListEcsNotInClusterRequest {
	s.VpcId = &v
	return s
}

type ListEcsNotInClusterResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The information about ECS instances.
	EcsEntityList *ListEcsNotInClusterResponseBodyEcsEntityList `json:"EcsEntityList,omitempty" xml:"EcsEntityList,omitempty" type:"Struct"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListEcsNotInClusterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListEcsNotInClusterResponseBody) GoString() string {
	return s.String()
}

func (s *ListEcsNotInClusterResponseBody) SetCode(v int32) *ListEcsNotInClusterResponseBody {
	s.Code = &v
	return s
}

func (s *ListEcsNotInClusterResponseBody) SetEcsEntityList(v *ListEcsNotInClusterResponseBodyEcsEntityList) *ListEcsNotInClusterResponseBody {
	s.EcsEntityList = v
	return s
}

func (s *ListEcsNotInClusterResponseBody) SetMessage(v string) *ListEcsNotInClusterResponseBody {
	s.Message = &v
	return s
}

func (s *ListEcsNotInClusterResponseBody) SetRequestId(v string) *ListEcsNotInClusterResponseBody {
	s.RequestId = &v
	return s
}

type ListEcsNotInClusterResponseBodyEcsEntityList struct {
	EcsEntity []*ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity `json:"EcsEntity,omitempty" xml:"EcsEntity,omitempty" type:"Repeated"`
}

func (s ListEcsNotInClusterResponseBodyEcsEntityList) String() string {
	return tea.Prettify(s)
}

func (s ListEcsNotInClusterResponseBodyEcsEntityList) GoString() string {
	return s.String()
}

func (s *ListEcsNotInClusterResponseBodyEcsEntityList) SetEcsEntity(v []*ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity) *ListEcsNotInClusterResponseBodyEcsEntityList {
	s.EcsEntity = v
	return s
}

type ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity struct {
	// The number of CPU cores.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The elastic IP address (EIP) associated with the ECS instance.
	Eip *string `json:"Eip,omitempty" xml:"Eip,omitempty"`
	// Indicates whether the ECS instance has expired. Valid values:
	//
	// *   **true**: The ECS instance has expired.
	// *   **false**: The ECS instance has not expired.
	Expired *bool `json:"Expired,omitempty" xml:"Expired,omitempty"`
	// The private IP address of the ECS instance.
	InnerIp *string `json:"InnerIp,omitempty" xml:"InnerIp,omitempty"`
	// The ID of the ECS instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The name of the ECS instance.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// The size of memory. Unit: bytes.
	Mem *int32 `json:"Mem,omitempty" xml:"Mem,omitempty"`
	// The private IP address of the ECS instance.
	PrivateIp *string `json:"PrivateIp,omitempty" xml:"PrivateIp,omitempty"`
	// The public IP address of the ECS instance.
	PublicIp *string `json:"PublicIp,omitempty" xml:"PublicIp,omitempty"`
	// The ID of the region where the ECS instance is located.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The status of the ECS instance. Valid values:
	//
	// *   **Pending**: The ECS instance is being created.
	// *   **Running**: The ECS instance is running.
	// *   **Starting**: The ECS instance is being started.
	// *   **Stopping**: The ECS instance is being stopped.
	// *   **Stopped**: The ECS instance is stopped.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the VPC.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The name of the VPC.
	VpcName *string `json:"VpcName,omitempty" xml:"VpcName,omitempty"`
}

func (s ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity) String() string {
	return tea.Prettify(s)
}

func (s ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity) GoString() string {
	return s.String()
}

func (s *ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity) SetCpu(v int32) *ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity {
	s.Cpu = &v
	return s
}

func (s *ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity) SetEip(v string) *ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity {
	s.Eip = &v
	return s
}

func (s *ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity) SetExpired(v bool) *ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity {
	s.Expired = &v
	return s
}

func (s *ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity) SetInnerIp(v string) *ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity {
	s.InnerIp = &v
	return s
}

func (s *ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity) SetInstanceId(v string) *ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity {
	s.InstanceId = &v
	return s
}

func (s *ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity) SetInstanceName(v string) *ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity {
	s.InstanceName = &v
	return s
}

func (s *ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity) SetMem(v int32) *ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity {
	s.Mem = &v
	return s
}

func (s *ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity) SetPrivateIp(v string) *ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity {
	s.PrivateIp = &v
	return s
}

func (s *ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity) SetPublicIp(v string) *ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity {
	s.PublicIp = &v
	return s
}

func (s *ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity) SetRegionId(v string) *ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity {
	s.RegionId = &v
	return s
}

func (s *ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity) SetStatus(v string) *ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity {
	s.Status = &v
	return s
}

func (s *ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity) SetVpcId(v string) *ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity {
	s.VpcId = &v
	return s
}

func (s *ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity) SetVpcName(v string) *ListEcsNotInClusterResponseBodyEcsEntityListEcsEntity {
	s.VpcName = &v
	return s
}

type ListEcsNotInClusterResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListEcsNotInClusterResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListEcsNotInClusterResponse) String() string {
	return tea.Prettify(s)
}

func (s ListEcsNotInClusterResponse) GoString() string {
	return s.String()
}

func (s *ListEcsNotInClusterResponse) SetHeaders(v map[string]*string) *ListEcsNotInClusterResponse {
	s.Headers = v
	return s
}

func (s *ListEcsNotInClusterResponse) SetStatusCode(v int32) *ListEcsNotInClusterResponse {
	s.StatusCode = &v
	return s
}

func (s *ListEcsNotInClusterResponse) SetBody(v *ListEcsNotInClusterResponseBody) *ListEcsNotInClusterResponse {
	s.Body = v
	return s
}

type ListEcuByRegionRequest struct {
	// Set the value to `pop-query`.
	Act *string `json:"Act,omitempty" xml:"Act,omitempty"`
	// The ID of the namespace.
	//
	// *   The ID of a custom namespace is in the `region ID:namespace identifier` format. Example: cn-beijing:tdy218.
	// *   The ID of the default namespace is in the `region ID` format. Example: cn-beijing.
	LogicalRegionId *string `json:"LogicalRegionId,omitempty" xml:"LogicalRegionId,omitempty"`
}

func (s ListEcuByRegionRequest) String() string {
	return tea.Prettify(s)
}

func (s ListEcuByRegionRequest) GoString() string {
	return s.String()
}

func (s *ListEcuByRegionRequest) SetAct(v string) *ListEcuByRegionRequest {
	s.Act = &v
	return s
}

func (s *ListEcuByRegionRequest) SetLogicalRegionId(v string) *ListEcuByRegionRequest {
	s.LogicalRegionId = &v
	return s
}

type ListEcuByRegionResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The information about ECUs.
	EcuEntityList *ListEcuByRegionResponseBodyEcuEntityList `json:"EcuEntityList,omitempty" xml:"EcuEntityList,omitempty" type:"Struct"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListEcuByRegionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListEcuByRegionResponseBody) GoString() string {
	return s.String()
}

func (s *ListEcuByRegionResponseBody) SetCode(v int32) *ListEcuByRegionResponseBody {
	s.Code = &v
	return s
}

func (s *ListEcuByRegionResponseBody) SetEcuEntityList(v *ListEcuByRegionResponseBodyEcuEntityList) *ListEcuByRegionResponseBody {
	s.EcuEntityList = v
	return s
}

func (s *ListEcuByRegionResponseBody) SetMessage(v string) *ListEcuByRegionResponseBody {
	s.Message = &v
	return s
}

func (s *ListEcuByRegionResponseBody) SetRequestId(v string) *ListEcuByRegionResponseBody {
	s.RequestId = &v
	return s
}

type ListEcuByRegionResponseBodyEcuEntityList struct {
	EcuEntity []*ListEcuByRegionResponseBodyEcuEntityListEcuEntity `json:"EcuEntity,omitempty" xml:"EcuEntity,omitempty" type:"Repeated"`
}

func (s ListEcuByRegionResponseBodyEcuEntityList) String() string {
	return tea.Prettify(s)
}

func (s ListEcuByRegionResponseBodyEcuEntityList) GoString() string {
	return s.String()
}

func (s *ListEcuByRegionResponseBodyEcuEntityList) SetEcuEntity(v []*ListEcuByRegionResponseBodyEcuEntityListEcuEntity) *ListEcuByRegionResponseBodyEcuEntityList {
	s.EcuEntity = v
	return s
}

type ListEcuByRegionResponseBodyEcuEntityListEcuEntity struct {
	// The number of available CPU cores for the ECU.
	AvailableCpu *int32 `json:"AvailableCpu,omitempty" xml:"AvailableCpu,omitempty"`
	// The size of available memory for the ECU. Unit: MB.
	AvailableMem *int32 `json:"AvailableMem,omitempty" xml:"AvailableMem,omitempty"`
	// The total number of CPU cores.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The timestamp when the ECU was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// Indicates whether Docker is installed. Valid values:
	//
	// *   true: Docker is installed.
	// *   false: Docker is not installed.
	DockerEnv *bool `json:"DockerEnv,omitempty" xml:"DockerEnv,omitempty"`
	// The unique ID of the ECU. To query the ID, you can run the `dmidecode` command on the ECS instance that corresponds to the ECU.
	EcuId *string `json:"EcuId,omitempty" xml:"EcuId,omitempty"`
	// The timestamp when the last heartbeat detection was performed. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	HeartbeatTime *int64 `json:"HeartbeatTime,omitempty" xml:"HeartbeatTime,omitempty"`
	// The ID of the ECU.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The private IP address of the ECU.
	IpAddr *string `json:"IpAddr,omitempty" xml:"IpAddr,omitempty"`
	// The total size of memory. Unit: MB.
	Mem *int32 `json:"Mem,omitempty" xml:"Mem,omitempty"`
	// The name of the ECU.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Indicates whether the ECU is online. Valid values:
	//
	// *   true: The ECU is online.
	// *   false: The ECU is offline.
	Online *bool `json:"Online,omitempty" xml:"Online,omitempty"`
	// The ID of the region in which the ECU resides.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The timestamp when the ECU was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The ID of the Alibaba Cloud account.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The ID of the virtual private cloud (VPC) in which the ECU resides.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The ID of the zone in which the ECU resides.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s ListEcuByRegionResponseBodyEcuEntityListEcuEntity) String() string {
	return tea.Prettify(s)
}

func (s ListEcuByRegionResponseBodyEcuEntityListEcuEntity) GoString() string {
	return s.String()
}

func (s *ListEcuByRegionResponseBodyEcuEntityListEcuEntity) SetAvailableCpu(v int32) *ListEcuByRegionResponseBodyEcuEntityListEcuEntity {
	s.AvailableCpu = &v
	return s
}

func (s *ListEcuByRegionResponseBodyEcuEntityListEcuEntity) SetAvailableMem(v int32) *ListEcuByRegionResponseBodyEcuEntityListEcuEntity {
	s.AvailableMem = &v
	return s
}

func (s *ListEcuByRegionResponseBodyEcuEntityListEcuEntity) SetCpu(v int32) *ListEcuByRegionResponseBodyEcuEntityListEcuEntity {
	s.Cpu = &v
	return s
}

func (s *ListEcuByRegionResponseBodyEcuEntityListEcuEntity) SetCreateTime(v int64) *ListEcuByRegionResponseBodyEcuEntityListEcuEntity {
	s.CreateTime = &v
	return s
}

func (s *ListEcuByRegionResponseBodyEcuEntityListEcuEntity) SetDockerEnv(v bool) *ListEcuByRegionResponseBodyEcuEntityListEcuEntity {
	s.DockerEnv = &v
	return s
}

func (s *ListEcuByRegionResponseBodyEcuEntityListEcuEntity) SetEcuId(v string) *ListEcuByRegionResponseBodyEcuEntityListEcuEntity {
	s.EcuId = &v
	return s
}

func (s *ListEcuByRegionResponseBodyEcuEntityListEcuEntity) SetHeartbeatTime(v int64) *ListEcuByRegionResponseBodyEcuEntityListEcuEntity {
	s.HeartbeatTime = &v
	return s
}

func (s *ListEcuByRegionResponseBodyEcuEntityListEcuEntity) SetInstanceId(v string) *ListEcuByRegionResponseBodyEcuEntityListEcuEntity {
	s.InstanceId = &v
	return s
}

func (s *ListEcuByRegionResponseBodyEcuEntityListEcuEntity) SetIpAddr(v string) *ListEcuByRegionResponseBodyEcuEntityListEcuEntity {
	s.IpAddr = &v
	return s
}

func (s *ListEcuByRegionResponseBodyEcuEntityListEcuEntity) SetMem(v int32) *ListEcuByRegionResponseBodyEcuEntityListEcuEntity {
	s.Mem = &v
	return s
}

func (s *ListEcuByRegionResponseBodyEcuEntityListEcuEntity) SetName(v string) *ListEcuByRegionResponseBodyEcuEntityListEcuEntity {
	s.Name = &v
	return s
}

func (s *ListEcuByRegionResponseBodyEcuEntityListEcuEntity) SetOnline(v bool) *ListEcuByRegionResponseBodyEcuEntityListEcuEntity {
	s.Online = &v
	return s
}

func (s *ListEcuByRegionResponseBodyEcuEntityListEcuEntity) SetRegionId(v string) *ListEcuByRegionResponseBodyEcuEntityListEcuEntity {
	s.RegionId = &v
	return s
}

func (s *ListEcuByRegionResponseBodyEcuEntityListEcuEntity) SetUpdateTime(v int64) *ListEcuByRegionResponseBodyEcuEntityListEcuEntity {
	s.UpdateTime = &v
	return s
}

func (s *ListEcuByRegionResponseBodyEcuEntityListEcuEntity) SetUserId(v string) *ListEcuByRegionResponseBodyEcuEntityListEcuEntity {
	s.UserId = &v
	return s
}

func (s *ListEcuByRegionResponseBodyEcuEntityListEcuEntity) SetVpcId(v string) *ListEcuByRegionResponseBodyEcuEntityListEcuEntity {
	s.VpcId = &v
	return s
}

func (s *ListEcuByRegionResponseBodyEcuEntityListEcuEntity) SetZoneId(v string) *ListEcuByRegionResponseBodyEcuEntityListEcuEntity {
	s.ZoneId = &v
	return s
}

type ListEcuByRegionResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListEcuByRegionResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListEcuByRegionResponse) String() string {
	return tea.Prettify(s)
}

func (s ListEcuByRegionResponse) GoString() string {
	return s.String()
}

func (s *ListEcuByRegionResponse) SetHeaders(v map[string]*string) *ListEcuByRegionResponse {
	s.Headers = v
	return s
}

func (s *ListEcuByRegionResponse) SetStatusCode(v int32) *ListEcuByRegionResponse {
	s.StatusCode = &v
	return s
}

func (s *ListEcuByRegionResponse) SetBody(v *ListEcuByRegionResponseBody) *ListEcuByRegionResponse {
	s.Body = v
	return s
}

type ListHistoryDeployVersionRequest struct {
	// The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
}

func (s ListHistoryDeployVersionRequest) String() string {
	return tea.Prettify(s)
}

func (s ListHistoryDeployVersionRequest) GoString() string {
	return s.String()
}

func (s *ListHistoryDeployVersionRequest) SetAppId(v string) *ListHistoryDeployVersionRequest {
	s.AppId = &v
	return s
}

type ListHistoryDeployVersionResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The information about historical deployment packages.
	PackageVersionList *ListHistoryDeployVersionResponseBodyPackageVersionList `json:"PackageVersionList,omitempty" xml:"PackageVersionList,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListHistoryDeployVersionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListHistoryDeployVersionResponseBody) GoString() string {
	return s.String()
}

func (s *ListHistoryDeployVersionResponseBody) SetCode(v int32) *ListHistoryDeployVersionResponseBody {
	s.Code = &v
	return s
}

func (s *ListHistoryDeployVersionResponseBody) SetMessage(v string) *ListHistoryDeployVersionResponseBody {
	s.Message = &v
	return s
}

func (s *ListHistoryDeployVersionResponseBody) SetPackageVersionList(v *ListHistoryDeployVersionResponseBodyPackageVersionList) *ListHistoryDeployVersionResponseBody {
	s.PackageVersionList = v
	return s
}

func (s *ListHistoryDeployVersionResponseBody) SetRequestId(v string) *ListHistoryDeployVersionResponseBody {
	s.RequestId = &v
	return s
}

type ListHistoryDeployVersionResponseBodyPackageVersionList struct {
	PackageVersion []*ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion `json:"PackageVersion,omitempty" xml:"PackageVersion,omitempty" type:"Repeated"`
}

func (s ListHistoryDeployVersionResponseBodyPackageVersionList) String() string {
	return tea.Prettify(s)
}

func (s ListHistoryDeployVersionResponseBodyPackageVersionList) GoString() string {
	return s.String()
}

func (s *ListHistoryDeployVersionResponseBodyPackageVersionList) SetPackageVersion(v []*ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion) *ListHistoryDeployVersionResponseBodyPackageVersionList {
	s.PackageVersion = v
	return s
}

type ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The time when the deployment package was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The description of the deployment package.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The unique ID of the deployment package.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The version of the application that was released by using the deployment package. This version can be used to call the RollbackApplication operation.
	PackageVersion *string `json:"PackageVersion,omitempty" xml:"PackageVersion,omitempty"`
	// The URL of the deployment package.
	PublicUrl *string `json:"PublicUrl,omitempty" xml:"PublicUrl,omitempty"`
	// The deployment mode of the application. Valid values:
	//
	// *   url: The application is deployed by using a JAR or WAR package.
	// *   image: The application is deployed by using an image.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The time when the deployment package was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The URL of the deployment package.
	WarUrl *string `json:"WarUrl,omitempty" xml:"WarUrl,omitempty"`
}

func (s ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion) String() string {
	return tea.Prettify(s)
}

func (s ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion) GoString() string {
	return s.String()
}

func (s *ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion) SetAppId(v string) *ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion {
	s.AppId = &v
	return s
}

func (s *ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion) SetCreateTime(v int64) *ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion {
	s.CreateTime = &v
	return s
}

func (s *ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion) SetDescription(v string) *ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion {
	s.Description = &v
	return s
}

func (s *ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion) SetId(v string) *ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion {
	s.Id = &v
	return s
}

func (s *ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion) SetPackageVersion(v string) *ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion {
	s.PackageVersion = &v
	return s
}

func (s *ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion) SetPublicUrl(v string) *ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion {
	s.PublicUrl = &v
	return s
}

func (s *ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion) SetType(v string) *ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion {
	s.Type = &v
	return s
}

func (s *ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion) SetUpdateTime(v int64) *ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion {
	s.UpdateTime = &v
	return s
}

func (s *ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion) SetWarUrl(v string) *ListHistoryDeployVersionResponseBodyPackageVersionListPackageVersion {
	s.WarUrl = &v
	return s
}

type ListHistoryDeployVersionResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListHistoryDeployVersionResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListHistoryDeployVersionResponse) String() string {
	return tea.Prettify(s)
}

func (s ListHistoryDeployVersionResponse) GoString() string {
	return s.String()
}

func (s *ListHistoryDeployVersionResponse) SetHeaders(v map[string]*string) *ListHistoryDeployVersionResponse {
	s.Headers = v
	return s
}

func (s *ListHistoryDeployVersionResponse) SetStatusCode(v int32) *ListHistoryDeployVersionResponse {
	s.StatusCode = &v
	return s
}

func (s *ListHistoryDeployVersionResponse) SetBody(v *ListHistoryDeployVersionResponseBody) *ListHistoryDeployVersionResponse {
	s.Body = v
	return s
}

type ListK8sConfigMapsRequest struct {
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The filter conditions. Set this parameter to a JSON string in the format of {"field":"Name", "pattern":"configmap-"}.
	Condition map[string]interface{} `json:"Condition,omitempty" xml:"Condition,omitempty"`
	// The namespace of the Kubernetes cluster.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The number of the page to return. Pages start from Page 0.
	PageNo *int32 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Specifies whether to return a list of applications that use a ConfigMap. Valid values: true and false.
	ShowRelatedApps *bool `json:"ShowRelatedApps,omitempty" xml:"ShowRelatedApps,omitempty"`
}

func (s ListK8sConfigMapsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListK8sConfigMapsRequest) GoString() string {
	return s.String()
}

func (s *ListK8sConfigMapsRequest) SetClusterId(v string) *ListK8sConfigMapsRequest {
	s.ClusterId = &v
	return s
}

func (s *ListK8sConfigMapsRequest) SetCondition(v map[string]interface{}) *ListK8sConfigMapsRequest {
	s.Condition = v
	return s
}

func (s *ListK8sConfigMapsRequest) SetNamespace(v string) *ListK8sConfigMapsRequest {
	s.Namespace = &v
	return s
}

func (s *ListK8sConfigMapsRequest) SetPageNo(v int32) *ListK8sConfigMapsRequest {
	s.PageNo = &v
	return s
}

func (s *ListK8sConfigMapsRequest) SetPageSize(v int32) *ListK8sConfigMapsRequest {
	s.PageSize = &v
	return s
}

func (s *ListK8sConfigMapsRequest) SetRegionId(v string) *ListK8sConfigMapsRequest {
	s.RegionId = &v
	return s
}

func (s *ListK8sConfigMapsRequest) SetShowRelatedApps(v bool) *ListK8sConfigMapsRequest {
	s.ShowRelatedApps = &v
	return s
}

type ListK8sConfigMapsResponseBody struct {
	// The HTTP status code.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The query results that are returned.
	Result *ListK8sConfigMapsResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s ListK8sConfigMapsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListK8sConfigMapsResponseBody) GoString() string {
	return s.String()
}

func (s *ListK8sConfigMapsResponseBody) SetCode(v int32) *ListK8sConfigMapsResponseBody {
	s.Code = &v
	return s
}

func (s *ListK8sConfigMapsResponseBody) SetMessage(v string) *ListK8sConfigMapsResponseBody {
	s.Message = &v
	return s
}

func (s *ListK8sConfigMapsResponseBody) SetRequestId(v string) *ListK8sConfigMapsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListK8sConfigMapsResponseBody) SetResult(v *ListK8sConfigMapsResponseBodyResult) *ListK8sConfigMapsResponseBody {
	s.Result = v
	return s
}

type ListK8sConfigMapsResponseBodyResult struct {
	// The information about ConfigMaps.
	ConfigMaps []*ListK8sConfigMapsResponseBodyResultConfigMaps `json:"ConfigMaps,omitempty" xml:"ConfigMaps,omitempty" type:"Repeated"`
	// The total number of entries that are returned.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListK8sConfigMapsResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListK8sConfigMapsResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListK8sConfigMapsResponseBodyResult) SetConfigMaps(v []*ListK8sConfigMapsResponseBodyResultConfigMaps) *ListK8sConfigMapsResponseBodyResult {
	s.ConfigMaps = v
	return s
}

func (s *ListK8sConfigMapsResponseBodyResult) SetTotal(v int32) *ListK8sConfigMapsResponseBodyResult {
	s.Total = &v
	return s
}

type ListK8sConfigMapsResponseBodyResultConfigMaps struct {
	// The ID of the Kubernetes cluster. You can obtain the cluster ID by calling the GetK8sCluster operation. For more information, see [GetK8sCluster](~~181437~~).
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the cluster.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The time when the ConfigMaps were created. The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The information about ConfigMaps.
	Data []*ListK8sConfigMapsResponseBodyResultConfigMapsData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The name of the ConfigMap.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace of the Kubernetes cluster.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The related applications.
	RelatedApps []*ListK8sConfigMapsResponseBodyResultConfigMapsRelatedApps `json:"RelatedApps,omitempty" xml:"RelatedApps,omitempty" type:"Repeated"`
}

func (s ListK8sConfigMapsResponseBodyResultConfigMaps) String() string {
	return tea.Prettify(s)
}

func (s ListK8sConfigMapsResponseBodyResultConfigMaps) GoString() string {
	return s.String()
}

func (s *ListK8sConfigMapsResponseBodyResultConfigMaps) SetClusterId(v string) *ListK8sConfigMapsResponseBodyResultConfigMaps {
	s.ClusterId = &v
	return s
}

func (s *ListK8sConfigMapsResponseBodyResultConfigMaps) SetClusterName(v string) *ListK8sConfigMapsResponseBodyResultConfigMaps {
	s.ClusterName = &v
	return s
}

func (s *ListK8sConfigMapsResponseBodyResultConfigMaps) SetCreationTime(v string) *ListK8sConfigMapsResponseBodyResultConfigMaps {
	s.CreationTime = &v
	return s
}

func (s *ListK8sConfigMapsResponseBodyResultConfigMaps) SetData(v []*ListK8sConfigMapsResponseBodyResultConfigMapsData) *ListK8sConfigMapsResponseBodyResultConfigMaps {
	s.Data = v
	return s
}

func (s *ListK8sConfigMapsResponseBodyResultConfigMaps) SetName(v string) *ListK8sConfigMapsResponseBodyResultConfigMaps {
	s.Name = &v
	return s
}

func (s *ListK8sConfigMapsResponseBodyResultConfigMaps) SetNamespace(v string) *ListK8sConfigMapsResponseBodyResultConfigMaps {
	s.Namespace = &v
	return s
}

func (s *ListK8sConfigMapsResponseBodyResultConfigMaps) SetRelatedApps(v []*ListK8sConfigMapsResponseBodyResultConfigMapsRelatedApps) *ListK8sConfigMapsResponseBodyResultConfigMaps {
	s.RelatedApps = v
	return s
}

type ListK8sConfigMapsResponseBodyResultConfigMapsData struct {
	// The user-defined key that is stored in the ConfigMap.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The user-defined value that is stored in the ConfigMap.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListK8sConfigMapsResponseBodyResultConfigMapsData) String() string {
	return tea.Prettify(s)
}

func (s ListK8sConfigMapsResponseBodyResultConfigMapsData) GoString() string {
	return s.String()
}

func (s *ListK8sConfigMapsResponseBodyResultConfigMapsData) SetKey(v string) *ListK8sConfigMapsResponseBodyResultConfigMapsData {
	s.Key = &v
	return s
}

func (s *ListK8sConfigMapsResponseBodyResultConfigMapsData) SetValue(v string) *ListK8sConfigMapsResponseBodyResultConfigMapsData {
	s.Value = &v
	return s
}

type ListK8sConfigMapsResponseBodyResultConfigMapsRelatedApps struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
}

func (s ListK8sConfigMapsResponseBodyResultConfigMapsRelatedApps) String() string {
	return tea.Prettify(s)
}

func (s ListK8sConfigMapsResponseBodyResultConfigMapsRelatedApps) GoString() string {
	return s.String()
}

func (s *ListK8sConfigMapsResponseBodyResultConfigMapsRelatedApps) SetAppId(v string) *ListK8sConfigMapsResponseBodyResultConfigMapsRelatedApps {
	s.AppId = &v
	return s
}

func (s *ListK8sConfigMapsResponseBodyResultConfigMapsRelatedApps) SetAppName(v string) *ListK8sConfigMapsResponseBodyResultConfigMapsRelatedApps {
	s.AppName = &v
	return s
}

type ListK8sConfigMapsResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListK8sConfigMapsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListK8sConfigMapsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListK8sConfigMapsResponse) GoString() string {
	return s.String()
}

func (s *ListK8sConfigMapsResponse) SetHeaders(v map[string]*string) *ListK8sConfigMapsResponse {
	s.Headers = v
	return s
}

func (s *ListK8sConfigMapsResponse) SetStatusCode(v int32) *ListK8sConfigMapsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListK8sConfigMapsResponse) SetBody(v *ListK8sConfigMapsResponseBody) *ListK8sConfigMapsResponse {
	s.Body = v
	return s
}

type ListK8sIngressRulesRequest struct {
	// The cluster ID.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The filter conditions. Set the value to a JSON string in the format of {"field":"Name", "pattern":"my-"}, where:
	//
	// *   field: the parameter to be matched. Valid values: Name and ClusterName.
	// *   pattern: the content to be matched.
	//
	// For example, a value of {"field":"Name", "pattern":"my-"} indicates that the specified filter conditions match the routing rules whose names start with my-.
	Condition *string `json:"Condition,omitempty" xml:"Condition,omitempty"`
	// The namespace of the Kubernetes cluster.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The ID of the region where the cluster resides.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListK8sIngressRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListK8sIngressRulesRequest) GoString() string {
	return s.String()
}

func (s *ListK8sIngressRulesRequest) SetClusterId(v string) *ListK8sIngressRulesRequest {
	s.ClusterId = &v
	return s
}

func (s *ListK8sIngressRulesRequest) SetCondition(v string) *ListK8sIngressRulesRequest {
	s.Condition = &v
	return s
}

func (s *ListK8sIngressRulesRequest) SetNamespace(v string) *ListK8sIngressRulesRequest {
	s.Namespace = &v
	return s
}

func (s *ListK8sIngressRulesRequest) SetRegionId(v string) *ListK8sIngressRulesRequest {
	s.RegionId = &v
	return s
}

type ListK8sIngressRulesResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The response data.
	Data []*ListK8sIngressRulesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListK8sIngressRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListK8sIngressRulesResponseBody) GoString() string {
	return s.String()
}

func (s *ListK8sIngressRulesResponseBody) SetCode(v int32) *ListK8sIngressRulesResponseBody {
	s.Code = &v
	return s
}

func (s *ListK8sIngressRulesResponseBody) SetData(v []*ListK8sIngressRulesResponseBodyData) *ListK8sIngressRulesResponseBody {
	s.Data = v
	return s
}

func (s *ListK8sIngressRulesResponseBody) SetMessage(v string) *ListK8sIngressRulesResponseBody {
	s.Message = &v
	return s
}

func (s *ListK8sIngressRulesResponseBody) SetRequestId(v string) *ListK8sIngressRulesResponseBody {
	s.RequestId = &v
	return s
}

type ListK8sIngressRulesResponseBodyData struct {
	// The cluster ID.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The cluster name.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The Ingresses.
	IngressConfs []*ListK8sIngressRulesResponseBodyDataIngressConfs `json:"IngressConfs,omitempty" xml:"IngressConfs,omitempty" type:"Repeated"`
	// The ID of the Alibaba Cloud region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s ListK8sIngressRulesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListK8sIngressRulesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListK8sIngressRulesResponseBodyData) SetClusterId(v string) *ListK8sIngressRulesResponseBodyData {
	s.ClusterId = &v
	return s
}

func (s *ListK8sIngressRulesResponseBodyData) SetClusterName(v string) *ListK8sIngressRulesResponseBodyData {
	s.ClusterName = &v
	return s
}

func (s *ListK8sIngressRulesResponseBodyData) SetIngressConfs(v []*ListK8sIngressRulesResponseBodyDataIngressConfs) *ListK8sIngressRulesResponseBodyData {
	s.IngressConfs = v
	return s
}

func (s *ListK8sIngressRulesResponseBodyData) SetRegionId(v string) *ListK8sIngressRulesResponseBodyData {
	s.RegionId = &v
	return s
}

type ListK8sIngressRulesResponseBodyDataIngressConfs struct {
	// The ID of the ALB instance.
	AlbId *string `json:"AlbId,omitempty" xml:"AlbId,omitempty"`
	// The annotations.
	Annotations *string `json:"Annotations,omitempty" xml:"Annotations,omitempty"`
	// The time when the Ingress was created.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The monitoring URL of the Ingress.
	DashboardUrl *string `json:"DashboardUrl,omitempty" xml:"DashboardUrl,omitempty"`
	// The IP address of the Ingress.
	Endpoint *string `json:"Endpoint,omitempty" xml:"Endpoint,omitempty"`
	// The Ingress type. Valid values:
	//
	// *   **NginxIngress**: NGINX Ingress controller
	// *   **AlbIngress**: ALB Ingress controller
	//
	// Default value: NginxIngress.
	IngressType *string `json:"IngressType,omitempty" xml:"IngressType,omitempty"`
	// The tags.
	Labels *string `json:"Labels,omitempty" xml:"Labels,omitempty"`
	// The ID of the MSE gateway.
	MseGatewayId *string `json:"MseGatewayId,omitempty" xml:"MseGatewayId,omitempty"`
	// The name of the MSE gateway.
	MseGatewayName *string `json:"MseGatewayName,omitempty" xml:"MseGatewayName,omitempty"`
	// The Ingress name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The Kubernetes namespace to which the Ingress belongs.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The URL used for basic monitoring of the open source version.
	OfficalBasicUrl *string `json:"OfficalBasicUrl,omitempty" xml:"OfficalBasicUrl,omitempty"`
	// The URL used for request performance monitoring of the open source version.
	OfficalRequestUrl *string `json:"OfficalRequestUrl,omitempty" xml:"OfficalRequestUrl,omitempty"`
	// The routing rules.
	Rules []*ListK8sIngressRulesResponseBodyDataIngressConfsRules `json:"Rules,omitempty" xml:"Rules,omitempty" type:"Repeated"`
	// Indicates whether SSL redirection is enabled. Valid values:
	//
	// *   true
	// *   false
	SslRedirect *bool `json:"SslRedirect,omitempty" xml:"SslRedirect,omitempty"`
}

func (s ListK8sIngressRulesResponseBodyDataIngressConfs) String() string {
	return tea.Prettify(s)
}

func (s ListK8sIngressRulesResponseBodyDataIngressConfs) GoString() string {
	return s.String()
}

func (s *ListK8sIngressRulesResponseBodyDataIngressConfs) SetAlbId(v string) *ListK8sIngressRulesResponseBodyDataIngressConfs {
	s.AlbId = &v
	return s
}

func (s *ListK8sIngressRulesResponseBodyDataIngressConfs) SetAnnotations(v string) *ListK8sIngressRulesResponseBodyDataIngressConfs {
	s.Annotations = &v
	return s
}

func (s *ListK8sIngressRulesResponseBodyDataIngressConfs) SetCreationTime(v string) *ListK8sIngressRulesResponseBodyDataIngressConfs {
	s.CreationTime = &v
	return s
}

func (s *ListK8sIngressRulesResponseBodyDataIngressConfs) SetDashboardUrl(v string) *ListK8sIngressRulesResponseBodyDataIngressConfs {
	s.DashboardUrl = &v
	return s
}

func (s *ListK8sIngressRulesResponseBodyDataIngressConfs) SetEndpoint(v string) *ListK8sIngressRulesResponseBodyDataIngressConfs {
	s.Endpoint = &v
	return s
}

func (s *ListK8sIngressRulesResponseBodyDataIngressConfs) SetIngressType(v string) *ListK8sIngressRulesResponseBodyDataIngressConfs {
	s.IngressType = &v
	return s
}

func (s *ListK8sIngressRulesResponseBodyDataIngressConfs) SetLabels(v string) *ListK8sIngressRulesResponseBodyDataIngressConfs {
	s.Labels = &v
	return s
}

func (s *ListK8sIngressRulesResponseBodyDataIngressConfs) SetMseGatewayId(v string) *ListK8sIngressRulesResponseBodyDataIngressConfs {
	s.MseGatewayId = &v
	return s
}

func (s *ListK8sIngressRulesResponseBodyDataIngressConfs) SetMseGatewayName(v string) *ListK8sIngressRulesResponseBodyDataIngressConfs {
	s.MseGatewayName = &v
	return s
}

func (s *ListK8sIngressRulesResponseBodyDataIngressConfs) SetName(v string) *ListK8sIngressRulesResponseBodyDataIngressConfs {
	s.Name = &v
	return s
}

func (s *ListK8sIngressRulesResponseBodyDataIngressConfs) SetNamespace(v string) *ListK8sIngressRulesResponseBodyDataIngressConfs {
	s.Namespace = &v
	return s
}

func (s *ListK8sIngressRulesResponseBodyDataIngressConfs) SetOfficalBasicUrl(v string) *ListK8sIngressRulesResponseBodyDataIngressConfs {
	s.OfficalBasicUrl = &v
	return s
}

func (s *ListK8sIngressRulesResponseBodyDataIngressConfs) SetOfficalRequestUrl(v string) *ListK8sIngressRulesResponseBodyDataIngressConfs {
	s.OfficalRequestUrl = &v
	return s
}

func (s *ListK8sIngressRulesResponseBodyDataIngressConfs) SetRules(v []*ListK8sIngressRulesResponseBodyDataIngressConfsRules) *ListK8sIngressRulesResponseBodyDataIngressConfs {
	s.Rules = v
	return s
}

func (s *ListK8sIngressRulesResponseBodyDataIngressConfs) SetSslRedirect(v bool) *ListK8sIngressRulesResponseBodyDataIngressConfs {
	s.SslRedirect = &v
	return s
}

type ListK8sIngressRulesResponseBodyDataIngressConfsRules struct {
	// Indicates whether TLS is enabled. Valid values:
	//
	// *   true
	// *   false
	EnableTls *bool `json:"EnableTls,omitempty" xml:"EnableTls,omitempty"`
	// The domain name to be accessed.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The paths to be accessed.
	Paths []*ListK8sIngressRulesResponseBodyDataIngressConfsRulesPaths `json:"Paths,omitempty" xml:"Paths,omitempty" type:"Repeated"`
	// The name of the Secret that stores the Transport Layer Security (TLS) certificate.
	SecretName *string `json:"SecretName,omitempty" xml:"SecretName,omitempty"`
}

func (s ListK8sIngressRulesResponseBodyDataIngressConfsRules) String() string {
	return tea.Prettify(s)
}

func (s ListK8sIngressRulesResponseBodyDataIngressConfsRules) GoString() string {
	return s.String()
}

func (s *ListK8sIngressRulesResponseBodyDataIngressConfsRules) SetEnableTls(v bool) *ListK8sIngressRulesResponseBodyDataIngressConfsRules {
	s.EnableTls = &v
	return s
}

func (s *ListK8sIngressRulesResponseBodyDataIngressConfsRules) SetHost(v string) *ListK8sIngressRulesResponseBodyDataIngressConfsRules {
	s.Host = &v
	return s
}

func (s *ListK8sIngressRulesResponseBodyDataIngressConfsRules) SetPaths(v []*ListK8sIngressRulesResponseBodyDataIngressConfsRulesPaths) *ListK8sIngressRulesResponseBodyDataIngressConfsRules {
	s.Paths = v
	return s
}

func (s *ListK8sIngressRulesResponseBodyDataIngressConfsRules) SetSecretName(v string) *ListK8sIngressRulesResponseBodyDataIngressConfsRules {
	s.SecretName = &v
	return s
}

type ListK8sIngressRulesResponseBodyDataIngressConfsRulesPaths struct {
	// The ID of the EDAS application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the EDAS application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The configurations of the backend Service.
	Backend *ListK8sIngressRulesResponseBodyDataIngressConfsRulesPathsBackend `json:"Backend,omitempty" xml:"Backend,omitempty" type:"Struct"`
	// The collection rate that is set based on the trace query feature. You can add a trace ID to a gateway to use the trace query feature of EDAS.
	CollectRate *int32 `json:"CollectRate,omitempty" xml:"CollectRate,omitempty"`
	// The path to be accessed.
	Path *string `json:"Path,omitempty" xml:"Path,omitempty"`
	// The path type that determines how a path is matched.
	//
	// *   ImplementationSpecific (default)
	// *   Exact
	// *   Prefix
	PathType *string `json:"PathType,omitempty" xml:"PathType,omitempty"`
	// The state of the Ingress. Valid values:
	//
	// *   **Normal**: The Ingress works as expected.
	// *   **ServiceNotFound**: The backend Service does not exist.
	// *   **InvalidServicePort**: The Service port is invalid.
	// *   **NotManagedService**: The Service is not managed by EDAS.
	// *   **Unknown**: An unknown error occurred.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListK8sIngressRulesResponseBodyDataIngressConfsRulesPaths) String() string {
	return tea.Prettify(s)
}

func (s ListK8sIngressRulesResponseBodyDataIngressConfsRulesPaths) GoString() string {
	return s.String()
}

func (s *ListK8sIngressRulesResponseBodyDataIngressConfsRulesPaths) SetAppId(v string) *ListK8sIngressRulesResponseBodyDataIngressConfsRulesPaths {
	s.AppId = &v
	return s
}

func (s *ListK8sIngressRulesResponseBodyDataIngressConfsRulesPaths) SetAppName(v string) *ListK8sIngressRulesResponseBodyDataIngressConfsRulesPaths {
	s.AppName = &v
	return s
}

func (s *ListK8sIngressRulesResponseBodyDataIngressConfsRulesPaths) SetBackend(v *ListK8sIngressRulesResponseBodyDataIngressConfsRulesPathsBackend) *ListK8sIngressRulesResponseBodyDataIngressConfsRulesPaths {
	s.Backend = v
	return s
}

func (s *ListK8sIngressRulesResponseBodyDataIngressConfsRulesPaths) SetCollectRate(v int32) *ListK8sIngressRulesResponseBodyDataIngressConfsRulesPaths {
	s.CollectRate = &v
	return s
}

func (s *ListK8sIngressRulesResponseBodyDataIngressConfsRulesPaths) SetPath(v string) *ListK8sIngressRulesResponseBodyDataIngressConfsRulesPaths {
	s.Path = &v
	return s
}

func (s *ListK8sIngressRulesResponseBodyDataIngressConfsRulesPaths) SetPathType(v string) *ListK8sIngressRulesResponseBodyDataIngressConfsRulesPaths {
	s.PathType = &v
	return s
}

func (s *ListK8sIngressRulesResponseBodyDataIngressConfsRulesPaths) SetStatus(v string) *ListK8sIngressRulesResponseBodyDataIngressConfsRulesPaths {
	s.Status = &v
	return s
}

type ListK8sIngressRulesResponseBodyDataIngressConfsRulesPathsBackend struct {
	// The name of the backend Service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	// The port of the backend Service.
	ServicePort *string `json:"ServicePort,omitempty" xml:"ServicePort,omitempty"`
}

func (s ListK8sIngressRulesResponseBodyDataIngressConfsRulesPathsBackend) String() string {
	return tea.Prettify(s)
}

func (s ListK8sIngressRulesResponseBodyDataIngressConfsRulesPathsBackend) GoString() string {
	return s.String()
}

func (s *ListK8sIngressRulesResponseBodyDataIngressConfsRulesPathsBackend) SetServiceName(v string) *ListK8sIngressRulesResponseBodyDataIngressConfsRulesPathsBackend {
	s.ServiceName = &v
	return s
}

func (s *ListK8sIngressRulesResponseBodyDataIngressConfsRulesPathsBackend) SetServicePort(v string) *ListK8sIngressRulesResponseBodyDataIngressConfsRulesPathsBackend {
	s.ServicePort = &v
	return s
}

type ListK8sIngressRulesResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListK8sIngressRulesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListK8sIngressRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListK8sIngressRulesResponse) GoString() string {
	return s.String()
}

func (s *ListK8sIngressRulesResponse) SetHeaders(v map[string]*string) *ListK8sIngressRulesResponse {
	s.Headers = v
	return s
}

func (s *ListK8sIngressRulesResponse) SetStatusCode(v int32) *ListK8sIngressRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListK8sIngressRulesResponse) SetBody(v *ListK8sIngressRulesResponseBody) *ListK8sIngressRulesResponse {
	s.Body = v
	return s
}

type ListK8sNamespacesRequest struct {
	// The ID of the cluster in Enterprise Distributed Application Service (EDAS).
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
}

func (s ListK8sNamespacesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListK8sNamespacesRequest) GoString() string {
	return s.String()
}

func (s *ListK8sNamespacesRequest) SetClusterId(v string) *ListK8sNamespacesRequest {
	s.ClusterId = &v
	return s
}

type ListK8sNamespacesResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data that is returned.
	Data []*ListK8sNamespacesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The message returned for the request.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListK8sNamespacesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListK8sNamespacesResponseBody) GoString() string {
	return s.String()
}

func (s *ListK8sNamespacesResponseBody) SetCode(v int32) *ListK8sNamespacesResponseBody {
	s.Code = &v
	return s
}

func (s *ListK8sNamespacesResponseBody) SetData(v []*ListK8sNamespacesResponseBodyData) *ListK8sNamespacesResponseBody {
	s.Data = v
	return s
}

func (s *ListK8sNamespacesResponseBody) SetMessage(v string) *ListK8sNamespacesResponseBody {
	s.Message = &v
	return s
}

func (s *ListK8sNamespacesResponseBody) SetRequestId(v string) *ListK8sNamespacesResponseBody {
	s.RequestId = &v
	return s
}

type ListK8sNamespacesResponseBodyData struct {
	// The namespaces of the Kubernetes cluster.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
}

func (s ListK8sNamespacesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListK8sNamespacesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListK8sNamespacesResponseBodyData) SetNamespace(v string) *ListK8sNamespacesResponseBodyData {
	s.Namespace = &v
	return s
}

type ListK8sNamespacesResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListK8sNamespacesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListK8sNamespacesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListK8sNamespacesResponse) GoString() string {
	return s.String()
}

func (s *ListK8sNamespacesResponse) SetHeaders(v map[string]*string) *ListK8sNamespacesResponse {
	s.Headers = v
	return s
}

func (s *ListK8sNamespacesResponse) SetStatusCode(v int32) *ListK8sNamespacesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListK8sNamespacesResponse) SetBody(v *ListK8sNamespacesResponseBody) *ListK8sNamespacesResponse {
	s.Body = v
	return s
}

type ListK8sSecretsRequest struct {
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The filter conditions. Set this parameter to a JSON string in the format of {"field":"Name", "pattern":"configmap-"}.
	Condition *string `json:"Condition,omitempty" xml:"Condition,omitempty"`
	// The namespace of the Kubernetes cluster.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The number of the page to return. Pages start from Page 0.
	PageNo *int32 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The number of entries to return on each page. The value 0 indicates that all entries are returned on one page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Specifies whether to return a list of applications that use a Secret.
	ShowRelatedApps *bool `json:"ShowRelatedApps,omitempty" xml:"ShowRelatedApps,omitempty"`
}

func (s ListK8sSecretsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListK8sSecretsRequest) GoString() string {
	return s.String()
}

func (s *ListK8sSecretsRequest) SetClusterId(v string) *ListK8sSecretsRequest {
	s.ClusterId = &v
	return s
}

func (s *ListK8sSecretsRequest) SetCondition(v string) *ListK8sSecretsRequest {
	s.Condition = &v
	return s
}

func (s *ListK8sSecretsRequest) SetNamespace(v string) *ListK8sSecretsRequest {
	s.Namespace = &v
	return s
}

func (s *ListK8sSecretsRequest) SetPageNo(v int32) *ListK8sSecretsRequest {
	s.PageNo = &v
	return s
}

func (s *ListK8sSecretsRequest) SetPageSize(v int32) *ListK8sSecretsRequest {
	s.PageSize = &v
	return s
}

func (s *ListK8sSecretsRequest) SetRegionId(v string) *ListK8sSecretsRequest {
	s.RegionId = &v
	return s
}

func (s *ListK8sSecretsRequest) SetShowRelatedApps(v bool) *ListK8sSecretsRequest {
	s.ShowRelatedApps = &v
	return s
}

type ListK8sSecretsResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned query results of Kubernetes Secrets.
	Result *ListK8sSecretsResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Struct"`
}

func (s ListK8sSecretsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListK8sSecretsResponseBody) GoString() string {
	return s.String()
}

func (s *ListK8sSecretsResponseBody) SetCode(v int32) *ListK8sSecretsResponseBody {
	s.Code = &v
	return s
}

func (s *ListK8sSecretsResponseBody) SetMessage(v string) *ListK8sSecretsResponseBody {
	s.Message = &v
	return s
}

func (s *ListK8sSecretsResponseBody) SetRequestId(v string) *ListK8sSecretsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListK8sSecretsResponseBody) SetResult(v *ListK8sSecretsResponseBodyResult) *ListK8sSecretsResponseBody {
	s.Result = v
	return s
}

type ListK8sSecretsResponseBodyResult struct {
	// The information about Kubernetes Secrets.
	Secrets []*ListK8sSecretsResponseBodyResultSecrets `json:"Secrets,omitempty" xml:"Secrets,omitempty" type:"Repeated"`
	// The total number of entries that are returned.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListK8sSecretsResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s ListK8sSecretsResponseBodyResult) GoString() string {
	return s.String()
}

func (s *ListK8sSecretsResponseBodyResult) SetSecrets(v []*ListK8sSecretsResponseBodyResultSecrets) *ListK8sSecretsResponseBodyResult {
	s.Secrets = v
	return s
}

func (s *ListK8sSecretsResponseBodyResult) SetTotal(v int32) *ListK8sSecretsResponseBodyResult {
	s.Total = &v
	return s
}

type ListK8sSecretsResponseBodyResultSecrets struct {
	// Indicates whether the data is Base64-encoded. Valid values:
	//
	// *   true: The data is Base64-encoded.
	// *   false: The data is not Base64-encoded.
	Base64Encoded *bool `json:"Base64Encoded,omitempty" xml:"Base64Encoded,omitempty"`
	// The details of the Secure Sockets Layer (SSL) certificate.
	CertDetail *ListK8sSecretsResponseBodyResultSecretsCertDetail `json:"CertDetail,omitempty" xml:"CertDetail,omitempty" type:"Struct"`
	// The ID of the certificate provided by Alibaba Cloud Certificate Management Service.
	CertId *string `json:"CertId,omitempty" xml:"CertId,omitempty"`
	// The region in which the certificate is stored.
	CertRegionId *string `json:"CertRegionId,omitempty" xml:"CertRegionId,omitempty"`
	// The ID of the cluster in Enterprise Distributed Application Service (EDAS).
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the cluster.
	ClusterName *string `json:"ClusterName,omitempty" xml:"ClusterName,omitempty"`
	// The time when the Secret was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*hh:mm:ss*Z format. The time is displayed in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The data of the Kubernetes Secret.
	Data []*ListK8sSecretsResponseBodyResultSecretsData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The name of the Secret. The name must start with a letter, and can contain digits, letters, and hyphens (-). It can be up to 63 characters in length.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace of the Kubernetes cluster.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// Applications that use the Secret.
	RelatedApps []*ListK8sSecretsResponseBodyResultSecretsRelatedApps `json:"RelatedApps,omitempty" xml:"RelatedApps,omitempty" type:"Repeated"`
	// Rules in the Ingress that is associated with the Secret.
	RelatedIngressRules []*ListK8sSecretsResponseBodyResultSecretsRelatedIngressRules `json:"RelatedIngressRules,omitempty" xml:"RelatedIngressRules,omitempty" type:"Repeated"`
	// The type of the Secret. Valid values:
	//
	// *   Opaque: user-defined data
	// *   kubernetes.io/tls: Transport Layer Security (TLS) certificate
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListK8sSecretsResponseBodyResultSecrets) String() string {
	return tea.Prettify(s)
}

func (s ListK8sSecretsResponseBodyResultSecrets) GoString() string {
	return s.String()
}

func (s *ListK8sSecretsResponseBodyResultSecrets) SetBase64Encoded(v bool) *ListK8sSecretsResponseBodyResultSecrets {
	s.Base64Encoded = &v
	return s
}

func (s *ListK8sSecretsResponseBodyResultSecrets) SetCertDetail(v *ListK8sSecretsResponseBodyResultSecretsCertDetail) *ListK8sSecretsResponseBodyResultSecrets {
	s.CertDetail = v
	return s
}

func (s *ListK8sSecretsResponseBodyResultSecrets) SetCertId(v string) *ListK8sSecretsResponseBodyResultSecrets {
	s.CertId = &v
	return s
}

func (s *ListK8sSecretsResponseBodyResultSecrets) SetCertRegionId(v string) *ListK8sSecretsResponseBodyResultSecrets {
	s.CertRegionId = &v
	return s
}

func (s *ListK8sSecretsResponseBodyResultSecrets) SetClusterId(v string) *ListK8sSecretsResponseBodyResultSecrets {
	s.ClusterId = &v
	return s
}

func (s *ListK8sSecretsResponseBodyResultSecrets) SetClusterName(v string) *ListK8sSecretsResponseBodyResultSecrets {
	s.ClusterName = &v
	return s
}

func (s *ListK8sSecretsResponseBodyResultSecrets) SetCreationTime(v string) *ListK8sSecretsResponseBodyResultSecrets {
	s.CreationTime = &v
	return s
}

func (s *ListK8sSecretsResponseBodyResultSecrets) SetData(v []*ListK8sSecretsResponseBodyResultSecretsData) *ListK8sSecretsResponseBodyResultSecrets {
	s.Data = v
	return s
}

func (s *ListK8sSecretsResponseBodyResultSecrets) SetName(v string) *ListK8sSecretsResponseBodyResultSecrets {
	s.Name = &v
	return s
}

func (s *ListK8sSecretsResponseBodyResultSecrets) SetNamespace(v string) *ListK8sSecretsResponseBodyResultSecrets {
	s.Namespace = &v
	return s
}

func (s *ListK8sSecretsResponseBodyResultSecrets) SetRelatedApps(v []*ListK8sSecretsResponseBodyResultSecretsRelatedApps) *ListK8sSecretsResponseBodyResultSecrets {
	s.RelatedApps = v
	return s
}

func (s *ListK8sSecretsResponseBodyResultSecrets) SetRelatedIngressRules(v []*ListK8sSecretsResponseBodyResultSecretsRelatedIngressRules) *ListK8sSecretsResponseBodyResultSecrets {
	s.RelatedIngressRules = v
	return s
}

func (s *ListK8sSecretsResponseBodyResultSecrets) SetType(v string) *ListK8sSecretsResponseBodyResultSecrets {
	s.Type = &v
	return s
}

type ListK8sSecretsResponseBodyResultSecretsCertDetail struct {
	// Domain names that are associated with the SSL certificate.
	DomainNames []*string `json:"DomainNames,omitempty" xml:"DomainNames,omitempty" type:"Repeated"`
	// The time when the SSL certificate expired.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The certificate authority (CA) that issued the SSL certificate.
	Issuer *string `json:"Issuer,omitempty" xml:"Issuer,omitempty"`
	// The time when the SSL certificate started to take effect.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The state of the SSL certificate. Valid values:
	//
	// *   normal: The SSL certificate is valid.
	// *   invalid: The SSL certificate is invalid.
	// *   expired: The SSL certificate has expired.
	// *   not_yet_valid: The SSL certificate is currently invalid.
	// *   about_to_expire: The SSL certificate is about to expire.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListK8sSecretsResponseBodyResultSecretsCertDetail) String() string {
	return tea.Prettify(s)
}

func (s ListK8sSecretsResponseBodyResultSecretsCertDetail) GoString() string {
	return s.String()
}

func (s *ListK8sSecretsResponseBodyResultSecretsCertDetail) SetDomainNames(v []*string) *ListK8sSecretsResponseBodyResultSecretsCertDetail {
	s.DomainNames = v
	return s
}

func (s *ListK8sSecretsResponseBodyResultSecretsCertDetail) SetEndTime(v string) *ListK8sSecretsResponseBodyResultSecretsCertDetail {
	s.EndTime = &v
	return s
}

func (s *ListK8sSecretsResponseBodyResultSecretsCertDetail) SetIssuer(v string) *ListK8sSecretsResponseBodyResultSecretsCertDetail {
	s.Issuer = &v
	return s
}

func (s *ListK8sSecretsResponseBodyResultSecretsCertDetail) SetStartTime(v string) *ListK8sSecretsResponseBodyResultSecretsCertDetail {
	s.StartTime = &v
	return s
}

func (s *ListK8sSecretsResponseBodyResultSecretsCertDetail) SetStatus(v string) *ListK8sSecretsResponseBodyResultSecretsCertDetail {
	s.Status = &v
	return s
}

type ListK8sSecretsResponseBodyResultSecretsData struct {
	// The user-defined key of the Kubernetes Secret.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The user-defined value of the Kubernetes Secret.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListK8sSecretsResponseBodyResultSecretsData) String() string {
	return tea.Prettify(s)
}

func (s ListK8sSecretsResponseBodyResultSecretsData) GoString() string {
	return s.String()
}

func (s *ListK8sSecretsResponseBodyResultSecretsData) SetKey(v string) *ListK8sSecretsResponseBodyResultSecretsData {
	s.Key = &v
	return s
}

func (s *ListK8sSecretsResponseBodyResultSecretsData) SetValue(v string) *ListK8sSecretsResponseBodyResultSecretsData {
	s.Value = &v
	return s
}

type ListK8sSecretsResponseBodyResultSecretsRelatedApps struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
}

func (s ListK8sSecretsResponseBodyResultSecretsRelatedApps) String() string {
	return tea.Prettify(s)
}

func (s ListK8sSecretsResponseBodyResultSecretsRelatedApps) GoString() string {
	return s.String()
}

func (s *ListK8sSecretsResponseBodyResultSecretsRelatedApps) SetAppId(v string) *ListK8sSecretsResponseBodyResultSecretsRelatedApps {
	s.AppId = &v
	return s
}

func (s *ListK8sSecretsResponseBodyResultSecretsRelatedApps) SetAppName(v string) *ListK8sSecretsResponseBodyResultSecretsRelatedApps {
	s.AppName = &v
	return s
}

type ListK8sSecretsResponseBodyResultSecretsRelatedIngressRules struct {
	// The name of the rule in the Ingress.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespaces of the Kubernetes cluster.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// Aplications that are associated with the Ingress.
	RelatedApps []*ListK8sSecretsResponseBodyResultSecretsRelatedIngressRulesRelatedApps `json:"RelatedApps,omitempty" xml:"RelatedApps,omitempty" type:"Repeated"`
}

func (s ListK8sSecretsResponseBodyResultSecretsRelatedIngressRules) String() string {
	return tea.Prettify(s)
}

func (s ListK8sSecretsResponseBodyResultSecretsRelatedIngressRules) GoString() string {
	return s.String()
}

func (s *ListK8sSecretsResponseBodyResultSecretsRelatedIngressRules) SetName(v string) *ListK8sSecretsResponseBodyResultSecretsRelatedIngressRules {
	s.Name = &v
	return s
}

func (s *ListK8sSecretsResponseBodyResultSecretsRelatedIngressRules) SetNamespace(v string) *ListK8sSecretsResponseBodyResultSecretsRelatedIngressRules {
	s.Namespace = &v
	return s
}

func (s *ListK8sSecretsResponseBodyResultSecretsRelatedIngressRules) SetRelatedApps(v []*ListK8sSecretsResponseBodyResultSecretsRelatedIngressRulesRelatedApps) *ListK8sSecretsResponseBodyResultSecretsRelatedIngressRules {
	s.RelatedApps = v
	return s
}

type ListK8sSecretsResponseBodyResultSecretsRelatedIngressRulesRelatedApps struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the EDAS application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
}

func (s ListK8sSecretsResponseBodyResultSecretsRelatedIngressRulesRelatedApps) String() string {
	return tea.Prettify(s)
}

func (s ListK8sSecretsResponseBodyResultSecretsRelatedIngressRulesRelatedApps) GoString() string {
	return s.String()
}

func (s *ListK8sSecretsResponseBodyResultSecretsRelatedIngressRulesRelatedApps) SetAppId(v string) *ListK8sSecretsResponseBodyResultSecretsRelatedIngressRulesRelatedApps {
	s.AppId = &v
	return s
}

func (s *ListK8sSecretsResponseBodyResultSecretsRelatedIngressRulesRelatedApps) SetAppName(v string) *ListK8sSecretsResponseBodyResultSecretsRelatedIngressRulesRelatedApps {
	s.AppName = &v
	return s
}

type ListK8sSecretsResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListK8sSecretsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListK8sSecretsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListK8sSecretsResponse) GoString() string {
	return s.String()
}

func (s *ListK8sSecretsResponse) SetHeaders(v map[string]*string) *ListK8sSecretsResponse {
	s.Headers = v
	return s
}

func (s *ListK8sSecretsResponse) SetStatusCode(v int32) *ListK8sSecretsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListK8sSecretsResponse) SetBody(v *ListK8sSecretsResponseBody) *ListK8sSecretsResponse {
	s.Body = v
	return s
}

type ListMethodsRequest struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
}

func (s ListMethodsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListMethodsRequest) GoString() string {
	return s.String()
}

func (s *ListMethodsRequest) SetAppId(v string) *ListMethodsRequest {
	s.AppId = &v
	return s
}

func (s *ListMethodsRequest) SetServiceName(v string) *ListMethodsRequest {
	s.ServiceName = &v
	return s
}

type ListMethodsResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned message that indicates whether the request is successful.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about service methods.
	ServiceMethodList *ListMethodsResponseBodyServiceMethodList `json:"ServiceMethodList,omitempty" xml:"ServiceMethodList,omitempty" type:"Struct"`
}

func (s ListMethodsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListMethodsResponseBody) GoString() string {
	return s.String()
}

func (s *ListMethodsResponseBody) SetCode(v int32) *ListMethodsResponseBody {
	s.Code = &v
	return s
}

func (s *ListMethodsResponseBody) SetMessage(v string) *ListMethodsResponseBody {
	s.Message = &v
	return s
}

func (s *ListMethodsResponseBody) SetRequestId(v string) *ListMethodsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListMethodsResponseBody) SetServiceMethodList(v *ListMethodsResponseBodyServiceMethodList) *ListMethodsResponseBody {
	s.ServiceMethodList = v
	return s
}

type ListMethodsResponseBodyServiceMethodList struct {
	ServiceMethod []*ListMethodsResponseBodyServiceMethodListServiceMethod `json:"ServiceMethod,omitempty" xml:"ServiceMethod,omitempty" type:"Repeated"`
}

func (s ListMethodsResponseBodyServiceMethodList) String() string {
	return tea.Prettify(s)
}

func (s ListMethodsResponseBodyServiceMethodList) GoString() string {
	return s.String()
}

func (s *ListMethodsResponseBodyServiceMethodList) SetServiceMethod(v []*ListMethodsResponseBodyServiceMethodListServiceMethod) *ListMethodsResponseBodyServiceMethodList {
	s.ServiceMethod = v
	return s
}

type ListMethodsResponseBodyServiceMethodListServiceMethod struct {
	// The name of the application.
	AppName     *string                                                           `json:"AppName,omitempty" xml:"AppName,omitempty"`
	InputParams *ListMethodsResponseBodyServiceMethodListServiceMethodInputParams `json:"InputParams,omitempty" xml:"InputParams,omitempty" type:"Struct"`
	// The name of the service method.
	MethodName *string `json:"MethodName,omitempty" xml:"MethodName,omitempty"`
	// The return type of the service method.
	Output     *string                                                          `json:"Output,omitempty" xml:"Output,omitempty"`
	ParamTypes *ListMethodsResponseBodyServiceMethodListServiceMethodParamTypes `json:"ParamTypes,omitempty" xml:"ParamTypes,omitempty" type:"Struct"`
	// The name of the service.
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
}

func (s ListMethodsResponseBodyServiceMethodListServiceMethod) String() string {
	return tea.Prettify(s)
}

func (s ListMethodsResponseBodyServiceMethodListServiceMethod) GoString() string {
	return s.String()
}

func (s *ListMethodsResponseBodyServiceMethodListServiceMethod) SetAppName(v string) *ListMethodsResponseBodyServiceMethodListServiceMethod {
	s.AppName = &v
	return s
}

func (s *ListMethodsResponseBodyServiceMethodListServiceMethod) SetInputParams(v *ListMethodsResponseBodyServiceMethodListServiceMethodInputParams) *ListMethodsResponseBodyServiceMethodListServiceMethod {
	s.InputParams = v
	return s
}

func (s *ListMethodsResponseBodyServiceMethodListServiceMethod) SetMethodName(v string) *ListMethodsResponseBodyServiceMethodListServiceMethod {
	s.MethodName = &v
	return s
}

func (s *ListMethodsResponseBodyServiceMethodListServiceMethod) SetOutput(v string) *ListMethodsResponseBodyServiceMethodListServiceMethod {
	s.Output = &v
	return s
}

func (s *ListMethodsResponseBodyServiceMethodListServiceMethod) SetParamTypes(v *ListMethodsResponseBodyServiceMethodListServiceMethodParamTypes) *ListMethodsResponseBodyServiceMethodListServiceMethod {
	s.ParamTypes = v
	return s
}

func (s *ListMethodsResponseBodyServiceMethodListServiceMethod) SetServiceName(v string) *ListMethodsResponseBodyServiceMethodListServiceMethod {
	s.ServiceName = &v
	return s
}

type ListMethodsResponseBodyServiceMethodListServiceMethodInputParams struct {
	InputParam []*string `json:"InputParam,omitempty" xml:"InputParam,omitempty" type:"Repeated"`
}

func (s ListMethodsResponseBodyServiceMethodListServiceMethodInputParams) String() string {
	return tea.Prettify(s)
}

func (s ListMethodsResponseBodyServiceMethodListServiceMethodInputParams) GoString() string {
	return s.String()
}

func (s *ListMethodsResponseBodyServiceMethodListServiceMethodInputParams) SetInputParam(v []*string) *ListMethodsResponseBodyServiceMethodListServiceMethodInputParams {
	s.InputParam = v
	return s
}

type ListMethodsResponseBodyServiceMethodListServiceMethodParamTypes struct {
	ParamType []*string `json:"ParamType,omitempty" xml:"ParamType,omitempty" type:"Repeated"`
}

func (s ListMethodsResponseBodyServiceMethodListServiceMethodParamTypes) String() string {
	return tea.Prettify(s)
}

func (s ListMethodsResponseBodyServiceMethodListServiceMethodParamTypes) GoString() string {
	return s.String()
}

func (s *ListMethodsResponseBodyServiceMethodListServiceMethodParamTypes) SetParamType(v []*string) *ListMethodsResponseBodyServiceMethodListServiceMethodParamTypes {
	s.ParamType = v
	return s
}

type ListMethodsResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListMethodsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListMethodsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListMethodsResponse) GoString() string {
	return s.String()
}

func (s *ListMethodsResponse) SetHeaders(v map[string]*string) *ListMethodsResponse {
	s.Headers = v
	return s
}

func (s *ListMethodsResponse) SetStatusCode(v int32) *ListMethodsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListMethodsResponse) SetBody(v *ListMethodsResponseBody) *ListMethodsResponse {
	s.Body = v
	return s
}

type ListPublishedServicesRequest struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
}

func (s ListPublishedServicesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListPublishedServicesRequest) GoString() string {
	return s.String()
}

func (s *ListPublishedServicesRequest) SetAppId(v string) *ListPublishedServicesRequest {
	s.AppId = &v
	return s
}

type ListPublishedServicesResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The published services.
	PublishedServicesList *ListPublishedServicesResponseBodyPublishedServicesList `json:"PublishedServicesList,omitempty" xml:"PublishedServicesList,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListPublishedServicesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListPublishedServicesResponseBody) GoString() string {
	return s.String()
}

func (s *ListPublishedServicesResponseBody) SetCode(v int32) *ListPublishedServicesResponseBody {
	s.Code = &v
	return s
}

func (s *ListPublishedServicesResponseBody) SetMessage(v string) *ListPublishedServicesResponseBody {
	s.Message = &v
	return s
}

func (s *ListPublishedServicesResponseBody) SetPublishedServicesList(v *ListPublishedServicesResponseBodyPublishedServicesList) *ListPublishedServicesResponseBody {
	s.PublishedServicesList = v
	return s
}

func (s *ListPublishedServicesResponseBody) SetRequestId(v string) *ListPublishedServicesResponseBody {
	s.RequestId = &v
	return s
}

type ListPublishedServicesResponseBodyPublishedServicesList struct {
	ListPublishedServices []*ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices `json:"ListPublishedServices,omitempty" xml:"ListPublishedServices,omitempty" type:"Repeated"`
}

func (s ListPublishedServicesResponseBodyPublishedServicesList) String() string {
	return tea.Prettify(s)
}

func (s ListPublishedServicesResponseBodyPublishedServicesList) GoString() string {
	return s.String()
}

func (s *ListPublishedServicesResponseBodyPublishedServicesList) SetListPublishedServices(v []*ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices) *ListPublishedServicesResponseBodyPublishedServicesList {
	s.ListPublishedServices = v
	return s
}

type ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// Indicates whether the application runs in a Docker container. Valid values:
	//
	// *   true: The application runs in a Docker container.
	// *   false: The application does not run in a Docker container.
	DockerApplication *bool `json:"DockerApplication,omitempty" xml:"DockerApplication,omitempty"`
	// A reserved parameter.
	Group2Ip *string                                                                            `json:"Group2Ip,omitempty" xml:"Group2Ip,omitempty"`
	Groups   *ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesGroups `json:"Groups,omitempty" xml:"Groups,omitempty" type:"Struct"`
	Ips      *ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesIps    `json:"Ips,omitempty" xml:"Ips,omitempty" type:"Struct"`
	// The name of the published service.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of the published service.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The version of the published services.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices) String() string {
	return tea.Prettify(s)
}

func (s ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices) GoString() string {
	return s.String()
}

func (s *ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices) SetAppId(v string) *ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices {
	s.AppId = &v
	return s
}

func (s *ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices) SetDockerApplication(v bool) *ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices {
	s.DockerApplication = &v
	return s
}

func (s *ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices) SetGroup2Ip(v string) *ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices {
	s.Group2Ip = &v
	return s
}

func (s *ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices) SetGroups(v *ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesGroups) *ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices {
	s.Groups = v
	return s
}

func (s *ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices) SetIps(v *ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesIps) *ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices {
	s.Ips = v
	return s
}

func (s *ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices) SetName(v string) *ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices {
	s.Name = &v
	return s
}

func (s *ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices) SetType(v string) *ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices {
	s.Type = &v
	return s
}

func (s *ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices) SetVersion(v string) *ListPublishedServicesResponseBodyPublishedServicesListListPublishedServices {
	s.Version = &v
	return s
}

type ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesGroups struct {
	Group []*string `json:"group,omitempty" xml:"group,omitempty" type:"Repeated"`
}

func (s ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesGroups) String() string {
	return tea.Prettify(s)
}

func (s ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesGroups) GoString() string {
	return s.String()
}

func (s *ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesGroups) SetGroup(v []*string) *ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesGroups {
	s.Group = v
	return s
}

type ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesIps struct {
	Ip []*string `json:"ip,omitempty" xml:"ip,omitempty" type:"Repeated"`
}

func (s ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesIps) String() string {
	return tea.Prettify(s)
}

func (s ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesIps) GoString() string {
	return s.String()
}

func (s *ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesIps) SetIp(v []*string) *ListPublishedServicesResponseBodyPublishedServicesListListPublishedServicesIps {
	s.Ip = v
	return s
}

type ListPublishedServicesResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListPublishedServicesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListPublishedServicesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListPublishedServicesResponse) GoString() string {
	return s.String()
}

func (s *ListPublishedServicesResponse) SetHeaders(v map[string]*string) *ListPublishedServicesResponse {
	s.Headers = v
	return s
}

func (s *ListPublishedServicesResponse) SetStatusCode(v int32) *ListPublishedServicesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListPublishedServicesResponse) SetBody(v *ListPublishedServicesResponseBody) *ListPublishedServicesResponse {
	s.Body = v
	return s
}

type ListRecentChangeOrderRequest struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
}

func (s ListRecentChangeOrderRequest) String() string {
	return tea.Prettify(s)
}

func (s ListRecentChangeOrderRequest) GoString() string {
	return s.String()
}

func (s *ListRecentChangeOrderRequest) SetAppId(v string) *ListRecentChangeOrderRequest {
	s.AppId = &v
	return s
}

type ListRecentChangeOrderResponseBody struct {
	// The information about change processes.
	ChangeOrderList *ListRecentChangeOrderResponseBodyChangeOrderList `json:"ChangeOrderList,omitempty" xml:"ChangeOrderList,omitempty" type:"Struct"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListRecentChangeOrderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListRecentChangeOrderResponseBody) GoString() string {
	return s.String()
}

func (s *ListRecentChangeOrderResponseBody) SetChangeOrderList(v *ListRecentChangeOrderResponseBodyChangeOrderList) *ListRecentChangeOrderResponseBody {
	s.ChangeOrderList = v
	return s
}

func (s *ListRecentChangeOrderResponseBody) SetCode(v int32) *ListRecentChangeOrderResponseBody {
	s.Code = &v
	return s
}

func (s *ListRecentChangeOrderResponseBody) SetMessage(v string) *ListRecentChangeOrderResponseBody {
	s.Message = &v
	return s
}

func (s *ListRecentChangeOrderResponseBody) SetRequestId(v string) *ListRecentChangeOrderResponseBody {
	s.RequestId = &v
	return s
}

type ListRecentChangeOrderResponseBodyChangeOrderList struct {
	ChangeOrder []*ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder `json:"ChangeOrder,omitempty" xml:"ChangeOrder,omitempty" type:"Repeated"`
}

func (s ListRecentChangeOrderResponseBodyChangeOrderList) String() string {
	return tea.Prettify(s)
}

func (s ListRecentChangeOrderResponseBodyChangeOrderList) GoString() string {
	return s.String()
}

func (s *ListRecentChangeOrderResponseBodyChangeOrderList) SetChangeOrder(v []*ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder) *ListRecentChangeOrderResponseBodyChangeOrderList {
	s.ChangeOrder = v
	return s
}

type ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The number of batches for the change. Valid values: 1 to 5.
	BatchCount *int32 `json:"BatchCount,omitempty" xml:"BatchCount,omitempty"`
	// The way in which the next batch is triggered during a phased release. Valid values:
	//
	// *   Automatic
	// *   Manual
	BatchType *string `json:"BatchType,omitempty" xml:"BatchType,omitempty"`
	// The description of the change process.
	ChangeOrderDescription *string `json:"ChangeOrderDescription,omitempty" xml:"ChangeOrderDescription,omitempty"`
	// The unique ID of the change process.
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	// The type of the change process.
	CoType *string `json:"CoType,omitempty" xml:"CoType,omitempty"`
	// The type of the change process.
	CoTypeCode *string `json:"CoTypeCode,omitempty" xml:"CoTypeCode,omitempty"`
	// The time when the change process was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The user who created the change process.
	CreateUserId *string `json:"CreateUserId,omitempty" xml:"CreateUserId,omitempty"`
	// The time when the change process ended.
	FinishTime *string `json:"FinishTime,omitempty" xml:"FinishTime,omitempty"`
	// The ID of the application instance group on which the change was performed.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The source of the change. Valid values:
	//
	// *   console: the Enterprise Distributed Application Service (EDAS) console
	// *   pop: the POP API or tool
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The state of the change process. Valid values:
	//
	// *   0: ready to start execution
	// *   1: in progress
	// *   2: successful
	// *   3: failed
	// *   6: terminated
	// *   8: waiting for manual confirmation (You can see the state when you manually confirm the execution of the next batch of the change.)
	// *   9: waiting for automatic execution
	// *   10: failed due to a system error
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the user who created the change process.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder) String() string {
	return tea.Prettify(s)
}

func (s ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder) GoString() string {
	return s.String()
}

func (s *ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder) SetAppId(v string) *ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder {
	s.AppId = &v
	return s
}

func (s *ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder) SetBatchCount(v int32) *ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder {
	s.BatchCount = &v
	return s
}

func (s *ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder) SetBatchType(v string) *ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder {
	s.BatchType = &v
	return s
}

func (s *ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder) SetChangeOrderDescription(v string) *ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder {
	s.ChangeOrderDescription = &v
	return s
}

func (s *ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder) SetChangeOrderId(v string) *ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder {
	s.ChangeOrderId = &v
	return s
}

func (s *ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder) SetCoType(v string) *ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder {
	s.CoType = &v
	return s
}

func (s *ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder) SetCoTypeCode(v string) *ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder {
	s.CoTypeCode = &v
	return s
}

func (s *ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder) SetCreateTime(v string) *ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder {
	s.CreateTime = &v
	return s
}

func (s *ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder) SetCreateUserId(v string) *ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder {
	s.CreateUserId = &v
	return s
}

func (s *ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder) SetFinishTime(v string) *ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder {
	s.FinishTime = &v
	return s
}

func (s *ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder) SetGroupId(v string) *ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder {
	s.GroupId = &v
	return s
}

func (s *ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder) SetSource(v string) *ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder {
	s.Source = &v
	return s
}

func (s *ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder) SetStatus(v int32) *ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder {
	s.Status = &v
	return s
}

func (s *ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder) SetUserId(v string) *ListRecentChangeOrderResponseBodyChangeOrderListChangeOrder {
	s.UserId = &v
	return s
}

type ListRecentChangeOrderResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListRecentChangeOrderResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListRecentChangeOrderResponse) String() string {
	return tea.Prettify(s)
}

func (s ListRecentChangeOrderResponse) GoString() string {
	return s.String()
}

func (s *ListRecentChangeOrderResponse) SetHeaders(v map[string]*string) *ListRecentChangeOrderResponse {
	s.Headers = v
	return s
}

func (s *ListRecentChangeOrderResponse) SetStatusCode(v int32) *ListRecentChangeOrderResponse {
	s.StatusCode = &v
	return s
}

func (s *ListRecentChangeOrderResponse) SetBody(v *ListRecentChangeOrderResponseBody) *ListRecentChangeOrderResponse {
	s.Body = v
	return s
}

type ListResourceGroupResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// For more information about how to define a resource group, see ResGroupEntity.
	ResourceGroupList *ListResourceGroupResponseBodyResourceGroupList `json:"ResourceGroupList,omitempty" xml:"ResourceGroupList,omitempty" type:"Struct"`
}

func (s ListResourceGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListResourceGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ListResourceGroupResponseBody) SetCode(v int32) *ListResourceGroupResponseBody {
	s.Code = &v
	return s
}

func (s *ListResourceGroupResponseBody) SetMessage(v string) *ListResourceGroupResponseBody {
	s.Message = &v
	return s
}

func (s *ListResourceGroupResponseBody) SetRequestId(v string) *ListResourceGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListResourceGroupResponseBody) SetResourceGroupList(v *ListResourceGroupResponseBodyResourceGroupList) *ListResourceGroupResponseBody {
	s.ResourceGroupList = v
	return s
}

type ListResourceGroupResponseBodyResourceGroupList struct {
	ResGroupEntity []*ListResourceGroupResponseBodyResourceGroupListResGroupEntity `json:"ResGroupEntity,omitempty" xml:"ResGroupEntity,omitempty" type:"Repeated"`
}

func (s ListResourceGroupResponseBodyResourceGroupList) String() string {
	return tea.Prettify(s)
}

func (s ListResourceGroupResponseBodyResourceGroupList) GoString() string {
	return s.String()
}

func (s *ListResourceGroupResponseBodyResourceGroupList) SetResGroupEntity(v []*ListResourceGroupResponseBodyResourceGroupListResGroupEntity) *ListResourceGroupResponseBodyResourceGroupList {
	s.ResGroupEntity = v
	return s
}

type ListResourceGroupResponseBodyResourceGroupListResGroupEntity struct {
	// The UID of the Alibaba Cloud account.
	AdminUserId *string `json:"AdminUserId,omitempty" xml:"AdminUserId,omitempty"`
	// The time when the resource group was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The description of the resource group.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the resource group.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the resource group.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the region where the resource group belongs.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The Server Load Balancer (SLB) instances.
	SlbList *ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbList `json:"SlbList,omitempty" xml:"SlbList,omitempty" type:"Struct"`
	// The time when the resource group was updated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The Elastic Compute Service (ECS) instances.
	EcsList *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsList `json:"ecsList,omitempty" xml:"ecsList,omitempty" type:"Struct"`
}

func (s ListResourceGroupResponseBodyResourceGroupListResGroupEntity) String() string {
	return tea.Prettify(s)
}

func (s ListResourceGroupResponseBodyResourceGroupListResGroupEntity) GoString() string {
	return s.String()
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntity) SetAdminUserId(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntity {
	s.AdminUserId = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntity) SetCreateTime(v int64) *ListResourceGroupResponseBodyResourceGroupListResGroupEntity {
	s.CreateTime = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntity) SetDescription(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntity {
	s.Description = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntity) SetId(v int64) *ListResourceGroupResponseBodyResourceGroupListResGroupEntity {
	s.Id = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntity) SetName(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntity {
	s.Name = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntity) SetRegionId(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntity {
	s.RegionId = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntity) SetSlbList(v *ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbList) *ListResourceGroupResponseBodyResourceGroupListResGroupEntity {
	s.SlbList = v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntity) SetUpdateTime(v int64) *ListResourceGroupResponseBodyResourceGroupListResGroupEntity {
	s.UpdateTime = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntity) SetEcsList(v *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsList) *ListResourceGroupResponseBodyResourceGroupListResGroupEntity {
	s.EcsList = v
	return s
}

type ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbList struct {
	SlbEntity []*ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity `json:"SlbEntity,omitempty" xml:"SlbEntity,omitempty" type:"Repeated"`
}

func (s ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbList) String() string {
	return tea.Prettify(s)
}

func (s ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbList) GoString() string {
	return s.String()
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbList) SetSlbEntity(v []*ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity) *ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbList {
	s.SlbEntity = v
	return s
}

type ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity struct {
	// The IP address of the SLB instance.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// The type of the IP address of the SLB instance. Valid values:
	//
	// *   Internet: Users can connect to the SLB instance over the Internet.
	// *   Intranet: Users can connect to the SLB instance over the internal network.
	AddressType *string `json:"AddressType,omitempty" xml:"AddressType,omitempty"`
	// Indicates whether the SLB instance has expired. Valid values:
	//
	// *   true: The SLB instance has expired.
	// *   false: The SLB instance has not expired.
	Expired *bool `json:"Expired,omitempty" xml:"Expired,omitempty"`
	// The ID of the group to which the SLB instance belongs.
	GroupId *int32 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The network type of the SLB instance. Valid values:
	//
	// *   Classic network
	// *   VPC
	NetworkType *string `json:"NetworkType,omitempty" xml:"NetworkType,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The unique ID of the SLB instance.
	SlbId *string `json:"SlbId,omitempty" xml:"SlbId,omitempty"`
	// The name of the SLB instance.
	SlbName *string `json:"SlbName,omitempty" xml:"SlbName,omitempty"`
	// The status of the SLB instance.
	SlbStatus *string `json:"SlbStatus,omitempty" xml:"SlbStatus,omitempty"`
	// The UID of the Alibaba Cloud account.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The ID of the VPC.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The ID of the vSwitch.
	VswitchId *string `json:"VswitchId,omitempty" xml:"VswitchId,omitempty"`
}

func (s ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity) String() string {
	return tea.Prettify(s)
}

func (s ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity) GoString() string {
	return s.String()
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity) SetAddress(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity {
	s.Address = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity) SetAddressType(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity {
	s.AddressType = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity) SetExpired(v bool) *ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity {
	s.Expired = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity) SetGroupId(v int32) *ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity {
	s.GroupId = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity) SetNetworkType(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity {
	s.NetworkType = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity) SetRegionId(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity {
	s.RegionId = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity) SetSlbId(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity {
	s.SlbId = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity) SetSlbName(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity {
	s.SlbName = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity) SetSlbStatus(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity {
	s.SlbStatus = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity) SetUserId(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity {
	s.UserId = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity) SetVpcId(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity {
	s.VpcId = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity) SetVswitchId(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntitySlbListSlbEntity {
	s.VswitchId = &v
	return s
}

type ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsList struct {
	EcsEntity []*ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity `json:"EcsEntity,omitempty" xml:"EcsEntity,omitempty" type:"Repeated"`
}

func (s ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsList) String() string {
	return tea.Prettify(s)
}

func (s ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsList) GoString() string {
	return s.String()
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsList) SetEcsEntity(v []*ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsList {
	s.EcsEntity = v
	return s
}

type ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity struct {
	// The total number of CPU cores.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The description of the ECS instance.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The elastic compute unit (ECU) that corresponds to the ECS instance.
	EcuEntity *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity `json:"EcuEntity,omitempty" xml:"EcuEntity,omitempty" type:"Struct"`
	// The elastic IP address (EIP).
	Eip *string `json:"Eip,omitempty" xml:"Eip,omitempty"`
	// Indicates whether the ECS instance has expired. Valid values:
	//
	// *   true: The ECS instance has expired.
	// *   false: The ECS instance has not expired.
	Expired *bool `json:"Expired,omitempty" xml:"Expired,omitempty"`
	// The ID of the resource group in Enterprise Distributed Application Service (EDAS).
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the host.
	HostName *string `json:"HostName,omitempty" xml:"HostName,omitempty"`
	// The private IP address.
	InnerIp *string `json:"InnerIp,omitempty" xml:"InnerIp,omitempty"`
	// The ID of the ECS instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The name of the ECS instance.
	InstanceName *string `json:"InstanceName,omitempty" xml:"InstanceName,omitempty"`
	// The total size of memory. Unit: MB.
	Mem *int32 `json:"Mem,omitempty" xml:"Mem,omitempty"`
	// The private IP address of the ECS instance.
	PrivateIp *string `json:"PrivateIp,omitempty" xml:"PrivateIp,omitempty"`
	// The public IP address.
	PublicIp *string `json:"PublicIp,omitempty" xml:"PublicIp,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The serial number of the ECS instance.
	SerialNum *string `json:"SerialNum,omitempty" xml:"SerialNum,omitempty"`
	// The ID of the security group.
	SgId *string `json:"SgId,omitempty" xml:"SgId,omitempty"`
	// The status of the ECS instance. Valid values:
	//
	// *   Pending: The ECS instance is being created.
	// *   Running: The ECS instance is running.
	// *   Starting: The ECS instance is being started.
	// *   Stopping: The ECS instance is being stopped.
	// *   Stopped: The ECS instance is stopped.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the user account.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The VPCs.
	VpcEntity *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity `json:"VpcEntity,omitempty" xml:"VpcEntity,omitempty" type:"Struct"`
	// The unique ID of the virtual private cloud (VPC).
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The ID of the zone.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity) String() string {
	return tea.Prettify(s)
}

func (s ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity) GoString() string {
	return s.String()
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity) SetCpu(v int32) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity {
	s.Cpu = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity) SetDescription(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity {
	s.Description = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity) SetEcuEntity(v *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity {
	s.EcuEntity = v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity) SetEip(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity {
	s.Eip = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity) SetExpired(v bool) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity {
	s.Expired = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity) SetGroupId(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity {
	s.GroupId = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity) SetHostName(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity {
	s.HostName = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity) SetInnerIp(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity {
	s.InnerIp = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity) SetInstanceId(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity {
	s.InstanceId = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity) SetInstanceName(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity {
	s.InstanceName = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity) SetMem(v int32) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity {
	s.Mem = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity) SetPrivateIp(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity {
	s.PrivateIp = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity) SetPublicIp(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity {
	s.PublicIp = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity) SetRegionId(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity {
	s.RegionId = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity) SetSerialNum(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity {
	s.SerialNum = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity) SetSgId(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity {
	s.SgId = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity) SetStatus(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity {
	s.Status = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity) SetUserId(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity {
	s.UserId = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity) SetVpcEntity(v *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity {
	s.VpcEntity = v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity) SetVpcId(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity {
	s.VpcId = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity) SetZoneId(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntity {
	s.ZoneId = &v
	return s
}

type ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity struct {
	// The number of available CPUs.
	AvailableCpu *int32 `json:"AvailableCpu,omitempty" xml:"AvailableCpu,omitempty"`
	// The size of the available memory.
	AvailableMem *int32 `json:"AvailableMem,omitempty" xml:"AvailableMem,omitempty"`
	// The total number of CPU cores.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The time when the ECU was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// Indicates whether Docker is installed. Valid values:
	//
	// *   true: Docker is installed.
	// *   false: Docker is not installed.
	DockerEnv *bool `json:"DockerEnv,omitempty" xml:"DockerEnv,omitempty"`
	// The unique ID of the elastic compute unit (ECU). You can run the `dmidecode` command on the ECS instance to query the ECU ID.
	EcuId *string `json:"EcuId,omitempty" xml:"EcuId,omitempty"`
	// The time when the last heartbeat detection was performed. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	HeartbeatTime *int64 `json:"HeartbeatTime,omitempty" xml:"HeartbeatTime,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The private IP address of the ECU.
	IpAddr *string `json:"IpAddr,omitempty" xml:"IpAddr,omitempty"`
	// The total size of memory. Unit: MB.
	Mem *int32 `json:"Mem,omitempty" xml:"Mem,omitempty"`
	// The name of the ECU.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Indicates whether the ECU is online. Valid values:
	//
	// *   true: The ECU is online.
	// *   false: The ECU is offline.
	Online *bool `json:"Online,omitempty" xml:"Online,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The time when the ECU was updated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The ID of the user associated with the ECU.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The ID of the VPC.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The ID of the zone.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity) String() string {
	return tea.Prettify(s)
}

func (s ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity) GoString() string {
	return s.String()
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity) SetAvailableCpu(v int32) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity {
	s.AvailableCpu = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity) SetAvailableMem(v int32) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity {
	s.AvailableMem = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity) SetCpu(v int32) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity {
	s.Cpu = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity) SetCreateTime(v int64) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity {
	s.CreateTime = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity) SetDockerEnv(v bool) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity {
	s.DockerEnv = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity) SetEcuId(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity {
	s.EcuId = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity) SetHeartbeatTime(v int64) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity {
	s.HeartbeatTime = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity) SetInstanceId(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity {
	s.InstanceId = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity) SetIpAddr(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity {
	s.IpAddr = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity) SetMem(v int32) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity {
	s.Mem = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity) SetName(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity {
	s.Name = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity) SetOnline(v bool) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity {
	s.Online = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity) SetRegionId(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity {
	s.RegionId = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity) SetUpdateTime(v int64) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity {
	s.UpdateTime = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity) SetUserId(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity {
	s.UserId = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity) SetVpcId(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity {
	s.VpcId = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity) SetZoneId(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityEcuEntity {
	s.ZoneId = &v
	return s
}

type ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity struct {
	// The IPv4 CIDR block of the vSwitch.
	Cidrblock *string `json:"Cidrblock,omitempty" xml:"Cidrblock,omitempty"`
	// The description of the VPC.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The number of ECS instances that run in the VPC.
	EcsNum *int32 `json:"EcsNum,omitempty" xml:"EcsNum,omitempty"`
	// Indicates whether the VPC has expired. Valid values:
	//
	// *   true: The VPC has expired.
	// *   false: The VPC has not expired.
	Expired *bool `json:"Expired,omitempty" xml:"Expired,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The status of the VPC.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the user.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The unique ID of the VPC.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The name of the VPC.
	VpcName *string `json:"VpcName,omitempty" xml:"VpcName,omitempty"`
}

func (s ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity) String() string {
	return tea.Prettify(s)
}

func (s ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity) GoString() string {
	return s.String()
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity) SetCidrblock(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity {
	s.Cidrblock = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity) SetDescription(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity {
	s.Description = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity) SetEcsNum(v int32) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity {
	s.EcsNum = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity) SetExpired(v bool) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity {
	s.Expired = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity) SetRegionId(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity {
	s.RegionId = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity) SetStatus(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity {
	s.Status = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity) SetUserId(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity {
	s.UserId = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity) SetVpcId(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity {
	s.VpcId = &v
	return s
}

func (s *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity) SetVpcName(v string) *ListResourceGroupResponseBodyResourceGroupListResGroupEntityEcsListEcsEntityVpcEntity {
	s.VpcName = &v
	return s
}

type ListResourceGroupResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListResourceGroupResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListResourceGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ListResourceGroupResponse) GoString() string {
	return s.String()
}

func (s *ListResourceGroupResponse) SetHeaders(v map[string]*string) *ListResourceGroupResponse {
	s.Headers = v
	return s
}

func (s *ListResourceGroupResponse) SetStatusCode(v int32) *ListResourceGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ListResourceGroupResponse) SetBody(v *ListResourceGroupResponseBody) *ListResourceGroupResponse {
	s.Body = v
	return s
}

type ListRoleResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The roles.
	RoleList *ListRoleResponseBodyRoleList `json:"RoleList,omitempty" xml:"RoleList,omitempty" type:"Struct"`
}

func (s ListRoleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListRoleResponseBody) GoString() string {
	return s.String()
}

func (s *ListRoleResponseBody) SetCode(v int32) *ListRoleResponseBody {
	s.Code = &v
	return s
}

func (s *ListRoleResponseBody) SetMessage(v string) *ListRoleResponseBody {
	s.Message = &v
	return s
}

func (s *ListRoleResponseBody) SetRequestId(v string) *ListRoleResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListRoleResponseBody) SetRoleList(v *ListRoleResponseBodyRoleList) *ListRoleResponseBody {
	s.RoleList = v
	return s
}

type ListRoleResponseBodyRoleList struct {
	RoleItem []*ListRoleResponseBodyRoleListRoleItem `json:"RoleItem,omitempty" xml:"RoleItem,omitempty" type:"Repeated"`
}

func (s ListRoleResponseBodyRoleList) String() string {
	return tea.Prettify(s)
}

func (s ListRoleResponseBodyRoleList) GoString() string {
	return s.String()
}

func (s *ListRoleResponseBodyRoleList) SetRoleItem(v []*ListRoleResponseBodyRoleListRoleItem) *ListRoleResponseBodyRoleList {
	s.RoleItem = v
	return s
}

type ListRoleResponseBodyRoleListRoleItem struct {
	// The set of permissions to be granted to the role.
	ActionList *ListRoleResponseBodyRoleListRoleItemActionList `json:"ActionList,omitempty" xml:"ActionList,omitempty" type:"Struct"`
	// The roles.
	Role *ListRoleResponseBodyRoleListRoleItemRole `json:"Role,omitempty" xml:"Role,omitempty" type:"Struct"`
}

func (s ListRoleResponseBodyRoleListRoleItem) String() string {
	return tea.Prettify(s)
}

func (s ListRoleResponseBodyRoleListRoleItem) GoString() string {
	return s.String()
}

func (s *ListRoleResponseBodyRoleListRoleItem) SetActionList(v *ListRoleResponseBodyRoleListRoleItemActionList) *ListRoleResponseBodyRoleListRoleItem {
	s.ActionList = v
	return s
}

func (s *ListRoleResponseBodyRoleListRoleItem) SetRole(v *ListRoleResponseBodyRoleListRoleItemRole) *ListRoleResponseBodyRoleListRoleItem {
	s.Role = v
	return s
}

type ListRoleResponseBodyRoleListRoleItemActionList struct {
	Action []*ListRoleResponseBodyRoleListRoleItemActionListAction `json:"Action,omitempty" xml:"Action,omitempty" type:"Repeated"`
}

func (s ListRoleResponseBodyRoleListRoleItemActionList) String() string {
	return tea.Prettify(s)
}

func (s ListRoleResponseBodyRoleListRoleItemActionList) GoString() string {
	return s.String()
}

func (s *ListRoleResponseBodyRoleListRoleItemActionList) SetAction(v []*ListRoleResponseBodyRoleListRoleItemActionListAction) *ListRoleResponseBodyRoleListRoleItemActionList {
	s.Action = v
	return s
}

type ListRoleResponseBodyRoleListRoleItemActionListAction struct {
	// The serial number of the permission that is granted to the role.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The description of the permission to be granted to the role.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the permission group to which the permission that is granted to the role belongs.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the permission to be granted to the role.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s ListRoleResponseBodyRoleListRoleItemActionListAction) String() string {
	return tea.Prettify(s)
}

func (s ListRoleResponseBodyRoleListRoleItemActionListAction) GoString() string {
	return s.String()
}

func (s *ListRoleResponseBodyRoleListRoleItemActionListAction) SetCode(v string) *ListRoleResponseBodyRoleListRoleItemActionListAction {
	s.Code = &v
	return s
}

func (s *ListRoleResponseBodyRoleListRoleItemActionListAction) SetDescription(v string) *ListRoleResponseBodyRoleListRoleItemActionListAction {
	s.Description = &v
	return s
}

func (s *ListRoleResponseBodyRoleListRoleItemActionListAction) SetGroupId(v string) *ListRoleResponseBodyRoleListRoleItemActionListAction {
	s.GroupId = &v
	return s
}

func (s *ListRoleResponseBodyRoleListRoleItemActionListAction) SetName(v string) *ListRoleResponseBodyRoleListRoleItemActionListAction {
	s.Name = &v
	return s
}

type ListRoleResponseBodyRoleListRoleItemRole struct {
	// The ID of the Alibaba Cloud account.
	AdminUserId *string `json:"AdminUserId,omitempty" xml:"AdminUserId,omitempty"`
	// The timestamp when the role was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the role.
	Id *int32 `json:"Id,omitempty" xml:"Id,omitempty"`
	// Indicates whether the role is a default role.
	IsDefault *bool `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	// The name of the role.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The timestamp when the role was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s ListRoleResponseBodyRoleListRoleItemRole) String() string {
	return tea.Prettify(s)
}

func (s ListRoleResponseBodyRoleListRoleItemRole) GoString() string {
	return s.String()
}

func (s *ListRoleResponseBodyRoleListRoleItemRole) SetAdminUserId(v string) *ListRoleResponseBodyRoleListRoleItemRole {
	s.AdminUserId = &v
	return s
}

func (s *ListRoleResponseBodyRoleListRoleItemRole) SetCreateTime(v int64) *ListRoleResponseBodyRoleListRoleItemRole {
	s.CreateTime = &v
	return s
}

func (s *ListRoleResponseBodyRoleListRoleItemRole) SetId(v int32) *ListRoleResponseBodyRoleListRoleItemRole {
	s.Id = &v
	return s
}

func (s *ListRoleResponseBodyRoleListRoleItemRole) SetIsDefault(v bool) *ListRoleResponseBodyRoleListRoleItemRole {
	s.IsDefault = &v
	return s
}

func (s *ListRoleResponseBodyRoleListRoleItemRole) SetName(v string) *ListRoleResponseBodyRoleListRoleItemRole {
	s.Name = &v
	return s
}

func (s *ListRoleResponseBodyRoleListRoleItemRole) SetUpdateTime(v int64) *ListRoleResponseBodyRoleListRoleItemRole {
	s.UpdateTime = &v
	return s
}

type ListRoleResponse struct {
	Headers    map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListRoleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListRoleResponse) String() string {
	return tea.Prettify(s)
}

func (s ListRoleResponse) GoString() string {
	return s.String()
}

func (s *ListRoleResponse) SetHeaders(v map[string]*string) *ListRoleResponse {
	s.Headers = v
	return s
}

func (s *ListRoleResponse) SetStatusCode(v int32) *ListRoleResponse {
	s.StatusCode = &v
	return s
}

func (s *ListRoleResponse) SetBody(v *ListRoleResponseBody) *ListRoleResponse {
	s.Body = v
	return s
}

type ListScaleOutEcuRequest struct {
	// The ID of the application. Specify this parameter if you want to query the available ECUs in the cluster where the application is deployed.
	//
	// >  Specify at least one of the ClusterId and AppId parameters as the query parameter.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the cluster. Specify this parameter if you want to query the available ECUs in the cluster.
	//
	// > Specify at least one of the ClusterId and AppId parameters as the query parameter.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The number of CPU cores based on which you want to query the available ECUs in the cluster.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The ID of the instance group. Specify this parameter if you want to query the available ECUs in the cluster where the instance group resides.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The number of ECUs that you want to query. If this parameter is not specified, all the ECUs that meet the query conditions are returned.
	InstanceNum *int32 `json:"InstanceNum,omitempty" xml:"InstanceNum,omitempty"`
	// The ID of the namespace.
	//
	// *   The ID of a custom namespace is in the `region ID:namespace identifier` format. Example: cn-beijing:test.
	// *   The ID of the default namespace is in the `region ID` format. Example: cn-beijing.
	LogicalRegionId *string `json:"LogicalRegionId,omitempty" xml:"LogicalRegionId,omitempty"`
	// The size of available memory based on which you want to query the available ECUs in the cluster. Unit: MB.
	Mem *int32 `json:"Mem,omitempty" xml:"Mem,omitempty"`
}

func (s ListScaleOutEcuRequest) String() string {
	return tea.Prettify(s)
}

func (s ListScaleOutEcuRequest) GoString() string {
	return s.String()
}

func (s *ListScaleOutEcuRequest) SetAppId(v string) *ListScaleOutEcuRequest {
	s.AppId = &v
	return s
}

func (s *ListScaleOutEcuRequest) SetClusterId(v string) *ListScaleOutEcuRequest {
	s.ClusterId = &v
	return s
}

func (s *ListScaleOutEcuRequest) SetCpu(v int32) *ListScaleOutEcuRequest {
	s.Cpu = &v
	return s
}

func (s *ListScaleOutEcuRequest) SetGroupId(v string) *ListScaleOutEcuRequest {
	s.GroupId = &v
	return s
}

func (s *ListScaleOutEcuRequest) SetInstanceNum(v int32) *ListScaleOutEcuRequest {
	s.InstanceNum = &v
	return s
}

func (s *ListScaleOutEcuRequest) SetLogicalRegionId(v string) *ListScaleOutEcuRequest {
	s.LogicalRegionId = &v
	return s
}

func (s *ListScaleOutEcuRequest) SetMem(v int32) *ListScaleOutEcuRequest {
	s.Mem = &v
	return s
}

type ListScaleOutEcuResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The ECUs.
	EcuInfoList *ListScaleOutEcuResponseBodyEcuInfoList `json:"EcuInfoList,omitempty" xml:"EcuInfoList,omitempty" type:"Struct"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListScaleOutEcuResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListScaleOutEcuResponseBody) GoString() string {
	return s.String()
}

func (s *ListScaleOutEcuResponseBody) SetCode(v int32) *ListScaleOutEcuResponseBody {
	s.Code = &v
	return s
}

func (s *ListScaleOutEcuResponseBody) SetEcuInfoList(v *ListScaleOutEcuResponseBodyEcuInfoList) *ListScaleOutEcuResponseBody {
	s.EcuInfoList = v
	return s
}

func (s *ListScaleOutEcuResponseBody) SetMessage(v string) *ListScaleOutEcuResponseBody {
	s.Message = &v
	return s
}

func (s *ListScaleOutEcuResponseBody) SetRequestId(v string) *ListScaleOutEcuResponseBody {
	s.RequestId = &v
	return s
}

type ListScaleOutEcuResponseBodyEcuInfoList struct {
	EcuInfo []*ListScaleOutEcuResponseBodyEcuInfoListEcuInfo `json:"EcuInfo,omitempty" xml:"EcuInfo,omitempty" type:"Repeated"`
}

func (s ListScaleOutEcuResponseBodyEcuInfoList) String() string {
	return tea.Prettify(s)
}

func (s ListScaleOutEcuResponseBodyEcuInfoList) GoString() string {
	return s.String()
}

func (s *ListScaleOutEcuResponseBodyEcuInfoList) SetEcuInfo(v []*ListScaleOutEcuResponseBodyEcuInfoListEcuInfo) *ListScaleOutEcuResponseBodyEcuInfoList {
	s.EcuInfo = v
	return s
}

type ListScaleOutEcuResponseBodyEcuInfoListEcuInfo struct {
	// The number of available CPU cores for the ECU.
	AvailableCpu *int32 `json:"AvailableCpu,omitempty" xml:"AvailableCpu,omitempty"`
	// The size of available memory for the ECU. Unit: MB.
	AvailableMem *int32 `json:"AvailableMem,omitempty" xml:"AvailableMem,omitempty"`
	// The time when the ECU was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// Indicates whether Docker is installed. Valid values:
	//
	// *   true: Docker is installed.
	// *   false: Docker is not installed.
	DockerEnv *bool `json:"DockerEnv,omitempty" xml:"DockerEnv,omitempty"`
	// The unique ID of the ECU. To query the ID, you can run the `dmidecode` command on the ECS instance that corresponds to the ECU.
	EcuId *string `json:"EcuId,omitempty" xml:"EcuId,omitempty"`
	// The time when the last heartbeat detection was performed. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	HeartbeatTime *int64 `json:"HeartbeatTime,omitempty" xml:"HeartbeatTime,omitempty"`
	// The ID of the ECU.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The private IP address of the ECU.
	IpAddr *string `json:"IpAddr,omitempty" xml:"IpAddr,omitempty"`
	// The name of the ECU.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Indicates whether the ECU is online. If the ECU is online, its corresponding ECS instance is managed in EDAS. Valid values:
	//
	// *   true: The ECU is online.
	// *   false: The ECU is offline.
	Online *bool `json:"Online,omitempty" xml:"Online,omitempty"`
	// The ID of the region where the ECU is located.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The time when the ECU was last updated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The ID of the Alibaba Cloud account to which the ECU belongs.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The ID of the virtual private cloud (VPC) where the ECU is located.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The ID of the zone where the ECU resides.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s ListScaleOutEcuResponseBodyEcuInfoListEcuInfo) String() string {
	return tea.Prettify(s)
}

func (s ListScaleOutEcuResponseBodyEcuInfoListEcuInfo) GoString() string {
	return s.String()
}

func (s *ListScaleOutEcuResponseBodyEcuInfoListEcuInfo) SetAvailableCpu(v int32) *ListScaleOutEcuResponseBodyEcuInfoListEcuInfo {
	s.AvailableCpu = &v
	return s
}

func (s *ListScaleOutEcuResponseBodyEcuInfoListEcuInfo) SetAvailableMem(v int32) *ListScaleOutEcuResponseBodyEcuInfoListEcuInfo {
	s.AvailableMem = &v
	return s
}

func (s *ListScaleOutEcuResponseBodyEcuInfoListEcuInfo) SetCreateTime(v int64) *ListScaleOutEcuResponseBodyEcuInfoListEcuInfo {
	s.CreateTime = &v
	return s
}

func (s *ListScaleOutEcuResponseBodyEcuInfoListEcuInfo) SetDockerEnv(v bool) *ListScaleOutEcuResponseBodyEcuInfoListEcuInfo {
	s.DockerEnv = &v
	return s
}

func (s *ListScaleOutEcuResponseBodyEcuInfoListEcuInfo) SetEcuId(v string) *ListScaleOutEcuResponseBodyEcuInfoListEcuInfo {
	s.EcuId = &v
	return s
}

func (s *ListScaleOutEcuResponseBodyEcuInfoListEcuInfo) SetHeartbeatTime(v int64) *ListScaleOutEcuResponseBodyEcuInfoListEcuInfo {
	s.HeartbeatTime = &v
	return s
}

func (s *ListScaleOutEcuResponseBodyEcuInfoListEcuInfo) SetInstanceId(v string) *ListScaleOutEcuResponseBodyEcuInfoListEcuInfo {
	s.InstanceId = &v
	return s
}

func (s *ListScaleOutEcuResponseBodyEcuInfoListEcuInfo) SetIpAddr(v string) *ListScaleOutEcuResponseBodyEcuInfoListEcuInfo {
	s.IpAddr = &v
	return s
}

func (s *ListScaleOutEcuResponseBodyEcuInfoListEcuInfo) SetName(v string) *ListScaleOutEcuResponseBodyEcuInfoListEcuInfo {
	s.Name = &v
	return s
}

func (s *ListScaleOutEcuResponseBodyEcuInfoListEcuInfo) SetOnline(v bool) *ListScaleOutEcuResponseBodyEcuInfoListEcuInfo {
	s.Online = &v
	return s
}

func (s *ListScaleOutEcuResponseBodyEcuInfoListEcuInfo) SetRegionId(v string) *ListScaleOutEcuResponseBodyEcuInfoListEcuInfo {
	s.RegionId = &v
	return s
}

func (s *ListScaleOutEcuResponseBodyEcuInfoListEcuInfo) SetUpdateTime(v int64) *ListScaleOutEcuResponseBodyEcuInfoListEcuInfo {
	s.UpdateTime = &v
	return s
}

func (s *ListScaleOutEcuResponseBodyEcuInfoListEcuInfo) SetUserId(v string) *ListScaleOutEcuResponseBodyEcuInfoListEcuInfo {
	s.UserId = &v
	return s
}

func (s *ListScaleOutEcuResponseBodyEcuInfoListEcuInfo) SetVpcId(v string) *ListScaleOutEcuResponseBodyEcuInfoListEcuInfo {
	s.VpcId = &v
	return s
}

func (s *ListScaleOutEcuResponseBodyEcuInfoListEcuInfo) SetZoneId(v string) *ListScaleOutEcuResponseBodyEcuInfoListEcuInfo {
	s.ZoneId = &v
	return s
}

type ListScaleOutEcuResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListScaleOutEcuResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListScaleOutEcuResponse) String() string {
	return tea.Prettify(s)
}

func (s ListScaleOutEcuResponse) GoString() string {
	return s.String()
}

func (s *ListScaleOutEcuResponse) SetHeaders(v map[string]*string) *ListScaleOutEcuResponse {
	s.Headers = v
	return s
}

func (s *ListScaleOutEcuResponse) SetStatusCode(v int32) *ListScaleOutEcuResponse {
	s.StatusCode = &v
	return s
}

func (s *ListScaleOutEcuResponse) SetBody(v *ListScaleOutEcuResponseBody) *ListScaleOutEcuResponse {
	s.Body = v
	return s
}

type ListServiceGroupsResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about service groups.
	ServiceGroupsList *ListServiceGroupsResponseBodyServiceGroupsList `json:"ServiceGroupsList,omitempty" xml:"ServiceGroupsList,omitempty" type:"Struct"`
}

func (s ListServiceGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListServiceGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *ListServiceGroupsResponseBody) SetCode(v int32) *ListServiceGroupsResponseBody {
	s.Code = &v
	return s
}

func (s *ListServiceGroupsResponseBody) SetMessage(v string) *ListServiceGroupsResponseBody {
	s.Message = &v
	return s
}

func (s *ListServiceGroupsResponseBody) SetRequestId(v string) *ListServiceGroupsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListServiceGroupsResponseBody) SetServiceGroupsList(v *ListServiceGroupsResponseBodyServiceGroupsList) *ListServiceGroupsResponseBody {
	s.ServiceGroupsList = v
	return s
}

type ListServiceGroupsResponseBodyServiceGroupsList struct {
	ListServiceGroups []*ListServiceGroupsResponseBodyServiceGroupsListListServiceGroups `json:"ListServiceGroups,omitempty" xml:"ListServiceGroups,omitempty" type:"Repeated"`
}

func (s ListServiceGroupsResponseBodyServiceGroupsList) String() string {
	return tea.Prettify(s)
}

func (s ListServiceGroupsResponseBodyServiceGroupsList) GoString() string {
	return s.String()
}

func (s *ListServiceGroupsResponseBodyServiceGroupsList) SetListServiceGroups(v []*ListServiceGroupsResponseBodyServiceGroupsListListServiceGroups) *ListServiceGroupsResponseBodyServiceGroupsList {
	s.ListServiceGroups = v
	return s
}

type ListServiceGroupsResponseBodyServiceGroupsListListServiceGroups struct {
	// The time when the service group was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the service group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the service group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
}

func (s ListServiceGroupsResponseBodyServiceGroupsListListServiceGroups) String() string {
	return tea.Prettify(s)
}

func (s ListServiceGroupsResponseBodyServiceGroupsListListServiceGroups) GoString() string {
	return s.String()
}

func (s *ListServiceGroupsResponseBodyServiceGroupsListListServiceGroups) SetCreateTime(v string) *ListServiceGroupsResponseBodyServiceGroupsListListServiceGroups {
	s.CreateTime = &v
	return s
}

func (s *ListServiceGroupsResponseBodyServiceGroupsListListServiceGroups) SetGroupId(v string) *ListServiceGroupsResponseBodyServiceGroupsListListServiceGroups {
	s.GroupId = &v
	return s
}

func (s *ListServiceGroupsResponseBodyServiceGroupsListListServiceGroups) SetGroupName(v string) *ListServiceGroupsResponseBodyServiceGroupsListListServiceGroups {
	s.GroupName = &v
	return s
}

type ListServiceGroupsResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListServiceGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListServiceGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListServiceGroupsResponse) GoString() string {
	return s.String()
}

func (s *ListServiceGroupsResponse) SetHeaders(v map[string]*string) *ListServiceGroupsResponse {
	s.Headers = v
	return s
}

func (s *ListServiceGroupsResponse) SetStatusCode(v int32) *ListServiceGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListServiceGroupsResponse) SetBody(v *ListServiceGroupsResponseBody) *ListServiceGroupsResponse {
	s.Body = v
	return s
}

type ListSlbRequest struct {
	// The type of the IP addresses. Valid values:
	//
	// *   Internet: Users can connect to the SLB instance over the Internet.
	// *   Intranet: Users can connect to the SLB instance over the internal network.
	AddressType *string `json:"AddressType,omitempty" xml:"AddressType,omitempty"`
	// The type of the SLB instance. Valid values:
	//
	// *   clb: Classic Load Balancer (CLB)
	// *   alb: Application Load Balancer (ALB)
	SlbType *string `json:"SlbType,omitempty" xml:"SlbType,omitempty"`
	// The ID of the virtual private cloud (VPC).
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s ListSlbRequest) String() string {
	return tea.Prettify(s)
}

func (s ListSlbRequest) GoString() string {
	return s.String()
}

func (s *ListSlbRequest) SetAddressType(v string) *ListSlbRequest {
	s.AddressType = &v
	return s
}

func (s *ListSlbRequest) SetSlbType(v string) *ListSlbRequest {
	s.SlbType = &v
	return s
}

func (s *ListSlbRequest) SetVpcId(v string) *ListSlbRequest {
	s.VpcId = &v
	return s
}

type ListSlbResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of SLB instances.
	SlbList *ListSlbResponseBodySlbList `json:"SlbList,omitempty" xml:"SlbList,omitempty" type:"Struct"`
}

func (s ListSlbResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListSlbResponseBody) GoString() string {
	return s.String()
}

func (s *ListSlbResponseBody) SetCode(v int32) *ListSlbResponseBody {
	s.Code = &v
	return s
}

func (s *ListSlbResponseBody) SetMessage(v string) *ListSlbResponseBody {
	s.Message = &v
	return s
}

func (s *ListSlbResponseBody) SetRequestId(v string) *ListSlbResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListSlbResponseBody) SetSlbList(v *ListSlbResponseBodySlbList) *ListSlbResponseBody {
	s.SlbList = v
	return s
}

type ListSlbResponseBodySlbList struct {
	SlbEntity []*ListSlbResponseBodySlbListSlbEntity `json:"SlbEntity,omitempty" xml:"SlbEntity,omitempty" type:"Repeated"`
}

func (s ListSlbResponseBodySlbList) String() string {
	return tea.Prettify(s)
}

func (s ListSlbResponseBodySlbList) GoString() string {
	return s.String()
}

func (s *ListSlbResponseBodySlbList) SetSlbEntity(v []*ListSlbResponseBodySlbListSlbEntity) *ListSlbResponseBodySlbList {
	s.SlbEntity = v
	return s
}

type ListSlbResponseBodySlbListSlbEntity struct {
	// The IP address of the SLB instance.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// The type of the IP addresses. Valid values:
	//
	// *   internet: Users can connect to the SLB instance over the Internet.
	// *   intranet: Users can connect to the SLB instance over the internal network.
	AddressType *string `json:"AddressType,omitempty" xml:"AddressType,omitempty"`
	// Indicates whether the SLB instance has expired. Valid values:
	//
	// *   true: The SLB instance has expired.
	// *   false: The SLB instance has not expired.
	Expired *bool `json:"Expired,omitempty" xml:"Expired,omitempty"`
	// The ID of the resource group in Enterprise Distributed Application Service (EDAS).
	GroupId *int32 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The type of the network.
	NetworkType *string `json:"NetworkType,omitempty" xml:"NetworkType,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Indicates whether Kubernetes applications can be reused. Valid values:
	//
	// *   true: Kubernetes applications can be reused.
	// *   false: Kubernetes applications cannot be reused.
	Reusable *bool `json:"Reusable,omitempty" xml:"Reusable,omitempty"`
	// The ID of the SLB instance.
	SlbId *string `json:"SlbId,omitempty" xml:"SlbId,omitempty"`
	// The name of the SLB instance.
	SlbName *string `json:"SlbName,omitempty" xml:"SlbName,omitempty"`
	// The status of the SLB instance.
	SlbStatus *string `json:"SlbStatus,omitempty" xml:"SlbStatus,omitempty"`
	// The tag of the SLB instance.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The ID of the user.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The ID of the VPC.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The ID of the vSwitch in the VPC.
	VswitchId *string `json:"VswitchId,omitempty" xml:"VswitchId,omitempty"`
}

func (s ListSlbResponseBodySlbListSlbEntity) String() string {
	return tea.Prettify(s)
}

func (s ListSlbResponseBodySlbListSlbEntity) GoString() string {
	return s.String()
}

func (s *ListSlbResponseBodySlbListSlbEntity) SetAddress(v string) *ListSlbResponseBodySlbListSlbEntity {
	s.Address = &v
	return s
}

func (s *ListSlbResponseBodySlbListSlbEntity) SetAddressType(v string) *ListSlbResponseBodySlbListSlbEntity {
	s.AddressType = &v
	return s
}

func (s *ListSlbResponseBodySlbListSlbEntity) SetExpired(v bool) *ListSlbResponseBodySlbListSlbEntity {
	s.Expired = &v
	return s
}

func (s *ListSlbResponseBodySlbListSlbEntity) SetGroupId(v int32) *ListSlbResponseBodySlbListSlbEntity {
	s.GroupId = &v
	return s
}

func (s *ListSlbResponseBodySlbListSlbEntity) SetNetworkType(v string) *ListSlbResponseBodySlbListSlbEntity {
	s.NetworkType = &v
	return s
}

func (s *ListSlbResponseBodySlbListSlbEntity) SetRegionId(v string) *ListSlbResponseBodySlbListSlbEntity {
	s.RegionId = &v
	return s
}

func (s *ListSlbResponseBodySlbListSlbEntity) SetReusable(v bool) *ListSlbResponseBodySlbListSlbEntity {
	s.Reusable = &v
	return s
}

func (s *ListSlbResponseBodySlbListSlbEntity) SetSlbId(v string) *ListSlbResponseBodySlbListSlbEntity {
	s.SlbId = &v
	return s
}

func (s *ListSlbResponseBodySlbListSlbEntity) SetSlbName(v string) *ListSlbResponseBodySlbListSlbEntity {
	s.SlbName = &v
	return s
}

func (s *ListSlbResponseBodySlbListSlbEntity) SetSlbStatus(v string) *ListSlbResponseBodySlbListSlbEntity {
	s.SlbStatus = &v
	return s
}

func (s *ListSlbResponseBodySlbListSlbEntity) SetTags(v string) *ListSlbResponseBodySlbListSlbEntity {
	s.Tags = &v
	return s
}

func (s *ListSlbResponseBodySlbListSlbEntity) SetUserId(v string) *ListSlbResponseBodySlbListSlbEntity {
	s.UserId = &v
	return s
}

func (s *ListSlbResponseBodySlbListSlbEntity) SetVpcId(v string) *ListSlbResponseBodySlbListSlbEntity {
	s.VpcId = &v
	return s
}

func (s *ListSlbResponseBodySlbListSlbEntity) SetVswitchId(v string) *ListSlbResponseBodySlbListSlbEntity {
	s.VswitchId = &v
	return s
}

type ListSlbResponse struct {
	Headers    map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListSlbResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListSlbResponse) String() string {
	return tea.Prettify(s)
}

func (s ListSlbResponse) GoString() string {
	return s.String()
}

func (s *ListSlbResponse) SetHeaders(v map[string]*string) *ListSlbResponse {
	s.Headers = v
	return s
}

func (s *ListSlbResponse) SetStatusCode(v int32) *ListSlbResponse {
	s.StatusCode = &v
	return s
}

func (s *ListSlbResponse) SetBody(v *ListSlbResponseBody) *ListSlbResponse {
	s.Body = v
	return s
}

type ListSubAccountResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The RAM users.
	SubAccountList *ListSubAccountResponseBodySubAccountList `json:"SubAccountList,omitempty" xml:"SubAccountList,omitempty" type:"Struct"`
}

func (s ListSubAccountResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListSubAccountResponseBody) GoString() string {
	return s.String()
}

func (s *ListSubAccountResponseBody) SetCode(v int32) *ListSubAccountResponseBody {
	s.Code = &v
	return s
}

func (s *ListSubAccountResponseBody) SetMessage(v string) *ListSubAccountResponseBody {
	s.Message = &v
	return s
}

func (s *ListSubAccountResponseBody) SetRequestId(v string) *ListSubAccountResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListSubAccountResponseBody) SetSubAccountList(v *ListSubAccountResponseBodySubAccountList) *ListSubAccountResponseBody {
	s.SubAccountList = v
	return s
}

type ListSubAccountResponseBodySubAccountList struct {
	SubAccount []*ListSubAccountResponseBodySubAccountListSubAccount `json:"SubAccount,omitempty" xml:"SubAccount,omitempty" type:"Repeated"`
}

func (s ListSubAccountResponseBodySubAccountList) String() string {
	return tea.Prettify(s)
}

func (s ListSubAccountResponseBodySubAccountList) GoString() string {
	return s.String()
}

func (s *ListSubAccountResponseBodySubAccountList) SetSubAccount(v []*ListSubAccountResponseBodySubAccountListSubAccount) *ListSubAccountResponseBodySubAccountList {
	s.SubAccount = v
	return s
}

type ListSubAccountResponseBodySubAccountListSubAccount struct {
	// The ID of the Alibaba Cloud account. This ID is generated by EDAS.
	AdminEdasId *string `json:"AdminEdasId,omitempty" xml:"AdminEdasId,omitempty"`
	// The ID of the Alibaba Cloud account.
	AdminUserId *string `json:"AdminUserId,omitempty" xml:"AdminUserId,omitempty"`
	// This parameter is the same as the AdminEdasId parameter. This parameter is deprecated.
	AdminUserKp *string `json:"AdminUserKp,omitempty" xml:"AdminUserKp,omitempty"`
	// The email address of the RAM user.
	Email *string `json:"Email,omitempty" xml:"Email,omitempty"`
	// The contact information of the RAM user.
	Phone *string `json:"Phone,omitempty" xml:"Phone,omitempty"`
	// The ID of the RAM user. This ID is generated by Enterprise Distributed Application Service (EDAS).
	SubEdasId *string `json:"SubEdasId,omitempty" xml:"SubEdasId,omitempty"`
	// The ID of the RAM user.
	SubUserId *string `json:"SubUserId,omitempty" xml:"SubUserId,omitempty"`
	// This parameter is the same as the SubEdasId parameter. This parameter is deprecated.
	SubUserKp *string `json:"SubUserKp,omitempty" xml:"SubUserKp,omitempty"`
}

func (s ListSubAccountResponseBodySubAccountListSubAccount) String() string {
	return tea.Prettify(s)
}

func (s ListSubAccountResponseBodySubAccountListSubAccount) GoString() string {
	return s.String()
}

func (s *ListSubAccountResponseBodySubAccountListSubAccount) SetAdminEdasId(v string) *ListSubAccountResponseBodySubAccountListSubAccount {
	s.AdminEdasId = &v
	return s
}

func (s *ListSubAccountResponseBodySubAccountListSubAccount) SetAdminUserId(v string) *ListSubAccountResponseBodySubAccountListSubAccount {
	s.AdminUserId = &v
	return s
}

func (s *ListSubAccountResponseBodySubAccountListSubAccount) SetAdminUserKp(v string) *ListSubAccountResponseBodySubAccountListSubAccount {
	s.AdminUserKp = &v
	return s
}

func (s *ListSubAccountResponseBodySubAccountListSubAccount) SetEmail(v string) *ListSubAccountResponseBodySubAccountListSubAccount {
	s.Email = &v
	return s
}

func (s *ListSubAccountResponseBodySubAccountListSubAccount) SetPhone(v string) *ListSubAccountResponseBodySubAccountListSubAccount {
	s.Phone = &v
	return s
}

func (s *ListSubAccountResponseBodySubAccountListSubAccount) SetSubEdasId(v string) *ListSubAccountResponseBodySubAccountListSubAccount {
	s.SubEdasId = &v
	return s
}

func (s *ListSubAccountResponseBodySubAccountListSubAccount) SetSubUserId(v string) *ListSubAccountResponseBodySubAccountListSubAccount {
	s.SubUserId = &v
	return s
}

func (s *ListSubAccountResponseBodySubAccountListSubAccount) SetSubUserKp(v string) *ListSubAccountResponseBodySubAccountListSubAccount {
	s.SubUserKp = &v
	return s
}

type ListSubAccountResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListSubAccountResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListSubAccountResponse) String() string {
	return tea.Prettify(s)
}

func (s ListSubAccountResponse) GoString() string {
	return s.String()
}

func (s *ListSubAccountResponse) SetHeaders(v map[string]*string) *ListSubAccountResponse {
	s.Headers = v
	return s
}

func (s *ListSubAccountResponse) SetStatusCode(v int32) *ListSubAccountResponse {
	s.StatusCode = &v
	return s
}

func (s *ListSubAccountResponse) SetBody(v *ListSubAccountResponseBody) *ListSubAccountResponse {
	s.Body = v
	return s
}

type ListSwimmingLaneRequest struct {
	// The ID of the lane group.
	GroupId *int64 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
}

func (s ListSwimmingLaneRequest) String() string {
	return tea.Prettify(s)
}

func (s ListSwimmingLaneRequest) GoString() string {
	return s.String()
}

func (s *ListSwimmingLaneRequest) SetGroupId(v int64) *ListSwimmingLaneRequest {
	s.GroupId = &v
	return s
}

type ListSwimmingLaneResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data that is returned.
	Data []*ListSwimmingLaneResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListSwimmingLaneResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListSwimmingLaneResponseBody) GoString() string {
	return s.String()
}

func (s *ListSwimmingLaneResponseBody) SetCode(v int32) *ListSwimmingLaneResponseBody {
	s.Code = &v
	return s
}

func (s *ListSwimmingLaneResponseBody) SetData(v []*ListSwimmingLaneResponseBodyData) *ListSwimmingLaneResponseBody {
	s.Data = v
	return s
}

func (s *ListSwimmingLaneResponseBody) SetMessage(v string) *ListSwimmingLaneResponseBody {
	s.Message = &v
	return s
}

func (s *ListSwimmingLaneResponseBody) SetRequestId(v string) *ListSwimmingLaneResponseBody {
	s.RequestId = &v
	return s
}

type ListSwimmingLaneResponseBodyData struct {
	// Indicates whether the throttling rule is enabled.
	EnableRules *bool `json:"EnableRules,omitempty" xml:"EnableRules,omitempty"`
	// The conditions.
	EntryRule *string `json:"EntryRule,omitempty" xml:"EntryRule,omitempty"`
	// The ID of the lane group.
	GroupId *int64 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The ID of the lane.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the lane.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the microservices namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The expected tag.
	ScenarioSign *string `json:"ScenarioSign,omitempty" xml:"ScenarioSign,omitempty"`
	// The applications that are related to the lane.
	SwimmingLaneAppRelationShipList []*ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList `json:"SwimmingLaneAppRelationShipList,omitempty" xml:"SwimmingLaneAppRelationShipList,omitempty" type:"Repeated"`
	// The tag.
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
}

func (s ListSwimmingLaneResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListSwimmingLaneResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListSwimmingLaneResponseBodyData) SetEnableRules(v bool) *ListSwimmingLaneResponseBodyData {
	s.EnableRules = &v
	return s
}

func (s *ListSwimmingLaneResponseBodyData) SetEntryRule(v string) *ListSwimmingLaneResponseBodyData {
	s.EntryRule = &v
	return s
}

func (s *ListSwimmingLaneResponseBodyData) SetGroupId(v int64) *ListSwimmingLaneResponseBodyData {
	s.GroupId = &v
	return s
}

func (s *ListSwimmingLaneResponseBodyData) SetId(v int64) *ListSwimmingLaneResponseBodyData {
	s.Id = &v
	return s
}

func (s *ListSwimmingLaneResponseBodyData) SetName(v string) *ListSwimmingLaneResponseBodyData {
	s.Name = &v
	return s
}

func (s *ListSwimmingLaneResponseBodyData) SetNamespaceId(v string) *ListSwimmingLaneResponseBodyData {
	s.NamespaceId = &v
	return s
}

func (s *ListSwimmingLaneResponseBodyData) SetScenarioSign(v string) *ListSwimmingLaneResponseBodyData {
	s.ScenarioSign = &v
	return s
}

func (s *ListSwimmingLaneResponseBodyData) SetSwimmingLaneAppRelationShipList(v []*ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList) *ListSwimmingLaneResponseBodyData {
	s.SwimmingLaneAppRelationShipList = v
	return s
}

func (s *ListSwimmingLaneResponseBodyData) SetTag(v string) *ListSwimmingLaneResponseBodyData {
	s.Tag = &v
	return s
}

type ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	Extra   *string `json:"Extra,omitempty" xml:"Extra,omitempty"`
	// The ID of the lane.
	LaneId *int64 `json:"LaneId,omitempty" xml:"LaneId,omitempty"`
	// The association rule.
	Rules *string `json:"Rules,omitempty" xml:"Rules,omitempty"`
}

func (s ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList) String() string {
	return tea.Prettify(s)
}

func (s ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList) GoString() string {
	return s.String()
}

func (s *ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList) SetAppId(v string) *ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList {
	s.AppId = &v
	return s
}

func (s *ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList) SetAppName(v string) *ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList {
	s.AppName = &v
	return s
}

func (s *ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList) SetExtra(v string) *ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList {
	s.Extra = &v
	return s
}

func (s *ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList) SetLaneId(v int64) *ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList {
	s.LaneId = &v
	return s
}

func (s *ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList) SetRules(v string) *ListSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList {
	s.Rules = &v
	return s
}

type ListSwimmingLaneResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListSwimmingLaneResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListSwimmingLaneResponse) String() string {
	return tea.Prettify(s)
}

func (s ListSwimmingLaneResponse) GoString() string {
	return s.String()
}

func (s *ListSwimmingLaneResponse) SetHeaders(v map[string]*string) *ListSwimmingLaneResponse {
	s.Headers = v
	return s
}

func (s *ListSwimmingLaneResponse) SetStatusCode(v int32) *ListSwimmingLaneResponse {
	s.StatusCode = &v
	return s
}

func (s *ListSwimmingLaneResponse) SetBody(v *ListSwimmingLaneResponseBody) *ListSwimmingLaneResponse {
	s.Body = v
	return s
}

type ListSwimmingLaneGroupRequest struct {
	// The ID of the lane group.
	GroupId *int64 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The ID of the namespace.
	//
	// The ID of a custom namespace is in the region ID:namespace identifier format. Example: cn-beijing:test.\
	// The ID of the default namespace is in the region ID format. Example: cn-beijing.
	LogicalRegionId *string `json:"LogicalRegionId,omitempty" xml:"LogicalRegionId,omitempty"`
}

func (s ListSwimmingLaneGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s ListSwimmingLaneGroupRequest) GoString() string {
	return s.String()
}

func (s *ListSwimmingLaneGroupRequest) SetGroupId(v int64) *ListSwimmingLaneGroupRequest {
	s.GroupId = &v
	return s
}

func (s *ListSwimmingLaneGroupRequest) SetLogicalRegionId(v string) *ListSwimmingLaneGroupRequest {
	s.LogicalRegionId = &v
	return s
}

type ListSwimmingLaneGroupResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data of the lane group.
	Data []*ListSwimmingLaneGroupResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListSwimmingLaneGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListSwimmingLaneGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ListSwimmingLaneGroupResponseBody) SetCode(v int32) *ListSwimmingLaneGroupResponseBody {
	s.Code = &v
	return s
}

func (s *ListSwimmingLaneGroupResponseBody) SetData(v []*ListSwimmingLaneGroupResponseBodyData) *ListSwimmingLaneGroupResponseBody {
	s.Data = v
	return s
}

func (s *ListSwimmingLaneGroupResponseBody) SetMessage(v string) *ListSwimmingLaneGroupResponseBody {
	s.Message = &v
	return s
}

func (s *ListSwimmingLaneGroupResponseBody) SetRequestId(v string) *ListSwimmingLaneGroupResponseBody {
	s.RequestId = &v
	return s
}

type ListSwimmingLaneGroupResponseBodyData struct {
	// The applications that are related to the lane group.
	ApplicationList []*ListSwimmingLaneGroupResponseBodyDataApplicationList `json:"ApplicationList,omitempty" xml:"ApplicationList,omitempty" type:"Repeated"`
	// The information about the Enterprise Distributed Application Service (EDAS) ingress gateway.
	EntryApplication *ListSwimmingLaneGroupResponseBodyDataEntryApplication `json:"EntryApplication,omitempty" xml:"EntryApplication,omitempty" type:"Struct"`
	// The ID of the lane group.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the lane group.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the microservices namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
}

func (s ListSwimmingLaneGroupResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListSwimmingLaneGroupResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListSwimmingLaneGroupResponseBodyData) SetApplicationList(v []*ListSwimmingLaneGroupResponseBodyDataApplicationList) *ListSwimmingLaneGroupResponseBodyData {
	s.ApplicationList = v
	return s
}

func (s *ListSwimmingLaneGroupResponseBodyData) SetEntryApplication(v *ListSwimmingLaneGroupResponseBodyDataEntryApplication) *ListSwimmingLaneGroupResponseBodyData {
	s.EntryApplication = v
	return s
}

func (s *ListSwimmingLaneGroupResponseBodyData) SetId(v int64) *ListSwimmingLaneGroupResponseBodyData {
	s.Id = &v
	return s
}

func (s *ListSwimmingLaneGroupResponseBodyData) SetName(v string) *ListSwimmingLaneGroupResponseBodyData {
	s.Name = &v
	return s
}

func (s *ListSwimmingLaneGroupResponseBodyData) SetNamespaceId(v string) *ListSwimmingLaneGroupResponseBodyData {
	s.NamespaceId = &v
	return s
}

type ListSwimmingLaneGroupResponseBodyDataApplicationList struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
}

func (s ListSwimmingLaneGroupResponseBodyDataApplicationList) String() string {
	return tea.Prettify(s)
}

func (s ListSwimmingLaneGroupResponseBodyDataApplicationList) GoString() string {
	return s.String()
}

func (s *ListSwimmingLaneGroupResponseBodyDataApplicationList) SetAppId(v string) *ListSwimmingLaneGroupResponseBodyDataApplicationList {
	s.AppId = &v
	return s
}

func (s *ListSwimmingLaneGroupResponseBodyDataApplicationList) SetAppName(v string) *ListSwimmingLaneGroupResponseBodyDataApplicationList {
	s.AppName = &v
	return s
}

type ListSwimmingLaneGroupResponseBodyDataEntryApplication struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The data source. Set the value to EDAS.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
}

func (s ListSwimmingLaneGroupResponseBodyDataEntryApplication) String() string {
	return tea.Prettify(s)
}

func (s ListSwimmingLaneGroupResponseBodyDataEntryApplication) GoString() string {
	return s.String()
}

func (s *ListSwimmingLaneGroupResponseBodyDataEntryApplication) SetAppId(v string) *ListSwimmingLaneGroupResponseBodyDataEntryApplication {
	s.AppId = &v
	return s
}

func (s *ListSwimmingLaneGroupResponseBodyDataEntryApplication) SetAppName(v string) *ListSwimmingLaneGroupResponseBodyDataEntryApplication {
	s.AppName = &v
	return s
}

func (s *ListSwimmingLaneGroupResponseBodyDataEntryApplication) SetSource(v string) *ListSwimmingLaneGroupResponseBodyDataEntryApplication {
	s.Source = &v
	return s
}

type ListSwimmingLaneGroupResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListSwimmingLaneGroupResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListSwimmingLaneGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ListSwimmingLaneGroupResponse) GoString() string {
	return s.String()
}

func (s *ListSwimmingLaneGroupResponse) SetHeaders(v map[string]*string) *ListSwimmingLaneGroupResponse {
	s.Headers = v
	return s
}

func (s *ListSwimmingLaneGroupResponse) SetStatusCode(v int32) *ListSwimmingLaneGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ListSwimmingLaneGroupResponse) SetBody(v *ListSwimmingLaneGroupResponseBody) *ListSwimmingLaneGroupResponse {
	s.Body = v
	return s
}

type ListTagResourcesRequest struct {
	// The IDs of the resources. You can specify up to 20 IDs. Set this parameter to a JSON array.
	ResourceIds map[string]interface{} `json:"ResourceIds,omitempty" xml:"ResourceIds,omitempty"`
	// The region in which the resource resides.
	ResourceRegionId *string `json:"ResourceRegionId,omitempty" xml:"ResourceRegionId,omitempty"`
	// The type of the resource. Valid values:
	//
	// *   **application**: Enterprise Distributed Application Service (EDAS) application
	// *   **cluster**: EDAS cluster
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The key-value pairs that specify the tags.
	//
	// *   You can add up to 20 tags to a resource.
	// *   The key cannot start with **aliyun** or **acs:** and cannot contain **http://** or **https://**.
	// *   The tag key or tag value can be up to 128 characters in length, and can contain letters, digits, hyphens (-), commas (,), asterisks (\*), forward slashes (/), question marks (?), and colons (:).
	// *   Set this parameter to a JSON array.
	Tags map[string]interface{} `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s ListTagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesRequest) GoString() string {
	return s.String()
}

func (s *ListTagResourcesRequest) SetResourceIds(v map[string]interface{}) *ListTagResourcesRequest {
	s.ResourceIds = v
	return s
}

func (s *ListTagResourcesRequest) SetResourceRegionId(v string) *ListTagResourcesRequest {
	s.ResourceRegionId = &v
	return s
}

func (s *ListTagResourcesRequest) SetResourceType(v string) *ListTagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesRequest) SetTags(v map[string]interface{}) *ListTagResourcesRequest {
	s.Tags = v
	return s
}

type ListTagResourcesResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about resource tags.
	TagResources *ListTagResourcesResponseBodyTagResources `json:"TagResources,omitempty" xml:"TagResources,omitempty" type:"Struct"`
}

func (s ListTagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBody) SetCode(v int32) *ListTagResourcesResponseBody {
	s.Code = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetMessage(v string) *ListTagResourcesResponseBody {
	s.Message = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetRequestId(v string) *ListTagResourcesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetTagResources(v *ListTagResourcesResponseBodyTagResources) *ListTagResourcesResponseBody {
	s.TagResources = v
	return s
}

type ListTagResourcesResponseBodyTagResources struct {
	TagResource []*ListTagResourcesResponseBodyTagResourcesTagResource `json:"TagResource,omitempty" xml:"TagResource,omitempty" type:"Repeated"`
}

func (s ListTagResourcesResponseBodyTagResources) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBodyTagResources) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBodyTagResources) SetTagResource(v []*ListTagResourcesResponseBodyTagResourcesTagResource) *ListTagResourcesResponseBodyTagResources {
	s.TagResource = v
	return s
}

type ListTagResourcesResponseBodyTagResourcesTagResource struct {
	// The ID of the resource.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of the resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tag key of the resource.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The tag value of the resource.
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s ListTagResourcesResponseBodyTagResourcesTagResource) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBodyTagResourcesTagResource) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetResourceId(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.ResourceId = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetResourceType(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetTagKey(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.TagKey = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetTagValue(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.TagValue = &v
	return s
}

type ListTagResourcesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListTagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListTagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponse) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponse) SetHeaders(v map[string]*string) *ListTagResourcesResponse {
	s.Headers = v
	return s
}

func (s *ListTagResourcesResponse) SetStatusCode(v int32) *ListTagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTagResourcesResponse) SetBody(v *ListTagResourcesResponseBody) *ListTagResourcesResponse {
	s.Body = v
	return s
}

type ListUserDefineRegionRequest struct {
	// Specifies whether remote debugging is allowed.
	DebugEnable *bool `json:"DebugEnable,omitempty" xml:"DebugEnable,omitempty"`
}

func (s ListUserDefineRegionRequest) String() string {
	return tea.Prettify(s)
}

func (s ListUserDefineRegionRequest) GoString() string {
	return s.String()
}

func (s *ListUserDefineRegionRequest) SetDebugEnable(v bool) *ListUserDefineRegionRequest {
	s.DebugEnable = &v
	return s
}

type ListUserDefineRegionResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The namespaces.
	UserDefineRegionList *ListUserDefineRegionResponseBodyUserDefineRegionList `json:"UserDefineRegionList,omitempty" xml:"UserDefineRegionList,omitempty" type:"Struct"`
}

func (s ListUserDefineRegionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListUserDefineRegionResponseBody) GoString() string {
	return s.String()
}

func (s *ListUserDefineRegionResponseBody) SetCode(v int32) *ListUserDefineRegionResponseBody {
	s.Code = &v
	return s
}

func (s *ListUserDefineRegionResponseBody) SetMessage(v string) *ListUserDefineRegionResponseBody {
	s.Message = &v
	return s
}

func (s *ListUserDefineRegionResponseBody) SetRequestId(v string) *ListUserDefineRegionResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListUserDefineRegionResponseBody) SetUserDefineRegionList(v *ListUserDefineRegionResponseBodyUserDefineRegionList) *ListUserDefineRegionResponseBody {
	s.UserDefineRegionList = v
	return s
}

type ListUserDefineRegionResponseBodyUserDefineRegionList struct {
	UserDefineRegionEntity []*ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity `json:"UserDefineRegionEntity,omitempty" xml:"UserDefineRegionEntity,omitempty" type:"Repeated"`
}

func (s ListUserDefineRegionResponseBodyUserDefineRegionList) String() string {
	return tea.Prettify(s)
}

func (s ListUserDefineRegionResponseBodyUserDefineRegionList) GoString() string {
	return s.String()
}

func (s *ListUserDefineRegionResponseBodyUserDefineRegionList) SetUserDefineRegionEntity(v []*ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity) *ListUserDefineRegionResponseBodyUserDefineRegionList {
	s.UserDefineRegionEntity = v
	return s
}

type ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity struct {
	// The ID of the region to which the namespace belongs.
	BelongRegion *string `json:"BelongRegion,omitempty" xml:"BelongRegion,omitempty"`
	// Indicates whether remote debugging is allowed.
	DebugEnable *bool `json:"DebugEnable,omitempty" xml:"DebugEnable,omitempty"`
	// The description of the namespace.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The unique identifier of the namespace.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The type of the registry. Valid values:
	//
	// *   default: shared service registry of Enterprise Distributed Application Service (EDAS)
	// *   exclusive_mse: Microservices Engine (MSE) Nacos registry
	MseInstanceId *string `json:"MseInstanceId,omitempty" xml:"MseInstanceId,omitempty"`
	// The ID of the namespace.
	//
	// > The ID cannot be changed after the namespace is created. The ID is in the `Physical region ID:Logical region identifier` format .
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The name of the namespace.
	RegionName *string `json:"RegionName,omitempty" xml:"RegionName,omitempty"`
	// The ID of the MSE instance.
	RegistryType *string `json:"RegistryType,omitempty" xml:"RegistryType,omitempty"`
	// The ID of the Alibaba Cloud account to which the namespace belongs.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity) String() string {
	return tea.Prettify(s)
}

func (s ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity) GoString() string {
	return s.String()
}

func (s *ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity) SetBelongRegion(v string) *ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity {
	s.BelongRegion = &v
	return s
}

func (s *ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity) SetDebugEnable(v bool) *ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity {
	s.DebugEnable = &v
	return s
}

func (s *ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity) SetDescription(v string) *ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity {
	s.Description = &v
	return s
}

func (s *ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity) SetId(v int64) *ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity {
	s.Id = &v
	return s
}

func (s *ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity) SetMseInstanceId(v string) *ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity {
	s.MseInstanceId = &v
	return s
}

func (s *ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity) SetRegionId(v string) *ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity {
	s.RegionId = &v
	return s
}

func (s *ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity) SetRegionName(v string) *ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity {
	s.RegionName = &v
	return s
}

func (s *ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity) SetRegistryType(v string) *ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity {
	s.RegistryType = &v
	return s
}

func (s *ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity) SetUserId(v string) *ListUserDefineRegionResponseBodyUserDefineRegionListUserDefineRegionEntity {
	s.UserId = &v
	return s
}

type ListUserDefineRegionResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListUserDefineRegionResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListUserDefineRegionResponse) String() string {
	return tea.Prettify(s)
}

func (s ListUserDefineRegionResponse) GoString() string {
	return s.String()
}

func (s *ListUserDefineRegionResponse) SetHeaders(v map[string]*string) *ListUserDefineRegionResponse {
	s.Headers = v
	return s
}

func (s *ListUserDefineRegionResponse) SetStatusCode(v int32) *ListUserDefineRegionResponse {
	s.StatusCode = &v
	return s
}

func (s *ListUserDefineRegionResponse) SetBody(v *ListUserDefineRegionResponseBody) *ListUserDefineRegionResponse {
	s.Body = v
	return s
}

type ListVpcResponseBody struct {
	// The ID of the request.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The information about VPCs.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The name of the VPC.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the VPC is available. Valid values:
	// - true: The VPC is available.
	// - false: The VPC is unavailable.
	VpcList *ListVpcResponseBodyVpcList `json:"VpcList,omitempty" xml:"VpcList,omitempty" type:"Struct"`
}

func (s ListVpcResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListVpcResponseBody) GoString() string {
	return s.String()
}

func (s *ListVpcResponseBody) SetCode(v int32) *ListVpcResponseBody {
	s.Code = &v
	return s
}

func (s *ListVpcResponseBody) SetMessage(v string) *ListVpcResponseBody {
	s.Message = &v
	return s
}

func (s *ListVpcResponseBody) SetRequestId(v string) *ListVpcResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListVpcResponseBody) SetVpcList(v *ListVpcResponseBodyVpcList) *ListVpcResponseBody {
	s.VpcList = v
	return s
}

type ListVpcResponseBodyVpcList struct {
	VpcEntity []*ListVpcResponseBodyVpcListVpcEntity `json:"VpcEntity,omitempty" xml:"VpcEntity,omitempty" type:"Repeated"`
}

func (s ListVpcResponseBodyVpcList) String() string {
	return tea.Prettify(s)
}

func (s ListVpcResponseBodyVpcList) GoString() string {
	return s.String()
}

func (s *ListVpcResponseBodyVpcList) SetVpcEntity(v []*ListVpcResponseBodyVpcListVpcEntity) *ListVpcResponseBodyVpcList {
	s.VpcEntity = v
	return s
}

type ListVpcResponseBodyVpcListVpcEntity struct {
	// This operation uses only common request headers. For more information, see [Common parameters for API calls](~~123488~~).
	EcsNum *int32 `json:"EcsNum,omitempty" xml:"EcsNum,omitempty"`
	// The region ID of the VPC.
	Expired *bool `json:"Expired,omitempty" xml:"Expired,omitempty"`
	// No request parameters.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// GET /pop/v5/vpc_list HTTP/1.1
	// Common request headers
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The ID of the Alibaba Cloud account to which the VPC belongs.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The number of ECS instances associated with the VPC.
	VpcName *string `json:"VpcName,omitempty" xml:"VpcName,omitempty"`
}

func (s ListVpcResponseBodyVpcListVpcEntity) String() string {
	return tea.Prettify(s)
}

func (s ListVpcResponseBodyVpcListVpcEntity) GoString() string {
	return s.String()
}

func (s *ListVpcResponseBodyVpcListVpcEntity) SetEcsNum(v int32) *ListVpcResponseBodyVpcListVpcEntity {
	s.EcsNum = &v
	return s
}

func (s *ListVpcResponseBodyVpcListVpcEntity) SetExpired(v bool) *ListVpcResponseBodyVpcListVpcEntity {
	s.Expired = &v
	return s
}

func (s *ListVpcResponseBodyVpcListVpcEntity) SetRegionId(v string) *ListVpcResponseBodyVpcListVpcEntity {
	s.RegionId = &v
	return s
}

func (s *ListVpcResponseBodyVpcListVpcEntity) SetUserId(v string) *ListVpcResponseBodyVpcListVpcEntity {
	s.UserId = &v
	return s
}

func (s *ListVpcResponseBodyVpcListVpcEntity) SetVpcId(v string) *ListVpcResponseBodyVpcListVpcEntity {
	s.VpcId = &v
	return s
}

func (s *ListVpcResponseBodyVpcListVpcEntity) SetVpcName(v string) *ListVpcResponseBodyVpcListVpcEntity {
	s.VpcName = &v
	return s
}

type ListVpcResponse struct {
	Headers    map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListVpcResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListVpcResponse) String() string {
	return tea.Prettify(s)
}

func (s ListVpcResponse) GoString() string {
	return s.String()
}

func (s *ListVpcResponse) SetHeaders(v map[string]*string) *ListVpcResponse {
	s.Headers = v
	return s
}

func (s *ListVpcResponse) SetStatusCode(v int32) *ListVpcResponse {
	s.StatusCode = &v
	return s
}

func (s *ListVpcResponse) SetBody(v *ListVpcResponseBody) *ListVpcResponse {
	s.Body = v
	return s
}

type MigrateEcuRequest struct {
	// The ID of the ECS instance. Separate multiple IDs with commas (,).
	InstanceIds *string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty"`
	// The ID of the custom namespace.
	//
	// *   The ID of a custom namespace is in the `region ID:custom namespace ID` format. Example: cn-beijing:tdy218.
	// *   The ID of the default namespace is in the `region ID` format. Example: cn-beijing.
	LogicalRegionId *string `json:"LogicalRegionId,omitempty" xml:"LogicalRegionId,omitempty"`
}

func (s MigrateEcuRequest) String() string {
	return tea.Prettify(s)
}

func (s MigrateEcuRequest) GoString() string {
	return s.String()
}

func (s *MigrateEcuRequest) SetInstanceIds(v string) *MigrateEcuRequest {
	s.InstanceIds = &v
	return s
}

func (s *MigrateEcuRequest) SetLogicalRegionId(v string) *MigrateEcuRequest {
	s.LogicalRegionId = &v
	return s
}

type MigrateEcuResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   true: The request is successful.
	// *   false: The request fails.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s MigrateEcuResponseBody) String() string {
	return tea.Prettify(s)
}

func (s MigrateEcuResponseBody) GoString() string {
	return s.String()
}

func (s *MigrateEcuResponseBody) SetCode(v int32) *MigrateEcuResponseBody {
	s.Code = &v
	return s
}

func (s *MigrateEcuResponseBody) SetData(v string) *MigrateEcuResponseBody {
	s.Data = &v
	return s
}

func (s *MigrateEcuResponseBody) SetMessage(v string) *MigrateEcuResponseBody {
	s.Message = &v
	return s
}

func (s *MigrateEcuResponseBody) SetRequestId(v string) *MigrateEcuResponseBody {
	s.RequestId = &v
	return s
}

type MigrateEcuResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *MigrateEcuResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s MigrateEcuResponse) String() string {
	return tea.Prettify(s)
}

func (s MigrateEcuResponse) GoString() string {
	return s.String()
}

func (s *MigrateEcuResponse) SetHeaders(v map[string]*string) *MigrateEcuResponse {
	s.Headers = v
	return s
}

func (s *MigrateEcuResponse) SetStatusCode(v int32) *MigrateEcuResponse {
	s.StatusCode = &v
	return s
}

func (s *MigrateEcuResponse) SetBody(v *MigrateEcuResponseBody) *MigrateEcuResponse {
	s.Body = v
	return s
}

type ModifyScalingRuleRequest struct {
	// Set the value to true if scale-outs are allowed.
	AcceptEULA *bool `json:"AcceptEULA,omitempty" xml:"AcceptEULA,omitempty"`
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the instance group to which the application is deployed.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The relationship among the conditions that trigger a scale-in.
	//
	// *   OR: one of the conditions
	// *   AND: all conditions
	InCondition *string `json:"InCondition,omitempty" xml:"InCondition,omitempty"`
	// The CPU utilization that triggers a scale-in.
	InCpu *int32 `json:"InCpu,omitempty" xml:"InCpu,omitempty"`
	// The duration in which the metric threshold is exceeded. Unit: minutes.
	InDuration *int32 `json:"InDuration,omitempty" xml:"InDuration,omitempty"`
	// Specifies whether to allow scale-ins.
	//
	// *   true: allows scale-ins.
	// *   false: does not allow scale-ins.
	InEnable *bool `json:"InEnable,omitempty" xml:"InEnable,omitempty"`
	// The minimum number of instances that must be retained in each group when a scale-in is performed.
	InInstanceNum *int32 `json:"InInstanceNum,omitempty" xml:"InInstanceNum,omitempty"`
	// The system load that triggers a scale-in.
	InLoad *int32 `json:"InLoad,omitempty" xml:"InLoad,omitempty"`
	// The minimum service latency that triggers a scale-in. The lower limit is 0. Unit: milliseconds.
	InRT *int32 `json:"InRT,omitempty" xml:"InRT,omitempty"`
	// The number of instances that are removed during each scale-in.
	InStep *int32 `json:"InStep,omitempty" xml:"InStep,omitempty"`
	// The key pair that is used to log on to the instance. This parameter takes effect only if you choose to create instances based on the specifications of an existing instance during a scale-out.
	KeyPairName *string `json:"KeyPairName,omitempty" xml:"KeyPairName,omitempty"`
	// The multi-zone scaling policy. Valid values:
	//
	// *   PRIORITY: The vSwitch that is first selected has the highest priority.
	// *   BALANCE: This policy evenly distributes instances across zones in which the vSwitches reside.
	MultiAzPolicy *string `json:"MultiAzPolicy,omitempty" xml:"MultiAzPolicy,omitempty"`
	// The CPU utilization that triggers a scale-out.
	OutCPU *int32 `json:"OutCPU,omitempty" xml:"OutCPU,omitempty"`
	// The relationship among the conditions that trigger a scale-out.
	//
	// *   OR: one of the conditions
	// *   AND: all conditions
	OutCondition *string `json:"OutCondition,omitempty" xml:"OutCondition,omitempty"`
	// The duration in which the metric threshold is exceeded. Unit: minutes.
	OutDuration *int32 `json:"OutDuration,omitempty" xml:"OutDuration,omitempty"`
	// Specifies whether to allow scale-outs.
	OutEnable *bool `json:"OutEnable,omitempty" xml:"OutEnable,omitempty"`
	// The maximum number of instances in each group when a scale-out is performed.
	OutInstanceNum *int32 `json:"OutInstanceNum,omitempty" xml:"OutInstanceNum,omitempty"`
	// The system load that triggers a scale-out.
	OutLoad *int32 `json:"OutLoad,omitempty" xml:"OutLoad,omitempty"`
	// The minimum service latency that triggers a scale-out. The lower limit is 0. Unit: milliseconds.
	OutRT *int32 `json:"OutRT,omitempty" xml:"OutRT,omitempty"`
	// The number of instances that are added during each scale-out.
	OutStep *int32 `json:"OutStep,omitempty" xml:"OutStep,omitempty"`
	// The password that is used to log on to the instance. This parameter takes effect only if you choose to create instances based on the specifications of an existing instance during a scale-out.
	Password *string `json:"Password,omitempty" xml:"Password,omitempty"`
	// The source of the instance to be added during a scale-out. Valid values:
	//
	// *   NEW: elastic resources
	// *   AVAILABLE: existing resources If you prefer existing resources to elastic resources, set this parameter to AVAILABLE_FIRST.
	//
	// If you set this parameter to NEW or AVAILABLE_FIRST, you must specify the auto-scaling parameters. If you set this parameter to NEW, instances are created based on a launch template or the specifications of an existing instance.
	ResourceFrom *string `json:"ResourceFrom,omitempty" xml:"ResourceFrom,omitempty"`
	// The instance handling mode during a scale-in. Valid values:
	//
	// *   release: When a scale-in is performed, instances that are no longer used are released.
	// *   recycle: When a scale-in is performed, instances that are no longer used are stopped and reclaimed.
	ScalingPolicy *string `json:"ScalingPolicy,omitempty" xml:"ScalingPolicy,omitempty"`
	// The ID of the launch template that is used to create instances during a scale-out. This parameter takes effect only if you set the OutEnable parameter to true. This parameter takes precedence over the TemplateInstanceId parameter.
	TemplateId *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The ID of the instance whose specifications are used to create instances during a scale-out. This parameter is valid only when you set the OutEnable parameter to true.
	TemplateInstanceId *string `json:"TemplateInstanceId,omitempty" xml:"TemplateInstanceId,omitempty"`
	// The name of the instance whose specifications are used to create instances during a scale-out. This parameter takes effect only if you specify the TemplateInstanceId parameter.
	TemplateInstanceName *string `json:"TemplateInstanceName,omitempty" xml:"TemplateInstanceName,omitempty"`
	// The version of the launch template that is used to create instances during a scale-out. This parameter takes effect only if you set the OutEnable parameter to true. To use the default template version, set this parameter to `-1`. Otherwise, set this parameter to the version that you want to use.
	TemplateVersion *int32 `json:"TemplateVersion,omitempty" xml:"TemplateVersion,omitempty"`
	// The IDs of the vSwitches that are associated with the VPC. Separate multiple IDs with commas (,).
	VSwitchIds *string `json:"VSwitchIds,omitempty" xml:"VSwitchIds,omitempty"`
	// The ID of the virtual private cloud (VPC) that is associated with the instances created based on a launch template or the specifications of an existing instance.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s ModifyScalingRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingRuleRequest) GoString() string {
	return s.String()
}

func (s *ModifyScalingRuleRequest) SetAcceptEULA(v bool) *ModifyScalingRuleRequest {
	s.AcceptEULA = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetAppId(v string) *ModifyScalingRuleRequest {
	s.AppId = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetGroupId(v string) *ModifyScalingRuleRequest {
	s.GroupId = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetInCondition(v string) *ModifyScalingRuleRequest {
	s.InCondition = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetInCpu(v int32) *ModifyScalingRuleRequest {
	s.InCpu = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetInDuration(v int32) *ModifyScalingRuleRequest {
	s.InDuration = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetInEnable(v bool) *ModifyScalingRuleRequest {
	s.InEnable = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetInInstanceNum(v int32) *ModifyScalingRuleRequest {
	s.InInstanceNum = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetInLoad(v int32) *ModifyScalingRuleRequest {
	s.InLoad = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetInRT(v int32) *ModifyScalingRuleRequest {
	s.InRT = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetInStep(v int32) *ModifyScalingRuleRequest {
	s.InStep = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetKeyPairName(v string) *ModifyScalingRuleRequest {
	s.KeyPairName = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetMultiAzPolicy(v string) *ModifyScalingRuleRequest {
	s.MultiAzPolicy = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetOutCPU(v int32) *ModifyScalingRuleRequest {
	s.OutCPU = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetOutCondition(v string) *ModifyScalingRuleRequest {
	s.OutCondition = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetOutDuration(v int32) *ModifyScalingRuleRequest {
	s.OutDuration = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetOutEnable(v bool) *ModifyScalingRuleRequest {
	s.OutEnable = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetOutInstanceNum(v int32) *ModifyScalingRuleRequest {
	s.OutInstanceNum = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetOutLoad(v int32) *ModifyScalingRuleRequest {
	s.OutLoad = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetOutRT(v int32) *ModifyScalingRuleRequest {
	s.OutRT = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetOutStep(v int32) *ModifyScalingRuleRequest {
	s.OutStep = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetPassword(v string) *ModifyScalingRuleRequest {
	s.Password = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetResourceFrom(v string) *ModifyScalingRuleRequest {
	s.ResourceFrom = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetScalingPolicy(v string) *ModifyScalingRuleRequest {
	s.ScalingPolicy = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetTemplateId(v string) *ModifyScalingRuleRequest {
	s.TemplateId = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetTemplateInstanceId(v string) *ModifyScalingRuleRequest {
	s.TemplateInstanceId = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetTemplateInstanceName(v string) *ModifyScalingRuleRequest {
	s.TemplateInstanceName = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetTemplateVersion(v int32) *ModifyScalingRuleRequest {
	s.TemplateVersion = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetVSwitchIds(v string) *ModifyScalingRuleRequest {
	s.VSwitchIds = &v
	return s
}

func (s *ModifyScalingRuleRequest) SetVpcId(v string) *ModifyScalingRuleRequest {
	s.VpcId = &v
	return s
}

type ModifyScalingRuleResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyScalingRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingRuleResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyScalingRuleResponseBody) SetCode(v int32) *ModifyScalingRuleResponseBody {
	s.Code = &v
	return s
}

func (s *ModifyScalingRuleResponseBody) SetMessage(v string) *ModifyScalingRuleResponseBody {
	s.Message = &v
	return s
}

func (s *ModifyScalingRuleResponseBody) SetRequestId(v string) *ModifyScalingRuleResponseBody {
	s.RequestId = &v
	return s
}

type ModifyScalingRuleResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ModifyScalingRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ModifyScalingRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyScalingRuleResponse) GoString() string {
	return s.String()
}

func (s *ModifyScalingRuleResponse) SetHeaders(v map[string]*string) *ModifyScalingRuleResponse {
	s.Headers = v
	return s
}

func (s *ModifyScalingRuleResponse) SetStatusCode(v int32) *ModifyScalingRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyScalingRuleResponse) SetBody(v *ModifyScalingRuleResponseBody) *ModifyScalingRuleResponse {
	s.Body = v
	return s
}

type QueryApplicationStatusRequest struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
}

func (s QueryApplicationStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryApplicationStatusRequest) GoString() string {
	return s.String()
}

func (s *QueryApplicationStatusRequest) SetAppId(v string) *QueryApplicationStatusRequest {
	s.AppId = &v
	return s
}

type QueryApplicationStatusResponseBody struct {
	// The information about the application.
	AppInfo *QueryApplicationStatusResponseBodyAppInfo `json:"AppInfo,omitempty" xml:"AppInfo,omitempty" type:"Struct"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s QueryApplicationStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryApplicationStatusResponseBody) GoString() string {
	return s.String()
}

func (s *QueryApplicationStatusResponseBody) SetAppInfo(v *QueryApplicationStatusResponseBodyAppInfo) *QueryApplicationStatusResponseBody {
	s.AppInfo = v
	return s
}

func (s *QueryApplicationStatusResponseBody) SetCode(v int32) *QueryApplicationStatusResponseBody {
	s.Code = &v
	return s
}

func (s *QueryApplicationStatusResponseBody) SetMessage(v string) *QueryApplicationStatusResponseBody {
	s.Message = &v
	return s
}

func (s *QueryApplicationStatusResponseBody) SetRequestId(v string) *QueryApplicationStatusResponseBody {
	s.RequestId = &v
	return s
}

type QueryApplicationStatusResponseBodyAppInfo struct {
	// The basic information about the application.
	Application *QueryApplicationStatusResponseBodyAppInfoApplication `json:"Application,omitempty" xml:"Application,omitempty" type:"Struct"`
	// The information about deployment records.
	DeployRecordList *QueryApplicationStatusResponseBodyAppInfoDeployRecordList `json:"DeployRecordList,omitempty" xml:"DeployRecordList,omitempty" type:"Struct"`
	// The information about elastic compute containers (ECCs).
	EccList *QueryApplicationStatusResponseBodyAppInfoEccList `json:"EccList,omitempty" xml:"EccList,omitempty" type:"Struct"`
	// The information about elastic compute units (ECUs).
	EcuList *QueryApplicationStatusResponseBodyAppInfoEcuList `json:"EcuList,omitempty" xml:"EcuList,omitempty" type:"Struct"`
	// The information about the instance groups.
	GroupList *QueryApplicationStatusResponseBodyAppInfoGroupList `json:"GroupList,omitempty" xml:"GroupList,omitempty" type:"Struct"`
}

func (s QueryApplicationStatusResponseBodyAppInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryApplicationStatusResponseBodyAppInfo) GoString() string {
	return s.String()
}

func (s *QueryApplicationStatusResponseBodyAppInfo) SetApplication(v *QueryApplicationStatusResponseBodyAppInfoApplication) *QueryApplicationStatusResponseBodyAppInfo {
	s.Application = v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfo) SetDeployRecordList(v *QueryApplicationStatusResponseBodyAppInfoDeployRecordList) *QueryApplicationStatusResponseBodyAppInfo {
	s.DeployRecordList = v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfo) SetEccList(v *QueryApplicationStatusResponseBodyAppInfoEccList) *QueryApplicationStatusResponseBodyAppInfo {
	s.EccList = v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfo) SetEcuList(v *QueryApplicationStatusResponseBodyAppInfoEcuList) *QueryApplicationStatusResponseBodyAppInfo {
	s.EcuList = v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfo) SetGroupList(v *QueryApplicationStatusResponseBodyAppInfoGroupList) *QueryApplicationStatusResponseBodyAppInfo {
	s.GroupList = v
	return s
}

type QueryApplicationStatusResponseBodyAppInfoApplication struct {
	// The ID of the application.
	ApplicationId *string `json:"ApplicationId,omitempty" xml:"ApplicationId,omitempty"`
	// The build package number of Enterprise Distributed Application Service (EDAS) Container.
	BuildPackageId *int32 `json:"BuildPackageId,omitempty" xml:"BuildPackageId,omitempty"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The number of CPU cores used by the application.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The time when the application was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// Indicates whether the application is a Docker application.
	Dockerize *bool `json:"Dockerize,omitempty" xml:"Dockerize,omitempty"`
	// The email address of the user who created the application.
	Email *string `json:"Email,omitempty" xml:"Email,omitempty"`
	// The health check URL.
	HealthCheckUrl *string `json:"HealthCheckUrl,omitempty" xml:"HealthCheckUrl,omitempty"`
	// The number of application instances.
	InstanceCount *int32 `json:"InstanceCount,omitempty" xml:"InstanceCount,omitempty"`
	// The time when the application was launched. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	LaunchTime *int64 `json:"LaunchTime,omitempty" xml:"LaunchTime,omitempty"`
	// The memory size.
	Memory *int32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// The name of the application.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the user who created the application.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The mobile number of the user who created the application.
	Phone *string `json:"Phone,omitempty" xml:"Phone,omitempty"`
	// The port used by the application.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The ID of the namespace.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The number of application instances that are running.
	RunningInstanceCount *int32 `json:"RunningInstanceCount,omitempty" xml:"RunningInstanceCount,omitempty"`
	// The ID of the Alibaba Cloud account.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s QueryApplicationStatusResponseBodyAppInfoApplication) String() string {
	return tea.Prettify(s)
}

func (s QueryApplicationStatusResponseBodyAppInfoApplication) GoString() string {
	return s.String()
}

func (s *QueryApplicationStatusResponseBodyAppInfoApplication) SetApplicationId(v string) *QueryApplicationStatusResponseBodyAppInfoApplication {
	s.ApplicationId = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoApplication) SetBuildPackageId(v int32) *QueryApplicationStatusResponseBodyAppInfoApplication {
	s.BuildPackageId = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoApplication) SetClusterId(v string) *QueryApplicationStatusResponseBodyAppInfoApplication {
	s.ClusterId = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoApplication) SetCpu(v int32) *QueryApplicationStatusResponseBodyAppInfoApplication {
	s.Cpu = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoApplication) SetCreateTime(v int64) *QueryApplicationStatusResponseBodyAppInfoApplication {
	s.CreateTime = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoApplication) SetDockerize(v bool) *QueryApplicationStatusResponseBodyAppInfoApplication {
	s.Dockerize = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoApplication) SetEmail(v string) *QueryApplicationStatusResponseBodyAppInfoApplication {
	s.Email = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoApplication) SetHealthCheckUrl(v string) *QueryApplicationStatusResponseBodyAppInfoApplication {
	s.HealthCheckUrl = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoApplication) SetInstanceCount(v int32) *QueryApplicationStatusResponseBodyAppInfoApplication {
	s.InstanceCount = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoApplication) SetLaunchTime(v int64) *QueryApplicationStatusResponseBodyAppInfoApplication {
	s.LaunchTime = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoApplication) SetMemory(v int32) *QueryApplicationStatusResponseBodyAppInfoApplication {
	s.Memory = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoApplication) SetName(v string) *QueryApplicationStatusResponseBodyAppInfoApplication {
	s.Name = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoApplication) SetOwner(v string) *QueryApplicationStatusResponseBodyAppInfoApplication {
	s.Owner = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoApplication) SetPhone(v string) *QueryApplicationStatusResponseBodyAppInfoApplication {
	s.Phone = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoApplication) SetPort(v int32) *QueryApplicationStatusResponseBodyAppInfoApplication {
	s.Port = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoApplication) SetRegionId(v string) *QueryApplicationStatusResponseBodyAppInfoApplication {
	s.RegionId = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoApplication) SetRunningInstanceCount(v int32) *QueryApplicationStatusResponseBodyAppInfoApplication {
	s.RunningInstanceCount = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoApplication) SetUserId(v string) *QueryApplicationStatusResponseBodyAppInfoApplication {
	s.UserId = &v
	return s
}

type QueryApplicationStatusResponseBodyAppInfoDeployRecordList struct {
	DeployRecord []*QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord `json:"DeployRecord,omitempty" xml:"DeployRecord,omitempty" type:"Repeated"`
}

func (s QueryApplicationStatusResponseBodyAppInfoDeployRecordList) String() string {
	return tea.Prettify(s)
}

func (s QueryApplicationStatusResponseBodyAppInfoDeployRecordList) GoString() string {
	return s.String()
}

func (s *QueryApplicationStatusResponseBodyAppInfoDeployRecordList) SetDeployRecord(v []*QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord) *QueryApplicationStatusResponseBodyAppInfoDeployRecordList {
	s.DeployRecord = v
	return s
}

type QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord struct {
	// The time when the deployment record was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the deployment record.
	DeployRecordId *string `json:"DeployRecordId,omitempty" xml:"DeployRecordId,omitempty"`
	// The unique ID of the ECC.
	EccId *string `json:"EccId,omitempty" xml:"EccId,omitempty"`
	// The unique ID of the ECU.
	EcuId *string `json:"EcuId,omitempty" xml:"EcuId,omitempty"`
	// The MD5 hash value of the deployment package.
	PackageMd5 *string `json:"PackageMd5,omitempty" xml:"PackageMd5,omitempty"`
	// The version of the deployment package that was used to deploy an application in the instance group.
	PackageVersionId *string `json:"PackageVersionId,omitempty" xml:"PackageVersionId,omitempty"`
}

func (s QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord) String() string {
	return tea.Prettify(s)
}

func (s QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord) GoString() string {
	return s.String()
}

func (s *QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord) SetCreateTime(v int64) *QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord {
	s.CreateTime = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord) SetDeployRecordId(v string) *QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord {
	s.DeployRecordId = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord) SetEccId(v string) *QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord {
	s.EccId = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord) SetEcuId(v string) *QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord {
	s.EcuId = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord) SetPackageMd5(v string) *QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord {
	s.PackageMd5 = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord) SetPackageVersionId(v string) *QueryApplicationStatusResponseBodyAppInfoDeployRecordListDeployRecord {
	s.PackageVersionId = &v
	return s
}

type QueryApplicationStatusResponseBodyAppInfoEccList struct {
	Ecc []*QueryApplicationStatusResponseBodyAppInfoEccListEcc `json:"Ecc,omitempty" xml:"Ecc,omitempty" type:"Repeated"`
}

func (s QueryApplicationStatusResponseBodyAppInfoEccList) String() string {
	return tea.Prettify(s)
}

func (s QueryApplicationStatusResponseBodyAppInfoEccList) GoString() string {
	return s.String()
}

func (s *QueryApplicationStatusResponseBodyAppInfoEccList) SetEcc(v []*QueryApplicationStatusResponseBodyAppInfoEccListEcc) *QueryApplicationStatusResponseBodyAppInfoEccList {
	s.Ecc = v
	return s
}

type QueryApplicationStatusResponseBodyAppInfoEccListEcc struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The status of the application instance. Valid values:
	//
	// *   0: AGENT_OFF: indicates that the agent is offline.
	// *   1: STOPPED: indicates that the application is stopped.
	// *   3: RUNNING_BUT_URL_FAILED: indicates that the health check failed.
	// *   7: RUNNING: indicates that the application is running.
	AppState *int32 `json:"AppState,omitempty" xml:"AppState,omitempty"`
	// The status of the container.
	ContainerStatus *string `json:"ContainerStatus,omitempty" xml:"ContainerStatus,omitempty"`
	// The time when the ECC was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The unique ID of the ECC.
	EccId *string `json:"EccId,omitempty" xml:"EccId,omitempty"`
	// The unique ID of the ECU.
	EcuId *string `json:"EcuId,omitempty" xml:"EcuId,omitempty"`
	// The ID of the instance group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The private IP address of the ECU.
	Ip *string `json:"Ip,omitempty" xml:"Ip,omitempty"`
	// The state of the latest task initiated on the application instance. Valid values:
	//
	// *   0: UNKNOWN: indicates that the state of the latest task is unknown.
	// *   1: PROCESSING: indicates that the latest task is being processed.
	// *   2: SUCCESS: indicates that the latest task is executed.
	// *   3: FAILED: indicates that the latest task failed.
	TaskState *int32 `json:"TaskState,omitempty" xml:"TaskState,omitempty"`
	// The time when the ECC was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The ID of the VPC.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s QueryApplicationStatusResponseBodyAppInfoEccListEcc) String() string {
	return tea.Prettify(s)
}

func (s QueryApplicationStatusResponseBodyAppInfoEccListEcc) GoString() string {
	return s.String()
}

func (s *QueryApplicationStatusResponseBodyAppInfoEccListEcc) SetAppId(v string) *QueryApplicationStatusResponseBodyAppInfoEccListEcc {
	s.AppId = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoEccListEcc) SetAppState(v int32) *QueryApplicationStatusResponseBodyAppInfoEccListEcc {
	s.AppState = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoEccListEcc) SetContainerStatus(v string) *QueryApplicationStatusResponseBodyAppInfoEccListEcc {
	s.ContainerStatus = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoEccListEcc) SetCreateTime(v int64) *QueryApplicationStatusResponseBodyAppInfoEccListEcc {
	s.CreateTime = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoEccListEcc) SetEccId(v string) *QueryApplicationStatusResponseBodyAppInfoEccListEcc {
	s.EccId = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoEccListEcc) SetEcuId(v string) *QueryApplicationStatusResponseBodyAppInfoEccListEcc {
	s.EcuId = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoEccListEcc) SetGroupId(v string) *QueryApplicationStatusResponseBodyAppInfoEccListEcc {
	s.GroupId = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoEccListEcc) SetIp(v string) *QueryApplicationStatusResponseBodyAppInfoEccListEcc {
	s.Ip = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoEccListEcc) SetTaskState(v int32) *QueryApplicationStatusResponseBodyAppInfoEccListEcc {
	s.TaskState = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoEccListEcc) SetUpdateTime(v int64) *QueryApplicationStatusResponseBodyAppInfoEccListEcc {
	s.UpdateTime = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoEccListEcc) SetVpcId(v string) *QueryApplicationStatusResponseBodyAppInfoEccListEcc {
	s.VpcId = &v
	return s
}

type QueryApplicationStatusResponseBodyAppInfoEcuList struct {
	Ecu []*QueryApplicationStatusResponseBodyAppInfoEcuListEcu `json:"Ecu,omitempty" xml:"Ecu,omitempty" type:"Repeated"`
}

func (s QueryApplicationStatusResponseBodyAppInfoEcuList) String() string {
	return tea.Prettify(s)
}

func (s QueryApplicationStatusResponseBodyAppInfoEcuList) GoString() string {
	return s.String()
}

func (s *QueryApplicationStatusResponseBodyAppInfoEcuList) SetEcu(v []*QueryApplicationStatusResponseBodyAppInfoEcuListEcu) *QueryApplicationStatusResponseBodyAppInfoEcuList {
	s.Ecu = v
	return s
}

type QueryApplicationStatusResponseBodyAppInfoEcuListEcu struct {
	// The number of available CPU cores.
	AvailableCpu *int32 `json:"AvailableCpu,omitempty" xml:"AvailableCpu,omitempty"`
	// The size of the available memory.
	AvailableMem *int32 `json:"AvailableMem,omitempty" xml:"AvailableMem,omitempty"`
	// The time when the ECU was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// Indicates whether Docker is installed.
	DockerEnv *bool `json:"DockerEnv,omitempty" xml:"DockerEnv,omitempty"`
	// The unique ID of the ECU. You can run the `dmidecode` command on the ECS instance to query the ECU ID.
	EcuId *string `json:"EcuId,omitempty" xml:"EcuId,omitempty"`
	// The ID of the group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The time when the last heartbeat detection was performed. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	HeartbeatTime *int64 `json:"HeartbeatTime,omitempty" xml:"HeartbeatTime,omitempty"`
	// The ID of the instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The private IP address of the ECU.
	IpAddr *string `json:"IpAddr,omitempty" xml:"IpAddr,omitempty"`
	// The name of the ECU.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Indicates whether the ECU is online.
	Online *bool `json:"Online,omitempty" xml:"Online,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The time when the ECU was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The ID of the user associated with the ECU.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The ID of the virtual private cloud (VPC).
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The ID of the zone.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s QueryApplicationStatusResponseBodyAppInfoEcuListEcu) String() string {
	return tea.Prettify(s)
}

func (s QueryApplicationStatusResponseBodyAppInfoEcuListEcu) GoString() string {
	return s.String()
}

func (s *QueryApplicationStatusResponseBodyAppInfoEcuListEcu) SetAvailableCpu(v int32) *QueryApplicationStatusResponseBodyAppInfoEcuListEcu {
	s.AvailableCpu = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoEcuListEcu) SetAvailableMem(v int32) *QueryApplicationStatusResponseBodyAppInfoEcuListEcu {
	s.AvailableMem = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoEcuListEcu) SetCreateTime(v int64) *QueryApplicationStatusResponseBodyAppInfoEcuListEcu {
	s.CreateTime = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoEcuListEcu) SetDockerEnv(v bool) *QueryApplicationStatusResponseBodyAppInfoEcuListEcu {
	s.DockerEnv = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoEcuListEcu) SetEcuId(v string) *QueryApplicationStatusResponseBodyAppInfoEcuListEcu {
	s.EcuId = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoEcuListEcu) SetGroupId(v string) *QueryApplicationStatusResponseBodyAppInfoEcuListEcu {
	s.GroupId = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoEcuListEcu) SetHeartbeatTime(v int64) *QueryApplicationStatusResponseBodyAppInfoEcuListEcu {
	s.HeartbeatTime = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoEcuListEcu) SetInstanceId(v string) *QueryApplicationStatusResponseBodyAppInfoEcuListEcu {
	s.InstanceId = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoEcuListEcu) SetIpAddr(v string) *QueryApplicationStatusResponseBodyAppInfoEcuListEcu {
	s.IpAddr = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoEcuListEcu) SetName(v string) *QueryApplicationStatusResponseBodyAppInfoEcuListEcu {
	s.Name = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoEcuListEcu) SetOnline(v bool) *QueryApplicationStatusResponseBodyAppInfoEcuListEcu {
	s.Online = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoEcuListEcu) SetRegionId(v string) *QueryApplicationStatusResponseBodyAppInfoEcuListEcu {
	s.RegionId = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoEcuListEcu) SetUpdateTime(v int64) *QueryApplicationStatusResponseBodyAppInfoEcuListEcu {
	s.UpdateTime = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoEcuListEcu) SetUserId(v string) *QueryApplicationStatusResponseBodyAppInfoEcuListEcu {
	s.UserId = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoEcuListEcu) SetVpcId(v string) *QueryApplicationStatusResponseBodyAppInfoEcuListEcu {
	s.VpcId = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoEcuListEcu) SetZoneId(v string) *QueryApplicationStatusResponseBodyAppInfoEcuListEcu {
	s.ZoneId = &v
	return s
}

type QueryApplicationStatusResponseBodyAppInfoGroupList struct {
	Group []*QueryApplicationStatusResponseBodyAppInfoGroupListGroup `json:"Group,omitempty" xml:"Group,omitempty" type:"Repeated"`
}

func (s QueryApplicationStatusResponseBodyAppInfoGroupList) String() string {
	return tea.Prettify(s)
}

func (s QueryApplicationStatusResponseBodyAppInfoGroupList) GoString() string {
	return s.String()
}

func (s *QueryApplicationStatusResponseBodyAppInfoGroupList) SetGroup(v []*QueryApplicationStatusResponseBodyAppInfoGroupListGroup) *QueryApplicationStatusResponseBodyAppInfoGroupList {
	s.Group = v
	return s
}

type QueryApplicationStatusResponseBodyAppInfoGroupListGroup struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the change process for application deployment in the instance group.
	AppVersionId *string `json:"AppVersionId,omitempty" xml:"AppVersionId,omitempty"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The time when the instance group was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the instance group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the instance group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The type of the instance group. Valid values:
	//
	// *   0: default group
	// *   1: self-managed group
	// *   2: canary release group
	GroupType *int32 `json:"GroupType,omitempty" xml:"GroupType,omitempty"`
	// The version of the deployment package that was used to deploy an application in the instance group.
	PackageVersionId *string `json:"PackageVersionId,omitempty" xml:"PackageVersionId,omitempty"`
	// The time when the instance group was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s QueryApplicationStatusResponseBodyAppInfoGroupListGroup) String() string {
	return tea.Prettify(s)
}

func (s QueryApplicationStatusResponseBodyAppInfoGroupListGroup) GoString() string {
	return s.String()
}

func (s *QueryApplicationStatusResponseBodyAppInfoGroupListGroup) SetAppId(v string) *QueryApplicationStatusResponseBodyAppInfoGroupListGroup {
	s.AppId = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoGroupListGroup) SetAppVersionId(v string) *QueryApplicationStatusResponseBodyAppInfoGroupListGroup {
	s.AppVersionId = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoGroupListGroup) SetClusterId(v string) *QueryApplicationStatusResponseBodyAppInfoGroupListGroup {
	s.ClusterId = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoGroupListGroup) SetCreateTime(v int64) *QueryApplicationStatusResponseBodyAppInfoGroupListGroup {
	s.CreateTime = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoGroupListGroup) SetGroupId(v string) *QueryApplicationStatusResponseBodyAppInfoGroupListGroup {
	s.GroupId = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoGroupListGroup) SetGroupName(v string) *QueryApplicationStatusResponseBodyAppInfoGroupListGroup {
	s.GroupName = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoGroupListGroup) SetGroupType(v int32) *QueryApplicationStatusResponseBodyAppInfoGroupListGroup {
	s.GroupType = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoGroupListGroup) SetPackageVersionId(v string) *QueryApplicationStatusResponseBodyAppInfoGroupListGroup {
	s.PackageVersionId = &v
	return s
}

func (s *QueryApplicationStatusResponseBodyAppInfoGroupListGroup) SetUpdateTime(v int64) *QueryApplicationStatusResponseBodyAppInfoGroupListGroup {
	s.UpdateTime = &v
	return s
}

type QueryApplicationStatusResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *QueryApplicationStatusResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s QueryApplicationStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryApplicationStatusResponse) GoString() string {
	return s.String()
}

func (s *QueryApplicationStatusResponse) SetHeaders(v map[string]*string) *QueryApplicationStatusResponse {
	s.Headers = v
	return s
}

func (s *QueryApplicationStatusResponse) SetStatusCode(v int32) *QueryApplicationStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryApplicationStatusResponse) SetBody(v *QueryApplicationStatusResponseBody) *QueryApplicationStatusResponse {
	s.Body = v
	return s
}

type QueryEccInfoRequest struct {
	// The ID of the ECC.
	EccId *string `json:"EccId,omitempty" xml:"EccId,omitempty"`
}

func (s QueryEccInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryEccInfoRequest) GoString() string {
	return s.String()
}

func (s *QueryEccInfoRequest) SetEccId(v string) *QueryEccInfoRequest {
	s.EccId = &v
	return s
}

type QueryEccInfoResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The information about the ECC.
	EccInfo *QueryEccInfoResponseBodyEccInfo `json:"EccInfo,omitempty" xml:"EccInfo,omitempty" type:"Struct"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s QueryEccInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryEccInfoResponseBody) GoString() string {
	return s.String()
}

func (s *QueryEccInfoResponseBody) SetCode(v int32) *QueryEccInfoResponseBody {
	s.Code = &v
	return s
}

func (s *QueryEccInfoResponseBody) SetEccInfo(v *QueryEccInfoResponseBodyEccInfo) *QueryEccInfoResponseBody {
	s.EccInfo = v
	return s
}

func (s *QueryEccInfoResponseBody) SetMessage(v string) *QueryEccInfoResponseBody {
	s.Message = &v
	return s
}

func (s *QueryEccInfoResponseBody) SetRequestId(v string) *QueryEccInfoResponseBody {
	s.RequestId = &v
	return s
}

type QueryEccInfoResponseBodyEccInfo struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// ECC ID
	EccId *string `json:"EccId,omitempty" xml:"EccId,omitempty"`
	// ECU ID
	EcuId *string `json:"EcuId,omitempty" xml:"EcuId,omitempty"`
	// The ID of the ECC group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the ECC group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The MD5 hash value of the deployment package version.
	PackageMd5 *string `json:"PackageMd5,omitempty" xml:"PackageMd5,omitempty"`
	// The version of the deployment package.
	PackageVersion *string `json:"PackageVersion,omitempty" xml:"PackageVersion,omitempty"`
	// VPC ID
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s QueryEccInfoResponseBodyEccInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryEccInfoResponseBodyEccInfo) GoString() string {
	return s.String()
}

func (s *QueryEccInfoResponseBodyEccInfo) SetAppId(v string) *QueryEccInfoResponseBodyEccInfo {
	s.AppId = &v
	return s
}

func (s *QueryEccInfoResponseBodyEccInfo) SetEccId(v string) *QueryEccInfoResponseBodyEccInfo {
	s.EccId = &v
	return s
}

func (s *QueryEccInfoResponseBodyEccInfo) SetEcuId(v string) *QueryEccInfoResponseBodyEccInfo {
	s.EcuId = &v
	return s
}

func (s *QueryEccInfoResponseBodyEccInfo) SetGroupId(v string) *QueryEccInfoResponseBodyEccInfo {
	s.GroupId = &v
	return s
}

func (s *QueryEccInfoResponseBodyEccInfo) SetGroupName(v string) *QueryEccInfoResponseBodyEccInfo {
	s.GroupName = &v
	return s
}

func (s *QueryEccInfoResponseBodyEccInfo) SetPackageMd5(v string) *QueryEccInfoResponseBodyEccInfo {
	s.PackageMd5 = &v
	return s
}

func (s *QueryEccInfoResponseBodyEccInfo) SetPackageVersion(v string) *QueryEccInfoResponseBodyEccInfo {
	s.PackageVersion = &v
	return s
}

func (s *QueryEccInfoResponseBodyEccInfo) SetVpcId(v string) *QueryEccInfoResponseBodyEccInfo {
	s.VpcId = &v
	return s
}

type QueryEccInfoResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *QueryEccInfoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s QueryEccInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryEccInfoResponse) GoString() string {
	return s.String()
}

func (s *QueryEccInfoResponse) SetHeaders(v map[string]*string) *QueryEccInfoResponse {
	s.Headers = v
	return s
}

func (s *QueryEccInfoResponse) SetStatusCode(v int32) *QueryEccInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryEccInfoResponse) SetBody(v *QueryEccInfoResponseBody) *QueryEccInfoResponse {
	s.Body = v
	return s
}

type QueryMigrateEcuListRequest struct {
	// The ID of the namespace.
	//
	// *   The ID of a custom namespace is in the `region ID:namespace identifier` format. Example: `cn-beijing:test`.
	// *   The ID of the default namespace is in the `region ID` format. Example: `cn-beijing`.
	LogicalRegionId *string `json:"LogicalRegionId,omitempty" xml:"LogicalRegionId,omitempty"`
}

func (s QueryMigrateEcuListRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryMigrateEcuListRequest) GoString() string {
	return s.String()
}

func (s *QueryMigrateEcuListRequest) SetLogicalRegionId(v string) *QueryMigrateEcuListRequest {
	s.LogicalRegionId = &v
	return s
}

type QueryMigrateEcuListResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The information about ECUs that can be migrated.
	EcuEntityList *QueryMigrateEcuListResponseBodyEcuEntityList `json:"EcuEntityList,omitempty" xml:"EcuEntityList,omitempty" type:"Struct"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s QueryMigrateEcuListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryMigrateEcuListResponseBody) GoString() string {
	return s.String()
}

func (s *QueryMigrateEcuListResponseBody) SetCode(v int32) *QueryMigrateEcuListResponseBody {
	s.Code = &v
	return s
}

func (s *QueryMigrateEcuListResponseBody) SetEcuEntityList(v *QueryMigrateEcuListResponseBodyEcuEntityList) *QueryMigrateEcuListResponseBody {
	s.EcuEntityList = v
	return s
}

func (s *QueryMigrateEcuListResponseBody) SetMessage(v string) *QueryMigrateEcuListResponseBody {
	s.Message = &v
	return s
}

func (s *QueryMigrateEcuListResponseBody) SetRequestId(v string) *QueryMigrateEcuListResponseBody {
	s.RequestId = &v
	return s
}

type QueryMigrateEcuListResponseBodyEcuEntityList struct {
	EcuEntity []*QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity `json:"EcuEntity,omitempty" xml:"EcuEntity,omitempty" type:"Repeated"`
}

func (s QueryMigrateEcuListResponseBodyEcuEntityList) String() string {
	return tea.Prettify(s)
}

func (s QueryMigrateEcuListResponseBodyEcuEntityList) GoString() string {
	return s.String()
}

func (s *QueryMigrateEcuListResponseBodyEcuEntityList) SetEcuEntity(v []*QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity) *QueryMigrateEcuListResponseBodyEcuEntityList {
	s.EcuEntity = v
	return s
}

type QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity struct {
	// The number of available CPUs. Unit: cores.
	AvailableCpu *int32 `json:"AvailableCpu,omitempty" xml:"AvailableCpu,omitempty"`
	// The size of available memory. Unit: MB.
	AvailableMem *int32 `json:"AvailableMem,omitempty" xml:"AvailableMem,omitempty"`
	// The CPU quota set by the system. Unit: cores. The value 0 indicates that no quota is set by the system.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The time when the ECU was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// Indicates whether Docker is installed. Valid values:
	//
	// *   true: Docker is installed.
	// *   false: Docker is not installed.
	DockerEnv *bool `json:"DockerEnv,omitempty" xml:"DockerEnv,omitempty"`
	// The unique ID of the ECU. To query the ID, you can run the `dmidecode` command on the ECS instance that corresponds to the ECU.
	EcuId *string `json:"EcuId,omitempty" xml:"EcuId,omitempty"`
	// The time when the last heartbeat detection was performed. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	HeartbeatTime *int64 `json:"HeartbeatTime,omitempty" xml:"HeartbeatTime,omitempty"`
	// The ID of the ECU.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The private IP address of the ECU.
	IpAddr *string `json:"IpAddr,omitempty" xml:"IpAddr,omitempty"`
	// The total size of memory.
	Mem *int32 `json:"Mem,omitempty" xml:"Mem,omitempty"`
	// The name of the ECU.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Indicates whether the ECU is online. Valid values:
	//
	// *   true: The ECU is online.
	// *   false: The ECU is offline.
	Online *bool `json:"Online,omitempty" xml:"Online,omitempty"`
	// The ID of the region where the ECU resides.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The time when the ECU was updated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The ID of the Alibaba Cloud account to which the ECU belongs.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// VPC ID
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The ID of the zone where the ECU resides.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity) String() string {
	return tea.Prettify(s)
}

func (s QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity) GoString() string {
	return s.String()
}

func (s *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity) SetAvailableCpu(v int32) *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity {
	s.AvailableCpu = &v
	return s
}

func (s *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity) SetAvailableMem(v int32) *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity {
	s.AvailableMem = &v
	return s
}

func (s *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity) SetCpu(v int32) *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity {
	s.Cpu = &v
	return s
}

func (s *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity) SetCreateTime(v int64) *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity {
	s.CreateTime = &v
	return s
}

func (s *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity) SetDockerEnv(v bool) *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity {
	s.DockerEnv = &v
	return s
}

func (s *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity) SetEcuId(v string) *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity {
	s.EcuId = &v
	return s
}

func (s *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity) SetHeartbeatTime(v int64) *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity {
	s.HeartbeatTime = &v
	return s
}

func (s *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity) SetInstanceId(v string) *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity {
	s.InstanceId = &v
	return s
}

func (s *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity) SetIpAddr(v string) *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity {
	s.IpAddr = &v
	return s
}

func (s *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity) SetMem(v int32) *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity {
	s.Mem = &v
	return s
}

func (s *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity) SetName(v string) *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity {
	s.Name = &v
	return s
}

func (s *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity) SetOnline(v bool) *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity {
	s.Online = &v
	return s
}

func (s *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity) SetRegionId(v string) *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity {
	s.RegionId = &v
	return s
}

func (s *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity) SetUpdateTime(v int64) *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity {
	s.UpdateTime = &v
	return s
}

func (s *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity) SetUserId(v string) *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity {
	s.UserId = &v
	return s
}

func (s *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity) SetVpcId(v string) *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity {
	s.VpcId = &v
	return s
}

func (s *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity) SetZoneId(v string) *QueryMigrateEcuListResponseBodyEcuEntityListEcuEntity {
	s.ZoneId = &v
	return s
}

type QueryMigrateEcuListResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *QueryMigrateEcuListResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s QueryMigrateEcuListResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryMigrateEcuListResponse) GoString() string {
	return s.String()
}

func (s *QueryMigrateEcuListResponse) SetHeaders(v map[string]*string) *QueryMigrateEcuListResponse {
	s.Headers = v
	return s
}

func (s *QueryMigrateEcuListResponse) SetStatusCode(v int32) *QueryMigrateEcuListResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryMigrateEcuListResponse) SetBody(v *QueryMigrateEcuListResponseBody) *QueryMigrateEcuListResponse {
	s.Body = v
	return s
}

type QueryMigrateRegionListRequest struct {
	// The ID of the namespace.
	LogicalRegionId *string `json:"LogicalRegionId,omitempty" xml:"LogicalRegionId,omitempty"`
}

func (s QueryMigrateRegionListRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryMigrateRegionListRequest) GoString() string {
	return s.String()
}

func (s *QueryMigrateRegionListRequest) SetLogicalRegionId(v string) *QueryMigrateRegionListRequest {
	s.LogicalRegionId = &v
	return s
}

type QueryMigrateRegionListResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The namespaces.
	RegionEntityList *QueryMigrateRegionListResponseBodyRegionEntityList `json:"RegionEntityList,omitempty" xml:"RegionEntityList,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s QueryMigrateRegionListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryMigrateRegionListResponseBody) GoString() string {
	return s.String()
}

func (s *QueryMigrateRegionListResponseBody) SetCode(v int32) *QueryMigrateRegionListResponseBody {
	s.Code = &v
	return s
}

func (s *QueryMigrateRegionListResponseBody) SetMessage(v string) *QueryMigrateRegionListResponseBody {
	s.Message = &v
	return s
}

func (s *QueryMigrateRegionListResponseBody) SetRegionEntityList(v *QueryMigrateRegionListResponseBodyRegionEntityList) *QueryMigrateRegionListResponseBody {
	s.RegionEntityList = v
	return s
}

func (s *QueryMigrateRegionListResponseBody) SetRequestId(v string) *QueryMigrateRegionListResponseBody {
	s.RequestId = &v
	return s
}

type QueryMigrateRegionListResponseBodyRegionEntityList struct {
	RegionEntity []*QueryMigrateRegionListResponseBodyRegionEntityListRegionEntity `json:"RegionEntity,omitempty" xml:"RegionEntity,omitempty" type:"Repeated"`
}

func (s QueryMigrateRegionListResponseBodyRegionEntityList) String() string {
	return tea.Prettify(s)
}

func (s QueryMigrateRegionListResponseBodyRegionEntityList) GoString() string {
	return s.String()
}

func (s *QueryMigrateRegionListResponseBodyRegionEntityList) SetRegionEntity(v []*QueryMigrateRegionListResponseBodyRegionEntityListRegionEntity) *QueryMigrateRegionListResponseBodyRegionEntityList {
	s.RegionEntity = v
	return s
}

type QueryMigrateRegionListResponseBodyRegionEntityListRegionEntity struct {
	// The name of the namespace.
	RegionName *string `json:"RegionName,omitempty" xml:"RegionName,omitempty"`
	// The ID of the namespace.
	RegionNo *string `json:"RegionNo,omitempty" xml:"RegionNo,omitempty"`
}

func (s QueryMigrateRegionListResponseBodyRegionEntityListRegionEntity) String() string {
	return tea.Prettify(s)
}

func (s QueryMigrateRegionListResponseBodyRegionEntityListRegionEntity) GoString() string {
	return s.String()
}

func (s *QueryMigrateRegionListResponseBodyRegionEntityListRegionEntity) SetRegionName(v string) *QueryMigrateRegionListResponseBodyRegionEntityListRegionEntity {
	s.RegionName = &v
	return s
}

func (s *QueryMigrateRegionListResponseBodyRegionEntityListRegionEntity) SetRegionNo(v string) *QueryMigrateRegionListResponseBodyRegionEntityListRegionEntity {
	s.RegionNo = &v
	return s
}

type QueryMigrateRegionListResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *QueryMigrateRegionListResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s QueryMigrateRegionListResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryMigrateRegionListResponse) GoString() string {
	return s.String()
}

func (s *QueryMigrateRegionListResponse) SetHeaders(v map[string]*string) *QueryMigrateRegionListResponse {
	s.Headers = v
	return s
}

func (s *QueryMigrateRegionListResponse) SetStatusCode(v int32) *QueryMigrateRegionListResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryMigrateRegionListResponse) SetBody(v *QueryMigrateRegionListResponseBody) *QueryMigrateRegionListResponse {
	s.Body = v
	return s
}

type QueryRegionConfigResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The information about region configurations.
	RegionConfig *QueryRegionConfigResponseBodyRegionConfig `json:"RegionConfig,omitempty" xml:"RegionConfig,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s QueryRegionConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryRegionConfigResponseBody) GoString() string {
	return s.String()
}

func (s *QueryRegionConfigResponseBody) SetCode(v int32) *QueryRegionConfigResponseBody {
	s.Code = &v
	return s
}

func (s *QueryRegionConfigResponseBody) SetMessage(v string) *QueryRegionConfigResponseBody {
	s.Message = &v
	return s
}

func (s *QueryRegionConfigResponseBody) SetRegionConfig(v *QueryRegionConfigResponseBodyRegionConfig) *QueryRegionConfigResponseBody {
	s.RegionConfig = v
	return s
}

func (s *QueryRegionConfigResponseBody) SetRequestId(v string) *QueryRegionConfigResponseBody {
	s.RequestId = &v
	return s
}

type QueryRegionConfigResponseBodyRegionConfig struct {
	// The domain name of Address Server.
	AddressServerHost *string `json:"AddressServerHost,omitempty" xml:"AddressServerHost,omitempty"`
	// The installation path of the script for EDAS Agent.
	AgentInstallScript *string `json:"AgentInstallScript,omitempty" xml:"AgentInstallScript,omitempty"`
	// The information about the file server.
	FileServerConfig *QueryRegionConfigResponseBodyRegionConfigFileServerConfig `json:"FileServerConfig,omitempty" xml:"FileServerConfig,omitempty" type:"Struct"`
	// The type of the file server.
	FileServerType *string `json:"FileServerType,omitempty" xml:"FileServerType,omitempty"`
	// The configured ID of the region.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the official image.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The configured name of the region.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The serial number of the region. This parameter is deprecated.
	No *int32 `json:"No,omitempty" xml:"No,omitempty"`
	// The tag of the region. The value is fixed to `ALIYUN_SHARE`.
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
}

func (s QueryRegionConfigResponseBodyRegionConfig) String() string {
	return tea.Prettify(s)
}

func (s QueryRegionConfigResponseBodyRegionConfig) GoString() string {
	return s.String()
}

func (s *QueryRegionConfigResponseBodyRegionConfig) SetAddressServerHost(v string) *QueryRegionConfigResponseBodyRegionConfig {
	s.AddressServerHost = &v
	return s
}

func (s *QueryRegionConfigResponseBodyRegionConfig) SetAgentInstallScript(v string) *QueryRegionConfigResponseBodyRegionConfig {
	s.AgentInstallScript = &v
	return s
}

func (s *QueryRegionConfigResponseBodyRegionConfig) SetFileServerConfig(v *QueryRegionConfigResponseBodyRegionConfigFileServerConfig) *QueryRegionConfigResponseBodyRegionConfig {
	s.FileServerConfig = v
	return s
}

func (s *QueryRegionConfigResponseBodyRegionConfig) SetFileServerType(v string) *QueryRegionConfigResponseBodyRegionConfig {
	s.FileServerType = &v
	return s
}

func (s *QueryRegionConfigResponseBodyRegionConfig) SetId(v string) *QueryRegionConfigResponseBodyRegionConfig {
	s.Id = &v
	return s
}

func (s *QueryRegionConfigResponseBodyRegionConfig) SetImageId(v string) *QueryRegionConfigResponseBodyRegionConfig {
	s.ImageId = &v
	return s
}

func (s *QueryRegionConfigResponseBodyRegionConfig) SetName(v string) *QueryRegionConfigResponseBodyRegionConfig {
	s.Name = &v
	return s
}

func (s *QueryRegionConfigResponseBodyRegionConfig) SetNo(v int32) *QueryRegionConfigResponseBodyRegionConfig {
	s.No = &v
	return s
}

func (s *QueryRegionConfigResponseBodyRegionConfig) SetTag(v string) *QueryRegionConfigResponseBodyRegionConfig {
	s.Tag = &v
	return s
}

type QueryRegionConfigResponseBodyRegionConfigFileServerConfig struct {
	// The Object Storage Service (OSS) bucket of the file server.
	Bucket *string `json:"Bucket,omitempty" xml:"Bucket,omitempty"`
	// The internal endpoint of the file server.
	InternalUrl *string `json:"InternalUrl,omitempty" xml:"InternalUrl,omitempty"`
	// The public endpoint of the file server.
	PublicUrl *string `json:"PublicUrl,omitempty" xml:"PublicUrl,omitempty"`
	// The virtual private cloud (VPC) endpoint of the file server.
	VpcUrl *string `json:"VpcUrl,omitempty" xml:"VpcUrl,omitempty"`
}

func (s QueryRegionConfigResponseBodyRegionConfigFileServerConfig) String() string {
	return tea.Prettify(s)
}

func (s QueryRegionConfigResponseBodyRegionConfigFileServerConfig) GoString() string {
	return s.String()
}

func (s *QueryRegionConfigResponseBodyRegionConfigFileServerConfig) SetBucket(v string) *QueryRegionConfigResponseBodyRegionConfigFileServerConfig {
	s.Bucket = &v
	return s
}

func (s *QueryRegionConfigResponseBodyRegionConfigFileServerConfig) SetInternalUrl(v string) *QueryRegionConfigResponseBodyRegionConfigFileServerConfig {
	s.InternalUrl = &v
	return s
}

func (s *QueryRegionConfigResponseBodyRegionConfigFileServerConfig) SetPublicUrl(v string) *QueryRegionConfigResponseBodyRegionConfigFileServerConfig {
	s.PublicUrl = &v
	return s
}

func (s *QueryRegionConfigResponseBodyRegionConfigFileServerConfig) SetVpcUrl(v string) *QueryRegionConfigResponseBodyRegionConfigFileServerConfig {
	s.VpcUrl = &v
	return s
}

type QueryRegionConfigResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *QueryRegionConfigResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s QueryRegionConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryRegionConfigResponse) GoString() string {
	return s.String()
}

func (s *QueryRegionConfigResponse) SetHeaders(v map[string]*string) *QueryRegionConfigResponse {
	s.Headers = v
	return s
}

func (s *QueryRegionConfigResponse) SetStatusCode(v int32) *QueryRegionConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryRegionConfigResponse) SetBody(v *QueryRegionConfigResponseBody) *QueryRegionConfigResponse {
	s.Body = v
	return s
}

type QuerySlsLogStoreListRequest struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The number of the page to return. Pages start from Page 1.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The type of data that is collected by Log Service. Valid values:
	//
	// *   file: the file type
	// *   stdout: the standard output type
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s QuerySlsLogStoreListRequest) String() string {
	return tea.Prettify(s)
}

func (s QuerySlsLogStoreListRequest) GoString() string {
	return s.String()
}

func (s *QuerySlsLogStoreListRequest) SetAppId(v string) *QuerySlsLogStoreListRequest {
	s.AppId = &v
	return s
}

func (s *QuerySlsLogStoreListRequest) SetCurrentPage(v int32) *QuerySlsLogStoreListRequest {
	s.CurrentPage = &v
	return s
}

func (s *QuerySlsLogStoreListRequest) SetPageSize(v int32) *QuerySlsLogStoreListRequest {
	s.PageSize = &v
	return s
}

func (s *QuerySlsLogStoreListRequest) SetType(v string) *QuerySlsLogStoreListRequest {
	s.Type = &v
	return s
}

type QuerySlsLogStoreListResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The configurations of Log Service for the application.
	Result []*QuerySlsLogStoreListResponseBodyResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// The number of log sources configured for the application.
	TotalSize *int32 `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s QuerySlsLogStoreListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QuerySlsLogStoreListResponseBody) GoString() string {
	return s.String()
}

func (s *QuerySlsLogStoreListResponseBody) SetCode(v int32) *QuerySlsLogStoreListResponseBody {
	s.Code = &v
	return s
}

func (s *QuerySlsLogStoreListResponseBody) SetMessage(v string) *QuerySlsLogStoreListResponseBody {
	s.Message = &v
	return s
}

func (s *QuerySlsLogStoreListResponseBody) SetRequestId(v string) *QuerySlsLogStoreListResponseBody {
	s.RequestId = &v
	return s
}

func (s *QuerySlsLogStoreListResponseBody) SetResult(v []*QuerySlsLogStoreListResponseBodyResult) *QuerySlsLogStoreListResponseBody {
	s.Result = v
	return s
}

func (s *QuerySlsLogStoreListResponseBody) SetTotalSize(v int32) *QuerySlsLogStoreListResponseBody {
	s.TotalSize = &v
	return s
}

type QuerySlsLogStoreListResponseBodyResult struct {
	// The type of the logging service.
	ConsumerSide *string `json:"ConsumerSide,omitempty" xml:"ConsumerSide,omitempty"`
	// The time when the logging service was created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The URL of the logging service.
	Link *string `json:"Link,omitempty" xml:"Link,omitempty"`
	// The name of the Logstore.
	Logstore *string `json:"Logstore,omitempty" xml:"Logstore,omitempty"`
	// The name of the project.
	Project *string `json:"Project,omitempty" xml:"Project,omitempty"`
	// The source of logs. Valid values:
	//
	// *   Standard output: stdout.log
	// *   File log: the directory that stores logs
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
}

func (s QuerySlsLogStoreListResponseBodyResult) String() string {
	return tea.Prettify(s)
}

func (s QuerySlsLogStoreListResponseBodyResult) GoString() string {
	return s.String()
}

func (s *QuerySlsLogStoreListResponseBodyResult) SetConsumerSide(v string) *QuerySlsLogStoreListResponseBodyResult {
	s.ConsumerSide = &v
	return s
}

func (s *QuerySlsLogStoreListResponseBodyResult) SetCreateTime(v string) *QuerySlsLogStoreListResponseBodyResult {
	s.CreateTime = &v
	return s
}

func (s *QuerySlsLogStoreListResponseBodyResult) SetLink(v string) *QuerySlsLogStoreListResponseBodyResult {
	s.Link = &v
	return s
}

func (s *QuerySlsLogStoreListResponseBodyResult) SetLogstore(v string) *QuerySlsLogStoreListResponseBodyResult {
	s.Logstore = &v
	return s
}

func (s *QuerySlsLogStoreListResponseBodyResult) SetProject(v string) *QuerySlsLogStoreListResponseBodyResult {
	s.Project = &v
	return s
}

func (s *QuerySlsLogStoreListResponseBodyResult) SetSource(v string) *QuerySlsLogStoreListResponseBodyResult {
	s.Source = &v
	return s
}

type QuerySlsLogStoreListResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *QuerySlsLogStoreListResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s QuerySlsLogStoreListResponse) String() string {
	return tea.Prettify(s)
}

func (s QuerySlsLogStoreListResponse) GoString() string {
	return s.String()
}

func (s *QuerySlsLogStoreListResponse) SetHeaders(v map[string]*string) *QuerySlsLogStoreListResponse {
	s.Headers = v
	return s
}

func (s *QuerySlsLogStoreListResponse) SetStatusCode(v int32) *QuerySlsLogStoreListResponse {
	s.StatusCode = &v
	return s
}

func (s *QuerySlsLogStoreListResponse) SetBody(v *QuerySlsLogStoreListResponseBody) *QuerySlsLogStoreListResponse {
	s.Body = v
	return s
}

type ResetApplicationRequest struct {
	// The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the elastic compute container (ECC) for which you want to reset the application. Separate multiple ECC IDs with commas (,). You can call the QueryApplicationStatus operation to query the ECC ID. For more information, see [QueryApplicationStatus](~~149394~~).
	EccInfo *string `json:"EccInfo,omitempty" xml:"EccInfo,omitempty"`
}

func (s ResetApplicationRequest) String() string {
	return tea.Prettify(s)
}

func (s ResetApplicationRequest) GoString() string {
	return s.String()
}

func (s *ResetApplicationRequest) SetAppId(v string) *ResetApplicationRequest {
	s.AppId = &v
	return s
}

func (s *ResetApplicationRequest) SetEccInfo(v string) *ResetApplicationRequest {
	s.EccInfo = &v
	return s
}

type ResetApplicationResponseBody struct {
	// The ID of the change process for this operation. You can call the GetChangeOrderInfo operation to query the progress of this operation. For more information, see [GetChangeOrderInfo](~~62072~~).
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ResetApplicationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ResetApplicationResponseBody) GoString() string {
	return s.String()
}

func (s *ResetApplicationResponseBody) SetChangeOrderId(v string) *ResetApplicationResponseBody {
	s.ChangeOrderId = &v
	return s
}

func (s *ResetApplicationResponseBody) SetCode(v int32) *ResetApplicationResponseBody {
	s.Code = &v
	return s
}

func (s *ResetApplicationResponseBody) SetMessage(v string) *ResetApplicationResponseBody {
	s.Message = &v
	return s
}

func (s *ResetApplicationResponseBody) SetRequestId(v string) *ResetApplicationResponseBody {
	s.RequestId = &v
	return s
}

type ResetApplicationResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ResetApplicationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ResetApplicationResponse) String() string {
	return tea.Prettify(s)
}

func (s ResetApplicationResponse) GoString() string {
	return s.String()
}

func (s *ResetApplicationResponse) SetHeaders(v map[string]*string) *ResetApplicationResponse {
	s.Headers = v
	return s
}

func (s *ResetApplicationResponse) SetStatusCode(v int32) *ResetApplicationResponse {
	s.StatusCode = &v
	return s
}

func (s *ResetApplicationResponse) SetBody(v *ResetApplicationResponseBody) *ResetApplicationResponse {
	s.Body = v
	return s
}

type RestartApplicationRequest struct {
	// The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the elastic compute container (ECC) that corresponds to the ECS instance on which you want to restart the application. You can call the QueryApplicationStatus operation to query the ECC ID. For more information, see [QueryApplicationStatus](~~149394~~).
	//
	// *   Separate multiple ECC IDs with commas (,).
	// *   If you leave this parameter empty, the application will be restarted on all the ECS instances deployed with the application.
	EccInfo *string `json:"EccInfo,omitempty" xml:"EccInfo,omitempty"`
}

func (s RestartApplicationRequest) String() string {
	return tea.Prettify(s)
}

func (s RestartApplicationRequest) GoString() string {
	return s.String()
}

func (s *RestartApplicationRequest) SetAppId(v string) *RestartApplicationRequest {
	s.AppId = &v
	return s
}

func (s *RestartApplicationRequest) SetEccInfo(v string) *RestartApplicationRequest {
	s.EccInfo = &v
	return s
}

type RestartApplicationResponseBody struct {
	// The ID of the change process.
	//
	// You can call the GetChangeOrderInfo operation to query the progress of this restart. For more information, see [GetChangeOrderInfo](~~62072~~).
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RestartApplicationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RestartApplicationResponseBody) GoString() string {
	return s.String()
}

func (s *RestartApplicationResponseBody) SetChangeOrderId(v string) *RestartApplicationResponseBody {
	s.ChangeOrderId = &v
	return s
}

func (s *RestartApplicationResponseBody) SetCode(v int32) *RestartApplicationResponseBody {
	s.Code = &v
	return s
}

func (s *RestartApplicationResponseBody) SetMessage(v string) *RestartApplicationResponseBody {
	s.Message = &v
	return s
}

func (s *RestartApplicationResponseBody) SetRequestId(v string) *RestartApplicationResponseBody {
	s.RequestId = &v
	return s
}

type RestartApplicationResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RestartApplicationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RestartApplicationResponse) String() string {
	return tea.Prettify(s)
}

func (s RestartApplicationResponse) GoString() string {
	return s.String()
}

func (s *RestartApplicationResponse) SetHeaders(v map[string]*string) *RestartApplicationResponse {
	s.Headers = v
	return s
}

func (s *RestartApplicationResponse) SetStatusCode(v int32) *RestartApplicationResponse {
	s.StatusCode = &v
	return s
}

func (s *RestartApplicationResponse) SetBody(v *RestartApplicationResponseBody) *RestartApplicationResponse {
	s.Body = v
	return s
}

type RestartK8sApplicationRequest struct {
	// The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The timeout period of the change process. Unit: seconds.
	Timeout *int32 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
}

func (s RestartK8sApplicationRequest) String() string {
	return tea.Prettify(s)
}

func (s RestartK8sApplicationRequest) GoString() string {
	return s.String()
}

func (s *RestartK8sApplicationRequest) SetAppId(v string) *RestartK8sApplicationRequest {
	s.AppId = &v
	return s
}

func (s *RestartK8sApplicationRequest) SetTimeout(v int32) *RestartK8sApplicationRequest {
	s.Timeout = &v
	return s
}

type RestartK8sApplicationResponseBody struct {
	// The ID of the change process.
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RestartK8sApplicationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RestartK8sApplicationResponseBody) GoString() string {
	return s.String()
}

func (s *RestartK8sApplicationResponseBody) SetChangeOrderId(v string) *RestartK8sApplicationResponseBody {
	s.ChangeOrderId = &v
	return s
}

func (s *RestartK8sApplicationResponseBody) SetCode(v int32) *RestartK8sApplicationResponseBody {
	s.Code = &v
	return s
}

func (s *RestartK8sApplicationResponseBody) SetMessage(v string) *RestartK8sApplicationResponseBody {
	s.Message = &v
	return s
}

func (s *RestartK8sApplicationResponseBody) SetRequestId(v string) *RestartK8sApplicationResponseBody {
	s.RequestId = &v
	return s
}

type RestartK8sApplicationResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RestartK8sApplicationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RestartK8sApplicationResponse) String() string {
	return tea.Prettify(s)
}

func (s RestartK8sApplicationResponse) GoString() string {
	return s.String()
}

func (s *RestartK8sApplicationResponse) SetHeaders(v map[string]*string) *RestartK8sApplicationResponse {
	s.Headers = v
	return s
}

func (s *RestartK8sApplicationResponse) SetStatusCode(v int32) *RestartK8sApplicationResponse {
	s.StatusCode = &v
	return s
}

func (s *RestartK8sApplicationResponse) SetBody(v *RestartK8sApplicationResponseBody) *RestartK8sApplicationResponse {
	s.Body = v
	return s
}

type RetryChangeOrderTaskRequest struct {
	// The retry status.
	RetryStatus *bool `json:"RetryStatus,omitempty" xml:"RetryStatus,omitempty"`
	// The ID of the process.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s RetryChangeOrderTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s RetryChangeOrderTaskRequest) GoString() string {
	return s.String()
}

func (s *RetryChangeOrderTaskRequest) SetRetryStatus(v bool) *RetryChangeOrderTaskRequest {
	s.RetryStatus = &v
	return s
}

func (s *RetryChangeOrderTaskRequest) SetTaskId(v string) *RetryChangeOrderTaskRequest {
	s.TaskId = &v
	return s
}

type RetryChangeOrderTaskResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The retry information.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RetryChangeOrderTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RetryChangeOrderTaskResponseBody) GoString() string {
	return s.String()
}

func (s *RetryChangeOrderTaskResponseBody) SetCode(v int32) *RetryChangeOrderTaskResponseBody {
	s.Code = &v
	return s
}

func (s *RetryChangeOrderTaskResponseBody) SetData(v string) *RetryChangeOrderTaskResponseBody {
	s.Data = &v
	return s
}

func (s *RetryChangeOrderTaskResponseBody) SetMessage(v string) *RetryChangeOrderTaskResponseBody {
	s.Message = &v
	return s
}

func (s *RetryChangeOrderTaskResponseBody) SetRequestId(v string) *RetryChangeOrderTaskResponseBody {
	s.RequestId = &v
	return s
}

type RetryChangeOrderTaskResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RetryChangeOrderTaskResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RetryChangeOrderTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s RetryChangeOrderTaskResponse) GoString() string {
	return s.String()
}

func (s *RetryChangeOrderTaskResponse) SetHeaders(v map[string]*string) *RetryChangeOrderTaskResponse {
	s.Headers = v
	return s
}

func (s *RetryChangeOrderTaskResponse) SetStatusCode(v int32) *RetryChangeOrderTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *RetryChangeOrderTaskResponse) SetBody(v *RetryChangeOrderTaskResponseBody) *RetryChangeOrderTaskResponse {
	s.Body = v
	return s
}

type RollbackApplicationRequest struct {
	// The application ID. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](~~423162~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The number of batches for the rollback. Default value: 1. Valid values: 1 to 5.
	Batch *int32 `json:"Batch,omitempty" xml:"Batch,omitempty"`
	// The wait time between batches. Default value: 0. The default value indicates no wait time. Valid values: 0 to 5. Unit: minutes.
	BatchWaitTime *int32 `json:"BatchWaitTime,omitempty" xml:"BatchWaitTime,omitempty"`
	// The application group ID. You can call the ListDeployGroup operation to query the application group ID. For more information, see [ListDeployGroup](~~423184~~).
	//
	// If you need to roll back the application in all application groups, set this parameter to `all`.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The historical version to which you want to roll back the application. Call the ListHistoryDeployVersion operation to query the historical versions of the application. Then, set this parameter based on the returned value of `PackageVersion`. For more information, see [ListHistoryDeployVersion](~~423163~~).
	HistoryVersion *string `json:"HistoryVersion,omitempty" xml:"HistoryVersion,omitempty"`
}

func (s RollbackApplicationRequest) String() string {
	return tea.Prettify(s)
}

func (s RollbackApplicationRequest) GoString() string {
	return s.String()
}

func (s *RollbackApplicationRequest) SetAppId(v string) *RollbackApplicationRequest {
	s.AppId = &v
	return s
}

func (s *RollbackApplicationRequest) SetBatch(v int32) *RollbackApplicationRequest {
	s.Batch = &v
	return s
}

func (s *RollbackApplicationRequest) SetBatchWaitTime(v int32) *RollbackApplicationRequest {
	s.BatchWaitTime = &v
	return s
}

func (s *RollbackApplicationRequest) SetGroupId(v string) *RollbackApplicationRequest {
	s.GroupId = &v
	return s
}

func (s *RollbackApplicationRequest) SetHistoryVersion(v string) *RollbackApplicationRequest {
	s.HistoryVersion = &v
	return s
}

type RollbackApplicationResponseBody struct {
	// The change process ID. You can call the GetChangeOrderInfo operation to query the progress of this rollback. For more information, see [GetChangeOrderInfo](~~423155~~).
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	// The HTTP status code.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RollbackApplicationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RollbackApplicationResponseBody) GoString() string {
	return s.String()
}

func (s *RollbackApplicationResponseBody) SetChangeOrderId(v string) *RollbackApplicationResponseBody {
	s.ChangeOrderId = &v
	return s
}

func (s *RollbackApplicationResponseBody) SetCode(v int32) *RollbackApplicationResponseBody {
	s.Code = &v
	return s
}

func (s *RollbackApplicationResponseBody) SetMessage(v string) *RollbackApplicationResponseBody {
	s.Message = &v
	return s
}

func (s *RollbackApplicationResponseBody) SetRequestId(v string) *RollbackApplicationResponseBody {
	s.RequestId = &v
	return s
}

type RollbackApplicationResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RollbackApplicationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RollbackApplicationResponse) String() string {
	return tea.Prettify(s)
}

func (s RollbackApplicationResponse) GoString() string {
	return s.String()
}

func (s *RollbackApplicationResponse) SetHeaders(v map[string]*string) *RollbackApplicationResponse {
	s.Headers = v
	return s
}

func (s *RollbackApplicationResponse) SetStatusCode(v int32) *RollbackApplicationResponse {
	s.StatusCode = &v
	return s
}

func (s *RollbackApplicationResponse) SetBody(v *RollbackApplicationResponseBody) *RollbackApplicationResponse {
	s.Body = v
	return s
}

type RollbackChangeOrderRequest struct {
	// The ID of the change process.
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
}

func (s RollbackChangeOrderRequest) String() string {
	return tea.Prettify(s)
}

func (s RollbackChangeOrderRequest) GoString() string {
	return s.String()
}

func (s *RollbackChangeOrderRequest) SetChangeOrderId(v string) *RollbackChangeOrderRequest {
	s.ChangeOrderId = &v
	return s
}

type RollbackChangeOrderResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The information about the change process.
	Data *RollbackChangeOrderResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code that is returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the trace.
	TraceId *string `json:"TraceId,omitempty" xml:"TraceId,omitempty"`
}

func (s RollbackChangeOrderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RollbackChangeOrderResponseBody) GoString() string {
	return s.String()
}

func (s *RollbackChangeOrderResponseBody) SetCode(v int32) *RollbackChangeOrderResponseBody {
	s.Code = &v
	return s
}

func (s *RollbackChangeOrderResponseBody) SetData(v *RollbackChangeOrderResponseBodyData) *RollbackChangeOrderResponseBody {
	s.Data = v
	return s
}

func (s *RollbackChangeOrderResponseBody) SetErrorCode(v string) *RollbackChangeOrderResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *RollbackChangeOrderResponseBody) SetMessage(v string) *RollbackChangeOrderResponseBody {
	s.Message = &v
	return s
}

func (s *RollbackChangeOrderResponseBody) SetRequestId(v string) *RollbackChangeOrderResponseBody {
	s.RequestId = &v
	return s
}

func (s *RollbackChangeOrderResponseBody) SetTraceId(v string) *RollbackChangeOrderResponseBody {
	s.TraceId = &v
	return s
}

type RollbackChangeOrderResponseBodyData struct {
	// The ID of the change process.
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
}

func (s RollbackChangeOrderResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s RollbackChangeOrderResponseBodyData) GoString() string {
	return s.String()
}

func (s *RollbackChangeOrderResponseBodyData) SetChangeOrderId(v string) *RollbackChangeOrderResponseBodyData {
	s.ChangeOrderId = &v
	return s
}

type RollbackChangeOrderResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RollbackChangeOrderResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RollbackChangeOrderResponse) String() string {
	return tea.Prettify(s)
}

func (s RollbackChangeOrderResponse) GoString() string {
	return s.String()
}

func (s *RollbackChangeOrderResponse) SetHeaders(v map[string]*string) *RollbackChangeOrderResponse {
	s.Headers = v
	return s
}

func (s *RollbackChangeOrderResponse) SetStatusCode(v int32) *RollbackChangeOrderResponse {
	s.StatusCode = &v
	return s
}

func (s *RollbackChangeOrderResponse) SetBody(v *RollbackChangeOrderResponseBody) *RollbackChangeOrderResponse {
	s.Body = v
	return s
}

type ScaleInApplicationRequest struct {
	// The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the elastic compute container (ECC) that corresponds to the Elastic Compute Service (ECS) instance to be removed for the application. Separate multiple ECC IDs with commas (,). You can call the QueryApplicationStatus operation to query the ECC ID. For more information, see [QueryApplicationStatus](~~149394~~).
	EccInfo *string `json:"EccInfo,omitempty" xml:"EccInfo,omitempty"`
	// Specifies whether to forcibly unpublish the application from the ECS instance. You need to set this parameter to true only if the ECS instance expires. In normal cases, you do not need to set this parameter to true.
	ForceStatus *bool `json:"ForceStatus,omitempty" xml:"ForceStatus,omitempty"`
}

func (s ScaleInApplicationRequest) String() string {
	return tea.Prettify(s)
}

func (s ScaleInApplicationRequest) GoString() string {
	return s.String()
}

func (s *ScaleInApplicationRequest) SetAppId(v string) *ScaleInApplicationRequest {
	s.AppId = &v
	return s
}

func (s *ScaleInApplicationRequest) SetEccInfo(v string) *ScaleInApplicationRequest {
	s.EccInfo = &v
	return s
}

func (s *ScaleInApplicationRequest) SetForceStatus(v bool) *ScaleInApplicationRequest {
	s.ForceStatus = &v
	return s
}

type ScaleInApplicationResponseBody struct {
	// The ID of the change process for this operation. You can call the GetChangeOrderInfo operation to query the progress of this scale-in. For more information, see [GetChangeOrderInfo](~~62072~~). No ID is generated if the ForceStatus parameter is set to true. You can check whether the request is successful based on the value of the Code parameter.
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
}

func (s ScaleInApplicationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ScaleInApplicationResponseBody) GoString() string {
	return s.String()
}

func (s *ScaleInApplicationResponseBody) SetChangeOrderId(v string) *ScaleInApplicationResponseBody {
	s.ChangeOrderId = &v
	return s
}

func (s *ScaleInApplicationResponseBody) SetCode(v int32) *ScaleInApplicationResponseBody {
	s.Code = &v
	return s
}

func (s *ScaleInApplicationResponseBody) SetMessage(v string) *ScaleInApplicationResponseBody {
	s.Message = &v
	return s
}

type ScaleInApplicationResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ScaleInApplicationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ScaleInApplicationResponse) String() string {
	return tea.Prettify(s)
}

func (s ScaleInApplicationResponse) GoString() string {
	return s.String()
}

func (s *ScaleInApplicationResponse) SetHeaders(v map[string]*string) *ScaleInApplicationResponse {
	s.Headers = v
	return s
}

func (s *ScaleInApplicationResponse) SetStatusCode(v int32) *ScaleInApplicationResponse {
	s.StatusCode = &v
	return s
}

func (s *ScaleInApplicationResponse) SetBody(v *ScaleInApplicationResponseBody) *ScaleInApplicationResponse {
	s.Body = v
	return s
}

type ScaleK8sApplicationRequest struct {
	// The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The expected number of application instances after the scale-out or scale-in. The minimum number is 0.
	Replicas *int32 `json:"Replicas,omitempty" xml:"Replicas,omitempty"`
	// The timeout period of the change process. Unit: seconds.
	Timeout *int32 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
}

func (s ScaleK8sApplicationRequest) String() string {
	return tea.Prettify(s)
}

func (s ScaleK8sApplicationRequest) GoString() string {
	return s.String()
}

func (s *ScaleK8sApplicationRequest) SetAppId(v string) *ScaleK8sApplicationRequest {
	s.AppId = &v
	return s
}

func (s *ScaleK8sApplicationRequest) SetReplicas(v int32) *ScaleK8sApplicationRequest {
	s.Replicas = &v
	return s
}

func (s *ScaleK8sApplicationRequest) SetTimeout(v int32) *ScaleK8sApplicationRequest {
	s.Timeout = &v
	return s
}

type ScaleK8sApplicationResponseBody struct {
	// The ID of the change process. You can call the GetChangeOrderInfo operation to query the progress of this scaling operation. For more information, see [GetChangeOrderInfo](~~62072~~).
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ScaleK8sApplicationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ScaleK8sApplicationResponseBody) GoString() string {
	return s.String()
}

func (s *ScaleK8sApplicationResponseBody) SetChangeOrderId(v string) *ScaleK8sApplicationResponseBody {
	s.ChangeOrderId = &v
	return s
}

func (s *ScaleK8sApplicationResponseBody) SetCode(v int32) *ScaleK8sApplicationResponseBody {
	s.Code = &v
	return s
}

func (s *ScaleK8sApplicationResponseBody) SetMessage(v string) *ScaleK8sApplicationResponseBody {
	s.Message = &v
	return s
}

func (s *ScaleK8sApplicationResponseBody) SetRequestId(v string) *ScaleK8sApplicationResponseBody {
	s.RequestId = &v
	return s
}

type ScaleK8sApplicationResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ScaleK8sApplicationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ScaleK8sApplicationResponse) String() string {
	return tea.Prettify(s)
}

func (s ScaleK8sApplicationResponse) GoString() string {
	return s.String()
}

func (s *ScaleK8sApplicationResponse) SetHeaders(v map[string]*string) *ScaleK8sApplicationResponse {
	s.Headers = v
	return s
}

func (s *ScaleK8sApplicationResponse) SetStatusCode(v int32) *ScaleK8sApplicationResponse {
	s.StatusCode = &v
	return s
}

func (s *ScaleK8sApplicationResponse) SetBody(v *ScaleK8sApplicationResponseBody) *ScaleK8sApplicationResponse {
	s.Body = v
	return s
}

type ScaleOutApplicationRequest struct {
	// The ID of the application that you want to scale out. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the instance group where the application you want to scale out is deployed. You can call the QueryApplicationStatus operation to query the group ID. For more information, see [QueryApplicationStatus](~~149394~~).
	DeployGroup *string `json:"DeployGroup,omitempty" xml:"DeployGroup,omitempty"`
	// The ID of the elastic compute unit (ECU) that corresponds to the Elastic Compute Service (ECS) instance to be added to the instance group for scale-out. You can call the ListScaleOutEcu operation to query the ECU ID. For more information, see [ListScaleOutEcu](~~149371~~). Separate multiple ECU IDs with commas (,).
	EcuInfo *string `json:"EcuInfo,omitempty" xml:"EcuInfo,omitempty"`
}

func (s ScaleOutApplicationRequest) String() string {
	return tea.Prettify(s)
}

func (s ScaleOutApplicationRequest) GoString() string {
	return s.String()
}

func (s *ScaleOutApplicationRequest) SetAppId(v string) *ScaleOutApplicationRequest {
	s.AppId = &v
	return s
}

func (s *ScaleOutApplicationRequest) SetDeployGroup(v string) *ScaleOutApplicationRequest {
	s.DeployGroup = &v
	return s
}

func (s *ScaleOutApplicationRequest) SetEcuInfo(v string) *ScaleOutApplicationRequest {
	s.EcuInfo = &v
	return s
}

type ScaleOutApplicationResponseBody struct {
	// The ID of the change process. You can call the GetChangeOrderInfo operation to query the progress of this scale-out. For more information, see [GetChangeOrderInfo](~~62072~~).
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ScaleOutApplicationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ScaleOutApplicationResponseBody) GoString() string {
	return s.String()
}

func (s *ScaleOutApplicationResponseBody) SetChangeOrderId(v string) *ScaleOutApplicationResponseBody {
	s.ChangeOrderId = &v
	return s
}

func (s *ScaleOutApplicationResponseBody) SetCode(v int32) *ScaleOutApplicationResponseBody {
	s.Code = &v
	return s
}

func (s *ScaleOutApplicationResponseBody) SetMessage(v string) *ScaleOutApplicationResponseBody {
	s.Message = &v
	return s
}

func (s *ScaleOutApplicationResponseBody) SetRequestId(v string) *ScaleOutApplicationResponseBody {
	s.RequestId = &v
	return s
}

type ScaleOutApplicationResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ScaleOutApplicationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ScaleOutApplicationResponse) String() string {
	return tea.Prettify(s)
}

func (s ScaleOutApplicationResponse) GoString() string {
	return s.String()
}

func (s *ScaleOutApplicationResponse) SetHeaders(v map[string]*string) *ScaleOutApplicationResponse {
	s.Headers = v
	return s
}

func (s *ScaleOutApplicationResponse) SetStatusCode(v int32) *ScaleOutApplicationResponse {
	s.StatusCode = &v
	return s
}

func (s *ScaleOutApplicationResponse) SetBody(v *ScaleOutApplicationResponseBody) *ScaleOutApplicationResponse {
	s.Body = v
	return s
}

type ScaleoutApplicationWithNewInstancesRequest struct {
	// The ID of the application that you want to scale out. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// Specifies whether to enable auto-renewal. This parameter takes effect only when the InstanceChargeType parameter is set to PrePaid. Valid values:
	//
	// *   true: enables auto-renewal.
	// *   false: does not enable auto-renewal. This is the default value.
	AutoRenew *bool `json:"AutoRenew,omitempty" xml:"AutoRenew,omitempty"`
	// The auto-renewal period. Valid values:
	//
	// *   If the InstanceChargePeriodUnit parameter is set to Week, the valid values of the AutoRenewPeriod parameter are 1, 2, and 3.
	// *   If the InstanceChargePeriodUnit parameter is set to Month, the valid values of the AutoRenewPeriod parameter are 1, 2, 3, 6, 12, 24, 36, 48, and 60.
	//
	// Default value: 1.
	AutoRenewPeriod *int32 `json:"AutoRenewPeriod,omitempty" xml:"AutoRenewPeriod,omitempty"`
	// The ID of the cluster to which you want to add ECS instances. If the application and application instance group for the scale-out are specified, this parameter is ignored.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The ID of the instance group that you want to scale out. You can call the ListDeployGroup operation to query the group ID. For more information, see [ListDeployGroup](~~62077~~).
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The duration of the subscription. The unit of the subscription duration is specified by the InstanceChargePeriodUnit parameter. This parameter takes effect only when the InstanceChargeType parameter is set to PrePaid.
	//
	// *   If the InstanceChargePeriodUnit parameter is set to Week, the valid values of the InstanceChargePeriod parameter are 1, 2, 3, and 4.
	// *   If the InstanceChargePeriodUnit parameter is set to Month, the valid values of the InstanceChargePeriod parameter are 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 24, 36, 48, and 60.
	InstanceChargePeriod *int32 `json:"InstanceChargePeriod,omitempty" xml:"InstanceChargePeriod,omitempty"`
	// The unit of the subscription period. Valid values:
	//
	// *   Week: billed on a weekly basis.
	// *   Month: billed on a monthly basis. This is the default value.
	InstanceChargePeriodUnit *string `json:"InstanceChargePeriodUnit,omitempty" xml:"InstanceChargePeriodUnit,omitempty"`
	// The billing method of the instance. Valid values:
	//
	// *   PrePaid: subscription.
	// *   PostPaid: pay-as-you-go. This is the default value.
	InstanceChargeType *string `json:"InstanceChargeType,omitempty" xml:"InstanceChargeType,omitempty"`
	// The number of instances to be added for the scale-out.
	ScalingNum *int32 `json:"ScalingNum,omitempty" xml:"ScalingNum,omitempty"`
	// The instance reclaim mode of the scaling group. Valid values:
	//
	// *   recycle: economical mode
	// *   release: release mode
	//
	// For more information about how to remove instances from a specified scaling group, see [RemoveInstances](~~25955~~).
	ScalingPolicy *string `json:"ScalingPolicy,omitempty" xml:"ScalingPolicy,omitempty"`
	// The ID of the ECS instance launch template. You can call the DescribeLaunchTemplates operation to query the launch template ID. For more information, see [DescribeLaunchTemplates](~~73759~~).
	TemplateId *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The ID of the existing ECS instance used for the scale-out. If this parameter is specified, the specifications and configurations of the specified ECS instance are used as a template to purchase new instances.
	TemplateInstanceId *string `json:"TemplateInstanceId,omitempty" xml:"TemplateInstanceId,omitempty"`
	// The version of the ECS instance launch template. You can call the DescribeLaunchTemplateVersions operation to query the launch template version. For more information, see [DescribeLaunchTemplateVersions](~~73761~~).
	//
	// > If you set this parameter to `-1`, the default launch template version is used.
	TemplateVersion *string `json:"TemplateVersion,omitempty" xml:"TemplateVersion,omitempty"`
}

func (s ScaleoutApplicationWithNewInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s ScaleoutApplicationWithNewInstancesRequest) GoString() string {
	return s.String()
}

func (s *ScaleoutApplicationWithNewInstancesRequest) SetAppId(v string) *ScaleoutApplicationWithNewInstancesRequest {
	s.AppId = &v
	return s
}

func (s *ScaleoutApplicationWithNewInstancesRequest) SetAutoRenew(v bool) *ScaleoutApplicationWithNewInstancesRequest {
	s.AutoRenew = &v
	return s
}

func (s *ScaleoutApplicationWithNewInstancesRequest) SetAutoRenewPeriod(v int32) *ScaleoutApplicationWithNewInstancesRequest {
	s.AutoRenewPeriod = &v
	return s
}

func (s *ScaleoutApplicationWithNewInstancesRequest) SetClusterId(v string) *ScaleoutApplicationWithNewInstancesRequest {
	s.ClusterId = &v
	return s
}

func (s *ScaleoutApplicationWithNewInstancesRequest) SetGroupId(v string) *ScaleoutApplicationWithNewInstancesRequest {
	s.GroupId = &v
	return s
}

func (s *ScaleoutApplicationWithNewInstancesRequest) SetInstanceChargePeriod(v int32) *ScaleoutApplicationWithNewInstancesRequest {
	s.InstanceChargePeriod = &v
	return s
}

func (s *ScaleoutApplicationWithNewInstancesRequest) SetInstanceChargePeriodUnit(v string) *ScaleoutApplicationWithNewInstancesRequest {
	s.InstanceChargePeriodUnit = &v
	return s
}

func (s *ScaleoutApplicationWithNewInstancesRequest) SetInstanceChargeType(v string) *ScaleoutApplicationWithNewInstancesRequest {
	s.InstanceChargeType = &v
	return s
}

func (s *ScaleoutApplicationWithNewInstancesRequest) SetScalingNum(v int32) *ScaleoutApplicationWithNewInstancesRequest {
	s.ScalingNum = &v
	return s
}

func (s *ScaleoutApplicationWithNewInstancesRequest) SetScalingPolicy(v string) *ScaleoutApplicationWithNewInstancesRequest {
	s.ScalingPolicy = &v
	return s
}

func (s *ScaleoutApplicationWithNewInstancesRequest) SetTemplateId(v string) *ScaleoutApplicationWithNewInstancesRequest {
	s.TemplateId = &v
	return s
}

func (s *ScaleoutApplicationWithNewInstancesRequest) SetTemplateInstanceId(v string) *ScaleoutApplicationWithNewInstancesRequest {
	s.TemplateInstanceId = &v
	return s
}

func (s *ScaleoutApplicationWithNewInstancesRequest) SetTemplateVersion(v string) *ScaleoutApplicationWithNewInstancesRequest {
	s.TemplateVersion = &v
	return s
}

type ScaleoutApplicationWithNewInstancesResponseBody struct {
	// The ID of the change process for the scale-out.
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The IDs of ECS instances.
	InstanceIds []*string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty" type:"Repeated"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ScaleoutApplicationWithNewInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ScaleoutApplicationWithNewInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *ScaleoutApplicationWithNewInstancesResponseBody) SetChangeOrderId(v string) *ScaleoutApplicationWithNewInstancesResponseBody {
	s.ChangeOrderId = &v
	return s
}

func (s *ScaleoutApplicationWithNewInstancesResponseBody) SetCode(v int32) *ScaleoutApplicationWithNewInstancesResponseBody {
	s.Code = &v
	return s
}

func (s *ScaleoutApplicationWithNewInstancesResponseBody) SetInstanceIds(v []*string) *ScaleoutApplicationWithNewInstancesResponseBody {
	s.InstanceIds = v
	return s
}

func (s *ScaleoutApplicationWithNewInstancesResponseBody) SetMessage(v string) *ScaleoutApplicationWithNewInstancesResponseBody {
	s.Message = &v
	return s
}

func (s *ScaleoutApplicationWithNewInstancesResponseBody) SetRequestId(v string) *ScaleoutApplicationWithNewInstancesResponseBody {
	s.RequestId = &v
	return s
}

type ScaleoutApplicationWithNewInstancesResponse struct {
	Headers    map[string]*string                               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ScaleoutApplicationWithNewInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ScaleoutApplicationWithNewInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s ScaleoutApplicationWithNewInstancesResponse) GoString() string {
	return s.String()
}

func (s *ScaleoutApplicationWithNewInstancesResponse) SetHeaders(v map[string]*string) *ScaleoutApplicationWithNewInstancesResponse {
	s.Headers = v
	return s
}

func (s *ScaleoutApplicationWithNewInstancesResponse) SetStatusCode(v int32) *ScaleoutApplicationWithNewInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *ScaleoutApplicationWithNewInstancesResponse) SetBody(v *ScaleoutApplicationWithNewInstancesResponseBody) *ScaleoutApplicationWithNewInstancesResponse {
	s.Body = v
	return s
}

type StartApplicationRequest struct {
	// The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the elastic compute container (ECC) that corresponds to the Elastic Compute Service (ECS) instance on which you want to start the application. Separate multiple ECC IDs with commas (,). You can call the QueryApplicationStatus operation to query the ECC ID. For more information, see [QueryApplicationStatus](~~149394~~).
	EccInfo *string `json:"EccInfo,omitempty" xml:"EccInfo,omitempty"`
}

func (s StartApplicationRequest) String() string {
	return tea.Prettify(s)
}

func (s StartApplicationRequest) GoString() string {
	return s.String()
}

func (s *StartApplicationRequest) SetAppId(v string) *StartApplicationRequest {
	s.AppId = &v
	return s
}

func (s *StartApplicationRequest) SetEccInfo(v string) *StartApplicationRequest {
	s.EccInfo = &v
	return s
}

type StartApplicationResponseBody struct {
	// The ID of the change process for this operation. You can call the GetChangeOrderInfo operation to query the progress of this startup. For more information, see [GetChangeOrderInfo](~~62072~~).
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s StartApplicationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StartApplicationResponseBody) GoString() string {
	return s.String()
}

func (s *StartApplicationResponseBody) SetChangeOrderId(v string) *StartApplicationResponseBody {
	s.ChangeOrderId = &v
	return s
}

func (s *StartApplicationResponseBody) SetCode(v int32) *StartApplicationResponseBody {
	s.Code = &v
	return s
}

func (s *StartApplicationResponseBody) SetMessage(v string) *StartApplicationResponseBody {
	s.Message = &v
	return s
}

func (s *StartApplicationResponseBody) SetRequestId(v string) *StartApplicationResponseBody {
	s.RequestId = &v
	return s
}

type StartApplicationResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *StartApplicationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s StartApplicationResponse) String() string {
	return tea.Prettify(s)
}

func (s StartApplicationResponse) GoString() string {
	return s.String()
}

func (s *StartApplicationResponse) SetHeaders(v map[string]*string) *StartApplicationResponse {
	s.Headers = v
	return s
}

func (s *StartApplicationResponse) SetStatusCode(v int32) *StartApplicationResponse {
	s.StatusCode = &v
	return s
}

func (s *StartApplicationResponse) SetBody(v *StartApplicationResponseBody) *StartApplicationResponse {
	s.Body = v
	return s
}

type StartK8sAppPrecheckRequest struct {
	// The annotation of an application pod.
	Annotations *string `json:"Annotations,omitempty" xml:"Annotations,omitempty"`
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application. The name must start with a letter, and can contain digits, letters, and hyphens (-). It can be up to 36 characters in length.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The ID of the application component. You can call the ListComponents operation to query application components. This parameter must be specified when the application runs in Apache Tomcat or in a standard Java application runtime environment. The Apache Tomcat application runtime environment is applicable to Dubbo applications that are deployed by using WAR packages. A standard Java application runtime environment is applicable to Spring Boot or Spring Cloud applications that are deployed by using JAR packages.
	//
	// Valid values for regular application component IDs:
	//
	// *   4: Apache Tomcat 7.0.91
	// *   5: OpenJDK 1.8.x
	// *   6: OpenJDK 1.7.x
	// *   7: Apache Tomcat 8.5.42
	//
	// This parameter is available only for Java SDK 2.57.3 or later, or Python SDK 2.57.3 or later. Assume that you use an SDK that is not provided by Enterprise Distributed Application Service (EDAS), such as aliyun-python-sdk-core, aliyun-java-sdk-core, and Alibaba Cloud CLI. In this case, you can directly specify this parameter.
	ComponentIds *string `json:"ComponentIds,omitempty" xml:"ComponentIds,omitempty"`
	// The configuration for mounting a Kubernetes ConfigMap or Secret to a directory in an elastic container instance. The following parameters are included in the configuration:
	//
	// *   name: the name of the Kubernetes ConfigMap or Secret.
	// *   type: the type of the API object that you want to mount. You can mount a Kubernetes ConfigMap or Secret.
	// *   mountPath: the mount path. The mount path must be an absolute path that starts with a forward slash (/).
	ConfigMountDescs *string `json:"ConfigMountDescs,omitempty" xml:"ConfigMountDescs,omitempty"`
	// The configuration for mounting a Kubernetes emptyDir volume to a directory in an elastic container instance. The following parameters are included in the configuration:
	//
	// *   mountPath: The mount path in the container. This parameter is required.
	// *   readOnly: (Optional) The mount mode. The value true indicates the read-only mode. The value false indicates the read and write mode. Default value: false.
	// *   subPathExpr: (Optional) The regular expression that is used to match the subdirectory.
	EmptyDirs *string `json:"EmptyDirs,omitempty" xml:"EmptyDirs,omitempty"`
	// The Kubernetes environment variables that are configured in EnvFrom mode. A ConfigMap or Secret is mounted to a directory. Each key corresponds to a file in the directory, and the content of the file is the value of the key.
	//
	// The following parameters are included in the configuration of the EnvFroms parameter:
	//
	// *   configMapRef: the ConfigMap that is referenced. The following parameter is included:
	//
	//     name: the name of the ConfigMap.
	//
	// *   secretRef: the Secret that is referenced. The following parameter is included:
	//
	//     name: the name of the Secret.
	EnvFroms *string `json:"EnvFroms,omitempty" xml:"EnvFroms,omitempty"`
	// The environment variables that are used to deploy the application. The value must be a JSON array. Valid values: regular environment variables, Kubernetes ConfigMap environment variables, and Kubernetes Secret environment variables. Specify regular environment variables in the following format:
	//
	// `{"name":"x", "value": "y"}`
	//
	// Specify Kubernetes ConfigMap environment variables in the following format to reference values from ConfigMaps:
	//
	// `{ "name": "x2", "valueFrom": { "configMapKeyRef": { "name": "my-config", "key": "y2" } } }`
	//
	// Specify Kubernetes Secret environment variables in the following format to reference values from Secrets:
	//
	// `{ "name": "x3", "valueFrom": { "secretKeyRef": { "name": "my-secret", "key": "y3" } } }`
	//
	// > If you want to cancel this configuration, set this parameter to an empty JSON array, which is in the format of "\[]".
	Envs *string `json:"Envs,omitempty" xml:"Envs,omitempty"`
	// The URL of the image.
	ImageUrl *string `json:"ImageUrl,omitempty" xml:"ImageUrl,omitempty"`
	// The configuration of Java startup parameters for a Java application. These startup parameters involve the memory, application, garbage collection (GC) policy, tools, service registration and discovery, and custom configurations. Proper parameter settings help reduce the GC overheads, shorten the server response time, and improve the throughput. Set this parameter to a JSON string. In the example, original indicates the configuration value, and startup indicates a startup parameter. The system automatically concatenates all startup values as the settings of Java startup parameters for the application. To delete this configuration, leave the parameter value empty by entering `""` or `"{}"`. The following parameters are included in the configuration:
	//
	// *   InitialHeapSize: the initial size of the heap memory.
	// *   MaxHeapSize: the maximum size of the heap memory.
	// *   CustomParams: the custom parameters, such as JVM -D parameters.
	// *   Other parameters: You can view the JSON structure submitted by the frontend.
	JavaStartUpConfig *string `json:"JavaStartUpConfig,omitempty" xml:"JavaStartUpConfig,omitempty"`
	// The label of an application pod.
	Labels *string `json:"Labels,omitempty" xml:"Labels,omitempty"`
	// The maximum size of space required by ephemeral storage. Unit: GB. The value 0 indicates that no limit is set on the ephemeral storage space.
	LimitEphemeralStorage *int32 `json:"LimitEphemeralStorage,omitempty" xml:"LimitEphemeralStorage,omitempty"`
	// The maximum size of memory allowed for each application instance when the application is running. Unit: MB. The value of LimitMem must be greater than or equal to that of RequestsMem.
	LimitMem *int32 `json:"LimitMem,omitempty" xml:"LimitMem,omitempty"`
	// The maximum number of CPU cores allowed for each application instance when the application is running. Unit: millicores. The value 0 indicates that no limit is set on CPU cores.
	LimitmCpu *int32 `json:"LimitmCpu,omitempty" xml:"LimitmCpu,omitempty"`
	// The configurations that are used when the host files are mounted to the container on which the application is running. Example: `\[{"type":"","nodePath":"/localfiles","mountPath":"/app/files"},{"type":"Directory","nodePath":"/mnt","mountPath":"/app/storage"}\]`. Description:
	//
	// *   `nodePath`: the host path.
	// *   `mountPath`: the path in the container.
	// *   `type`: the mounting type.
	LocalVolume *string `json:"LocalVolume,omitempty" xml:"LocalVolume,omitempty"`
	// The namespace of the Kubernetes cluster. This parameter specifies the Kubernetes namespace in which your application is deployed. By default, the default namespace is used.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The URL of the deployment package.
	PackageUrl *string `json:"PackageUrl,omitempty" xml:"PackageUrl,omitempty"`
	// The configuration for mounting a Kubernetes PersistentVolumeClaim (PVC) to a directory in an elastic container instance. The following parameters are included in the configuration:
	//
	// *   pvcName: the name of the PVC. Make sure that the volume exists and is in the Bound state.
	//
	// *   mountPaths: the directory to which you want to mount the PVC. You can configure multiple directories. You can set the following two parameters for each mount directory:
	//
	//     *   mountPath: the mount path. The mount path must be an absolute path that starts with a forward slash (/).
	//     *   readOnly: the mount mode. The value true indicates the read-only mode. The value false indicates the read and write mode. Default value: false.
	PvcMountDescs *string `json:"PvcMountDescs,omitempty" xml:"PvcMountDescs,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The number of application instances.
	Replicas *int32 `json:"Replicas,omitempty" xml:"Replicas,omitempty"`
	// The minimum size of space required by ephemeral storage. Unit: GB. The value 0 indicates that no limit is set on the ephemeral storage space.
	RequestsEphemeralStorage *int32 `json:"RequestsEphemeralStorage,omitempty" xml:"RequestsEphemeralStorage,omitempty"`
	// The maximum size of memory allowed for each application instance when the application is created. Unit: MB. The value 0 indicates that no limit is set on the memory size. The value of RequestsMem cannot be greater than that of LimitMem.
	RequestsMem *int32 `json:"RequestsMem,omitempty" xml:"RequestsMem,omitempty"`
	// The maximum number of CPU cores allowed for each application instance when the application is created. Unit: millicores.
	RequestsmCpu *int32 `json:"RequestsmCpu,omitempty" xml:"RequestsmCpu,omitempty"`
}

func (s StartK8sAppPrecheckRequest) String() string {
	return tea.Prettify(s)
}

func (s StartK8sAppPrecheckRequest) GoString() string {
	return s.String()
}

func (s *StartK8sAppPrecheckRequest) SetAnnotations(v string) *StartK8sAppPrecheckRequest {
	s.Annotations = &v
	return s
}

func (s *StartK8sAppPrecheckRequest) SetAppId(v string) *StartK8sAppPrecheckRequest {
	s.AppId = &v
	return s
}

func (s *StartK8sAppPrecheckRequest) SetAppName(v string) *StartK8sAppPrecheckRequest {
	s.AppName = &v
	return s
}

func (s *StartK8sAppPrecheckRequest) SetClusterId(v string) *StartK8sAppPrecheckRequest {
	s.ClusterId = &v
	return s
}

func (s *StartK8sAppPrecheckRequest) SetComponentIds(v string) *StartK8sAppPrecheckRequest {
	s.ComponentIds = &v
	return s
}

func (s *StartK8sAppPrecheckRequest) SetConfigMountDescs(v string) *StartK8sAppPrecheckRequest {
	s.ConfigMountDescs = &v
	return s
}

func (s *StartK8sAppPrecheckRequest) SetEmptyDirs(v string) *StartK8sAppPrecheckRequest {
	s.EmptyDirs = &v
	return s
}

func (s *StartK8sAppPrecheckRequest) SetEnvFroms(v string) *StartK8sAppPrecheckRequest {
	s.EnvFroms = &v
	return s
}

func (s *StartK8sAppPrecheckRequest) SetEnvs(v string) *StartK8sAppPrecheckRequest {
	s.Envs = &v
	return s
}

func (s *StartK8sAppPrecheckRequest) SetImageUrl(v string) *StartK8sAppPrecheckRequest {
	s.ImageUrl = &v
	return s
}

func (s *StartK8sAppPrecheckRequest) SetJavaStartUpConfig(v string) *StartK8sAppPrecheckRequest {
	s.JavaStartUpConfig = &v
	return s
}

func (s *StartK8sAppPrecheckRequest) SetLabels(v string) *StartK8sAppPrecheckRequest {
	s.Labels = &v
	return s
}

func (s *StartK8sAppPrecheckRequest) SetLimitEphemeralStorage(v int32) *StartK8sAppPrecheckRequest {
	s.LimitEphemeralStorage = &v
	return s
}

func (s *StartK8sAppPrecheckRequest) SetLimitMem(v int32) *StartK8sAppPrecheckRequest {
	s.LimitMem = &v
	return s
}

func (s *StartK8sAppPrecheckRequest) SetLimitmCpu(v int32) *StartK8sAppPrecheckRequest {
	s.LimitmCpu = &v
	return s
}

func (s *StartK8sAppPrecheckRequest) SetLocalVolume(v string) *StartK8sAppPrecheckRequest {
	s.LocalVolume = &v
	return s
}

func (s *StartK8sAppPrecheckRequest) SetNamespace(v string) *StartK8sAppPrecheckRequest {
	s.Namespace = &v
	return s
}

func (s *StartK8sAppPrecheckRequest) SetPackageUrl(v string) *StartK8sAppPrecheckRequest {
	s.PackageUrl = &v
	return s
}

func (s *StartK8sAppPrecheckRequest) SetPvcMountDescs(v string) *StartK8sAppPrecheckRequest {
	s.PvcMountDescs = &v
	return s
}

func (s *StartK8sAppPrecheckRequest) SetRegionId(v string) *StartK8sAppPrecheckRequest {
	s.RegionId = &v
	return s
}

func (s *StartK8sAppPrecheckRequest) SetReplicas(v int32) *StartK8sAppPrecheckRequest {
	s.Replicas = &v
	return s
}

func (s *StartK8sAppPrecheckRequest) SetRequestsEphemeralStorage(v int32) *StartK8sAppPrecheckRequest {
	s.RequestsEphemeralStorage = &v
	return s
}

func (s *StartK8sAppPrecheckRequest) SetRequestsMem(v int32) *StartK8sAppPrecheckRequest {
	s.RequestsMem = &v
	return s
}

func (s *StartK8sAppPrecheckRequest) SetRequestsmCpu(v int32) *StartK8sAppPrecheckRequest {
	s.RequestsmCpu = &v
	return s
}

type StartK8sAppPrecheckResponseBody struct {
	// The HTTP status code.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *StartK8sAppPrecheckResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The returned message.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s StartK8sAppPrecheckResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StartK8sAppPrecheckResponseBody) GoString() string {
	return s.String()
}

func (s *StartK8sAppPrecheckResponseBody) SetCode(v int32) *StartK8sAppPrecheckResponseBody {
	s.Code = &v
	return s
}

func (s *StartK8sAppPrecheckResponseBody) SetData(v *StartK8sAppPrecheckResponseBodyData) *StartK8sAppPrecheckResponseBody {
	s.Data = v
	return s
}

func (s *StartK8sAppPrecheckResponseBody) SetMessage(v string) *StartK8sAppPrecheckResponseBody {
	s.Message = &v
	return s
}

func (s *StartK8sAppPrecheckResponseBody) SetRequestId(v string) *StartK8sAppPrecheckResponseBody {
	s.RequestId = &v
	return s
}

type StartK8sAppPrecheckResponseBodyData struct {
	// The jobs and the details about the jobs.
	Jobs []*string `json:"Jobs,omitempty" xml:"Jobs,omitempty" type:"Repeated"`
}

func (s StartK8sAppPrecheckResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s StartK8sAppPrecheckResponseBodyData) GoString() string {
	return s.String()
}

func (s *StartK8sAppPrecheckResponseBodyData) SetJobs(v []*string) *StartK8sAppPrecheckResponseBodyData {
	s.Jobs = v
	return s
}

type StartK8sAppPrecheckResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *StartK8sAppPrecheckResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s StartK8sAppPrecheckResponse) String() string {
	return tea.Prettify(s)
}

func (s StartK8sAppPrecheckResponse) GoString() string {
	return s.String()
}

func (s *StartK8sAppPrecheckResponse) SetHeaders(v map[string]*string) *StartK8sAppPrecheckResponse {
	s.Headers = v
	return s
}

func (s *StartK8sAppPrecheckResponse) SetStatusCode(v int32) *StartK8sAppPrecheckResponse {
	s.StatusCode = &v
	return s
}

func (s *StartK8sAppPrecheckResponse) SetBody(v *StartK8sAppPrecheckResponseBody) *StartK8sAppPrecheckResponse {
	s.Body = v
	return s
}

type StartK8sApplicationRequest struct {
	// The ID of the application. You can query the application ID by calling the ListApplication operation. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The number of instances on which you want to start the application.
	Replicas *int32 `json:"Replicas,omitempty" xml:"Replicas,omitempty"`
	// The timeout period of the change process. Valid values: 1 to 1800. Default value: 600. Unit: seconds.
	Timeout *int32 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
}

func (s StartK8sApplicationRequest) String() string {
	return tea.Prettify(s)
}

func (s StartK8sApplicationRequest) GoString() string {
	return s.String()
}

func (s *StartK8sApplicationRequest) SetAppId(v string) *StartK8sApplicationRequest {
	s.AppId = &v
	return s
}

func (s *StartK8sApplicationRequest) SetReplicas(v int32) *StartK8sApplicationRequest {
	s.Replicas = &v
	return s
}

func (s *StartK8sApplicationRequest) SetTimeout(v int32) *StartK8sApplicationRequest {
	s.Timeout = &v
	return s
}

type StartK8sApplicationResponseBody struct {
	// The ID of the change process.
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s StartK8sApplicationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StartK8sApplicationResponseBody) GoString() string {
	return s.String()
}

func (s *StartK8sApplicationResponseBody) SetChangeOrderId(v string) *StartK8sApplicationResponseBody {
	s.ChangeOrderId = &v
	return s
}

func (s *StartK8sApplicationResponseBody) SetCode(v int32) *StartK8sApplicationResponseBody {
	s.Code = &v
	return s
}

func (s *StartK8sApplicationResponseBody) SetMessage(v string) *StartK8sApplicationResponseBody {
	s.Message = &v
	return s
}

func (s *StartK8sApplicationResponseBody) SetRequestId(v string) *StartK8sApplicationResponseBody {
	s.RequestId = &v
	return s
}

type StartK8sApplicationResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *StartK8sApplicationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s StartK8sApplicationResponse) String() string {
	return tea.Prettify(s)
}

func (s StartK8sApplicationResponse) GoString() string {
	return s.String()
}

func (s *StartK8sApplicationResponse) SetHeaders(v map[string]*string) *StartK8sApplicationResponse {
	s.Headers = v
	return s
}

func (s *StartK8sApplicationResponse) SetStatusCode(v int32) *StartK8sApplicationResponse {
	s.StatusCode = &v
	return s
}

func (s *StartK8sApplicationResponse) SetBody(v *StartK8sApplicationResponseBody) *StartK8sApplicationResponse {
	s.Body = v
	return s
}

type StopApplicationRequest struct {
	// The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the elastic compute container (ECC) that corresponds to the Elastic Compute Service (ECS) instance on which you want to stop the application. You can call the QueryApplicationStatus operation to query the ECC ID. For more information, see [QueryApplicationStatus](~~149394~~).
	//
	// *   If you want to stop the application on multiple ECS instances, separate the ECC IDs with commas (,).
	// *   If you leave this parameter empty, the application will be stopped on all ECS instances.
	EccInfo *string `json:"EccInfo,omitempty" xml:"EccInfo,omitempty"`
}

func (s StopApplicationRequest) String() string {
	return tea.Prettify(s)
}

func (s StopApplicationRequest) GoString() string {
	return s.String()
}

func (s *StopApplicationRequest) SetAppId(v string) *StopApplicationRequest {
	s.AppId = &v
	return s
}

func (s *StopApplicationRequest) SetEccInfo(v string) *StopApplicationRequest {
	s.EccInfo = &v
	return s
}

type StopApplicationResponseBody struct {
	// The ID of the change process. You can call the GetChangeOrderInfo operation to query the details about the change process. For more information, see [GetChangeOrderInfo](~~62072~~).
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s StopApplicationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StopApplicationResponseBody) GoString() string {
	return s.String()
}

func (s *StopApplicationResponseBody) SetChangeOrderId(v string) *StopApplicationResponseBody {
	s.ChangeOrderId = &v
	return s
}

func (s *StopApplicationResponseBody) SetCode(v int32) *StopApplicationResponseBody {
	s.Code = &v
	return s
}

func (s *StopApplicationResponseBody) SetMessage(v string) *StopApplicationResponseBody {
	s.Message = &v
	return s
}

func (s *StopApplicationResponseBody) SetRequestId(v string) *StopApplicationResponseBody {
	s.RequestId = &v
	return s
}

type StopApplicationResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *StopApplicationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s StopApplicationResponse) String() string {
	return tea.Prettify(s)
}

func (s StopApplicationResponse) GoString() string {
	return s.String()
}

func (s *StopApplicationResponse) SetHeaders(v map[string]*string) *StopApplicationResponse {
	s.Headers = v
	return s
}

func (s *StopApplicationResponse) SetStatusCode(v int32) *StopApplicationResponse {
	s.StatusCode = &v
	return s
}

func (s *StopApplicationResponse) SetBody(v *StopApplicationResponseBody) *StopApplicationResponse {
	s.Body = v
	return s
}

type StopK8sApplicationRequest struct {
	// The ID of the application. You can query the application ID by calling the ListApplication operation. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The timeout period of the change process. Unit: seconds.
	Timeout *int32 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
}

func (s StopK8sApplicationRequest) String() string {
	return tea.Prettify(s)
}

func (s StopK8sApplicationRequest) GoString() string {
	return s.String()
}

func (s *StopK8sApplicationRequest) SetAppId(v string) *StopK8sApplicationRequest {
	s.AppId = &v
	return s
}

func (s *StopK8sApplicationRequest) SetTimeout(v int32) *StopK8sApplicationRequest {
	s.Timeout = &v
	return s
}

type StopK8sApplicationResponseBody struct {
	// The ID of the change process.
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s StopK8sApplicationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StopK8sApplicationResponseBody) GoString() string {
	return s.String()
}

func (s *StopK8sApplicationResponseBody) SetChangeOrderId(v string) *StopK8sApplicationResponseBody {
	s.ChangeOrderId = &v
	return s
}

func (s *StopK8sApplicationResponseBody) SetCode(v int32) *StopK8sApplicationResponseBody {
	s.Code = &v
	return s
}

func (s *StopK8sApplicationResponseBody) SetMessage(v string) *StopK8sApplicationResponseBody {
	s.Message = &v
	return s
}

func (s *StopK8sApplicationResponseBody) SetRequestId(v string) *StopK8sApplicationResponseBody {
	s.RequestId = &v
	return s
}

type StopK8sApplicationResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *StopK8sApplicationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s StopK8sApplicationResponse) String() string {
	return tea.Prettify(s)
}

func (s StopK8sApplicationResponse) GoString() string {
	return s.String()
}

func (s *StopK8sApplicationResponse) SetHeaders(v map[string]*string) *StopK8sApplicationResponse {
	s.Headers = v
	return s
}

func (s *StopK8sApplicationResponse) SetStatusCode(v int32) *StopK8sApplicationResponse {
	s.StatusCode = &v
	return s
}

func (s *StopK8sApplicationResponse) SetBody(v *StopK8sApplicationResponseBody) *StopK8sApplicationResponse {
	s.Body = v
	return s
}

type SwitchAdvancedMonitoringRequest struct {
	// The ID of the application for which you want to query or configure the advanced application monitoring feature.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// Specifies whether to enable the advanced application monitoring feature. Valid values:
	//
	// *   true: enables the advanced application monitoring feature.
	// *   false: disables the advanced application monitoring feature.
	//
	// If you call this operation to query the status of the advanced application monitoring feature, you do not need to specify this parameter.
	EnableAdvancedMonitoring *bool `json:"EnableAdvancedMonitoring,omitempty" xml:"EnableAdvancedMonitoring,omitempty"`
}

func (s SwitchAdvancedMonitoringRequest) String() string {
	return tea.Prettify(s)
}

func (s SwitchAdvancedMonitoringRequest) GoString() string {
	return s.String()
}

func (s *SwitchAdvancedMonitoringRequest) SetAppId(v string) *SwitchAdvancedMonitoringRequest {
	s.AppId = &v
	return s
}

func (s *SwitchAdvancedMonitoringRequest) SetEnableAdvancedMonitoring(v bool) *SwitchAdvancedMonitoringRequest {
	s.EnableAdvancedMonitoring = &v
	return s
}

type SwitchAdvancedMonitoringResponseBody struct {
	// Indicates whether the advanced application monitoring feature is enabled. Valid values:
	//
	// *   true: The advanced application monitoring feature is enabled.
	// *   false: The advanced application monitoring feature is disabled.
	AdvancedMonitoringEnabled *bool `json:"AdvancedMonitoringEnabled,omitempty" xml:"AdvancedMonitoringEnabled,omitempty"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SwitchAdvancedMonitoringResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SwitchAdvancedMonitoringResponseBody) GoString() string {
	return s.String()
}

func (s *SwitchAdvancedMonitoringResponseBody) SetAdvancedMonitoringEnabled(v bool) *SwitchAdvancedMonitoringResponseBody {
	s.AdvancedMonitoringEnabled = &v
	return s
}

func (s *SwitchAdvancedMonitoringResponseBody) SetCode(v int32) *SwitchAdvancedMonitoringResponseBody {
	s.Code = &v
	return s
}

func (s *SwitchAdvancedMonitoringResponseBody) SetMessage(v string) *SwitchAdvancedMonitoringResponseBody {
	s.Message = &v
	return s
}

func (s *SwitchAdvancedMonitoringResponseBody) SetRequestId(v string) *SwitchAdvancedMonitoringResponseBody {
	s.RequestId = &v
	return s
}

type SwitchAdvancedMonitoringResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SwitchAdvancedMonitoringResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SwitchAdvancedMonitoringResponse) String() string {
	return tea.Prettify(s)
}

func (s SwitchAdvancedMonitoringResponse) GoString() string {
	return s.String()
}

func (s *SwitchAdvancedMonitoringResponse) SetHeaders(v map[string]*string) *SwitchAdvancedMonitoringResponse {
	s.Headers = v
	return s
}

func (s *SwitchAdvancedMonitoringResponse) SetStatusCode(v int32) *SwitchAdvancedMonitoringResponse {
	s.StatusCode = &v
	return s
}

func (s *SwitchAdvancedMonitoringResponse) SetBody(v *SwitchAdvancedMonitoringResponseBody) *SwitchAdvancedMonitoringResponse {
	s.Body = v
	return s
}

type SynchronizeResourceRequest struct {
	// The ID of the resource. This parameter is required only when you set the Type parameter to `ecs`. If you specify multiple IDs, separate them with commas (,). You can synchronize up to 50 resources at a time.
	ResourceIds *string `json:"ResourceIds,omitempty" xml:"ResourceIds,omitempty"`
	// The type of the resource to be synchronized. Valid values: `ecs, slb, vpc, ram, and all`. These values are case-sensitive.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s SynchronizeResourceRequest) String() string {
	return tea.Prettify(s)
}

func (s SynchronizeResourceRequest) GoString() string {
	return s.String()
}

func (s *SynchronizeResourceRequest) SetResourceIds(v string) *SynchronizeResourceRequest {
	s.ResourceIds = &v
	return s
}

func (s *SynchronizeResourceRequest) SetType(v string) *SynchronizeResourceRequest {
	s.Type = &v
	return s
}

type SynchronizeResourceResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned for the request.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the resources are synchronized. Valid values:
	//
	// *   **true**: The resources are synchronized.
	// *   **false**: The resources fail to be synchronized.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SynchronizeResourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SynchronizeResourceResponseBody) GoString() string {
	return s.String()
}

func (s *SynchronizeResourceResponseBody) SetCode(v int32) *SynchronizeResourceResponseBody {
	s.Code = &v
	return s
}

func (s *SynchronizeResourceResponseBody) SetData(v string) *SynchronizeResourceResponseBody {
	s.Data = &v
	return s
}

func (s *SynchronizeResourceResponseBody) SetMessage(v string) *SynchronizeResourceResponseBody {
	s.Message = &v
	return s
}

func (s *SynchronizeResourceResponseBody) SetRequestId(v string) *SynchronizeResourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *SynchronizeResourceResponseBody) SetSuccess(v bool) *SynchronizeResourceResponseBody {
	s.Success = &v
	return s
}

type SynchronizeResourceResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SynchronizeResourceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SynchronizeResourceResponse) String() string {
	return tea.Prettify(s)
}

func (s SynchronizeResourceResponse) GoString() string {
	return s.String()
}

func (s *SynchronizeResourceResponse) SetHeaders(v map[string]*string) *SynchronizeResourceResponse {
	s.Headers = v
	return s
}

func (s *SynchronizeResourceResponse) SetStatusCode(v int32) *SynchronizeResourceResponse {
	s.StatusCode = &v
	return s
}

func (s *SynchronizeResourceResponse) SetBody(v *SynchronizeResourceResponseBody) *SynchronizeResourceResponse {
	s.Body = v
	return s
}

type TagResourcesRequest struct {
	// The IDs of the resources. You can specify up to 20 IDs in the format of a JSON array.
	ResourceIds *string `json:"ResourceIds,omitempty" xml:"ResourceIds,omitempty"`
	// The region in which the resource resides.
	ResourceRegionId *string `json:"ResourceRegionId,omitempty" xml:"ResourceRegionId,omitempty"`
	// The type of the resource. Valid values:
	//
	// *   **application**: Enterprise Distributed Application Service (EDAS) application
	// *   **cluster**: EDAS cluster
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The key-value pairs. When you set this parameter, take note of the following limits:
	//
	// *   You can add up to 20 tags to a resource.
	// *   The tag key cannot start with **aliyun** or **acs:**. It cannot contain **http://** or **https://**.
	// *   The tag key or tag value can be up to 128 characters in length, and can contain letters, digits, hyphens (-), commas (,), asterisks (\*), forward slashes (/), question marks (?), and colons (:).
	// *   Set this parameter to a JSON array.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s TagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequest) GoString() string {
	return s.String()
}

func (s *TagResourcesRequest) SetResourceIds(v string) *TagResourcesRequest {
	s.ResourceIds = &v
	return s
}

func (s *TagResourcesRequest) SetResourceRegionId(v string) *TagResourcesRequest {
	s.ResourceRegionId = &v
	return s
}

func (s *TagResourcesRequest) SetResourceType(v string) *TagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *TagResourcesRequest) SetTags(v string) *TagResourcesRequest {
	s.Tags = &v
	return s
}

type TagResourcesResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s TagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *TagResourcesResponseBody) SetCode(v int32) *TagResourcesResponseBody {
	s.Code = &v
	return s
}

func (s *TagResourcesResponseBody) SetMessage(v string) *TagResourcesResponseBody {
	s.Message = &v
	return s
}

func (s *TagResourcesResponseBody) SetRequestId(v string) *TagResourcesResponseBody {
	s.RequestId = &v
	return s
}

type TagResourcesResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *TagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s TagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponse) GoString() string {
	return s.String()
}

func (s *TagResourcesResponse) SetHeaders(v map[string]*string) *TagResourcesResponse {
	s.Headers = v
	return s
}

func (s *TagResourcesResponse) SetStatusCode(v int32) *TagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *TagResourcesResponse) SetBody(v *TagResourcesResponseBody) *TagResourcesResponse {
	s.Body = v
	return s
}

type TransformClusterMemberRequest struct {
	// The ID of the instance that you want to import or migrate. Separate multiple IDs with commas (,).
	//
	// *   An instance may not belong to a cluster, but an instance can belong to only one cluster at most.
	// *   The ECS instances and the destination cluster must be in the same virtual private cloud (VPC).
	InstanceIds *string `json:"InstanceIds,omitempty" xml:"InstanceIds,omitempty"`
	// The logon password of the ECS instance that you want to import or migrate to the cluster.
	Password *string `json:"Password,omitempty" xml:"Password,omitempty"`
	// The ID of the destination cluster.
	TargetClusterId *string `json:"TargetClusterId,omitempty" xml:"TargetClusterId,omitempty"`
}

func (s TransformClusterMemberRequest) String() string {
	return tea.Prettify(s)
}

func (s TransformClusterMemberRequest) GoString() string {
	return s.String()
}

func (s *TransformClusterMemberRequest) SetInstanceIds(v string) *TransformClusterMemberRequest {
	s.InstanceIds = &v
	return s
}

func (s *TransformClusterMemberRequest) SetPassword(v string) *TransformClusterMemberRequest {
	s.Password = &v
	return s
}

func (s *TransformClusterMemberRequest) SetTargetClusterId(v string) *TransformClusterMemberRequest {
	s.TargetClusterId = &v
	return s
}

type TransformClusterMemberResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// `Transform submit success!` is returned if the request is successful.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s TransformClusterMemberResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TransformClusterMemberResponseBody) GoString() string {
	return s.String()
}

func (s *TransformClusterMemberResponseBody) SetCode(v int32) *TransformClusterMemberResponseBody {
	s.Code = &v
	return s
}

func (s *TransformClusterMemberResponseBody) SetData(v string) *TransformClusterMemberResponseBody {
	s.Data = &v
	return s
}

func (s *TransformClusterMemberResponseBody) SetMessage(v string) *TransformClusterMemberResponseBody {
	s.Message = &v
	return s
}

func (s *TransformClusterMemberResponseBody) SetRequestId(v string) *TransformClusterMemberResponseBody {
	s.RequestId = &v
	return s
}

type TransformClusterMemberResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *TransformClusterMemberResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s TransformClusterMemberResponse) String() string {
	return tea.Prettify(s)
}

func (s TransformClusterMemberResponse) GoString() string {
	return s.String()
}

func (s *TransformClusterMemberResponse) SetHeaders(v map[string]*string) *TransformClusterMemberResponse {
	s.Headers = v
	return s
}

func (s *TransformClusterMemberResponse) SetStatusCode(v int32) *TransformClusterMemberResponse {
	s.StatusCode = &v
	return s
}

func (s *TransformClusterMemberResponse) SetBody(v *TransformClusterMemberResponseBody) *TransformClusterMemberResponse {
	s.Body = v
	return s
}

type UnbindK8sSlbRequest struct {
	// The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the cluster. You can call the GetK8sCluster operation to query the cluster ID. For more information, see [GetK8sCluster](~~181437~~).
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the SLB instance.
	SlbName *string `json:"SlbName,omitempty" xml:"SlbName,omitempty"`
	// The type of the SLB instance. Valid values:
	//
	// *   **internet**: Internet-facing SLB instance
	// *   **intranet**: internal-facing SLB instance
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UnbindK8sSlbRequest) String() string {
	return tea.Prettify(s)
}

func (s UnbindK8sSlbRequest) GoString() string {
	return s.String()
}

func (s *UnbindK8sSlbRequest) SetAppId(v string) *UnbindK8sSlbRequest {
	s.AppId = &v
	return s
}

func (s *UnbindK8sSlbRequest) SetClusterId(v string) *UnbindK8sSlbRequest {
	s.ClusterId = &v
	return s
}

func (s *UnbindK8sSlbRequest) SetSlbName(v string) *UnbindK8sSlbRequest {
	s.SlbName = &v
	return s
}

func (s *UnbindK8sSlbRequest) SetType(v string) *UnbindK8sSlbRequest {
	s.Type = &v
	return s
}

type UnbindK8sSlbResponseBody struct {
	// The ID of the change process.
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UnbindK8sSlbResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UnbindK8sSlbResponseBody) GoString() string {
	return s.String()
}

func (s *UnbindK8sSlbResponseBody) SetChangeOrderId(v string) *UnbindK8sSlbResponseBody {
	s.ChangeOrderId = &v
	return s
}

func (s *UnbindK8sSlbResponseBody) SetCode(v int32) *UnbindK8sSlbResponseBody {
	s.Code = &v
	return s
}

func (s *UnbindK8sSlbResponseBody) SetMessage(v string) *UnbindK8sSlbResponseBody {
	s.Message = &v
	return s
}

func (s *UnbindK8sSlbResponseBody) SetRequestId(v string) *UnbindK8sSlbResponseBody {
	s.RequestId = &v
	return s
}

type UnbindK8sSlbResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UnbindK8sSlbResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UnbindK8sSlbResponse) String() string {
	return tea.Prettify(s)
}

func (s UnbindK8sSlbResponse) GoString() string {
	return s.String()
}

func (s *UnbindK8sSlbResponse) SetHeaders(v map[string]*string) *UnbindK8sSlbResponse {
	s.Headers = v
	return s
}

func (s *UnbindK8sSlbResponse) SetStatusCode(v int32) *UnbindK8sSlbResponse {
	s.StatusCode = &v
	return s
}

func (s *UnbindK8sSlbResponse) SetBody(v *UnbindK8sSlbResponseBody) *UnbindK8sSlbResponse {
	s.Body = v
	return s
}

type UnbindSlbRequest struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// Specifies whether to remove the configured listeners. Valid values:
	//
	// *   true: removes the configured listeners.
	// *   false: does not remove the configured listeners.
	DeleteListener *string `json:"DeleteListener,omitempty" xml:"DeleteListener,omitempty"`
	// The ID of the SLB instance.
	SlbId *string `json:"SlbId,omitempty" xml:"SlbId,omitempty"`
	// The network type of the SLB instance. Valid values:
	//
	// *   **internet**: Internet-facing SLB instance
	// *   **intranet**: internal-facing SLB instance
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UnbindSlbRequest) String() string {
	return tea.Prettify(s)
}

func (s UnbindSlbRequest) GoString() string {
	return s.String()
}

func (s *UnbindSlbRequest) SetAppId(v string) *UnbindSlbRequest {
	s.AppId = &v
	return s
}

func (s *UnbindSlbRequest) SetDeleteListener(v string) *UnbindSlbRequest {
	s.DeleteListener = &v
	return s
}

func (s *UnbindSlbRequest) SetSlbId(v string) *UnbindSlbRequest {
	s.SlbId = &v
	return s
}

func (s *UnbindSlbRequest) SetType(v string) *UnbindSlbRequest {
	s.Type = &v
	return s
}

type UnbindSlbResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// This parameter is left empty. It has no meaning.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UnbindSlbResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UnbindSlbResponseBody) GoString() string {
	return s.String()
}

func (s *UnbindSlbResponseBody) SetCode(v int32) *UnbindSlbResponseBody {
	s.Code = &v
	return s
}

func (s *UnbindSlbResponseBody) SetData(v string) *UnbindSlbResponseBody {
	s.Data = &v
	return s
}

func (s *UnbindSlbResponseBody) SetMessage(v string) *UnbindSlbResponseBody {
	s.Message = &v
	return s
}

func (s *UnbindSlbResponseBody) SetRequestId(v string) *UnbindSlbResponseBody {
	s.RequestId = &v
	return s
}

type UnbindSlbResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UnbindSlbResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UnbindSlbResponse) String() string {
	return tea.Prettify(s)
}

func (s UnbindSlbResponse) GoString() string {
	return s.String()
}

func (s *UnbindSlbResponse) SetHeaders(v map[string]*string) *UnbindSlbResponse {
	s.Headers = v
	return s
}

func (s *UnbindSlbResponse) SetStatusCode(v int32) *UnbindSlbResponse {
	s.StatusCode = &v
	return s
}

func (s *UnbindSlbResponse) SetBody(v *UnbindSlbResponseBody) *UnbindSlbResponse {
	s.Body = v
	return s
}

type UntagResourcesRequest struct {
	// Specifies whether to remove all existing tags from the specified resources. Default value: false. Valid values:
	//
	// *   **true**: removes all existing tags from the specified resources.
	// *   **false**: does not remove all existing tags from the specified resources.
	//
	// > All existing tags of a resource are removed only if the **tagKeys** parameter is left empty and the **DeleteAll** parameter is set to true.
	DeleteAll *bool `json:"DeleteAll,omitempty" xml:"DeleteAll,omitempty"`
	// The IDs of the resources from which you want to remove tags. You can specify up to 20 IDs.
	ResourceIds *string `json:"ResourceIds,omitempty" xml:"ResourceIds,omitempty"`
	// The region in which the resource resides.
	ResourceRegionId *string `json:"ResourceRegionId,omitempty" xml:"ResourceRegionId,omitempty"`
	// The type of the resource. Valid values:
	//
	// *   **application**: Enterprise Distributed Application Service (EDAS) application
	// *   **cluster**: EDAS cluster
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tags that you want to remove. You can specify up to 20 tags. Set this parameter to a JSON array.
	TagKeys *string `json:"TagKeys,omitempty" xml:"TagKeys,omitempty"`
}

func (s UntagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesRequest) GoString() string {
	return s.String()
}

func (s *UntagResourcesRequest) SetDeleteAll(v bool) *UntagResourcesRequest {
	s.DeleteAll = &v
	return s
}

func (s *UntagResourcesRequest) SetResourceIds(v string) *UntagResourcesRequest {
	s.ResourceIds = &v
	return s
}

func (s *UntagResourcesRequest) SetResourceRegionId(v string) *UntagResourcesRequest {
	s.ResourceRegionId = &v
	return s
}

func (s *UntagResourcesRequest) SetResourceType(v string) *UntagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *UntagResourcesRequest) SetTagKeys(v string) *UntagResourcesRequest {
	s.TagKeys = &v
	return s
}

type UntagResourcesResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UntagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponseBody) SetCode(v int32) *UntagResourcesResponseBody {
	s.Code = &v
	return s
}

func (s *UntagResourcesResponseBody) SetMessage(v string) *UntagResourcesResponseBody {
	s.Message = &v
	return s
}

func (s *UntagResourcesResponseBody) SetRequestId(v string) *UntagResourcesResponseBody {
	s.RequestId = &v
	return s
}

type UntagResourcesResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UntagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UntagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponse) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponse) SetHeaders(v map[string]*string) *UntagResourcesResponse {
	s.Headers = v
	return s
}

func (s *UntagResourcesResponse) SetStatusCode(v int32) *UntagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *UntagResourcesResponse) SetBody(v *UntagResourcesResponseBody) *UntagResourcesResponse {
	s.Body = v
	return s
}

type UpdateAccountInfoRequest struct {
	// The email address of the account.
	Email *string `json:"Email,omitempty" xml:"Email,omitempty"`
	// The name of the account.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The contact information of the account.
	Telephone *string `json:"Telephone,omitempty" xml:"Telephone,omitempty"`
}

func (s UpdateAccountInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAccountInfoRequest) GoString() string {
	return s.String()
}

func (s *UpdateAccountInfoRequest) SetEmail(v string) *UpdateAccountInfoRequest {
	s.Email = &v
	return s
}

func (s *UpdateAccountInfoRequest) SetName(v string) *UpdateAccountInfoRequest {
	s.Name = &v
	return s
}

func (s *UpdateAccountInfoRequest) SetTelephone(v string) *UpdateAccountInfoRequest {
	s.Telephone = &v
	return s
}

type UpdateAccountInfoResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateAccountInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateAccountInfoResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateAccountInfoResponseBody) SetCode(v int32) *UpdateAccountInfoResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateAccountInfoResponseBody) SetMessage(v string) *UpdateAccountInfoResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateAccountInfoResponseBody) SetRequestId(v string) *UpdateAccountInfoResponseBody {
	s.RequestId = &v
	return s
}

type UpdateAccountInfoResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateAccountInfoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateAccountInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAccountInfoResponse) GoString() string {
	return s.String()
}

func (s *UpdateAccountInfoResponse) SetHeaders(v map[string]*string) *UpdateAccountInfoResponse {
	s.Headers = v
	return s
}

func (s *UpdateAccountInfoResponse) SetStatusCode(v int32) *UpdateAccountInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateAccountInfoResponse) SetBody(v *UpdateAccountInfoResponseBody) *UpdateAccountInfoResponse {
	s.Body = v
	return s
}

type UpdateApplicationBaseInfoRequest struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application. The name must start with a letter, and can contain letters, digits, underscores (\_), and hyphens (-). The name can be up to 36 characters in length.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The description of the application. The description can be up to 256 characters in length.
	Desc *string `json:"Desc,omitempty" xml:"Desc,omitempty"`
	// The owner of the application. The value can be up to 127 characters in length.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
}

func (s UpdateApplicationBaseInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateApplicationBaseInfoRequest) GoString() string {
	return s.String()
}

func (s *UpdateApplicationBaseInfoRequest) SetAppId(v string) *UpdateApplicationBaseInfoRequest {
	s.AppId = &v
	return s
}

func (s *UpdateApplicationBaseInfoRequest) SetAppName(v string) *UpdateApplicationBaseInfoRequest {
	s.AppName = &v
	return s
}

func (s *UpdateApplicationBaseInfoRequest) SetDesc(v string) *UpdateApplicationBaseInfoRequest {
	s.Desc = &v
	return s
}

func (s *UpdateApplicationBaseInfoRequest) SetOwner(v string) *UpdateApplicationBaseInfoRequest {
	s.Owner = &v
	return s
}

type UpdateApplicationBaseInfoResponseBody struct {
	// The applications that you want to modify.
	Applcation *UpdateApplicationBaseInfoResponseBodyApplcation `json:"Applcation,omitempty" xml:"Applcation,omitempty" type:"Struct"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateApplicationBaseInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateApplicationBaseInfoResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateApplicationBaseInfoResponseBody) SetApplcation(v *UpdateApplicationBaseInfoResponseBodyApplcation) *UpdateApplicationBaseInfoResponseBody {
	s.Applcation = v
	return s
}

func (s *UpdateApplicationBaseInfoResponseBody) SetCode(v int32) *UpdateApplicationBaseInfoResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateApplicationBaseInfoResponseBody) SetMessage(v string) *UpdateApplicationBaseInfoResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateApplicationBaseInfoResponseBody) SetRequestId(v string) *UpdateApplicationBaseInfoResponseBody {
	s.RequestId = &v
	return s
}

type UpdateApplicationBaseInfoResponseBodyApplcation struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The deployment type of the application. Valid values:
	//
	// *   War: The application is deployed by using a WAR package.
	// *   FatJar: The application is deployed by using a JAR package.
	// *   Image: The application is deployed by using an image.
	// *   If this parameter is empty, the application is not deployed.
	ApplicationType *string `json:"ApplicationType,omitempty" xml:"ApplicationType,omitempty"`
	// The build package number of Enterprise Distributed Application Service (EDAS) Container.
	BuildPackageId *int64 `json:"BuildPackageId,omitempty" xml:"BuildPackageId,omitempty"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The type of the cluster. Valid values:
	//
	// *   0: normal Docker cluster
	// *   1: Swarm cluster
	// *   2: ECS cluster
	// *   3: self-managed Kubernetes cluster in EDAS
	// *   4: cluster in which Pandora automatically registers applications
	// *   5: Container Service for Kubernetes (ACK) clusters
	ClusterType *int32 `json:"ClusterType,omitempty" xml:"ClusterType,omitempty"`
	// The number of CPU cores.
	Cpu *int32 `json:"Cpu,omitempty" xml:"Cpu,omitempty"`
	// The time when the application was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The description of the application.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether the application is a Docker application.
	Dockerize *bool `json:"Dockerize,omitempty" xml:"Dockerize,omitempty"`
	// The ID of the Internet-facing SLB instance.
	ExtSlbId *string `json:"ExtSlbId,omitempty" xml:"ExtSlbId,omitempty"`
	// The IP address of the Internet-facing Server Load Balancer (SLB) instance.
	ExtSlbIp *string `json:"ExtSlbIp,omitempty" xml:"ExtSlbIp,omitempty"`
	// The name of the Internet-facing SLB instance.
	ExtSlbName *string `json:"ExtSlbName,omitempty" xml:"ExtSlbName,omitempty"`
	// The health check URL.
	HealthCheckUrl *string `json:"HealthCheckUrl,omitempty" xml:"HealthCheckUrl,omitempty"`
	// The number of application instances.
	InstanceCount *int32 `json:"InstanceCount,omitempty" xml:"InstanceCount,omitempty"`
	// The size of memory configured for an application instance. Unit: MB.
	Memory *int32 `json:"Memory,omitempty" xml:"Memory,omitempty"`
	// The name of the application.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The owner of the application.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The port used by the application.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The number of running application instances.
	RunningInstanceCount *int32 `json:"RunningInstanceCount,omitempty" xml:"RunningInstanceCount,omitempty"`
	// The ID of the internal-facing SLB instance.
	SlbId *string `json:"SlbId,omitempty" xml:"SlbId,omitempty"`
	// The IP address of the internal-facing SLB instance.
	SlbIp *string `json:"SlbIp,omitempty" xml:"SlbIp,omitempty"`
	// The name of the internal-facing SLB instance.
	SlbName *string `json:"SlbName,omitempty" xml:"SlbName,omitempty"`
	// The port used by the internal-facing SLB instance.
	SlbPort *int32 `json:"SlbPort,omitempty" xml:"SlbPort,omitempty"`
	// The ID of the Alibaba Cloud account.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s UpdateApplicationBaseInfoResponseBodyApplcation) String() string {
	return tea.Prettify(s)
}

func (s UpdateApplicationBaseInfoResponseBodyApplcation) GoString() string {
	return s.String()
}

func (s *UpdateApplicationBaseInfoResponseBodyApplcation) SetAppId(v string) *UpdateApplicationBaseInfoResponseBodyApplcation {
	s.AppId = &v
	return s
}

func (s *UpdateApplicationBaseInfoResponseBodyApplcation) SetApplicationType(v string) *UpdateApplicationBaseInfoResponseBodyApplcation {
	s.ApplicationType = &v
	return s
}

func (s *UpdateApplicationBaseInfoResponseBodyApplcation) SetBuildPackageId(v int64) *UpdateApplicationBaseInfoResponseBodyApplcation {
	s.BuildPackageId = &v
	return s
}

func (s *UpdateApplicationBaseInfoResponseBodyApplcation) SetClusterId(v string) *UpdateApplicationBaseInfoResponseBodyApplcation {
	s.ClusterId = &v
	return s
}

func (s *UpdateApplicationBaseInfoResponseBodyApplcation) SetClusterType(v int32) *UpdateApplicationBaseInfoResponseBodyApplcation {
	s.ClusterType = &v
	return s
}

func (s *UpdateApplicationBaseInfoResponseBodyApplcation) SetCpu(v int32) *UpdateApplicationBaseInfoResponseBodyApplcation {
	s.Cpu = &v
	return s
}

func (s *UpdateApplicationBaseInfoResponseBodyApplcation) SetCreateTime(v int64) *UpdateApplicationBaseInfoResponseBodyApplcation {
	s.CreateTime = &v
	return s
}

func (s *UpdateApplicationBaseInfoResponseBodyApplcation) SetDescription(v string) *UpdateApplicationBaseInfoResponseBodyApplcation {
	s.Description = &v
	return s
}

func (s *UpdateApplicationBaseInfoResponseBodyApplcation) SetDockerize(v bool) *UpdateApplicationBaseInfoResponseBodyApplcation {
	s.Dockerize = &v
	return s
}

func (s *UpdateApplicationBaseInfoResponseBodyApplcation) SetExtSlbId(v string) *UpdateApplicationBaseInfoResponseBodyApplcation {
	s.ExtSlbId = &v
	return s
}

func (s *UpdateApplicationBaseInfoResponseBodyApplcation) SetExtSlbIp(v string) *UpdateApplicationBaseInfoResponseBodyApplcation {
	s.ExtSlbIp = &v
	return s
}

func (s *UpdateApplicationBaseInfoResponseBodyApplcation) SetExtSlbName(v string) *UpdateApplicationBaseInfoResponseBodyApplcation {
	s.ExtSlbName = &v
	return s
}

func (s *UpdateApplicationBaseInfoResponseBodyApplcation) SetHealthCheckUrl(v string) *UpdateApplicationBaseInfoResponseBodyApplcation {
	s.HealthCheckUrl = &v
	return s
}

func (s *UpdateApplicationBaseInfoResponseBodyApplcation) SetInstanceCount(v int32) *UpdateApplicationBaseInfoResponseBodyApplcation {
	s.InstanceCount = &v
	return s
}

func (s *UpdateApplicationBaseInfoResponseBodyApplcation) SetMemory(v int32) *UpdateApplicationBaseInfoResponseBodyApplcation {
	s.Memory = &v
	return s
}

func (s *UpdateApplicationBaseInfoResponseBodyApplcation) SetName(v string) *UpdateApplicationBaseInfoResponseBodyApplcation {
	s.Name = &v
	return s
}

func (s *UpdateApplicationBaseInfoResponseBodyApplcation) SetOwner(v string) *UpdateApplicationBaseInfoResponseBodyApplcation {
	s.Owner = &v
	return s
}

func (s *UpdateApplicationBaseInfoResponseBodyApplcation) SetPort(v int32) *UpdateApplicationBaseInfoResponseBodyApplcation {
	s.Port = &v
	return s
}

func (s *UpdateApplicationBaseInfoResponseBodyApplcation) SetRegionId(v string) *UpdateApplicationBaseInfoResponseBodyApplcation {
	s.RegionId = &v
	return s
}

func (s *UpdateApplicationBaseInfoResponseBodyApplcation) SetRunningInstanceCount(v int32) *UpdateApplicationBaseInfoResponseBodyApplcation {
	s.RunningInstanceCount = &v
	return s
}

func (s *UpdateApplicationBaseInfoResponseBodyApplcation) SetSlbId(v string) *UpdateApplicationBaseInfoResponseBodyApplcation {
	s.SlbId = &v
	return s
}

func (s *UpdateApplicationBaseInfoResponseBodyApplcation) SetSlbIp(v string) *UpdateApplicationBaseInfoResponseBodyApplcation {
	s.SlbIp = &v
	return s
}

func (s *UpdateApplicationBaseInfoResponseBodyApplcation) SetSlbName(v string) *UpdateApplicationBaseInfoResponseBodyApplcation {
	s.SlbName = &v
	return s
}

func (s *UpdateApplicationBaseInfoResponseBodyApplcation) SetSlbPort(v int32) *UpdateApplicationBaseInfoResponseBodyApplcation {
	s.SlbPort = &v
	return s
}

func (s *UpdateApplicationBaseInfoResponseBodyApplcation) SetUserId(v string) *UpdateApplicationBaseInfoResponseBodyApplcation {
	s.UserId = &v
	return s
}

type UpdateApplicationBaseInfoResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateApplicationBaseInfoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateApplicationBaseInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateApplicationBaseInfoResponse) GoString() string {
	return s.String()
}

func (s *UpdateApplicationBaseInfoResponse) SetHeaders(v map[string]*string) *UpdateApplicationBaseInfoResponse {
	s.Headers = v
	return s
}

func (s *UpdateApplicationBaseInfoResponse) SetStatusCode(v int32) *UpdateApplicationBaseInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateApplicationBaseInfoResponse) SetBody(v *UpdateApplicationBaseInfoResponseBody) *UpdateApplicationBaseInfoResponse {
	s.Body = v
	return s
}

type UpdateApplicationScalingRuleRequest struct {
	// The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The behavior of the auto scaling. See the example for the data structure.
	ScalingBehaviour *string `json:"ScalingBehaviour,omitempty" xml:"ScalingBehaviour,omitempty"`
	// Specifies whether to enable the auto scaling policy. Valid values:
	//
	// *   **true**: enables the auto scaling policy.
	// *   **false**: disables the auto scaling policy.
	ScalingRuleEnable *bool `json:"ScalingRuleEnable,omitempty" xml:"ScalingRuleEnable,omitempty"`
	// This parameter is deprecated.
	ScalingRuleMetric *string `json:"ScalingRuleMetric,omitempty" xml:"ScalingRuleMetric,omitempty"`
	// The name of the auto scaling policy.
	ScalingRuleName *string `json:"ScalingRuleName,omitempty" xml:"ScalingRuleName,omitempty"`
	// This parameter is deprecated.
	ScalingRuleTimer *string `json:"ScalingRuleTimer,omitempty" xml:"ScalingRuleTimer,omitempty"`
	// The trigger policy for the auto scaling policy. Set this parameter in the JSON format by using the ScalingRuleTriggerDTO class. For more information, see Additional description of request parameters.
	ScalingRuleTrigger *string `json:"ScalingRuleTrigger,omitempty" xml:"ScalingRuleTrigger,omitempty"`
	// The type of the auto scaling policy.
	//
	// *   Set the value to trigger.
	ScalingRuleType *string `json:"ScalingRuleType,omitempty" xml:"ScalingRuleType,omitempty"`
}

func (s UpdateApplicationScalingRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateApplicationScalingRuleRequest) GoString() string {
	return s.String()
}

func (s *UpdateApplicationScalingRuleRequest) SetAppId(v string) *UpdateApplicationScalingRuleRequest {
	s.AppId = &v
	return s
}

func (s *UpdateApplicationScalingRuleRequest) SetScalingBehaviour(v string) *UpdateApplicationScalingRuleRequest {
	s.ScalingBehaviour = &v
	return s
}

func (s *UpdateApplicationScalingRuleRequest) SetScalingRuleEnable(v bool) *UpdateApplicationScalingRuleRequest {
	s.ScalingRuleEnable = &v
	return s
}

func (s *UpdateApplicationScalingRuleRequest) SetScalingRuleMetric(v string) *UpdateApplicationScalingRuleRequest {
	s.ScalingRuleMetric = &v
	return s
}

func (s *UpdateApplicationScalingRuleRequest) SetScalingRuleName(v string) *UpdateApplicationScalingRuleRequest {
	s.ScalingRuleName = &v
	return s
}

func (s *UpdateApplicationScalingRuleRequest) SetScalingRuleTimer(v string) *UpdateApplicationScalingRuleRequest {
	s.ScalingRuleTimer = &v
	return s
}

func (s *UpdateApplicationScalingRuleRequest) SetScalingRuleTrigger(v string) *UpdateApplicationScalingRuleRequest {
	s.ScalingRuleTrigger = &v
	return s
}

func (s *UpdateApplicationScalingRuleRequest) SetScalingRuleType(v string) *UpdateApplicationScalingRuleRequest {
	s.ScalingRuleType = &v
	return s
}

type UpdateApplicationScalingRuleResponseBody struct {
	// The information about the auto scaling policy.
	AppScalingRule *UpdateApplicationScalingRuleResponseBodyAppScalingRule `json:"AppScalingRule,omitempty" xml:"AppScalingRule,omitempty" type:"Struct"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateApplicationScalingRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateApplicationScalingRuleResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateApplicationScalingRuleResponseBody) SetAppScalingRule(v *UpdateApplicationScalingRuleResponseBodyAppScalingRule) *UpdateApplicationScalingRuleResponseBody {
	s.AppScalingRule = v
	return s
}

func (s *UpdateApplicationScalingRuleResponseBody) SetCode(v int32) *UpdateApplicationScalingRuleResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateApplicationScalingRuleResponseBody) SetMessage(v string) *UpdateApplicationScalingRuleResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateApplicationScalingRuleResponseBody) SetRequestId(v string) *UpdateApplicationScalingRuleResponseBody {
	s.RequestId = &v
	return s
}

type UpdateApplicationScalingRuleResponseBodyAppScalingRule struct {
	// The ID of the application to which the auto scaling policy belongs.
	AppId     *string                                                          `json:"AppId,omitempty" xml:"AppId,omitempty"`
	Behaviour *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour `json:"Behaviour,omitempty" xml:"Behaviour,omitempty" type:"Struct"`
	// The time when the auto scaling policy was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The time when the auto scaling policy was last disabled. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	LastDisableTime *int64 `json:"LastDisableTime,omitempty" xml:"LastDisableTime,omitempty"`
	// This parameter is deprecated.
	MaxReplicas *int32 `json:"MaxReplicas,omitempty" xml:"MaxReplicas,omitempty"`
	// This parameter is deprecated.
	Metric *UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetric `json:"Metric,omitempty" xml:"Metric,omitempty" type:"Struct"`
	// This parameter is deprecated.
	MinReplicas *int32 `json:"MinReplicas,omitempty" xml:"MinReplicas,omitempty"`
	// Indicates whether the auto scaling policy is enabled. Valid values:
	//
	// *   **true**: The auto scaling policy is enabled.
	// *   **false**: The auto scaling policy is disabled.
	ScaleRuleEnabled *bool `json:"ScaleRuleEnabled,omitempty" xml:"ScaleRuleEnabled,omitempty"`
	// The name of the auto scaling policy.
	ScaleRuleName *string `json:"ScaleRuleName,omitempty" xml:"ScaleRuleName,omitempty"`
	// The type of the auto scaling policy. The value is fixed to trigger.
	ScaleRuleType *string `json:"ScaleRuleType,omitempty" xml:"ScaleRuleType,omitempty"`
	// The configurations of the trigger.
	Trigger *UpdateApplicationScalingRuleResponseBodyAppScalingRuleTrigger `json:"Trigger,omitempty" xml:"Trigger,omitempty" type:"Struct"`
	// The time when the auto scaling policy was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s UpdateApplicationScalingRuleResponseBodyAppScalingRule) String() string {
	return tea.Prettify(s)
}

func (s UpdateApplicationScalingRuleResponseBodyAppScalingRule) GoString() string {
	return s.String()
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRule) SetAppId(v string) *UpdateApplicationScalingRuleResponseBodyAppScalingRule {
	s.AppId = &v
	return s
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRule) SetBehaviour(v *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour) *UpdateApplicationScalingRuleResponseBodyAppScalingRule {
	s.Behaviour = v
	return s
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRule) SetCreateTime(v int64) *UpdateApplicationScalingRuleResponseBodyAppScalingRule {
	s.CreateTime = &v
	return s
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRule) SetLastDisableTime(v int64) *UpdateApplicationScalingRuleResponseBodyAppScalingRule {
	s.LastDisableTime = &v
	return s
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRule) SetMaxReplicas(v int32) *UpdateApplicationScalingRuleResponseBodyAppScalingRule {
	s.MaxReplicas = &v
	return s
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRule) SetMetric(v *UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetric) *UpdateApplicationScalingRuleResponseBodyAppScalingRule {
	s.Metric = v
	return s
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRule) SetMinReplicas(v int32) *UpdateApplicationScalingRuleResponseBodyAppScalingRule {
	s.MinReplicas = &v
	return s
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRule) SetScaleRuleEnabled(v bool) *UpdateApplicationScalingRuleResponseBodyAppScalingRule {
	s.ScaleRuleEnabled = &v
	return s
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRule) SetScaleRuleName(v string) *UpdateApplicationScalingRuleResponseBodyAppScalingRule {
	s.ScaleRuleName = &v
	return s
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRule) SetScaleRuleType(v string) *UpdateApplicationScalingRuleResponseBodyAppScalingRule {
	s.ScaleRuleType = &v
	return s
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRule) SetTrigger(v *UpdateApplicationScalingRuleResponseBodyAppScalingRuleTrigger) *UpdateApplicationScalingRuleResponseBodyAppScalingRule {
	s.Trigger = v
	return s
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRule) SetUpdateTime(v int64) *UpdateApplicationScalingRuleResponseBodyAppScalingRule {
	s.UpdateTime = &v
	return s
}

type UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour struct {
	ScaleDown *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown `json:"ScaleDown,omitempty" xml:"ScaleDown,omitempty" type:"Struct"`
	ScaleUp   *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp   `json:"ScaleUp,omitempty" xml:"ScaleUp,omitempty" type:"Struct"`
}

func (s UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour) String() string {
	return tea.Prettify(s)
}

func (s UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour) GoString() string {
	return s.String()
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour) SetScaleDown(v *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown) *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour {
	s.ScaleDown = v
	return s
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour) SetScaleUp(v *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp) *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviour {
	s.ScaleUp = v
	return s
}

type UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown struct {
	// The configuration of the policy.
	Policies []*UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies `json:"Policies,omitempty" xml:"Policies,omitempty" type:"Repeated"`
	// The step size policy for the scale-in. Valid values: Max, Min, and Disable.
	SelectPolicy *string `json:"SelectPolicy,omitempty" xml:"SelectPolicy,omitempty"`
	// The cooldown time of the scale-in. Valid values: 0 to 3600. Unit: seconds. Default value: 300.
	StabilizationWindowSeconds *int32 `json:"StabilizationWindowSeconds,omitempty" xml:"StabilizationWindowSeconds,omitempty"`
}

func (s UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown) String() string {
	return tea.Prettify(s)
}

func (s UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown) GoString() string {
	return s.String()
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown) SetPolicies(v []*UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies) *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown {
	s.Policies = v
	return s
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown) SetSelectPolicy(v string) *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown {
	s.SelectPolicy = &v
	return s
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown) SetStabilizationWindowSeconds(v int32) *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDown {
	s.StabilizationWindowSeconds = &v
	return s
}

type UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies struct {
	// The cycle of the policy check. Valid values: 0 to 1800. Unit: seconds.
	PeriodSeconds *int32 `json:"PeriodSeconds,omitempty" xml:"PeriodSeconds,omitempty"`
	// The type of the policy. Valid values: Pods and Percent.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The policy value of auto scaling. Set the value to an integer greater than zero. If the policy type is Pods, the value of this parameter indicates the number of pods. If the policy type is Percent, the value of this parameter indicates a percentage, which can exceed 100%.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies) String() string {
	return tea.Prettify(s)
}

func (s UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies) GoString() string {
	return s.String()
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies) SetPeriodSeconds(v int32) *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies {
	s.PeriodSeconds = &v
	return s
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies) SetType(v string) *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies {
	s.Type = &v
	return s
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies) SetValue(v string) *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleDownPolicies {
	s.Value = &v
	return s
}

type UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp struct {
	// The configuration of the policy.
	Policies []*UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies `json:"Policies,omitempty" xml:"Policies,omitempty" type:"Repeated"`
	// The step size policy for the scale-out. Valid values: Max, Min, and Disable.
	SelectPolicy *string `json:"SelectPolicy,omitempty" xml:"SelectPolicy,omitempty"`
	// The cooldown time of the scale-out. Valid values: 0 to 3600. Unit: seconds. Default value: 0.
	StabilizationWindowSeconds *int32 `json:"StabilizationWindowSeconds,omitempty" xml:"StabilizationWindowSeconds,omitempty"`
}

func (s UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp) String() string {
	return tea.Prettify(s)
}

func (s UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp) GoString() string {
	return s.String()
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp) SetPolicies(v []*UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies) *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp {
	s.Policies = v
	return s
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp) SetSelectPolicy(v string) *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp {
	s.SelectPolicy = &v
	return s
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp) SetStabilizationWindowSeconds(v int32) *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUp {
	s.StabilizationWindowSeconds = &v
	return s
}

type UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies struct {
	// The cycle of the policy check. Valid values: 0 to 1800. Unit: seconds.
	PeriodSeconds *int32 `json:"PeriodSeconds,omitempty" xml:"PeriodSeconds,omitempty"`
	// The type of the policy. Valid values: Pods and Percent.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The policy value of auto scaling. Set the value to an integer greater than zero. If the policy type is Pods, the value of this parameter indicates the number of pods. If the policy type is Percent, the value of this parameter indicates a percentage, which can exceed 100%.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies) String() string {
	return tea.Prettify(s)
}

func (s UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies) GoString() string {
	return s.String()
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies) SetPeriodSeconds(v int32) *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies {
	s.PeriodSeconds = &v
	return s
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies) SetType(v string) *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies {
	s.Type = &v
	return s
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies) SetValue(v string) *UpdateApplicationScalingRuleResponseBodyAppScalingRuleBehaviourScaleUpPolicies {
	s.Value = &v
	return s
}

type UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetric struct {
	// This parameter is deprecated.
	MaxReplicas *int32 `json:"MaxReplicas,omitempty" xml:"MaxReplicas,omitempty"`
	// This parameter is deprecated.
	Metrics []*UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics `json:"Metrics,omitempty" xml:"Metrics,omitempty" type:"Repeated"`
	// This parameter is deprecated.
	MinReplicas *int32 `json:"MinReplicas,omitempty" xml:"MinReplicas,omitempty"`
}

func (s UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetric) String() string {
	return tea.Prettify(s)
}

func (s UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetric) GoString() string {
	return s.String()
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetric) SetMaxReplicas(v int32) *UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetric {
	s.MaxReplicas = &v
	return s
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetric) SetMetrics(v []*UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics) *UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetric {
	s.Metrics = v
	return s
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetric) SetMinReplicas(v int32) *UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetric {
	s.MinReplicas = &v
	return s
}

type UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics struct {
	// This parameter is deprecated.
	MetricTargetAverageUtilization *int32 `json:"MetricTargetAverageUtilization,omitempty" xml:"MetricTargetAverageUtilization,omitempty"`
	// This parameter is deprecated.
	MetricType *string `json:"MetricType,omitempty" xml:"MetricType,omitempty"`
}

func (s UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics) String() string {
	return tea.Prettify(s)
}

func (s UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics) GoString() string {
	return s.String()
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics) SetMetricTargetAverageUtilization(v int32) *UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics {
	s.MetricTargetAverageUtilization = &v
	return s
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics) SetMetricType(v string) *UpdateApplicationScalingRuleResponseBodyAppScalingRuleMetricMetrics {
	s.MetricType = &v
	return s
}

type UpdateApplicationScalingRuleResponseBodyAppScalingRuleTrigger struct {
	// The maximum number of replicas. The maximum value is 1000.
	MaxReplicas *int32 `json:"MaxReplicas,omitempty" xml:"MaxReplicas,omitempty"`
	// The minimum number of replicas. The minimum value is 0.
	MinReplicas *int32 `json:"MinReplicas,omitempty" xml:"MinReplicas,omitempty"`
	// The configurations of the trigger.
	Triggers []*UpdateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers `json:"Triggers,omitempty" xml:"Triggers,omitempty" type:"Repeated"`
}

func (s UpdateApplicationScalingRuleResponseBodyAppScalingRuleTrigger) String() string {
	return tea.Prettify(s)
}

func (s UpdateApplicationScalingRuleResponseBodyAppScalingRuleTrigger) GoString() string {
	return s.String()
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRuleTrigger) SetMaxReplicas(v int32) *UpdateApplicationScalingRuleResponseBodyAppScalingRuleTrigger {
	s.MaxReplicas = &v
	return s
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRuleTrigger) SetMinReplicas(v int32) *UpdateApplicationScalingRuleResponseBodyAppScalingRuleTrigger {
	s.MinReplicas = &v
	return s
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRuleTrigger) SetTriggers(v []*UpdateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers) *UpdateApplicationScalingRuleResponseBodyAppScalingRuleTrigger {
	s.Triggers = v
	return s
}

type UpdateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers struct {
	// The metadata of the trigger.
	MetaData *string `json:"MetaData,omitempty" xml:"MetaData,omitempty"`
	// The name of the trigger.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of the trigger. Valid values: cron and app_metric.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers) String() string {
	return tea.Prettify(s)
}

func (s UpdateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers) GoString() string {
	return s.String()
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers) SetMetaData(v string) *UpdateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers {
	s.MetaData = &v
	return s
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers) SetName(v string) *UpdateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers {
	s.Name = &v
	return s
}

func (s *UpdateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers) SetType(v string) *UpdateApplicationScalingRuleResponseBodyAppScalingRuleTriggerTriggers {
	s.Type = &v
	return s
}

type UpdateApplicationScalingRuleResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateApplicationScalingRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateApplicationScalingRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateApplicationScalingRuleResponse) GoString() string {
	return s.String()
}

func (s *UpdateApplicationScalingRuleResponse) SetHeaders(v map[string]*string) *UpdateApplicationScalingRuleResponse {
	s.Headers = v
	return s
}

func (s *UpdateApplicationScalingRuleResponse) SetStatusCode(v int32) *UpdateApplicationScalingRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateApplicationScalingRuleResponse) SetBody(v *UpdateApplicationScalingRuleResponseBody) *UpdateApplicationScalingRuleResponse {
	s.Body = v
	return s
}

type UpdateConfigTemplateRequest struct {
	// The content of the configuration template. The value must be in the format that is specified by the Format parameter.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The description of the configuration template. The description can be up to 255 characters in length.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The data format of the configuration template. Valid values:
	//
	// *   JSON: JSON format
	// *   XML: XML format
	// *   YAML: YAML format
	// *   Properties: .properties format
	// *   KeyValue: key-value pairs
	// *   Custom: custom format
	Format *string `json:"Format,omitempty" xml:"Format,omitempty"`
	// The ID of the configuration template.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the configuration template. The name can be up to 64 characters in length.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s UpdateConfigTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateConfigTemplateRequest) GoString() string {
	return s.String()
}

func (s *UpdateConfigTemplateRequest) SetContent(v string) *UpdateConfigTemplateRequest {
	s.Content = &v
	return s
}

func (s *UpdateConfigTemplateRequest) SetDescription(v string) *UpdateConfigTemplateRequest {
	s.Description = &v
	return s
}

func (s *UpdateConfigTemplateRequest) SetFormat(v string) *UpdateConfigTemplateRequest {
	s.Format = &v
	return s
}

func (s *UpdateConfigTemplateRequest) SetId(v int64) *UpdateConfigTemplateRequest {
	s.Id = &v
	return s
}

func (s *UpdateConfigTemplateRequest) SetName(v string) *UpdateConfigTemplateRequest {
	s.Name = &v
	return s
}

type UpdateConfigTemplateResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateConfigTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateConfigTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateConfigTemplateResponseBody) SetCode(v int32) *UpdateConfigTemplateResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateConfigTemplateResponseBody) SetMessage(v string) *UpdateConfigTemplateResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateConfigTemplateResponseBody) SetRequestId(v string) *UpdateConfigTemplateResponseBody {
	s.RequestId = &v
	return s
}

type UpdateConfigTemplateResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateConfigTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateConfigTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateConfigTemplateResponse) GoString() string {
	return s.String()
}

func (s *UpdateConfigTemplateResponse) SetHeaders(v map[string]*string) *UpdateConfigTemplateResponse {
	s.Headers = v
	return s
}

func (s *UpdateConfigTemplateResponse) SetStatusCode(v int32) *UpdateConfigTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateConfigTemplateResponse) SetBody(v *UpdateConfigTemplateResponseBody) *UpdateConfigTemplateResponse {
	s.Body = v
	return s
}

type UpdateContainerRequest struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The build package number of EDAS Container. You can obtain the build package number in the Build package number column in the EDAS Container release notes table. For more information, see [Release notes for EDAS Container](~~92614~~).
	BuildPackId *int32 `json:"BuildPackId,omitempty" xml:"BuildPackId,omitempty"`
}

func (s UpdateContainerRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateContainerRequest) GoString() string {
	return s.String()
}

func (s *UpdateContainerRequest) SetAppId(v string) *UpdateContainerRequest {
	s.AppId = &v
	return s
}

func (s *UpdateContainerRequest) SetBuildPackId(v int32) *UpdateContainerRequest {
	s.BuildPackId = &v
	return s
}

type UpdateContainerResponseBody struct {
	// The ID of the change process.
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateContainerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateContainerResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateContainerResponseBody) SetChangeOrderId(v string) *UpdateContainerResponseBody {
	s.ChangeOrderId = &v
	return s
}

func (s *UpdateContainerResponseBody) SetCode(v int32) *UpdateContainerResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateContainerResponseBody) SetMessage(v string) *UpdateContainerResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateContainerResponseBody) SetRequestId(v string) *UpdateContainerResponseBody {
	s.RequestId = &v
	return s
}

type UpdateContainerResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateContainerResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateContainerResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateContainerResponse) GoString() string {
	return s.String()
}

func (s *UpdateContainerResponse) SetHeaders(v map[string]*string) *UpdateContainerResponse {
	s.Headers = v
	return s
}

func (s *UpdateContainerResponse) SetStatusCode(v int32) *UpdateContainerResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateContainerResponse) SetBody(v *UpdateContainerResponseBody) *UpdateContainerResponse {
	s.Body = v
	return s
}

type UpdateContainerConfigurationRequest struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The context path of the Tomcat container. The context path can be an empty string, a null WAR package name, a root directory, or other custom non-empty strings. It can contain letters, digits, hyphens (-), and underscores (\_). Take note of the following items:
	//
	// *   If this parameter is not specified when you configure the application instance group, the configuration of the application is applied.
	// *   If this parameter is not specified when you configure the Tomcat container for an application, the root directory `/` is used.
	ContextPath *string `json:"ContextPath,omitempty" xml:"ContextPath,omitempty"`
	// The ID of the application instance group.
	//
	// *   If an ID is specified, this operation configures the Tomcat container for the specified application instance group.
	// *   If you set this parameter to "", this operation configures the Tomcat container for the application.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The application port number for the Tomcat container. Take note of the following items:
	//
	// *   If this parameter is not specified when you configure the application instance group, the configuration of the application is applied.
	// *   If this parameter is not specified when you configure the application, the default port 8080 is applied.
	HttpPort *int32 `json:"HttpPort,omitempty" xml:"HttpPort,omitempty"`
	// The maximum number of threads. Take note of the following items:
	//
	// *   If this parameter is not specified when you configure the application instance group, the configuration of the application is applied.
	// *   If this parameter is not specified when you configure the application, the default value 250 is applied.
	MaxThreads *int32 `json:"MaxThreads,omitempty" xml:"MaxThreads,omitempty"`
	// The uniform resource identifier (URI) encoding scheme. Valid values: ISO-8859-1, GBK, GB2312, and UTF-8. Take note of the following items:
	//
	// *   If this parameter is not specified when you configure the application instance group, the configuration of the application is applied.
	// *   If this parameter is not specified when you configure the application, the default URI encoding scheme in the Tomcat container is applied.
	URIEncoding *string `json:"URIEncoding,omitempty" xml:"URIEncoding,omitempty"`
	// Specifies whether to use the encoding scheme specified in the request body for URI query parameters. Take note of the following items:
	//
	// *   If this parameter is not specified when you configure the application instance group, the configuration of the application is applied.
	// *   If this parameter is not specified when you configure the application, the default value false is applied.
	UseBodyEncoding *bool `json:"UseBodyEncoding,omitempty" xml:"UseBodyEncoding,omitempty"`
}

func (s UpdateContainerConfigurationRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateContainerConfigurationRequest) GoString() string {
	return s.String()
}

func (s *UpdateContainerConfigurationRequest) SetAppId(v string) *UpdateContainerConfigurationRequest {
	s.AppId = &v
	return s
}

func (s *UpdateContainerConfigurationRequest) SetContextPath(v string) *UpdateContainerConfigurationRequest {
	s.ContextPath = &v
	return s
}

func (s *UpdateContainerConfigurationRequest) SetGroupId(v string) *UpdateContainerConfigurationRequest {
	s.GroupId = &v
	return s
}

func (s *UpdateContainerConfigurationRequest) SetHttpPort(v int32) *UpdateContainerConfigurationRequest {
	s.HttpPort = &v
	return s
}

func (s *UpdateContainerConfigurationRequest) SetMaxThreads(v int32) *UpdateContainerConfigurationRequest {
	s.MaxThreads = &v
	return s
}

func (s *UpdateContainerConfigurationRequest) SetURIEncoding(v string) *UpdateContainerConfigurationRequest {
	s.URIEncoding = &v
	return s
}

func (s *UpdateContainerConfigurationRequest) SetUseBodyEncoding(v bool) *UpdateContainerConfigurationRequest {
	s.UseBodyEncoding = &v
	return s
}

type UpdateContainerConfigurationResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The configuration of the Tomcat container.
	ContainerConfiguration *UpdateContainerConfigurationResponseBodyContainerConfiguration `json:"ContainerConfiguration,omitempty" xml:"ContainerConfiguration,omitempty" type:"Struct"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateContainerConfigurationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateContainerConfigurationResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateContainerConfigurationResponseBody) SetCode(v int32) *UpdateContainerConfigurationResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateContainerConfigurationResponseBody) SetContainerConfiguration(v *UpdateContainerConfigurationResponseBodyContainerConfiguration) *UpdateContainerConfigurationResponseBody {
	s.ContainerConfiguration = v
	return s
}

func (s *UpdateContainerConfigurationResponseBody) SetMessage(v string) *UpdateContainerConfigurationResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateContainerConfigurationResponseBody) SetRequestId(v string) *UpdateContainerConfigurationResponseBody {
	s.RequestId = &v
	return s
}

type UpdateContainerConfigurationResponseBodyContainerConfiguration struct {
	// The context path of the Tomcat container.
	ContextPath *string `json:"ContextPath,omitempty" xml:"ContextPath,omitempty"`
	// The application port number for the Tomcat container.
	HttpPort *int32 `json:"HttpPort,omitempty" xml:"HttpPort,omitempty"`
	// The maximum number of threads.
	MaxThreads *int32 `json:"MaxThreads,omitempty" xml:"MaxThreads,omitempty"`
	// The URI encoding scheme. Valid values: ISO-8859-1, GBK, GB2312, and UTF-8.
	URIEncoding *string `json:"URIEncoding,omitempty" xml:"URIEncoding,omitempty"`
	// Indicates whether useBodyEncodingForURI is enabled.
	UseBodyEncoding *bool `json:"UseBodyEncoding,omitempty" xml:"UseBodyEncoding,omitempty"`
}

func (s UpdateContainerConfigurationResponseBodyContainerConfiguration) String() string {
	return tea.Prettify(s)
}

func (s UpdateContainerConfigurationResponseBodyContainerConfiguration) GoString() string {
	return s.String()
}

func (s *UpdateContainerConfigurationResponseBodyContainerConfiguration) SetContextPath(v string) *UpdateContainerConfigurationResponseBodyContainerConfiguration {
	s.ContextPath = &v
	return s
}

func (s *UpdateContainerConfigurationResponseBodyContainerConfiguration) SetHttpPort(v int32) *UpdateContainerConfigurationResponseBodyContainerConfiguration {
	s.HttpPort = &v
	return s
}

func (s *UpdateContainerConfigurationResponseBodyContainerConfiguration) SetMaxThreads(v int32) *UpdateContainerConfigurationResponseBodyContainerConfiguration {
	s.MaxThreads = &v
	return s
}

func (s *UpdateContainerConfigurationResponseBodyContainerConfiguration) SetURIEncoding(v string) *UpdateContainerConfigurationResponseBodyContainerConfiguration {
	s.URIEncoding = &v
	return s
}

func (s *UpdateContainerConfigurationResponseBodyContainerConfiguration) SetUseBodyEncoding(v bool) *UpdateContainerConfigurationResponseBodyContainerConfiguration {
	s.UseBodyEncoding = &v
	return s
}

type UpdateContainerConfigurationResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateContainerConfigurationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateContainerConfigurationResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateContainerConfigurationResponse) GoString() string {
	return s.String()
}

func (s *UpdateContainerConfigurationResponse) SetHeaders(v map[string]*string) *UpdateContainerConfigurationResponse {
	s.Headers = v
	return s
}

func (s *UpdateContainerConfigurationResponse) SetStatusCode(v int32) *UpdateContainerConfigurationResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateContainerConfigurationResponse) SetBody(v *UpdateContainerConfigurationResponseBody) *UpdateContainerConfigurationResponse {
	s.Body = v
	return s
}

type UpdateHealthCheckUrlRequest struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The health check URL of the application. The URL must start with `http://`, and can be up to 255 characters in length. Example: `http://127.0.0.1:8080/_ehc.html`. If this parameter is not specified, the health check URL of the application is not changed.
	HcURL *string `json:"hcURL,omitempty" xml:"hcURL,omitempty"`
}

func (s UpdateHealthCheckUrlRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateHealthCheckUrlRequest) GoString() string {
	return s.String()
}

func (s *UpdateHealthCheckUrlRequest) SetAppId(v string) *UpdateHealthCheckUrlRequest {
	s.AppId = &v
	return s
}

func (s *UpdateHealthCheckUrlRequest) SetHcURL(v string) *UpdateHealthCheckUrlRequest {
	s.HcURL = &v
	return s
}

type UpdateHealthCheckUrlResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The health check URL.
	HealthCheckURL *string `json:"HealthCheckURL,omitempty" xml:"HealthCheckURL,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateHealthCheckUrlResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateHealthCheckUrlResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateHealthCheckUrlResponseBody) SetCode(v int32) *UpdateHealthCheckUrlResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateHealthCheckUrlResponseBody) SetHealthCheckURL(v string) *UpdateHealthCheckUrlResponseBody {
	s.HealthCheckURL = &v
	return s
}

func (s *UpdateHealthCheckUrlResponseBody) SetMessage(v string) *UpdateHealthCheckUrlResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateHealthCheckUrlResponseBody) SetRequestId(v string) *UpdateHealthCheckUrlResponseBody {
	s.RequestId = &v
	return s
}

type UpdateHealthCheckUrlResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateHealthCheckUrlResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateHealthCheckUrlResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateHealthCheckUrlResponse) GoString() string {
	return s.String()
}

func (s *UpdateHealthCheckUrlResponse) SetHeaders(v map[string]*string) *UpdateHealthCheckUrlResponse {
	s.Headers = v
	return s
}

func (s *UpdateHealthCheckUrlResponse) SetStatusCode(v int32) *UpdateHealthCheckUrlResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateHealthCheckUrlResponse) SetBody(v *UpdateHealthCheckUrlResponseBody) *UpdateHealthCheckUrlResponse {
	s.Body = v
	return s
}

type UpdateHookConfigurationRequest struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the application instance group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The script to mount. Set the value in the JSON format. Example: `[{"ignoreFail":false,"name":"postprepareInstanceEnvironmentOnScaleOut","script":"ls"},{"ignoreFail":true,"name":"postdeleteInstanceDataOnScaleIn","script":""},{"ignoreFail":true,"name":"prestartInstance","script":""},{"ignoreFail":true,"name":"poststartInstance","script":""},{"ignoreFail":true,"name":"prestopInstance","script":""},{"ignoreFail":true,"name":"poststopInstance","script":""}]`
	Hooks *string `json:"Hooks,omitempty" xml:"Hooks,omitempty"`
}

func (s UpdateHookConfigurationRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateHookConfigurationRequest) GoString() string {
	return s.String()
}

func (s *UpdateHookConfigurationRequest) SetAppId(v string) *UpdateHookConfigurationRequest {
	s.AppId = &v
	return s
}

func (s *UpdateHookConfigurationRequest) SetGroupId(v string) *UpdateHookConfigurationRequest {
	s.GroupId = &v
	return s
}

func (s *UpdateHookConfigurationRequest) SetHooks(v string) *UpdateHookConfigurationRequest {
	s.Hooks = &v
	return s
}

type UpdateHookConfigurationResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The information about the mounted script.
	HooksConfiguration []*UpdateHookConfigurationResponseBodyHooksConfiguration `json:"HooksConfiguration,omitempty" xml:"HooksConfiguration,omitempty" type:"Repeated"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateHookConfigurationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateHookConfigurationResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateHookConfigurationResponseBody) SetCode(v int32) *UpdateHookConfigurationResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateHookConfigurationResponseBody) SetHooksConfiguration(v []*UpdateHookConfigurationResponseBodyHooksConfiguration) *UpdateHookConfigurationResponseBody {
	s.HooksConfiguration = v
	return s
}

func (s *UpdateHookConfigurationResponseBody) SetMessage(v string) *UpdateHookConfigurationResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateHookConfigurationResponseBody) SetRequestId(v string) *UpdateHookConfigurationResponseBody {
	s.RequestId = &v
	return s
}

type UpdateHookConfigurationResponseBodyHooksConfiguration struct {
	// Indicates whether a mount failure is ignored. Valid values:
	//
	// *   **true**: A mount failure is ignored.
	// *   **false**: A mount failure is not ignored.
	IgnoreFail *bool `json:"IgnoreFail,omitempty" xml:"IgnoreFail,omitempty"`
	// The name of the mounted script.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The content of the mounted script.
	Script *string `json:"Script,omitempty" xml:"Script,omitempty"`
}

func (s UpdateHookConfigurationResponseBodyHooksConfiguration) String() string {
	return tea.Prettify(s)
}

func (s UpdateHookConfigurationResponseBodyHooksConfiguration) GoString() string {
	return s.String()
}

func (s *UpdateHookConfigurationResponseBodyHooksConfiguration) SetIgnoreFail(v bool) *UpdateHookConfigurationResponseBodyHooksConfiguration {
	s.IgnoreFail = &v
	return s
}

func (s *UpdateHookConfigurationResponseBodyHooksConfiguration) SetName(v string) *UpdateHookConfigurationResponseBodyHooksConfiguration {
	s.Name = &v
	return s
}

func (s *UpdateHookConfigurationResponseBodyHooksConfiguration) SetScript(v string) *UpdateHookConfigurationResponseBodyHooksConfiguration {
	s.Script = &v
	return s
}

type UpdateHookConfigurationResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateHookConfigurationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateHookConfigurationResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateHookConfigurationResponse) GoString() string {
	return s.String()
}

func (s *UpdateHookConfigurationResponse) SetHeaders(v map[string]*string) *UpdateHookConfigurationResponse {
	s.Headers = v
	return s
}

func (s *UpdateHookConfigurationResponse) SetStatusCode(v int32) *UpdateHookConfigurationResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateHookConfigurationResponse) SetBody(v *UpdateHookConfigurationResponseBody) *UpdateHookConfigurationResponse {
	s.Body = v
	return s
}

type UpdateJvmConfigurationRequest struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the instance group where the application is deployed. You can call the ListDeployGroup operation to query the group ID. For more information, see [ListDeployGroup](~~62077~~).
	//
	// >
	//
	// *   To configure the JVM parameters for an instance group, set this parameter to a specific ID.
	//
	// *   To configure the JVM parameters for an application, leave this parameter empty.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The maximum size of the heap memory. Unit: MB.
	//
	// >
	//
	// *   If this parameter is not specified in the group configuration, the value specified in the application configuration is used.
	//
	// *   If this parameter is not specified in the application configuration, the default value is used.
	MaxHeapSize *int32 `json:"MaxHeapSize,omitempty" xml:"MaxHeapSize,omitempty"`
	// The size of the permanent generation heap memory. Unit: MB.
	//
	// >
	//
	// *   If this parameter is not specified in the group configuration, the value specified in the application configuration is used.
	//
	// *   If this parameter is not specified in the application configuration, the default value is used.
	MaxPermSize *int32 `json:"MaxPermSize,omitempty" xml:"MaxPermSize,omitempty"`
	// The initial size of the heap memory. Unit: MB.
	//
	// >
	//
	// *   If this parameter is not specified in the group configuration, the value specified in the application configuration is used.
	//
	// *   If this parameter is not specified in the application configuration, the default value is used.
	MinHeapSize *int32 `json:"MinHeapSize,omitempty" xml:"MinHeapSize,omitempty"`
	// The custom JVM parameters.
	//
	// >
	//
	// *   If this parameter is not specified in the group configuration, the value specified in the application configuration is used.
	//
	// *   If this parameter is not specified in the application configuration, the default value is used.
	Options *string `json:"Options,omitempty" xml:"Options,omitempty"`
}

func (s UpdateJvmConfigurationRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateJvmConfigurationRequest) GoString() string {
	return s.String()
}

func (s *UpdateJvmConfigurationRequest) SetAppId(v string) *UpdateJvmConfigurationRequest {
	s.AppId = &v
	return s
}

func (s *UpdateJvmConfigurationRequest) SetGroupId(v string) *UpdateJvmConfigurationRequest {
	s.GroupId = &v
	return s
}

func (s *UpdateJvmConfigurationRequest) SetMaxHeapSize(v int32) *UpdateJvmConfigurationRequest {
	s.MaxHeapSize = &v
	return s
}

func (s *UpdateJvmConfigurationRequest) SetMaxPermSize(v int32) *UpdateJvmConfigurationRequest {
	s.MaxPermSize = &v
	return s
}

func (s *UpdateJvmConfigurationRequest) SetMinHeapSize(v int32) *UpdateJvmConfigurationRequest {
	s.MinHeapSize = &v
	return s
}

func (s *UpdateJvmConfigurationRequest) SetOptions(v string) *UpdateJvmConfigurationRequest {
	s.Options = &v
	return s
}

type UpdateJvmConfigurationResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The settings of the JVM parameters.
	JvmConfiguration *UpdateJvmConfigurationResponseBodyJvmConfiguration `json:"JvmConfiguration,omitempty" xml:"JvmConfiguration,omitempty" type:"Struct"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateJvmConfigurationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateJvmConfigurationResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateJvmConfigurationResponseBody) SetCode(v int32) *UpdateJvmConfigurationResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateJvmConfigurationResponseBody) SetJvmConfiguration(v *UpdateJvmConfigurationResponseBodyJvmConfiguration) *UpdateJvmConfigurationResponseBody {
	s.JvmConfiguration = v
	return s
}

func (s *UpdateJvmConfigurationResponseBody) SetMessage(v string) *UpdateJvmConfigurationResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateJvmConfigurationResponseBody) SetRequestId(v string) *UpdateJvmConfigurationResponseBody {
	s.RequestId = &v
	return s
}

type UpdateJvmConfigurationResponseBodyJvmConfiguration struct {
	// The maximum size of the heap memory. Unit: MB.
	MaxHeapSize *int32 `json:"MaxHeapSize,omitempty" xml:"MaxHeapSize,omitempty"`
	// The size of the permanent generation heap memory. Unit: MB.
	MaxPermSize *int32 `json:"MaxPermSize,omitempty" xml:"MaxPermSize,omitempty"`
	// The initial size of the heap memory. Unit: MB.
	MinHeapSize *int32 `json:"MinHeapSize,omitempty" xml:"MinHeapSize,omitempty"`
	// The optional parameters.
	Options *string `json:"Options,omitempty" xml:"Options,omitempty"`
}

func (s UpdateJvmConfigurationResponseBodyJvmConfiguration) String() string {
	return tea.Prettify(s)
}

func (s UpdateJvmConfigurationResponseBodyJvmConfiguration) GoString() string {
	return s.String()
}

func (s *UpdateJvmConfigurationResponseBodyJvmConfiguration) SetMaxHeapSize(v int32) *UpdateJvmConfigurationResponseBodyJvmConfiguration {
	s.MaxHeapSize = &v
	return s
}

func (s *UpdateJvmConfigurationResponseBodyJvmConfiguration) SetMaxPermSize(v int32) *UpdateJvmConfigurationResponseBodyJvmConfiguration {
	s.MaxPermSize = &v
	return s
}

func (s *UpdateJvmConfigurationResponseBodyJvmConfiguration) SetMinHeapSize(v int32) *UpdateJvmConfigurationResponseBodyJvmConfiguration {
	s.MinHeapSize = &v
	return s
}

func (s *UpdateJvmConfigurationResponseBodyJvmConfiguration) SetOptions(v string) *UpdateJvmConfigurationResponseBodyJvmConfiguration {
	s.Options = &v
	return s
}

type UpdateJvmConfigurationResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateJvmConfigurationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateJvmConfigurationResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateJvmConfigurationResponse) GoString() string {
	return s.String()
}

func (s *UpdateJvmConfigurationResponse) SetHeaders(v map[string]*string) *UpdateJvmConfigurationResponse {
	s.Headers = v
	return s
}

func (s *UpdateJvmConfigurationResponse) SetStatusCode(v int32) *UpdateJvmConfigurationResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateJvmConfigurationResponse) SetBody(v *UpdateJvmConfigurationResponseBody) *UpdateJvmConfigurationResponse {
	s.Body = v
	return s
}

type UpdateK8sApplicationBaseInfoRequest struct {
	// The ID of the application that you want to modify.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The description of the application. The description can be up to 256 characters in length.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The email address of the application owner.
	Email *string `json:"Email,omitempty" xml:"Email,omitempty"`
	// The owner of the application. The value can be up to 128 characters in length.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The phone number of the application owner.
	PhoneNumber *string `json:"PhoneNumber,omitempty" xml:"PhoneNumber,omitempty"`
}

func (s UpdateK8sApplicationBaseInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateK8sApplicationBaseInfoRequest) GoString() string {
	return s.String()
}

func (s *UpdateK8sApplicationBaseInfoRequest) SetAppId(v string) *UpdateK8sApplicationBaseInfoRequest {
	s.AppId = &v
	return s
}

func (s *UpdateK8sApplicationBaseInfoRequest) SetDescription(v string) *UpdateK8sApplicationBaseInfoRequest {
	s.Description = &v
	return s
}

func (s *UpdateK8sApplicationBaseInfoRequest) SetEmail(v string) *UpdateK8sApplicationBaseInfoRequest {
	s.Email = &v
	return s
}

func (s *UpdateK8sApplicationBaseInfoRequest) SetOwner(v string) *UpdateK8sApplicationBaseInfoRequest {
	s.Owner = &v
	return s
}

func (s *UpdateK8sApplicationBaseInfoRequest) SetPhoneNumber(v string) *UpdateK8sApplicationBaseInfoRequest {
	s.PhoneNumber = &v
	return s
}

type UpdateK8sApplicationBaseInfoResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The result of the modification.
	Result *string `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s UpdateK8sApplicationBaseInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateK8sApplicationBaseInfoResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateK8sApplicationBaseInfoResponseBody) SetCode(v int32) *UpdateK8sApplicationBaseInfoResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateK8sApplicationBaseInfoResponseBody) SetMessage(v string) *UpdateK8sApplicationBaseInfoResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateK8sApplicationBaseInfoResponseBody) SetRequestId(v string) *UpdateK8sApplicationBaseInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateK8sApplicationBaseInfoResponseBody) SetResult(v string) *UpdateK8sApplicationBaseInfoResponseBody {
	s.Result = &v
	return s
}

type UpdateK8sApplicationBaseInfoResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateK8sApplicationBaseInfoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateK8sApplicationBaseInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateK8sApplicationBaseInfoResponse) GoString() string {
	return s.String()
}

func (s *UpdateK8sApplicationBaseInfoResponse) SetHeaders(v map[string]*string) *UpdateK8sApplicationBaseInfoResponse {
	s.Headers = v
	return s
}

func (s *UpdateK8sApplicationBaseInfoResponse) SetStatusCode(v int32) *UpdateK8sApplicationBaseInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateK8sApplicationBaseInfoResponse) SetBody(v *UpdateK8sApplicationBaseInfoResponseBody) *UpdateK8sApplicationBaseInfoResponse {
	s.Body = v
	return s
}

type UpdateK8sApplicationConfigRequest struct {
	// The ID of the application. You can query the application ID by calling the ListApplication operation. For more information, see [ListApplication](~~423162~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the cluster. You can query the cluster ID by calling the ListCluster operation. For more information, see [ListCluster](~~411844~~).
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The maximum number of CPU cores allowed for each application instance when the application is running. The value 0 indicates that no limit is set on CPU cores.
	CpuLimit *string `json:"CpuLimit,omitempty" xml:"CpuLimit,omitempty"`
	// The number of CPU cores requested for each application instance when the application is running. Unit: cores. We recommend that you set this parameter. The value 0 indicates that no limit is set on CPU cores.
	//
	// > You must set this parameter together with the CpuLimit parameter. Make sure that the value of this parameter does not exceed that of the CpuLimit parameter.
	CpuRequest *string `json:"CpuRequest,omitempty" xml:"CpuRequest,omitempty"`
	// The maximum size of space required by ephemeral storage. Unit: GB. The value 0 indicates that no limit is set on the ephemeral storage space.
	EphemeralStorageLimit *string `json:"EphemeralStorageLimit,omitempty" xml:"EphemeralStorageLimit,omitempty"`
	// The minimum size of space required by ephemeral storage. Unit: GB. The value 0 indicates that no limit is set on the ephemeral storage space.
	//
	// > You must set this parameter together with the EphemeralStorageLimit parameter. Make sure that the value of this parameter does not exceed that of the EphemeralStorageLimit parameter.
	EphemeralStorageRequest *string `json:"EphemeralStorageRequest,omitempty" xml:"EphemeralStorageRequest,omitempty"`
	// The maximum number of CPU cores allowed. The value 0 indicates that no limit is set on CPU cores.
	McpuLimit *string `json:"McpuLimit,omitempty" xml:"McpuLimit,omitempty"`
	// The minimum number of CPU cores required. Unit: cores. The value 0 indicates that no limit is set on CPU cores.
	//
	// > You must set this parameter together with the CpuLimit parameter. Make sure that the value of this parameter does not exceed that of the CpuLimit parameter.
	McpuRequest *string `json:"McpuRequest,omitempty" xml:"McpuRequest,omitempty"`
	// The maximum size of memory allowed for each application instance when the application is running. Unit: MB. The value 0 indicates that no limit is set on the memory size.
	MemoryLimit *string `json:"MemoryLimit,omitempty" xml:"MemoryLimit,omitempty"`
	// The size of memory requested for each application instance when the application is running. Unit: MB. We recommend that you set this parameter. If you do not want to apply for a memory quota, set this parameter to 0.
	//
	// > You must set this parameter together with the MemoryLimit parameter. Make sure that the value of this parameter does not exceed that of the MemoryLimit parameter.
	MemoryRequest *string `json:"MemoryRequest,omitempty" xml:"MemoryRequest,omitempty"`
	// The timeout period of the change process. Valid values: 1 to 1800. Default value: 600. Unit: seconds.
	Timeout *int32 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
}

func (s UpdateK8sApplicationConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateK8sApplicationConfigRequest) GoString() string {
	return s.String()
}

func (s *UpdateK8sApplicationConfigRequest) SetAppId(v string) *UpdateK8sApplicationConfigRequest {
	s.AppId = &v
	return s
}

func (s *UpdateK8sApplicationConfigRequest) SetClusterId(v string) *UpdateK8sApplicationConfigRequest {
	s.ClusterId = &v
	return s
}

func (s *UpdateK8sApplicationConfigRequest) SetCpuLimit(v string) *UpdateK8sApplicationConfigRequest {
	s.CpuLimit = &v
	return s
}

func (s *UpdateK8sApplicationConfigRequest) SetCpuRequest(v string) *UpdateK8sApplicationConfigRequest {
	s.CpuRequest = &v
	return s
}

func (s *UpdateK8sApplicationConfigRequest) SetEphemeralStorageLimit(v string) *UpdateK8sApplicationConfigRequest {
	s.EphemeralStorageLimit = &v
	return s
}

func (s *UpdateK8sApplicationConfigRequest) SetEphemeralStorageRequest(v string) *UpdateK8sApplicationConfigRequest {
	s.EphemeralStorageRequest = &v
	return s
}

func (s *UpdateK8sApplicationConfigRequest) SetMcpuLimit(v string) *UpdateK8sApplicationConfigRequest {
	s.McpuLimit = &v
	return s
}

func (s *UpdateK8sApplicationConfigRequest) SetMcpuRequest(v string) *UpdateK8sApplicationConfigRequest {
	s.McpuRequest = &v
	return s
}

func (s *UpdateK8sApplicationConfigRequest) SetMemoryLimit(v string) *UpdateK8sApplicationConfigRequest {
	s.MemoryLimit = &v
	return s
}

func (s *UpdateK8sApplicationConfigRequest) SetMemoryRequest(v string) *UpdateK8sApplicationConfigRequest {
	s.MemoryRequest = &v
	return s
}

func (s *UpdateK8sApplicationConfigRequest) SetTimeout(v int32) *UpdateK8sApplicationConfigRequest {
	s.Timeout = &v
	return s
}

type UpdateK8sApplicationConfigResponseBody struct {
	// The ID of the change process.
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateK8sApplicationConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateK8sApplicationConfigResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateK8sApplicationConfigResponseBody) SetChangeOrderId(v string) *UpdateK8sApplicationConfigResponseBody {
	s.ChangeOrderId = &v
	return s
}

func (s *UpdateK8sApplicationConfigResponseBody) SetCode(v int32) *UpdateK8sApplicationConfigResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateK8sApplicationConfigResponseBody) SetMessage(v string) *UpdateK8sApplicationConfigResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateK8sApplicationConfigResponseBody) SetRequestId(v string) *UpdateK8sApplicationConfigResponseBody {
	s.RequestId = &v
	return s
}

type UpdateK8sApplicationConfigResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateK8sApplicationConfigResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateK8sApplicationConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateK8sApplicationConfigResponse) GoString() string {
	return s.String()
}

func (s *UpdateK8sApplicationConfigResponse) SetHeaders(v map[string]*string) *UpdateK8sApplicationConfigResponse {
	s.Headers = v
	return s
}

func (s *UpdateK8sApplicationConfigResponse) SetStatusCode(v int32) *UpdateK8sApplicationConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateK8sApplicationConfigResponse) SetBody(v *UpdateK8sApplicationConfigResponseBody) *UpdateK8sApplicationConfigResponse {
	s.Body = v
	return s
}

type UpdateK8sConfigMapRequest struct {
	// The ID of the Kubernetes cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The data of the ConfigMap. Set this parameter to a JSON string.
	Data map[string]interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	// The name of the ConfigMap. The name must start with a letter, and can contain digits, letters, and hyphens (-). It can be up to 63 characters in length.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace of the Kubernetes cluster.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
}

func (s UpdateK8sConfigMapRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateK8sConfigMapRequest) GoString() string {
	return s.String()
}

func (s *UpdateK8sConfigMapRequest) SetClusterId(v string) *UpdateK8sConfigMapRequest {
	s.ClusterId = &v
	return s
}

func (s *UpdateK8sConfigMapRequest) SetData(v map[string]interface{}) *UpdateK8sConfigMapRequest {
	s.Data = v
	return s
}

func (s *UpdateK8sConfigMapRequest) SetName(v string) *UpdateK8sConfigMapRequest {
	s.Name = &v
	return s
}

func (s *UpdateK8sConfigMapRequest) SetNamespace(v string) *UpdateK8sConfigMapRequest {
	s.Namespace = &v
	return s
}

type UpdateK8sConfigMapResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateK8sConfigMapResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateK8sConfigMapResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateK8sConfigMapResponseBody) SetCode(v int32) *UpdateK8sConfigMapResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateK8sConfigMapResponseBody) SetMessage(v string) *UpdateK8sConfigMapResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateK8sConfigMapResponseBody) SetRequestId(v string) *UpdateK8sConfigMapResponseBody {
	s.RequestId = &v
	return s
}

type UpdateK8sConfigMapResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateK8sConfigMapResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateK8sConfigMapResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateK8sConfigMapResponse) GoString() string {
	return s.String()
}

func (s *UpdateK8sConfigMapResponse) SetHeaders(v map[string]*string) *UpdateK8sConfigMapResponse {
	s.Headers = v
	return s
}

func (s *UpdateK8sConfigMapResponse) SetStatusCode(v int32) *UpdateK8sConfigMapResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateK8sConfigMapResponse) SetBody(v *UpdateK8sConfigMapResponseBody) *UpdateK8sConfigMapResponse {
	s.Body = v
	return s
}

type UpdateK8sIngressRuleRequest struct {
	// The annotations.
	Annotations *string `json:"Annotations,omitempty" xml:"Annotations,omitempty"`
	// The ID of the Kubernetes cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The routing rules of the Ingress. Set this parameter to a JSON string in the following format:
	//
	//     {
	//       "rules": [
	//         {
	//           "host": "abc.com",
	//           "secretName": "tls-secret",
	//           "paths": [
	//             {
	//               "path": "/path",
	//               "backend": {
	//                 "servicePort": 80,
	//                 "serviceName": "xxx"
	//               }
	//             }
	//           ]
	//         }
	//       ]
	//     }
	//
	// Parameter description:
	//
	// *   rules: the list of routing rules.
	// *   host: the domain name to be accessed.
	// *   secretName: the name of the Secret that stores the information about the Transport Layer Security (TLS) certificate. The certificate is required if you need to use the HTTPS protocol.
	// *   paths: the list of paths to be accessed.
	// *   path: the path to be accessed.
	// *   backend: the configuration of the backend service. You can specify a service that is created in the Enterprise Distributed Application Service (EDAS) console.
	// *   serviceName: the name of the backend service.
	// *   servicePort: the port of the backend service.
	IngressConf map[string]interface{} `json:"IngressConf,omitempty" xml:"IngressConf,omitempty"`
	// The labels.
	Labels *string `json:"Labels,omitempty" xml:"Labels,omitempty"`
	// The name of the Ingress. The name can contain lowercase letters, digits, and hyphens (-). It must start with a lowercase letter but cannot end with a hyphen (-). The name can be up to 63 characters in length.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace of the Kubernetes cluster.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
}

func (s UpdateK8sIngressRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateK8sIngressRuleRequest) GoString() string {
	return s.String()
}

func (s *UpdateK8sIngressRuleRequest) SetAnnotations(v string) *UpdateK8sIngressRuleRequest {
	s.Annotations = &v
	return s
}

func (s *UpdateK8sIngressRuleRequest) SetClusterId(v string) *UpdateK8sIngressRuleRequest {
	s.ClusterId = &v
	return s
}

func (s *UpdateK8sIngressRuleRequest) SetIngressConf(v map[string]interface{}) *UpdateK8sIngressRuleRequest {
	s.IngressConf = v
	return s
}

func (s *UpdateK8sIngressRuleRequest) SetLabels(v string) *UpdateK8sIngressRuleRequest {
	s.Labels = &v
	return s
}

func (s *UpdateK8sIngressRuleRequest) SetName(v string) *UpdateK8sIngressRuleRequest {
	s.Name = &v
	return s
}

func (s *UpdateK8sIngressRuleRequest) SetNamespace(v string) *UpdateK8sIngressRuleRequest {
	s.Namespace = &v
	return s
}

type UpdateK8sIngressRuleResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
}

func (s UpdateK8sIngressRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateK8sIngressRuleResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateK8sIngressRuleResponseBody) SetCode(v int32) *UpdateK8sIngressRuleResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateK8sIngressRuleResponseBody) SetMessage(v string) *UpdateK8sIngressRuleResponseBody {
	s.Message = &v
	return s
}

type UpdateK8sIngressRuleResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateK8sIngressRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateK8sIngressRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateK8sIngressRuleResponse) GoString() string {
	return s.String()
}

func (s *UpdateK8sIngressRuleResponse) SetHeaders(v map[string]*string) *UpdateK8sIngressRuleResponse {
	s.Headers = v
	return s
}

func (s *UpdateK8sIngressRuleResponse) SetStatusCode(v int32) *UpdateK8sIngressRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateK8sIngressRuleResponse) SetBody(v *UpdateK8sIngressRuleResponseBody) *UpdateK8sIngressRuleResponse {
	s.Body = v
	return s
}

type UpdateK8sResourceRequest struct {
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The ID of the namespace to which the Kubernetes resource belongs.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The description of the resource in the YAML format.
	ResourceContent *string `json:"ResourceContent,omitempty" xml:"ResourceContent,omitempty"`
}

func (s UpdateK8sResourceRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateK8sResourceRequest) GoString() string {
	return s.String()
}

func (s *UpdateK8sResourceRequest) SetClusterId(v string) *UpdateK8sResourceRequest {
	s.ClusterId = &v
	return s
}

func (s *UpdateK8sResourceRequest) SetNamespace(v string) *UpdateK8sResourceRequest {
	s.Namespace = &v
	return s
}

func (s *UpdateK8sResourceRequest) SetResourceContent(v string) *UpdateK8sResourceRequest {
	s.ResourceContent = &v
	return s
}

type UpdateK8sResourceResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateK8sResourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateK8sResourceResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateK8sResourceResponseBody) SetCode(v int32) *UpdateK8sResourceResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateK8sResourceResponseBody) SetMessage(v string) *UpdateK8sResourceResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateK8sResourceResponseBody) SetRequestId(v string) *UpdateK8sResourceResponseBody {
	s.RequestId = &v
	return s
}

type UpdateK8sResourceResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateK8sResourceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateK8sResourceResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateK8sResourceResponse) GoString() string {
	return s.String()
}

func (s *UpdateK8sResourceResponse) SetHeaders(v map[string]*string) *UpdateK8sResourceResponse {
	s.Headers = v
	return s
}

func (s *UpdateK8sResourceResponse) SetStatusCode(v int32) *UpdateK8sResourceResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateK8sResourceResponse) SetBody(v *UpdateK8sResourceResponseBody) *UpdateK8sResourceResponse {
	s.Body = v
	return s
}

type UpdateK8sSecretRequest struct {
	// Specifies whether the data has been encoded in Base64.
	Base64Encoded *bool `json:"Base64Encoded,omitempty" xml:"Base64Encoded,omitempty"`
	// The ID of the certificate.
	CertId *string `json:"CertId,omitempty" xml:"CertId,omitempty"`
	// The region ID of the certificate.
	CertRegionId *string `json:"CertRegionId,omitempty" xml:"CertRegionId,omitempty"`
	// The ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The data of the Secret. The value must be a JSON array that contains the following information:
	//
	// *   Key: Secret key
	// *   Value: Secret value
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The name of the Secret. The name must start with a letter, and can contain digits, letters, and hyphens (-). It can be up to 63 characters in length.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The namespace of the Kubernetes cluster.
	Namespace *string `json:"Namespace,omitempty" xml:"Namespace,omitempty"`
	// The type of the Secret. Valid values:
	//
	// *   Opaque: user-defined data type
	// *   kubernetes.io/tls: Transport Layer Security (TLS) certificate type
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdateK8sSecretRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateK8sSecretRequest) GoString() string {
	return s.String()
}

func (s *UpdateK8sSecretRequest) SetBase64Encoded(v bool) *UpdateK8sSecretRequest {
	s.Base64Encoded = &v
	return s
}

func (s *UpdateK8sSecretRequest) SetCertId(v string) *UpdateK8sSecretRequest {
	s.CertId = &v
	return s
}

func (s *UpdateK8sSecretRequest) SetCertRegionId(v string) *UpdateK8sSecretRequest {
	s.CertRegionId = &v
	return s
}

func (s *UpdateK8sSecretRequest) SetClusterId(v string) *UpdateK8sSecretRequest {
	s.ClusterId = &v
	return s
}

func (s *UpdateK8sSecretRequest) SetData(v string) *UpdateK8sSecretRequest {
	s.Data = &v
	return s
}

func (s *UpdateK8sSecretRequest) SetName(v string) *UpdateK8sSecretRequest {
	s.Name = &v
	return s
}

func (s *UpdateK8sSecretRequest) SetNamespace(v string) *UpdateK8sSecretRequest {
	s.Namespace = &v
	return s
}

func (s *UpdateK8sSecretRequest) SetType(v string) *UpdateK8sSecretRequest {
	s.Type = &v
	return s
}

type UpdateK8sSecretResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateK8sSecretResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateK8sSecretResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateK8sSecretResponseBody) SetCode(v int32) *UpdateK8sSecretResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateK8sSecretResponseBody) SetMessage(v string) *UpdateK8sSecretResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateK8sSecretResponseBody) SetRequestId(v string) *UpdateK8sSecretResponseBody {
	s.RequestId = &v
	return s
}

type UpdateK8sSecretResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateK8sSecretResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateK8sSecretResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateK8sSecretResponse) GoString() string {
	return s.String()
}

func (s *UpdateK8sSecretResponse) SetHeaders(v map[string]*string) *UpdateK8sSecretResponse {
	s.Headers = v
	return s
}

func (s *UpdateK8sSecretResponse) SetStatusCode(v int32) *UpdateK8sSecretResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateK8sSecretResponse) SetBody(v *UpdateK8sSecretResponseBody) *UpdateK8sSecretResponse {
	s.Body = v
	return s
}

type UpdateK8sServiceRequest struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The policy used for external traffic management. Valid values:
	//
	// *   Local: local mode
	// *   Cluster: cluster mode
	//
	// Default value: Local.
	ExternalTrafficPolicy *string `json:"ExternalTrafficPolicy,omitempty" xml:"ExternalTrafficPolicy,omitempty"`
	// The name of the service in a Kubernetes cluster.
	//
	// *   The name can contain lowercase letters, digits, and hyphens (-).
	// *   It must start with a letter and end with a letter or digit.
	// *   The name can be 2 to 32 characters in length.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The mappings between service ports. Set this parameter to a JSON array. The following parameters are included in the configurations:
	//
	// *   **protocol**: the protocol used by the service. Valid values: TCP and UDP. This parameter is required.
	// *   **port**: the frontend service port. Valid values: 1 to 65535. This parameter is required.
	// *   **targetPort**: the backend container port. Valid values: 1 to 65535. This parameter is required.
	//
	// Example: `[{"protocol": "TCP", "port": 80, "targetPort": 8080},{"protocol": "TCP", "port": 81, "targetPort": 8081}]`
	ServicePorts map[string]interface{} `json:"ServicePorts,omitempty" xml:"ServicePorts,omitempty"`
	// The type of the service in a Kubernetes cluster. Set the value to ClusterIP.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdateK8sServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateK8sServiceRequest) GoString() string {
	return s.String()
}

func (s *UpdateK8sServiceRequest) SetAppId(v string) *UpdateK8sServiceRequest {
	s.AppId = &v
	return s
}

func (s *UpdateK8sServiceRequest) SetExternalTrafficPolicy(v string) *UpdateK8sServiceRequest {
	s.ExternalTrafficPolicy = &v
	return s
}

func (s *UpdateK8sServiceRequest) SetName(v string) *UpdateK8sServiceRequest {
	s.Name = &v
	return s
}

func (s *UpdateK8sServiceRequest) SetServicePorts(v map[string]interface{}) *UpdateK8sServiceRequest {
	s.ServicePorts = v
	return s
}

func (s *UpdateK8sServiceRequest) SetType(v string) *UpdateK8sServiceRequest {
	s.Type = &v
	return s
}

type UpdateK8sServiceResponseBody struct {
	// The ID of the change process.
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateK8sServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateK8sServiceResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateK8sServiceResponseBody) SetChangeOrderId(v string) *UpdateK8sServiceResponseBody {
	s.ChangeOrderId = &v
	return s
}

func (s *UpdateK8sServiceResponseBody) SetCode(v int32) *UpdateK8sServiceResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateK8sServiceResponseBody) SetMessage(v string) *UpdateK8sServiceResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateK8sServiceResponseBody) SetRequestId(v string) *UpdateK8sServiceResponseBody {
	s.RequestId = &v
	return s
}

type UpdateK8sServiceResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateK8sServiceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateK8sServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateK8sServiceResponse) GoString() string {
	return s.String()
}

func (s *UpdateK8sServiceResponse) SetHeaders(v map[string]*string) *UpdateK8sServiceResponse {
	s.Headers = v
	return s
}

func (s *UpdateK8sServiceResponse) SetStatusCode(v int32) *UpdateK8sServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateK8sServiceResponse) SetBody(v *UpdateK8sServiceResponseBody) *UpdateK8sServiceResponse {
	s.Body = v
	return s
}

type UpdateK8sSlbRequest struct {
	// The ID of the application. You can query the application ID by calling the ListApplication operation. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the cluster. You can query the cluster ID by calling the GetK8sCluster operation. For more information, see [GetK8sCluster](~~181437~~).
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// Specifies whether to disable listener configuration overriding.
	//
	// *   true: disables listener configuration overriding.
	// *   false: enables listener configuration overriding.
	DisableForceOverride *bool `json:"DisableForceOverride,omitempty" xml:"DisableForceOverride,omitempty"`
	// The frontend port. Valid values: 1 to 65535.
	Port *string `json:"Port,omitempty" xml:"Port,omitempty"`
	// The scheduling algorithm for the SLB instance. If you do not specify this parameter, the default value rr is used. SLB supports the following scheduling algorithms: round-robin and weighted round-robin. Valid values:
	//
	// *   wrr: weighted round-robin scheduling. Backend servers that have higher weights receive more requests than those that have lower weights.
	// *   rr: round-robin scheduling. Requests are sequentially distributed to backend servers.
	Scheduler *string `json:"Scheduler,omitempty" xml:"Scheduler,omitempty"`
	// The information about the ports. This parameter is required if you want to configure multi-port mappings or use a protocol other than TCP. You must set this parameter to a JSON array. Example: \[{"targetPort":8080,"port":82,"loadBalancerProtocol":"TCP"},{"port":81,"certId":"1362469756373809\_16c185d6fa2\_1914500329\_-xxxxxxx","targetPort":8181,"lo adBalancerProtocol":"HTTPS"}]
	//
	// *   port: required. The frontend port. Valid values: 1 to 65535. Each port must be unique.
	// *   targetPort: required. The backend port. Valid values: 1 to 65535.
	// *   loadBalancerProtocol: required. Valid values: TCP and HTTPS. If the HTTP protocol is used, set this parameter to TCP.
	// *   certId: the ID of the certificate. This parameter is required if the HTTPS protocol is used. You can purchase an SLB instance in the SLB console.
	// *   Note: The ServicePortInfos parameter is specified to support multi-port mappings. If you want this parameter to take effect, make sure that you specify the AppId, ClusterId, Type, and SlbId parameters.
	ServicePortInfos *string `json:"ServicePortInfos,omitempty" xml:"ServicePortInfos,omitempty"`
	// The name of the SLB instance.
	SlbName *string `json:"SlbName,omitempty" xml:"SlbName,omitempty"`
	// The protocol used by the SLB instance. Set the value to TCP.
	SlbProtocol *string `json:"SlbProtocol,omitempty" xml:"SlbProtocol,omitempty"`
	// The specifications of the SLB instance.
	//
	// *   slb.s1.small
	// *   slb.s2.small
	// *   slb.s2.medium
	// *   slb.s3.small
	// *   slb.s3.medium
	// *   slb.s3.large
	//
	// If you do not specify this parameter, the default value slb.s1.small is used.
	Specification *string `json:"Specification,omitempty" xml:"Specification,omitempty"`
	// The backend port, which is also the service port of the application. Valid values: 1 to 65535.
	TargetPort *string `json:"TargetPort,omitempty" xml:"TargetPort,omitempty"`
	// The type of the SLB instance. Valid values:
	//
	// *   Internet: an Internet-facing SLB instance
	// *   Intranet: an internal-facing SLB instance
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdateK8sSlbRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateK8sSlbRequest) GoString() string {
	return s.String()
}

func (s *UpdateK8sSlbRequest) SetAppId(v string) *UpdateK8sSlbRequest {
	s.AppId = &v
	return s
}

func (s *UpdateK8sSlbRequest) SetClusterId(v string) *UpdateK8sSlbRequest {
	s.ClusterId = &v
	return s
}

func (s *UpdateK8sSlbRequest) SetDisableForceOverride(v bool) *UpdateK8sSlbRequest {
	s.DisableForceOverride = &v
	return s
}

func (s *UpdateK8sSlbRequest) SetPort(v string) *UpdateK8sSlbRequest {
	s.Port = &v
	return s
}

func (s *UpdateK8sSlbRequest) SetScheduler(v string) *UpdateK8sSlbRequest {
	s.Scheduler = &v
	return s
}

func (s *UpdateK8sSlbRequest) SetServicePortInfos(v string) *UpdateK8sSlbRequest {
	s.ServicePortInfos = &v
	return s
}

func (s *UpdateK8sSlbRequest) SetSlbName(v string) *UpdateK8sSlbRequest {
	s.SlbName = &v
	return s
}

func (s *UpdateK8sSlbRequest) SetSlbProtocol(v string) *UpdateK8sSlbRequest {
	s.SlbProtocol = &v
	return s
}

func (s *UpdateK8sSlbRequest) SetSpecification(v string) *UpdateK8sSlbRequest {
	s.Specification = &v
	return s
}

func (s *UpdateK8sSlbRequest) SetTargetPort(v string) *UpdateK8sSlbRequest {
	s.TargetPort = &v
	return s
}

func (s *UpdateK8sSlbRequest) SetType(v string) *UpdateK8sSlbRequest {
	s.Type = &v
	return s
}

type UpdateK8sSlbResponseBody struct {
	// The ID of the change process.
	ChangeOrderId *string `json:"ChangeOrderId,omitempty" xml:"ChangeOrderId,omitempty"`
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateK8sSlbResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateK8sSlbResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateK8sSlbResponseBody) SetChangeOrderId(v string) *UpdateK8sSlbResponseBody {
	s.ChangeOrderId = &v
	return s
}

func (s *UpdateK8sSlbResponseBody) SetCode(v int32) *UpdateK8sSlbResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateK8sSlbResponseBody) SetMessage(v string) *UpdateK8sSlbResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateK8sSlbResponseBody) SetRequestId(v string) *UpdateK8sSlbResponseBody {
	s.RequestId = &v
	return s
}

type UpdateK8sSlbResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateK8sSlbResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateK8sSlbResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateK8sSlbResponse) GoString() string {
	return s.String()
}

func (s *UpdateK8sSlbResponse) SetHeaders(v map[string]*string) *UpdateK8sSlbResponse {
	s.Headers = v
	return s
}

func (s *UpdateK8sSlbResponse) SetStatusCode(v int32) *UpdateK8sSlbResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateK8sSlbResponse) SetBody(v *UpdateK8sSlbResponseBody) *UpdateK8sSlbResponse {
	s.Body = v
	return s
}

type UpdateRoleRequest struct {
	// The set of permissions to be granted to the role. The value is in the format of `Permission group ID 1:Permission serial number 1;...;Permission group ID n:Permission serial number n`. Example: `1:1;1:2;2:1;2:2`. For more information about permission groups and permission serial numbers, see [ListAuthority](~~149409~~).
	ActionData *string `json:"ActionData,omitempty" xml:"ActionData,omitempty"`
	// The ID of the role. You can call the ListRole operation to query the role IDs. For more information, see [ListRole](~~149410~~).
	RoleId *int32 `json:"RoleId,omitempty" xml:"RoleId,omitempty"`
}

func (s UpdateRoleRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateRoleRequest) GoString() string {
	return s.String()
}

func (s *UpdateRoleRequest) SetActionData(v string) *UpdateRoleRequest {
	s.ActionData = &v
	return s
}

func (s *UpdateRoleRequest) SetRoleId(v int32) *UpdateRoleRequest {
	s.RoleId = &v
	return s
}

type UpdateRoleResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateRoleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateRoleResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateRoleResponseBody) SetCode(v int32) *UpdateRoleResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateRoleResponseBody) SetMessage(v string) *UpdateRoleResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateRoleResponseBody) SetRequestId(v string) *UpdateRoleResponseBody {
	s.RequestId = &v
	return s
}

type UpdateRoleResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateRoleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateRoleResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateRoleResponse) GoString() string {
	return s.String()
}

func (s *UpdateRoleResponse) SetHeaders(v map[string]*string) *UpdateRoleResponse {
	s.Headers = v
	return s
}

func (s *UpdateRoleResponse) SetStatusCode(v int32) *UpdateRoleResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateRoleResponse) SetBody(v *UpdateRoleResponseBody) *UpdateRoleResponse {
	s.Body = v
	return s
}

type UpdateSlsLogStoreRequest struct {
	// The ID of the application. You can call the ListApplication operation to query the application ID. For more information, see [ListApplication](~~149390~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The configurations of the Logstore.
	//
	// *   The following parameters are included in the configurations:****
	//
	//     *   **type**: the collection type. Set this parameter to file to specify the file type. Set this parameter to stdout to specify the standard output type.
	//
	//     *   **logstore**: the name of the Logstore. Make sure that the name of the Logstore is unique in the cluster. The name must comply with the following rules:
	//
	//         *   The name can contain only lowercase letters, digits, hyphens (-), and underscores (\_).
	//         *   The name must start and end with a lowercase letter or a digit.
	//         *   The name must be 3 to 63 characters in length.
	//
	//         **
	//
	//         **Note**If you leave this parameter empty, the system automatically generates a name.
	//
	//     *   **LogDir**: If the standard output type is used, the collection path is stdout.log. If the file type is used, the collection path is the path of the collected file. Wildcards (\*) are supported. The collection path must match the following regular expression: `^/(.+)/(.*)^/$`.
	Configs *string `json:"Configs,omitempty" xml:"Configs,omitempty"`
}

func (s UpdateSlsLogStoreRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateSlsLogStoreRequest) GoString() string {
	return s.String()
}

func (s *UpdateSlsLogStoreRequest) SetAppId(v string) *UpdateSlsLogStoreRequest {
	s.AppId = &v
	return s
}

func (s *UpdateSlsLogStoreRequest) SetConfigs(v string) *UpdateSlsLogStoreRequest {
	s.Configs = &v
	return s
}

type UpdateSlsLogStoreResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateSlsLogStoreResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateSlsLogStoreResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateSlsLogStoreResponseBody) SetCode(v int32) *UpdateSlsLogStoreResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateSlsLogStoreResponseBody) SetMessage(v string) *UpdateSlsLogStoreResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateSlsLogStoreResponseBody) SetRequestId(v string) *UpdateSlsLogStoreResponseBody {
	s.RequestId = &v
	return s
}

type UpdateSlsLogStoreResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateSlsLogStoreResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateSlsLogStoreResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateSlsLogStoreResponse) GoString() string {
	return s.String()
}

func (s *UpdateSlsLogStoreResponse) SetHeaders(v map[string]*string) *UpdateSlsLogStoreResponse {
	s.Headers = v
	return s
}

func (s *UpdateSlsLogStoreResponse) SetStatusCode(v int32) *UpdateSlsLogStoreResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateSlsLogStoreResponse) SetBody(v *UpdateSlsLogStoreResponseBody) *UpdateSlsLogStoreResponse {
	s.Body = v
	return s
}

type UpdateSwimmingLaneRequest struct {
	// The list of applications that are related to the lane.
	AppInfos *string `json:"AppInfos,omitempty" xml:"AppInfos,omitempty"`
	// Specifies whether to enable the throttling rule.
	EnableRules *bool `json:"EnableRules,omitempty" xml:"EnableRules,omitempty"`
	// The configuration of the throttling rule.
	EntryRules *string `json:"EntryRules,omitempty" xml:"EntryRules,omitempty"`
	// The ID of the lane.
	LaneId *int64 `json:"LaneId,omitempty" xml:"LaneId,omitempty"`
	// The name of the lane.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s UpdateSwimmingLaneRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateSwimmingLaneRequest) GoString() string {
	return s.String()
}

func (s *UpdateSwimmingLaneRequest) SetAppInfos(v string) *UpdateSwimmingLaneRequest {
	s.AppInfos = &v
	return s
}

func (s *UpdateSwimmingLaneRequest) SetEnableRules(v bool) *UpdateSwimmingLaneRequest {
	s.EnableRules = &v
	return s
}

func (s *UpdateSwimmingLaneRequest) SetEntryRules(v string) *UpdateSwimmingLaneRequest {
	s.EntryRules = &v
	return s
}

func (s *UpdateSwimmingLaneRequest) SetLaneId(v int64) *UpdateSwimmingLaneRequest {
	s.LaneId = &v
	return s
}

func (s *UpdateSwimmingLaneRequest) SetName(v string) *UpdateSwimmingLaneRequest {
	s.Name = &v
	return s
}

type UpdateSwimmingLaneResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data that is returned.
	Data *UpdateSwimmingLaneResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateSwimmingLaneResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateSwimmingLaneResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateSwimmingLaneResponseBody) SetCode(v int32) *UpdateSwimmingLaneResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateSwimmingLaneResponseBody) SetData(v *UpdateSwimmingLaneResponseBodyData) *UpdateSwimmingLaneResponseBody {
	s.Data = v
	return s
}

func (s *UpdateSwimmingLaneResponseBody) SetMessage(v string) *UpdateSwimmingLaneResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateSwimmingLaneResponseBody) SetRequestId(v string) *UpdateSwimmingLaneResponseBody {
	s.RequestId = &v
	return s
}

type UpdateSwimmingLaneResponseBodyData struct {
	// The rule of the lane.
	EntryRule *string `json:"EntryRule,omitempty" xml:"EntryRule,omitempty"`
	// The ID of the lane group.
	GroupId *int64 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The ID of the lane.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the lane.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
	// The list of associations between the lane and the related application.
	SwimmingLaneAppRelationShipList []*UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList `json:"SwimmingLaneAppRelationShipList,omitempty" xml:"SwimmingLaneAppRelationShipList,omitempty" type:"Repeated"`
	// The tag of the lane.
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
}

func (s UpdateSwimmingLaneResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s UpdateSwimmingLaneResponseBodyData) GoString() string {
	return s.String()
}

func (s *UpdateSwimmingLaneResponseBodyData) SetEntryRule(v string) *UpdateSwimmingLaneResponseBodyData {
	s.EntryRule = &v
	return s
}

func (s *UpdateSwimmingLaneResponseBodyData) SetGroupId(v int64) *UpdateSwimmingLaneResponseBodyData {
	s.GroupId = &v
	return s
}

func (s *UpdateSwimmingLaneResponseBodyData) SetId(v int64) *UpdateSwimmingLaneResponseBodyData {
	s.Id = &v
	return s
}

func (s *UpdateSwimmingLaneResponseBodyData) SetName(v string) *UpdateSwimmingLaneResponseBodyData {
	s.Name = &v
	return s
}

func (s *UpdateSwimmingLaneResponseBodyData) SetNamespaceId(v string) *UpdateSwimmingLaneResponseBodyData {
	s.NamespaceId = &v
	return s
}

func (s *UpdateSwimmingLaneResponseBodyData) SetSwimmingLaneAppRelationShipList(v []*UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList) *UpdateSwimmingLaneResponseBodyData {
	s.SwimmingLaneAppRelationShipList = v
	return s
}

func (s *UpdateSwimmingLaneResponseBodyData) SetTag(v string) *UpdateSwimmingLaneResponseBodyData {
	s.Tag = &v
	return s
}

type UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The ID of the lane.
	LaneId *int64 `json:"LaneId,omitempty" xml:"LaneId,omitempty"`
	// The association rule.
	Rules *string `json:"Rules,omitempty" xml:"Rules,omitempty"`
}

func (s UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList) String() string {
	return tea.Prettify(s)
}

func (s UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList) GoString() string {
	return s.String()
}

func (s *UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList) SetAppId(v string) *UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList {
	s.AppId = &v
	return s
}

func (s *UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList) SetAppName(v string) *UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList {
	s.AppName = &v
	return s
}

func (s *UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList) SetLaneId(v int64) *UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList {
	s.LaneId = &v
	return s
}

func (s *UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList) SetRules(v string) *UpdateSwimmingLaneResponseBodyDataSwimmingLaneAppRelationShipList {
	s.Rules = &v
	return s
}

type UpdateSwimmingLaneResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateSwimmingLaneResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateSwimmingLaneResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateSwimmingLaneResponse) GoString() string {
	return s.String()
}

func (s *UpdateSwimmingLaneResponse) SetHeaders(v map[string]*string) *UpdateSwimmingLaneResponse {
	s.Headers = v
	return s
}

func (s *UpdateSwimmingLaneResponse) SetStatusCode(v int32) *UpdateSwimmingLaneResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateSwimmingLaneResponse) SetBody(v *UpdateSwimmingLaneResponseBody) *UpdateSwimmingLaneResponse {
	s.Body = v
	return s
}

type UpdateSwimmingLaneGroupRequest struct {
	// The list of application IDs related to the lane group.
	AppIds *string `json:"AppIds,omitempty" xml:"AppIds,omitempty"`
	// The ingress application. The application is in the EDAS:{application ID} format.
	EntryApp *string `json:"EntryApp,omitempty" xml:"EntryApp,omitempty"`
	// The ID of the lane group.
	GroupId *int64 `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the lane group.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s UpdateSwimmingLaneGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateSwimmingLaneGroupRequest) GoString() string {
	return s.String()
}

func (s *UpdateSwimmingLaneGroupRequest) SetAppIds(v string) *UpdateSwimmingLaneGroupRequest {
	s.AppIds = &v
	return s
}

func (s *UpdateSwimmingLaneGroupRequest) SetEntryApp(v string) *UpdateSwimmingLaneGroupRequest {
	s.EntryApp = &v
	return s
}

func (s *UpdateSwimmingLaneGroupRequest) SetGroupId(v int64) *UpdateSwimmingLaneGroupRequest {
	s.GroupId = &v
	return s
}

func (s *UpdateSwimmingLaneGroupRequest) SetName(v string) *UpdateSwimmingLaneGroupRequest {
	s.Name = &v
	return s
}

type UpdateSwimmingLaneGroupResponseBody struct {
	// The HTTP status code that is returned.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data that is returned.
	Data *UpdateSwimmingLaneGroupResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The additional information that is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateSwimmingLaneGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateSwimmingLaneGroupResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateSwimmingLaneGroupResponseBody) SetCode(v int32) *UpdateSwimmingLaneGroupResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateSwimmingLaneGroupResponseBody) SetData(v *UpdateSwimmingLaneGroupResponseBodyData) *UpdateSwimmingLaneGroupResponseBody {
	s.Data = v
	return s
}

func (s *UpdateSwimmingLaneGroupResponseBody) SetMessage(v string) *UpdateSwimmingLaneGroupResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateSwimmingLaneGroupResponseBody) SetRequestId(v string) *UpdateSwimmingLaneGroupResponseBody {
	s.RequestId = &v
	return s
}

type UpdateSwimmingLaneGroupResponseBodyData struct {
	// The list of applications related to the lane group.
	ApplicationList []*UpdateSwimmingLaneGroupResponseBodyDataApplicationList `json:"ApplicationList,omitempty" xml:"ApplicationList,omitempty" type:"Repeated"`
	// The EDAS ingress gateway information.
	EntryApplication *UpdateSwimmingLaneGroupResponseBodyDataEntryApplication `json:"EntryApplication,omitempty" xml:"EntryApplication,omitempty" type:"Struct"`
	// The ID of the lane group.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the lane group.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the namespace.
	NamespaceId *string `json:"NamespaceId,omitempty" xml:"NamespaceId,omitempty"`
}

func (s UpdateSwimmingLaneGroupResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s UpdateSwimmingLaneGroupResponseBodyData) GoString() string {
	return s.String()
}

func (s *UpdateSwimmingLaneGroupResponseBodyData) SetApplicationList(v []*UpdateSwimmingLaneGroupResponseBodyDataApplicationList) *UpdateSwimmingLaneGroupResponseBodyData {
	s.ApplicationList = v
	return s
}

func (s *UpdateSwimmingLaneGroupResponseBodyData) SetEntryApplication(v *UpdateSwimmingLaneGroupResponseBodyDataEntryApplication) *UpdateSwimmingLaneGroupResponseBodyData {
	s.EntryApplication = v
	return s
}

func (s *UpdateSwimmingLaneGroupResponseBodyData) SetId(v int64) *UpdateSwimmingLaneGroupResponseBodyData {
	s.Id = &v
	return s
}

func (s *UpdateSwimmingLaneGroupResponseBodyData) SetName(v string) *UpdateSwimmingLaneGroupResponseBodyData {
	s.Name = &v
	return s
}

func (s *UpdateSwimmingLaneGroupResponseBodyData) SetNamespaceId(v string) *UpdateSwimmingLaneGroupResponseBodyData {
	s.NamespaceId = &v
	return s
}

type UpdateSwimmingLaneGroupResponseBodyDataApplicationList struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
}

func (s UpdateSwimmingLaneGroupResponseBodyDataApplicationList) String() string {
	return tea.Prettify(s)
}

func (s UpdateSwimmingLaneGroupResponseBodyDataApplicationList) GoString() string {
	return s.String()
}

func (s *UpdateSwimmingLaneGroupResponseBodyDataApplicationList) SetAppId(v string) *UpdateSwimmingLaneGroupResponseBodyDataApplicationList {
	s.AppId = &v
	return s
}

func (s *UpdateSwimmingLaneGroupResponseBodyDataApplicationList) SetAppName(v string) *UpdateSwimmingLaneGroupResponseBodyDataApplicationList {
	s.AppName = &v
	return s
}

type UpdateSwimmingLaneGroupResponseBodyDataEntryApplication struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
}

func (s UpdateSwimmingLaneGroupResponseBodyDataEntryApplication) String() string {
	return tea.Prettify(s)
}

func (s UpdateSwimmingLaneGroupResponseBodyDataEntryApplication) GoString() string {
	return s.String()
}

func (s *UpdateSwimmingLaneGroupResponseBodyDataEntryApplication) SetAppId(v string) *UpdateSwimmingLaneGroupResponseBodyDataEntryApplication {
	s.AppId = &v
	return s
}

func (s *UpdateSwimmingLaneGroupResponseBodyDataEntryApplication) SetAppName(v string) *UpdateSwimmingLaneGroupResponseBodyDataEntryApplication {
	s.AppName = &v
	return s
}

type UpdateSwimmingLaneGroupResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateSwimmingLaneGroupResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateSwimmingLaneGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateSwimmingLaneGroupResponse) GoString() string {
	return s.String()
}

func (s *UpdateSwimmingLaneGroupResponse) SetHeaders(v map[string]*string) *UpdateSwimmingLaneGroupResponse {
	s.Headers = v
	return s
}

func (s *UpdateSwimmingLaneGroupResponse) SetStatusCode(v int32) *UpdateSwimmingLaneGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateSwimmingLaneGroupResponse) SetBody(v *UpdateSwimmingLaneGroupResponseBody) *UpdateSwimmingLaneGroupResponse {
	s.Body = v
	return s
}

type Client struct {
	openapi.Client
}

func NewClient(config *openapi.Config) (*Client, error) {
	client := new(Client)
	err := client.Init(config)
	return client, err
}

func (client *Client) Init(config *openapi.Config) (_err error) {
	_err = client.Client.Init(config)
	if _err != nil {
		return _err
	}
	client.SignatureAlgorithm = tea.String("v2")
	client.EndpointRule = tea.String("regional")
	client.EndpointMap = map[string]*string{
		"ap-northeast-2-pop":          tea.String("edas.ap-northeast-1.aliyuncs.com"),
		"ap-south-1":                  tea.String("edas.ap-northeast-1.aliyuncs.com"),
		"ap-southeast-3":              tea.String("edas.ap-northeast-1.aliyuncs.com"),
		"ap-southeast-5":              tea.String("edas.ap-northeast-1.aliyuncs.com"),
		"cn-beijing-finance-1":        tea.String("edas.aliyuncs.com"),
		"cn-beijing-finance-pop":      tea.String("edas.aliyuncs.com"),
		"cn-beijing-gov-1":            tea.String("edas.aliyuncs.com"),
		"cn-beijing-nu16-b01":         tea.String("edas.aliyuncs.com"),
		"cn-chengdu":                  tea.String("edas.aliyuncs.com"),
		"cn-edge-1":                   tea.String("edas.aliyuncs.com"),
		"cn-fujian":                   tea.String("edas.aliyuncs.com"),
		"cn-haidian-cm12-c01":         tea.String("edas.aliyuncs.com"),
		"cn-hangzhou-bj-b01":          tea.String("edas.aliyuncs.com"),
		"cn-hangzhou-finance":         tea.String("edas.aliyuncs.com"),
		"cn-hangzhou-internal-prod-1": tea.String("edas.aliyuncs.com"),
		"cn-hangzhou-internal-test-1": tea.String("edas.aliyuncs.com"),
		"cn-hangzhou-internal-test-2": tea.String("edas.aliyuncs.com"),
		"cn-hangzhou-internal-test-3": tea.String("edas.aliyuncs.com"),
		"cn-hangzhou-test-306":        tea.String("edas.aliyuncs.com"),
		"cn-hongkong-finance-pop":     tea.String("edas.aliyuncs.com"),
		"cn-huhehaote":                tea.String("edas.aliyuncs.com"),
		"cn-qingdao-nebula":           tea.String("edas.aliyuncs.com"),
		"cn-shanghai-et15-b01":        tea.String("edas.aliyuncs.com"),
		"cn-shanghai-et2-b01":         tea.String("edas.aliyuncs.com"),
		"cn-shanghai-finance-1":       tea.String("edas.aliyuncs.com"),
		"cn-shanghai-inner":           tea.String("edas.aliyuncs.com"),
		"cn-shanghai-internal-test-1": tea.String("edas.aliyuncs.com"),
		"cn-shenzhen-finance-1":       tea.String("edas.aliyuncs.com"),
		"cn-shenzhen-inner":           tea.String("edas.aliyuncs.com"),
		"cn-shenzhen-st4-d01":         tea.String("edas.aliyuncs.com"),
		"cn-shenzhen-su18-b01":        tea.String("edas.aliyuncs.com"),
		"cn-wuhan":                    tea.String("edas.aliyuncs.com"),
		"cn-yushanfang":               tea.String("edas.aliyuncs.com"),
		"cn-zhangbei-na61-b01":        tea.String("edas.aliyuncs.com"),
		"cn-zhangjiakou-na62-a01":     tea.String("edas.aliyuncs.com"),
		"cn-zhengzhou-nebula-1":       tea.String("edas.aliyuncs.com"),
		"eu-west-1":                   tea.String("edas.ap-northeast-1.aliyuncs.com"),
		"eu-west-1-oxs":               tea.String("edas.ap-northeast-1.aliyuncs.com"),
		"me-east-1":                   tea.String("edas.ap-northeast-1.aliyuncs.com"),
		"rus-west-1-pop":              tea.String("edas.ap-northeast-1.aliyuncs.com"),
		"us-west-1":                   tea.String("edas.ap-northeast-1.aliyuncs.com"),
	}
	_err = client.CheckConfig(config)
	if _err != nil {
		return _err
	}
	client.Endpoint, _err = client.GetEndpoint(tea.String("edas"), client.RegionId, client.EndpointRule, client.Network, client.Suffix, client.EndpointMap, client.Endpoint)
	if _err != nil {
		return _err
	}

	return nil
}

func (client *Client) GetEndpoint(productId *string, regionId *string, endpointRule *string, network *string, suffix *string, endpointMap map[string]*string, endpoint *string) (_result *string, _err error) {
	if !tea.BoolValue(util.Empty(endpoint)) {
		_result = endpoint
		return _result, _err
	}

	if !tea.BoolValue(util.IsUnset(endpointMap)) && !tea.BoolValue(util.Empty(endpointMap[tea.StringValue(regionId)])) {
		_result = endpointMap[tea.StringValue(regionId)]
		return _result, _err
	}

	_body, _err := endpointutil.GetEndpointRules(productId, regionId, endpointRule, network, suffix)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AbortAndRollbackChangeOrderWithOptions(request *AbortAndRollbackChangeOrderRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *AbortAndRollbackChangeOrderResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ChangeOrderId)) {
		query["ChangeOrderId"] = request.ChangeOrderId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AbortAndRollbackChangeOrder"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/changeorder/change_order_abort_and_rollback"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &AbortAndRollbackChangeOrderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AbortAndRollbackChangeOrder(request *AbortAndRollbackChangeOrderRequest) (_result *AbortAndRollbackChangeOrderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &AbortAndRollbackChangeOrderResponse{}
	_body, _err := client.AbortAndRollbackChangeOrderWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AbortChangeOrderWithOptions(request *AbortChangeOrderRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *AbortChangeOrderResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ChangeOrderId)) {
		query["ChangeOrderId"] = request.ChangeOrderId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AbortChangeOrder"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/changeorder/change_order_abort"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &AbortChangeOrderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AbortChangeOrder(request *AbortChangeOrderRequest) (_result *AbortChangeOrderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &AbortChangeOrderResponse{}
	_body, _err := client.AbortChangeOrderWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddLogPathWithOptions(request *AddLogPathRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *AddLogPathResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		body["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.Path)) {
		body["Path"] = request.Path
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("AddLogPath"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/log/popListLogDirs"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddLogPathResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddLogPath(request *AddLogPathRequest) (_result *AddLogPathResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &AddLogPathResponse{}
	_body, _err := client.AddLogPathWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AuthorizeApplicationWithOptions(request *AuthorizeApplicationRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *AuthorizeApplicationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppIds)) {
		query["AppIds"] = request.AppIds
	}

	if !tea.BoolValue(util.IsUnset(request.TargetUserId)) {
		query["TargetUserId"] = request.TargetUserId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AuthorizeApplication"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/account/authorize_app"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &AuthorizeApplicationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AuthorizeApplication(request *AuthorizeApplicationRequest) (_result *AuthorizeApplicationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &AuthorizeApplicationResponse{}
	_body, _err := client.AuthorizeApplicationWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AuthorizeResourceGroupWithOptions(request *AuthorizeResourceGroupRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *AuthorizeResourceGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceGroupIds)) {
		query["ResourceGroupIds"] = request.ResourceGroupIds
	}

	if !tea.BoolValue(util.IsUnset(request.TargetUserId)) {
		query["TargetUserId"] = request.TargetUserId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AuthorizeResourceGroup"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/account/authorize_res_group"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &AuthorizeResourceGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AuthorizeResourceGroup(request *AuthorizeResourceGroupRequest) (_result *AuthorizeResourceGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &AuthorizeResourceGroupResponse{}
	_body, _err := client.AuthorizeResourceGroupWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AuthorizeRoleWithOptions(request *AuthorizeRoleRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *AuthorizeRoleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RoleIds)) {
		query["RoleIds"] = request.RoleIds
	}

	if !tea.BoolValue(util.IsUnset(request.TargetUserId)) {
		query["TargetUserId"] = request.TargetUserId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AuthorizeRole"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/account/authorize_role"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &AuthorizeRoleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AuthorizeRole(request *AuthorizeRoleRequest) (_result *AuthorizeRoleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &AuthorizeRoleResponse{}
	_body, _err := client.AuthorizeRoleWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) BindEcsSlbWithOptions(request *BindEcsSlbRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *BindEcsSlbResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.DeployGroupId)) {
		query["DeployGroupId"] = request.DeployGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerHealthCheckUrl)) {
		query["ListenerHealthCheckUrl"] = request.ListenerHealthCheckUrl
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerPort)) {
		query["ListenerPort"] = request.ListenerPort
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerProtocol)) {
		query["ListenerProtocol"] = request.ListenerProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.SlbId)) {
		query["SlbId"] = request.SlbId
	}

	if !tea.BoolValue(util.IsUnset(request.VForwardingUrlRule)) {
		query["VForwardingUrlRule"] = request.VForwardingUrlRule
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroupId)) {
		query["VServerGroupId"] = request.VServerGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroupName)) {
		query["VServerGroupName"] = request.VServerGroupName
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BindEcsSlb"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/app/slb/bind_slb"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &BindEcsSlbResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) BindEcsSlb(request *BindEcsSlbRequest) (_result *BindEcsSlbResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &BindEcsSlbResponse{}
	_body, _err := client.BindEcsSlbWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) BindK8sSlbWithOptions(request *BindK8sSlbRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *BindK8sSlbResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Port)) {
		query["Port"] = request.Port
	}

	if !tea.BoolValue(util.IsUnset(request.Scheduler)) {
		query["Scheduler"] = request.Scheduler
	}

	if !tea.BoolValue(util.IsUnset(request.ServicePortInfos)) {
		query["ServicePortInfos"] = request.ServicePortInfos
	}

	if !tea.BoolValue(util.IsUnset(request.SlbId)) {
		query["SlbId"] = request.SlbId
	}

	if !tea.BoolValue(util.IsUnset(request.SlbProtocol)) {
		query["SlbProtocol"] = request.SlbProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.Specification)) {
		query["Specification"] = request.Specification
	}

	if !tea.BoolValue(util.IsUnset(request.TargetPort)) {
		query["TargetPort"] = request.TargetPort
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BindK8sSlb"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/acs/k8s_slb_binding"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &BindK8sSlbResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) BindK8sSlb(request *BindK8sSlbRequest) (_result *BindK8sSlbResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &BindK8sSlbResponse{}
	_body, _err := client.BindK8sSlbWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) BindSlbWithOptions(request *BindSlbRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *BindSlbResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerPort)) {
		query["ListenerPort"] = request.ListenerPort
	}

	if !tea.BoolValue(util.IsUnset(request.SlbId)) {
		query["SlbId"] = request.SlbId
	}

	if !tea.BoolValue(util.IsUnset(request.SlbIp)) {
		query["SlbIp"] = request.SlbIp
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroupId)) {
		query["VServerGroupId"] = request.VServerGroupId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BindSlb"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/app/bind_slb_json"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &BindSlbResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) BindSlb(request *BindSlbRequest) (_result *BindSlbResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &BindSlbResponse{}
	_body, _err := client.BindSlbWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ChangeDeployGroupWithOptions(request *ChangeDeployGroupRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ChangeDeployGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.EccInfo)) {
		query["EccInfo"] = request.EccInfo
	}

	if !tea.BoolValue(util.IsUnset(request.ForceStatus)) {
		query["ForceStatus"] = request.ForceStatus
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ChangeDeployGroup"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/changeorder/co_change_group"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ChangeDeployGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ChangeDeployGroup(request *ChangeDeployGroupRequest) (_result *ChangeDeployGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ChangeDeployGroupResponse{}
	_body, _err := client.ChangeDeployGroupWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ContinuePipelineWithOptions(request *ContinuePipelineRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ContinuePipelineResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Confirm)) {
		query["Confirm"] = request.Confirm
	}

	if !tea.BoolValue(util.IsUnset(request.PipelineId)) {
		query["PipelineId"] = request.PipelineId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ContinuePipeline"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/changeorder/pipeline_batch_confirm"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ContinuePipelineResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ContinuePipeline(request *ContinuePipelineRequest) (_result *ContinuePipelineResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ContinuePipelineResponse{}
	_body, _err := client.ContinuePipelineWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ConvertK8sResourceWithOptions(request *ConvertK8sResourceRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ConvertK8sResourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceName)) {
		query["ResourceName"] = request.ResourceName
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ConvertK8sResource"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/oam/k8s_resource_convert"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ConvertK8sResourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ConvertK8sResource(request *ConvertK8sResourceRequest) (_result *ConvertK8sResourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ConvertK8sResourceResponse{}
	_body, _err := client.ConvertK8sResourceWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateApplicationScalingRuleWithOptions(request *CreateApplicationScalingRuleRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateApplicationScalingRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingBehaviour)) {
		query["ScalingBehaviour"] = request.ScalingBehaviour
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleEnable)) {
		query["ScalingRuleEnable"] = request.ScalingRuleEnable
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleMetric)) {
		query["ScalingRuleMetric"] = request.ScalingRuleMetric
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleName)) {
		query["ScalingRuleName"] = request.ScalingRuleName
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleTimer)) {
		query["ScalingRuleTimer"] = request.ScalingRuleTimer
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleTrigger)) {
		query["ScalingRuleTrigger"] = request.ScalingRuleTrigger
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleType)) {
		query["ScalingRuleType"] = request.ScalingRuleType
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateApplicationScalingRule"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v1/eam/scale/application_scaling_rule"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateApplicationScalingRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateApplicationScalingRule(request *CreateApplicationScalingRuleRequest) (_result *CreateApplicationScalingRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateApplicationScalingRuleResponse{}
	_body, _err := client.CreateApplicationScalingRuleWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateConfigTemplateWithOptions(request *CreateConfigTemplateRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateConfigTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Content)) {
		body["Content"] = request.Content
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Format)) {
		body["Format"] = request.Format
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateConfigTemplate"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/config_template"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateConfigTemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateConfigTemplate(request *CreateConfigTemplateRequest) (_result *CreateConfigTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateConfigTemplateResponse{}
	_body, _err := client.CreateConfigTemplateWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Description
 * You must call the CreateIDCImportCommand operation first to generate a command used to import hybrid cloud ECS instances to a hybrid cloud ECS cluster. Then, run this command on the instances to import the instances to the cluster.
 *
 * @param request CreateIDCImportCommandRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateIDCImportCommandResponse
 */
func (client *Client) CreateIDCImportCommandWithOptions(request *CreateIDCImportCommandRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateIDCImportCommandResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		body["ClusterId"] = request.ClusterId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateIDCImportCommand"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/create_idc_import_command"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateIDCImportCommandResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Description
 * You must call the CreateIDCImportCommand operation first to generate a command used to import hybrid cloud ECS instances to a hybrid cloud ECS cluster. Then, run this command on the instances to import the instances to the cluster.
 *
 * @param request CreateIDCImportCommandRequest
 * @return CreateIDCImportCommandResponse
 */
func (client *Client) CreateIDCImportCommand(request *CreateIDCImportCommandRequest) (_result *CreateIDCImportCommandResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateIDCImportCommandResponse{}
	_body, _err := client.CreateIDCImportCommandWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateK8sConfigMapWithOptions(request *CreateK8sConfigMapRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateK8sConfigMapResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		body["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Data)) {
		body["Data"] = request.Data
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		body["Namespace"] = request.Namespace
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateK8sConfigMap"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/acs/k8s_config_map"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateK8sConfigMapResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateK8sConfigMap(request *CreateK8sConfigMapRequest) (_result *CreateK8sConfigMapResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateK8sConfigMapResponse{}
	_body, _err := client.CreateK8sConfigMapWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateK8sIngressRuleWithOptions(request *CreateK8sIngressRuleRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateK8sIngressRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Annotations)) {
		query["Annotations"] = request.Annotations
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.IngressConf)) {
		query["IngressConf"] = request.IngressConf
	}

	if !tea.BoolValue(util.IsUnset(request.Labels)) {
		query["Labels"] = request.Labels
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateK8sIngressRule"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/acs/k8s_ingress"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateK8sIngressRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateK8sIngressRule(request *CreateK8sIngressRuleRequest) (_result *CreateK8sIngressRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateK8sIngressRuleResponse{}
	_body, _err := client.CreateK8sIngressRuleWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateK8sSecretWithOptions(request *CreateK8sSecretRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateK8sSecretResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Base64Encoded)) {
		body["Base64Encoded"] = request.Base64Encoded
	}

	if !tea.BoolValue(util.IsUnset(request.CertId)) {
		body["CertId"] = request.CertId
	}

	if !tea.BoolValue(util.IsUnset(request.CertRegionId)) {
		body["CertRegionId"] = request.CertRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		body["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Data)) {
		body["Data"] = request.Data
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		body["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		body["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateK8sSecret"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/acs/k8s_secret"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateK8sSecretResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateK8sSecret(request *CreateK8sSecretRequest) (_result *CreateK8sSecretResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateK8sSecretResponse{}
	_body, _err := client.CreateK8sSecretWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateK8sServiceWithOptions(request *CreateK8sServiceRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *CreateK8sServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.ExternalTrafficPolicy)) {
		query["ExternalTrafficPolicy"] = request.ExternalTrafficPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.ServicePorts)) {
		query["ServicePorts"] = request.ServicePorts
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateK8sService"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/acs/k8s_service"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateK8sServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateK8sService(request *CreateK8sServiceRequest) (_result *CreateK8sServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &CreateK8sServiceResponse{}
	_body, _err := client.CreateK8sServiceWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteApplicationWithOptions(request *DeleteApplicationRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteApplicationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteApplication"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/changeorder/co_delete_app"),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteApplicationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteApplication(request *DeleteApplicationRequest) (_result *DeleteApplicationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteApplicationResponse{}
	_body, _err := client.DeleteApplicationWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteApplicationScalingRuleWithOptions(request *DeleteApplicationScalingRuleRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteApplicationScalingRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleName)) {
		query["ScalingRuleName"] = request.ScalingRuleName
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteApplicationScalingRule"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v1/eam/scale/application_scaling_rule"),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteApplicationScalingRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteApplicationScalingRule(request *DeleteApplicationScalingRuleRequest) (_result *DeleteApplicationScalingRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteApplicationScalingRuleResponse{}
	_body, _err := client.DeleteApplicationScalingRuleWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteClusterWithOptions(request *DeleteClusterRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Mode)) {
		query["Mode"] = request.Mode
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteCluster"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/resource/cluster"),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteCluster(request *DeleteClusterRequest) (_result *DeleteClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteClusterResponse{}
	_body, _err := client.DeleteClusterWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteClusterMemberWithOptions(request *DeleteClusterMemberRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteClusterMemberResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterMemberId)) {
		query["ClusterMemberId"] = request.ClusterMemberId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteClusterMember"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/resource/cluster_member"),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteClusterMemberResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteClusterMember(request *DeleteClusterMemberRequest) (_result *DeleteClusterMemberResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteClusterMemberResponse{}
	_body, _err := client.DeleteClusterMemberWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteConfigTemplateWithOptions(request *DeleteConfigTemplateRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteConfigTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteConfigTemplate"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/config_template"),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteConfigTemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteConfigTemplate(request *DeleteConfigTemplateRequest) (_result *DeleteConfigTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteConfigTemplateResponse{}
	_body, _err := client.DeleteConfigTemplateWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteDeployGroupWithOptions(request *DeleteDeployGroupRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteDeployGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDeployGroup"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/deploy_group"),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDeployGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteDeployGroup(request *DeleteDeployGroupRequest) (_result *DeleteDeployGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteDeployGroupResponse{}
	_body, _err := client.DeleteDeployGroupWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteEcuWithOptions(request *DeleteEcuRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteEcuResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EcuId)) {
		query["EcuId"] = request.EcuId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteEcu"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/resource/delete_ecu"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteEcuResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteEcu(request *DeleteEcuRequest) (_result *DeleteEcuResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteEcuResponse{}
	_body, _err := client.DeleteEcuWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteK8sApplicationWithOptions(request *DeleteK8sApplicationRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteK8sApplicationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.Force)) {
		query["Force"] = request.Force
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteK8sApplication"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/acs/k8s_apps"),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteK8sApplicationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteK8sApplication(request *DeleteK8sApplicationRequest) (_result *DeleteK8sApplicationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteK8sApplicationResponse{}
	_body, _err := client.DeleteK8sApplicationWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteK8sConfigMapWithOptions(request *DeleteK8sConfigMapRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteK8sConfigMapResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteK8sConfigMap"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/acs/k8s_config_map"),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteK8sConfigMapResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteK8sConfigMap(request *DeleteK8sConfigMapRequest) (_result *DeleteK8sConfigMapResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteK8sConfigMapResponse{}
	_body, _err := client.DeleteK8sConfigMapWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteK8sIngressRuleWithOptions(request *DeleteK8sIngressRuleRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteK8sIngressRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteK8sIngressRule"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/acs/k8s_ingress"),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteK8sIngressRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteK8sIngressRule(request *DeleteK8sIngressRuleRequest) (_result *DeleteK8sIngressRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteK8sIngressRuleResponse{}
	_body, _err := client.DeleteK8sIngressRuleWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteK8sSecretWithOptions(request *DeleteK8sSecretRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteK8sSecretResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteK8sSecret"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/acs/k8s_secret"),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteK8sSecretResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteK8sSecret(request *DeleteK8sSecretRequest) (_result *DeleteK8sSecretResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteK8sSecretResponse{}
	_body, _err := client.DeleteK8sSecretWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteK8sServiceWithOptions(request *DeleteK8sServiceRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteK8sServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteK8sService"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/acs/k8s_service"),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteK8sServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteK8sService(request *DeleteK8sServiceRequest) (_result *DeleteK8sServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteK8sServiceResponse{}
	_body, _err := client.DeleteK8sServiceWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteLogPathWithOptions(request *DeleteLogPathRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteLogPathResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.Path)) {
		query["Path"] = request.Path
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteLogPath"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/log/popListLogDirs"),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteLogPathResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteLogPath(request *DeleteLogPathRequest) (_result *DeleteLogPathResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteLogPathResponse{}
	_body, _err := client.DeleteLogPathWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteRoleWithOptions(request *DeleteRoleRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteRoleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RoleId)) {
		query["RoleId"] = request.RoleId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteRole"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/account/delete_role"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteRoleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteRole(request *DeleteRoleRequest) (_result *DeleteRoleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteRoleResponse{}
	_body, _err := client.DeleteRoleWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteServiceGroupWithOptions(request *DeleteServiceGroupRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteServiceGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteServiceGroup"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/service/serviceGroups"),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteServiceGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteServiceGroup(request *DeleteServiceGroupRequest) (_result *DeleteServiceGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteServiceGroupResponse{}
	_body, _err := client.DeleteServiceGroupWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteSwimmingLaneWithOptions(request *DeleteSwimmingLaneRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteSwimmingLaneResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LaneId)) {
		query["LaneId"] = request.LaneId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSwimmingLane"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/trafficmgnt/swimming_lanes"),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteSwimmingLaneResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteSwimmingLane(request *DeleteSwimmingLaneRequest) (_result *DeleteSwimmingLaneResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteSwimmingLaneResponse{}
	_body, _err := client.DeleteSwimmingLaneWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteUserDefineRegionWithOptions(request *DeleteUserDefineRegionRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeleteUserDefineRegionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.RegionTag)) {
		query["RegionTag"] = request.RegionTag
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteUserDefineRegion"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/user_region_def"),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteUserDefineRegionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteUserDefineRegion(request *DeleteUserDefineRegionRequest) (_result *DeleteUserDefineRegionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeleteUserDefineRegionResponse{}
	_body, _err := client.DeleteUserDefineRegionWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > To deploy an application in a Container Service for Kubernetes (ACK) cluster that is imported into Enterprise Distributed Application Service (EDAS), call the DeployK8sApplication operation provided by EDAS. For more information, see [](~~149420~~)DeployK8sApplication.
 *
 * @param request DeployApplicationRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeployApplicationResponse
 */
func (client *Client) DeployApplicationWithOptions(request *DeployApplicationRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeployApplicationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppEnv)) {
		query["AppEnv"] = request.AppEnv
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.Batch)) {
		query["Batch"] = request.Batch
	}

	if !tea.BoolValue(util.IsUnset(request.BatchWaitTime)) {
		query["BatchWaitTime"] = request.BatchWaitTime
	}

	if !tea.BoolValue(util.IsUnset(request.BuildPackId)) {
		query["BuildPackId"] = request.BuildPackId
	}

	if !tea.BoolValue(util.IsUnset(request.ComponentIds)) {
		query["ComponentIds"] = request.ComponentIds
	}

	if !tea.BoolValue(util.IsUnset(request.DeployType)) {
		query["DeployType"] = request.DeployType
	}

	if !tea.BoolValue(util.IsUnset(request.Desc)) {
		query["Desc"] = request.Desc
	}

	if !tea.BoolValue(util.IsUnset(request.Gray)) {
		query["Gray"] = request.Gray
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ImageUrl)) {
		query["ImageUrl"] = request.ImageUrl
	}

	if !tea.BoolValue(util.IsUnset(request.PackageVersion)) {
		query["PackageVersion"] = request.PackageVersion
	}

	if !tea.BoolValue(util.IsUnset(request.ReleaseType)) {
		query["ReleaseType"] = request.ReleaseType
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficControlStrategy)) {
		query["TrafficControlStrategy"] = request.TrafficControlStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.WarUrl)) {
		query["WarUrl"] = request.WarUrl
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeployApplication"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/changeorder/co_deploy"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeployApplicationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > To deploy an application in a Container Service for Kubernetes (ACK) cluster that is imported into Enterprise Distributed Application Service (EDAS), call the DeployK8sApplication operation provided by EDAS. For more information, see [](~~149420~~)DeployK8sApplication.
 *
 * @param request DeployApplicationRequest
 * @return DeployApplicationResponse
 */
func (client *Client) DeployApplication(request *DeployApplicationRequest) (_result *DeployApplicationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeployApplicationResponse{}
	_body, _err := client.DeployApplicationWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeployK8sApplicationWithOptions(request *DeployK8sApplicationRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DeployK8sApplicationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Annotations)) {
		query["Annotations"] = request.Annotations
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.Args)) {
		query["Args"] = request.Args
	}

	if !tea.BoolValue(util.IsUnset(request.BatchTimeout)) {
		query["BatchTimeout"] = request.BatchTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.BatchWaitTime)) {
		query["BatchWaitTime"] = request.BatchWaitTime
	}

	if !tea.BoolValue(util.IsUnset(request.BuildPackId)) {
		query["BuildPackId"] = request.BuildPackId
	}

	if !tea.BoolValue(util.IsUnset(request.CanaryRuleId)) {
		query["CanaryRuleId"] = request.CanaryRuleId
	}

	if !tea.BoolValue(util.IsUnset(request.ChangeOrderDesc)) {
		query["ChangeOrderDesc"] = request.ChangeOrderDesc
	}

	if !tea.BoolValue(util.IsUnset(request.Command)) {
		query["Command"] = request.Command
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigMountDescs)) {
		query["ConfigMountDescs"] = request.ConfigMountDescs
	}

	if !tea.BoolValue(util.IsUnset(request.CpuLimit)) {
		query["CpuLimit"] = request.CpuLimit
	}

	if !tea.BoolValue(util.IsUnset(request.CpuRequest)) {
		query["CpuRequest"] = request.CpuRequest
	}

	if !tea.BoolValue(util.IsUnset(request.CustomAffinity)) {
		query["CustomAffinity"] = request.CustomAffinity
	}

	if !tea.BoolValue(util.IsUnset(request.CustomAgentVersion)) {
		query["CustomAgentVersion"] = request.CustomAgentVersion
	}

	if !tea.BoolValue(util.IsUnset(request.CustomTolerations)) {
		query["CustomTolerations"] = request.CustomTolerations
	}

	if !tea.BoolValue(util.IsUnset(request.DeployAcrossNodes)) {
		query["DeployAcrossNodes"] = request.DeployAcrossNodes
	}

	if !tea.BoolValue(util.IsUnset(request.DeployAcrossZones)) {
		query["DeployAcrossZones"] = request.DeployAcrossZones
	}

	if !tea.BoolValue(util.IsUnset(request.EdasContainerVersion)) {
		query["EdasContainerVersion"] = request.EdasContainerVersion
	}

	if !tea.BoolValue(util.IsUnset(request.EmptyDirs)) {
		query["EmptyDirs"] = request.EmptyDirs
	}

	if !tea.BoolValue(util.IsUnset(request.EnableAhas)) {
		query["EnableAhas"] = request.EnableAhas
	}

	if !tea.BoolValue(util.IsUnset(request.EnableEmptyPushReject)) {
		query["EnableEmptyPushReject"] = request.EnableEmptyPushReject
	}

	if !tea.BoolValue(util.IsUnset(request.EnableLosslessRule)) {
		query["EnableLosslessRule"] = request.EnableLosslessRule
	}

	if !tea.BoolValue(util.IsUnset(request.EnvFroms)) {
		query["EnvFroms"] = request.EnvFroms
	}

	if !tea.BoolValue(util.IsUnset(request.Envs)) {
		query["Envs"] = request.Envs
	}

	if !tea.BoolValue(util.IsUnset(request.Image)) {
		query["Image"] = request.Image
	}

	if !tea.BoolValue(util.IsUnset(request.ImagePlatforms)) {
		query["ImagePlatforms"] = request.ImagePlatforms
	}

	if !tea.BoolValue(util.IsUnset(request.ImageTag)) {
		query["ImageTag"] = request.ImageTag
	}

	if !tea.BoolValue(util.IsUnset(request.InitContainers)) {
		query["InitContainers"] = request.InitContainers
	}

	if !tea.BoolValue(util.IsUnset(request.JDK)) {
		query["JDK"] = request.JDK
	}

	if !tea.BoolValue(util.IsUnset(request.JavaStartUpConfig)) {
		query["JavaStartUpConfig"] = request.JavaStartUpConfig
	}

	if !tea.BoolValue(util.IsUnset(request.Labels)) {
		query["Labels"] = request.Labels
	}

	if !tea.BoolValue(util.IsUnset(request.LimitEphemeralStorage)) {
		query["LimitEphemeralStorage"] = request.LimitEphemeralStorage
	}

	if !tea.BoolValue(util.IsUnset(request.Liveness)) {
		query["Liveness"] = request.Liveness
	}

	if !tea.BoolValue(util.IsUnset(request.LocalVolume)) {
		query["LocalVolume"] = request.LocalVolume
	}

	if !tea.BoolValue(util.IsUnset(request.LosslessRuleAligned)) {
		query["LosslessRuleAligned"] = request.LosslessRuleAligned
	}

	if !tea.BoolValue(util.IsUnset(request.LosslessRuleDelayTime)) {
		query["LosslessRuleDelayTime"] = request.LosslessRuleDelayTime
	}

	if !tea.BoolValue(util.IsUnset(request.LosslessRuleFuncType)) {
		query["LosslessRuleFuncType"] = request.LosslessRuleFuncType
	}

	if !tea.BoolValue(util.IsUnset(request.LosslessRuleRelated)) {
		query["LosslessRuleRelated"] = request.LosslessRuleRelated
	}

	if !tea.BoolValue(util.IsUnset(request.LosslessRuleWarmupTime)) {
		query["LosslessRuleWarmupTime"] = request.LosslessRuleWarmupTime
	}

	if !tea.BoolValue(util.IsUnset(request.McpuLimit)) {
		query["McpuLimit"] = request.McpuLimit
	}

	if !tea.BoolValue(util.IsUnset(request.McpuRequest)) {
		query["McpuRequest"] = request.McpuRequest
	}

	if !tea.BoolValue(util.IsUnset(request.MemoryLimit)) {
		query["MemoryLimit"] = request.MemoryLimit
	}

	if !tea.BoolValue(util.IsUnset(request.MemoryRequest)) {
		query["MemoryRequest"] = request.MemoryRequest
	}

	if !tea.BoolValue(util.IsUnset(request.MountDescs)) {
		query["MountDescs"] = request.MountDescs
	}

	if !tea.BoolValue(util.IsUnset(request.NasId)) {
		query["NasId"] = request.NasId
	}

	if !tea.BoolValue(util.IsUnset(request.PackageUrl)) {
		query["PackageUrl"] = request.PackageUrl
	}

	if !tea.BoolValue(util.IsUnset(request.PackageVersion)) {
		query["PackageVersion"] = request.PackageVersion
	}

	if !tea.BoolValue(util.IsUnset(request.PackageVersionId)) {
		query["PackageVersionId"] = request.PackageVersionId
	}

	if !tea.BoolValue(util.IsUnset(request.PostStart)) {
		query["PostStart"] = request.PostStart
	}

	if !tea.BoolValue(util.IsUnset(request.PreStop)) {
		query["PreStop"] = request.PreStop
	}

	if !tea.BoolValue(util.IsUnset(request.PvcMountDescs)) {
		query["PvcMountDescs"] = request.PvcMountDescs
	}

	if !tea.BoolValue(util.IsUnset(request.Readiness)) {
		query["Readiness"] = request.Readiness
	}

	if !tea.BoolValue(util.IsUnset(request.Replicas)) {
		query["Replicas"] = request.Replicas
	}

	if !tea.BoolValue(util.IsUnset(request.RequestsEphemeralStorage)) {
		query["RequestsEphemeralStorage"] = request.RequestsEphemeralStorage
	}

	if !tea.BoolValue(util.IsUnset(request.RuntimeClassName)) {
		query["RuntimeClassName"] = request.RuntimeClassName
	}

	if !tea.BoolValue(util.IsUnset(request.Sidecars)) {
		query["Sidecars"] = request.Sidecars
	}

	if !tea.BoolValue(util.IsUnset(request.SlsConfigs)) {
		query["SlsConfigs"] = request.SlsConfigs
	}

	if !tea.BoolValue(util.IsUnset(request.Startup)) {
		query["Startup"] = request.Startup
	}

	if !tea.BoolValue(util.IsUnset(request.StorageType)) {
		query["StorageType"] = request.StorageType
	}

	if !tea.BoolValue(util.IsUnset(request.TerminateGracePeriod)) {
		query["TerminateGracePeriod"] = request.TerminateGracePeriod
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficControlStrategy)) {
		query["TrafficControlStrategy"] = request.TrafficControlStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.UpdateStrategy)) {
		query["UpdateStrategy"] = request.UpdateStrategy
	}

	if !tea.BoolValue(util.IsUnset(request.UriEncoding)) {
		query["UriEncoding"] = request.UriEncoding
	}

	if !tea.BoolValue(util.IsUnset(request.UseBodyEncoding)) {
		query["UseBodyEncoding"] = request.UseBodyEncoding
	}

	if !tea.BoolValue(util.IsUnset(request.UserBaseImageUrl)) {
		query["UserBaseImageUrl"] = request.UserBaseImageUrl
	}

	if !tea.BoolValue(util.IsUnset(request.VolumesStr)) {
		query["VolumesStr"] = request.VolumesStr
	}

	if !tea.BoolValue(util.IsUnset(request.WebContainer)) {
		query["WebContainer"] = request.WebContainer
	}

	if !tea.BoolValue(util.IsUnset(request.WebContainerConfig)) {
		query["WebContainerConfig"] = request.WebContainerConfig
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeployK8sApplication"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/acs/k8s_apps"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DeployK8sApplicationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeployK8sApplication(request *DeployK8sApplicationRequest) (_result *DeployK8sApplicationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DeployK8sApplicationResponse{}
	_body, _err := client.DeployK8sApplicationWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeAppInstanceListWithOptions(request *DescribeAppInstanceListRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DescribeAppInstanceListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.WithNodeInfo)) {
		query["WithNodeInfo"] = request.WithNodeInfo
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeAppInstanceList"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/oam/app_instance_list"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeAppInstanceListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeAppInstanceList(request *DescribeAppInstanceListRequest) (_result *DescribeAppInstanceListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DescribeAppInstanceListResponse{}
	_body, _err := client.DescribeAppInstanceListWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeApplicationScalingRulesWithOptions(request *DescribeApplicationScalingRulesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DescribeApplicationScalingRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeApplicationScalingRules"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v1/eam/scale/application_scaling_rules"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeApplicationScalingRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeApplicationScalingRules(request *DescribeApplicationScalingRulesRequest) (_result *DescribeApplicationScalingRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DescribeApplicationScalingRulesResponse{}
	_body, _err := client.DescribeApplicationScalingRulesWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DisableApplicationScalingRuleWithOptions(request *DisableApplicationScalingRuleRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *DisableApplicationScalingRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleName)) {
		query["ScalingRuleName"] = request.ScalingRuleName
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DisableApplicationScalingRule"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v1/eam/scale/disable_application_scaling_rule"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &DisableApplicationScalingRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DisableApplicationScalingRule(request *DisableApplicationScalingRuleRequest) (_result *DisableApplicationScalingRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &DisableApplicationScalingRuleResponse{}
	_body, _err := client.DisableApplicationScalingRuleWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) EnableApplicationScalingRuleWithOptions(request *EnableApplicationScalingRuleRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *EnableApplicationScalingRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleName)) {
		query["ScalingRuleName"] = request.ScalingRuleName
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EnableApplicationScalingRule"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v1/eam/scale/enable_application_scaling_rule"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &EnableApplicationScalingRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) EnableApplicationScalingRule(request *EnableApplicationScalingRuleRequest) (_result *EnableApplicationScalingRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &EnableApplicationScalingRuleResponse{}
	_body, _err := client.EnableApplicationScalingRuleWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetAppDeploymentWithOptions(request *GetAppDeploymentRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetAppDeploymentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAppDeployment"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/oam/app_deployment"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAppDeploymentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetAppDeployment(request *GetAppDeploymentRequest) (_result *GetAppDeploymentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetAppDeploymentResponse{}
	_body, _err := client.GetAppDeploymentWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetApplicationWithOptions(request *GetApplicationRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetApplicationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetApplication"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/app/app_info"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetApplicationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetApplication(request *GetApplicationRequest) (_result *GetApplicationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetApplicationResponse{}
	_body, _err := client.GetApplicationWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetChangeOrderInfoWithOptions(request *GetChangeOrderInfoRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetChangeOrderInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ChangeOrderId)) {
		query["ChangeOrderId"] = request.ChangeOrderId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetChangeOrderInfo"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/changeorder/change_order_info"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetChangeOrderInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetChangeOrderInfo(request *GetChangeOrderInfoRequest) (_result *GetChangeOrderInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetChangeOrderInfoResponse{}
	_body, _err := client.GetChangeOrderInfoWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetClusterWithOptions(request *GetClusterRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetCluster"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/resource/cluster"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetCluster(request *GetClusterRequest) (_result *GetClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetClusterResponse{}
	_body, _err := client.GetClusterWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetContainerConfigurationWithOptions(request *GetContainerConfigurationRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetContainerConfigurationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetContainerConfiguration"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/app/container_config"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetContainerConfigurationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetContainerConfiguration(request *GetContainerConfigurationRequest) (_result *GetContainerConfigurationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetContainerConfigurationResponse{}
	_body, _err := client.GetContainerConfigurationWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetJavaStartUpConfigWithOptions(request *GetJavaStartUpConfigRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetJavaStartUpConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetJavaStartUpConfig"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/oam/java_start_up_config"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetJavaStartUpConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetJavaStartUpConfig(request *GetJavaStartUpConfigRequest) (_result *GetJavaStartUpConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetJavaStartUpConfigResponse{}
	_body, _err := client.GetJavaStartUpConfigWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetJvmConfigurationWithOptions(request *GetJvmConfigurationRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetJvmConfigurationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetJvmConfiguration"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/app/app_jvm_config"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetJvmConfigurationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetJvmConfiguration(request *GetJvmConfigurationRequest) (_result *GetJvmConfigurationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetJvmConfigurationResponse{}
	_body, _err := client.GetJvmConfigurationWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetK8sAppPrecheckResultWithOptions(request *GetK8sAppPrecheckResultRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetK8sAppPrecheckResultResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetK8sAppPrecheckResult"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/app_precheck"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetK8sAppPrecheckResultResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetK8sAppPrecheckResult(request *GetK8sAppPrecheckResultRequest) (_result *GetK8sAppPrecheckResultResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetK8sAppPrecheckResultResponse{}
	_body, _err := client.GetK8sAppPrecheckResultWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetK8sApplicationWithOptions(request *GetK8sApplicationRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetK8sApplicationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.From)) {
		query["From"] = request.From
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetK8sApplication"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/changeorder/co_application"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetK8sApplicationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetK8sApplication(request *GetK8sApplicationRequest) (_result *GetK8sApplicationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetK8sApplicationResponse{}
	_body, _err := client.GetK8sApplicationWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetK8sClusterWithOptions(request *GetK8sClusterRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetK8sClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterType)) {
		query["ClusterType"] = request.ClusterType
	}

	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionTag)) {
		query["RegionTag"] = request.RegionTag
	}

	if !tea.BoolValue(util.IsUnset(request.SubClusterType)) {
		query["SubClusterType"] = request.SubClusterType
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetK8sCluster"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s_clusters"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetK8sClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetK8sCluster(request *GetK8sClusterRequest) (_result *GetK8sClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetK8sClusterResponse{}
	_body, _err := client.GetK8sClusterWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetK8sServicesWithOptions(request *GetK8sServicesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetK8sServicesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetK8sServices"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/acs/k8s_service"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetK8sServicesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetK8sServices(request *GetK8sServicesRequest) (_result *GetK8sServicesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetK8sServicesResponse{}
	_body, _err := client.GetK8sServicesWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetPackageStorageCredentialWithOptions(headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetPackageStorageCredentialResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("GetPackageStorageCredential"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/package_storage_credential"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetPackageStorageCredentialResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetPackageStorageCredential() (_result *GetPackageStorageCredentialResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetPackageStorageCredentialResponse{}
	_body, _err := client.GetPackageStorageCredentialWithOptions(headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetScalingRulesWithOptions(request *GetScalingRulesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetScalingRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Mode)) {
		query["Mode"] = request.Mode
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetScalingRules"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/app/scalingRules"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetScalingRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetScalingRules(request *GetScalingRulesRequest) (_result *GetScalingRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetScalingRulesResponse{}
	_body, _err := client.GetScalingRulesWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetSecureTokenWithOptions(request *GetSecureTokenRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetSecureTokenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetSecureToken"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/secure_token"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetSecureTokenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetSecureToken(request *GetSecureTokenRequest) (_result *GetSecureTokenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetSecureTokenResponse{}
	_body, _err := client.GetSecureTokenWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetServiceConsumersPageWithOptions(request *GetServiceConsumersPageRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetServiceConsumersPageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["appId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.Group)) {
		query["group"] = request.Group
	}

	if !tea.BoolValue(util.IsUnset(request.Ip)) {
		query["ip"] = request.Ip
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.Origin)) {
		query["origin"] = request.Origin
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.RegistryType)) {
		query["registryType"] = request.RegistryType
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceId)) {
		query["serviceId"] = request.ServiceId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["serviceName"] = request.ServiceName
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceType)) {
		query["serviceType"] = request.ServiceType
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceVersion)) {
		query["serviceVersion"] = request.ServiceVersion
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	if !tea.BoolValue(util.IsUnset(request.Source)) {
		query["source"] = request.Source
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetServiceConsumersPage"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/sp/api/mseForOam/getServiceConsumersPage"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetServiceConsumersPageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetServiceConsumersPage(request *GetServiceConsumersPageRequest) (_result *GetServiceConsumersPageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetServiceConsumersPageResponse{}
	_body, _err := client.GetServiceConsumersPageWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetServiceDetailWithOptions(request *GetServiceDetailRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetServiceDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["appId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.Group)) {
		query["group"] = request.Group
	}

	if !tea.BoolValue(util.IsUnset(request.Ip)) {
		query["ip"] = request.Ip
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.Origin)) {
		query["origin"] = request.Origin
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.RegistryType)) {
		query["registryType"] = request.RegistryType
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceId)) {
		query["serviceId"] = request.ServiceId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["serviceName"] = request.ServiceName
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceType)) {
		query["serviceType"] = request.ServiceType
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceVersion)) {
		query["serviceVersion"] = request.ServiceVersion
	}

	if !tea.BoolValue(util.IsUnset(request.Source)) {
		query["source"] = request.Source
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetServiceDetail"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/sp/api/mseForOam/getServiceDetail"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetServiceDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetServiceDetail(request *GetServiceDetailRequest) (_result *GetServiceDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetServiceDetailResponse{}
	_body, _err := client.GetServiceDetailWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetServiceListPageWithOptions(request *GetServiceListPageRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetServiceListPageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.Origin)) {
		query["origin"] = request.Origin
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.SearchType)) {
		query["searchType"] = request.SearchType
	}

	if !tea.BoolValue(util.IsUnset(request.SearchValue)) {
		query["searchValue"] = request.SearchValue
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceType)) {
		query["serviceType"] = request.ServiceType
	}

	if !tea.BoolValue(util.IsUnset(request.Side)) {
		query["side"] = request.Side
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetServiceListPage"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/sp/api/mseForOam/getServiceListPage"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetServiceListPageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetServiceListPage(request *GetServiceListPageRequest) (_result *GetServiceListPageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetServiceListPageResponse{}
	_body, _err := client.GetServiceListPageWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetServiceMethodPageWithOptions(request *GetServiceMethodPageRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetServiceMethodPageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["appId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.Group)) {
		query["group"] = request.Group
	}

	if !tea.BoolValue(util.IsUnset(request.Ip)) {
		query["ip"] = request.Ip
	}

	if !tea.BoolValue(util.IsUnset(request.MethodController)) {
		query["methodController"] = request.MethodController
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.Origin)) {
		query["origin"] = request.Origin
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["pageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["pageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Path)) {
		query["path"] = request.Path
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.RegistryType)) {
		query["registryType"] = request.RegistryType
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceId)) {
		query["serviceId"] = request.ServiceId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["serviceName"] = request.ServiceName
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceType)) {
		query["serviceType"] = request.ServiceType
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceVersion)) {
		query["serviceVersion"] = request.ServiceVersion
	}

	if !tea.BoolValue(util.IsUnset(request.Source)) {
		query["source"] = request.Source
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetServiceMethodPage"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/sp/api/mseForOam/getServiceMethodPage"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetServiceMethodPageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetServiceMethodPage(request *GetServiceMethodPageRequest) (_result *GetServiceMethodPageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetServiceMethodPageResponse{}
	_body, _err := client.GetServiceMethodPageWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetServiceProvidersPageWithOptions(request *GetServiceProvidersPageRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetServiceProvidersPageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["appId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.Group)) {
		query["group"] = request.Group
	}

	if !tea.BoolValue(util.IsUnset(request.Ip)) {
		query["ip"] = request.Ip
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.Origin)) {
		query["origin"] = request.Origin
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.RegistryType)) {
		query["registryType"] = request.RegistryType
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceId)) {
		query["serviceId"] = request.ServiceId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["serviceName"] = request.ServiceName
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceType)) {
		query["serviceType"] = request.ServiceType
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceVersion)) {
		query["serviceVersion"] = request.ServiceVersion
	}

	if !tea.BoolValue(util.IsUnset(request.Size)) {
		query["size"] = request.Size
	}

	if !tea.BoolValue(util.IsUnset(request.Source)) {
		query["source"] = request.Source
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetServiceProvidersPage"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/sp/api/mseForOam/getServiceProvidersPage"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetServiceProvidersPageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetServiceProvidersPage(request *GetServiceProvidersPageRequest) (_result *GetServiceProvidersPageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetServiceProvidersPageResponse{}
	_body, _err := client.GetServiceProvidersPageWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ***
 *
 * @param request GetWebContainerConfigRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetWebContainerConfigResponse
 */
func (client *Client) GetWebContainerConfigWithOptions(request *GetWebContainerConfigRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *GetWebContainerConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetWebContainerConfig"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/oam/web_container_config"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &GetWebContainerConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ***
 *
 * @param request GetWebContainerConfigRequest
 * @return GetWebContainerConfigResponse
 */
func (client *Client) GetWebContainerConfig(request *GetWebContainerConfigRequest) (_result *GetWebContainerConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &GetWebContainerConfigResponse{}
	_body, _err := client.GetWebContainerConfigWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ImportK8sClusterWithOptions(request *ImportK8sClusterRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ImportK8sClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.EnableAsm)) {
		query["EnableAsm"] = request.EnableAsm
	}

	if !tea.BoolValue(util.IsUnset(request.Mode)) {
		query["Mode"] = request.Mode
	}

	if !tea.BoolValue(util.IsUnset(request.NamespaceId)) {
		query["NamespaceId"] = request.NamespaceId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ImportK8sCluster"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/import_k8s_cluster"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ImportK8sClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ImportK8sCluster(request *ImportK8sClusterRequest) (_result *ImportK8sClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ImportK8sClusterResponse{}
	_body, _err := client.ImportK8sClusterWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > To create an application in a Kubernetes cluster, call the InsertK8sApplication operation provided by Enterprise Distributed Application Service (EDAS).
 *
 * @param request InsertApplicationRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return InsertApplicationResponse
 */
func (client *Client) InsertApplicationWithOptions(request *InsertApplicationRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *InsertApplicationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApplicationName)) {
		query["ApplicationName"] = request.ApplicationName
	}

	if !tea.BoolValue(util.IsUnset(request.BuildPackId)) {
		query["BuildPackId"] = request.BuildPackId
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.ComponentIds)) {
		query["ComponentIds"] = request.ComponentIds
	}

	if !tea.BoolValue(util.IsUnset(request.Cpu)) {
		query["Cpu"] = request.Cpu
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EcuInfo)) {
		query["EcuInfo"] = request.EcuInfo
	}

	if !tea.BoolValue(util.IsUnset(request.EnablePortCheck)) {
		query["EnablePortCheck"] = request.EnablePortCheck
	}

	if !tea.BoolValue(util.IsUnset(request.EnableUrlCheck)) {
		query["EnableUrlCheck"] = request.EnableUrlCheck
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckURL)) {
		query["HealthCheckURL"] = request.HealthCheckURL
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckUrl)) {
		query["HealthCheckUrl"] = request.HealthCheckUrl
	}

	if !tea.BoolValue(util.IsUnset(request.Hooks)) {
		query["Hooks"] = request.Hooks
	}

	if !tea.BoolValue(util.IsUnset(request.Jdk)) {
		query["Jdk"] = request.Jdk
	}

	if !tea.BoolValue(util.IsUnset(request.JvmOptions)) {
		query["JvmOptions"] = request.JvmOptions
	}

	if !tea.BoolValue(util.IsUnset(request.LogicalRegionId)) {
		query["LogicalRegionId"] = request.LogicalRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.MaxHeapSize)) {
		query["MaxHeapSize"] = request.MaxHeapSize
	}

	if !tea.BoolValue(util.IsUnset(request.MaxPermSize)) {
		query["MaxPermSize"] = request.MaxPermSize
	}

	if !tea.BoolValue(util.IsUnset(request.Mem)) {
		query["Mem"] = request.Mem
	}

	if !tea.BoolValue(util.IsUnset(request.MinHeapSize)) {
		query["MinHeapSize"] = request.MinHeapSize
	}

	if !tea.BoolValue(util.IsUnset(request.PackageType)) {
		query["PackageType"] = request.PackageType
	}

	if !tea.BoolValue(util.IsUnset(request.ReservedPortStr)) {
		query["ReservedPortStr"] = request.ReservedPortStr
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.WebContainer)) {
		query["WebContainer"] = request.WebContainer
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("InsertApplication"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/changeorder/co_create_app"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &InsertApplicationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > To create an application in a Kubernetes cluster, call the InsertK8sApplication operation provided by Enterprise Distributed Application Service (EDAS).
 *
 * @param request InsertApplicationRequest
 * @return InsertApplicationResponse
 */
func (client *Client) InsertApplication(request *InsertApplicationRequest) (_result *InsertApplicationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &InsertApplicationResponse{}
	_body, _err := client.InsertApplicationWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) InsertClusterWithOptions(request *InsertClusterRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *InsertClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterName)) {
		query["ClusterName"] = request.ClusterName
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterType)) {
		query["ClusterType"] = request.ClusterType
	}

	if !tea.BoolValue(util.IsUnset(request.IaasProvider)) {
		query["IaasProvider"] = request.IaasProvider
	}

	if !tea.BoolValue(util.IsUnset(request.LogicalRegionId)) {
		query["LogicalRegionId"] = request.LogicalRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkMode)) {
		query["NetworkMode"] = request.NetworkMode
	}

	if !tea.BoolValue(util.IsUnset(request.OversoldFactor)) {
		query["OversoldFactor"] = request.OversoldFactor
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("InsertCluster"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/resource/cluster"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &InsertClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) InsertCluster(request *InsertClusterRequest) (_result *InsertClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &InsertClusterResponse{}
	_body, _err := client.InsertClusterWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ##
 * If you call this operation to import an ECS instance, the operating system of the ECS instance is reinstalled. After the operating system is reinstalled, all original data of the ECS instance is deleted. In addition, you must set a logon password for the ECS instance. Make sure that no important data exists on the ECS instance that you want to import or data has been backed up for the ECS instance.
 * > We recommend that you call the InstallAgent operation instead of this operation. For more information, see [InstallAgent](~~127023~~).
 *
 * @param request InsertClusterMemberRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return InsertClusterMemberResponse
 */
func (client *Client) InsertClusterMemberWithOptions(request *InsertClusterMemberRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *InsertClusterMemberResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["clusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["instanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.Password)) {
		query["password"] = request.Password
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("InsertClusterMember"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/resource/cluster_member"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &InsertClusterMemberResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ##
 * If you call this operation to import an ECS instance, the operating system of the ECS instance is reinstalled. After the operating system is reinstalled, all original data of the ECS instance is deleted. In addition, you must set a logon password for the ECS instance. Make sure that no important data exists on the ECS instance that you want to import or data has been backed up for the ECS instance.
 * > We recommend that you call the InstallAgent operation instead of this operation. For more information, see [InstallAgent](~~127023~~).
 *
 * @param request InsertClusterMemberRequest
 * @return InsertClusterMemberResponse
 */
func (client *Client) InsertClusterMember(request *InsertClusterMemberRequest) (_result *InsertClusterMemberResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &InsertClusterMemberResponse{}
	_body, _err := client.InsertClusterMemberWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) InsertDeployGroupWithOptions(request *InsertDeployGroupRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *InsertDeployGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.InitPackageVersionId)) {
		query["InitPackageVersionId"] = request.InitPackageVersionId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("InsertDeployGroup"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/deploy_group"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &InsertDeployGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) InsertDeployGroup(request *InsertDeployGroupRequest) (_result *InsertDeployGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &InsertDeployGroupResponse{}
	_body, _err := client.InsertDeployGroupWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) InsertK8sApplicationWithOptions(request *InsertK8sApplicationRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *InsertK8sApplicationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Annotations)) {
		query["Annotations"] = request.Annotations
	}

	if !tea.BoolValue(util.IsUnset(request.AppConfig)) {
		query["AppConfig"] = request.AppConfig
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.AppTemplateName)) {
		query["AppTemplateName"] = request.AppTemplateName
	}

	if !tea.BoolValue(util.IsUnset(request.ApplicationDescription)) {
		query["ApplicationDescription"] = request.ApplicationDescription
	}

	if !tea.BoolValue(util.IsUnset(request.BuildPackId)) {
		query["BuildPackId"] = request.BuildPackId
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Command)) {
		query["Command"] = request.Command
	}

	if !tea.BoolValue(util.IsUnset(request.CommandArgs)) {
		query["CommandArgs"] = request.CommandArgs
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigMountDescs)) {
		query["ConfigMountDescs"] = request.ConfigMountDescs
	}

	if !tea.BoolValue(util.IsUnset(request.ContainerRegistryId)) {
		query["ContainerRegistryId"] = request.ContainerRegistryId
	}

	if !tea.BoolValue(util.IsUnset(request.CsClusterId)) {
		query["CsClusterId"] = request.CsClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.CustomAffinity)) {
		query["CustomAffinity"] = request.CustomAffinity
	}

	if !tea.BoolValue(util.IsUnset(request.CustomAgentVersion)) {
		query["CustomAgentVersion"] = request.CustomAgentVersion
	}

	if !tea.BoolValue(util.IsUnset(request.CustomTolerations)) {
		query["CustomTolerations"] = request.CustomTolerations
	}

	if !tea.BoolValue(util.IsUnset(request.DeployAcrossNodes)) {
		query["DeployAcrossNodes"] = request.DeployAcrossNodes
	}

	if !tea.BoolValue(util.IsUnset(request.DeployAcrossZones)) {
		query["DeployAcrossZones"] = request.DeployAcrossZones
	}

	if !tea.BoolValue(util.IsUnset(request.EdasContainerVersion)) {
		query["EdasContainerVersion"] = request.EdasContainerVersion
	}

	if !tea.BoolValue(util.IsUnset(request.EmptyDirs)) {
		query["EmptyDirs"] = request.EmptyDirs
	}

	if !tea.BoolValue(util.IsUnset(request.EnableAhas)) {
		query["EnableAhas"] = request.EnableAhas
	}

	if !tea.BoolValue(util.IsUnset(request.EnableAsm)) {
		query["EnableAsm"] = request.EnableAsm
	}

	if !tea.BoolValue(util.IsUnset(request.EnableEmptyPushReject)) {
		query["EnableEmptyPushReject"] = request.EnableEmptyPushReject
	}

	if !tea.BoolValue(util.IsUnset(request.EnableLosslessRule)) {
		query["EnableLosslessRule"] = request.EnableLosslessRule
	}

	if !tea.BoolValue(util.IsUnset(request.EnvFroms)) {
		query["EnvFroms"] = request.EnvFroms
	}

	if !tea.BoolValue(util.IsUnset(request.Envs)) {
		query["Envs"] = request.Envs
	}

	if !tea.BoolValue(util.IsUnset(request.FeatureConfig)) {
		query["FeatureConfig"] = request.FeatureConfig
	}

	if !tea.BoolValue(util.IsUnset(request.ImagePlatforms)) {
		query["ImagePlatforms"] = request.ImagePlatforms
	}

	if !tea.BoolValue(util.IsUnset(request.ImageUrl)) {
		query["ImageUrl"] = request.ImageUrl
	}

	if !tea.BoolValue(util.IsUnset(request.InitContainers)) {
		query["InitContainers"] = request.InitContainers
	}

	if !tea.BoolValue(util.IsUnset(request.InternetSlbId)) {
		query["InternetSlbId"] = request.InternetSlbId
	}

	if !tea.BoolValue(util.IsUnset(request.InternetSlbPort)) {
		query["InternetSlbPort"] = request.InternetSlbPort
	}

	if !tea.BoolValue(util.IsUnset(request.InternetSlbProtocol)) {
		query["InternetSlbProtocol"] = request.InternetSlbProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.InternetTargetPort)) {
		query["InternetTargetPort"] = request.InternetTargetPort
	}

	if !tea.BoolValue(util.IsUnset(request.IntranetSlbId)) {
		query["IntranetSlbId"] = request.IntranetSlbId
	}

	if !tea.BoolValue(util.IsUnset(request.IntranetSlbPort)) {
		query["IntranetSlbPort"] = request.IntranetSlbPort
	}

	if !tea.BoolValue(util.IsUnset(request.IntranetSlbProtocol)) {
		query["IntranetSlbProtocol"] = request.IntranetSlbProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.IntranetTargetPort)) {
		query["IntranetTargetPort"] = request.IntranetTargetPort
	}

	if !tea.BoolValue(util.IsUnset(request.IsMultilingualApp)) {
		query["IsMultilingualApp"] = request.IsMultilingualApp
	}

	if !tea.BoolValue(util.IsUnset(request.JDK)) {
		query["JDK"] = request.JDK
	}

	if !tea.BoolValue(util.IsUnset(request.JavaStartUpConfig)) {
		query["JavaStartUpConfig"] = request.JavaStartUpConfig
	}

	if !tea.BoolValue(util.IsUnset(request.Labels)) {
		query["Labels"] = request.Labels
	}

	if !tea.BoolValue(util.IsUnset(request.LimitCpu)) {
		query["LimitCpu"] = request.LimitCpu
	}

	if !tea.BoolValue(util.IsUnset(request.LimitEphemeralStorage)) {
		query["LimitEphemeralStorage"] = request.LimitEphemeralStorage
	}

	if !tea.BoolValue(util.IsUnset(request.LimitMem)) {
		query["LimitMem"] = request.LimitMem
	}

	if !tea.BoolValue(util.IsUnset(request.LimitmCpu)) {
		query["LimitmCpu"] = request.LimitmCpu
	}

	if !tea.BoolValue(util.IsUnset(request.Liveness)) {
		query["Liveness"] = request.Liveness
	}

	if !tea.BoolValue(util.IsUnset(request.LocalVolume)) {
		query["LocalVolume"] = request.LocalVolume
	}

	if !tea.BoolValue(util.IsUnset(request.LogicalRegionId)) {
		query["LogicalRegionId"] = request.LogicalRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.LosslessRuleAligned)) {
		query["LosslessRuleAligned"] = request.LosslessRuleAligned
	}

	if !tea.BoolValue(util.IsUnset(request.LosslessRuleDelayTime)) {
		query["LosslessRuleDelayTime"] = request.LosslessRuleDelayTime
	}

	if !tea.BoolValue(util.IsUnset(request.LosslessRuleFuncType)) {
		query["LosslessRuleFuncType"] = request.LosslessRuleFuncType
	}

	if !tea.BoolValue(util.IsUnset(request.LosslessRuleRelated)) {
		query["LosslessRuleRelated"] = request.LosslessRuleRelated
	}

	if !tea.BoolValue(util.IsUnset(request.LosslessRuleWarmupTime)) {
		query["LosslessRuleWarmupTime"] = request.LosslessRuleWarmupTime
	}

	if !tea.BoolValue(util.IsUnset(request.MountDescs)) {
		query["MountDescs"] = request.MountDescs
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.NasId)) {
		query["NasId"] = request.NasId
	}

	if !tea.BoolValue(util.IsUnset(request.PackageType)) {
		query["PackageType"] = request.PackageType
	}

	if !tea.BoolValue(util.IsUnset(request.PackageUrl)) {
		query["PackageUrl"] = request.PackageUrl
	}

	if !tea.BoolValue(util.IsUnset(request.PackageVersion)) {
		query["PackageVersion"] = request.PackageVersion
	}

	if !tea.BoolValue(util.IsUnset(request.PostStart)) {
		query["PostStart"] = request.PostStart
	}

	if !tea.BoolValue(util.IsUnset(request.PreStop)) {
		query["PreStop"] = request.PreStop
	}

	if !tea.BoolValue(util.IsUnset(request.PvcMountDescs)) {
		query["PvcMountDescs"] = request.PvcMountDescs
	}

	if !tea.BoolValue(util.IsUnset(request.Readiness)) {
		query["Readiness"] = request.Readiness
	}

	if !tea.BoolValue(util.IsUnset(request.Replicas)) {
		query["Replicas"] = request.Replicas
	}

	if !tea.BoolValue(util.IsUnset(request.RepoId)) {
		query["RepoId"] = request.RepoId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestsCpu)) {
		query["RequestsCpu"] = request.RequestsCpu
	}

	if !tea.BoolValue(util.IsUnset(request.RequestsEphemeralStorage)) {
		query["RequestsEphemeralStorage"] = request.RequestsEphemeralStorage
	}

	if !tea.BoolValue(util.IsUnset(request.RequestsMem)) {
		query["RequestsMem"] = request.RequestsMem
	}

	if !tea.BoolValue(util.IsUnset(request.RequestsmCpu)) {
		query["RequestsmCpu"] = request.RequestsmCpu
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RuntimeClassName)) {
		query["RuntimeClassName"] = request.RuntimeClassName
	}

	if !tea.BoolValue(util.IsUnset(request.SecretName)) {
		query["SecretName"] = request.SecretName
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceConfigs)) {
		query["ServiceConfigs"] = request.ServiceConfigs
	}

	if !tea.BoolValue(util.IsUnset(request.Sidecars)) {
		query["Sidecars"] = request.Sidecars
	}

	if !tea.BoolValue(util.IsUnset(request.SlsConfigs)) {
		query["SlsConfigs"] = request.SlsConfigs
	}

	if !tea.BoolValue(util.IsUnset(request.Startup)) {
		query["Startup"] = request.Startup
	}

	if !tea.BoolValue(util.IsUnset(request.StorageType)) {
		query["StorageType"] = request.StorageType
	}

	if !tea.BoolValue(util.IsUnset(request.TerminateGracePeriod)) {
		query["TerminateGracePeriod"] = request.TerminateGracePeriod
	}

	if !tea.BoolValue(util.IsUnset(request.Timeout)) {
		query["Timeout"] = request.Timeout
	}

	if !tea.BoolValue(util.IsUnset(request.UriEncoding)) {
		query["UriEncoding"] = request.UriEncoding
	}

	if !tea.BoolValue(util.IsUnset(request.UseBodyEncoding)) {
		query["UseBodyEncoding"] = request.UseBodyEncoding
	}

	if !tea.BoolValue(util.IsUnset(request.UserBaseImageUrl)) {
		query["UserBaseImageUrl"] = request.UserBaseImageUrl
	}

	if !tea.BoolValue(util.IsUnset(request.WebContainer)) {
		query["WebContainer"] = request.WebContainer
	}

	if !tea.BoolValue(util.IsUnset(request.WebContainerConfig)) {
		query["WebContainerConfig"] = request.WebContainerConfig
	}

	if !tea.BoolValue(util.IsUnset(request.WorkloadType)) {
		query["WorkloadType"] = request.WorkloadType
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("InsertK8sApplication"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/acs/create_k8s_app"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &InsertK8sApplicationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) InsertK8sApplication(request *InsertK8sApplicationRequest) (_result *InsertK8sApplicationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &InsertK8sApplicationResponse{}
	_body, _err := client.InsertK8sApplicationWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) InsertOrUpdateRegionWithOptions(request *InsertOrUpdateRegionRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *InsertOrUpdateRegionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DebugEnable)) {
		query["DebugEnable"] = request.DebugEnable
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.MseInstanceId)) {
		query["MseInstanceId"] = request.MseInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionName)) {
		query["RegionName"] = request.RegionName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionTag)) {
		query["RegionTag"] = request.RegionTag
	}

	if !tea.BoolValue(util.IsUnset(request.RegistryType)) {
		query["RegistryType"] = request.RegistryType
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("InsertOrUpdateRegion"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/user_region_def"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &InsertOrUpdateRegionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) InsertOrUpdateRegion(request *InsertOrUpdateRegionRequest) (_result *InsertOrUpdateRegionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &InsertOrUpdateRegionResponse{}
	_body, _err := client.InsertOrUpdateRegionWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) InsertRoleWithOptions(request *InsertRoleRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *InsertRoleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ActionData)) {
		query["ActionData"] = request.ActionData
	}

	if !tea.BoolValue(util.IsUnset(request.RoleName)) {
		query["RoleName"] = request.RoleName
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("InsertRole"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/account/create_role"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &InsertRoleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) InsertRole(request *InsertRoleRequest) (_result *InsertRoleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &InsertRoleResponse{}
	_body, _err := client.InsertRoleWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) InsertServiceGroupWithOptions(request *InsertServiceGroupRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *InsertServiceGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("InsertServiceGroup"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/service/serviceGroups"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &InsertServiceGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) InsertServiceGroup(request *InsertServiceGroupRequest) (_result *InsertServiceGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &InsertServiceGroupResponse{}
	_body, _err := client.InsertServiceGroupWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) InsertSwimmingLaneWithOptions(request *InsertSwimmingLaneRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *InsertSwimmingLaneResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppInfos)) {
		query["AppInfos"] = request.AppInfos
	}

	if !tea.BoolValue(util.IsUnset(request.EnableRules)) {
		query["EnableRules"] = request.EnableRules
	}

	if !tea.BoolValue(util.IsUnset(request.EntryRules)) {
		query["EntryRules"] = request.EntryRules
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.LogicalRegionId)) {
		query["LogicalRegionId"] = request.LogicalRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("InsertSwimmingLane"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/trafficmgnt/swimming_lanes"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &InsertSwimmingLaneResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) InsertSwimmingLane(request *InsertSwimmingLaneRequest) (_result *InsertSwimmingLaneResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &InsertSwimmingLaneResponse{}
	_body, _err := client.InsertSwimmingLaneWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) InsertSwimmingLaneGroupWithOptions(request *InsertSwimmingLaneGroupRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *InsertSwimmingLaneGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppIds)) {
		query["AppIds"] = request.AppIds
	}

	if !tea.BoolValue(util.IsUnset(request.EntryApp)) {
		query["EntryApp"] = request.EntryApp
	}

	if !tea.BoolValue(util.IsUnset(request.LogicalRegionId)) {
		query["LogicalRegionId"] = request.LogicalRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("InsertSwimmingLaneGroup"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/trafficmgnt/swimming_lane_groups"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &InsertSwimmingLaneGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) InsertSwimmingLaneGroup(request *InsertSwimmingLaneGroupRequest) (_result *InsertSwimmingLaneGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &InsertSwimmingLaneGroupResponse{}
	_body, _err := client.InsertSwimmingLaneGroupWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If you call this operation to import an ECS instance into EDAS, the operating system of the ECS instance is not reinstalled. We recommend that you call this operation to import ECS instances into EDAS.
 *
 * @param request InstallAgentRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return InstallAgentResponse
 */
func (client *Client) InstallAgentWithOptions(request *InstallAgentRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *InstallAgentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.DoAsync)) {
		query["DoAsync"] = request.DoAsync
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("InstallAgent"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/ecss/install_agent"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &InstallAgentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If you call this operation to import an ECS instance into EDAS, the operating system of the ECS instance is not reinstalled. We recommend that you call this operation to import ECS instances into EDAS.
 *
 * @param request InstallAgentRequest
 * @return InstallAgentResponse
 */
func (client *Client) InstallAgent(request *InstallAgentRequest) (_result *InstallAgentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &InstallAgentResponse{}
	_body, _err := client.InstallAgentWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListAliyunRegionWithOptions(headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListAliyunRegionResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("ListAliyunRegion"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/resource/region_list"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAliyunRegionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListAliyunRegion() (_result *ListAliyunRegionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListAliyunRegionResponse{}
	_body, _err := client.ListAliyunRegionWithOptions(headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListApplicationWithOptions(request *ListApplicationRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListApplicationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppIds)) {
		query["AppIds"] = request.AppIds
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.LogicalRegionId)) {
		query["LogicalRegionId"] = request.LogicalRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.LogicalRegionIdFilter)) {
		query["LogicalRegionIdFilter"] = request.LogicalRegionIdFilter
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListApplication"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/app/app_list"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListApplicationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListApplication(request *ListApplicationRequest) (_result *ListApplicationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListApplicationResponse{}
	_body, _err := client.ListApplicationWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListApplicationEcuWithOptions(request *ListApplicationEcuRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListApplicationEcuResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.LogicalRegionId)) {
		query["LogicalRegionId"] = request.LogicalRegionId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListApplicationEcu"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/resource/ecu_list"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListApplicationEcuResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListApplicationEcu(request *ListApplicationEcuRequest) (_result *ListApplicationEcuResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListApplicationEcuResponse{}
	_body, _err := client.ListApplicationEcuWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListAuthorityWithOptions(headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListAuthorityResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("ListAuthority"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/account/authority_list"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAuthorityResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListAuthority() (_result *ListAuthorityResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListAuthorityResponse{}
	_body, _err := client.ListAuthorityWithOptions(headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListBuildPackWithOptions(headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListBuildPackResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("ListBuildPack"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/app/build_pack_list"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListBuildPackResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListBuildPack() (_result *ListBuildPackResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListBuildPackResponse{}
	_body, _err := client.ListBuildPackWithOptions(headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListClusterWithOptions(request *ListClusterRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LogicalRegionId)) {
		query["LogicalRegionId"] = request.LogicalRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListCluster"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/resource/cluster_list"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListCluster(request *ListClusterRequest) (_result *ListClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListClusterResponse{}
	_body, _err := client.ListClusterWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListClusterMembersWithOptions(request *ListClusterMembersRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListClusterMembersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.EcsList)) {
		query["EcsList"] = request.EcsList
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListClusterMembers"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/resource/cluster_member_list"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListClusterMembersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListClusterMembers(request *ListClusterMembersRequest) (_result *ListClusterMembersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListClusterMembersResponse{}
	_body, _err := client.ListClusterMembersWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListComponentsWithOptions(headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListComponentsResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("ListComponents"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/resource/components"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListComponentsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListComponents() (_result *ListComponentsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListComponentsResponse{}
	_body, _err := client.ListComponentsWithOptions(headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListConfigTemplatesWithOptions(request *ListConfigTemplatesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListConfigTemplatesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		query["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListConfigTemplates"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/config_template"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListConfigTemplatesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListConfigTemplates(request *ListConfigTemplatesRequest) (_result *ListConfigTemplatesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListConfigTemplatesResponse{}
	_body, _err := client.ListConfigTemplatesWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListConsumedServicesWithOptions(request *ListConsumedServicesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListConsumedServicesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListConsumedServices"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/service/listConsumedServices"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListConsumedServicesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListConsumedServices(request *ListConsumedServicesRequest) (_result *ListConsumedServicesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListConsumedServicesResponse{}
	_body, _err := client.ListConsumedServicesWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListConvertableEcuWithOptions(request *ListConvertableEcuRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListConvertableEcuResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["clusterId"] = request.ClusterId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListConvertableEcu"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/resource/convertable_ecu_list"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListConvertableEcuResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListConvertableEcu(request *ListConvertableEcuRequest) (_result *ListConvertableEcuResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListConvertableEcuResponse{}
	_body, _err := client.ListConvertableEcuWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListDeployGroupWithOptions(request *ListDeployGroupRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListDeployGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDeployGroup"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/app/deploy_group_list"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDeployGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListDeployGroup(request *ListDeployGroupRequest) (_result *ListDeployGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListDeployGroupResponse{}
	_body, _err := client.ListDeployGroupWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListEcsNotInClusterWithOptions(request *ListEcsNotInClusterRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListEcsNotInClusterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NetworkMode)) {
		query["NetworkMode"] = request.NetworkMode
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListEcsNotInCluster"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/resource/ecs_not_in_cluster"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListEcsNotInClusterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListEcsNotInCluster(request *ListEcsNotInClusterRequest) (_result *ListEcsNotInClusterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListEcsNotInClusterResponse{}
	_body, _err := client.ListEcsNotInClusterWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Terms
 * *   **Namespace**: the logical concept that is used to isolate resources such as clusters, ECS instances, and applications, and microservices published in EDAS. This concept involves the default namespace and custom namespaces. Each region has a default namespace and supports multiple custom namespaces. By default, only the default namespace is available. You do not need to create a custom namespace if you do not want to isolate resources and microservices.
 * *   **Elastic compute unit (ECU)**: After an ECS instance is imported to a cluster, the instance becomes an ECU.
 * *   **Elastic compute container (ECC)**: After you deploy an application to an ECU in a cluster, the ECU becomes an ECC.
 *
 * @param request ListEcuByRegionRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListEcuByRegionResponse
 */
func (client *Client) ListEcuByRegionWithOptions(request *ListEcuByRegionRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListEcuByRegionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Act)) {
		query["Act"] = request.Act
	}

	if !tea.BoolValue(util.IsUnset(request.LogicalRegionId)) {
		query["LogicalRegionId"] = request.LogicalRegionId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListEcuByRegion"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/resource/ecu_list"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListEcuByRegionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Terms
 * *   **Namespace**: the logical concept that is used to isolate resources such as clusters, ECS instances, and applications, and microservices published in EDAS. This concept involves the default namespace and custom namespaces. Each region has a default namespace and supports multiple custom namespaces. By default, only the default namespace is available. You do not need to create a custom namespace if you do not want to isolate resources and microservices.
 * *   **Elastic compute unit (ECU)**: After an ECS instance is imported to a cluster, the instance becomes an ECU.
 * *   **Elastic compute container (ECC)**: After you deploy an application to an ECU in a cluster, the ECU becomes an ECC.
 *
 * @param request ListEcuByRegionRequest
 * @return ListEcuByRegionResponse
 */
func (client *Client) ListEcuByRegion(request *ListEcuByRegionRequest) (_result *ListEcuByRegionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListEcuByRegionResponse{}
	_body, _err := client.ListEcuByRegionWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListHistoryDeployVersionWithOptions(request *ListHistoryDeployVersionRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListHistoryDeployVersionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListHistoryDeployVersion"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/app/deploy_history_version_list"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListHistoryDeployVersionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListHistoryDeployVersion(request *ListHistoryDeployVersionRequest) (_result *ListHistoryDeployVersionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListHistoryDeployVersionResponse{}
	_body, _err := client.ListHistoryDeployVersionWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListK8sConfigMapsWithOptions(request *ListK8sConfigMapsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListK8sConfigMapsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Condition)) {
		query["Condition"] = request.Condition
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		query["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ShowRelatedApps)) {
		query["ShowRelatedApps"] = request.ShowRelatedApps
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListK8sConfigMaps"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/acs/k8s_config_map"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListK8sConfigMapsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListK8sConfigMaps(request *ListK8sConfigMapsRequest) (_result *ListK8sConfigMapsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListK8sConfigMapsResponse{}
	_body, _err := client.ListK8sConfigMapsWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListK8sIngressRulesWithOptions(request *ListK8sIngressRulesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListK8sIngressRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Condition)) {
		query["Condition"] = request.Condition
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListK8sIngressRules"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/acs/k8s_ingress"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListK8sIngressRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListK8sIngressRules(request *ListK8sIngressRulesRequest) (_result *ListK8sIngressRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListK8sIngressRulesResponse{}
	_body, _err := client.ListK8sIngressRulesWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListK8sNamespacesWithOptions(request *ListK8sNamespacesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListK8sNamespacesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListK8sNamespaces"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/acs/k8s_namespace"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListK8sNamespacesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListK8sNamespaces(request *ListK8sNamespacesRequest) (_result *ListK8sNamespacesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListK8sNamespacesResponse{}
	_body, _err := client.ListK8sNamespacesWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListK8sSecretsWithOptions(request *ListK8sSecretsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListK8sSecretsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Condition)) {
		query["Condition"] = request.Condition
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		query["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ShowRelatedApps)) {
		query["ShowRelatedApps"] = request.ShowRelatedApps
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListK8sSecrets"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/acs/k8s_secret"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListK8sSecretsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListK8sSecrets(request *ListK8sSecretsRequest) (_result *ListK8sSecretsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListK8sSecretsResponse{}
	_body, _err := client.ListK8sSecretsWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListMethodsWithOptions(request *ListMethodsRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListMethodsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceName)) {
		query["ServiceName"] = request.ServiceName
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListMethods"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/service/list_methods"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListMethodsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListMethods(request *ListMethodsRequest) (_result *ListMethodsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListMethodsResponse{}
	_body, _err := client.ListMethodsWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListPublishedServicesWithOptions(request *ListPublishedServicesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListPublishedServicesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListPublishedServices"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/service/listPublishedServices"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListPublishedServicesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListPublishedServices(request *ListPublishedServicesRequest) (_result *ListPublishedServicesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListPublishedServicesResponse{}
	_body, _err := client.ListPublishedServicesWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListRecentChangeOrderWithOptions(request *ListRecentChangeOrderRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListRecentChangeOrderResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListRecentChangeOrder"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/changeorder/change_order_list"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListRecentChangeOrderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListRecentChangeOrder(request *ListRecentChangeOrderRequest) (_result *ListRecentChangeOrderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListRecentChangeOrderResponse{}
	_body, _err := client.ListRecentChangeOrderWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListResourceGroupWithOptions(headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListResourceGroupResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("ListResourceGroup"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/resource/reg_group_list"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListResourceGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListResourceGroup() (_result *ListResourceGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListResourceGroupResponse{}
	_body, _err := client.ListResourceGroupWithOptions(headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListRoleWithOptions(headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListRoleResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("ListRole"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/account/role_list"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListRoleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListRole() (_result *ListRoleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListRoleResponse{}
	_body, _err := client.ListRoleWithOptions(headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Terms
 * *   **Namespace**: the logical concept that is used to isolate resources such as clusters, ECS instances, and applications, and microservices published in EDAS. This concept involves the default namespace and custom namespaces. Each region has a default namespace and supports multiple custom namespaces. By default, only the default namespace is available. You do not need to create a custom namespace if you do not want to isolate resources and microservices.
 * *   **Elastic compute unit (ECU)**: After an ECS instance is imported to a cluster, the instance becomes an ECU.
 * *   **Elastic compute container (ECC)**: After you deploy an application to an ECU in a cluster, the ECU becomes an ECC.
 *
 * @param request ListScaleOutEcuRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListScaleOutEcuResponse
 */
func (client *Client) ListScaleOutEcuWithOptions(request *ListScaleOutEcuRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListScaleOutEcuResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Cpu)) {
		query["Cpu"] = request.Cpu
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceNum)) {
		query["InstanceNum"] = request.InstanceNum
	}

	if !tea.BoolValue(util.IsUnset(request.LogicalRegionId)) {
		query["LogicalRegionId"] = request.LogicalRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Mem)) {
		query["Mem"] = request.Mem
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListScaleOutEcu"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/resource/scale_out_ecu_list"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListScaleOutEcuResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Terms
 * *   **Namespace**: the logical concept that is used to isolate resources such as clusters, ECS instances, and applications, and microservices published in EDAS. This concept involves the default namespace and custom namespaces. Each region has a default namespace and supports multiple custom namespaces. By default, only the default namespace is available. You do not need to create a custom namespace if you do not want to isolate resources and microservices.
 * *   **Elastic compute unit (ECU)**: After an ECS instance is imported to a cluster, the instance becomes an ECU.
 * *   **Elastic compute container (ECC)**: After you deploy an application to an ECU in a cluster, the ECU becomes an ECC.
 *
 * @param request ListScaleOutEcuRequest
 * @return ListScaleOutEcuResponse
 */
func (client *Client) ListScaleOutEcu(request *ListScaleOutEcuRequest) (_result *ListScaleOutEcuResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListScaleOutEcuResponse{}
	_body, _err := client.ListScaleOutEcuWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListServiceGroupsWithOptions(headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListServiceGroupsResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("ListServiceGroups"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/service/serviceGroups"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListServiceGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListServiceGroups() (_result *ListServiceGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListServiceGroupsResponse{}
	_body, _err := client.ListServiceGroupsWithOptions(headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListSlbWithOptions(request *ListSlbRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListSlbResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AddressType)) {
		query["AddressType"] = request.AddressType
	}

	if !tea.BoolValue(util.IsUnset(request.SlbType)) {
		query["SlbType"] = request.SlbType
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListSlb"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/slb_list"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListSlbResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListSlb(request *ListSlbRequest) (_result *ListSlbResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListSlbResponse{}
	_body, _err := client.ListSlbWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListSubAccountWithOptions(headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListSubAccountResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("ListSubAccount"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/account/sub_account_list"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListSubAccountResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListSubAccount() (_result *ListSubAccountResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListSubAccountResponse{}
	_body, _err := client.ListSubAccountWithOptions(headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListSwimmingLaneWithOptions(request *ListSwimmingLaneRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListSwimmingLaneResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListSwimmingLane"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/trafficmgnt/swimming_lanes"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListSwimmingLaneResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListSwimmingLane(request *ListSwimmingLaneRequest) (_result *ListSwimmingLaneResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListSwimmingLaneResponse{}
	_body, _err := client.ListSwimmingLaneWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListSwimmingLaneGroupWithOptions(request *ListSwimmingLaneGroupRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListSwimmingLaneGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.LogicalRegionId)) {
		query["LogicalRegionId"] = request.LogicalRegionId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListSwimmingLaneGroup"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/trafficmgnt/swimming_lane_groups"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListSwimmingLaneGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListSwimmingLaneGroup(request *ListSwimmingLaneGroupRequest) (_result *ListSwimmingLaneGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListSwimmingLaneGroupResponse{}
	_body, _err := client.ListSwimmingLaneGroupWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTagResourcesWithOptions(request *ListTagResourcesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListTagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceIds)) {
		query["ResourceIds"] = request.ResourceIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceRegionId)) {
		query["ResourceRegionId"] = request.ResourceRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTagResources"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/tag/tags"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTagResources(request *ListTagResourcesRequest) (_result *ListTagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListTagResourcesResponse{}
	_body, _err := client.ListTagResourcesWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListUserDefineRegionWithOptions(request *ListUserDefineRegionRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListUserDefineRegionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DebugEnable)) {
		query["DebugEnable"] = request.DebugEnable
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListUserDefineRegion"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/user_region_defs"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListUserDefineRegionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListUserDefineRegion(request *ListUserDefineRegionRequest) (_result *ListUserDefineRegionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListUserDefineRegionResponse{}
	_body, _err := client.ListUserDefineRegionWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListVpcWithOptions(headers map[string]*string, runtime *util.RuntimeOptions) (_result *ListVpcResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("ListVpc"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/vpc_list"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ListVpcResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListVpc() (_result *ListVpcResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ListVpcResponse{}
	_body, _err := client.ListVpcWithOptions(headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * We recommend that you do not call this operation. Instead, we recommend that you call the TransformClusterMember operation. For more information, see [TransformClusterMember](~~71514~~).
 * When you call this operation to import an Elastic Compute Service (ECS) instance, the operating system of the ECS instance is reinstalled. After the operating system is reinstalled, all data of the ECS instance is deleted. You must set a logon password for the ECS instance. Make sure that no important data exists on or data has been backed up for the ECS instance that you want to import.
 * ## Terms
 * *   **Namespace**: the logical concept that is used to isolate resources and microservices in Enterprise Distributed Application Service (EDAS). The resources include clusters, ECS instances, and applications. You can use a default or custom namespace. Each region has a default namespace and supports multiple custom namespaces. By default, only the default namespace is available. You do not need to create a custom namespace if you do not want to isolate resources or microservices.
 * *   **ECU**: After an ECS instance is imported to a cluster, the instance becomes an ECU.
 * *   **Elastic compute container (ECC)**: After you deploy an application to an ECU in a cluster, the ECU becomes an ECC.
 *
 * @param request MigrateEcuRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return MigrateEcuResponse
 */
func (client *Client) MigrateEcuWithOptions(request *MigrateEcuRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *MigrateEcuResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.LogicalRegionId)) {
		query["LogicalRegionId"] = request.LogicalRegionId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("MigrateEcu"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/resource/migrate_ecu"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &MigrateEcuResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * We recommend that you do not call this operation. Instead, we recommend that you call the TransformClusterMember operation. For more information, see [TransformClusterMember](~~71514~~).
 * When you call this operation to import an Elastic Compute Service (ECS) instance, the operating system of the ECS instance is reinstalled. After the operating system is reinstalled, all data of the ECS instance is deleted. You must set a logon password for the ECS instance. Make sure that no important data exists on or data has been backed up for the ECS instance that you want to import.
 * ## Terms
 * *   **Namespace**: the logical concept that is used to isolate resources and microservices in Enterprise Distributed Application Service (EDAS). The resources include clusters, ECS instances, and applications. You can use a default or custom namespace. Each region has a default namespace and supports multiple custom namespaces. By default, only the default namespace is available. You do not need to create a custom namespace if you do not want to isolate resources or microservices.
 * *   **ECU**: After an ECS instance is imported to a cluster, the instance becomes an ECU.
 * *   **Elastic compute container (ECC)**: After you deploy an application to an ECU in a cluster, the ECU becomes an ECC.
 *
 * @param request MigrateEcuRequest
 * @return MigrateEcuResponse
 */
func (client *Client) MigrateEcu(request *MigrateEcuRequest) (_result *MigrateEcuResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &MigrateEcuResponse{}
	_body, _err := client.MigrateEcuWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyScalingRuleWithOptions(request *ModifyScalingRuleRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ModifyScalingRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptEULA)) {
		query["AcceptEULA"] = request.AcceptEULA
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.InCondition)) {
		query["InCondition"] = request.InCondition
	}

	if !tea.BoolValue(util.IsUnset(request.InCpu)) {
		query["InCpu"] = request.InCpu
	}

	if !tea.BoolValue(util.IsUnset(request.InDuration)) {
		query["InDuration"] = request.InDuration
	}

	if !tea.BoolValue(util.IsUnset(request.InEnable)) {
		query["InEnable"] = request.InEnable
	}

	if !tea.BoolValue(util.IsUnset(request.InInstanceNum)) {
		query["InInstanceNum"] = request.InInstanceNum
	}

	if !tea.BoolValue(util.IsUnset(request.InLoad)) {
		query["InLoad"] = request.InLoad
	}

	if !tea.BoolValue(util.IsUnset(request.InRT)) {
		query["InRT"] = request.InRT
	}

	if !tea.BoolValue(util.IsUnset(request.InStep)) {
		query["InStep"] = request.InStep
	}

	if !tea.BoolValue(util.IsUnset(request.KeyPairName)) {
		query["KeyPairName"] = request.KeyPairName
	}

	if !tea.BoolValue(util.IsUnset(request.MultiAzPolicy)) {
		query["MultiAzPolicy"] = request.MultiAzPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.OutCPU)) {
		query["OutCPU"] = request.OutCPU
	}

	if !tea.BoolValue(util.IsUnset(request.OutCondition)) {
		query["OutCondition"] = request.OutCondition
	}

	if !tea.BoolValue(util.IsUnset(request.OutDuration)) {
		query["OutDuration"] = request.OutDuration
	}

	if !tea.BoolValue(util.IsUnset(request.OutEnable)) {
		query["OutEnable"] = request.OutEnable
	}

	if !tea.BoolValue(util.IsUnset(request.OutInstanceNum)) {
		query["OutInstanceNum"] = request.OutInstanceNum
	}

	if !tea.BoolValue(util.IsUnset(request.OutLoad)) {
		query["OutLoad"] = request.OutLoad
	}

	if !tea.BoolValue(util.IsUnset(request.OutRT)) {
		query["OutRT"] = request.OutRT
	}

	if !tea.BoolValue(util.IsUnset(request.OutStep)) {
		query["OutStep"] = request.OutStep
	}

	if !tea.BoolValue(util.IsUnset(request.Password)) {
		query["Password"] = request.Password
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceFrom)) {
		query["ResourceFrom"] = request.ResourceFrom
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingPolicy)) {
		query["ScalingPolicy"] = request.ScalingPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		query["TemplateId"] = request.TemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateInstanceId)) {
		query["TemplateInstanceId"] = request.TemplateInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateInstanceName)) {
		query["TemplateInstanceName"] = request.TemplateInstanceName
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateVersion)) {
		query["TemplateVersion"] = request.TemplateVersion
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchIds)) {
		query["VSwitchIds"] = request.VSwitchIds
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyScalingRule"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/app/scaling_rules"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyScalingRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyScalingRule(request *ModifyScalingRuleRequest) (_result *ModifyScalingRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ModifyScalingRuleResponse{}
	_body, _err := client.ModifyScalingRuleWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryApplicationStatusWithOptions(request *QueryApplicationStatusRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *QueryApplicationStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryApplicationStatus"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/app/app_status"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryApplicationStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryApplicationStatus(request *QueryApplicationStatusRequest) (_result *QueryApplicationStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &QueryApplicationStatusResponse{}
	_body, _err := client.QueryApplicationStatusWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryEccInfoWithOptions(request *QueryEccInfoRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *QueryEccInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EccId)) {
		query["EccId"] = request.EccId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryEccInfo"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/ecc"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryEccInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryEccInfo(request *QueryEccInfoRequest) (_result *QueryEccInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &QueryEccInfoResponse{}
	_body, _err := client.QueryEccInfoWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryMigrateEcuListWithOptions(request *QueryMigrateEcuListRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *QueryMigrateEcuListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LogicalRegionId)) {
		query["LogicalRegionId"] = request.LogicalRegionId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryMigrateEcuList"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/resource/migrate_ecu_list"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryMigrateEcuListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryMigrateEcuList(request *QueryMigrateEcuListRequest) (_result *QueryMigrateEcuListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &QueryMigrateEcuListResponse{}
	_body, _err := client.QueryMigrateEcuListWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryMigrateRegionListWithOptions(request *QueryMigrateRegionListRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *QueryMigrateRegionListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LogicalRegionId)) {
		query["LogicalRegionId"] = request.LogicalRegionId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryMigrateRegionList"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/resource/migrate_region_select"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryMigrateRegionListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryMigrateRegionList(request *QueryMigrateRegionListRequest) (_result *QueryMigrateRegionListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &QueryMigrateRegionListResponse{}
	_body, _err := client.QueryMigrateRegionListWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryRegionConfigWithOptions(headers map[string]*string, runtime *util.RuntimeOptions) (_result *QueryRegionConfigResponse, _err error) {
	req := &openapi.OpenApiRequest{
		Headers: headers,
	}
	params := &openapi.Params{
		Action:      tea.String("QueryRegionConfig"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/region_config"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryRegionConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryRegionConfig() (_result *QueryRegionConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &QueryRegionConfigResponse{}
	_body, _err := client.QueryRegionConfigWithOptions(headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QuerySlsLogStoreListWithOptions(request *QuerySlsLogStoreListRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *QuerySlsLogStoreListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QuerySlsLogStoreList"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/sls/query_sls_log_store_list"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &QuerySlsLogStoreListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QuerySlsLogStoreList(request *QuerySlsLogStoreListRequest) (_result *QuerySlsLogStoreListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &QuerySlsLogStoreListResponse{}
	_body, _err := client.QuerySlsLogStoreListWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ResetApplicationWithOptions(request *ResetApplicationRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ResetApplicationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.EccInfo)) {
		query["EccInfo"] = request.EccInfo
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ResetApplication"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/changeorder/co_reset"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ResetApplicationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ResetApplication(request *ResetApplicationRequest) (_result *ResetApplicationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ResetApplicationResponse{}
	_body, _err := client.ResetApplicationWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RestartApplicationWithOptions(request *RestartApplicationRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *RestartApplicationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.EccInfo)) {
		query["EccInfo"] = request.EccInfo
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RestartApplication"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/changeorder/co_restart"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &RestartApplicationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RestartApplication(request *RestartApplicationRequest) (_result *RestartApplicationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &RestartApplicationResponse{}
	_body, _err := client.RestartApplicationWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RestartK8sApplicationWithOptions(request *RestartK8sApplicationRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *RestartK8sApplicationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.Timeout)) {
		query["Timeout"] = request.Timeout
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RestartK8sApplication"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/acs/restart_k8s_app"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &RestartK8sApplicationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RestartK8sApplication(request *RestartK8sApplicationRequest) (_result *RestartK8sApplicationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &RestartK8sApplicationResponse{}
	_body, _err := client.RestartK8sApplicationWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RetryChangeOrderTaskWithOptions(request *RetryChangeOrderTaskRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *RetryChangeOrderTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RetryStatus)) {
		query["RetryStatus"] = request.RetryStatus
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RetryChangeOrderTask"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/changeorder/task_retry"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &RetryChangeOrderTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RetryChangeOrderTask(request *RetryChangeOrderTaskRequest) (_result *RetryChangeOrderTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &RetryChangeOrderTaskResponse{}
	_body, _err := client.RetryChangeOrderTaskWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RollbackApplicationWithOptions(request *RollbackApplicationRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *RollbackApplicationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.Batch)) {
		query["Batch"] = request.Batch
	}

	if !tea.BoolValue(util.IsUnset(request.BatchWaitTime)) {
		query["BatchWaitTime"] = request.BatchWaitTime
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.HistoryVersion)) {
		query["HistoryVersion"] = request.HistoryVersion
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RollbackApplication"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/changeorder/co_rollback"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &RollbackApplicationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RollbackApplication(request *RollbackApplicationRequest) (_result *RollbackApplicationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &RollbackApplicationResponse{}
	_body, _err := client.RollbackApplicationWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RollbackChangeOrderWithOptions(request *RollbackChangeOrderRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *RollbackChangeOrderResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ChangeOrderId)) {
		query["ChangeOrderId"] = request.ChangeOrderId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RollbackChangeOrder"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/oam/changeorder/rollback"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &RollbackChangeOrderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RollbackChangeOrder(request *RollbackChangeOrderRequest) (_result *RollbackChangeOrderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &RollbackChangeOrderResponse{}
	_body, _err := client.RollbackChangeOrderWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ScaleInApplicationWithOptions(request *ScaleInApplicationRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ScaleInApplicationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.EccInfo)) {
		query["EccInfo"] = request.EccInfo
	}

	if !tea.BoolValue(util.IsUnset(request.ForceStatus)) {
		query["ForceStatus"] = request.ForceStatus
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ScaleInApplication"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/changeorder/co_scale_in"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ScaleInApplicationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ScaleInApplication(request *ScaleInApplicationRequest) (_result *ScaleInApplicationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ScaleInApplicationResponse{}
	_body, _err := client.ScaleInApplicationWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ScaleK8sApplicationWithOptions(request *ScaleK8sApplicationRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ScaleK8sApplicationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.Replicas)) {
		query["Replicas"] = request.Replicas
	}

	if !tea.BoolValue(util.IsUnset(request.Timeout)) {
		query["Timeout"] = request.Timeout
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ScaleK8sApplication"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/acs/k8s_apps"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ScaleK8sApplicationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ScaleK8sApplication(request *ScaleK8sApplicationRequest) (_result *ScaleK8sApplicationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ScaleK8sApplicationResponse{}
	_body, _err := client.ScaleK8sApplicationWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ScaleOutApplicationWithOptions(request *ScaleOutApplicationRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ScaleOutApplicationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.DeployGroup)) {
		query["DeployGroup"] = request.DeployGroup
	}

	if !tea.BoolValue(util.IsUnset(request.EcuInfo)) {
		query["EcuInfo"] = request.EcuInfo
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ScaleOutApplication"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/changeorder/co_scale_out"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ScaleOutApplicationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ScaleOutApplication(request *ScaleOutApplicationRequest) (_result *ScaleOutApplicationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ScaleOutApplicationResponse{}
	_body, _err := client.ScaleOutApplicationWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Assume that the auto scaling feature is configured and enabled for an application. When an auto scale-in is triggered for the application, the ECS instances that are purchased by calling this operation are removed first.
 *
 * @param request ScaleoutApplicationWithNewInstancesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ScaleoutApplicationWithNewInstancesResponse
 */
func (client *Client) ScaleoutApplicationWithNewInstancesWithOptions(request *ScaleoutApplicationWithNewInstancesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *ScaleoutApplicationWithNewInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AutoRenew)) {
		query["AutoRenew"] = request.AutoRenew
	}

	if !tea.BoolValue(util.IsUnset(request.AutoRenewPeriod)) {
		query["AutoRenewPeriod"] = request.AutoRenewPeriod
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceChargePeriod)) {
		query["InstanceChargePeriod"] = request.InstanceChargePeriod
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceChargePeriodUnit)) {
		query["InstanceChargePeriodUnit"] = request.InstanceChargePeriodUnit
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceChargeType)) {
		query["InstanceChargeType"] = request.InstanceChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingNum)) {
		query["ScalingNum"] = request.ScalingNum
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingPolicy)) {
		query["ScalingPolicy"] = request.ScalingPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		query["TemplateId"] = request.TemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateInstanceId)) {
		query["TemplateInstanceId"] = request.TemplateInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateVersion)) {
		query["TemplateVersion"] = request.TemplateVersion
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ScaleoutApplicationWithNewInstances"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/scaling/scale_out"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &ScaleoutApplicationWithNewInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Assume that the auto scaling feature is configured and enabled for an application. When an auto scale-in is triggered for the application, the ECS instances that are purchased by calling this operation are removed first.
 *
 * @param request ScaleoutApplicationWithNewInstancesRequest
 * @return ScaleoutApplicationWithNewInstancesResponse
 */
func (client *Client) ScaleoutApplicationWithNewInstances(request *ScaleoutApplicationWithNewInstancesRequest) (_result *ScaleoutApplicationWithNewInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &ScaleoutApplicationWithNewInstancesResponse{}
	_body, _err := client.ScaleoutApplicationWithNewInstancesWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) StartApplicationWithOptions(request *StartApplicationRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *StartApplicationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.EccInfo)) {
		query["EccInfo"] = request.EccInfo
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StartApplication"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/changeorder/co_start"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &StartApplicationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) StartApplication(request *StartApplicationRequest) (_result *StartApplicationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &StartApplicationResponse{}
	_body, _err := client.StartApplicationWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) StartK8sAppPrecheckWithOptions(request *StartK8sAppPrecheckRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *StartK8sAppPrecheckResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Annotations)) {
		query["Annotations"] = request.Annotations
	}

	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.ComponentIds)) {
		query["ComponentIds"] = request.ComponentIds
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigMountDescs)) {
		query["ConfigMountDescs"] = request.ConfigMountDescs
	}

	if !tea.BoolValue(util.IsUnset(request.EmptyDirs)) {
		query["EmptyDirs"] = request.EmptyDirs
	}

	if !tea.BoolValue(util.IsUnset(request.EnvFroms)) {
		query["EnvFroms"] = request.EnvFroms
	}

	if !tea.BoolValue(util.IsUnset(request.Envs)) {
		query["Envs"] = request.Envs
	}

	if !tea.BoolValue(util.IsUnset(request.ImageUrl)) {
		query["ImageUrl"] = request.ImageUrl
	}

	if !tea.BoolValue(util.IsUnset(request.JavaStartUpConfig)) {
		query["JavaStartUpConfig"] = request.JavaStartUpConfig
	}

	if !tea.BoolValue(util.IsUnset(request.Labels)) {
		query["Labels"] = request.Labels
	}

	if !tea.BoolValue(util.IsUnset(request.LimitEphemeralStorage)) {
		query["LimitEphemeralStorage"] = request.LimitEphemeralStorage
	}

	if !tea.BoolValue(util.IsUnset(request.LimitMem)) {
		query["LimitMem"] = request.LimitMem
	}

	if !tea.BoolValue(util.IsUnset(request.LimitmCpu)) {
		query["LimitmCpu"] = request.LimitmCpu
	}

	if !tea.BoolValue(util.IsUnset(request.LocalVolume)) {
		query["LocalVolume"] = request.LocalVolume
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.PackageUrl)) {
		query["PackageUrl"] = request.PackageUrl
	}

	if !tea.BoolValue(util.IsUnset(request.PvcMountDescs)) {
		query["PvcMountDescs"] = request.PvcMountDescs
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Replicas)) {
		query["Replicas"] = request.Replicas
	}

	if !tea.BoolValue(util.IsUnset(request.RequestsEphemeralStorage)) {
		query["RequestsEphemeralStorage"] = request.RequestsEphemeralStorage
	}

	if !tea.BoolValue(util.IsUnset(request.RequestsMem)) {
		query["RequestsMem"] = request.RequestsMem
	}

	if !tea.BoolValue(util.IsUnset(request.RequestsmCpu)) {
		query["RequestsmCpu"] = request.RequestsmCpu
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StartK8sAppPrecheck"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/app_precheck"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &StartK8sAppPrecheckResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) StartK8sAppPrecheck(request *StartK8sAppPrecheckRequest) (_result *StartK8sAppPrecheckResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &StartK8sAppPrecheckResponse{}
	_body, _err := client.StartK8sAppPrecheckWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) StartK8sApplicationWithOptions(request *StartK8sApplicationRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *StartK8sApplicationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.Replicas)) {
		query["Replicas"] = request.Replicas
	}

	if !tea.BoolValue(util.IsUnset(request.Timeout)) {
		query["Timeout"] = request.Timeout
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StartK8sApplication"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/acs/start_k8s_app"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &StartK8sApplicationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) StartK8sApplication(request *StartK8sApplicationRequest) (_result *StartK8sApplicationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &StartK8sApplicationResponse{}
	_body, _err := client.StartK8sApplicationWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) StopApplicationWithOptions(request *StopApplicationRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *StopApplicationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.EccInfo)) {
		query["EccInfo"] = request.EccInfo
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StopApplication"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/changeorder/co_stop"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &StopApplicationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) StopApplication(request *StopApplicationRequest) (_result *StopApplicationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &StopApplicationResponse{}
	_body, _err := client.StopApplicationWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) StopK8sApplicationWithOptions(request *StopK8sApplicationRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *StopK8sApplicationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.Timeout)) {
		query["Timeout"] = request.Timeout
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StopK8sApplication"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/acs/stop_k8s_app"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &StopK8sApplicationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) StopK8sApplication(request *StopK8sApplicationRequest) (_result *StopK8sApplicationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &StopK8sApplicationResponse{}
	_body, _err := client.StopK8sApplicationWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * To call the SwitchAdvancedMonitoring operation, you must make sure that the version of Enterprise Distributed Application Service (EDAS) SDK for Java or Python is 3.15.2 or later.
 *
 * @param request SwitchAdvancedMonitoringRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return SwitchAdvancedMonitoringResponse
 */
func (client *Client) SwitchAdvancedMonitoringWithOptions(request *SwitchAdvancedMonitoringRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *SwitchAdvancedMonitoringResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.EnableAdvancedMonitoring)) {
		query["EnableAdvancedMonitoring"] = request.EnableAdvancedMonitoring
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SwitchAdvancedMonitoring"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/monitor/advancedMonitorInfo"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &SwitchAdvancedMonitoringResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * To call the SwitchAdvancedMonitoring operation, you must make sure that the version of Enterprise Distributed Application Service (EDAS) SDK for Java or Python is 3.15.2 or later.
 *
 * @param request SwitchAdvancedMonitoringRequest
 * @return SwitchAdvancedMonitoringResponse
 */
func (client *Client) SwitchAdvancedMonitoring(request *SwitchAdvancedMonitoringRequest) (_result *SwitchAdvancedMonitoringResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &SwitchAdvancedMonitoringResponse{}
	_body, _err := client.SwitchAdvancedMonitoringWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If you call this operation to synchronize ECS resource information, all instance data is synchronized from ECS. If you have more than 100 ECS instances, we recommend that you do not frequently call this operation.
 *
 * @param request SynchronizeResourceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return SynchronizeResourceResponse
 */
func (client *Client) SynchronizeResourceWithOptions(request *SynchronizeResourceRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *SynchronizeResourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceIds)) {
		query["ResourceIds"] = request.ResourceIds
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SynchronizeResource"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/resource/pop_sync_resource"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &SynchronizeResourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If you call this operation to synchronize ECS resource information, all instance data is synchronized from ECS. If you have more than 100 ECS instances, we recommend that you do not frequently call this operation.
 *
 * @param request SynchronizeResourceRequest
 * @return SynchronizeResourceResponse
 */
func (client *Client) SynchronizeResource(request *SynchronizeResourceRequest) (_result *SynchronizeResourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &SynchronizeResourceResponse{}
	_body, _err := client.SynchronizeResourceWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) TagResourcesWithOptions(request *TagResourcesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *TagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceIds)) {
		query["ResourceIds"] = request.ResourceIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceRegionId)) {
		query["ResourceRegionId"] = request.ResourceRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("TagResources"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/tag/tags"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &TagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) TagResources(request *TagResourcesRequest) (_result *TagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &TagResourcesResponse{}
	_body, _err := client.TagResourcesWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * When you call this operation to import an ECS instance, the operating system of the ECS instance is reinstalled. After the operating system is reinstalled, all data of the ECS instance is deleted. You must set a logon password for the ECS instance. Make sure that no important data exists on or data has been backed up for the ECS instance that you want to import.
 *
 * @param request TransformClusterMemberRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return TransformClusterMemberResponse
 */
func (client *Client) TransformClusterMemberWithOptions(request *TransformClusterMemberRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *TransformClusterMemberResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceIds)) {
		query["InstanceIds"] = request.InstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.Password)) {
		query["Password"] = request.Password
	}

	if !tea.BoolValue(util.IsUnset(request.TargetClusterId)) {
		query["TargetClusterId"] = request.TargetClusterId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("TransformClusterMember"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/resource/transform_cluster_member"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &TransformClusterMemberResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * When you call this operation to import an ECS instance, the operating system of the ECS instance is reinstalled. After the operating system is reinstalled, all data of the ECS instance is deleted. You must set a logon password for the ECS instance. Make sure that no important data exists on or data has been backed up for the ECS instance that you want to import.
 *
 * @param request TransformClusterMemberRequest
 * @return TransformClusterMemberResponse
 */
func (client *Client) TransformClusterMember(request *TransformClusterMemberRequest) (_result *TransformClusterMemberResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &TransformClusterMemberResponse{}
	_body, _err := client.TransformClusterMemberWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UnbindK8sSlbWithOptions(request *UnbindK8sSlbRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UnbindK8sSlbResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.SlbName)) {
		query["SlbName"] = request.SlbName
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UnbindK8sSlb"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/acs/k8s_slb_binding"),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UnbindK8sSlbResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UnbindK8sSlb(request *UnbindK8sSlbRequest) (_result *UnbindK8sSlbResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UnbindK8sSlbResponse{}
	_body, _err := client.UnbindK8sSlbWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UnbindSlbWithOptions(request *UnbindSlbRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UnbindSlbResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.DeleteListener)) {
		query["DeleteListener"] = request.DeleteListener
	}

	if !tea.BoolValue(util.IsUnset(request.SlbId)) {
		query["SlbId"] = request.SlbId
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UnbindSlb"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/app/unbind_slb_json"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UnbindSlbResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UnbindSlb(request *UnbindSlbRequest) (_result *UnbindSlbResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UnbindSlbResponse{}
	_body, _err := client.UnbindSlbWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UntagResourcesWithOptions(request *UntagResourcesRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UntagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeleteAll)) {
		query["DeleteAll"] = request.DeleteAll
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceIds)) {
		query["ResourceIds"] = request.ResourceIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceRegionId)) {
		query["ResourceRegionId"] = request.ResourceRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TagKeys)) {
		query["TagKeys"] = request.TagKeys
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UntagResources"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/tag/tags"),
		Method:      tea.String("DELETE"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UntagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UntagResources(request *UntagResourcesRequest) (_result *UntagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UntagResourcesResponse{}
	_body, _err := client.UntagResourcesWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateAccountInfoWithOptions(request *UpdateAccountInfoRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateAccountInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Email)) {
		query["Email"] = request.Email
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Telephone)) {
		query["Telephone"] = request.Telephone
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAccountInfo"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/account/edit_account_info"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateAccountInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateAccountInfo(request *UpdateAccountInfoRequest) (_result *UpdateAccountInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateAccountInfoResponse{}
	_body, _err := client.UpdateAccountInfoWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateApplicationBaseInfoWithOptions(request *UpdateApplicationBaseInfoRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateApplicationBaseInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.Desc)) {
		query["Desc"] = request.Desc
	}

	if !tea.BoolValue(util.IsUnset(request.Owner)) {
		query["Owner"] = request.Owner
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateApplicationBaseInfo"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/app/update_app_info"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateApplicationBaseInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateApplicationBaseInfo(request *UpdateApplicationBaseInfoRequest) (_result *UpdateApplicationBaseInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateApplicationBaseInfoResponse{}
	_body, _err := client.UpdateApplicationBaseInfoWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateApplicationScalingRuleWithOptions(request *UpdateApplicationScalingRuleRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateApplicationScalingRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingBehaviour)) {
		query["ScalingBehaviour"] = request.ScalingBehaviour
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleEnable)) {
		query["ScalingRuleEnable"] = request.ScalingRuleEnable
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleMetric)) {
		query["ScalingRuleMetric"] = request.ScalingRuleMetric
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleName)) {
		query["ScalingRuleName"] = request.ScalingRuleName
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleTimer)) {
		query["ScalingRuleTimer"] = request.ScalingRuleTimer
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleTrigger)) {
		query["ScalingRuleTrigger"] = request.ScalingRuleTrigger
	}

	if !tea.BoolValue(util.IsUnset(request.ScalingRuleType)) {
		query["ScalingRuleType"] = request.ScalingRuleType
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateApplicationScalingRule"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v1/eam/scale/application_scaling_rule"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateApplicationScalingRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateApplicationScalingRule(request *UpdateApplicationScalingRuleRequest) (_result *UpdateApplicationScalingRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateApplicationScalingRuleResponse{}
	_body, _err := client.UpdateApplicationScalingRuleWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateConfigTemplateWithOptions(request *UpdateConfigTemplateRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateConfigTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Content)) {
		body["Content"] = request.Content
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Format)) {
		body["Format"] = request.Format
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		body["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateConfigTemplate"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/config_template"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateConfigTemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateConfigTemplate(request *UpdateConfigTemplateRequest) (_result *UpdateConfigTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateConfigTemplateResponse{}
	_body, _err := client.UpdateConfigTemplateWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateContainerWithOptions(request *UpdateContainerRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateContainerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.BuildPackId)) {
		query["BuildPackId"] = request.BuildPackId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateContainer"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/changeorder/co_update_container"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateContainerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateContainer(request *UpdateContainerRequest) (_result *UpdateContainerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateContainerResponse{}
	_body, _err := client.UpdateContainerWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateContainerConfigurationWithOptions(request *UpdateContainerConfigurationRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateContainerConfigurationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.ContextPath)) {
		query["ContextPath"] = request.ContextPath
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.HttpPort)) {
		query["HttpPort"] = request.HttpPort
	}

	if !tea.BoolValue(util.IsUnset(request.MaxThreads)) {
		query["MaxThreads"] = request.MaxThreads
	}

	if !tea.BoolValue(util.IsUnset(request.URIEncoding)) {
		query["URIEncoding"] = request.URIEncoding
	}

	if !tea.BoolValue(util.IsUnset(request.UseBodyEncoding)) {
		query["UseBodyEncoding"] = request.UseBodyEncoding
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateContainerConfiguration"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/app/container_config"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateContainerConfigurationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateContainerConfiguration(request *UpdateContainerConfigurationRequest) (_result *UpdateContainerConfigurationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateContainerConfigurationResponse{}
	_body, _err := client.UpdateContainerConfigurationWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateHealthCheckUrlWithOptions(request *UpdateHealthCheckUrlRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateHealthCheckUrlResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.HcURL)) {
		query["hcURL"] = request.HcURL
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateHealthCheckUrl"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/app/modify_hc_url"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateHealthCheckUrlResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateHealthCheckUrl(request *UpdateHealthCheckUrlRequest) (_result *UpdateHealthCheckUrlResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateHealthCheckUrlResponse{}
	_body, _err := client.UpdateHealthCheckUrlWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateHookConfigurationWithOptions(request *UpdateHookConfigurationRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateHookConfigurationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Hooks)) {
		query["Hooks"] = request.Hooks
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateHookConfiguration"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/app/config_app_hook_json"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateHookConfigurationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateHookConfiguration(request *UpdateHookConfigurationRequest) (_result *UpdateHookConfigurationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateHookConfigurationResponse{}
	_body, _err := client.UpdateHookConfigurationWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateJvmConfigurationWithOptions(request *UpdateJvmConfigurationRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateJvmConfigurationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.MaxHeapSize)) {
		query["MaxHeapSize"] = request.MaxHeapSize
	}

	if !tea.BoolValue(util.IsUnset(request.MaxPermSize)) {
		query["MaxPermSize"] = request.MaxPermSize
	}

	if !tea.BoolValue(util.IsUnset(request.MinHeapSize)) {
		query["MinHeapSize"] = request.MinHeapSize
	}

	if !tea.BoolValue(util.IsUnset(request.Options)) {
		query["Options"] = request.Options
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateJvmConfiguration"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/app/app_jvm_config"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateJvmConfigurationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateJvmConfiguration(request *UpdateJvmConfigurationRequest) (_result *UpdateJvmConfigurationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateJvmConfigurationResponse{}
	_body, _err := client.UpdateJvmConfigurationWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateK8sApplicationBaseInfoWithOptions(request *UpdateK8sApplicationBaseInfoRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateK8sApplicationBaseInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Email)) {
		query["Email"] = request.Email
	}

	if !tea.BoolValue(util.IsUnset(request.Owner)) {
		query["Owner"] = request.Owner
	}

	if !tea.BoolValue(util.IsUnset(request.PhoneNumber)) {
		query["PhoneNumber"] = request.PhoneNumber
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateK8sApplicationBaseInfo"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/oam/update_app_basic_info"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateK8sApplicationBaseInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateK8sApplicationBaseInfo(request *UpdateK8sApplicationBaseInfoRequest) (_result *UpdateK8sApplicationBaseInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateK8sApplicationBaseInfoResponse{}
	_body, _err := client.UpdateK8sApplicationBaseInfoWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateK8sApplicationConfigWithOptions(request *UpdateK8sApplicationConfigRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateK8sApplicationConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.CpuLimit)) {
		query["CpuLimit"] = request.CpuLimit
	}

	if !tea.BoolValue(util.IsUnset(request.CpuRequest)) {
		query["CpuRequest"] = request.CpuRequest
	}

	if !tea.BoolValue(util.IsUnset(request.EphemeralStorageLimit)) {
		query["EphemeralStorageLimit"] = request.EphemeralStorageLimit
	}

	if !tea.BoolValue(util.IsUnset(request.EphemeralStorageRequest)) {
		query["EphemeralStorageRequest"] = request.EphemeralStorageRequest
	}

	if !tea.BoolValue(util.IsUnset(request.McpuLimit)) {
		query["McpuLimit"] = request.McpuLimit
	}

	if !tea.BoolValue(util.IsUnset(request.McpuRequest)) {
		query["McpuRequest"] = request.McpuRequest
	}

	if !tea.BoolValue(util.IsUnset(request.MemoryLimit)) {
		query["MemoryLimit"] = request.MemoryLimit
	}

	if !tea.BoolValue(util.IsUnset(request.MemoryRequest)) {
		query["MemoryRequest"] = request.MemoryRequest
	}

	if !tea.BoolValue(util.IsUnset(request.Timeout)) {
		query["Timeout"] = request.Timeout
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateK8sApplicationConfig"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/acs/k8s_app_configuration"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateK8sApplicationConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateK8sApplicationConfig(request *UpdateK8sApplicationConfigRequest) (_result *UpdateK8sApplicationConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateK8sApplicationConfigResponse{}
	_body, _err := client.UpdateK8sApplicationConfigWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateK8sConfigMapWithOptions(request *UpdateK8sConfigMapRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateK8sConfigMapResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		body["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Data)) {
		body["Data"] = request.Data
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		body["Namespace"] = request.Namespace
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateK8sConfigMap"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/acs/k8s_config_map"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateK8sConfigMapResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateK8sConfigMap(request *UpdateK8sConfigMapRequest) (_result *UpdateK8sConfigMapResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateK8sConfigMapResponse{}
	_body, _err := client.UpdateK8sConfigMapWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateK8sIngressRuleWithOptions(request *UpdateK8sIngressRuleRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateK8sIngressRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Annotations)) {
		query["Annotations"] = request.Annotations
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.IngressConf)) {
		query["IngressConf"] = request.IngressConf
	}

	if !tea.BoolValue(util.IsUnset(request.Labels)) {
		query["Labels"] = request.Labels
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		query["Namespace"] = request.Namespace
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateK8sIngressRule"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/acs/k8s_ingress"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateK8sIngressRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateK8sIngressRule(request *UpdateK8sIngressRuleRequest) (_result *UpdateK8sIngressRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateK8sIngressRuleResponse{}
	_body, _err := client.UpdateK8sIngressRuleWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can update only Deployments.
 *
 * @param request UpdateK8sResourceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateK8sResourceResponse
 */
func (client *Client) UpdateK8sResourceWithOptions(request *UpdateK8sResourceRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateK8sResourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		body["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		body["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceContent)) {
		body["ResourceContent"] = request.ResourceContent
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateK8sResource"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/oam/update_k8s_resource_config"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateK8sResourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can update only Deployments.
 *
 * @param request UpdateK8sResourceRequest
 * @return UpdateK8sResourceResponse
 */
func (client *Client) UpdateK8sResource(request *UpdateK8sResourceRequest) (_result *UpdateK8sResourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateK8sResourceResponse{}
	_body, _err := client.UpdateK8sResourceWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateK8sSecretWithOptions(request *UpdateK8sSecretRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateK8sSecretResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Base64Encoded)) {
		body["Base64Encoded"] = request.Base64Encoded
	}

	if !tea.BoolValue(util.IsUnset(request.CertId)) {
		body["CertId"] = request.CertId
	}

	if !tea.BoolValue(util.IsUnset(request.CertRegionId)) {
		body["CertRegionId"] = request.CertRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		body["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.Data)) {
		body["Data"] = request.Data
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Namespace)) {
		body["Namespace"] = request.Namespace
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		body["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateK8sSecret"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/acs/k8s_secret"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateK8sSecretResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateK8sSecret(request *UpdateK8sSecretRequest) (_result *UpdateK8sSecretResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateK8sSecretResponse{}
	_body, _err := client.UpdateK8sSecretWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateK8sServiceWithOptions(request *UpdateK8sServiceRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateK8sServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.ExternalTrafficPolicy)) {
		query["ExternalTrafficPolicy"] = request.ExternalTrafficPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.ServicePorts)) {
		query["ServicePorts"] = request.ServicePorts
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateK8sService"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/acs/k8s_service"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateK8sServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateK8sService(request *UpdateK8sServiceRequest) (_result *UpdateK8sServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateK8sServiceResponse{}
	_body, _err := client.UpdateK8sServiceWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateK8sSlbWithOptions(request *UpdateK8sSlbRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateK8sSlbResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.DisableForceOverride)) {
		query["DisableForceOverride"] = request.DisableForceOverride
	}

	if !tea.BoolValue(util.IsUnset(request.Port)) {
		query["Port"] = request.Port
	}

	if !tea.BoolValue(util.IsUnset(request.Scheduler)) {
		query["Scheduler"] = request.Scheduler
	}

	if !tea.BoolValue(util.IsUnset(request.ServicePortInfos)) {
		query["ServicePortInfos"] = request.ServicePortInfos
	}

	if !tea.BoolValue(util.IsUnset(request.SlbName)) {
		query["SlbName"] = request.SlbName
	}

	if !tea.BoolValue(util.IsUnset(request.SlbProtocol)) {
		query["SlbProtocol"] = request.SlbProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.Specification)) {
		query["Specification"] = request.Specification
	}

	if !tea.BoolValue(util.IsUnset(request.TargetPort)) {
		query["TargetPort"] = request.TargetPort
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateK8sSlb"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/acs/k8s_slb_binding"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateK8sSlbResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateK8sSlb(request *UpdateK8sSlbRequest) (_result *UpdateK8sSlbResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateK8sSlbResponse{}
	_body, _err := client.UpdateK8sSlbWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateRoleWithOptions(request *UpdateRoleRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateRoleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ActionData)) {
		query["ActionData"] = request.ActionData
	}

	if !tea.BoolValue(util.IsUnset(request.RoleId)) {
		query["RoleId"] = request.RoleId
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateRole"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/account/edit_role"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateRoleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateRole(request *UpdateRoleRequest) (_result *UpdateRoleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateRoleResponse{}
	_body, _err := client.UpdateRoleWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateSlsLogStoreWithOptions(request *UpdateSlsLogStoreRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateSlsLogStoreResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		body["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.Configs)) {
		body["Configs"] = request.Configs
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Body:    openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateSlsLogStore"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/k8s/sls/update_sls_log_store"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateSlsLogStoreResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateSlsLogStore(request *UpdateSlsLogStoreRequest) (_result *UpdateSlsLogStoreResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateSlsLogStoreResponse{}
	_body, _err := client.UpdateSlsLogStoreWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateSwimmingLaneWithOptions(request *UpdateSwimmingLaneRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateSwimmingLaneResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppInfos)) {
		query["AppInfos"] = request.AppInfos
	}

	if !tea.BoolValue(util.IsUnset(request.EnableRules)) {
		query["EnableRules"] = request.EnableRules
	}

	if !tea.BoolValue(util.IsUnset(request.EntryRules)) {
		query["EntryRules"] = request.EntryRules
	}

	if !tea.BoolValue(util.IsUnset(request.LaneId)) {
		query["LaneId"] = request.LaneId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateSwimmingLane"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/trafficmgnt/swimming_lanes"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateSwimmingLaneResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateSwimmingLane(request *UpdateSwimmingLaneRequest) (_result *UpdateSwimmingLaneResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateSwimmingLaneResponse{}
	_body, _err := client.UpdateSwimmingLaneWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateSwimmingLaneGroupWithOptions(request *UpdateSwimmingLaneGroupRequest, headers map[string]*string, runtime *util.RuntimeOptions) (_result *UpdateSwimmingLaneGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppIds)) {
		query["AppIds"] = request.AppIds
	}

	if !tea.BoolValue(util.IsUnset(request.EntryApp)) {
		query["EntryApp"] = request.EntryApp
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		Headers: headers,
		Query:   openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateSwimmingLaneGroup"),
		Version:     tea.String("2017-08-01"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/pop/v5/trafficmgnt/swimming_lane_groups"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("ROA"),
		ReqBodyType: tea.String("json"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateSwimmingLaneGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateSwimmingLaneGroup(request *UpdateSwimmingLaneGroupRequest) (_result *UpdateSwimmingLaneGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	headers := make(map[string]*string)
	_result = &UpdateSwimmingLaneGroupResponse{}
	_body, _err := client.UpdateSwimmingLaneGroupWithOptions(request, headers, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}
