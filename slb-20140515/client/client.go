// This file is auto-generated, don't edit it. Thanks.
/**
 *
 */
package client

import (
	openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
	endpointutil "github.com/alibabacloud-go/endpoint-util/service"
	openapiutil "github.com/alibabacloud-go/openapi-util/service"
	util "github.com/alibabacloud-go/tea-utils/v2/service"
	"github.com/alibabacloud-go/tea/tea"
)

type AddAccessControlListEntryRequest struct {
	// The configuration of the network ACL. Valid values:
	//
	// *   **entry**: the IP entries that you want to add to the network ACL. You can add CIDR blocks. Separate multiple CIDR blocks with commas (,).
	// *   **comment**: the comment on the network ACL.
	//
	// > You can add at most 50 IP entries to a network ACL in each call. If the IP entry that you want to add to a network ACL already exists, the IP entry is not added. The IP entries that you add must be CIDR blocks.
	AclEntrys *string `json:"AclEntrys,omitempty" xml:"AclEntrys,omitempty"`
	// The ID of the network ACL.
	AclId        *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the network ACL.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s AddAccessControlListEntryRequest) String() string {
	return tea.Prettify(s)
}

func (s AddAccessControlListEntryRequest) GoString() string {
	return s.String()
}

func (s *AddAccessControlListEntryRequest) SetAclEntrys(v string) *AddAccessControlListEntryRequest {
	s.AclEntrys = &v
	return s
}

func (s *AddAccessControlListEntryRequest) SetAclId(v string) *AddAccessControlListEntryRequest {
	s.AclId = &v
	return s
}

func (s *AddAccessControlListEntryRequest) SetOwnerAccount(v string) *AddAccessControlListEntryRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AddAccessControlListEntryRequest) SetOwnerId(v int64) *AddAccessControlListEntryRequest {
	s.OwnerId = &v
	return s
}

func (s *AddAccessControlListEntryRequest) SetRegionId(v string) *AddAccessControlListEntryRequest {
	s.RegionId = &v
	return s
}

func (s *AddAccessControlListEntryRequest) SetResourceOwnerAccount(v string) *AddAccessControlListEntryRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AddAccessControlListEntryRequest) SetResourceOwnerId(v int64) *AddAccessControlListEntryRequest {
	s.ResourceOwnerId = &v
	return s
}

type AddAccessControlListEntryResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddAccessControlListEntryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddAccessControlListEntryResponseBody) GoString() string {
	return s.String()
}

func (s *AddAccessControlListEntryResponseBody) SetRequestId(v string) *AddAccessControlListEntryResponseBody {
	s.RequestId = &v
	return s
}

type AddAccessControlListEntryResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddAccessControlListEntryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddAccessControlListEntryResponse) String() string {
	return tea.Prettify(s)
}

func (s AddAccessControlListEntryResponse) GoString() string {
	return s.String()
}

func (s *AddAccessControlListEntryResponse) SetHeaders(v map[string]*string) *AddAccessControlListEntryResponse {
	s.Headers = v
	return s
}

func (s *AddAccessControlListEntryResponse) SetStatusCode(v int32) *AddAccessControlListEntryResponse {
	s.StatusCode = &v
	return s
}

func (s *AddAccessControlListEntryResponse) SetBody(v *AddAccessControlListEntryResponseBody) *AddAccessControlListEntryResponse {
	s.Body = v
	return s
}

type AddBackendServersRequest struct {
	// The description of the backend server.
	BackendServers *string `json:"BackendServers,omitempty" xml:"BackendServers,omitempty"`
	// The ID of the CLB instance.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The list of backend servers that you want to add. Set the following parameters:
	//
	// *   **ServerId**: Required. This value must be a string. Enter the ID of an ECS instance, elastic network interface (ENI), or elastic container instance. If **ServerId** is set to the ID of an ENI or elastic container instance, **Type** is required.
	//
	// *   **Weight**: the weight of the backend server. Valid values: **0** to **100**. Default value: **100**.
	//
	//     If the value is set to 0, no requests are forwarded to the backend server.
	//
	// *   **Description**: Optional. The description of the backend server. This value must be a string. The description must be 1 to 80 characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.), and underscores (\_).
	//
	// *   **Type**: the type of the backend server. Valid values:
	//
	//     *   **ecs** (default): an ECS instance
	//     *   **eni**: an ENI
	//     *   **eci**: an elastic container instance
	//
	// >  You can specify ENIs and elastic container instances as the backend servers only for high-performance CLB instances.
	//
	// *   **ServerIp**: the IP address of the ECS instance, ENI, or elastic container instance
	// *   **Port**: the backend port
	//
	// Examples:
	//
	// *   ECS instance: `[{ "ServerId": "i-xxxxxxxxx", "Weight": "100", "Type": "ecs", "Port":"80","Description":"test-112" }]`
	// *   ENI: `[{ "ServerId": "eni-xxxxxxxxx", "Weight": "100", "Type": "eni", "ServerIp": "192.168.**.**", "Port":"80","Description":"test-112" }]`
	// *   ENI with multiple IP addresses: `[{ "ServerId": "eni-xxxxxxxxx", "Weight": "100", "Type": "eni", "ServerIp": "192.168.**.**", "Port":"80","Description":"test-113" },{ "ServerId": "eni-xxxxxxxxx", "Weight": "100", "Type": "eni", "ServerIp": "172.166.**.**", "Port":"80","Description":"test-113" }]`
	// *   Elastic container instance: `[{ "ServerId": "eci-xxxxxxxxx", "Weight": "100", "Type": "eci", "ServerIp": "192.168.**.**", "Port":"80","Description":"test-114" }]`
	//
	// >  The backend servers that you add to a CLB instance must be in the Running state. You can add at most 20 backend servers to a CLB instance in each request.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s AddBackendServersRequest) String() string {
	return tea.Prettify(s)
}

func (s AddBackendServersRequest) GoString() string {
	return s.String()
}

func (s *AddBackendServersRequest) SetBackendServers(v string) *AddBackendServersRequest {
	s.BackendServers = &v
	return s
}

func (s *AddBackendServersRequest) SetLoadBalancerId(v string) *AddBackendServersRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *AddBackendServersRequest) SetOwnerAccount(v string) *AddBackendServersRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AddBackendServersRequest) SetOwnerId(v int64) *AddBackendServersRequest {
	s.OwnerId = &v
	return s
}

func (s *AddBackendServersRequest) SetRegionId(v string) *AddBackendServersRequest {
	s.RegionId = &v
	return s
}

func (s *AddBackendServersRequest) SetResourceOwnerAccount(v string) *AddBackendServersRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AddBackendServersRequest) SetResourceOwnerId(v int64) *AddBackendServersRequest {
	s.ResourceOwnerId = &v
	return s
}

type AddBackendServersResponseBody struct {
	// The ID of the request.
	BackendServers *AddBackendServersResponseBodyBackendServers `json:"BackendServers,omitempty" xml:"BackendServers,omitempty" type:"Struct"`
	// The type of the backend server. Valid values:
	//
	// *   **ecs** (default): an ECS instance
	// *   **eni**: an ENI
	// *   **eci**: an elastic container instance
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// The list of backend servers.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddBackendServersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddBackendServersResponseBody) GoString() string {
	return s.String()
}

func (s *AddBackendServersResponseBody) SetBackendServers(v *AddBackendServersResponseBodyBackendServers) *AddBackendServersResponseBody {
	s.BackendServers = v
	return s
}

func (s *AddBackendServersResponseBody) SetLoadBalancerId(v string) *AddBackendServersResponseBody {
	s.LoadBalancerId = &v
	return s
}

func (s *AddBackendServersResponseBody) SetRequestId(v string) *AddBackendServersResponseBody {
	s.RequestId = &v
	return s
}

type AddBackendServersResponseBodyBackendServers struct {
	BackendServer []*AddBackendServersResponseBodyBackendServersBackendServer `json:"BackendServer,omitempty" xml:"BackendServer,omitempty" type:"Repeated"`
}

func (s AddBackendServersResponseBodyBackendServers) String() string {
	return tea.Prettify(s)
}

func (s AddBackendServersResponseBodyBackendServers) GoString() string {
	return s.String()
}

func (s *AddBackendServersResponseBodyBackendServers) SetBackendServer(v []*AddBackendServersResponseBodyBackendServersBackendServer) *AddBackendServersResponseBodyBackendServers {
	s.BackendServer = v
	return s
}

type AddBackendServersResponseBodyBackendServersBackendServer struct {
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	ServerId    *string `json:"ServerId,omitempty" xml:"ServerId,omitempty"`
	// The ID of the region where the Classic Load Balancer (CLB) instance is deployed.
	//
	// You can call the [DescribeRegions](~~27584~~) operation to query the most recent region list.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// Adds backend servers.
	Weight *string `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s AddBackendServersResponseBodyBackendServersBackendServer) String() string {
	return tea.Prettify(s)
}

func (s AddBackendServersResponseBodyBackendServersBackendServer) GoString() string {
	return s.String()
}

func (s *AddBackendServersResponseBodyBackendServersBackendServer) SetDescription(v string) *AddBackendServersResponseBodyBackendServersBackendServer {
	s.Description = &v
	return s
}

func (s *AddBackendServersResponseBodyBackendServersBackendServer) SetServerId(v string) *AddBackendServersResponseBodyBackendServersBackendServer {
	s.ServerId = &v
	return s
}

func (s *AddBackendServersResponseBodyBackendServersBackendServer) SetType(v string) *AddBackendServersResponseBodyBackendServersBackendServer {
	s.Type = &v
	return s
}

func (s *AddBackendServersResponseBodyBackendServersBackendServer) SetWeight(v string) *AddBackendServersResponseBodyBackendServersBackendServer {
	s.Weight = &v
	return s
}

type AddBackendServersResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddBackendServersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddBackendServersResponse) String() string {
	return tea.Prettify(s)
}

func (s AddBackendServersResponse) GoString() string {
	return s.String()
}

func (s *AddBackendServersResponse) SetHeaders(v map[string]*string) *AddBackendServersResponse {
	s.Headers = v
	return s
}

func (s *AddBackendServersResponse) SetStatusCode(v int32) *AddBackendServersResponse {
	s.StatusCode = &v
	return s
}

func (s *AddBackendServersResponse) SetBody(v *AddBackendServersResponseBody) *AddBackendServersResponse {
	s.Body = v
	return s
}

type AddListenerWhiteListItemRequest struct {
	// The frontend protocol that is used by the CLB instance.
	//
	// >  This parameter is required when listeners that use different protocols listen on the same port.
	ListenerPort     *int32  `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	ListenerProtocol *string `json:"ListenerProtocol,omitempty" xml:"ListenerProtocol,omitempty"`
	// The ID of the region where the Classic Load Balancer (CLB) instance is created.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The IP addresses or CIDR blocks that you want to add to the whitelist.
	//
	// This parameter takes effect when the **AccessControlStatus** parameter of the listener is set to **open_white_list**.
	//
	// Separate multiple IP addresses or CIDR blocks with commas (,).
	//
	// You cannot enter **0.0.0.0** or **0.0.0.0/0**. To disable access control, you can call the [SetListenerAccessControlStatus](~~27599~~) operation to set the value of the **AccessControlStatus** parameter to **close**.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	SourceItems          *string `json:"SourceItems,omitempty" xml:"SourceItems,omitempty"`
}

func (s AddListenerWhiteListItemRequest) String() string {
	return tea.Prettify(s)
}

func (s AddListenerWhiteListItemRequest) GoString() string {
	return s.String()
}

func (s *AddListenerWhiteListItemRequest) SetListenerPort(v int32) *AddListenerWhiteListItemRequest {
	s.ListenerPort = &v
	return s
}

func (s *AddListenerWhiteListItemRequest) SetListenerProtocol(v string) *AddListenerWhiteListItemRequest {
	s.ListenerProtocol = &v
	return s
}

func (s *AddListenerWhiteListItemRequest) SetLoadBalancerId(v string) *AddListenerWhiteListItemRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *AddListenerWhiteListItemRequest) SetOwnerAccount(v string) *AddListenerWhiteListItemRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AddListenerWhiteListItemRequest) SetOwnerId(v int64) *AddListenerWhiteListItemRequest {
	s.OwnerId = &v
	return s
}

func (s *AddListenerWhiteListItemRequest) SetRegionId(v string) *AddListenerWhiteListItemRequest {
	s.RegionId = &v
	return s
}

func (s *AddListenerWhiteListItemRequest) SetResourceOwnerAccount(v string) *AddListenerWhiteListItemRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AddListenerWhiteListItemRequest) SetResourceOwnerId(v int64) *AddListenerWhiteListItemRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *AddListenerWhiteListItemRequest) SetSourceItems(v string) *AddListenerWhiteListItemRequest {
	s.SourceItems = &v
	return s
}

type AddListenerWhiteListItemResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddListenerWhiteListItemResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddListenerWhiteListItemResponseBody) GoString() string {
	return s.String()
}

func (s *AddListenerWhiteListItemResponseBody) SetRequestId(v string) *AddListenerWhiteListItemResponseBody {
	s.RequestId = &v
	return s
}

type AddListenerWhiteListItemResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddListenerWhiteListItemResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddListenerWhiteListItemResponse) String() string {
	return tea.Prettify(s)
}

func (s AddListenerWhiteListItemResponse) GoString() string {
	return s.String()
}

func (s *AddListenerWhiteListItemResponse) SetHeaders(v map[string]*string) *AddListenerWhiteListItemResponse {
	s.Headers = v
	return s
}

func (s *AddListenerWhiteListItemResponse) SetStatusCode(v int32) *AddListenerWhiteListItemResponse {
	s.StatusCode = &v
	return s
}

func (s *AddListenerWhiteListItemResponse) SetBody(v *AddListenerWhiteListItemResponseBody) *AddListenerWhiteListItemResponse {
	s.Body = v
	return s
}

type AddTagsRequest struct {
	// A list of tags to be added.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the SLB instance.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the request.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s AddTagsRequest) String() string {
	return tea.Prettify(s)
}

func (s AddTagsRequest) GoString() string {
	return s.String()
}

func (s *AddTagsRequest) SetLoadBalancerId(v string) *AddTagsRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *AddTagsRequest) SetOwnerAccount(v string) *AddTagsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AddTagsRequest) SetOwnerId(v int64) *AddTagsRequest {
	s.OwnerId = &v
	return s
}

func (s *AddTagsRequest) SetRegionId(v string) *AddTagsRequest {
	s.RegionId = &v
	return s
}

func (s *AddTagsRequest) SetResourceOwnerAccount(v string) *AddTagsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AddTagsRequest) SetResourceOwnerId(v int64) *AddTagsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *AddTagsRequest) SetTags(v string) *AddTagsRequest {
	s.Tags = &v
	return s
}

type AddTagsResponseBody struct {
	// # Limits
	//
	// Before you call this API, note the following limits:
	//
	// *   You can add up to 10 tags to each SLB instance.
	// *   You can add up to five pairs of tags at a time.
	// *   All the tags and keys added to an SLB instance must be unique.
	// *   If you add a tag of which the key is the same as that of an existing tag, but the value is different, the new tag overwrites the existing one.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddTagsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddTagsResponseBody) GoString() string {
	return s.String()
}

func (s *AddTagsResponseBody) SetRequestId(v string) *AddTagsResponseBody {
	s.RequestId = &v
	return s
}

type AddTagsResponse struct {
	Headers    map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddTagsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddTagsResponse) String() string {
	return tea.Prettify(s)
}

func (s AddTagsResponse) GoString() string {
	return s.String()
}

func (s *AddTagsResponse) SetHeaders(v map[string]*string) *AddTagsResponse {
	s.Headers = v
	return s
}

func (s *AddTagsResponse) SetStatusCode(v int32) *AddTagsResponse {
	s.StatusCode = &v
	return s
}

func (s *AddTagsResponse) SetBody(v *AddTagsResponseBody) *AddTagsResponse {
	s.Body = v
	return s
}

type AddVServerGroupBackendServersRequest struct {
	// The ID of the server group.
	BackendServers *string `json:"BackendServers,omitempty" xml:"BackendServers,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the server group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The list of backend servers. You can specify up to 20 backend servers in each request.
	//
	// The following parameters are used to specify the backend servers:
	//
	// *   **ServerId**: The ID of the backend server. You can specify the ID of an Elastic Compute Service (ECS) instance or an elastic network interface (ENI).
	//
	// *   **Port**: Required. The port that is used by the backend server. Valid values: **1 to 65535**.
	//
	// *   **Weight**: The weight of the backend server. Valid values: **0** to **100**. Default value: **100**. If the value is set to 0, no requests are forwarded to the backend server.
	//
	// *   **Type**: The type of backend server. Valid values:
	//
	//     *   **ecs**: an ECS instance. This is the default value.
	//     *   **eni**: an ENI.
	//
	// *   **Description**: Optional. The description of the backend server. This parameter is of the STRING type. The description must be 1 to 80 characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.), and underscores (\_).
	//
	// *   **ServerIp**: The IP address of the ECS instance or ENI.
	//
	// Examples:
	//
	// *   ECS instance:`  [{ "ServerId": "i-xxxxxxxxx", "Weight": "100", "Type": "ecs", "Port": "80", "Description": "test-112" }]. `
	// *   ENI:`  [{ "ServerId": "eni-xxxxxxxxx", "Weight": "100", "Type": "eni", "ServerIp": "192.168. **. **", "Port":"80","Description":"test-112" }] `
	// *   ENI with multiple IP addresses:`  [{ "ServerId": "eni-xxxxxxxxx", "Weight": "100", "Type": "eni", "ServerIp": "192.168. **. **", "Port":"80","Description":"test-112" },{ "ServerId": "eni-xxxxxxxxx", "Weight": "100", "Type": "eni", "ServerIp": "172.166. **. **", "Port":"80","Description":"test-113" }] `
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
}

func (s AddVServerGroupBackendServersRequest) String() string {
	return tea.Prettify(s)
}

func (s AddVServerGroupBackendServersRequest) GoString() string {
	return s.String()
}

func (s *AddVServerGroupBackendServersRequest) SetBackendServers(v string) *AddVServerGroupBackendServersRequest {
	s.BackendServers = &v
	return s
}

func (s *AddVServerGroupBackendServersRequest) SetOwnerAccount(v string) *AddVServerGroupBackendServersRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AddVServerGroupBackendServersRequest) SetOwnerId(v int64) *AddVServerGroupBackendServersRequest {
	s.OwnerId = &v
	return s
}

func (s *AddVServerGroupBackendServersRequest) SetRegionId(v string) *AddVServerGroupBackendServersRequest {
	s.RegionId = &v
	return s
}

func (s *AddVServerGroupBackendServersRequest) SetResourceOwnerAccount(v string) *AddVServerGroupBackendServersRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AddVServerGroupBackendServersRequest) SetResourceOwnerId(v int64) *AddVServerGroupBackendServersRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *AddVServerGroupBackendServersRequest) SetVServerGroupId(v string) *AddVServerGroupBackendServersRequest {
	s.VServerGroupId = &v
	return s
}

type AddVServerGroupBackendServersResponseBody struct {
	// The type of backend server. Valid values:
	//
	// *   **ecs**: an ECS instance. This is the default value.
	// *   **eni**: an ENI.
	BackendServers *AddVServerGroupBackendServersResponseBodyBackendServers `json:"BackendServers,omitempty" xml:"BackendServers,omitempty" type:"Struct"`
	// The list of backend servers.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the request.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
}

func (s AddVServerGroupBackendServersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddVServerGroupBackendServersResponseBody) GoString() string {
	return s.String()
}

func (s *AddVServerGroupBackendServersResponseBody) SetBackendServers(v *AddVServerGroupBackendServersResponseBodyBackendServers) *AddVServerGroupBackendServersResponseBody {
	s.BackendServers = v
	return s
}

func (s *AddVServerGroupBackendServersResponseBody) SetRequestId(v string) *AddVServerGroupBackendServersResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddVServerGroupBackendServersResponseBody) SetVServerGroupId(v string) *AddVServerGroupBackendServersResponseBody {
	s.VServerGroupId = &v
	return s
}

type AddVServerGroupBackendServersResponseBodyBackendServers struct {
	BackendServer []*AddVServerGroupBackendServersResponseBodyBackendServersBackendServer `json:"BackendServer,omitempty" xml:"BackendServer,omitempty" type:"Repeated"`
}

func (s AddVServerGroupBackendServersResponseBodyBackendServers) String() string {
	return tea.Prettify(s)
}

func (s AddVServerGroupBackendServersResponseBodyBackendServers) GoString() string {
	return s.String()
}

func (s *AddVServerGroupBackendServersResponseBodyBackendServers) SetBackendServer(v []*AddVServerGroupBackendServersResponseBodyBackendServersBackendServer) *AddVServerGroupBackendServersResponseBodyBackendServers {
	s.BackendServer = v
	return s
}

type AddVServerGroupBackendServersResponseBodyBackendServersBackendServer struct {
	// backend server
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the ECS instance or ENI.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// Adds backend servers to a specified server group.
	ServerId *string `json:"ServerId,omitempty" xml:"ServerId,omitempty"`
	// The weight of the backend server.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The description of the server group.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s AddVServerGroupBackendServersResponseBodyBackendServersBackendServer) String() string {
	return tea.Prettify(s)
}

func (s AddVServerGroupBackendServersResponseBodyBackendServersBackendServer) GoString() string {
	return s.String()
}

func (s *AddVServerGroupBackendServersResponseBodyBackendServersBackendServer) SetDescription(v string) *AddVServerGroupBackendServersResponseBodyBackendServersBackendServer {
	s.Description = &v
	return s
}

func (s *AddVServerGroupBackendServersResponseBodyBackendServersBackendServer) SetPort(v int32) *AddVServerGroupBackendServersResponseBodyBackendServersBackendServer {
	s.Port = &v
	return s
}

func (s *AddVServerGroupBackendServersResponseBodyBackendServersBackendServer) SetServerId(v string) *AddVServerGroupBackendServersResponseBodyBackendServersBackendServer {
	s.ServerId = &v
	return s
}

func (s *AddVServerGroupBackendServersResponseBodyBackendServersBackendServer) SetType(v string) *AddVServerGroupBackendServersResponseBodyBackendServersBackendServer {
	s.Type = &v
	return s
}

func (s *AddVServerGroupBackendServersResponseBodyBackendServersBackendServer) SetWeight(v int32) *AddVServerGroupBackendServersResponseBodyBackendServersBackendServer {
	s.Weight = &v
	return s
}

type AddVServerGroupBackendServersResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddVServerGroupBackendServersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddVServerGroupBackendServersResponse) String() string {
	return tea.Prettify(s)
}

func (s AddVServerGroupBackendServersResponse) GoString() string {
	return s.String()
}

func (s *AddVServerGroupBackendServersResponse) SetHeaders(v map[string]*string) *AddVServerGroupBackendServersResponse {
	s.Headers = v
	return s
}

func (s *AddVServerGroupBackendServersResponse) SetStatusCode(v int32) *AddVServerGroupBackendServersResponse {
	s.StatusCode = &v
	return s
}

func (s *AddVServerGroupBackendServersResponse) SetBody(v *AddVServerGroupBackendServersResponseBody) *AddVServerGroupBackendServersResponse {
	s.Body = v
	return s
}

type CreateAccessControlListRequest struct {
	// The ID of the resource group to which the ACL belongs.
	AclName *string `json:"AclName,omitempty" xml:"AclName,omitempty"`
	// The ID of the ACL.
	AddressIPVersion *string `json:"AddressIPVersion,omitempty" xml:"AddressIPVersion,omitempty"`
	OwnerAccount     *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId          *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The IP version. Valid values: **ipv4** and **ipv6**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the request.
	ResourceGroupId      *string                              `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string                              `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                               `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tag                  []*CreateAccessControlListRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s CreateAccessControlListRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAccessControlListRequest) GoString() string {
	return s.String()
}

func (s *CreateAccessControlListRequest) SetAclName(v string) *CreateAccessControlListRequest {
	s.AclName = &v
	return s
}

func (s *CreateAccessControlListRequest) SetAddressIPVersion(v string) *CreateAccessControlListRequest {
	s.AddressIPVersion = &v
	return s
}

func (s *CreateAccessControlListRequest) SetOwnerAccount(v string) *CreateAccessControlListRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateAccessControlListRequest) SetOwnerId(v int64) *CreateAccessControlListRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateAccessControlListRequest) SetRegionId(v string) *CreateAccessControlListRequest {
	s.RegionId = &v
	return s
}

func (s *CreateAccessControlListRequest) SetResourceGroupId(v string) *CreateAccessControlListRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateAccessControlListRequest) SetResourceOwnerAccount(v string) *CreateAccessControlListRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateAccessControlListRequest) SetResourceOwnerId(v int64) *CreateAccessControlListRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateAccessControlListRequest) SetTag(v []*CreateAccessControlListRequestTag) *CreateAccessControlListRequest {
	s.Tag = v
	return s
}

type CreateAccessControlListRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateAccessControlListRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateAccessControlListRequestTag) GoString() string {
	return s.String()
}

func (s *CreateAccessControlListRequestTag) SetKey(v string) *CreateAccessControlListRequestTag {
	s.Key = &v
	return s
}

func (s *CreateAccessControlListRequestTag) SetValue(v string) *CreateAccessControlListRequestTag {
	s.Value = &v
	return s
}

type CreateAccessControlListResponseBody struct {
	// You can create multiple ACLs. Each ACL can contain one or more IP addresses or CIDR blocks. Before you create an ACL, take note of the following limits:
	//
	// *   An account can have a maximum of 50 ACLs in each region.
	// *   You can add a maximum of 50 IP addresses or CIDR blocks at a time within an account.
	// *   Each ACL can contain a maximum of 300 IP addresses or CIDR blocks.
	AclId     *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateAccessControlListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateAccessControlListResponseBody) GoString() string {
	return s.String()
}

func (s *CreateAccessControlListResponseBody) SetAclId(v string) *CreateAccessControlListResponseBody {
	s.AclId = &v
	return s
}

func (s *CreateAccessControlListResponseBody) SetRequestId(v string) *CreateAccessControlListResponseBody {
	s.RequestId = &v
	return s
}

type CreateAccessControlListResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateAccessControlListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateAccessControlListResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateAccessControlListResponse) GoString() string {
	return s.String()
}

func (s *CreateAccessControlListResponse) SetHeaders(v map[string]*string) *CreateAccessControlListResponse {
	s.Headers = v
	return s
}

func (s *CreateAccessControlListResponse) SetStatusCode(v int32) *CreateAccessControlListResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateAccessControlListResponse) SetBody(v *CreateAccessControlListResponseBody) *CreateAccessControlListResponse {
	s.Body = v
	return s
}

type CreateDomainExtensionRequest struct {
	// The ID of the certificate used by the domain name.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// The domain name to be created.
	ListenerPort *int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	// The frontend port of the HTTPS listener.
	//
	// Value range:** 1 to 65535**
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the SLB instance.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The frontend port used by the SLB instance.
	ServerCertificateId *string `json:"ServerCertificateId,omitempty" xml:"ServerCertificateId,omitempty"`
}

func (s CreateDomainExtensionRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDomainExtensionRequest) GoString() string {
	return s.String()
}

func (s *CreateDomainExtensionRequest) SetDomain(v string) *CreateDomainExtensionRequest {
	s.Domain = &v
	return s
}

func (s *CreateDomainExtensionRequest) SetListenerPort(v int32) *CreateDomainExtensionRequest {
	s.ListenerPort = &v
	return s
}

func (s *CreateDomainExtensionRequest) SetLoadBalancerId(v string) *CreateDomainExtensionRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *CreateDomainExtensionRequest) SetOwnerAccount(v string) *CreateDomainExtensionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateDomainExtensionRequest) SetOwnerId(v int64) *CreateDomainExtensionRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateDomainExtensionRequest) SetRegionId(v string) *CreateDomainExtensionRequest {
	s.RegionId = &v
	return s
}

func (s *CreateDomainExtensionRequest) SetResourceOwnerAccount(v string) *CreateDomainExtensionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateDomainExtensionRequest) SetResourceOwnerId(v int64) *CreateDomainExtensionRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateDomainExtensionRequest) SetServerCertificateId(v string) *CreateDomainExtensionRequest {
	s.ServerCertificateId = &v
	return s
}

type CreateDomainExtensionResponseBody struct {
	DomainExtensionId *string `json:"DomainExtensionId,omitempty" xml:"DomainExtensionId,omitempty"`
	// The ID of the request.
	ListenerPort *int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	// The ID of the created domain name extension.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateDomainExtensionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDomainExtensionResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDomainExtensionResponseBody) SetDomainExtensionId(v string) *CreateDomainExtensionResponseBody {
	s.DomainExtensionId = &v
	return s
}

func (s *CreateDomainExtensionResponseBody) SetListenerPort(v int32) *CreateDomainExtensionResponseBody {
	s.ListenerPort = &v
	return s
}

func (s *CreateDomainExtensionResponseBody) SetRequestId(v string) *CreateDomainExtensionResponseBody {
	s.RequestId = &v
	return s
}

type CreateDomainExtensionResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDomainExtensionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDomainExtensionResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDomainExtensionResponse) GoString() string {
	return s.String()
}

func (s *CreateDomainExtensionResponse) SetHeaders(v map[string]*string) *CreateDomainExtensionResponse {
	s.Headers = v
	return s
}

func (s *CreateDomainExtensionResponse) SetStatusCode(v int32) *CreateDomainExtensionResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDomainExtensionResponse) SetBody(v *CreateDomainExtensionResponseBody) *CreateDomainExtensionResponse {
	s.Body = v
	return s
}

type CreateLoadBalancerRequest struct {
	Address                      *string                         `json:"Address,omitempty" xml:"Address,omitempty"`
	AddressIPVersion             *string                         `json:"AddressIPVersion,omitempty" xml:"AddressIPVersion,omitempty"`
	AddressType                  *string                         `json:"AddressType,omitempty" xml:"AddressType,omitempty"`
	AutoPay                      *bool                           `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	Bandwidth                    *int32                          `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	ClientToken                  *string                         `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	DeleteProtection             *string                         `json:"DeleteProtection,omitempty" xml:"DeleteProtection,omitempty"`
	Duration                     *int32                          `json:"Duration,omitempty" xml:"Duration,omitempty"`
	InstanceChargeType           *string                         `json:"InstanceChargeType,omitempty" xml:"InstanceChargeType,omitempty"`
	InternetChargeType           *string                         `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	LoadBalancerName             *string                         `json:"LoadBalancerName,omitempty" xml:"LoadBalancerName,omitempty"`
	LoadBalancerSpec             *string                         `json:"LoadBalancerSpec,omitempty" xml:"LoadBalancerSpec,omitempty"`
	MasterZoneId                 *string                         `json:"MasterZoneId,omitempty" xml:"MasterZoneId,omitempty"`
	ModificationProtectionReason *string                         `json:"ModificationProtectionReason,omitempty" xml:"ModificationProtectionReason,omitempty"`
	ModificationProtectionStatus *string                         `json:"ModificationProtectionStatus,omitempty" xml:"ModificationProtectionStatus,omitempty"`
	OwnerAccount                 *string                         `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                      *int64                          `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	PayType                      *string                         `json:"PayType,omitempty" xml:"PayType,omitempty"`
	PricingCycle                 *string                         `json:"PricingCycle,omitempty" xml:"PricingCycle,omitempty"`
	RegionId                     *string                         `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceGroupId              *string                         `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount         *string                         `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId              *int64                          `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	SlaveZoneId                  *string                         `json:"SlaveZoneId,omitempty" xml:"SlaveZoneId,omitempty"`
	Tag                          []*CreateLoadBalancerRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	VSwitchId                    *string                         `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	VpcId                        *string                         `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s CreateLoadBalancerRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateLoadBalancerRequest) GoString() string {
	return s.String()
}

func (s *CreateLoadBalancerRequest) SetAddress(v string) *CreateLoadBalancerRequest {
	s.Address = &v
	return s
}

func (s *CreateLoadBalancerRequest) SetAddressIPVersion(v string) *CreateLoadBalancerRequest {
	s.AddressIPVersion = &v
	return s
}

func (s *CreateLoadBalancerRequest) SetAddressType(v string) *CreateLoadBalancerRequest {
	s.AddressType = &v
	return s
}

func (s *CreateLoadBalancerRequest) SetAutoPay(v bool) *CreateLoadBalancerRequest {
	s.AutoPay = &v
	return s
}

func (s *CreateLoadBalancerRequest) SetBandwidth(v int32) *CreateLoadBalancerRequest {
	s.Bandwidth = &v
	return s
}

func (s *CreateLoadBalancerRequest) SetClientToken(v string) *CreateLoadBalancerRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateLoadBalancerRequest) SetDeleteProtection(v string) *CreateLoadBalancerRequest {
	s.DeleteProtection = &v
	return s
}

func (s *CreateLoadBalancerRequest) SetDuration(v int32) *CreateLoadBalancerRequest {
	s.Duration = &v
	return s
}

func (s *CreateLoadBalancerRequest) SetInstanceChargeType(v string) *CreateLoadBalancerRequest {
	s.InstanceChargeType = &v
	return s
}

func (s *CreateLoadBalancerRequest) SetInternetChargeType(v string) *CreateLoadBalancerRequest {
	s.InternetChargeType = &v
	return s
}

func (s *CreateLoadBalancerRequest) SetLoadBalancerName(v string) *CreateLoadBalancerRequest {
	s.LoadBalancerName = &v
	return s
}

func (s *CreateLoadBalancerRequest) SetLoadBalancerSpec(v string) *CreateLoadBalancerRequest {
	s.LoadBalancerSpec = &v
	return s
}

func (s *CreateLoadBalancerRequest) SetMasterZoneId(v string) *CreateLoadBalancerRequest {
	s.MasterZoneId = &v
	return s
}

func (s *CreateLoadBalancerRequest) SetModificationProtectionReason(v string) *CreateLoadBalancerRequest {
	s.ModificationProtectionReason = &v
	return s
}

func (s *CreateLoadBalancerRequest) SetModificationProtectionStatus(v string) *CreateLoadBalancerRequest {
	s.ModificationProtectionStatus = &v
	return s
}

func (s *CreateLoadBalancerRequest) SetOwnerAccount(v string) *CreateLoadBalancerRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateLoadBalancerRequest) SetOwnerId(v int64) *CreateLoadBalancerRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateLoadBalancerRequest) SetPayType(v string) *CreateLoadBalancerRequest {
	s.PayType = &v
	return s
}

func (s *CreateLoadBalancerRequest) SetPricingCycle(v string) *CreateLoadBalancerRequest {
	s.PricingCycle = &v
	return s
}

func (s *CreateLoadBalancerRequest) SetRegionId(v string) *CreateLoadBalancerRequest {
	s.RegionId = &v
	return s
}

func (s *CreateLoadBalancerRequest) SetResourceGroupId(v string) *CreateLoadBalancerRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateLoadBalancerRequest) SetResourceOwnerAccount(v string) *CreateLoadBalancerRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateLoadBalancerRequest) SetResourceOwnerId(v int64) *CreateLoadBalancerRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateLoadBalancerRequest) SetSlaveZoneId(v string) *CreateLoadBalancerRequest {
	s.SlaveZoneId = &v
	return s
}

func (s *CreateLoadBalancerRequest) SetTag(v []*CreateLoadBalancerRequestTag) *CreateLoadBalancerRequest {
	s.Tag = v
	return s
}

func (s *CreateLoadBalancerRequest) SetVSwitchId(v string) *CreateLoadBalancerRequest {
	s.VSwitchId = &v
	return s
}

func (s *CreateLoadBalancerRequest) SetVpcId(v string) *CreateLoadBalancerRequest {
	s.VpcId = &v
	return s
}

type CreateLoadBalancerRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateLoadBalancerRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateLoadBalancerRequestTag) GoString() string {
	return s.String()
}

func (s *CreateLoadBalancerRequestTag) SetKey(v string) *CreateLoadBalancerRequestTag {
	s.Key = &v
	return s
}

func (s *CreateLoadBalancerRequestTag) SetValue(v string) *CreateLoadBalancerRequestTag {
	s.Value = &v
	return s
}

type CreateLoadBalancerResponseBody struct {
	Address          *string `json:"Address,omitempty" xml:"Address,omitempty"`
	AddressIPVersion *string `json:"AddressIPVersion,omitempty" xml:"AddressIPVersion,omitempty"`
	LoadBalancerId   *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	LoadBalancerName *string `json:"LoadBalancerName,omitempty" xml:"LoadBalancerName,omitempty"`
	NetworkType      *string `json:"NetworkType,omitempty" xml:"NetworkType,omitempty"`
	OrderId          *int64  `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	RequestId        *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	ResourceGroupId  *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	VSwitchId        *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	VpcId            *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s CreateLoadBalancerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateLoadBalancerResponseBody) GoString() string {
	return s.String()
}

func (s *CreateLoadBalancerResponseBody) SetAddress(v string) *CreateLoadBalancerResponseBody {
	s.Address = &v
	return s
}

func (s *CreateLoadBalancerResponseBody) SetAddressIPVersion(v string) *CreateLoadBalancerResponseBody {
	s.AddressIPVersion = &v
	return s
}

func (s *CreateLoadBalancerResponseBody) SetLoadBalancerId(v string) *CreateLoadBalancerResponseBody {
	s.LoadBalancerId = &v
	return s
}

func (s *CreateLoadBalancerResponseBody) SetLoadBalancerName(v string) *CreateLoadBalancerResponseBody {
	s.LoadBalancerName = &v
	return s
}

func (s *CreateLoadBalancerResponseBody) SetNetworkType(v string) *CreateLoadBalancerResponseBody {
	s.NetworkType = &v
	return s
}

func (s *CreateLoadBalancerResponseBody) SetOrderId(v int64) *CreateLoadBalancerResponseBody {
	s.OrderId = &v
	return s
}

func (s *CreateLoadBalancerResponseBody) SetRequestId(v string) *CreateLoadBalancerResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateLoadBalancerResponseBody) SetResourceGroupId(v string) *CreateLoadBalancerResponseBody {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateLoadBalancerResponseBody) SetVSwitchId(v string) *CreateLoadBalancerResponseBody {
	s.VSwitchId = &v
	return s
}

func (s *CreateLoadBalancerResponseBody) SetVpcId(v string) *CreateLoadBalancerResponseBody {
	s.VpcId = &v
	return s
}

type CreateLoadBalancerResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateLoadBalancerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateLoadBalancerResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateLoadBalancerResponse) GoString() string {
	return s.String()
}

func (s *CreateLoadBalancerResponse) SetHeaders(v map[string]*string) *CreateLoadBalancerResponse {
	s.Headers = v
	return s
}

func (s *CreateLoadBalancerResponse) SetStatusCode(v int32) *CreateLoadBalancerResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateLoadBalancerResponse) SetBody(v *CreateLoadBalancerResponseBody) *CreateLoadBalancerResponse {
	s.Body = v
	return s
}

type CreateLoadBalancerHTTPListenerRequest struct {
	// The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. In this case, the health status is changed from **success** to **fail**.
	//
	// Valid values: **2** to **10**.
	//
	// >  This parameter takes effect only if the **HealthCheck** parameter is set to **on**.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The frontend port that is used by the CLB instance.
	//
	// Valid values: **1** to **65535**.
	AclStatus *string `json:"AclStatus,omitempty" xml:"AclStatus,omitempty"`
	// The interval between two consecutive health checks. Unit: seconds.
	//
	// Valid values: **1** to **50**.
	//
	// >  This parameter takes effect only if the **HealthCheck** parameter is set to **on**.
	AclType *string `json:"AclType,omitempty" xml:"AclType,omitempty"`
	// The ID of the vServer group.
	BackendServerPort *int32 `json:"BackendServerPort,omitempty" xml:"BackendServerPort,omitempty"`
	// The backend port that is used by the CLB instance.
	//
	// Valid values: **1** to **65535**.
	//
	// >  If the VServerGroupId parameter is not set, this parameter is required.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// Specifies whether to use the `SLB-IP` header to retrieve the virtual IP address (VIP) of the client. Valid values:
	//
	// *   **on**: yes
	// *   **off** (default): no
	Cookie *string `json:"Cookie,omitempty" xml:"Cookie,omitempty"`
	// Specifies whether to enable HTTP-to-HTTPS redirection. Valid values:
	//
	// *   **on**: yes
	// *   **off** (default): no
	CookieTimeout *int32 `json:"CookieTimeout,omitempty" xml:"CookieTimeout,omitempty"`
	// The timeout period of a request. Unit: seconds.
	//
	// Default value: **60**. Valid values: **1** to **180**.
	//
	// If no response is received from the backend server within the specified timeout period, CLB sends an `HTTP 504` error code to the client.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the request.
	ForwardPort *int32 `json:"ForwardPort,omitempty" xml:"ForwardPort,omitempty"`
	// The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. In this case, the health status is changed from **fail** to **success**.
	//
	// Valid values: **2** to **10**.
	//
	// >  This parameter takes effect only if the **HealthCheck** parameter is set to **on**.
	Gzip *string `json:"Gzip,omitempty" xml:"Gzip,omitempty"`
	// The domain name that is used for health checks. Valid values:
	//
	// *   **$\_ip**: the private IP address of a backend server. If you do not set the HealthCheckDomain parameter or set the parameter to $\_ip, the CLB instance uses the private IP address of each backend server for health checks.
	// *   **domain**: The domain name must be 1 to 80 characters in length and can contain letters, digits, periods (.), and hyphens (-).
	//
	// >  This parameter takes effect only if the **HealthCheck** parameter is set to **on**.
	HealthCheck *string `json:"HealthCheck,omitempty" xml:"HealthCheck,omitempty"`
	// The scheduling algorithm. Valid values:
	//
	// *   **wrr** (default): Backend servers with higher weights receive more requests than backend servers with lower weights.
	// *   **rr**: Requests are distributed to backend servers in sequence.
	HealthCheckConnectPort *int32 `json:"HealthCheckConnectPort,omitempty" xml:"HealthCheckConnectPort,omitempty"`
	// Specifies whether to enable session persistence. Valid values:
	//
	// *   **on**: yes
	// *   **off** (default): no
	HealthCheckDomain *string `json:"HealthCheckDomain,omitempty" xml:"HealthCheckDomain,omitempty"`
	// Specifies whether to enable access control. Valid values:
	//
	// *   **on**: yes
	// *   **off** (default): no
	HealthCheckHttpCode *string `json:"HealthCheckHttpCode,omitempty" xml:"HealthCheckHttpCode,omitempty"`
	// The timeout period of a health check response. If a backend server, such as an Elastic Compute Service (ECS) instance, does not respond to a probe packet within the specified timeout period, the server fails the health check. Unit: seconds.
	//
	// Valid values: **1** to **300**.
	//
	// >
	// *   If the value of the **HealthCheckTimeout** parameter is smaller than that of the **HealthCheckInterval** parameter, the timeout period specified by the **HealthCheckTimeout** parameter is ignored and the period of time specified by the **HealthCheckInterval** parameter is used as the timeout period.
	// *   This parameter takes effect only if the **HealthCheck** parameter is set to **on**.
	HealthCheckInterval *int32 `json:"HealthCheckInterval,omitempty" xml:"HealthCheckInterval,omitempty"`
	// Specifies whether to enable the health check feature. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	HealthCheckMethod *string `json:"HealthCheckMethod,omitempty" xml:"HealthCheckMethod,omitempty"`
	// The maximum bandwidth of the listener. Unit: Mbit/s. Valid values:
	//
	// *   **-1**: If you set the value to -1, the bandwidth of the listener is unlimited.
	// *   **1** to **5120**: The sum of bandwidth values that you specify for all listeners of the CLB instance cannot exceed the maximum bandwidth of the CLB instance.
	//
	// >  This parameter is available only in the Chinese mainland.
	HealthCheckTimeout *int32 `json:"HealthCheckTimeout,omitempty" xml:"HealthCheckTimeout,omitempty"`
	// The ID of the CLB instance.
	HealthCheckURI *string `json:"HealthCheckURI,omitempty" xml:"HealthCheckURI,omitempty"`
	// The health check method used in HTTP health checks. Valid values: **head** and **get**.
	//
	// >  This parameter takes effect only if the **HealthCheck** parameter is set to **on**.
	HealthyThreshold *int32 `json:"HealthyThreshold,omitempty" xml:"HealthyThreshold,omitempty"`
	// Creates an HTTP listener for a Classic Load Balancer (CLB) instance.
	IdleTimeout *int32 `json:"IdleTimeout,omitempty" xml:"IdleTimeout,omitempty"`
	// Specifies whether to use the `X-Forwarded-Proto` header to retrieve the listening protocol. Valid values:
	//
	// *   **on**: yes
	// *   **off** (default): no
	ListenerForward *string `json:"ListenerForward,omitempty" xml:"ListenerForward,omitempty"`
	// The backend port that is used for health checks.
	//
	// Valid values: **1** to **65535**.
	//
	// >  This parameter takes effect only if the **HealthCheck** parameter is set to **on**.
	ListenerPort *int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	// The ID of the region where the CLB instance is deployed.
	//
	// You can query the region ID from the [Regions and zones](~~40654~~) list or by calling the [DescribeRegions](~~27584~~) operation.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The HTTP status code for a successful health check. Separate multiple HTTP status codes with commas (,).
	//
	// Valid values: **http\_2xx** (default), **http\_3xx**, **http\_4xx**, and **http\_5xx**.
	//
	// >  This parameter takes effect only if the **HealthCheck** parameter is set to **on**.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	RequestTimeout       *int32  `json:"RequestTimeout,omitempty" xml:"RequestTimeout,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The operation that you want to perform. Set the value to **CreateLoadBalancerHTTPListener**.
	Scheduler *string `json:"Scheduler,omitempty" xml:"Scheduler,omitempty"`
	// The ID of the network ACL that is associated with the listener.
	//
	// >  If **AclStatus** is set to **on**, this parameter is required.
	StickySession *string `json:"StickySession,omitempty" xml:"StickySession,omitempty"`
	// The type of the network ACL. Valid values:
	//
	// *   **white**: a whitelist. Only requests from the IP addresses or CIDR blocks in the network ACL are forwarded. Whitelists apply to scenarios where you want to allow only specific IP addresses to access an application. Your service may be adversely affected if the whitelist is not properly configured. If a whitelist is configured, only requests from IP addresses that are added to the whitelist are forwarded by the listener.
	//
	//     If you enable a whitelist but do not add an IP address to the ACL, the listener forwards all requests.
	//
	// *   **black**: a blacklist. All requests from the IP addresses or CIDR blocks in the ACL are rejected. Blacklists apply to scenarios where you want to block access from specified IP addresses to an application.
	//
	//     If a blacklist is configured for a listener but no IP address is added to the blacklist, the listener forwards all requests.
	//
	// >  If **AclStatus** is set to **on**, this parameter is required.
	StickySessionType *string                                     `json:"StickySessionType,omitempty" xml:"StickySessionType,omitempty"`
	Tag               []*CreateLoadBalancerHTTPListenerRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// Specifies whether to use the `SLB-ID` header to retrieve the ID of the CLB instance. Valid values:
	//
	// *   **on**: yes
	// *   **off** (default): no
	UnhealthyThreshold *int32 `json:"UnhealthyThreshold,omitempty" xml:"UnhealthyThreshold,omitempty"`
	// The name of the listener.
	//
	// The name must be 1 to 256 characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.), and underscores (\_).
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
	// Specifies whether to use the `X-Forwarded-For` header to retrieve client IP addresses. Valid values:
	//
	// *   **on** (default): yes
	// *   **off**: no
	XForwardedFor *string `json:"XForwardedFor,omitempty" xml:"XForwardedFor,omitempty"`
	// The timeout period of an idle connection. Unit: seconds.
	//
	// Default value: **15**. Valid values: **1** to **60**.
	//
	// If no request is received within the specified timeout period, SLB closes the connection. When a request is received, SLB establishes a new connection.
	XForwardedFor_SLBID *string `json:"XForwardedFor_SLBID,omitempty" xml:"XForwardedFor_SLBID,omitempty"`
	// The cookie that is configured on the server.
	//
	// The cookie must be 1 to 200 characters in length and can contain only ASCII characters and digits. It cannot contain commas (,), semicolons (;), or space characters. It cannot start with a dollar sign ($).
	//
	// >  This parameter is required if the **StickySession** parameter is set to **on** and the **StickySessionType** parameter is set to **server**.
	XForwardedFor_SLBIP *string `json:"XForwardedFor_SLBIP,omitempty" xml:"XForwardedFor_SLBIP,omitempty"`
	// The method that is used to handle a cookie. Valid values:
	//
	// *   **insert**: inserts a cookie.
	//
	//     CLB inserts a cookie (SERVERID) into the first HTTP or HTTPS response that is sent to a client. The next request from the client carries this cookie, and the listener will forward this request to the recorded backend server.
	//
	// *   **server**: rewrites a cookie.
	//
	//     When CLB detects a user-defined cookie, it overwrites the original cookie with the user-defined cookie. The next request from the client carries the user-defined cookie, and the listener forwards this request to the recorded backend server.
	//
	// > This parameter is required if the **StickySession** parameter is set to **on**.
	XForwardedFor_proto *string `json:"XForwardedFor_proto,omitempty" xml:"XForwardedFor_proto,omitempty"`
}

func (s CreateLoadBalancerHTTPListenerRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateLoadBalancerHTTPListenerRequest) GoString() string {
	return s.String()
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetAclId(v string) *CreateLoadBalancerHTTPListenerRequest {
	s.AclId = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetAclStatus(v string) *CreateLoadBalancerHTTPListenerRequest {
	s.AclStatus = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetAclType(v string) *CreateLoadBalancerHTTPListenerRequest {
	s.AclType = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetBackendServerPort(v int32) *CreateLoadBalancerHTTPListenerRequest {
	s.BackendServerPort = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetBandwidth(v int32) *CreateLoadBalancerHTTPListenerRequest {
	s.Bandwidth = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetCookie(v string) *CreateLoadBalancerHTTPListenerRequest {
	s.Cookie = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetCookieTimeout(v int32) *CreateLoadBalancerHTTPListenerRequest {
	s.CookieTimeout = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetDescription(v string) *CreateLoadBalancerHTTPListenerRequest {
	s.Description = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetForwardPort(v int32) *CreateLoadBalancerHTTPListenerRequest {
	s.ForwardPort = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetGzip(v string) *CreateLoadBalancerHTTPListenerRequest {
	s.Gzip = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetHealthCheck(v string) *CreateLoadBalancerHTTPListenerRequest {
	s.HealthCheck = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetHealthCheckConnectPort(v int32) *CreateLoadBalancerHTTPListenerRequest {
	s.HealthCheckConnectPort = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetHealthCheckDomain(v string) *CreateLoadBalancerHTTPListenerRequest {
	s.HealthCheckDomain = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetHealthCheckHttpCode(v string) *CreateLoadBalancerHTTPListenerRequest {
	s.HealthCheckHttpCode = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetHealthCheckInterval(v int32) *CreateLoadBalancerHTTPListenerRequest {
	s.HealthCheckInterval = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetHealthCheckMethod(v string) *CreateLoadBalancerHTTPListenerRequest {
	s.HealthCheckMethod = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetHealthCheckTimeout(v int32) *CreateLoadBalancerHTTPListenerRequest {
	s.HealthCheckTimeout = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetHealthCheckURI(v string) *CreateLoadBalancerHTTPListenerRequest {
	s.HealthCheckURI = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetHealthyThreshold(v int32) *CreateLoadBalancerHTTPListenerRequest {
	s.HealthyThreshold = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetIdleTimeout(v int32) *CreateLoadBalancerHTTPListenerRequest {
	s.IdleTimeout = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetListenerForward(v string) *CreateLoadBalancerHTTPListenerRequest {
	s.ListenerForward = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetListenerPort(v int32) *CreateLoadBalancerHTTPListenerRequest {
	s.ListenerPort = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetLoadBalancerId(v string) *CreateLoadBalancerHTTPListenerRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetOwnerAccount(v string) *CreateLoadBalancerHTTPListenerRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetOwnerId(v int64) *CreateLoadBalancerHTTPListenerRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetRegionId(v string) *CreateLoadBalancerHTTPListenerRequest {
	s.RegionId = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetRequestTimeout(v int32) *CreateLoadBalancerHTTPListenerRequest {
	s.RequestTimeout = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetResourceOwnerAccount(v string) *CreateLoadBalancerHTTPListenerRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetResourceOwnerId(v int64) *CreateLoadBalancerHTTPListenerRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetScheduler(v string) *CreateLoadBalancerHTTPListenerRequest {
	s.Scheduler = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetStickySession(v string) *CreateLoadBalancerHTTPListenerRequest {
	s.StickySession = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetStickySessionType(v string) *CreateLoadBalancerHTTPListenerRequest {
	s.StickySessionType = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetTag(v []*CreateLoadBalancerHTTPListenerRequestTag) *CreateLoadBalancerHTTPListenerRequest {
	s.Tag = v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetUnhealthyThreshold(v int32) *CreateLoadBalancerHTTPListenerRequest {
	s.UnhealthyThreshold = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetVServerGroupId(v string) *CreateLoadBalancerHTTPListenerRequest {
	s.VServerGroupId = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetXForwardedFor(v string) *CreateLoadBalancerHTTPListenerRequest {
	s.XForwardedFor = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetXForwardedFor_SLBID(v string) *CreateLoadBalancerHTTPListenerRequest {
	s.XForwardedFor_SLBID = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetXForwardedFor_SLBIP(v string) *CreateLoadBalancerHTTPListenerRequest {
	s.XForwardedFor_SLBIP = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequest) SetXForwardedFor_proto(v string) *CreateLoadBalancerHTTPListenerRequest {
	s.XForwardedFor_proto = &v
	return s
}

type CreateLoadBalancerHTTPListenerRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateLoadBalancerHTTPListenerRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateLoadBalancerHTTPListenerRequestTag) GoString() string {
	return s.String()
}

func (s *CreateLoadBalancerHTTPListenerRequestTag) SetKey(v string) *CreateLoadBalancerHTTPListenerRequestTag {
	s.Key = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerRequestTag) SetValue(v string) *CreateLoadBalancerHTTPListenerRequestTag {
	s.Value = &v
	return s
}

type CreateLoadBalancerHTTPListenerResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateLoadBalancerHTTPListenerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateLoadBalancerHTTPListenerResponseBody) GoString() string {
	return s.String()
}

func (s *CreateLoadBalancerHTTPListenerResponseBody) SetRequestId(v string) *CreateLoadBalancerHTTPListenerResponseBody {
	s.RequestId = &v
	return s
}

type CreateLoadBalancerHTTPListenerResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateLoadBalancerHTTPListenerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateLoadBalancerHTTPListenerResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateLoadBalancerHTTPListenerResponse) GoString() string {
	return s.String()
}

func (s *CreateLoadBalancerHTTPListenerResponse) SetHeaders(v map[string]*string) *CreateLoadBalancerHTTPListenerResponse {
	s.Headers = v
	return s
}

func (s *CreateLoadBalancerHTTPListenerResponse) SetStatusCode(v int32) *CreateLoadBalancerHTTPListenerResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateLoadBalancerHTTPListenerResponse) SetBody(v *CreateLoadBalancerHTTPListenerResponseBody) *CreateLoadBalancerHTTPListenerResponse {
	s.Body = v
	return s
}

type CreateLoadBalancerHTTPSListenerRequest struct {
	// The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. In this case, the health status is changed from **success** to **fail**.
	//
	// Valid values: **2** to **10**.
	//
	// >  This parameter takes effect only if the **HealthCheck** parameter is set to **on**.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The frontend port that is used by the CLB instance.
	//
	// Valid values: **1** to **65535**.
	AclStatus *string `json:"AclStatus,omitempty" xml:"AclStatus,omitempty"`
	// The interval between two consecutive health checks. Unit: seconds.
	//
	// Valid values: **1** to **50**.
	//
	// >  This parameter takes effect only if the **HealthCheck** parameter is set to **on**.
	AclType *string `json:"AclType,omitempty" xml:"AclType,omitempty"`
	// The ID of the server certificate.
	BackendServerPort *int32 `json:"BackendServerPort,omitempty" xml:"BackendServerPort,omitempty"`
	// The backend port that is used by the CLB instance. Valid values: **1** to **65535**.
	//
	// If the VServerGroupId parameter is not set, this parameter is required.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// Specifies whether to enable HTTP/2. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	CACertificateId *string `json:"CACertificateId,omitempty" xml:"CACertificateId,omitempty"`
	// Specifies whether to enable access control. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	Cookie *string `json:"Cookie,omitempty" xml:"Cookie,omitempty"`
	// Specifies whether to enable `Gzip` compression to compress specific types of files. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	CookieTimeout *int32 `json:"CookieTimeout,omitempty" xml:"CookieTimeout,omitempty"`
	// The timeout period of a request. Valid values: **1 to 180**. Default value: **60**. Unit: seconds.
	//
	// If no response is received from a backend server within the specified timeout period, CLB returns the HTTP 504 status code to the client.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Creates an HTTPS listener.
	EnableHttp2 *string `json:"EnableHttp2,omitempty" xml:"EnableHttp2,omitempty"`
	// The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. In this case, the health status is changed from **fail** to **success**.
	//
	// Valid values: **2** to **10**.
	//
	// >  This parameter takes effect only if the **HealthCheck** parameter is set to **on**.
	Gzip *string `json:"Gzip,omitempty" xml:"Gzip,omitempty"`
	// The ID of the server group.
	HealthCheck *string `json:"HealthCheck,omitempty" xml:"HealthCheck,omitempty"`
	// The maximum bandwidth of the listener. Unit: Mbit/s.
	//
	// Valid values: **-1** and **1** to **5120**.
	//
	// *   **-1**: For a pay-by-data-transfer Internet-facing CLB instance, you can set this parameter to **-1**. This way, the bandwidth of the listener is unlimited.
	// *   **1** to **5120**: For a pay-by-bandwidth Internet-facing SLB instance, you can specify the bandwidth limit of each listener. The sum of bandwidth limits that you set for all listeners cannot exceed the bandwidth limit of the SLB instance.
	HealthCheckConnectPort *int32 `json:"HealthCheckConnectPort,omitempty" xml:"HealthCheckConnectPort,omitempty"`
	// Specifies whether to enable the health check feature. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	HealthCheckDomain *string `json:"HealthCheckDomain,omitempty" xml:"HealthCheckDomain,omitempty"`
	// The timeout period of a health check response. If a backend server, such as an Elastic Compute Service (ECS) instance, does not return a health check response within the specified timeout period, the server fails the health check. Unit: seconds.
	//
	// Valid values: **1** to **300**.
	//
	// >
	// *   If the value of the **HealthCheckTimeout** parameter is smaller than that of the **HealthCheckInterval** parameter, the timeout period specified by the **HealthCheckTimeout** parameter is ignored and the period of time specified by the **HealthCheckInterval** parameter is used as the timeout period.
	// *   This parameter takes effect only if the **HealthCheck** parameter is set to **on**.
	HealthCheckHttpCode *string `json:"HealthCheckHttpCode,omitempty" xml:"HealthCheckHttpCode,omitempty"`
	// The scheduling algorithm. Valid values:
	//
	// *   **wrr**: Backend servers with higher weights receive more requests than those with lower weights.
	// *   **rr**: Requests are distributed to backend servers in sequence.
	HealthCheckInterval *int32 `json:"HealthCheckInterval,omitempty" xml:"HealthCheckInterval,omitempty"`
	// The domain name that is used for health checks. Valid values:
	//
	// *   **$\_ip**: the private IP address of a backend server. If you do not set the HealthCheckDomain parameter or set the parameter to $\_ip, the CLB instance uses the private IP address of each backend server for health checks.
	// *   **domain**: The domain name must be 1 to 80 characters in length and can contain letters, digits, periods (.), and hyphens (-).
	//
	// >  This parameter takes effect only if the **HealthCheck** parameter is set to **on**.
	HealthCheckMethod *string `json:"HealthCheckMethod,omitempty" xml:"HealthCheckMethod,omitempty"`
	// The ID of the certification authority (CA) certificate.
	//
	// If both the CA certificate and the server certificate are uploaded, mutual authentication is used.
	//
	// If you upload only the server certificate, one-way authentication is used.
	HealthCheckTimeout *int32 `json:"HealthCheckTimeout,omitempty" xml:"HealthCheckTimeout,omitempty"`
	// Specifies whether to enable session persistence. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	HealthCheckURI *string `json:"HealthCheckURI,omitempty" xml:"HealthCheckURI,omitempty"`
	// The ID of the CLB instance.
	HealthyThreshold *int32 `json:"HealthyThreshold,omitempty" xml:"HealthyThreshold,omitempty"`
	// Specifies whether to use the `SLB-IP` header to retrieve the virtual IP address (VIP) of the client. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	IdleTimeout *int32 `json:"IdleTimeout,omitempty" xml:"IdleTimeout,omitempty"`
	// The port that is used for health checks.
	//
	// Valid values: **1** to **65535**.
	//
	// >  This parameter takes effect only if the **HealthCheck** parameter is set to **on**.
	ListenerPort *int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	// The region ID of the CLB instance.
	//
	// You can query the region ID from the [Regions and zones](~~40654~~) list or by calling the [DescribeRegions](~~25609~~) operation.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The HTTP status code for a successful health check. Separate multiple HTTP status codes with commas (,).
	//
	// Valid values: **http\_2xx**, **http\_3xx**, **http\_4xx**, and **http\_5xx**.
	//
	// >  This parameter takes effect only if the **HealthCheck** parameter is set to **on**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the request.
	RequestTimeout       *int32  `json:"RequestTimeout,omitempty" xml:"RequestTimeout,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The Transport Layer Security (TLS) security policy. Each security policy contains TLS protocol versions and cipher suites available for HTTPS.
	//
	// *   **tls_cipher_policy\_1\_0**:
	//
	//     Supported TLS versions: TLS 1.0, TLS 1.1, and TLS 1.2
	//
	//     Supported cipher suites: ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, AES128-GCM-SHA256, AES256-GCM-SHA384, AES128-SHA256, AES256-SHA256, ECDHE-RSA-AES128-SHA, ECDHE-RSA-AES256-SHA, AES128-SHA, AES256-SHA, and DES-CBC3-SHA
	//
	// *   **tls_cipher_policy\_1\_1**:
	//
	//     Supported TLS versions: TLS 1.1 and TLS 1.2
	//
	//     Supported cipher suites: ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, AES128-GCM-SHA256, AES256-GCM-SHA384, AES128-SHA256, AES256-SHA256, ECDHE-RSA-AES128-SHA, ECDHE-RSA-AES256-SHA, AES128-SHA, AES256-SHA, and DES-CBC3-SHA
	//
	// *   **tls_cipher_policy\_1\_2**
	//
	//     Supported TLS version: TLS 1.2
	//
	//     Supported cipher suites: ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, AES128-GCM-SHA256, AES256-GCM-SHA384, AES128-SHA256, AES256-SHA256, ECDHE-RSA-AES128-SHA, ECDHE-RSA-AES256-SHA, AES128-SHA, AES256-SHA, and DES-CBC3-SHA
	//
	// *   **tls_cipher_policy\_1\_2\_strict**
	//
	//     Supported TLS version: TLS 1.2
	//
	//     Supported cipher suites: ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, ECDHE-RSA-AES128-SHA, and ECDHE-RSA-AES256-SHA
	//
	// *   **tls_cipher_policy\_1\_2\_strict_with\_1\_3**
	//
	//     Supported TLS versions: TLS 1.2 and TLS 1.3
	//
	//     Supported cipher suites: TLS_AES\_128\_GCM_SHA256, TLS_AES\_256\_GCM_SHA384, TLS_CHACHA20\_POLY1305\_SHA256, TLS_AES\_128\_CCM_SHA256, TLS_AES\_128\_CCM\_8\_SHA256, ECDHE-ECDSA-AES128-GCM-SHA256, ECDHE-ECDSA-AES256-GCM-SHA384, ECDHE-ECDSA-AES128-SHA256, ECDHE-ECDSA-AES256-SHA384, ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, ECDHE-ECDSA-AES128-SHA, ECDHE-ECDSA-AES256-SHA, ECDHE-RSA-AES128-SHA, and ECDHE-RSA-AES256-SHA
	Scheduler *string `json:"Scheduler,omitempty" xml:"Scheduler,omitempty"`
	// The ID of the network access control list (ACL) that is associated with the listener.
	//
	// >  If **AclStatus** is set to **on**, this parameter is required.
	ServerCertificateId *string `json:"ServerCertificateId,omitempty" xml:"ServerCertificateId,omitempty"`
	// The operation that you want to perform. Set the value to **CreateLoadBalancerHTTPSListener**.
	StickySession *string `json:"StickySession,omitempty" xml:"StickySession,omitempty"`
	// Specifies whether to use the `X-Forwarded-Proto` header to retrieve the listener protocol. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	StickySessionType *string                                      `json:"StickySessionType,omitempty" xml:"StickySessionType,omitempty"`
	TLSCipherPolicy   *string                                      `json:"TLSCipherPolicy,omitempty" xml:"TLSCipherPolicy,omitempty"`
	Tag               []*CreateLoadBalancerHTTPSListenerRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The health check method used in HTTP health checks. Valid values: **head** and **get**.
	//
	// >  This parameter takes effect only if the **HealthCheck** parameter is set to **on**.
	UnhealthyThreshold *int32 `json:"UnhealthyThreshold,omitempty" xml:"UnhealthyThreshold,omitempty"`
	// The type of the network ACL. Valid values:
	//
	// *   **white**: a whitelist. Only requests from the IP addresses or CIDR blocks in the network ACL are forwarded. Whitelists apply to scenarios in which you want to allow only specific IP addresses to access an application. Your service may be adversely affected if the allowlist is not properly configured. After a whitelist is configured, only requests from IP addresses that are added to the whitelist are forwarded by the listener.
	//
	//     If you enable a whitelist but do not add an IP address to the ACL, the listener forwards all requests.
	//
	// *   **black**: a blacklist. All requests from the IP addresses or CIDR blocks in the network ACL are denied. The blacklist applies to scenarios in which you want to deny access from specific IP addresses to an application.
	//
	//     If a blacklist is configured for a listener but no IP address is added to the blacklist, the listener forwards all requests.
	//
	// >  If **AclStatus** is set to **on**, this parameter is required.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
	// Specifies whether to use the `X-Forwarded-For` header to retrieve client IP addresses. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	XForwardedFor *string `json:"XForwardedFor,omitempty" xml:"XForwardedFor,omitempty"`
	// The timeout period of an idle connection. Valid values: **1 to 60**. Default value: **15**. Unit: seconds.
	//
	// If no request is received within the specified timeout period, CLB closes the connection. When a request is received, CLB establishes a new connection.
	XForwardedFor_SLBID *string `json:"XForwardedFor_SLBID,omitempty" xml:"XForwardedFor_SLBID,omitempty"`
	// The cookie that is configured on the server.
	//
	// The cookie must be 1 to 200 characters in length and can contain only ASCII characters and digits. It cannot contain commas (,), semicolons (;), or space characters. It cannot start with a dollar sign ($).
	//
	// >  This parameter is required if the **StickySession** parameter is set to **on** and the **StickySessionType** parameter is set to **server**.
	XForwardedFor_SLBIP *string `json:"XForwardedFor_SLBIP,omitempty" xml:"XForwardedFor_SLBIP,omitempty"`
	// The method that is used to handle a cookie. Valid values: **insert** and **server**.
	//
	// *   **insert**: inserts a cookie.
	//
	//     CLB inserts a cookie (SERVERID) into the first HTTP or HTTPS response packet that is sent to a client. The next request from the client will contain this cookie, and the listener will distribute this request to the recorded backend server.
	//
	// *   **server**: rewrites a cookie.
	//
	//     When CLB detects a user-defined cookie, it overwrites the original cookie with the user-defined cookie. The next request from the client carries the user-defined cookie, and the listener will distribute the request to the recorded backend server.
	//
	// >  This parameter is required if the **StickySession** parameter is set to **on**.
	XForwardedFor_proto *string `json:"XForwardedFor_proto,omitempty" xml:"XForwardedFor_proto,omitempty"`
}

func (s CreateLoadBalancerHTTPSListenerRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateLoadBalancerHTTPSListenerRequest) GoString() string {
	return s.String()
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetAclId(v string) *CreateLoadBalancerHTTPSListenerRequest {
	s.AclId = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetAclStatus(v string) *CreateLoadBalancerHTTPSListenerRequest {
	s.AclStatus = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetAclType(v string) *CreateLoadBalancerHTTPSListenerRequest {
	s.AclType = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetBackendServerPort(v int32) *CreateLoadBalancerHTTPSListenerRequest {
	s.BackendServerPort = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetBandwidth(v int32) *CreateLoadBalancerHTTPSListenerRequest {
	s.Bandwidth = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetCACertificateId(v string) *CreateLoadBalancerHTTPSListenerRequest {
	s.CACertificateId = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetCookie(v string) *CreateLoadBalancerHTTPSListenerRequest {
	s.Cookie = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetCookieTimeout(v int32) *CreateLoadBalancerHTTPSListenerRequest {
	s.CookieTimeout = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetDescription(v string) *CreateLoadBalancerHTTPSListenerRequest {
	s.Description = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetEnableHttp2(v string) *CreateLoadBalancerHTTPSListenerRequest {
	s.EnableHttp2 = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetGzip(v string) *CreateLoadBalancerHTTPSListenerRequest {
	s.Gzip = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetHealthCheck(v string) *CreateLoadBalancerHTTPSListenerRequest {
	s.HealthCheck = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetHealthCheckConnectPort(v int32) *CreateLoadBalancerHTTPSListenerRequest {
	s.HealthCheckConnectPort = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetHealthCheckDomain(v string) *CreateLoadBalancerHTTPSListenerRequest {
	s.HealthCheckDomain = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetHealthCheckHttpCode(v string) *CreateLoadBalancerHTTPSListenerRequest {
	s.HealthCheckHttpCode = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetHealthCheckInterval(v int32) *CreateLoadBalancerHTTPSListenerRequest {
	s.HealthCheckInterval = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetHealthCheckMethod(v string) *CreateLoadBalancerHTTPSListenerRequest {
	s.HealthCheckMethod = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetHealthCheckTimeout(v int32) *CreateLoadBalancerHTTPSListenerRequest {
	s.HealthCheckTimeout = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetHealthCheckURI(v string) *CreateLoadBalancerHTTPSListenerRequest {
	s.HealthCheckURI = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetHealthyThreshold(v int32) *CreateLoadBalancerHTTPSListenerRequest {
	s.HealthyThreshold = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetIdleTimeout(v int32) *CreateLoadBalancerHTTPSListenerRequest {
	s.IdleTimeout = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetListenerPort(v int32) *CreateLoadBalancerHTTPSListenerRequest {
	s.ListenerPort = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetLoadBalancerId(v string) *CreateLoadBalancerHTTPSListenerRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetOwnerAccount(v string) *CreateLoadBalancerHTTPSListenerRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetOwnerId(v int64) *CreateLoadBalancerHTTPSListenerRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetRegionId(v string) *CreateLoadBalancerHTTPSListenerRequest {
	s.RegionId = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetRequestTimeout(v int32) *CreateLoadBalancerHTTPSListenerRequest {
	s.RequestTimeout = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetResourceOwnerAccount(v string) *CreateLoadBalancerHTTPSListenerRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetResourceOwnerId(v int64) *CreateLoadBalancerHTTPSListenerRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetScheduler(v string) *CreateLoadBalancerHTTPSListenerRequest {
	s.Scheduler = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetServerCertificateId(v string) *CreateLoadBalancerHTTPSListenerRequest {
	s.ServerCertificateId = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetStickySession(v string) *CreateLoadBalancerHTTPSListenerRequest {
	s.StickySession = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetStickySessionType(v string) *CreateLoadBalancerHTTPSListenerRequest {
	s.StickySessionType = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetTLSCipherPolicy(v string) *CreateLoadBalancerHTTPSListenerRequest {
	s.TLSCipherPolicy = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetTag(v []*CreateLoadBalancerHTTPSListenerRequestTag) *CreateLoadBalancerHTTPSListenerRequest {
	s.Tag = v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetUnhealthyThreshold(v int32) *CreateLoadBalancerHTTPSListenerRequest {
	s.UnhealthyThreshold = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetVServerGroupId(v string) *CreateLoadBalancerHTTPSListenerRequest {
	s.VServerGroupId = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetXForwardedFor(v string) *CreateLoadBalancerHTTPSListenerRequest {
	s.XForwardedFor = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetXForwardedFor_SLBID(v string) *CreateLoadBalancerHTTPSListenerRequest {
	s.XForwardedFor_SLBID = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetXForwardedFor_SLBIP(v string) *CreateLoadBalancerHTTPSListenerRequest {
	s.XForwardedFor_SLBIP = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequest) SetXForwardedFor_proto(v string) *CreateLoadBalancerHTTPSListenerRequest {
	s.XForwardedFor_proto = &v
	return s
}

type CreateLoadBalancerHTTPSListenerRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateLoadBalancerHTTPSListenerRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateLoadBalancerHTTPSListenerRequestTag) GoString() string {
	return s.String()
}

func (s *CreateLoadBalancerHTTPSListenerRequestTag) SetKey(v string) *CreateLoadBalancerHTTPSListenerRequestTag {
	s.Key = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerRequestTag) SetValue(v string) *CreateLoadBalancerHTTPSListenerRequestTag {
	s.Value = &v
	return s
}

type CreateLoadBalancerHTTPSListenerResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateLoadBalancerHTTPSListenerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateLoadBalancerHTTPSListenerResponseBody) GoString() string {
	return s.String()
}

func (s *CreateLoadBalancerHTTPSListenerResponseBody) SetRequestId(v string) *CreateLoadBalancerHTTPSListenerResponseBody {
	s.RequestId = &v
	return s
}

type CreateLoadBalancerHTTPSListenerResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateLoadBalancerHTTPSListenerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateLoadBalancerHTTPSListenerResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateLoadBalancerHTTPSListenerResponse) GoString() string {
	return s.String()
}

func (s *CreateLoadBalancerHTTPSListenerResponse) SetHeaders(v map[string]*string) *CreateLoadBalancerHTTPSListenerResponse {
	s.Headers = v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerResponse) SetStatusCode(v int32) *CreateLoadBalancerHTTPSListenerResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateLoadBalancerHTTPSListenerResponse) SetBody(v *CreateLoadBalancerHTTPSListenerResponseBody) *CreateLoadBalancerHTTPSListenerResponse {
	s.Body = v
	return s
}

type CreateLoadBalancerTCPListenerRequest struct {
	// The HTTP status code for a successful health check. Separate multiple HTTP status codes with commas (,). Valid values:
	//
	// *   **http\_2xx**(default)
	// *   **http\_3xx**
	// *   **http\_4xx**
	// *   **http\_5xx**
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The ID of the network ACL that is associated with the listener.
	//
	// >  If **AclStatus** is set to **on**, this parameter is required.
	AclStatus *string `json:"AclStatus,omitempty" xml:"AclStatus,omitempty"`
	// The type of health checks. Valid values:
	//
	// *   **tcp** (default)
	// *   **http**
	AclType *string `json:"AclType,omitempty" xml:"AclType,omitempty"`
	// Specifies whether to enable access control. Valid values:
	//
	// *   **on**: yes
	// *   **off** (default): no
	BackendServerPort *int32 `json:"BackendServerPort,omitempty" xml:"BackendServerPort,omitempty"`
	// The routing algorithm. Valid values:
	//
	// *   **wrr** (default): Backend servers with higher weights receive more requests than backend servers with lower weights.
	// *   **rr**: Requests are distributed to backend servers in sequence.
	// *   **sch**: specifies consistent hashing that is based on source IP addresses. Requests from the same source IP address are distributed to the same backend server.
	// *   **tch**: specifies consistent hashing that is based on four factors: source IP address, destination IP address, source port, and destination port. Requests that contain the same information based on the four factors are distributed to the same backend server.
	//
	// >  Only high-performance CLB instances support the **sch** and **tch** consistent hashing algorithms.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The timeout period of connection draining. Unit: seconds.
	//
	// Valid values: **10** to **900**.
	//
	// >  This parameter is required if **ConnectionDrain** is set to **on**.
	ConnectionDrain *string `json:"ConnectionDrain,omitempty" xml:"ConnectionDrain,omitempty"`
	// The ID of the request.
	ConnectionDrainTimeout *int32 `json:"ConnectionDrainTimeout,omitempty" xml:"ConnectionDrainTimeout,omitempty"`
	// The backend port used by the CLB instance.
	//
	// Valid values: **1** to **65535**.
	//
	// If the **VServerGroupId** parameter is not set, this parameter is required.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the listener.
	//
	// The name must be 1 to 256 characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.), and underscores (\_).
	EstablishedTimeout *int32 `json:"EstablishedTimeout,omitempty" xml:"EstablishedTimeout,omitempty"`
	// The ID of the CLB instance.
	HealthCheckConnectPort *int32 `json:"HealthCheckConnectPort,omitempty" xml:"HealthCheckConnectPort,omitempty"`
	// The timeout period of a connection. Unit: seconds.
	//
	// Valid values: **10** to **900**.
	HealthCheckConnectTimeout *int32 `json:"HealthCheckConnectTimeout,omitempty" xml:"HealthCheckConnectTimeout,omitempty"`
	// Specifies whether to enable connection draining. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	HealthCheckDomain *string `json:"HealthCheckDomain,omitempty" xml:"HealthCheckDomain,omitempty"`
	// The timeout period of session persistence. Unit: seconds.
	//
	// Valid values: **0 to 3600**.
	//
	// Default value: **0**. If the default value is used, the system disables session persistence.
	HealthCheckHttpCode *string `json:"HealthCheckHttpCode,omitempty" xml:"HealthCheckHttpCode,omitempty"`
	HealthCheckSwitch   *string `json:"HealthCheckSwitch,omitempty" xml:"HealthCheckSwitch,omitempty"`
	// The ID of the vServer group.
	HealthCheckType *string `json:"HealthCheckType,omitempty" xml:"HealthCheckType,omitempty"`
	// The frontend port used by the CLB instance.
	//
	// Valid values: **1** to **65535**.
	HealthCheckURI *string `json:"HealthCheckURI,omitempty" xml:"HealthCheckURI,omitempty"`
	// The domain name that you want to use for health checks. Valid values:
	//
	// *   **$\_ip**: the private IP address of a backend server. If you do not set the HealthCheckDomain parameter or set the parameter to $\_ip, the CLB instance uses the private IP address of each backend server for health checks.
	// *   **domain**: The domain name must be 1 to 80 characters in length, and can contain letters, digits, periods (.), and hyphens (-).
	HealthyThreshold *int32 `json:"HealthyThreshold,omitempty" xml:"HealthyThreshold,omitempty"`
	// The ID of the primary/secondary server group.
	//
	// >  You cannot set both VServerGroupId and MasterSlaveServerGroupId.
	ListenerPort *int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	// The maximum bandwidth of the listener. Unit: Mbit/s. Valid values:
	//
	// *   **-1**: For a pay-by-data-transfer Internet-facing CLB instance, this value can be set to -1, which specifies unlimited bandwidth.
	// *   **1** to **5120**: For a pay-by-bandwidth Internet-facing CLB instance, you can specify the maximum bandwidth of each listener. The sum of the maximum bandwidth values that you set for all listeners cannot exceed the maximum bandwidth of the CLB instance.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. In this case, the health status is changed from **fail** to **success**.
	//
	// Valid values: **2** to **10**.
	MasterSlaveServerGroupId *string `json:"MasterSlaveServerGroupId,omitempty" xml:"MasterSlaveServerGroupId,omitempty"`
	OwnerAccount             *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                  *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// Specifies whether to enable the health check feature. Valid values:
	//
	// *   **on** (default): yes
	// *   **off**: no
	PersistenceTimeout     *int32 `json:"PersistenceTimeout,omitempty" xml:"PersistenceTimeout,omitempty"`
	ProxyProtocolV2Enabled *bool  `json:"ProxyProtocolV2Enabled,omitempty" xml:"ProxyProtocolV2Enabled,omitempty"`
	// The type of the ACL. Valid values:
	//
	// *   **white**: a whitelist. Only requests from the IP addresses or CIDR blocks in the network ACL are forwarded. Whitelists apply to scenarios where you want to allow only specific IP addresses to access an application.
	//
	//     Your service may be adversely affected if the whitelist is not properly configured.
	//
	//     If a whitelist is configured, only requests from IP addresses that are added to the whitelist are forwarded by the listener. If a whitelist is configured but no IP address is added to the whitelist, the listener forwards all requests.
	//
	// *   **black**: a blacklist. All requests from the IP addresses or CIDR blocks in the ACL are rejected. Blacklists apply to scenarios where you want to block access from specified IP addresses to an application.
	//
	//     If a blacklist is configured for a listener but no IP address is added to the blacklist, the listener forwards all requests.
	//
	// >  If **AclStatus** is set to **on**, this parameter is required.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The operation that you want to perform. Set the value to **CreateLoadBalancerTCPListener**.
	Scheduler *string                                    `json:"Scheduler,omitempty" xml:"Scheduler,omitempty"`
	Tag       []*CreateLoadBalancerTCPListenerRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The port that is used for health checks.
	//
	// Valid values: **1** to **65535**.
	//
	// If this parameter is not set, the backend port specified by **BackendServerPort** is used for health checks.
	UnhealthyThreshold *int32 `json:"UnhealthyThreshold,omitempty" xml:"UnhealthyThreshold,omitempty"`
	// The maximum timeout period of a health check response. Unit: seconds.
	//
	// Valid values: **1** to **300**.
	//
	// Default value: **5**.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
	// The interval between two consecutive health checks. Unit: seconds.
	//
	// Valid values: **1** to **50**.
	HealthCheckInterval *int32 `json:"healthCheckInterval,omitempty" xml:"healthCheckInterval,omitempty"`
}

func (s CreateLoadBalancerTCPListenerRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateLoadBalancerTCPListenerRequest) GoString() string {
	return s.String()
}

func (s *CreateLoadBalancerTCPListenerRequest) SetAclId(v string) *CreateLoadBalancerTCPListenerRequest {
	s.AclId = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetAclStatus(v string) *CreateLoadBalancerTCPListenerRequest {
	s.AclStatus = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetAclType(v string) *CreateLoadBalancerTCPListenerRequest {
	s.AclType = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetBackendServerPort(v int32) *CreateLoadBalancerTCPListenerRequest {
	s.BackendServerPort = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetBandwidth(v int32) *CreateLoadBalancerTCPListenerRequest {
	s.Bandwidth = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetConnectionDrain(v string) *CreateLoadBalancerTCPListenerRequest {
	s.ConnectionDrain = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetConnectionDrainTimeout(v int32) *CreateLoadBalancerTCPListenerRequest {
	s.ConnectionDrainTimeout = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetDescription(v string) *CreateLoadBalancerTCPListenerRequest {
	s.Description = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetEstablishedTimeout(v int32) *CreateLoadBalancerTCPListenerRequest {
	s.EstablishedTimeout = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetHealthCheckConnectPort(v int32) *CreateLoadBalancerTCPListenerRequest {
	s.HealthCheckConnectPort = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetHealthCheckConnectTimeout(v int32) *CreateLoadBalancerTCPListenerRequest {
	s.HealthCheckConnectTimeout = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetHealthCheckDomain(v string) *CreateLoadBalancerTCPListenerRequest {
	s.HealthCheckDomain = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetHealthCheckHttpCode(v string) *CreateLoadBalancerTCPListenerRequest {
	s.HealthCheckHttpCode = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetHealthCheckSwitch(v string) *CreateLoadBalancerTCPListenerRequest {
	s.HealthCheckSwitch = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetHealthCheckType(v string) *CreateLoadBalancerTCPListenerRequest {
	s.HealthCheckType = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetHealthCheckURI(v string) *CreateLoadBalancerTCPListenerRequest {
	s.HealthCheckURI = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetHealthyThreshold(v int32) *CreateLoadBalancerTCPListenerRequest {
	s.HealthyThreshold = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetListenerPort(v int32) *CreateLoadBalancerTCPListenerRequest {
	s.ListenerPort = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetLoadBalancerId(v string) *CreateLoadBalancerTCPListenerRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetMasterSlaveServerGroupId(v string) *CreateLoadBalancerTCPListenerRequest {
	s.MasterSlaveServerGroupId = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetOwnerAccount(v string) *CreateLoadBalancerTCPListenerRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetOwnerId(v int64) *CreateLoadBalancerTCPListenerRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetPersistenceTimeout(v int32) *CreateLoadBalancerTCPListenerRequest {
	s.PersistenceTimeout = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetProxyProtocolV2Enabled(v bool) *CreateLoadBalancerTCPListenerRequest {
	s.ProxyProtocolV2Enabled = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetRegionId(v string) *CreateLoadBalancerTCPListenerRequest {
	s.RegionId = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetResourceOwnerAccount(v string) *CreateLoadBalancerTCPListenerRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetResourceOwnerId(v int64) *CreateLoadBalancerTCPListenerRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetScheduler(v string) *CreateLoadBalancerTCPListenerRequest {
	s.Scheduler = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetTag(v []*CreateLoadBalancerTCPListenerRequestTag) *CreateLoadBalancerTCPListenerRequest {
	s.Tag = v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetUnhealthyThreshold(v int32) *CreateLoadBalancerTCPListenerRequest {
	s.UnhealthyThreshold = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetVServerGroupId(v string) *CreateLoadBalancerTCPListenerRequest {
	s.VServerGroupId = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequest) SetHealthCheckInterval(v int32) *CreateLoadBalancerTCPListenerRequest {
	s.HealthCheckInterval = &v
	return s
}

type CreateLoadBalancerTCPListenerRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateLoadBalancerTCPListenerRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateLoadBalancerTCPListenerRequestTag) GoString() string {
	return s.String()
}

func (s *CreateLoadBalancerTCPListenerRequestTag) SetKey(v string) *CreateLoadBalancerTCPListenerRequestTag {
	s.Key = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerRequestTag) SetValue(v string) *CreateLoadBalancerTCPListenerRequestTag {
	s.Value = &v
	return s
}

type CreateLoadBalancerTCPListenerResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateLoadBalancerTCPListenerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateLoadBalancerTCPListenerResponseBody) GoString() string {
	return s.String()
}

func (s *CreateLoadBalancerTCPListenerResponseBody) SetRequestId(v string) *CreateLoadBalancerTCPListenerResponseBody {
	s.RequestId = &v
	return s
}

type CreateLoadBalancerTCPListenerResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateLoadBalancerTCPListenerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateLoadBalancerTCPListenerResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateLoadBalancerTCPListenerResponse) GoString() string {
	return s.String()
}

func (s *CreateLoadBalancerTCPListenerResponse) SetHeaders(v map[string]*string) *CreateLoadBalancerTCPListenerResponse {
	s.Headers = v
	return s
}

func (s *CreateLoadBalancerTCPListenerResponse) SetStatusCode(v int32) *CreateLoadBalancerTCPListenerResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateLoadBalancerTCPListenerResponse) SetBody(v *CreateLoadBalancerTCPListenerResponseBody) *CreateLoadBalancerTCPListenerResponse {
	s.Body = v
	return s
}

type CreateLoadBalancerUDPListenerRequest struct {
	// The type of the network ACL. Valid values:
	//
	// *   **white**: a whitelist. Only requests from the IP addresses or CIDR blocks in the network ACL are forwarded. Whitelists apply to scenarios in which you want to allow only specific IP addresses to access an application. After a whitelist is configured, only IP addresses in the whitelist can access the CLB listener. Risks may arise if the whitelist is improperly set.
	//
	//     If a whitelist is configured but no IP address is added to the whitelist, the listener forwards all requests.
	//
	// *   **black**: a blacklist. All requests from the IP addresses or CIDR blocks in the network ACL are blocked. Blacklists apply to scenarios in which you want to deny access from specific IP addresses to an application.
	//
	//     If a blacklist is configured for a listener but no IP address is added to the blacklist, the listener forwards all requests.
	//
	// If **AclStatus** is set to **on**, this parameter is required.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The backend port used by the CLB instance.
	//
	// Valid values: **1** to **65535**.
	//
	// If the **VServerGroupId** parameter is not set, this parameter is required.
	AclStatus *string `json:"AclStatus,omitempty" xml:"AclStatus,omitempty"`
	// Specifies whether to use the Proxy protocol to pass client IP addresses to backend servers. Valid values:
	//
	// *   **true**: yes
	// *   **false** (default): no
	AclType *string `json:"AclType,omitempty" xml:"AclType,omitempty"`
	// The response string for UDP listener health checks. The string must be 1 to 64 characters in length and can contain only letters and digits.
	BackendServerPort *int32 `json:"BackendServerPort,omitempty" xml:"BackendServerPort,omitempty"`
	// The frontend port used by the CLB instance.
	//
	// Valid values: **1** to **65535**.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The ID of the vServer group.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the listener.
	//
	// The name must be 1 to 256 characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.), and underscores (\_).
	HealthCheckConnectPort *int32 `json:"HealthCheckConnectPort,omitempty" xml:"HealthCheckConnectPort,omitempty"`
	// The maximum bandwidth of the listener. Unit: Mbit/s. Valid values:
	//
	// **-1**: For a pay-by-data-transfer Internet-facing CLB instance, you can set this parameter to **-1**. This way, the bandwidth of the listener is unlimited.
	HealthCheckConnectTimeout *int32  `json:"HealthCheckConnectTimeout,omitempty" xml:"HealthCheckConnectTimeout,omitempty"`
	HealthCheckSwitch         *string `json:"HealthCheckSwitch,omitempty" xml:"HealthCheckSwitch,omitempty"`
	// Specifies whether to enable access control. Valid values:
	//
	// *   **on**: yes
	// *   **off** (default): no
	HealthyThreshold *int32 `json:"HealthyThreshold,omitempty" xml:"HealthyThreshold,omitempty"`
	// The ID of the CLB instance.
	ListenerPort *int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	// Specifies whether to enable the health check feature. Valid values:
	//
	// *   **on** (default): yes
	// *   **off**: no
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// The ID of the network ACL that is associated with the listener.
	//
	// If **AclStatus** is set to **on**, this parameter is required.
	MasterSlaveServerGroupId *string `json:"MasterSlaveServerGroupId,omitempty" xml:"MasterSlaveServerGroupId,omitempty"`
	OwnerAccount             *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                  *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the request.
	ProxyProtocolV2Enabled *bool `json:"ProxyProtocolV2Enabled,omitempty" xml:"ProxyProtocolV2Enabled,omitempty"`
	// The request string for UDP listener health checks. The string must be 1 to 64 characters in length and can contain only letters and digits.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. In this case, the health status is changed from **fail** to **success**.
	//
	// Valid values: **2** to **10**.
	Scheduler *string                                    `json:"Scheduler,omitempty" xml:"Scheduler,omitempty"`
	Tag       []*CreateLoadBalancerUDPListenerRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the region where the CLB instance is deployed.
	UnhealthyThreshold *int32 `json:"UnhealthyThreshold,omitempty" xml:"UnhealthyThreshold,omitempty"`
	// The operation that you want to perform. Set the value to **CreateLoadBalancerUDPListener**.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
	// The timeout period of a health check.
	//
	// If a backend server, such as an Elastic Compute Service (ECS) instance, does not respond to a probe packet within the specified timeout period, the server fails the health check. Unit: seconds.
	//
	// Valid values: **1** to **300**.
	HealthCheckExp *string `json:"healthCheckExp,omitempty" xml:"healthCheckExp,omitempty"`
	// The interval between two consecutive health checks. Unit: seconds.
	//
	// Valid values: **1** to **50**.
	HealthCheckInterval *int32 `json:"healthCheckInterval,omitempty" xml:"healthCheckInterval,omitempty"`
	// The routing algorithm. Valid values:
	//
	// *   **wrr** (default): Backend servers with higher weights receive more requests than backend servers with lower weights.
	// *   **rr**: Requests are distributed to backend servers in sequence.
	// *   **sch**: specifies consistent hashing that is based on source IP addresses. Requests from the same source IP address are distributed to the same backend server.
	// *   **tch**: specifies consistent hashing that is based on four factors: source IP address, destination IP address, source port, and destination port. Requests that contain the same information based on the four factors are distributed to the same backend server.
	// *   **qch**: specifies consistent hashing that is based on QUIC connection IDs. Requests that contain the same QUIC connection ID are distributed to the same backend server.
	//
	// Only high-performance CLB instances support the sch, tch, and qch consistent hashing algorithms.
	HealthCheckReq *string `json:"healthCheckReq,omitempty" xml:"healthCheckReq,omitempty"`
}

func (s CreateLoadBalancerUDPListenerRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateLoadBalancerUDPListenerRequest) GoString() string {
	return s.String()
}

func (s *CreateLoadBalancerUDPListenerRequest) SetAclId(v string) *CreateLoadBalancerUDPListenerRequest {
	s.AclId = &v
	return s
}

func (s *CreateLoadBalancerUDPListenerRequest) SetAclStatus(v string) *CreateLoadBalancerUDPListenerRequest {
	s.AclStatus = &v
	return s
}

func (s *CreateLoadBalancerUDPListenerRequest) SetAclType(v string) *CreateLoadBalancerUDPListenerRequest {
	s.AclType = &v
	return s
}

func (s *CreateLoadBalancerUDPListenerRequest) SetBackendServerPort(v int32) *CreateLoadBalancerUDPListenerRequest {
	s.BackendServerPort = &v
	return s
}

func (s *CreateLoadBalancerUDPListenerRequest) SetBandwidth(v int32) *CreateLoadBalancerUDPListenerRequest {
	s.Bandwidth = &v
	return s
}

func (s *CreateLoadBalancerUDPListenerRequest) SetDescription(v string) *CreateLoadBalancerUDPListenerRequest {
	s.Description = &v
	return s
}

func (s *CreateLoadBalancerUDPListenerRequest) SetHealthCheckConnectPort(v int32) *CreateLoadBalancerUDPListenerRequest {
	s.HealthCheckConnectPort = &v
	return s
}

func (s *CreateLoadBalancerUDPListenerRequest) SetHealthCheckConnectTimeout(v int32) *CreateLoadBalancerUDPListenerRequest {
	s.HealthCheckConnectTimeout = &v
	return s
}

func (s *CreateLoadBalancerUDPListenerRequest) SetHealthCheckSwitch(v string) *CreateLoadBalancerUDPListenerRequest {
	s.HealthCheckSwitch = &v
	return s
}

func (s *CreateLoadBalancerUDPListenerRequest) SetHealthyThreshold(v int32) *CreateLoadBalancerUDPListenerRequest {
	s.HealthyThreshold = &v
	return s
}

func (s *CreateLoadBalancerUDPListenerRequest) SetListenerPort(v int32) *CreateLoadBalancerUDPListenerRequest {
	s.ListenerPort = &v
	return s
}

func (s *CreateLoadBalancerUDPListenerRequest) SetLoadBalancerId(v string) *CreateLoadBalancerUDPListenerRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *CreateLoadBalancerUDPListenerRequest) SetMasterSlaveServerGroupId(v string) *CreateLoadBalancerUDPListenerRequest {
	s.MasterSlaveServerGroupId = &v
	return s
}

func (s *CreateLoadBalancerUDPListenerRequest) SetOwnerAccount(v string) *CreateLoadBalancerUDPListenerRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateLoadBalancerUDPListenerRequest) SetOwnerId(v int64) *CreateLoadBalancerUDPListenerRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateLoadBalancerUDPListenerRequest) SetProxyProtocolV2Enabled(v bool) *CreateLoadBalancerUDPListenerRequest {
	s.ProxyProtocolV2Enabled = &v
	return s
}

func (s *CreateLoadBalancerUDPListenerRequest) SetRegionId(v string) *CreateLoadBalancerUDPListenerRequest {
	s.RegionId = &v
	return s
}

func (s *CreateLoadBalancerUDPListenerRequest) SetResourceOwnerAccount(v string) *CreateLoadBalancerUDPListenerRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateLoadBalancerUDPListenerRequest) SetResourceOwnerId(v int64) *CreateLoadBalancerUDPListenerRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateLoadBalancerUDPListenerRequest) SetScheduler(v string) *CreateLoadBalancerUDPListenerRequest {
	s.Scheduler = &v
	return s
}

func (s *CreateLoadBalancerUDPListenerRequest) SetTag(v []*CreateLoadBalancerUDPListenerRequestTag) *CreateLoadBalancerUDPListenerRequest {
	s.Tag = v
	return s
}

func (s *CreateLoadBalancerUDPListenerRequest) SetUnhealthyThreshold(v int32) *CreateLoadBalancerUDPListenerRequest {
	s.UnhealthyThreshold = &v
	return s
}

func (s *CreateLoadBalancerUDPListenerRequest) SetVServerGroupId(v string) *CreateLoadBalancerUDPListenerRequest {
	s.VServerGroupId = &v
	return s
}

func (s *CreateLoadBalancerUDPListenerRequest) SetHealthCheckExp(v string) *CreateLoadBalancerUDPListenerRequest {
	s.HealthCheckExp = &v
	return s
}

func (s *CreateLoadBalancerUDPListenerRequest) SetHealthCheckInterval(v int32) *CreateLoadBalancerUDPListenerRequest {
	s.HealthCheckInterval = &v
	return s
}

func (s *CreateLoadBalancerUDPListenerRequest) SetHealthCheckReq(v string) *CreateLoadBalancerUDPListenerRequest {
	s.HealthCheckReq = &v
	return s
}

type CreateLoadBalancerUDPListenerRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateLoadBalancerUDPListenerRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateLoadBalancerUDPListenerRequestTag) GoString() string {
	return s.String()
}

func (s *CreateLoadBalancerUDPListenerRequestTag) SetKey(v string) *CreateLoadBalancerUDPListenerRequestTag {
	s.Key = &v
	return s
}

func (s *CreateLoadBalancerUDPListenerRequestTag) SetValue(v string) *CreateLoadBalancerUDPListenerRequestTag {
	s.Value = &v
	return s
}

type CreateLoadBalancerUDPListenerResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateLoadBalancerUDPListenerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateLoadBalancerUDPListenerResponseBody) GoString() string {
	return s.String()
}

func (s *CreateLoadBalancerUDPListenerResponseBody) SetRequestId(v string) *CreateLoadBalancerUDPListenerResponseBody {
	s.RequestId = &v
	return s
}

type CreateLoadBalancerUDPListenerResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateLoadBalancerUDPListenerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateLoadBalancerUDPListenerResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateLoadBalancerUDPListenerResponse) GoString() string {
	return s.String()
}

func (s *CreateLoadBalancerUDPListenerResponse) SetHeaders(v map[string]*string) *CreateLoadBalancerUDPListenerResponse {
	s.Headers = v
	return s
}

func (s *CreateLoadBalancerUDPListenerResponse) SetStatusCode(v int32) *CreateLoadBalancerUDPListenerResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateLoadBalancerUDPListenerResponse) SetBody(v *CreateLoadBalancerUDPListenerResponseBody) *CreateLoadBalancerUDPListenerResponse {
	s.Body = v
	return s
}

type CreateMasterSlaveServerGroupRequest struct {
	// The name of the primary/secondary server group.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// The ID of the primary/secondary server group.
	MasterSlaveBackendServers *string `json:"MasterSlaveBackendServers,omitempty" xml:"MasterSlaveBackendServers,omitempty"`
	// The list of backend servers in the primary/secondary server group.
	//
	// The value of this parameter must be a STRING list in the JSON format. You can specify up to 20 elements in each request.
	//
	// *   **ServerId**: This parameter is required. Specify the ID of the backend server. This parameter must be of the STRING type.
	//
	// *   **Port**: This parameter is required. Specify the port that is used by the backend server. This parameter must be of the INTEGER type. Valid values: **1** to **65535**.
	//
	// *   **Weight**: This parameter is required. Specify the weight of the backend server. This parameter must be of the INTEGER type. Valid values: **0** to **100**.
	//
	// *   **Description**: This parameter is optional. Specify the description of the backend server. This parameter must be of the STRING type. The description must be 1 to 80 characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.),and underscores (\_).
	//
	// *   **ServerType**: Specify the type of the backend server. This parameter must be of the STRING type. Valid values:
	//
	//     *   **Master**: primary server
	//
	//     <!---->
	//
	//     *   **Slave**: secondary server
	//
	// *   **Type**: Specify the type of backend server. This parameter must be of the STRING type. Valid values:
	//
	//     *   **ecs**: an ECS instance
	//     *   **eni**: an elastic network interface (ENI)
	//
	// *   **ServerIp**: the IP address of the ECS instance or ENI
	//
	// A primary/secondary server group can contain at most two backend servers.
	//
	// If you do not set this parameter, an empty primary/secondary server group is created.
	//
	// Examples:
	//
	// *   ECS: `[{ "ServerId": "i-xxxxxxxxx", "Weight": "100", "Type": "ecs", "Port":"82","ServerType":"Master","Description":"test-112" }, { "ServerId": "i-xxxxxxxxx", "Weight": "100", "Type": "ecs", "Port":"84","ServerType":"Slave","Description":"test-112" }]`
	//
	// <!---->
	//
	// *   ENI: `[{ "ServerId": "eni-xxxxxxxxx", "Weight": "100", "Type": "eni", "Port":"80","ServerType":"Master","Description":"test-112" }, { "ServerId": "eni-xxxxxxxxx", "Weight": "100", "Type": "eni", "ServerIp": "192.168.**.**", "Port":"80","ServerType":"Slave","Description":"test-112" }]`
	// *   ENI with multiple IP addresses: `[{ "ServerId": "eni-xxxxxxxxx", "Weight": "100", "Type": "eni","ServerIp": "192.168.**.**", "Port":"80","ServerType":"Master","Description":"test-112" }, { "ServerId": "eni-xxxxxxxxx", "Weight": "100", "Type": "eni","ServerIp": "192.168.**.**", "Port":"80","ServerType":"Slave","Description":"test-112" }]`
	MasterSlaveServerGroupName *string `json:"MasterSlaveServerGroupName,omitempty" xml:"MasterSlaveServerGroupName,omitempty"`
	OwnerAccount               *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                    *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the Classic Load Balancer (CLB) instance.
	RegionId             *string                                   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string                                   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                                    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tag                  []*CreateMasterSlaveServerGroupRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s CreateMasterSlaveServerGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateMasterSlaveServerGroupRequest) GoString() string {
	return s.String()
}

func (s *CreateMasterSlaveServerGroupRequest) SetLoadBalancerId(v string) *CreateMasterSlaveServerGroupRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *CreateMasterSlaveServerGroupRequest) SetMasterSlaveBackendServers(v string) *CreateMasterSlaveServerGroupRequest {
	s.MasterSlaveBackendServers = &v
	return s
}

func (s *CreateMasterSlaveServerGroupRequest) SetMasterSlaveServerGroupName(v string) *CreateMasterSlaveServerGroupRequest {
	s.MasterSlaveServerGroupName = &v
	return s
}

func (s *CreateMasterSlaveServerGroupRequest) SetOwnerAccount(v string) *CreateMasterSlaveServerGroupRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateMasterSlaveServerGroupRequest) SetOwnerId(v int64) *CreateMasterSlaveServerGroupRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateMasterSlaveServerGroupRequest) SetRegionId(v string) *CreateMasterSlaveServerGroupRequest {
	s.RegionId = &v
	return s
}

func (s *CreateMasterSlaveServerGroupRequest) SetResourceOwnerAccount(v string) *CreateMasterSlaveServerGroupRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateMasterSlaveServerGroupRequest) SetResourceOwnerId(v int64) *CreateMasterSlaveServerGroupRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateMasterSlaveServerGroupRequest) SetTag(v []*CreateMasterSlaveServerGroupRequestTag) *CreateMasterSlaveServerGroupRequest {
	s.Tag = v
	return s
}

type CreateMasterSlaveServerGroupRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateMasterSlaveServerGroupRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateMasterSlaveServerGroupRequestTag) GoString() string {
	return s.String()
}

func (s *CreateMasterSlaveServerGroupRequestTag) SetKey(v string) *CreateMasterSlaveServerGroupRequestTag {
	s.Key = &v
	return s
}

func (s *CreateMasterSlaveServerGroupRequestTag) SetValue(v string) *CreateMasterSlaveServerGroupRequestTag {
	s.Value = &v
	return s
}

type CreateMasterSlaveServerGroupResponseBody struct {
	// The type of the backend server. Valid values:
	//
	// *   **ecs**: an ECS instance
	// *   **eni**: an ENI
	MasterSlaveBackendServers *CreateMasterSlaveServerGroupResponseBodyMasterSlaveBackendServers `json:"MasterSlaveBackendServers,omitempty" xml:"MasterSlaveBackendServers,omitempty" type:"Struct"`
	// The ID of the request.
	MasterSlaveServerGroupId *string `json:"MasterSlaveServerGroupId,omitempty" xml:"MasterSlaveServerGroupId,omitempty"`
	// The list of backend servers in the primary/secondary server group.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateMasterSlaveServerGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateMasterSlaveServerGroupResponseBody) GoString() string {
	return s.String()
}

func (s *CreateMasterSlaveServerGroupResponseBody) SetMasterSlaveBackendServers(v *CreateMasterSlaveServerGroupResponseBodyMasterSlaveBackendServers) *CreateMasterSlaveServerGroupResponseBody {
	s.MasterSlaveBackendServers = v
	return s
}

func (s *CreateMasterSlaveServerGroupResponseBody) SetMasterSlaveServerGroupId(v string) *CreateMasterSlaveServerGroupResponseBody {
	s.MasterSlaveServerGroupId = &v
	return s
}

func (s *CreateMasterSlaveServerGroupResponseBody) SetRequestId(v string) *CreateMasterSlaveServerGroupResponseBody {
	s.RequestId = &v
	return s
}

type CreateMasterSlaveServerGroupResponseBodyMasterSlaveBackendServers struct {
	MasterSlaveBackendServer []*CreateMasterSlaveServerGroupResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer `json:"MasterSlaveBackendServer,omitempty" xml:"MasterSlaveBackendServer,omitempty" type:"Repeated"`
}

func (s CreateMasterSlaveServerGroupResponseBodyMasterSlaveBackendServers) String() string {
	return tea.Prettify(s)
}

func (s CreateMasterSlaveServerGroupResponseBodyMasterSlaveBackendServers) GoString() string {
	return s.String()
}

func (s *CreateMasterSlaveServerGroupResponseBodyMasterSlaveBackendServers) SetMasterSlaveBackendServer(v []*CreateMasterSlaveServerGroupResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer) *CreateMasterSlaveServerGroupResponseBodyMasterSlaveBackendServers {
	s.MasterSlaveBackendServer = v
	return s
}

type CreateMasterSlaveServerGroupResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer struct {
	// The port number used by the backend server.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the ECS instance or ENI that is added.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The type of the backend server.
	//
	// Valid values: **Master** and **Slave**.
	ServerId *string `json:"ServerId,omitempty" xml:"ServerId,omitempty"`
	// Creates a primary/secondary server group. A primary/secondary server group can contain only two Elastic Compute Service (ECS) instances: one of the ECS instances functions as the primary server and the other functions as the secondary server.
	ServerType *string `json:"ServerType,omitempty" xml:"ServerType,omitempty"`
	// The weight of the backend server.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The description of the primary/secondary server group.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s CreateMasterSlaveServerGroupResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer) String() string {
	return tea.Prettify(s)
}

func (s CreateMasterSlaveServerGroupResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer) GoString() string {
	return s.String()
}

func (s *CreateMasterSlaveServerGroupResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer) SetDescription(v string) *CreateMasterSlaveServerGroupResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer {
	s.Description = &v
	return s
}

func (s *CreateMasterSlaveServerGroupResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer) SetPort(v int32) *CreateMasterSlaveServerGroupResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer {
	s.Port = &v
	return s
}

func (s *CreateMasterSlaveServerGroupResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer) SetServerId(v string) *CreateMasterSlaveServerGroupResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer {
	s.ServerId = &v
	return s
}

func (s *CreateMasterSlaveServerGroupResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer) SetServerType(v string) *CreateMasterSlaveServerGroupResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer {
	s.ServerType = &v
	return s
}

func (s *CreateMasterSlaveServerGroupResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer) SetType(v string) *CreateMasterSlaveServerGroupResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer {
	s.Type = &v
	return s
}

func (s *CreateMasterSlaveServerGroupResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer) SetWeight(v int32) *CreateMasterSlaveServerGroupResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer {
	s.Weight = &v
	return s
}

type CreateMasterSlaveServerGroupResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateMasterSlaveServerGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateMasterSlaveServerGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateMasterSlaveServerGroupResponse) GoString() string {
	return s.String()
}

func (s *CreateMasterSlaveServerGroupResponse) SetHeaders(v map[string]*string) *CreateMasterSlaveServerGroupResponse {
	s.Headers = v
	return s
}

func (s *CreateMasterSlaveServerGroupResponse) SetStatusCode(v int32) *CreateMasterSlaveServerGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateMasterSlaveServerGroupResponse) SetBody(v *CreateMasterSlaveServerGroupResponseBody) *CreateMasterSlaveServerGroupResponse {
	s.Body = v
	return s
}

type CreateRulesRequest struct {
	// The frontend protocol that is used by the SLB instance.
	//
	// >  This parameter is required when listeners that use different protocols listen on the same port.
	ListenerPort *int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	// The forwarding rules to be created. A maximum of 10 forwarding rules can be specified in each request. Each forwarding rule contains the following parameters:
	//
	// *   **RuleName**: Required. The value must be of the STRING type. The name of the forwarding rule. The name must be 1 to 40 characters in length, and can contain only letters, digits, hyphens (-), forward slashes (/), periods (.),and underscores (\_). Forwarding rule names must be unique within each listener.
	// *   **Domain**: Optional. The value must be of the STRING type. The domain name to be associated with the forwarding rule. You must specify at least this parameter or **Url**.
	// *   **Url**: Optional. The URL to be specified in the forwarding rule. The value must be of the STRING type. The URL must be 1 to 80 characters in length, and can contain only letters, digits, hyphens (-), forward slashes (/), periods (.), percent signs (%), question marks (?), number signs (#), and ampersands (&). The URL must not be a single forward slash (/). However, it must start with a forward slash (/). You must specify at least the URL or **Domain**.
	// *   **VServerGroupId**: Required. The value must be of the STRING type. The ID of the vServer group to be specified in the forwarding rule.
	//
	// >  You must specify at least `Domain` or `Url`. You can also specify both. The combination of `Domain` and `Url` must be unique within a listener.
	ListenerProtocol *string `json:"ListenerProtocol,omitempty" xml:"ListenerProtocol,omitempty"`
	// The frontend port that is used by the Server Load Balancer (SLB) instance.
	//
	// Valid values: **1 to 65535**.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the SLB instance.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the request.
	RuleList *string `json:"RuleList,omitempty" xml:"RuleList,omitempty"`
}

func (s CreateRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateRulesRequest) GoString() string {
	return s.String()
}

func (s *CreateRulesRequest) SetListenerPort(v int32) *CreateRulesRequest {
	s.ListenerPort = &v
	return s
}

func (s *CreateRulesRequest) SetListenerProtocol(v string) *CreateRulesRequest {
	s.ListenerProtocol = &v
	return s
}

func (s *CreateRulesRequest) SetLoadBalancerId(v string) *CreateRulesRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *CreateRulesRequest) SetOwnerAccount(v string) *CreateRulesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateRulesRequest) SetOwnerId(v int64) *CreateRulesRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateRulesRequest) SetRegionId(v string) *CreateRulesRequest {
	s.RegionId = &v
	return s
}

func (s *CreateRulesRequest) SetResourceOwnerAccount(v string) *CreateRulesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateRulesRequest) SetResourceOwnerId(v int64) *CreateRulesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateRulesRequest) SetRuleList(v string) *CreateRulesRequest {
	s.RuleList = &v
	return s
}

type CreateRulesResponseBody struct {
	// The list of forwarding rules.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The name of the forwarding rule.
	Rules *CreateRulesResponseBodyRules `json:"Rules,omitempty" xml:"Rules,omitempty" type:"Struct"`
}

func (s CreateRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateRulesResponseBody) GoString() string {
	return s.String()
}

func (s *CreateRulesResponseBody) SetRequestId(v string) *CreateRulesResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateRulesResponseBody) SetRules(v *CreateRulesResponseBodyRules) *CreateRulesResponseBody {
	s.Rules = v
	return s
}

type CreateRulesResponseBodyRules struct {
	Rule []*CreateRulesResponseBodyRulesRule `json:"Rule,omitempty" xml:"Rule,omitempty" type:"Repeated"`
}

func (s CreateRulesResponseBodyRules) String() string {
	return tea.Prettify(s)
}

func (s CreateRulesResponseBodyRules) GoString() string {
	return s.String()
}

func (s *CreateRulesResponseBodyRules) SetRule(v []*CreateRulesResponseBodyRulesRule) *CreateRulesResponseBodyRules {
	s.Rule = v
	return s
}

type CreateRulesResponseBodyRulesRule struct {
	// Creates forwarding rules for HTTP or HTTPS listeners.
	RuleId *string `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	// The ID of the forwarding rule.
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
}

func (s CreateRulesResponseBodyRulesRule) String() string {
	return tea.Prettify(s)
}

func (s CreateRulesResponseBodyRulesRule) GoString() string {
	return s.String()
}

func (s *CreateRulesResponseBodyRulesRule) SetRuleId(v string) *CreateRulesResponseBodyRulesRule {
	s.RuleId = &v
	return s
}

func (s *CreateRulesResponseBodyRulesRule) SetRuleName(v string) *CreateRulesResponseBodyRulesRule {
	s.RuleName = &v
	return s
}

type CreateRulesResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateRulesResponse) GoString() string {
	return s.String()
}

func (s *CreateRulesResponse) SetHeaders(v map[string]*string) *CreateRulesResponse {
	s.Headers = v
	return s
}

func (s *CreateRulesResponse) SetStatusCode(v int32) *CreateRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateRulesResponse) SetBody(v *CreateRulesResponseBody) *CreateRulesResponse {
	s.Body = v
	return s
}

type CreateTLSCipherPolicyRequest struct {
	// The supported cipher suites, which are determined by the TLS protocol version. You can specify at most 32 cipher suites.
	//
	// TLS 1.0 and TLS 1.1 support the following cipher suites:
	//
	// *   **ECDHE-ECDSA-AES128-SHA**
	// *   **ECDHE-ECDSA-AES256-SHA**
	// *   **ECDHE-RSA-AES128-SHA**
	// *   **ECDHE-RSA-AES256-SHA**
	// *   **AES128-SHA**
	// *   **AES256-SHA**
	// *   **DES-CBC3-SHA**
	//
	// TLS 1.2 supports the following cipher suites:
	//
	// *   **ECDHE-ECDSA-AES128-SHA**
	// *   **ECDHE-ECDSA-AES256-SHA**
	// *   **ECDHE-RSA-AES128-SHA**
	// *   **ECDHE-RSA-AES256-SHA**
	// *   **AES128-SHA**
	// *   **AES256-SHA**
	// *   **DES-CBC3-SHA**
	// *   **ECDHE-ECDSA-AES128-GCM-SHA256**
	// *   **ECDHE-ECDSA-AES256-GCM-SHA384**
	// *   **ECDHE-ECDSA-AES128-SHA256**
	// *   **ECDHE-ECDSA-AES256-SHA384**
	// *   **ECDHE-RSA-AES128-GCM-SHA256**
	// *   **ECDHE-RSA-AES256-GCM-SHA384**
	// *   **ECDHE-RSA-AES128-SHA256**
	// *   **ECDHE-RSA-AES256-SHA384**
	// *   **AES128-GCM-SHA256**
	// *   **AES256-GCM-SHA384**
	// *   **AES128-SHA256**
	// *   **AES256-SHA256**
	//
	// TLS 1.3 supports the following cipher suites:
	//
	// *   **TLS_AES\_128\_GCM_SHA256**
	// *   **TLS_AES\_256\_GCM_SHA384**
	// *   **TLS_CHACHA20\_POLY1305\_SHA256**
	// *   **TLS_AES\_128\_CCM_SHA256**
	// *   **TLS_AES\_128\_CCM\_8\_SHA256**
	Ciphers []*string `json:"Ciphers,omitempty" xml:"Ciphers,omitempty" type:"Repeated"`
	// The name of the TLS policy. The name must be 1 to 200 characters in length, and can contain letters, digits, periods (.), underscores (\_), and hyphens (-).
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the Server Load Balancer (SLB) instance is created.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The version of the TLS protocol. Valid values: **TLSv1.0**, **TLSv1.1**, **TLSv1.2**, and **TLSv1.3**. You can specify at most four TLS versions.
	TLSVersions []*string `json:"TLSVersions,omitempty" xml:"TLSVersions,omitempty" type:"Repeated"`
}

func (s CreateTLSCipherPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateTLSCipherPolicyRequest) GoString() string {
	return s.String()
}

func (s *CreateTLSCipherPolicyRequest) SetCiphers(v []*string) *CreateTLSCipherPolicyRequest {
	s.Ciphers = v
	return s
}

func (s *CreateTLSCipherPolicyRequest) SetName(v string) *CreateTLSCipherPolicyRequest {
	s.Name = &v
	return s
}

func (s *CreateTLSCipherPolicyRequest) SetOwnerAccount(v string) *CreateTLSCipherPolicyRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateTLSCipherPolicyRequest) SetOwnerId(v int64) *CreateTLSCipherPolicyRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateTLSCipherPolicyRequest) SetRegionId(v string) *CreateTLSCipherPolicyRequest {
	s.RegionId = &v
	return s
}

func (s *CreateTLSCipherPolicyRequest) SetResourceOwnerAccount(v string) *CreateTLSCipherPolicyRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateTLSCipherPolicyRequest) SetResourceOwnerId(v int64) *CreateTLSCipherPolicyRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateTLSCipherPolicyRequest) SetTLSVersions(v []*string) *CreateTLSCipherPolicyRequest {
	s.TLSVersions = v
	return s
}

type CreateTLSCipherPolicyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the policy.
	TLSCipherPolicyId *string `json:"TLSCipherPolicyId,omitempty" xml:"TLSCipherPolicyId,omitempty"`
}

func (s CreateTLSCipherPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateTLSCipherPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *CreateTLSCipherPolicyResponseBody) SetRequestId(v string) *CreateTLSCipherPolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateTLSCipherPolicyResponseBody) SetTLSCipherPolicyId(v string) *CreateTLSCipherPolicyResponseBody {
	s.TLSCipherPolicyId = &v
	return s
}

type CreateTLSCipherPolicyResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateTLSCipherPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateTLSCipherPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateTLSCipherPolicyResponse) GoString() string {
	return s.String()
}

func (s *CreateTLSCipherPolicyResponse) SetHeaders(v map[string]*string) *CreateTLSCipherPolicyResponse {
	s.Headers = v
	return s
}

func (s *CreateTLSCipherPolicyResponse) SetStatusCode(v int32) *CreateTLSCipherPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateTLSCipherPolicyResponse) SetBody(v *CreateTLSCipherPolicyResponseBody) *CreateTLSCipherPolicyResponse {
	s.Body = v
	return s
}

type CreateVServerGroupRequest struct {
	// The ID of the vServer group.
	BackendServers *string `json:"BackendServers,omitempty" xml:"BackendServers,omitempty"`
	// The name of the vServer group.
	//
	// The name must be 1 to 80 characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.),and underscores (\_).
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the Server Load Balancer (SLB) instance.
	RegionId             *string                         `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string                         `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                          `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tag                  []*CreateVServerGroupRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The list of backend servers to be added.
	//
	// The value of this parameter must be a STRING list in the JSON format. You can specify up to 20 elements in each request.
	//
	// *   **ServerId**: Required. Specify the ID of an Elastic Compute Service (ECS) instance or an Elastic Network Interface (ENI). This parameter must be of the STRING type.
	//
	// *   **Port**: Required. Specify the port that is used by the backend server. This parameter must be of the INTEGER type. Valid values: **1** to **65535**.
	//
	// *   **Weight**: Required. Specify the weight of the backend server. This parameter must be of the INTEGER type. Valid values: **0** to **100**.
	//
	// *   **Description**: Optional. Specify the description of the backend server. This parameter must be of the STRING type. The description must be 1 to 80 characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.),and underscores (\_).
	//
	// *   **Type**: Specify the type of the backend server. This parameter must be of the STRING type. Valid values:
	//
	//     *   **ecs**: an ECS instance. This is the default value.
	//     *   **eni**: an ENI.
	//
	// *   **ServerIp**: The IP address of the ECS instance or ENI.
	//
	// Examples:
	//
	// *   ECS instance:`  [{ "ServerId": "i-xxxxxxxxx", "Weight": "100", "Type": "ecs", "Port": "80", "Description": "test-112" }]. `
	// *   ENI:`  [{ "ServerId": "eni-xxxxxxxxx", "Weight": "100", "Type": "eni", "ServerIp": "192.168.**.**", "Port":"80","Description":"test-112" }] `
	// *   ENI with multiple IP addresses:`  [{ "ServerId": "eni-xxxxxxxxx", "Weight": "100", "Type": "eni", "ServerIp": "192.168.**.**", "Port":"80","Description":"test-112" },{ "ServerId": "eni-xxxxxxxxx", "Weight": "100", "Type": "eni", "ServerIp": "172.166.**.**", "Port":"80","Description":"test-113" }] `
	VServerGroupName *string `json:"VServerGroupName,omitempty" xml:"VServerGroupName,omitempty"`
}

func (s CreateVServerGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateVServerGroupRequest) GoString() string {
	return s.String()
}

func (s *CreateVServerGroupRequest) SetBackendServers(v string) *CreateVServerGroupRequest {
	s.BackendServers = &v
	return s
}

func (s *CreateVServerGroupRequest) SetLoadBalancerId(v string) *CreateVServerGroupRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *CreateVServerGroupRequest) SetOwnerAccount(v string) *CreateVServerGroupRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateVServerGroupRequest) SetOwnerId(v int64) *CreateVServerGroupRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateVServerGroupRequest) SetRegionId(v string) *CreateVServerGroupRequest {
	s.RegionId = &v
	return s
}

func (s *CreateVServerGroupRequest) SetResourceOwnerAccount(v string) *CreateVServerGroupRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateVServerGroupRequest) SetResourceOwnerId(v int64) *CreateVServerGroupRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateVServerGroupRequest) SetTag(v []*CreateVServerGroupRequestTag) *CreateVServerGroupRequest {
	s.Tag = v
	return s
}

func (s *CreateVServerGroupRequest) SetVServerGroupName(v string) *CreateVServerGroupRequest {
	s.VServerGroupName = &v
	return s
}

type CreateVServerGroupRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateVServerGroupRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateVServerGroupRequestTag) GoString() string {
	return s.String()
}

func (s *CreateVServerGroupRequestTag) SetKey(v string) *CreateVServerGroupRequestTag {
	s.Key = &v
	return s
}

func (s *CreateVServerGroupRequestTag) SetValue(v string) *CreateVServerGroupRequestTag {
	s.Value = &v
	return s
}

type CreateVServerGroupResponseBody struct {
	// The type of the backend server. Valid values:
	//
	// *   **ecs**: an ECS instance. This is the default value.
	// *   **eni**: an ENI.
	BackendServers *CreateVServerGroupResponseBodyBackendServers `json:"BackendServers,omitempty" xml:"BackendServers,omitempty" type:"Struct"`
	// The list of backend servers.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the request.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
}

func (s CreateVServerGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateVServerGroupResponseBody) GoString() string {
	return s.String()
}

func (s *CreateVServerGroupResponseBody) SetBackendServers(v *CreateVServerGroupResponseBodyBackendServers) *CreateVServerGroupResponseBody {
	s.BackendServers = v
	return s
}

func (s *CreateVServerGroupResponseBody) SetRequestId(v string) *CreateVServerGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateVServerGroupResponseBody) SetVServerGroupId(v string) *CreateVServerGroupResponseBody {
	s.VServerGroupId = &v
	return s
}

type CreateVServerGroupResponseBodyBackendServers struct {
	BackendServer []*CreateVServerGroupResponseBodyBackendServersBackendServer `json:"BackendServer,omitempty" xml:"BackendServer,omitempty" type:"Repeated"`
}

func (s CreateVServerGroupResponseBodyBackendServers) String() string {
	return tea.Prettify(s)
}

func (s CreateVServerGroupResponseBodyBackendServers) GoString() string {
	return s.String()
}

func (s *CreateVServerGroupResponseBodyBackendServers) SetBackendServer(v []*CreateVServerGroupResponseBodyBackendServersBackendServer) *CreateVServerGroupResponseBodyBackendServers {
	s.BackendServer = v
	return s
}

type CreateVServerGroupResponseBodyBackendServersBackendServer struct {
	// backend server
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the ECS instance or ENI.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// Creates a vServer group and adds backend servers to the vServer group.
	ServerId *string `json:"ServerId,omitempty" xml:"ServerId,omitempty"`
	// The weight of the backend server.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The description of the vServer group.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s CreateVServerGroupResponseBodyBackendServersBackendServer) String() string {
	return tea.Prettify(s)
}

func (s CreateVServerGroupResponseBodyBackendServersBackendServer) GoString() string {
	return s.String()
}

func (s *CreateVServerGroupResponseBodyBackendServersBackendServer) SetDescription(v string) *CreateVServerGroupResponseBodyBackendServersBackendServer {
	s.Description = &v
	return s
}

func (s *CreateVServerGroupResponseBodyBackendServersBackendServer) SetPort(v int32) *CreateVServerGroupResponseBodyBackendServersBackendServer {
	s.Port = &v
	return s
}

func (s *CreateVServerGroupResponseBodyBackendServersBackendServer) SetServerId(v string) *CreateVServerGroupResponseBodyBackendServersBackendServer {
	s.ServerId = &v
	return s
}

func (s *CreateVServerGroupResponseBodyBackendServersBackendServer) SetType(v string) *CreateVServerGroupResponseBodyBackendServersBackendServer {
	s.Type = &v
	return s
}

func (s *CreateVServerGroupResponseBodyBackendServersBackendServer) SetWeight(v int32) *CreateVServerGroupResponseBodyBackendServersBackendServer {
	s.Weight = &v
	return s
}

type CreateVServerGroupResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateVServerGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateVServerGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateVServerGroupResponse) GoString() string {
	return s.String()
}

func (s *CreateVServerGroupResponse) SetHeaders(v map[string]*string) *CreateVServerGroupResponse {
	s.Headers = v
	return s
}

func (s *CreateVServerGroupResponse) SetStatusCode(v int32) *CreateVServerGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateVServerGroupResponse) SetBody(v *CreateVServerGroupResponseBody) *CreateVServerGroupResponse {
	s.Body = v
	return s
}

type DeleteAccessControlListRequest struct {
	// >  An access control list can be deleted only after it is disassociated from a listener.
	AclId        *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the request.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteAccessControlListRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAccessControlListRequest) GoString() string {
	return s.String()
}

func (s *DeleteAccessControlListRequest) SetAclId(v string) *DeleteAccessControlListRequest {
	s.AclId = &v
	return s
}

func (s *DeleteAccessControlListRequest) SetOwnerAccount(v string) *DeleteAccessControlListRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteAccessControlListRequest) SetOwnerId(v int64) *DeleteAccessControlListRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteAccessControlListRequest) SetRegionId(v string) *DeleteAccessControlListRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteAccessControlListRequest) SetResourceOwnerAccount(v string) *DeleteAccessControlListRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteAccessControlListRequest) SetResourceOwnerId(v int64) *DeleteAccessControlListRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteAccessControlListResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteAccessControlListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAccessControlListResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAccessControlListResponseBody) SetRequestId(v string) *DeleteAccessControlListResponseBody {
	s.RequestId = &v
	return s
}

type DeleteAccessControlListResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteAccessControlListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteAccessControlListResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAccessControlListResponse) GoString() string {
	return s.String()
}

func (s *DeleteAccessControlListResponse) SetHeaders(v map[string]*string) *DeleteAccessControlListResponse {
	s.Headers = v
	return s
}

func (s *DeleteAccessControlListResponse) SetStatusCode(v int32) *DeleteAccessControlListResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAccessControlListResponse) SetBody(v *DeleteAccessControlListResponseBody) *DeleteAccessControlListResponse {
	s.Body = v
	return s
}

type DeleteAccessLogsDownloadAttributeRequest struct {
	LoadBalancerId         *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	LogsDownloadAttributes *string `json:"LogsDownloadAttributes,omitempty" xml:"LogsDownloadAttributes,omitempty"`
	OwnerAccount           *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The operation that you want to perform. Set the value to **DeleteAccessLogsDownloadAttribute**.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The tags that are added to the CLB instance. The tags must be key-value pairs that are contained in a JSON dictionary.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s DeleteAccessLogsDownloadAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAccessLogsDownloadAttributeRequest) GoString() string {
	return s.String()
}

func (s *DeleteAccessLogsDownloadAttributeRequest) SetLoadBalancerId(v string) *DeleteAccessLogsDownloadAttributeRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *DeleteAccessLogsDownloadAttributeRequest) SetLogsDownloadAttributes(v string) *DeleteAccessLogsDownloadAttributeRequest {
	s.LogsDownloadAttributes = &v
	return s
}

func (s *DeleteAccessLogsDownloadAttributeRequest) SetOwnerAccount(v string) *DeleteAccessLogsDownloadAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteAccessLogsDownloadAttributeRequest) SetOwnerId(v int64) *DeleteAccessLogsDownloadAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteAccessLogsDownloadAttributeRequest) SetRegionId(v string) *DeleteAccessLogsDownloadAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteAccessLogsDownloadAttributeRequest) SetResourceOwnerAccount(v string) *DeleteAccessLogsDownloadAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteAccessLogsDownloadAttributeRequest) SetResourceOwnerId(v int64) *DeleteAccessLogsDownloadAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteAccessLogsDownloadAttributeRequest) SetTags(v string) *DeleteAccessLogsDownloadAttributeRequest {
	s.Tags = &v
	return s
}

type DeleteAccessLogsDownloadAttributeResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteAccessLogsDownloadAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAccessLogsDownloadAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAccessLogsDownloadAttributeResponseBody) SetRequestId(v string) *DeleteAccessLogsDownloadAttributeResponseBody {
	s.RequestId = &v
	return s
}

type DeleteAccessLogsDownloadAttributeResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteAccessLogsDownloadAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteAccessLogsDownloadAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAccessLogsDownloadAttributeResponse) GoString() string {
	return s.String()
}

func (s *DeleteAccessLogsDownloadAttributeResponse) SetHeaders(v map[string]*string) *DeleteAccessLogsDownloadAttributeResponse {
	s.Headers = v
	return s
}

func (s *DeleteAccessLogsDownloadAttributeResponse) SetStatusCode(v int32) *DeleteAccessLogsDownloadAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAccessLogsDownloadAttributeResponse) SetBody(v *DeleteAccessLogsDownloadAttributeResponseBody) *DeleteAccessLogsDownloadAttributeResponse {
	s.Body = v
	return s
}

type DeleteCACertificateRequest struct {
	// >  CA certificates in use cannot be deleted.
	CACertificateId *string `json:"CACertificateId,omitempty" xml:"CACertificateId,omitempty"`
	OwnerAccount    *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId         *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the request.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteCACertificateRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteCACertificateRequest) GoString() string {
	return s.String()
}

func (s *DeleteCACertificateRequest) SetCACertificateId(v string) *DeleteCACertificateRequest {
	s.CACertificateId = &v
	return s
}

func (s *DeleteCACertificateRequest) SetOwnerAccount(v string) *DeleteCACertificateRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteCACertificateRequest) SetOwnerId(v int64) *DeleteCACertificateRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteCACertificateRequest) SetRegionId(v string) *DeleteCACertificateRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteCACertificateRequest) SetResourceOwnerAccount(v string) *DeleteCACertificateRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteCACertificateRequest) SetResourceOwnerId(v int64) *DeleteCACertificateRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteCACertificateResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteCACertificateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteCACertificateResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteCACertificateResponseBody) SetRequestId(v string) *DeleteCACertificateResponseBody {
	s.RequestId = &v
	return s
}

type DeleteCACertificateResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteCACertificateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteCACertificateResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteCACertificateResponse) GoString() string {
	return s.String()
}

func (s *DeleteCACertificateResponse) SetHeaders(v map[string]*string) *DeleteCACertificateResponse {
	s.Headers = v
	return s
}

func (s *DeleteCACertificateResponse) SetStatusCode(v int32) *DeleteCACertificateResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteCACertificateResponse) SetBody(v *DeleteCACertificateResponseBody) *DeleteCACertificateResponse {
	s.Body = v
	return s
}

type DeleteDomainExtensionRequest struct {
	// The ID of the request.
	DomainExtensionId *string `json:"DomainExtensionId,omitempty" xml:"DomainExtensionId,omitempty"`
	OwnerAccount      *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId           *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the domain name extension to be deleted.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteDomainExtensionRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDomainExtensionRequest) GoString() string {
	return s.String()
}

func (s *DeleteDomainExtensionRequest) SetDomainExtensionId(v string) *DeleteDomainExtensionRequest {
	s.DomainExtensionId = &v
	return s
}

func (s *DeleteDomainExtensionRequest) SetOwnerAccount(v string) *DeleteDomainExtensionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteDomainExtensionRequest) SetOwnerId(v int64) *DeleteDomainExtensionRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteDomainExtensionRequest) SetRegionId(v string) *DeleteDomainExtensionRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteDomainExtensionRequest) SetResourceOwnerAccount(v string) *DeleteDomainExtensionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteDomainExtensionRequest) SetResourceOwnerId(v int64) *DeleteDomainExtensionRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteDomainExtensionResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDomainExtensionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDomainExtensionResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDomainExtensionResponseBody) SetRequestId(v string) *DeleteDomainExtensionResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDomainExtensionResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDomainExtensionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDomainExtensionResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDomainExtensionResponse) GoString() string {
	return s.String()
}

func (s *DeleteDomainExtensionResponse) SetHeaders(v map[string]*string) *DeleteDomainExtensionResponse {
	s.Headers = v
	return s
}

func (s *DeleteDomainExtensionResponse) SetStatusCode(v int32) *DeleteDomainExtensionResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDomainExtensionResponse) SetBody(v *DeleteDomainExtensionResponseBody) *DeleteDomainExtensionResponse {
	s.Body = v
	return s
}

type DeleteLoadBalancerRequest struct {
	// If the SLB instance that you want to delete has deletion protection enabled, the system reports an error in the following formats:
	//
	// *   JSON format
	//
	//     ```
	//
	//         {
	//         "RequestId": "7B7AB375-1EA6-4A18-9D1C-F258F2D57638",
	//         "HostId": "slb.aliyuncs.com",
	//         "Code": "OperationDenied.DeleteProtectionIsOn",
	//         "Message": "The loadbalancer can\"t be deleted due to DeleteProtection is enabled."
	//          }
	//
	//     ```
	//
	// *   XML format
	//
	//     ```
	//
	//        <?xml version="1.0" encoding="UTF-8" ?>
	//             <DeleteLoadBabalancerResponse>
	//         <RequestId>7B7AB375-1EA6-4A18-9D1C-F258F2D57638</RequestId>
	//         <HostId>slb.aliyuncs.com</HostId>
	//         <Code>OperationDenied.DeleteProtectionIsOn</Code>
	//         <Message>The loadbalancer can\"t be deleted due to DeleteProtection is enabled.</Message>
	//            </DeleteLoadBabalancerResponse>
	//
	//     ```
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the request.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteLoadBalancerRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteLoadBalancerRequest) GoString() string {
	return s.String()
}

func (s *DeleteLoadBalancerRequest) SetLoadBalancerId(v string) *DeleteLoadBalancerRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *DeleteLoadBalancerRequest) SetOwnerAccount(v string) *DeleteLoadBalancerRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteLoadBalancerRequest) SetOwnerId(v int64) *DeleteLoadBalancerRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteLoadBalancerRequest) SetRegionId(v string) *DeleteLoadBalancerRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteLoadBalancerRequest) SetResourceOwnerAccount(v string) *DeleteLoadBalancerRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteLoadBalancerRequest) SetResourceOwnerId(v int64) *DeleteLoadBalancerRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteLoadBalancerResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteLoadBalancerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteLoadBalancerResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteLoadBalancerResponseBody) SetRequestId(v string) *DeleteLoadBalancerResponseBody {
	s.RequestId = &v
	return s
}

type DeleteLoadBalancerResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteLoadBalancerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteLoadBalancerResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteLoadBalancerResponse) GoString() string {
	return s.String()
}

func (s *DeleteLoadBalancerResponse) SetHeaders(v map[string]*string) *DeleteLoadBalancerResponse {
	s.Headers = v
	return s
}

func (s *DeleteLoadBalancerResponse) SetStatusCode(v int32) *DeleteLoadBalancerResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteLoadBalancerResponse) SetBody(v *DeleteLoadBalancerResponseBody) *DeleteLoadBalancerResponse {
	s.Body = v
	return s
}

type DeleteLoadBalancerListenerRequest struct {
	// The frontend port that is used by the CLB instance.
	//
	// Valid values: **1 to 65535**.
	ListenerPort *int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	// The frontend protocol that is used by the CLB instance.
	//
	// >  This parameter is required if the same port is specified for listeners of different protocols.
	ListenerProtocol *string `json:"ListenerProtocol,omitempty" xml:"ListenerProtocol,omitempty"`
	// The ID of the CLB instance.
	//
	// >  If the endpoint of the selected region is slb.aliyuncs.com, the **RegionId** parameter is required.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the Classic Load Balancer (CLB) instance.
	//
	// You can call the [DescribeRegions](~~27584~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteLoadBalancerListenerRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteLoadBalancerListenerRequest) GoString() string {
	return s.String()
}

func (s *DeleteLoadBalancerListenerRequest) SetListenerPort(v int32) *DeleteLoadBalancerListenerRequest {
	s.ListenerPort = &v
	return s
}

func (s *DeleteLoadBalancerListenerRequest) SetListenerProtocol(v string) *DeleteLoadBalancerListenerRequest {
	s.ListenerProtocol = &v
	return s
}

func (s *DeleteLoadBalancerListenerRequest) SetLoadBalancerId(v string) *DeleteLoadBalancerListenerRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *DeleteLoadBalancerListenerRequest) SetOwnerAccount(v string) *DeleteLoadBalancerListenerRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteLoadBalancerListenerRequest) SetOwnerId(v int64) *DeleteLoadBalancerListenerRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteLoadBalancerListenerRequest) SetRegionId(v string) *DeleteLoadBalancerListenerRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteLoadBalancerListenerRequest) SetResourceOwnerAccount(v string) *DeleteLoadBalancerListenerRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteLoadBalancerListenerRequest) SetResourceOwnerId(v int64) *DeleteLoadBalancerListenerRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteLoadBalancerListenerResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteLoadBalancerListenerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteLoadBalancerListenerResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteLoadBalancerListenerResponseBody) SetRequestId(v string) *DeleteLoadBalancerListenerResponseBody {
	s.RequestId = &v
	return s
}

type DeleteLoadBalancerListenerResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteLoadBalancerListenerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteLoadBalancerListenerResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteLoadBalancerListenerResponse) GoString() string {
	return s.String()
}

func (s *DeleteLoadBalancerListenerResponse) SetHeaders(v map[string]*string) *DeleteLoadBalancerListenerResponse {
	s.Headers = v
	return s
}

func (s *DeleteLoadBalancerListenerResponse) SetStatusCode(v int32) *DeleteLoadBalancerListenerResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteLoadBalancerListenerResponse) SetBody(v *DeleteLoadBalancerListenerResponseBody) *DeleteLoadBalancerListenerResponse {
	s.Body = v
	return s
}

type DeleteMasterSlaveServerGroupRequest struct {
	// The ID of the request.
	MasterSlaveServerGroupId *string `json:"MasterSlaveServerGroupId,omitempty" xml:"MasterSlaveServerGroupId,omitempty"`
	OwnerAccount             *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                  *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the active/standby server group to be deleted.
	//
	// >  An active/standby server group in use cannot be deleted.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteMasterSlaveServerGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteMasterSlaveServerGroupRequest) GoString() string {
	return s.String()
}

func (s *DeleteMasterSlaveServerGroupRequest) SetMasterSlaveServerGroupId(v string) *DeleteMasterSlaveServerGroupRequest {
	s.MasterSlaveServerGroupId = &v
	return s
}

func (s *DeleteMasterSlaveServerGroupRequest) SetOwnerAccount(v string) *DeleteMasterSlaveServerGroupRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteMasterSlaveServerGroupRequest) SetOwnerId(v int64) *DeleteMasterSlaveServerGroupRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteMasterSlaveServerGroupRequest) SetRegionId(v string) *DeleteMasterSlaveServerGroupRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteMasterSlaveServerGroupRequest) SetResourceOwnerAccount(v string) *DeleteMasterSlaveServerGroupRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteMasterSlaveServerGroupRequest) SetResourceOwnerId(v int64) *DeleteMasterSlaveServerGroupRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteMasterSlaveServerGroupResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteMasterSlaveServerGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteMasterSlaveServerGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteMasterSlaveServerGroupResponseBody) SetRequestId(v string) *DeleteMasterSlaveServerGroupResponseBody {
	s.RequestId = &v
	return s
}

type DeleteMasterSlaveServerGroupResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteMasterSlaveServerGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteMasterSlaveServerGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteMasterSlaveServerGroupResponse) GoString() string {
	return s.String()
}

func (s *DeleteMasterSlaveServerGroupResponse) SetHeaders(v map[string]*string) *DeleteMasterSlaveServerGroupResponse {
	s.Headers = v
	return s
}

func (s *DeleteMasterSlaveServerGroupResponse) SetStatusCode(v int32) *DeleteMasterSlaveServerGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteMasterSlaveServerGroupResponse) SetBody(v *DeleteMasterSlaveServerGroupResponseBody) *DeleteMasterSlaveServerGroupResponse {
	s.Body = v
	return s
}

type DeleteRulesRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the request.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// ## Limits
	//
	// The RuleIds parameter is required. You can specify up to 10 forwarding rules in each request.
	RuleIds *string `json:"RuleIds,omitempty" xml:"RuleIds,omitempty"`
}

func (s DeleteRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteRulesRequest) GoString() string {
	return s.String()
}

func (s *DeleteRulesRequest) SetOwnerAccount(v string) *DeleteRulesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteRulesRequest) SetOwnerId(v int64) *DeleteRulesRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteRulesRequest) SetRegionId(v string) *DeleteRulesRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteRulesRequest) SetResourceOwnerAccount(v string) *DeleteRulesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteRulesRequest) SetResourceOwnerId(v int64) *DeleteRulesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteRulesRequest) SetRuleIds(v string) *DeleteRulesRequest {
	s.RuleIds = &v
	return s
}

type DeleteRulesResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteRulesResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteRulesResponseBody) SetRequestId(v string) *DeleteRulesResponseBody {
	s.RequestId = &v
	return s
}

type DeleteRulesResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteRulesResponse) GoString() string {
	return s.String()
}

func (s *DeleteRulesResponse) SetHeaders(v map[string]*string) *DeleteRulesResponse {
	s.Headers = v
	return s
}

func (s *DeleteRulesResponse) SetStatusCode(v int32) *DeleteRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteRulesResponse) SetBody(v *DeleteRulesResponseBody) *DeleteRulesResponse {
	s.Body = v
	return s
}

type DeleteServerCertificateRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the request.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// >  You cannot delete server certificates that are in use.
	ServerCertificateId *string `json:"ServerCertificateId,omitempty" xml:"ServerCertificateId,omitempty"`
}

func (s DeleteServerCertificateRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteServerCertificateRequest) GoString() string {
	return s.String()
}

func (s *DeleteServerCertificateRequest) SetOwnerAccount(v string) *DeleteServerCertificateRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteServerCertificateRequest) SetOwnerId(v int64) *DeleteServerCertificateRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteServerCertificateRequest) SetRegionId(v string) *DeleteServerCertificateRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteServerCertificateRequest) SetResourceOwnerAccount(v string) *DeleteServerCertificateRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteServerCertificateRequest) SetResourceOwnerId(v int64) *DeleteServerCertificateRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteServerCertificateRequest) SetServerCertificateId(v string) *DeleteServerCertificateRequest {
	s.ServerCertificateId = &v
	return s
}

type DeleteServerCertificateResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteServerCertificateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteServerCertificateResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteServerCertificateResponseBody) SetRequestId(v string) *DeleteServerCertificateResponseBody {
	s.RequestId = &v
	return s
}

type DeleteServerCertificateResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteServerCertificateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteServerCertificateResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteServerCertificateResponse) GoString() string {
	return s.String()
}

func (s *DeleteServerCertificateResponse) SetHeaders(v map[string]*string) *DeleteServerCertificateResponse {
	s.Headers = v
	return s
}

func (s *DeleteServerCertificateResponse) SetStatusCode(v int32) *DeleteServerCertificateResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteServerCertificateResponse) SetBody(v *DeleteServerCertificateResponseBody) *DeleteServerCertificateResponse {
	s.Body = v
	return s
}

type DeleteTLSCipherPolicyRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the TLS policy.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the request.
	TLSCipherPolicyId *string `json:"TLSCipherPolicyId,omitempty" xml:"TLSCipherPolicyId,omitempty"`
}

func (s DeleteTLSCipherPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteTLSCipherPolicyRequest) GoString() string {
	return s.String()
}

func (s *DeleteTLSCipherPolicyRequest) SetOwnerAccount(v string) *DeleteTLSCipherPolicyRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteTLSCipherPolicyRequest) SetOwnerId(v int64) *DeleteTLSCipherPolicyRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteTLSCipherPolicyRequest) SetRegionId(v string) *DeleteTLSCipherPolicyRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteTLSCipherPolicyRequest) SetResourceOwnerAccount(v string) *DeleteTLSCipherPolicyRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteTLSCipherPolicyRequest) SetResourceOwnerId(v int64) *DeleteTLSCipherPolicyRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteTLSCipherPolicyRequest) SetTLSCipherPolicyId(v string) *DeleteTLSCipherPolicyRequest {
	s.TLSCipherPolicyId = &v
	return s
}

type DeleteTLSCipherPolicyResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteTLSCipherPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteTLSCipherPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteTLSCipherPolicyResponseBody) SetRequestId(v string) *DeleteTLSCipherPolicyResponseBody {
	s.RequestId = &v
	return s
}

type DeleteTLSCipherPolicyResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteTLSCipherPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteTLSCipherPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteTLSCipherPolicyResponse) GoString() string {
	return s.String()
}

func (s *DeleteTLSCipherPolicyResponse) SetHeaders(v map[string]*string) *DeleteTLSCipherPolicyResponse {
	s.Headers = v
	return s
}

func (s *DeleteTLSCipherPolicyResponse) SetStatusCode(v int32) *DeleteTLSCipherPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteTLSCipherPolicyResponse) SetBody(v *DeleteTLSCipherPolicyResponseBody) *DeleteTLSCipherPolicyResponse {
	s.Body = v
	return s
}

type DeleteVServerGroupRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the associated Server Load Balancer (SLB) instance belongs.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VServer group to be deleted.
	//
	// >  If the VServer group is in use, it cannot be deleted.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
}

func (s DeleteVServerGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteVServerGroupRequest) GoString() string {
	return s.String()
}

func (s *DeleteVServerGroupRequest) SetOwnerAccount(v string) *DeleteVServerGroupRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteVServerGroupRequest) SetOwnerId(v int64) *DeleteVServerGroupRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteVServerGroupRequest) SetRegionId(v string) *DeleteVServerGroupRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteVServerGroupRequest) SetResourceOwnerAccount(v string) *DeleteVServerGroupRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteVServerGroupRequest) SetResourceOwnerId(v int64) *DeleteVServerGroupRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteVServerGroupRequest) SetVServerGroupId(v string) *DeleteVServerGroupRequest {
	s.VServerGroupId = &v
	return s
}

type DeleteVServerGroupResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteVServerGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteVServerGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteVServerGroupResponseBody) SetRequestId(v string) *DeleteVServerGroupResponseBody {
	s.RequestId = &v
	return s
}

type DeleteVServerGroupResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteVServerGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteVServerGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteVServerGroupResponse) GoString() string {
	return s.String()
}

func (s *DeleteVServerGroupResponse) SetHeaders(v map[string]*string) *DeleteVServerGroupResponse {
	s.Headers = v
	return s
}

func (s *DeleteVServerGroupResponse) SetStatusCode(v int32) *DeleteVServerGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteVServerGroupResponse) SetBody(v *DeleteVServerGroupResponseBody) *DeleteVServerGroupResponse {
	s.Body = v
	return s
}

type DescribeAccessControlListAttributeRequest struct {
	AclEntryComment *string `json:"AclEntryComment,omitempty" xml:"AclEntryComment,omitempty"`
	AclId           *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	OwnerAccount    *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId         *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	Page            *int32  `json:"Page,omitempty" xml:"Page,omitempty"`
	PageSize        *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The time when the network ACL was created. The time follows the `YYYY-MM-DDThh:mm:ssZ` format.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeAccessControlListAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccessControlListAttributeRequest) GoString() string {
	return s.String()
}

func (s *DescribeAccessControlListAttributeRequest) SetAclEntryComment(v string) *DescribeAccessControlListAttributeRequest {
	s.AclEntryComment = &v
	return s
}

func (s *DescribeAccessControlListAttributeRequest) SetAclId(v string) *DescribeAccessControlListAttributeRequest {
	s.AclId = &v
	return s
}

func (s *DescribeAccessControlListAttributeRequest) SetOwnerAccount(v string) *DescribeAccessControlListAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeAccessControlListAttributeRequest) SetOwnerId(v int64) *DescribeAccessControlListAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeAccessControlListAttributeRequest) SetPage(v int32) *DescribeAccessControlListAttributeRequest {
	s.Page = &v
	return s
}

func (s *DescribeAccessControlListAttributeRequest) SetPageSize(v int32) *DescribeAccessControlListAttributeRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeAccessControlListAttributeRequest) SetRegionId(v string) *DescribeAccessControlListAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeAccessControlListAttributeRequest) SetResourceOwnerAccount(v string) *DescribeAccessControlListAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeAccessControlListAttributeRequest) SetResourceOwnerId(v int64) *DescribeAccessControlListAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeAccessControlListAttributeResponseBody struct {
	AclEntrys        *DescribeAccessControlListAttributeResponseBodyAclEntrys        `json:"AclEntrys,omitempty" xml:"AclEntrys,omitempty" type:"Struct"`
	AclId            *string                                                         `json:"AclId,omitempty" xml:"AclId,omitempty"`
	AclName          *string                                                         `json:"AclName,omitempty" xml:"AclName,omitempty"`
	AddressIPVersion *string                                                         `json:"AddressIPVersion,omitempty" xml:"AddressIPVersion,omitempty"`
	CreateTime       *string                                                         `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	RelatedListeners *DescribeAccessControlListAttributeResponseBodyRelatedListeners `json:"RelatedListeners,omitempty" xml:"RelatedListeners,omitempty" type:"Struct"`
	RequestId        *string                                                         `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	ResourceGroupId  *string                                                         `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	Tags             *DescribeAccessControlListAttributeResponseBodyTags             `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	TotalAclEntry    *int32                                                          `json:"TotalAclEntry,omitempty" xml:"TotalAclEntry,omitempty"`
}

func (s DescribeAccessControlListAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccessControlListAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAccessControlListAttributeResponseBody) SetAclEntrys(v *DescribeAccessControlListAttributeResponseBodyAclEntrys) *DescribeAccessControlListAttributeResponseBody {
	s.AclEntrys = v
	return s
}

func (s *DescribeAccessControlListAttributeResponseBody) SetAclId(v string) *DescribeAccessControlListAttributeResponseBody {
	s.AclId = &v
	return s
}

func (s *DescribeAccessControlListAttributeResponseBody) SetAclName(v string) *DescribeAccessControlListAttributeResponseBody {
	s.AclName = &v
	return s
}

func (s *DescribeAccessControlListAttributeResponseBody) SetAddressIPVersion(v string) *DescribeAccessControlListAttributeResponseBody {
	s.AddressIPVersion = &v
	return s
}

func (s *DescribeAccessControlListAttributeResponseBody) SetCreateTime(v string) *DescribeAccessControlListAttributeResponseBody {
	s.CreateTime = &v
	return s
}

func (s *DescribeAccessControlListAttributeResponseBody) SetRelatedListeners(v *DescribeAccessControlListAttributeResponseBodyRelatedListeners) *DescribeAccessControlListAttributeResponseBody {
	s.RelatedListeners = v
	return s
}

func (s *DescribeAccessControlListAttributeResponseBody) SetRequestId(v string) *DescribeAccessControlListAttributeResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeAccessControlListAttributeResponseBody) SetResourceGroupId(v string) *DescribeAccessControlListAttributeResponseBody {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeAccessControlListAttributeResponseBody) SetTags(v *DescribeAccessControlListAttributeResponseBodyTags) *DescribeAccessControlListAttributeResponseBody {
	s.Tags = v
	return s
}

func (s *DescribeAccessControlListAttributeResponseBody) SetTotalAclEntry(v int32) *DescribeAccessControlListAttributeResponseBody {
	s.TotalAclEntry = &v
	return s
}

type DescribeAccessControlListAttributeResponseBodyAclEntrys struct {
	AclEntry []*DescribeAccessControlListAttributeResponseBodyAclEntrysAclEntry `json:"AclEntry,omitempty" xml:"AclEntry,omitempty" type:"Repeated"`
}

func (s DescribeAccessControlListAttributeResponseBodyAclEntrys) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccessControlListAttributeResponseBodyAclEntrys) GoString() string {
	return s.String()
}

func (s *DescribeAccessControlListAttributeResponseBodyAclEntrys) SetAclEntry(v []*DescribeAccessControlListAttributeResponseBodyAclEntrysAclEntry) *DescribeAccessControlListAttributeResponseBodyAclEntrys {
	s.AclEntry = v
	return s
}

type DescribeAccessControlListAttributeResponseBodyAclEntrysAclEntry struct {
	AclEntryComment *string `json:"AclEntryComment,omitempty" xml:"AclEntryComment,omitempty"`
	AclEntryIP      *string `json:"AclEntryIP,omitempty" xml:"AclEntryIP,omitempty"`
}

func (s DescribeAccessControlListAttributeResponseBodyAclEntrysAclEntry) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccessControlListAttributeResponseBodyAclEntrysAclEntry) GoString() string {
	return s.String()
}

func (s *DescribeAccessControlListAttributeResponseBodyAclEntrysAclEntry) SetAclEntryComment(v string) *DescribeAccessControlListAttributeResponseBodyAclEntrysAclEntry {
	s.AclEntryComment = &v
	return s
}

func (s *DescribeAccessControlListAttributeResponseBodyAclEntrysAclEntry) SetAclEntryIP(v string) *DescribeAccessControlListAttributeResponseBodyAclEntrysAclEntry {
	s.AclEntryIP = &v
	return s
}

type DescribeAccessControlListAttributeResponseBodyRelatedListeners struct {
	RelatedListener []*DescribeAccessControlListAttributeResponseBodyRelatedListenersRelatedListener `json:"RelatedListener,omitempty" xml:"RelatedListener,omitempty" type:"Repeated"`
}

func (s DescribeAccessControlListAttributeResponseBodyRelatedListeners) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccessControlListAttributeResponseBodyRelatedListeners) GoString() string {
	return s.String()
}

func (s *DescribeAccessControlListAttributeResponseBodyRelatedListeners) SetRelatedListener(v []*DescribeAccessControlListAttributeResponseBodyRelatedListenersRelatedListener) *DescribeAccessControlListAttributeResponseBodyRelatedListeners {
	s.RelatedListener = v
	return s
}

type DescribeAccessControlListAttributeResponseBodyRelatedListenersRelatedListener struct {
	AclType        *string `json:"AclType,omitempty" xml:"AclType,omitempty"`
	ListenerPort   *int32  `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	Protocol       *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
}

func (s DescribeAccessControlListAttributeResponseBodyRelatedListenersRelatedListener) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccessControlListAttributeResponseBodyRelatedListenersRelatedListener) GoString() string {
	return s.String()
}

func (s *DescribeAccessControlListAttributeResponseBodyRelatedListenersRelatedListener) SetAclType(v string) *DescribeAccessControlListAttributeResponseBodyRelatedListenersRelatedListener {
	s.AclType = &v
	return s
}

func (s *DescribeAccessControlListAttributeResponseBodyRelatedListenersRelatedListener) SetListenerPort(v int32) *DescribeAccessControlListAttributeResponseBodyRelatedListenersRelatedListener {
	s.ListenerPort = &v
	return s
}

func (s *DescribeAccessControlListAttributeResponseBodyRelatedListenersRelatedListener) SetLoadBalancerId(v string) *DescribeAccessControlListAttributeResponseBodyRelatedListenersRelatedListener {
	s.LoadBalancerId = &v
	return s
}

func (s *DescribeAccessControlListAttributeResponseBodyRelatedListenersRelatedListener) SetProtocol(v string) *DescribeAccessControlListAttributeResponseBodyRelatedListenersRelatedListener {
	s.Protocol = &v
	return s
}

type DescribeAccessControlListAttributeResponseBodyTags struct {
	Tag []*DescribeAccessControlListAttributeResponseBodyTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeAccessControlListAttributeResponseBodyTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccessControlListAttributeResponseBodyTags) GoString() string {
	return s.String()
}

func (s *DescribeAccessControlListAttributeResponseBodyTags) SetTag(v []*DescribeAccessControlListAttributeResponseBodyTagsTag) *DescribeAccessControlListAttributeResponseBodyTags {
	s.Tag = v
	return s
}

type DescribeAccessControlListAttributeResponseBodyTagsTag struct {
	TagKey   *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s DescribeAccessControlListAttributeResponseBodyTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccessControlListAttributeResponseBodyTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeAccessControlListAttributeResponseBodyTagsTag) SetTagKey(v string) *DescribeAccessControlListAttributeResponseBodyTagsTag {
	s.TagKey = &v
	return s
}

func (s *DescribeAccessControlListAttributeResponseBodyTagsTag) SetTagValue(v string) *DescribeAccessControlListAttributeResponseBodyTagsTag {
	s.TagValue = &v
	return s
}

type DescribeAccessControlListAttributeResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeAccessControlListAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeAccessControlListAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccessControlListAttributeResponse) GoString() string {
	return s.String()
}

func (s *DescribeAccessControlListAttributeResponse) SetHeaders(v map[string]*string) *DescribeAccessControlListAttributeResponse {
	s.Headers = v
	return s
}

func (s *DescribeAccessControlListAttributeResponse) SetStatusCode(v int32) *DescribeAccessControlListAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAccessControlListAttributeResponse) SetBody(v *DescribeAccessControlListAttributeResponseBody) *DescribeAccessControlListAttributeResponse {
	s.Body = v
	return s
}

type DescribeAccessControlListsRequest struct {
	// The operation that you want to perform. Set the value to **DescribeAccessControlLists**.
	AclName *string `json:"AclName,omitempty" xml:"AclName,omitempty"`
	// The number of the page to return. Default value: **1**.
	AddressIPVersion *string `json:"AddressIPVersion,omitempty" xml:"AddressIPVersion,omitempty"`
	OwnerAccount     *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId          *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the network ACL.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The ID of the resource group.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The IP version that is used by the associated CLB instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the region where the network ACL is created.
	//
	// You can call the [DescribeRegions](~~27584~~) operation to query the IDs of regions.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeAccessControlListsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccessControlListsRequest) GoString() string {
	return s.String()
}

func (s *DescribeAccessControlListsRequest) SetAclName(v string) *DescribeAccessControlListsRequest {
	s.AclName = &v
	return s
}

func (s *DescribeAccessControlListsRequest) SetAddressIPVersion(v string) *DescribeAccessControlListsRequest {
	s.AddressIPVersion = &v
	return s
}

func (s *DescribeAccessControlListsRequest) SetOwnerAccount(v string) *DescribeAccessControlListsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeAccessControlListsRequest) SetOwnerId(v int64) *DescribeAccessControlListsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeAccessControlListsRequest) SetPageNumber(v int32) *DescribeAccessControlListsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeAccessControlListsRequest) SetPageSize(v int32) *DescribeAccessControlListsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeAccessControlListsRequest) SetRegionId(v string) *DescribeAccessControlListsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeAccessControlListsRequest) SetResourceGroupId(v string) *DescribeAccessControlListsRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeAccessControlListsRequest) SetResourceOwnerAccount(v string) *DescribeAccessControlListsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeAccessControlListsRequest) SetResourceOwnerId(v int64) *DescribeAccessControlListsRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeAccessControlListsResponseBody struct {
	// The ID of the request.
	Acls *DescribeAccessControlListsResponseBodyAcls `json:"Acls,omitempty" xml:"Acls,omitempty" type:"Struct"`
	// The list of network ACLs.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The name of the network ACL.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The number of the returned page. Pages start from page **1**. Default value: **1**.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of entries returned on each page. Maximum value: **50**. Default value: **10**.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeAccessControlListsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccessControlListsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAccessControlListsResponseBody) SetAcls(v *DescribeAccessControlListsResponseBodyAcls) *DescribeAccessControlListsResponseBody {
	s.Acls = v
	return s
}

func (s *DescribeAccessControlListsResponseBody) SetCount(v int32) *DescribeAccessControlListsResponseBody {
	s.Count = &v
	return s
}

func (s *DescribeAccessControlListsResponseBody) SetPageNumber(v int32) *DescribeAccessControlListsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeAccessControlListsResponseBody) SetPageSize(v int32) *DescribeAccessControlListsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeAccessControlListsResponseBody) SetRequestId(v string) *DescribeAccessControlListsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeAccessControlListsResponseBody) SetTotalCount(v int32) *DescribeAccessControlListsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeAccessControlListsResponseBodyAcls struct {
	Acl []*DescribeAccessControlListsResponseBodyAclsAcl `json:"Acl,omitempty" xml:"Acl,omitempty" type:"Repeated"`
}

func (s DescribeAccessControlListsResponseBodyAcls) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccessControlListsResponseBodyAcls) GoString() string {
	return s.String()
}

func (s *DescribeAccessControlListsResponseBodyAcls) SetAcl(v []*DescribeAccessControlListsResponseBodyAclsAcl) *DescribeAccessControlListsResponseBodyAcls {
	s.Acl = v
	return s
}

type DescribeAccessControlListsResponseBodyAclsAcl struct {
	// The ID of the resource group to which the CLB instance belongs.
	AclId   *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	AclName *string `json:"AclName,omitempty" xml:"AclName,omitempty"`
	// The number of network ACLs on the current page.
	AddressIPVersion *string                                            `json:"AddressIPVersion,omitempty" xml:"AddressIPVersion,omitempty"`
	CreateTime       *string                                            `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	ResourceGroupId  *string                                            `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	Tags             *DescribeAccessControlListsResponseBodyAclsAclTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
}

func (s DescribeAccessControlListsResponseBodyAclsAcl) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccessControlListsResponseBodyAclsAcl) GoString() string {
	return s.String()
}

func (s *DescribeAccessControlListsResponseBodyAclsAcl) SetAclId(v string) *DescribeAccessControlListsResponseBodyAclsAcl {
	s.AclId = &v
	return s
}

func (s *DescribeAccessControlListsResponseBodyAclsAcl) SetAclName(v string) *DescribeAccessControlListsResponseBodyAclsAcl {
	s.AclName = &v
	return s
}

func (s *DescribeAccessControlListsResponseBodyAclsAcl) SetAddressIPVersion(v string) *DescribeAccessControlListsResponseBodyAclsAcl {
	s.AddressIPVersion = &v
	return s
}

func (s *DescribeAccessControlListsResponseBodyAclsAcl) SetCreateTime(v string) *DescribeAccessControlListsResponseBodyAclsAcl {
	s.CreateTime = &v
	return s
}

func (s *DescribeAccessControlListsResponseBodyAclsAcl) SetResourceGroupId(v string) *DescribeAccessControlListsResponseBodyAclsAcl {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeAccessControlListsResponseBodyAclsAcl) SetTags(v *DescribeAccessControlListsResponseBodyAclsAclTags) *DescribeAccessControlListsResponseBodyAclsAcl {
	s.Tags = v
	return s
}

type DescribeAccessControlListsResponseBodyAclsAclTags struct {
	Tag []*DescribeAccessControlListsResponseBodyAclsAclTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeAccessControlListsResponseBodyAclsAclTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccessControlListsResponseBodyAclsAclTags) GoString() string {
	return s.String()
}

func (s *DescribeAccessControlListsResponseBodyAclsAclTags) SetTag(v []*DescribeAccessControlListsResponseBodyAclsAclTagsTag) *DescribeAccessControlListsResponseBodyAclsAclTags {
	s.Tag = v
	return s
}

type DescribeAccessControlListsResponseBodyAclsAclTagsTag struct {
}

func (s DescribeAccessControlListsResponseBodyAclsAclTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccessControlListsResponseBodyAclsAclTagsTag) GoString() string {
	return s.String()
}

type DescribeAccessControlListsResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeAccessControlListsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeAccessControlListsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccessControlListsResponse) GoString() string {
	return s.String()
}

func (s *DescribeAccessControlListsResponse) SetHeaders(v map[string]*string) *DescribeAccessControlListsResponse {
	s.Headers = v
	return s
}

func (s *DescribeAccessControlListsResponse) SetStatusCode(v int32) *DescribeAccessControlListsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAccessControlListsResponse) SetBody(v *DescribeAccessControlListsResponseBody) *DescribeAccessControlListsResponse {
	s.Body = v
	return s
}

type DescribeAccessLogsDownloadAttributeRequest struct {
	// The configuration of access logs.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	LogType      *string `json:"LogType,omitempty" xml:"LogType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the CLB instance is deployed.
	//
	// You can call the [DescribeRegions](~~27584~~) operation to query the most recent region list.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The name of the Logstore of Log Service.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The operation that you want to perform. Set the value to **DescribeAccessLogsDownloadAttribute**.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s DescribeAccessLogsDownloadAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccessLogsDownloadAttributeRequest) GoString() string {
	return s.String()
}

func (s *DescribeAccessLogsDownloadAttributeRequest) SetLoadBalancerId(v string) *DescribeAccessLogsDownloadAttributeRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *DescribeAccessLogsDownloadAttributeRequest) SetLogType(v string) *DescribeAccessLogsDownloadAttributeRequest {
	s.LogType = &v
	return s
}

func (s *DescribeAccessLogsDownloadAttributeRequest) SetOwnerAccount(v string) *DescribeAccessLogsDownloadAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeAccessLogsDownloadAttributeRequest) SetOwnerId(v int64) *DescribeAccessLogsDownloadAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeAccessLogsDownloadAttributeRequest) SetPageNumber(v int32) *DescribeAccessLogsDownloadAttributeRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeAccessLogsDownloadAttributeRequest) SetPageSize(v int32) *DescribeAccessLogsDownloadAttributeRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeAccessLogsDownloadAttributeRequest) SetRegionId(v string) *DescribeAccessLogsDownloadAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeAccessLogsDownloadAttributeRequest) SetResourceOwnerAccount(v string) *DescribeAccessLogsDownloadAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeAccessLogsDownloadAttributeRequest) SetResourceOwnerId(v int64) *DescribeAccessLogsDownloadAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeAccessLogsDownloadAttributeRequest) SetTags(v string) *DescribeAccessLogsDownloadAttributeRequest {
	s.Tags = &v
	return s
}

type DescribeAccessLogsDownloadAttributeResponseBody struct {
	// The number of entries returned per page.
	LogsDownloadAttributes *DescribeAccessLogsDownloadAttributeResponseBodyLogsDownloadAttributes `json:"LogsDownloadAttributes,omitempty" xml:"LogsDownloadAttributes,omitempty" type:"Struct"`
	// The type of access log. Set the value to **layer7**, which specifies Layer 7 access logs.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The ID of the CLB instance.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The page number of the returned page.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The type of access log. Only **layer7** is returned, which indicates Layer 7 access logs.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeAccessLogsDownloadAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccessLogsDownloadAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAccessLogsDownloadAttributeResponseBody) SetLogsDownloadAttributes(v *DescribeAccessLogsDownloadAttributeResponseBodyLogsDownloadAttributes) *DescribeAccessLogsDownloadAttributeResponseBody {
	s.LogsDownloadAttributes = v
	return s
}

func (s *DescribeAccessLogsDownloadAttributeResponseBody) SetPageNumber(v int32) *DescribeAccessLogsDownloadAttributeResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeAccessLogsDownloadAttributeResponseBody) SetPageSize(v int32) *DescribeAccessLogsDownloadAttributeResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeAccessLogsDownloadAttributeResponseBody) SetRequestId(v string) *DescribeAccessLogsDownloadAttributeResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeAccessLogsDownloadAttributeResponseBody) SetTotalCount(v int32) *DescribeAccessLogsDownloadAttributeResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeAccessLogsDownloadAttributeResponseBodyLogsDownloadAttributes struct {
	LogsDownloadAttribute []*DescribeAccessLogsDownloadAttributeResponseBodyLogsDownloadAttributesLogsDownloadAttribute `json:"LogsDownloadAttribute,omitempty" xml:"LogsDownloadAttribute,omitempty" type:"Repeated"`
}

func (s DescribeAccessLogsDownloadAttributeResponseBodyLogsDownloadAttributes) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccessLogsDownloadAttributeResponseBodyLogsDownloadAttributes) GoString() string {
	return s.String()
}

func (s *DescribeAccessLogsDownloadAttributeResponseBodyLogsDownloadAttributes) SetLogsDownloadAttribute(v []*DescribeAccessLogsDownloadAttributeResponseBodyLogsDownloadAttributesLogsDownloadAttribute) *DescribeAccessLogsDownloadAttributeResponseBodyLogsDownloadAttributes {
	s.LogsDownloadAttribute = v
	return s
}

type DescribeAccessLogsDownloadAttributeResponseBodyLogsDownloadAttributesLogsDownloadAttribute struct {
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// The name of the project of Log Service.
	LogProject *string `json:"LogProject,omitempty" xml:"LogProject,omitempty"`
	// The ID of the request.
	LogStore *string `json:"LogStore,omitempty" xml:"LogStore,omitempty"`
	LogType  *string `json:"LogType,omitempty" xml:"LogType,omitempty"`
	Region   *string `json:"Region,omitempty" xml:"Region,omitempty"`
}

func (s DescribeAccessLogsDownloadAttributeResponseBodyLogsDownloadAttributesLogsDownloadAttribute) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccessLogsDownloadAttributeResponseBodyLogsDownloadAttributesLogsDownloadAttribute) GoString() string {
	return s.String()
}

func (s *DescribeAccessLogsDownloadAttributeResponseBodyLogsDownloadAttributesLogsDownloadAttribute) SetLoadBalancerId(v string) *DescribeAccessLogsDownloadAttributeResponseBodyLogsDownloadAttributesLogsDownloadAttribute {
	s.LoadBalancerId = &v
	return s
}

func (s *DescribeAccessLogsDownloadAttributeResponseBodyLogsDownloadAttributesLogsDownloadAttribute) SetLogProject(v string) *DescribeAccessLogsDownloadAttributeResponseBodyLogsDownloadAttributesLogsDownloadAttribute {
	s.LogProject = &v
	return s
}

func (s *DescribeAccessLogsDownloadAttributeResponseBodyLogsDownloadAttributesLogsDownloadAttribute) SetLogStore(v string) *DescribeAccessLogsDownloadAttributeResponseBodyLogsDownloadAttributesLogsDownloadAttribute {
	s.LogStore = &v
	return s
}

func (s *DescribeAccessLogsDownloadAttributeResponseBodyLogsDownloadAttributesLogsDownloadAttribute) SetLogType(v string) *DescribeAccessLogsDownloadAttributeResponseBodyLogsDownloadAttributesLogsDownloadAttribute {
	s.LogType = &v
	return s
}

func (s *DescribeAccessLogsDownloadAttributeResponseBodyLogsDownloadAttributesLogsDownloadAttribute) SetRegion(v string) *DescribeAccessLogsDownloadAttributeResponseBodyLogsDownloadAttributesLogsDownloadAttribute {
	s.Region = &v
	return s
}

type DescribeAccessLogsDownloadAttributeResponse struct {
	Headers    map[string]*string                               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeAccessLogsDownloadAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeAccessLogsDownloadAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeAccessLogsDownloadAttributeResponse) GoString() string {
	return s.String()
}

func (s *DescribeAccessLogsDownloadAttributeResponse) SetHeaders(v map[string]*string) *DescribeAccessLogsDownloadAttributeResponse {
	s.Headers = v
	return s
}

func (s *DescribeAccessLogsDownloadAttributeResponse) SetStatusCode(v int32) *DescribeAccessLogsDownloadAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAccessLogsDownloadAttributeResponse) SetBody(v *DescribeAccessLogsDownloadAttributeResponseBody) *DescribeAccessLogsDownloadAttributeResponse {
	s.Body = v
	return s
}

type DescribeAvailableResourceRequest struct {
	// The zones and the supported resources.
	AddressIPVersion *string `json:"AddressIPVersion,omitempty" xml:"AddressIPVersion,omitempty"`
	// The ID of the request.
	AddressType  *string `json:"AddressType,omitempty" xml:"AddressType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The type of IP address.
	//
	// Valid values: **ipv4 and ipv6**.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeAvailableResourceRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableResourceRequest) GoString() string {
	return s.String()
}

func (s *DescribeAvailableResourceRequest) SetAddressIPVersion(v string) *DescribeAvailableResourceRequest {
	s.AddressIPVersion = &v
	return s
}

func (s *DescribeAvailableResourceRequest) SetAddressType(v string) *DescribeAvailableResourceRequest {
	s.AddressType = &v
	return s
}

func (s *DescribeAvailableResourceRequest) SetOwnerAccount(v string) *DescribeAvailableResourceRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeAvailableResourceRequest) SetOwnerId(v int64) *DescribeAvailableResourceRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeAvailableResourceRequest) SetRegionId(v string) *DescribeAvailableResourceRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeAvailableResourceRequest) SetResourceOwnerAccount(v string) *DescribeAvailableResourceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeAvailableResourceRequest) SetResourceOwnerId(v int64) *DescribeAvailableResourceRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeAvailableResourceResponseBody struct {
	// The primary zone.
	AvailableResources *DescribeAvailableResourceResponseBodyAvailableResources `json:"AvailableResources,omitempty" xml:"AvailableResources,omitempty" type:"Struct"`
	// The secondary zone.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeAvailableResourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableResourceResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeAvailableResourceResponseBody) SetAvailableResources(v *DescribeAvailableResourceResponseBodyAvailableResources) *DescribeAvailableResourceResponseBody {
	s.AvailableResources = v
	return s
}

func (s *DescribeAvailableResourceResponseBody) SetRequestId(v string) *DescribeAvailableResourceResponseBody {
	s.RequestId = &v
	return s
}

type DescribeAvailableResourceResponseBodyAvailableResources struct {
	AvailableResource []*DescribeAvailableResourceResponseBodyAvailableResourcesAvailableResource `json:"AvailableResource,omitempty" xml:"AvailableResource,omitempty" type:"Repeated"`
}

func (s DescribeAvailableResourceResponseBodyAvailableResources) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableResourceResponseBodyAvailableResources) GoString() string {
	return s.String()
}

func (s *DescribeAvailableResourceResponseBodyAvailableResources) SetAvailableResource(v []*DescribeAvailableResourceResponseBodyAvailableResourcesAvailableResource) *DescribeAvailableResourceResponseBodyAvailableResources {
	s.AvailableResource = v
	return s
}

type DescribeAvailableResourceResponseBodyAvailableResourcesAvailableResource struct {
	// The type of network.
	//
	// Valid values: **vpc, classic-internet, and classic-intranet**.
	MasterZoneId *string `json:"MasterZoneId,omitempty" xml:"MasterZoneId,omitempty"`
	// The supported resources.
	SlaveZoneId *string `json:"SlaveZoneId,omitempty" xml:"SlaveZoneId,omitempty"`
	// The type of IP address.
	//
	// Valid values: **ipv4 and ipv6**.
	SupportResources *DescribeAvailableResourceResponseBodyAvailableResourcesAvailableResourceSupportResources `json:"SupportResources,omitempty" xml:"SupportResources,omitempty" type:"Struct"`
}

func (s DescribeAvailableResourceResponseBodyAvailableResourcesAvailableResource) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableResourceResponseBodyAvailableResourcesAvailableResource) GoString() string {
	return s.String()
}

func (s *DescribeAvailableResourceResponseBodyAvailableResourcesAvailableResource) SetMasterZoneId(v string) *DescribeAvailableResourceResponseBodyAvailableResourcesAvailableResource {
	s.MasterZoneId = &v
	return s
}

func (s *DescribeAvailableResourceResponseBodyAvailableResourcesAvailableResource) SetSlaveZoneId(v string) *DescribeAvailableResourceResponseBodyAvailableResourcesAvailableResource {
	s.SlaveZoneId = &v
	return s
}

func (s *DescribeAvailableResourceResponseBodyAvailableResourcesAvailableResource) SetSupportResources(v *DescribeAvailableResourceResponseBodyAvailableResourcesAvailableResourceSupportResources) *DescribeAvailableResourceResponseBodyAvailableResourcesAvailableResource {
	s.SupportResources = v
	return s
}

type DescribeAvailableResourceResponseBodyAvailableResourcesAvailableResourceSupportResources struct {
	SupportResource []*DescribeAvailableResourceResponseBodyAvailableResourcesAvailableResourceSupportResourcesSupportResource `json:"SupportResource,omitempty" xml:"SupportResource,omitempty" type:"Repeated"`
}

func (s DescribeAvailableResourceResponseBodyAvailableResourcesAvailableResourceSupportResources) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableResourceResponseBodyAvailableResourcesAvailableResourceSupportResources) GoString() string {
	return s.String()
}

func (s *DescribeAvailableResourceResponseBodyAvailableResourcesAvailableResourceSupportResources) SetSupportResource(v []*DescribeAvailableResourceResponseBodyAvailableResourcesAvailableResourceSupportResourcesSupportResource) *DescribeAvailableResourceResponseBodyAvailableResourcesAvailableResourceSupportResources {
	s.SupportResource = v
	return s
}

type DescribeAvailableResourceResponseBodyAvailableResourcesAvailableResourceSupportResourcesSupportResource struct {
	AddressIPVersion *string `json:"AddressIPVersion,omitempty" xml:"AddressIPVersion,omitempty"`
	// >  Only resources that are available for purchase and the corresponding zones are returned.
	AddressType *string `json:"AddressType,omitempty" xml:"AddressType,omitempty"`
}

func (s DescribeAvailableResourceResponseBodyAvailableResourcesAvailableResourceSupportResourcesSupportResource) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableResourceResponseBodyAvailableResourcesAvailableResourceSupportResourcesSupportResource) GoString() string {
	return s.String()
}

func (s *DescribeAvailableResourceResponseBodyAvailableResourcesAvailableResourceSupportResourcesSupportResource) SetAddressIPVersion(v string) *DescribeAvailableResourceResponseBodyAvailableResourcesAvailableResourceSupportResourcesSupportResource {
	s.AddressIPVersion = &v
	return s
}

func (s *DescribeAvailableResourceResponseBodyAvailableResourcesAvailableResourceSupportResourcesSupportResource) SetAddressType(v string) *DescribeAvailableResourceResponseBodyAvailableResourcesAvailableResourceSupportResourcesSupportResource {
	s.AddressType = &v
	return s
}

type DescribeAvailableResourceResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeAvailableResourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeAvailableResourceResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeAvailableResourceResponse) GoString() string {
	return s.String()
}

func (s *DescribeAvailableResourceResponse) SetHeaders(v map[string]*string) *DescribeAvailableResourceResponse {
	s.Headers = v
	return s
}

func (s *DescribeAvailableResourceResponse) SetStatusCode(v int32) *DescribeAvailableResourceResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeAvailableResourceResponse) SetBody(v *DescribeAvailableResourceResponseBody) *DescribeAvailableResourceResponse {
	s.Body = v
	return s
}

type DescribeCACertificatesRequest struct {
	// The ID of the resource group.
	CACertificateId *string `json:"CACertificateId,omitempty" xml:"CACertificateId,omitempty"`
	OwnerAccount    *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId         *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The timestamp that indicates when the CA certificate expires. Unit: milliseconds.
	//
	// This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeCACertificatesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCACertificatesRequest) GoString() string {
	return s.String()
}

func (s *DescribeCACertificatesRequest) SetCACertificateId(v string) *DescribeCACertificatesRequest {
	s.CACertificateId = &v
	return s
}

func (s *DescribeCACertificatesRequest) SetOwnerAccount(v string) *DescribeCACertificatesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeCACertificatesRequest) SetOwnerId(v int64) *DescribeCACertificatesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCACertificatesRequest) SetRegionId(v string) *DescribeCACertificatesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeCACertificatesRequest) SetResourceGroupId(v string) *DescribeCACertificatesRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeCACertificatesRequest) SetResourceOwnerAccount(v string) *DescribeCACertificatesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeCACertificatesRequest) SetResourceOwnerId(v int64) *DescribeCACertificatesRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeCACertificatesResponseBody struct {
	// The fingerprint of the CA certificate.
	CACertificates *DescribeCACertificatesResponseBodyCACertificates `json:"CACertificates,omitempty" xml:"CACertificates,omitempty" type:"Struct"`
	// The operation that you want to perform. Set the value to **DescribeCACertificates**.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCACertificatesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCACertificatesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCACertificatesResponseBody) SetCACertificates(v *DescribeCACertificatesResponseBodyCACertificates) *DescribeCACertificatesResponseBody {
	s.CACertificates = v
	return s
}

func (s *DescribeCACertificatesResponseBody) SetRequestId(v string) *DescribeCACertificatesResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCACertificatesResponseBodyCACertificates struct {
	CACertificate []*DescribeCACertificatesResponseBodyCACertificatesCACertificate `json:"CACertificate,omitempty" xml:"CACertificate,omitempty" type:"Repeated"`
}

func (s DescribeCACertificatesResponseBodyCACertificates) String() string {
	return tea.Prettify(s)
}

func (s DescribeCACertificatesResponseBodyCACertificates) GoString() string {
	return s.String()
}

func (s *DescribeCACertificatesResponseBodyCACertificates) SetCACertificate(v []*DescribeCACertificatesResponseBodyCACertificatesCACertificate) *DescribeCACertificatesResponseBodyCACertificates {
	s.CACertificate = v
	return s
}

type DescribeCACertificatesResponseBodyCACertificatesCACertificate struct {
	// The ID of the CA certificate.
	CACertificateId   *string `json:"CACertificateId,omitempty" xml:"CACertificateId,omitempty"`
	CACertificateName *string `json:"CACertificateName,omitempty" xml:"CACertificateName,omitempty"`
	CommonName        *string `json:"CommonName,omitempty" xml:"CommonName,omitempty"`
	// The time when the CA certificate expires. The time is in the `YYYY-MM-DDThh:mm:ssZ` format.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The information about the CA certificate.
	CreateTimeStamp *int64 `json:"CreateTimeStamp,omitempty" xml:"CreateTimeStamp,omitempty"`
	// The region where the CA certificates are created.
	//
	// You can call the [DescribeRegions](~~27584~~) operation to query the most recent region list.
	ExpireTime *string `json:"ExpireTime,omitempty" xml:"ExpireTime,omitempty"`
	// The name of the CA certificate.
	ExpireTimeStamp *int64 `json:"ExpireTimeStamp,omitempty" xml:"ExpireTimeStamp,omitempty"`
	// The region where the CA certificate is created.
	Fingerprint *string `json:"Fingerprint,omitempty" xml:"Fingerprint,omitempty"`
	// The ID of the request.
	RegionId        *string                                                            `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceGroupId *string                                                            `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	Tags            *DescribeCACertificatesResponseBodyCACertificatesCACertificateTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
}

func (s DescribeCACertificatesResponseBodyCACertificatesCACertificate) String() string {
	return tea.Prettify(s)
}

func (s DescribeCACertificatesResponseBodyCACertificatesCACertificate) GoString() string {
	return s.String()
}

func (s *DescribeCACertificatesResponseBodyCACertificatesCACertificate) SetCACertificateId(v string) *DescribeCACertificatesResponseBodyCACertificatesCACertificate {
	s.CACertificateId = &v
	return s
}

func (s *DescribeCACertificatesResponseBodyCACertificatesCACertificate) SetCACertificateName(v string) *DescribeCACertificatesResponseBodyCACertificatesCACertificate {
	s.CACertificateName = &v
	return s
}

func (s *DescribeCACertificatesResponseBodyCACertificatesCACertificate) SetCommonName(v string) *DescribeCACertificatesResponseBodyCACertificatesCACertificate {
	s.CommonName = &v
	return s
}

func (s *DescribeCACertificatesResponseBodyCACertificatesCACertificate) SetCreateTime(v string) *DescribeCACertificatesResponseBodyCACertificatesCACertificate {
	s.CreateTime = &v
	return s
}

func (s *DescribeCACertificatesResponseBodyCACertificatesCACertificate) SetCreateTimeStamp(v int64) *DescribeCACertificatesResponseBodyCACertificatesCACertificate {
	s.CreateTimeStamp = &v
	return s
}

func (s *DescribeCACertificatesResponseBodyCACertificatesCACertificate) SetExpireTime(v string) *DescribeCACertificatesResponseBodyCACertificatesCACertificate {
	s.ExpireTime = &v
	return s
}

func (s *DescribeCACertificatesResponseBodyCACertificatesCACertificate) SetExpireTimeStamp(v int64) *DescribeCACertificatesResponseBodyCACertificatesCACertificate {
	s.ExpireTimeStamp = &v
	return s
}

func (s *DescribeCACertificatesResponseBodyCACertificatesCACertificate) SetFingerprint(v string) *DescribeCACertificatesResponseBodyCACertificatesCACertificate {
	s.Fingerprint = &v
	return s
}

func (s *DescribeCACertificatesResponseBodyCACertificatesCACertificate) SetRegionId(v string) *DescribeCACertificatesResponseBodyCACertificatesCACertificate {
	s.RegionId = &v
	return s
}

func (s *DescribeCACertificatesResponseBodyCACertificatesCACertificate) SetResourceGroupId(v string) *DescribeCACertificatesResponseBodyCACertificatesCACertificate {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeCACertificatesResponseBodyCACertificatesCACertificate) SetTags(v *DescribeCACertificatesResponseBodyCACertificatesCACertificateTags) *DescribeCACertificatesResponseBodyCACertificatesCACertificate {
	s.Tags = v
	return s
}

type DescribeCACertificatesResponseBodyCACertificatesCACertificateTags struct {
	Tag []*DescribeCACertificatesResponseBodyCACertificatesCACertificateTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeCACertificatesResponseBodyCACertificatesCACertificateTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeCACertificatesResponseBodyCACertificatesCACertificateTags) GoString() string {
	return s.String()
}

func (s *DescribeCACertificatesResponseBodyCACertificatesCACertificateTags) SetTag(v []*DescribeCACertificatesResponseBodyCACertificatesCACertificateTagsTag) *DescribeCACertificatesResponseBodyCACertificatesCACertificateTags {
	s.Tag = v
	return s
}

type DescribeCACertificatesResponseBodyCACertificatesCACertificateTagsTag struct {
}

func (s DescribeCACertificatesResponseBodyCACertificatesCACertificateTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeCACertificatesResponseBodyCACertificatesCACertificateTagsTag) GoString() string {
	return s.String()
}

type DescribeCACertificatesResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCACertificatesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCACertificatesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCACertificatesResponse) GoString() string {
	return s.String()
}

func (s *DescribeCACertificatesResponse) SetHeaders(v map[string]*string) *DescribeCACertificatesResponse {
	s.Headers = v
	return s
}

func (s *DescribeCACertificatesResponse) SetStatusCode(v int32) *DescribeCACertificatesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCACertificatesResponse) SetBody(v *DescribeCACertificatesResponseBody) *DescribeCACertificatesResponse {
	s.Body = v
	return s
}

type DescribeDomainExtensionAttributeRequest struct {
	// The domain name.
	DomainExtensionId *string `json:"DomainExtensionId,omitempty" xml:"DomainExtensionId,omitempty"`
	OwnerAccount      *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId           *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the additional certificate.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeDomainExtensionAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainExtensionAttributeRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainExtensionAttributeRequest) SetDomainExtensionId(v string) *DescribeDomainExtensionAttributeRequest {
	s.DomainExtensionId = &v
	return s
}

func (s *DescribeDomainExtensionAttributeRequest) SetOwnerAccount(v string) *DescribeDomainExtensionAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeDomainExtensionAttributeRequest) SetOwnerId(v int64) *DescribeDomainExtensionAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDomainExtensionAttributeRequest) SetRegionId(v string) *DescribeDomainExtensionAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeDomainExtensionAttributeRequest) SetResourceOwnerAccount(v string) *DescribeDomainExtensionAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeDomainExtensionAttributeRequest) SetResourceOwnerId(v int64) *DescribeDomainExtensionAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeDomainExtensionAttributeResponseBody struct {
	// The ID of the request.
	Domain            *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	DomainExtensionId *string `json:"DomainExtensionId,omitempty" xml:"DomainExtensionId,omitempty"`
	// The ID of the server certificate that is used by the domain name.
	ListenerPort *int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	// The frontend port of the HTTPS listener that is configured for the SLB instance. Valid values: **1** to **65535**.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// The ID of the SLB instance.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the additional certificate.
	ServerCertificateId *string `json:"ServerCertificateId,omitempty" xml:"ServerCertificateId,omitempty"`
}

func (s DescribeDomainExtensionAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainExtensionAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainExtensionAttributeResponseBody) SetDomain(v string) *DescribeDomainExtensionAttributeResponseBody {
	s.Domain = &v
	return s
}

func (s *DescribeDomainExtensionAttributeResponseBody) SetDomainExtensionId(v string) *DescribeDomainExtensionAttributeResponseBody {
	s.DomainExtensionId = &v
	return s
}

func (s *DescribeDomainExtensionAttributeResponseBody) SetListenerPort(v int32) *DescribeDomainExtensionAttributeResponseBody {
	s.ListenerPort = &v
	return s
}

func (s *DescribeDomainExtensionAttributeResponseBody) SetLoadBalancerId(v string) *DescribeDomainExtensionAttributeResponseBody {
	s.LoadBalancerId = &v
	return s
}

func (s *DescribeDomainExtensionAttributeResponseBody) SetRequestId(v string) *DescribeDomainExtensionAttributeResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeDomainExtensionAttributeResponseBody) SetServerCertificateId(v string) *DescribeDomainExtensionAttributeResponseBody {
	s.ServerCertificateId = &v
	return s
}

type DescribeDomainExtensionAttributeResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainExtensionAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainExtensionAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainExtensionAttributeResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainExtensionAttributeResponse) SetHeaders(v map[string]*string) *DescribeDomainExtensionAttributeResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainExtensionAttributeResponse) SetStatusCode(v int32) *DescribeDomainExtensionAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainExtensionAttributeResponse) SetBody(v *DescribeDomainExtensionAttributeResponseBody) *DescribeDomainExtensionAttributeResponse {
	s.Body = v
	return s
}

type DescribeDomainExtensionsRequest struct {
	// The ID of the request.
	DomainExtensionId *string `json:"DomainExtensionId,omitempty" xml:"DomainExtensionId,omitempty"`
	// The ID of the additional certificate.
	ListenerPort *int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	// The frontend port of the HTTPS listener that is configured for the Classic Load Balancer (CLB) instance. Valid values: **1 to 65535**.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the CLB instance.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeDomainExtensionsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainExtensionsRequest) GoString() string {
	return s.String()
}

func (s *DescribeDomainExtensionsRequest) SetDomainExtensionId(v string) *DescribeDomainExtensionsRequest {
	s.DomainExtensionId = &v
	return s
}

func (s *DescribeDomainExtensionsRequest) SetListenerPort(v int32) *DescribeDomainExtensionsRequest {
	s.ListenerPort = &v
	return s
}

func (s *DescribeDomainExtensionsRequest) SetLoadBalancerId(v string) *DescribeDomainExtensionsRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *DescribeDomainExtensionsRequest) SetOwnerAccount(v string) *DescribeDomainExtensionsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeDomainExtensionsRequest) SetOwnerId(v int64) *DescribeDomainExtensionsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeDomainExtensionsRequest) SetRegionId(v string) *DescribeDomainExtensionsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeDomainExtensionsRequest) SetResourceOwnerAccount(v string) *DescribeDomainExtensionsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeDomainExtensionsRequest) SetResourceOwnerId(v int64) *DescribeDomainExtensionsRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeDomainExtensionsResponseBody struct {
	// The ID of the server certificate that is used by the domain name.
	DomainExtensions *DescribeDomainExtensionsResponseBodyDomainExtensions `json:"DomainExtensions,omitempty" xml:"DomainExtensions,omitempty" type:"Struct"`
	// The list of additional certificates.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeDomainExtensionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainExtensionsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeDomainExtensionsResponseBody) SetDomainExtensions(v *DescribeDomainExtensionsResponseBodyDomainExtensions) *DescribeDomainExtensionsResponseBody {
	s.DomainExtensions = v
	return s
}

func (s *DescribeDomainExtensionsResponseBody) SetRequestId(v string) *DescribeDomainExtensionsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeDomainExtensionsResponseBodyDomainExtensions struct {
	DomainExtension []*DescribeDomainExtensionsResponseBodyDomainExtensionsDomainExtension `json:"DomainExtension,omitempty" xml:"DomainExtension,omitempty" type:"Repeated"`
}

func (s DescribeDomainExtensionsResponseBodyDomainExtensions) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainExtensionsResponseBodyDomainExtensions) GoString() string {
	return s.String()
}

func (s *DescribeDomainExtensionsResponseBodyDomainExtensions) SetDomainExtension(v []*DescribeDomainExtensionsResponseBodyDomainExtensionsDomainExtension) *DescribeDomainExtensionsResponseBodyDomainExtensions {
	s.DomainExtension = v
	return s
}

type DescribeDomainExtensionsResponseBodyDomainExtensionsDomainExtension struct {
	// The ID of the additional certificate.
	Domain *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	// Queries additional certificates.
	DomainExtensionId *string `json:"DomainExtensionId,omitempty" xml:"DomainExtensionId,omitempty"`
	// The domain name.
	ServerCertificateId *string `json:"ServerCertificateId,omitempty" xml:"ServerCertificateId,omitempty"`
}

func (s DescribeDomainExtensionsResponseBodyDomainExtensionsDomainExtension) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainExtensionsResponseBodyDomainExtensionsDomainExtension) GoString() string {
	return s.String()
}

func (s *DescribeDomainExtensionsResponseBodyDomainExtensionsDomainExtension) SetDomain(v string) *DescribeDomainExtensionsResponseBodyDomainExtensionsDomainExtension {
	s.Domain = &v
	return s
}

func (s *DescribeDomainExtensionsResponseBodyDomainExtensionsDomainExtension) SetDomainExtensionId(v string) *DescribeDomainExtensionsResponseBodyDomainExtensionsDomainExtension {
	s.DomainExtensionId = &v
	return s
}

func (s *DescribeDomainExtensionsResponseBodyDomainExtensionsDomainExtension) SetServerCertificateId(v string) *DescribeDomainExtensionsResponseBodyDomainExtensionsDomainExtension {
	s.ServerCertificateId = &v
	return s
}

type DescribeDomainExtensionsResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeDomainExtensionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeDomainExtensionsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeDomainExtensionsResponse) GoString() string {
	return s.String()
}

func (s *DescribeDomainExtensionsResponse) SetHeaders(v map[string]*string) *DescribeDomainExtensionsResponse {
	s.Headers = v
	return s
}

func (s *DescribeDomainExtensionsResponse) SetStatusCode(v int32) *DescribeDomainExtensionsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeDomainExtensionsResponse) SetBody(v *DescribeDomainExtensionsResponseBody) *DescribeDomainExtensionsResponse {
	s.Body = v
	return s
}

type DescribeHealthStatusRequest struct {
	// The frontend protocol that is used by the CLB instance.
	ListenerPort *int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	// The ID of the region where the CLB instance is deployed.
	ListenerProtocol *string `json:"ListenerProtocol,omitempty" xml:"ListenerProtocol,omitempty"`
	// The frontend port that is used by the CLB instance.
	//
	// Valid values: **1 to 65535**.
	//
	// >  If you do not specify this parameter, the health status of all ports is returned.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the request.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeHealthStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeHealthStatusRequest) GoString() string {
	return s.String()
}

func (s *DescribeHealthStatusRequest) SetListenerPort(v int32) *DescribeHealthStatusRequest {
	s.ListenerPort = &v
	return s
}

func (s *DescribeHealthStatusRequest) SetListenerProtocol(v string) *DescribeHealthStatusRequest {
	s.ListenerProtocol = &v
	return s
}

func (s *DescribeHealthStatusRequest) SetLoadBalancerId(v string) *DescribeHealthStatusRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *DescribeHealthStatusRequest) SetOwnerAccount(v string) *DescribeHealthStatusRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeHealthStatusRequest) SetOwnerId(v int64) *DescribeHealthStatusRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeHealthStatusRequest) SetRegionId(v string) *DescribeHealthStatusRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeHealthStatusRequest) SetResourceOwnerAccount(v string) *DescribeHealthStatusRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeHealthStatusRequest) SetResourceOwnerId(v int64) *DescribeHealthStatusRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeHealthStatusResponseBody struct {
	// The health status of the backend server. Valid values:
	//
	// *   **normal**: The backend server is healthy.
	// *   **abnormal**: The backend server is unhealthy.
	// *   **unavailable**: The health check is not complete.
	BackendServers *DescribeHealthStatusResponseBodyBackendServers `json:"BackendServers,omitempty" xml:"BackendServers,omitempty" type:"Struct"`
	// The list of backend servers.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeHealthStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeHealthStatusResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeHealthStatusResponseBody) SetBackendServers(v *DescribeHealthStatusResponseBodyBackendServers) *DescribeHealthStatusResponseBody {
	s.BackendServers = v
	return s
}

func (s *DescribeHealthStatusResponseBody) SetRequestId(v string) *DescribeHealthStatusResponseBody {
	s.RequestId = &v
	return s
}

type DescribeHealthStatusResponseBodyBackendServers struct {
	BackendServer []*DescribeHealthStatusResponseBodyBackendServersBackendServer `json:"BackendServer,omitempty" xml:"BackendServer,omitempty" type:"Repeated"`
}

func (s DescribeHealthStatusResponseBodyBackendServers) String() string {
	return tea.Prettify(s)
}

func (s DescribeHealthStatusResponseBodyBackendServers) GoString() string {
	return s.String()
}

func (s *DescribeHealthStatusResponseBodyBackendServers) SetBackendServer(v []*DescribeHealthStatusResponseBodyBackendServersBackendServer) *DescribeHealthStatusResponseBodyBackendServers {
	s.BackendServer = v
	return s
}

type DescribeHealthStatusResponseBodyBackendServersBackendServer struct {
	// The IP address of the ECS instance.
	ListenerPort *int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	// The ID of the Elastic Compute Service (ECS) instance or elastic network interface (ENI).
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The frontend port that is used by the CLB instance.
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The frontend protocol that is used by the CLB instance.
	ServerHealthStatus *string `json:"ServerHealthStatus,omitempty" xml:"ServerHealthStatus,omitempty"`
	// Queries the health status of backend servers.
	ServerId *string `json:"ServerId,omitempty" xml:"ServerId,omitempty"`
	// The backend port that is used by the CLB instance.
	ServerIp *string `json:"ServerIp,omitempty" xml:"ServerIp,omitempty"`
}

func (s DescribeHealthStatusResponseBodyBackendServersBackendServer) String() string {
	return tea.Prettify(s)
}

func (s DescribeHealthStatusResponseBodyBackendServersBackendServer) GoString() string {
	return s.String()
}

func (s *DescribeHealthStatusResponseBodyBackendServersBackendServer) SetListenerPort(v int32) *DescribeHealthStatusResponseBodyBackendServersBackendServer {
	s.ListenerPort = &v
	return s
}

func (s *DescribeHealthStatusResponseBodyBackendServersBackendServer) SetPort(v int32) *DescribeHealthStatusResponseBodyBackendServersBackendServer {
	s.Port = &v
	return s
}

func (s *DescribeHealthStatusResponseBodyBackendServersBackendServer) SetProtocol(v string) *DescribeHealthStatusResponseBodyBackendServersBackendServer {
	s.Protocol = &v
	return s
}

func (s *DescribeHealthStatusResponseBodyBackendServersBackendServer) SetServerHealthStatus(v string) *DescribeHealthStatusResponseBodyBackendServersBackendServer {
	s.ServerHealthStatus = &v
	return s
}

func (s *DescribeHealthStatusResponseBodyBackendServersBackendServer) SetServerId(v string) *DescribeHealthStatusResponseBodyBackendServersBackendServer {
	s.ServerId = &v
	return s
}

func (s *DescribeHealthStatusResponseBodyBackendServersBackendServer) SetServerIp(v string) *DescribeHealthStatusResponseBodyBackendServersBackendServer {
	s.ServerIp = &v
	return s
}

type DescribeHealthStatusResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeHealthStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeHealthStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeHealthStatusResponse) GoString() string {
	return s.String()
}

func (s *DescribeHealthStatusResponse) SetHeaders(v map[string]*string) *DescribeHealthStatusResponse {
	s.Headers = v
	return s
}

func (s *DescribeHealthStatusResponse) SetStatusCode(v int32) *DescribeHealthStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeHealthStatusResponse) SetBody(v *DescribeHealthStatusResponseBody) *DescribeHealthStatusResponse {
	s.Body = v
	return s
}

type DescribeHighDefinationMonitorRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The name of the Logstore of Log Service.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the region where you want to query the configuration of fine-grained monitoring.
	//
	// You can call the [DescribeRegions](~~27584~~) operation to query the most recent region list.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s DescribeHighDefinationMonitorRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeHighDefinationMonitorRequest) GoString() string {
	return s.String()
}

func (s *DescribeHighDefinationMonitorRequest) SetOwnerAccount(v string) *DescribeHighDefinationMonitorRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeHighDefinationMonitorRequest) SetOwnerId(v int64) *DescribeHighDefinationMonitorRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeHighDefinationMonitorRequest) SetRegionId(v string) *DescribeHighDefinationMonitorRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeHighDefinationMonitorRequest) SetResourceOwnerAccount(v string) *DescribeHighDefinationMonitorRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeHighDefinationMonitorRequest) SetResourceOwnerId(v int64) *DescribeHighDefinationMonitorRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeHighDefinationMonitorRequest) SetTags(v string) *DescribeHighDefinationMonitorRequest {
	s.Tags = &v
	return s
}

type DescribeHighDefinationMonitorResponseBody struct {
	// The ID of the request.
	LogProject *string `json:"LogProject,omitempty" xml:"LogProject,omitempty"`
	LogStore   *string `json:"LogStore,omitempty" xml:"LogStore,omitempty"`
	// The operation that you want to perform. Set the value to **DescribeHighDefinationMonitor**.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DescribeHighDefinationMonitorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeHighDefinationMonitorResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeHighDefinationMonitorResponseBody) SetLogProject(v string) *DescribeHighDefinationMonitorResponseBody {
	s.LogProject = &v
	return s
}

func (s *DescribeHighDefinationMonitorResponseBody) SetLogStore(v string) *DescribeHighDefinationMonitorResponseBody {
	s.LogStore = &v
	return s
}

func (s *DescribeHighDefinationMonitorResponseBody) SetRequestId(v string) *DescribeHighDefinationMonitorResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeHighDefinationMonitorResponseBody) SetSuccess(v string) *DescribeHighDefinationMonitorResponseBody {
	s.Success = &v
	return s
}

type DescribeHighDefinationMonitorResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeHighDefinationMonitorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeHighDefinationMonitorResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeHighDefinationMonitorResponse) GoString() string {
	return s.String()
}

func (s *DescribeHighDefinationMonitorResponse) SetHeaders(v map[string]*string) *DescribeHighDefinationMonitorResponse {
	s.Headers = v
	return s
}

func (s *DescribeHighDefinationMonitorResponse) SetStatusCode(v int32) *DescribeHighDefinationMonitorResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeHighDefinationMonitorResponse) SetBody(v *DescribeHighDefinationMonitorResponseBody) *DescribeHighDefinationMonitorResponse {
	s.Body = v
	return s
}

type DescribeListenerAccessControlAttributeRequest struct {
	// The region where the Classic Load Balancer (CLB) instance is created.
	//
	// You can query the region ID from the [Regions and zones](~~40654~~) list or by calling the [DescribeRegions](~~25609~~) operation.
	ListenerPort *int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	// The IP addresses and CIDR blocks added to the whitelist.
	ListenerProtocol *string `json:"ListenerProtocol,omitempty" xml:"ListenerProtocol,omitempty"`
	// The ID of the request.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The frontend protocol that is used by the CLB instance.
	//
	// >  This parameter is required when listeners that use different protocols listen on the same port.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeListenerAccessControlAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeListenerAccessControlAttributeRequest) GoString() string {
	return s.String()
}

func (s *DescribeListenerAccessControlAttributeRequest) SetListenerPort(v int32) *DescribeListenerAccessControlAttributeRequest {
	s.ListenerPort = &v
	return s
}

func (s *DescribeListenerAccessControlAttributeRequest) SetListenerProtocol(v string) *DescribeListenerAccessControlAttributeRequest {
	s.ListenerProtocol = &v
	return s
}

func (s *DescribeListenerAccessControlAttributeRequest) SetLoadBalancerId(v string) *DescribeListenerAccessControlAttributeRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *DescribeListenerAccessControlAttributeRequest) SetOwnerAccount(v string) *DescribeListenerAccessControlAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeListenerAccessControlAttributeRequest) SetOwnerId(v int64) *DescribeListenerAccessControlAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeListenerAccessControlAttributeRequest) SetRegionId(v string) *DescribeListenerAccessControlAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeListenerAccessControlAttributeRequest) SetResourceOwnerAccount(v string) *DescribeListenerAccessControlAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeListenerAccessControlAttributeRequest) SetResourceOwnerId(v int64) *DescribeListenerAccessControlAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeListenerAccessControlAttributeResponseBody struct {
	AccessControlStatus *string `json:"AccessControlStatus,omitempty" xml:"AccessControlStatus,omitempty"`
	RequestId           *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	SourceItems         *string `json:"SourceItems,omitempty" xml:"SourceItems,omitempty"`
}

func (s DescribeListenerAccessControlAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeListenerAccessControlAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeListenerAccessControlAttributeResponseBody) SetAccessControlStatus(v string) *DescribeListenerAccessControlAttributeResponseBody {
	s.AccessControlStatus = &v
	return s
}

func (s *DescribeListenerAccessControlAttributeResponseBody) SetRequestId(v string) *DescribeListenerAccessControlAttributeResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeListenerAccessControlAttributeResponseBody) SetSourceItems(v string) *DescribeListenerAccessControlAttributeResponseBody {
	s.SourceItems = &v
	return s
}

type DescribeListenerAccessControlAttributeResponse struct {
	Headers    map[string]*string                                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeListenerAccessControlAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeListenerAccessControlAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeListenerAccessControlAttributeResponse) GoString() string {
	return s.String()
}

func (s *DescribeListenerAccessControlAttributeResponse) SetHeaders(v map[string]*string) *DescribeListenerAccessControlAttributeResponse {
	s.Headers = v
	return s
}

func (s *DescribeListenerAccessControlAttributeResponse) SetStatusCode(v int32) *DescribeListenerAccessControlAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeListenerAccessControlAttributeResponse) SetBody(v *DescribeListenerAccessControlAttributeResponseBody) *DescribeListenerAccessControlAttributeResponse {
	s.Body = v
	return s
}

type DescribeLoadBalancerAttributeRequest struct {
	LoadBalancerId       *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeLoadBalancerAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerAttributeRequest) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerAttributeRequest) SetLoadBalancerId(v string) *DescribeLoadBalancerAttributeRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *DescribeLoadBalancerAttributeRequest) SetOwnerAccount(v string) *DescribeLoadBalancerAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeLoadBalancerAttributeRequest) SetOwnerId(v int64) *DescribeLoadBalancerAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeLoadBalancerAttributeRequest) SetRegionId(v string) *DescribeLoadBalancerAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeLoadBalancerAttributeRequest) SetResourceOwnerAccount(v string) *DescribeLoadBalancerAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeLoadBalancerAttributeRequest) SetResourceOwnerId(v int64) *DescribeLoadBalancerAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeLoadBalancerAttributeResponseBody struct {
	Address                      *string                                                            `json:"Address,omitempty" xml:"Address,omitempty"`
	AddressIPVersion             *string                                                            `json:"AddressIPVersion,omitempty" xml:"AddressIPVersion,omitempty"`
	AddressType                  *string                                                            `json:"AddressType,omitempty" xml:"AddressType,omitempty"`
	AutoReleaseTime              *int64                                                             `json:"AutoReleaseTime,omitempty" xml:"AutoReleaseTime,omitempty"`
	BackendServers               *DescribeLoadBalancerAttributeResponseBodyBackendServers           `json:"BackendServers,omitempty" xml:"BackendServers,omitempty" type:"Struct"`
	Bandwidth                    *int32                                                             `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	CreateTime                   *string                                                            `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	CreateTimeStamp              *int64                                                             `json:"CreateTimeStamp,omitempty" xml:"CreateTimeStamp,omitempty"`
	DeleteProtection             *string                                                            `json:"DeleteProtection,omitempty" xml:"DeleteProtection,omitempty"`
	EndTime                      *string                                                            `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	EndTimeStamp                 *int64                                                             `json:"EndTimeStamp,omitempty" xml:"EndTimeStamp,omitempty"`
	InstanceChargeType           *string                                                            `json:"InstanceChargeType,omitempty" xml:"InstanceChargeType,omitempty"`
	InternetChargeType           *string                                                            `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	ListenerPorts                *DescribeLoadBalancerAttributeResponseBodyListenerPorts            `json:"ListenerPorts,omitempty" xml:"ListenerPorts,omitempty" type:"Struct"`
	ListenerPortsAndProtocal     *DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocal `json:"ListenerPortsAndProtocal,omitempty" xml:"ListenerPortsAndProtocal,omitempty" type:"Struct"`
	ListenerPortsAndProtocol     *DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocol `json:"ListenerPortsAndProtocol,omitempty" xml:"ListenerPortsAndProtocol,omitempty" type:"Struct"`
	LoadBalancerId               *string                                                            `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	LoadBalancerName             *string                                                            `json:"LoadBalancerName,omitempty" xml:"LoadBalancerName,omitempty"`
	LoadBalancerSpec             *string                                                            `json:"LoadBalancerSpec,omitempty" xml:"LoadBalancerSpec,omitempty"`
	LoadBalancerStatus           *string                                                            `json:"LoadBalancerStatus,omitempty" xml:"LoadBalancerStatus,omitempty"`
	MasterZoneId                 *string                                                            `json:"MasterZoneId,omitempty" xml:"MasterZoneId,omitempty"`
	ModificationProtectionReason *string                                                            `json:"ModificationProtectionReason,omitempty" xml:"ModificationProtectionReason,omitempty"`
	ModificationProtectionStatus *string                                                            `json:"ModificationProtectionStatus,omitempty" xml:"ModificationProtectionStatus,omitempty"`
	NetworkType                  *string                                                            `json:"NetworkType,omitempty" xml:"NetworkType,omitempty"`
	PayType                      *string                                                            `json:"PayType,omitempty" xml:"PayType,omitempty"`
	RegionId                     *string                                                            `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	RegionIdAlias                *string                                                            `json:"RegionIdAlias,omitempty" xml:"RegionIdAlias,omitempty"`
	RenewalCycUnit               *string                                                            `json:"RenewalCycUnit,omitempty" xml:"RenewalCycUnit,omitempty"`
	RenewalDuration              *int32                                                             `json:"RenewalDuration,omitempty" xml:"RenewalDuration,omitempty"`
	RenewalStatus                *string                                                            `json:"RenewalStatus,omitempty" xml:"RenewalStatus,omitempty"`
	RequestId                    *string                                                            `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	ResourceGroupId              *string                                                            `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	SlaveZoneId                  *string                                                            `json:"SlaveZoneId,omitempty" xml:"SlaveZoneId,omitempty"`
	Tags                         *DescribeLoadBalancerAttributeResponseBodyTags                     `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	VSwitchId                    *string                                                            `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	VpcId                        *string                                                            `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DescribeLoadBalancerAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetAddress(v string) *DescribeLoadBalancerAttributeResponseBody {
	s.Address = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetAddressIPVersion(v string) *DescribeLoadBalancerAttributeResponseBody {
	s.AddressIPVersion = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetAddressType(v string) *DescribeLoadBalancerAttributeResponseBody {
	s.AddressType = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetAutoReleaseTime(v int64) *DescribeLoadBalancerAttributeResponseBody {
	s.AutoReleaseTime = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetBackendServers(v *DescribeLoadBalancerAttributeResponseBodyBackendServers) *DescribeLoadBalancerAttributeResponseBody {
	s.BackendServers = v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetBandwidth(v int32) *DescribeLoadBalancerAttributeResponseBody {
	s.Bandwidth = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetCreateTime(v string) *DescribeLoadBalancerAttributeResponseBody {
	s.CreateTime = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetCreateTimeStamp(v int64) *DescribeLoadBalancerAttributeResponseBody {
	s.CreateTimeStamp = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetDeleteProtection(v string) *DescribeLoadBalancerAttributeResponseBody {
	s.DeleteProtection = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetEndTime(v string) *DescribeLoadBalancerAttributeResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetEndTimeStamp(v int64) *DescribeLoadBalancerAttributeResponseBody {
	s.EndTimeStamp = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetInstanceChargeType(v string) *DescribeLoadBalancerAttributeResponseBody {
	s.InstanceChargeType = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetInternetChargeType(v string) *DescribeLoadBalancerAttributeResponseBody {
	s.InternetChargeType = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetListenerPorts(v *DescribeLoadBalancerAttributeResponseBodyListenerPorts) *DescribeLoadBalancerAttributeResponseBody {
	s.ListenerPorts = v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetListenerPortsAndProtocal(v *DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocal) *DescribeLoadBalancerAttributeResponseBody {
	s.ListenerPortsAndProtocal = v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetListenerPortsAndProtocol(v *DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocol) *DescribeLoadBalancerAttributeResponseBody {
	s.ListenerPortsAndProtocol = v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetLoadBalancerId(v string) *DescribeLoadBalancerAttributeResponseBody {
	s.LoadBalancerId = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetLoadBalancerName(v string) *DescribeLoadBalancerAttributeResponseBody {
	s.LoadBalancerName = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetLoadBalancerSpec(v string) *DescribeLoadBalancerAttributeResponseBody {
	s.LoadBalancerSpec = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetLoadBalancerStatus(v string) *DescribeLoadBalancerAttributeResponseBody {
	s.LoadBalancerStatus = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetMasterZoneId(v string) *DescribeLoadBalancerAttributeResponseBody {
	s.MasterZoneId = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetModificationProtectionReason(v string) *DescribeLoadBalancerAttributeResponseBody {
	s.ModificationProtectionReason = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetModificationProtectionStatus(v string) *DescribeLoadBalancerAttributeResponseBody {
	s.ModificationProtectionStatus = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetNetworkType(v string) *DescribeLoadBalancerAttributeResponseBody {
	s.NetworkType = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetPayType(v string) *DescribeLoadBalancerAttributeResponseBody {
	s.PayType = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetRegionId(v string) *DescribeLoadBalancerAttributeResponseBody {
	s.RegionId = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetRegionIdAlias(v string) *DescribeLoadBalancerAttributeResponseBody {
	s.RegionIdAlias = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetRenewalCycUnit(v string) *DescribeLoadBalancerAttributeResponseBody {
	s.RenewalCycUnit = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetRenewalDuration(v int32) *DescribeLoadBalancerAttributeResponseBody {
	s.RenewalDuration = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetRenewalStatus(v string) *DescribeLoadBalancerAttributeResponseBody {
	s.RenewalStatus = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetRequestId(v string) *DescribeLoadBalancerAttributeResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetResourceGroupId(v string) *DescribeLoadBalancerAttributeResponseBody {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetSlaveZoneId(v string) *DescribeLoadBalancerAttributeResponseBody {
	s.SlaveZoneId = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetTags(v *DescribeLoadBalancerAttributeResponseBodyTags) *DescribeLoadBalancerAttributeResponseBody {
	s.Tags = v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetVSwitchId(v string) *DescribeLoadBalancerAttributeResponseBody {
	s.VSwitchId = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBody) SetVpcId(v string) *DescribeLoadBalancerAttributeResponseBody {
	s.VpcId = &v
	return s
}

type DescribeLoadBalancerAttributeResponseBodyBackendServers struct {
	BackendServer []*DescribeLoadBalancerAttributeResponseBodyBackendServersBackendServer `json:"BackendServer,omitempty" xml:"BackendServer,omitempty" type:"Repeated"`
}

func (s DescribeLoadBalancerAttributeResponseBodyBackendServers) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerAttributeResponseBodyBackendServers) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerAttributeResponseBodyBackendServers) SetBackendServer(v []*DescribeLoadBalancerAttributeResponseBodyBackendServersBackendServer) *DescribeLoadBalancerAttributeResponseBodyBackendServers {
	s.BackendServer = v
	return s
}

type DescribeLoadBalancerAttributeResponseBodyBackendServersBackendServer struct {
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	ServerId    *string `json:"ServerId,omitempty" xml:"ServerId,omitempty"`
	ServerIp    *string `json:"ServerIp,omitempty" xml:"ServerIp,omitempty"`
	Type        *string `json:"Type,omitempty" xml:"Type,omitempty"`
	Weight      *int32  `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeLoadBalancerAttributeResponseBodyBackendServersBackendServer) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerAttributeResponseBodyBackendServersBackendServer) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerAttributeResponseBodyBackendServersBackendServer) SetDescription(v string) *DescribeLoadBalancerAttributeResponseBodyBackendServersBackendServer {
	s.Description = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBodyBackendServersBackendServer) SetServerId(v string) *DescribeLoadBalancerAttributeResponseBodyBackendServersBackendServer {
	s.ServerId = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBodyBackendServersBackendServer) SetServerIp(v string) *DescribeLoadBalancerAttributeResponseBodyBackendServersBackendServer {
	s.ServerIp = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBodyBackendServersBackendServer) SetType(v string) *DescribeLoadBalancerAttributeResponseBodyBackendServersBackendServer {
	s.Type = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBodyBackendServersBackendServer) SetWeight(v int32) *DescribeLoadBalancerAttributeResponseBodyBackendServersBackendServer {
	s.Weight = &v
	return s
}

type DescribeLoadBalancerAttributeResponseBodyListenerPorts struct {
	ListenerPort []*int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty" type:"Repeated"`
}

func (s DescribeLoadBalancerAttributeResponseBodyListenerPorts) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerAttributeResponseBodyListenerPorts) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerAttributeResponseBodyListenerPorts) SetListenerPort(v []*int32) *DescribeLoadBalancerAttributeResponseBodyListenerPorts {
	s.ListenerPort = v
	return s
}

type DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocal struct {
	ListenerPortAndProtocal []*DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocalListenerPortAndProtocal `json:"ListenerPortAndProtocal,omitempty" xml:"ListenerPortAndProtocal,omitempty" type:"Repeated"`
}

func (s DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocal) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocal) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocal) SetListenerPortAndProtocal(v []*DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocalListenerPortAndProtocal) *DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocal {
	s.ListenerPortAndProtocal = v
	return s
}

type DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocalListenerPortAndProtocal struct {
	ListenerPort     *int32  `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	ListenerProtocal *string `json:"ListenerProtocal,omitempty" xml:"ListenerProtocal,omitempty"`
}

func (s DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocalListenerPortAndProtocal) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocalListenerPortAndProtocal) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocalListenerPortAndProtocal) SetListenerPort(v int32) *DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocalListenerPortAndProtocal {
	s.ListenerPort = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocalListenerPortAndProtocal) SetListenerProtocal(v string) *DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocalListenerPortAndProtocal {
	s.ListenerProtocal = &v
	return s
}

type DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocol struct {
	ListenerPortAndProtocol []*DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocolListenerPortAndProtocol `json:"ListenerPortAndProtocol,omitempty" xml:"ListenerPortAndProtocol,omitempty" type:"Repeated"`
}

func (s DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocol) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocol) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocol) SetListenerPortAndProtocol(v []*DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocolListenerPortAndProtocol) *DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocol {
	s.ListenerPortAndProtocol = v
	return s
}

type DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocolListenerPortAndProtocol struct {
	Description      *string `json:"Description,omitempty" xml:"Description,omitempty"`
	ForwardPort      *int32  `json:"ForwardPort,omitempty" xml:"ForwardPort,omitempty"`
	ListenerForward  *string `json:"ListenerForward,omitempty" xml:"ListenerForward,omitempty"`
	ListenerPort     *int32  `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	ListenerProtocol *string `json:"ListenerProtocol,omitempty" xml:"ListenerProtocol,omitempty"`
}

func (s DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocolListenerPortAndProtocol) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocolListenerPortAndProtocol) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocolListenerPortAndProtocol) SetDescription(v string) *DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocolListenerPortAndProtocol {
	s.Description = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocolListenerPortAndProtocol) SetForwardPort(v int32) *DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocolListenerPortAndProtocol {
	s.ForwardPort = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocolListenerPortAndProtocol) SetListenerForward(v string) *DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocolListenerPortAndProtocol {
	s.ListenerForward = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocolListenerPortAndProtocol) SetListenerPort(v int32) *DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocolListenerPortAndProtocol {
	s.ListenerPort = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocolListenerPortAndProtocol) SetListenerProtocol(v string) *DescribeLoadBalancerAttributeResponseBodyListenerPortsAndProtocolListenerPortAndProtocol {
	s.ListenerProtocol = &v
	return s
}

type DescribeLoadBalancerAttributeResponseBodyTags struct {
	Tag []*DescribeLoadBalancerAttributeResponseBodyTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeLoadBalancerAttributeResponseBodyTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerAttributeResponseBodyTags) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerAttributeResponseBodyTags) SetTag(v []*DescribeLoadBalancerAttributeResponseBodyTagsTag) *DescribeLoadBalancerAttributeResponseBodyTags {
	s.Tag = v
	return s
}

type DescribeLoadBalancerAttributeResponseBodyTagsTag struct {
	TagKey   *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s DescribeLoadBalancerAttributeResponseBodyTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerAttributeResponseBodyTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerAttributeResponseBodyTagsTag) SetTagKey(v string) *DescribeLoadBalancerAttributeResponseBodyTagsTag {
	s.TagKey = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponseBodyTagsTag) SetTagValue(v string) *DescribeLoadBalancerAttributeResponseBodyTagsTag {
	s.TagValue = &v
	return s
}

type DescribeLoadBalancerAttributeResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeLoadBalancerAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeLoadBalancerAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerAttributeResponse) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerAttributeResponse) SetHeaders(v map[string]*string) *DescribeLoadBalancerAttributeResponse {
	s.Headers = v
	return s
}

func (s *DescribeLoadBalancerAttributeResponse) SetStatusCode(v int32) *DescribeLoadBalancerAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeLoadBalancerAttributeResponse) SetBody(v *DescribeLoadBalancerAttributeResponseBody) *DescribeLoadBalancerAttributeResponse {
	s.Body = v
	return s
}

type DescribeLoadBalancerHTTPListenerAttributeRequest struct {
	// Indicates whether the listener is in the Secure state. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	ListenerPort *int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	// The name of the forwarding rule.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// Indicates whether the `SLB-ID` header is used to retrieve the ID of the CLB instance. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeLoadBalancerHTTPListenerAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerHTTPListenerAttributeRequest) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerHTTPListenerAttributeRequest) SetListenerPort(v int32) *DescribeLoadBalancerHTTPListenerAttributeRequest {
	s.ListenerPort = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeRequest) SetLoadBalancerId(v string) *DescribeLoadBalancerHTTPListenerAttributeRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeRequest) SetOwnerAccount(v string) *DescribeLoadBalancerHTTPListenerAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeRequest) SetOwnerId(v int64) *DescribeLoadBalancerHTTPListenerAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeRequest) SetRegionId(v string) *DescribeLoadBalancerHTTPListenerAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeRequest) SetResourceOwnerAccount(v string) *DescribeLoadBalancerHTTPListenerAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeRequest) SetResourceOwnerId(v int64) *DescribeLoadBalancerHTTPListenerAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeLoadBalancerHTTPListenerAttributeResponseBody struct {
	// The URI that is used for health checks.
	//
	// The URI must be 1 to 80 characters in length, and can contain only digits, letters, hyphens (-), forward slashes (/), periods (.), percent signs (%), question marks (?), number signs (#), and ampersands (&). The URI must start with a forward slash (/) but cannot be a single forward slash (/).
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The ID of the server group that is associated with the forwarding rule.
	AclStatus *string `json:"AclStatus,omitempty" xml:"AclStatus,omitempty"`
	// Indicates whether HTTP-to-HTTPS redirection is enabled. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	AclType *string `json:"AclType,omitempty" xml:"AclType,omitempty"`
	// The frontend port that is used by the CLB instance.
	BackendServerPort *int32 `json:"BackendServerPort,omitempty" xml:"BackendServerPort,omitempty"`
	// The maximum bandwidth of the listener. Unit: Mbit/s.
	//
	// *   **-1**: If -1 is returned, it indicates that the bandwidth of the listener is unlimited.
	// *   **1 to 5120**: If a value from 1 to 5120 is returned, the value indicates the maximum bandwidth of the listener. The sum of the maximum bandwidth of all listeners added to a CLB instance does not exceed the maximum bandwidth of the CLB instance.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The port that is used for health checks.
	//
	// >  This parameter takes effect only if the **HealthCheck** parameter is set to **on**.
	Cookie *string `json:"Cookie,omitempty" xml:"Cookie,omitempty"`
	// The listening port that is used to redirect HTTP requests to HTTPS.
	//
	// >  If the **ListenerForward** parameter is set to **off**, this parameter is not returned.
	CookieTimeout *int32 `json:"CookieTimeout,omitempty" xml:"CookieTimeout,omitempty"`
	// The number of times that a backend server must consecutively fail health checks before it is declared unhealthy.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether session persistence is enabled. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	ForwardPort *int32 `json:"ForwardPort,omitempty" xml:"ForwardPort,omitempty"`
	// Indicates whether the `SLB-IP` header is used to retrieve the virtual IP address requested by the client. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	Gzip *string `json:"Gzip,omitempty" xml:"Gzip,omitempty"`
	// The ID of the request.
	HealthCheck *string `json:"HealthCheck,omitempty" xml:"HealthCheck,omitempty"`
	// The domain name.
	HealthCheckConnectPort *int32 `json:"HealthCheckConnectPort,omitempty" xml:"HealthCheckConnectPort,omitempty"`
	// The list of forwarding rules.
	HealthCheckDomain *string `json:"HealthCheckDomain,omitempty" xml:"HealthCheckDomain,omitempty"`
	// Indicates whether the `X-Forwarded-Proto` header is used to retrieve the listening protocol. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	HealthCheckHttpCode *string `json:"HealthCheckHttpCode,omitempty" xml:"HealthCheckHttpCode,omitempty"`
	// The ID of the associated server group.
	HealthCheckInterval *int32 `json:"HealthCheckInterval,omitempty" xml:"HealthCheckInterval,omitempty"`
	// The number of times that a backend server must consecutively pass health checks before it is declared healthy.
	HealthCheckMethod *string `json:"HealthCheckMethod,omitempty" xml:"HealthCheckMethod,omitempty"`
	// The cookie that is configured on the backend server.
	HealthCheckTimeout *int32 `json:"HealthCheckTimeout,omitempty" xml:"HealthCheckTimeout,omitempty"`
	// The domain name that is used for health checks.
	HealthCheckURI *string `json:"HealthCheckURI,omitempty" xml:"HealthCheckURI,omitempty"`
	// The timeout period of a request. Unit: seconds.
	//
	// Default value: **60**. Valid values: **1 to 180**.
	//
	// If no response is received from a backend server within the specified timeout period, CLB returns the HTTP 504 status code to the client.
	HealthyThreshold *int32 `json:"HealthyThreshold,omitempty" xml:"HealthyThreshold,omitempty"`
	// The health check method used in HTTP health checks. Valid values: **head** and **get**.
	//
	// >  This parameter is returned only if the **HealthCheck** parameter is set to **on**.
	IdleTimeout *int32 `json:"IdleTimeout,omitempty" xml:"IdleTimeout,omitempty"`
	// Indicates whether `Gzip` compression is enabled to compress specific types of files. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	ListenerForward *string `json:"ListenerForward,omitempty" xml:"ListenerForward,omitempty"`
	// The frontend port that is used by the CLB instance.
	//
	// Valid values: **1** to **65535**.
	ListenerPort   *int32  `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// The operation that you want to perform. Set the value to **DescribeLoadBalancerHTTPListenerAttribute**.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the CLB instance.
	RequestTimeout *int32 `json:"RequestTimeout,omitempty" xml:"RequestTimeout,omitempty"`
	// Indicates whether the health check feature is enabled. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	Rules *DescribeLoadBalancerHTTPListenerAttributeResponseBodyRules `json:"Rules,omitempty" xml:"Rules,omitempty" type:"Struct"`
	// The timeout period of each health check. Unit: seconds.
	Scheduler *string `json:"Scheduler,omitempty" xml:"Scheduler,omitempty"`
	// The method that is used to handle a cookie.
	//
	// Valid values: **insert** and **server**.
	//
	// *   **insert**: inserts a cookie.
	//
	//     CLB inserts a session cookie (SERVERID) into the first HTTP or HTTPS response that is sent to a client. Subsequent requests to CLB carry this cookie, and CLB determines the destination servers of the requests based on the cookies.
	//
	// *   **server**: rewrites a cookie.
	//
	//     When CLB detects a user-defined cookie, it overwrites the original cookie with the user-defined cookie. The next request from the client carries the user-defined cookie, and the listener will distribute the request to the recorded backend server.
	//
	// >  This parameter is returned if the **StickySession** parameter is set to **on**.
	SecurityStatus *string `json:"SecurityStatus,omitempty" xml:"SecurityStatus,omitempty"`
	// The region ID of the CLB instance.
	//
	// You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The description of the HTTP listener.
	StickySession *string `json:"StickySession,omitempty" xml:"StickySession,omitempty"`
	// Indicates whether the `X-Forwarded-For` header is used to preserve the real IP address of the client. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	StickySessionType *string                                                    `json:"StickySessionType,omitempty" xml:"StickySessionType,omitempty"`
	Tags              *DescribeLoadBalancerHTTPListenerAttributeResponseBodyTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The interval at which health checks are performed. Unit: seconds.
	UnhealthyThreshold *int32 `json:"UnhealthyThreshold,omitempty" xml:"UnhealthyThreshold,omitempty"`
	// The timeout period of an idle connection. Unit: seconds.
	//
	// Default value: **15**. Valid values: **1 to 60**.
	//
	// If no request is received within the specified timeout period, CLB closes the connection. When a request is received, CLB establishes a new connection.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
	// Indicates whether access control is enabled. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	XForwardedFor *string `json:"XForwardedFor,omitempty" xml:"XForwardedFor,omitempty"`
	// The ID of the forwarding rule.
	XForwardedFor_SLBID *string `json:"XForwardedFor_SLBID,omitempty" xml:"XForwardedFor_SLBID,omitempty"`
	// The timeout period of a cookie. Unit: seconds.
	XForwardedFor_SLBIP *string `json:"XForwardedFor_SLBIP,omitempty" xml:"XForwardedFor_SLBIP,omitempty"`
	// The type of the ACL. Valid values:
	//
	// *   **white**: a whitelist. Only requests from the IP addresses or CIDR blocks in the network ACL are forwarded. Whitelists apply to scenarios where you want to allow only specific IP addresses to access an application. Your service may be adversely affected if the whitelist is not properly configured. After a whitelist is configured, only requests from IP addresses that are added to the whitelist are forwarded by the listener.
	//
	//     If you enable a whitelist but do not add an IP address to the ACL, the listener forwards all requests.
	//
	// *   **black**: a blacklist. All requests from the IP addresses or CIDR blocks in the ACL are rejected. Blacklists apply to scenarios where you want to block access from specified IP addresses to an application.
	//
	//     If a blacklist is configured for a listener but no IP address is added to the blacklist, the listener forwards all requests.
	//
	// >  If **AclStatus** is set to **on**, this parameter is returned.
	XForwardedFor_proto *string `json:"XForwardedFor_proto,omitempty" xml:"XForwardedFor_proto,omitempty"`
}

func (s DescribeLoadBalancerHTTPListenerAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerHTTPListenerAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetAclId(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.AclId = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetAclStatus(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.AclStatus = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetAclType(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.AclType = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetBackendServerPort(v int32) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.BackendServerPort = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetBandwidth(v int32) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.Bandwidth = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetCookie(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.Cookie = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetCookieTimeout(v int32) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.CookieTimeout = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetDescription(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.Description = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetForwardPort(v int32) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.ForwardPort = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetGzip(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.Gzip = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetHealthCheck(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.HealthCheck = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetHealthCheckConnectPort(v int32) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.HealthCheckConnectPort = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetHealthCheckDomain(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.HealthCheckDomain = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetHealthCheckHttpCode(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.HealthCheckHttpCode = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetHealthCheckInterval(v int32) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.HealthCheckInterval = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetHealthCheckMethod(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.HealthCheckMethod = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetHealthCheckTimeout(v int32) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.HealthCheckTimeout = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetHealthCheckURI(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.HealthCheckURI = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetHealthyThreshold(v int32) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.HealthyThreshold = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetIdleTimeout(v int32) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.IdleTimeout = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetListenerForward(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.ListenerForward = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetListenerPort(v int32) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.ListenerPort = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetLoadBalancerId(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.LoadBalancerId = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetRequestId(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetRequestTimeout(v int32) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.RequestTimeout = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetRules(v *DescribeLoadBalancerHTTPListenerAttributeResponseBodyRules) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.Rules = v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetScheduler(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.Scheduler = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetSecurityStatus(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.SecurityStatus = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetStatus(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.Status = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetStickySession(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.StickySession = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetStickySessionType(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.StickySessionType = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetTags(v *DescribeLoadBalancerHTTPListenerAttributeResponseBodyTags) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.Tags = v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetUnhealthyThreshold(v int32) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.UnhealthyThreshold = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetVServerGroupId(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.VServerGroupId = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetXForwardedFor(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.XForwardedFor = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetXForwardedFor_SLBID(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.XForwardedFor_SLBID = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetXForwardedFor_SLBIP(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.XForwardedFor_SLBIP = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBody) SetXForwardedFor_proto(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBody {
	s.XForwardedFor_proto = &v
	return s
}

type DescribeLoadBalancerHTTPListenerAttributeResponseBodyRules struct {
	Rule []*DescribeLoadBalancerHTTPListenerAttributeResponseBodyRulesRule `json:"Rule,omitempty" xml:"Rule,omitempty" type:"Repeated"`
}

func (s DescribeLoadBalancerHTTPListenerAttributeResponseBodyRules) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerHTTPListenerAttributeResponseBodyRules) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBodyRules) SetRule(v []*DescribeLoadBalancerHTTPListenerAttributeResponseBodyRulesRule) *DescribeLoadBalancerHTTPListenerAttributeResponseBodyRules {
	s.Rule = v
	return s
}

type DescribeLoadBalancerHTTPListenerAttributeResponseBodyRulesRule struct {
	// Queries the configuration of an HTTP listener of Classic Load Balancer (CLB).
	Domain   *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	RuleId   *string `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	// The status of the listener. Valid values:
	//
	// *   **running**
	// *   **stopped**
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
	// The backend port that is used by the CLB instance.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
}

func (s DescribeLoadBalancerHTTPListenerAttributeResponseBodyRulesRule) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerHTTPListenerAttributeResponseBodyRulesRule) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBodyRulesRule) SetDomain(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBodyRulesRule {
	s.Domain = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBodyRulesRule) SetRuleId(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBodyRulesRule {
	s.RuleId = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBodyRulesRule) SetRuleName(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBodyRulesRule {
	s.RuleName = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBodyRulesRule) SetUrl(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBodyRulesRule {
	s.Url = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBodyRulesRule) SetVServerGroupId(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBodyRulesRule {
	s.VServerGroupId = &v
	return s
}

type DescribeLoadBalancerHTTPListenerAttributeResponseBodyTags struct {
	Tag []*DescribeLoadBalancerHTTPListenerAttributeResponseBodyTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeLoadBalancerHTTPListenerAttributeResponseBodyTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerHTTPListenerAttributeResponseBodyTags) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBodyTags) SetTag(v []*DescribeLoadBalancerHTTPListenerAttributeResponseBodyTagsTag) *DescribeLoadBalancerHTTPListenerAttributeResponseBodyTags {
	s.Tag = v
	return s
}

type DescribeLoadBalancerHTTPListenerAttributeResponseBodyTagsTag struct {
	TagKey   *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s DescribeLoadBalancerHTTPListenerAttributeResponseBodyTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerHTTPListenerAttributeResponseBodyTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBodyTagsTag) SetTagKey(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBodyTagsTag {
	s.TagKey = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponseBodyTagsTag) SetTagValue(v string) *DescribeLoadBalancerHTTPListenerAttributeResponseBodyTagsTag {
	s.TagValue = &v
	return s
}

type DescribeLoadBalancerHTTPListenerAttributeResponse struct {
	Headers    map[string]*string                                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeLoadBalancerHTTPListenerAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeLoadBalancerHTTPListenerAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerHTTPListenerAttributeResponse) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponse) SetHeaders(v map[string]*string) *DescribeLoadBalancerHTTPListenerAttributeResponse {
	s.Headers = v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponse) SetStatusCode(v int32) *DescribeLoadBalancerHTTPListenerAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeLoadBalancerHTTPListenerAttributeResponse) SetBody(v *DescribeLoadBalancerHTTPListenerAttributeResponseBody) *DescribeLoadBalancerHTTPListenerAttributeResponse {
	s.Body = v
	return s
}

type DescribeLoadBalancerHTTPSListenerAttributeRequest struct {
	// The operation that you want to perform. Set the value to **DescribeLoadBalancerHTTPSListenerAttribute**.
	ListenerPort *int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	// The domain name.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the CLB instance.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeLoadBalancerHTTPSListenerAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerHTTPSListenerAttributeRequest) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeRequest) SetListenerPort(v int32) *DescribeLoadBalancerHTTPSListenerAttributeRequest {
	s.ListenerPort = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeRequest) SetLoadBalancerId(v string) *DescribeLoadBalancerHTTPSListenerAttributeRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeRequest) SetOwnerAccount(v string) *DescribeLoadBalancerHTTPSListenerAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeRequest) SetOwnerId(v int64) *DescribeLoadBalancerHTTPSListenerAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeRequest) SetRegionId(v string) *DescribeLoadBalancerHTTPSListenerAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeRequest) SetResourceOwnerAccount(v string) *DescribeLoadBalancerHTTPSListenerAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeRequest) SetResourceOwnerId(v int64) *DescribeLoadBalancerHTTPSListenerAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeLoadBalancerHTTPSListenerAttributeResponseBody struct {
	// Indicates whether the `X-Forwarded-For` header is used to retrieve client IP addresses. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// Indicates whether `HTTP/2` is used. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	AclStatus *string `json:"AclStatus,omitempty" xml:"AclStatus,omitempty"`
	// The ID of the certification authority (CA) certificate.
	AclType *string `json:"AclType,omitempty" xml:"AclType,omitempty"`
	// The ID of the forwarding rule.
	BackendServerPort *int32 `json:"BackendServerPort,omitempty" xml:"BackendServerPort,omitempty"`
	// The number of times that a backend server must consecutively fail health checks before it is declared unhealthy.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The ID of the server group that is associated with the forwarding rule.
	CACertificateId *string `json:"CACertificateId,omitempty" xml:"CACertificateId,omitempty"`
	// The timeout period of an idle connection. Valid values: **1** to **60**. Default value: **15**. Unit: seconds.
	//
	// If no request is received within the specified timeout period, CLB closes the connection. When a request is received, CLB establishes a new connection.
	Cookie *string `json:"Cookie,omitempty" xml:"Cookie,omitempty"`
	// Indicates whether `Gzip` compression is enabled. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	CookieTimeout *int32 `json:"CookieTimeout,omitempty" xml:"CookieTimeout,omitempty"`
	// Indicates whether the `XForwardedFor_ClientSrcPort` header is used to retrieve the client port. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	Description      *string                                                                 `json:"Description,omitempty" xml:"Description,omitempty"`
	DomainExtensions *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyDomainExtensions `json:"DomainExtensions,omitempty" xml:"DomainExtensions,omitempty" type:"Struct"`
	// Indicates whether the `SLB-IP` header is used to retrieve the virtual IP address requested by the client. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	EnableHttp2 *string `json:"EnableHttp2,omitempty" xml:"EnableHttp2,omitempty"`
	// The ID of the server certificate.
	Gzip *string `json:"Gzip,omitempty" xml:"Gzip,omitempty"`
	// Indicates whether the `XForwardedFor_SLBPORT` header is used to retrieve the listening port. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	HealthCheck *string `json:"HealthCheck,omitempty" xml:"HealthCheck,omitempty"`
	// Indicates whether session persistence is enabled. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	HealthCheckConnectPort *int32 `json:"HealthCheckConnectPort,omitempty" xml:"HealthCheckConnectPort,omitempty"`
	// Indicates whether access control is enabled. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	HealthCheckDomain *string `json:"HealthCheckDomain,omitempty" xml:"HealthCheckDomain,omitempty"`
	// Indicates whether the `X-Forwarded-Proto` header is used to retrieve the listening protocol. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	HealthCheckHttpCode *string `json:"HealthCheckHttpCode,omitempty" xml:"HealthCheckHttpCode,omitempty"`
	// The Transport Layer Security (TLS) security policy for a high-performance CLB instance.
	//
	// Each security policy contains TLS protocol versions and cipher suites available for HTTPS. Valid values:
	//
	// *   **tls_cipher_policy\_1\_0**:
	//
	//     Supported TLS versions: TLS 1.0, TLS 1.1, and TLS 1.2
	//
	//     Supported cipher suites: ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, AES128-GCM-SHA256, AES256-GCM-SHA384, AES128-SHA256, AES256-SHA256, ECDHE-RSA-AES128-SHA, ECDHE-RSA-AES256-SHA, AES128-SHA, AES256-SHA, and DES-CBC3-SHA
	//
	// *   **tls_cipher_policy\_1\_1**:
	//
	//     Supported TLS versions: TLS 1.1 and TLS 1.2
	//
	//     Supported cipher suites: ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, AES128-GCM-SHA256, AES256-GCM-SHA384, AES128-SHA256, AES256-SHA256, ECDHE-RSA-AES128-SHA, ECDHE-RSA-AES256-SHA, AES128-SHA, AES256-SHA, and DES-CBC3-SHA
	//
	// *   **tls_cipher_policy\_1\_2**
	//
	//     Supported TLS version: TLS 1.2
	//
	//     Supported cipher suites: ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, AES128-GCM-SHA256, AES256-GCM-SHA384, AES128-SHA256, AES256-SHA256, ECDHE-RSA-AES128-SHA, ECDHE-RSA-AES256-SHA, AES128-SHA, AES256-SHA, and DES-CBC3-SHA
	//
	// *   **tls_cipher_policy\_1\_2\_strict**
	//
	//     Supported TLS version: TLS 1.2
	//
	//     Supported cipher suites: ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, ECDHE-RSA-AES128-SHA, and ECDHE-RSA-AES256-SHA
	//
	// *   **tls_cipher_policy\_1\_2\_strict_with\_1\_3**
	//
	//     Supported TLS versions: TLS 1.2 and TLS 1.3
	//
	//     Supported cipher suites: TLS_AES\_128\_GCM_SHA256, TLS_AES\_256\_GCM_SHA384, TLS_CHACHA20\_POLY1305\_SHA256, TLS_AES\_128\_CCM_SHA256, TLS_AES\_128\_CCM\_8\_SHA256, ECDHE-ECDSA-AES128-GCM-SHA256, ECDHE-ECDSA-AES256-GCM-SHA384, ECDHE-ECDSA-AES128-SHA256, ECDHE-ECDSA-AES256-SHA384, ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, ECDHE-ECDSA-AES128-SHA, ECDHE-ECDSA-AES256-SHA, ECDHE-RSA-AES128-SHA, and ECDHE-RSA-AES256-SHA
	HealthCheckInterval *int32 `json:"HealthCheckInterval,omitempty" xml:"HealthCheckInterval,omitempty"`
	// The HTTP status codes that are used to determine whether the backend server passes the health check.
	HealthCheckMethod *string `json:"HealthCheckMethod,omitempty" xml:"HealthCheckMethod,omitempty"`
	// The cookie that is configured on the backend server.
	HealthCheckTimeout *int32 `json:"HealthCheckTimeout,omitempty" xml:"HealthCheckTimeout,omitempty"`
	// The timeout period of a cookie.
	HealthCheckURI *string `json:"HealthCheckURI,omitempty" xml:"HealthCheckURI,omitempty"`
	// The timeout period of a request. Valid values: **1** to **180**. Default value: **60**. Unit: seconds.
	//
	// If no response is received from a backend server within the specified timeout period, CLB returns the HTTP 504 status code to the client.
	HealthyThreshold *int32 `json:"HealthyThreshold,omitempty" xml:"HealthyThreshold,omitempty"`
	// The frontend port that is used by the CLB instance.
	//
	// Valid values: **1** to **65535**.
	IdleTimeout *int32 `json:"IdleTimeout,omitempty" xml:"IdleTimeout,omitempty"`
	// The timeout period of a health check response. Unit: seconds.
	ListenerPort   *int32  `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// Indicates whether the `XForwardedFor_ClientCertIssuerDN` header is used to retrieve information about the authority that issues the client certificate. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the associated server group.
	RequestTimeout *int32 `json:"RequestTimeout,omitempty" xml:"RequestTimeout,omitempty"`
	// The ID of the request.
	Rules *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyRules `json:"Rules,omitempty" xml:"Rules,omitempty" type:"Struct"`
	// The backend port that is used by the CLB instance.
	Scheduler *string `json:"Scheduler,omitempty" xml:"Scheduler,omitempty"`
	// The method that is used to handle a cookie.
	//
	// Valid values: **insert** and **server**.
	//
	// *   **insert**: inserts a cookie.
	//
	//     CLB inserts a cookie (SERVERID) into the first HTTP or HTTPS response packet that is sent to a client. The next request from the client will contain this cookie, and the listener will distribute this request to the recorded backend server.
	//
	// *   **server**: rewrites a cookie.
	//
	//     When CLB detects a user-defined cookie, it overwrites the original cookie with the user-defined cookie. The next request from the client carries the user-defined cookie, and the listener will distribute the request to the recorded backend server.
	SecurityStatus *string `json:"SecurityStatus,omitempty" xml:"SecurityStatus,omitempty"`
	// The domain name that is used for health checks.
	ServerCertificateId *string `json:"ServerCertificateId,omitempty" xml:"ServerCertificateId,omitempty"`
	// The ID of the network ACL that is associated with the listener.
	//
	// >  If **AclStatus** is set to **on**, this parameter is returned.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the ACL. Valid values:
	//
	// *   **white**: a whitelist. Only requests from the IP addresses or CIDR blocks in the network ACL are forwarded. Whitelists apply to scenarios where you want to allow only specific IP addresses to access an application. Your service may be adversely affected if the whitelist is not properly configured. After a whitelist is configured, only requests from IP addresses that are added to the whitelist are forwarded by the listener.
	//
	//     If you enable a whitelist but do not add an IP address to the ACL, the listener forwards all requests.
	//
	// *   **black**: a blacklist. All requests from the IP addresses or CIDR blocks in the ACL are rejected. Blacklists apply to scenarios where you want to block access from specified IP addresses to an application.
	//
	//     If a blacklist is configured for a listener but no IP address is added to the blacklist, the listener forwards all requests.
	//
	// >  If **AclStatus** is set to **on**, this parameter is returned.
	StickySession *string `json:"StickySession,omitempty" xml:"StickySession,omitempty"`
	// The number of times that a backend server must consecutively pass health checks before it is declared healthy.
	StickySessionType *string `json:"StickySessionType,omitempty" xml:"StickySessionType,omitempty"`
	// Indicates whether the `SLB-ID` header is used to retrieve the ID of the CLB instance. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	TLSCipherPolicy *string                                                     `json:"TLSCipherPolicy,omitempty" xml:"TLSCipherPolicy,omitempty"`
	Tags            *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The frontend port that is used by the CLB instance.
	UnhealthyThreshold *int32 `json:"UnhealthyThreshold,omitempty" xml:"UnhealthyThreshold,omitempty"`
	// The name of the forwarding rule.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
	// The health check method used in HTTP health checks. Valid values: **head** and **get**.
	//
	// >  This parameter is returned only if the **HealthCheck** parameter is set to **on**.
	XForwardedFor *string `json:"XForwardedFor,omitempty" xml:"XForwardedFor,omitempty"`
	// The maximum bandwidth of the listener. Unit: Mbit/s.
	XForwardedFor_ClientCertClientVerify *string `json:"XForwardedFor_ClientCertClientVerify,omitempty" xml:"XForwardedFor_ClientCertClientVerify,omitempty"`
	// The ID of the CLB instance.
	XForwardedFor_ClientCertFingerprint *string `json:"XForwardedFor_ClientCertFingerprint,omitempty" xml:"XForwardedFor_ClientCertFingerprint,omitempty"`
	// The URI that is used for health checks.
	XForwardedFor_ClientCertIssuerDN *string `json:"XForwardedFor_ClientCertIssuerDN,omitempty" xml:"XForwardedFor_ClientCertIssuerDN,omitempty"`
	// The interval between two consecutive health checks. Unit: seconds.
	XForwardedFor_ClientCertSubjectDN *string `json:"XForwardedFor_ClientCertSubjectDN,omitempty" xml:"XForwardedFor_ClientCertSubjectDN,omitempty"`
	// Indicates whether the listener is in the Secure state. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	XForwardedFor_ClientSrcPort *string `json:"XForwardedFor_ClientSrcPort,omitempty" xml:"XForwardedFor_ClientSrcPort,omitempty"`
	// The list of forwarding rules that are associated with the listener.
	XForwardedFor_SLBID *string `json:"XForwardedFor_SLBID,omitempty" xml:"XForwardedFor_SLBID,omitempty"`
	// Indicates whether the `XForwardedFor_ClientCertSubjectDN` header is used to retrieve information about the owner of the client certificate. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	XForwardedFor_SLBIP *string `json:"XForwardedFor_SLBIP,omitempty" xml:"XForwardedFor_SLBIP,omitempty"`
	// The description of the listener.
	XForwardedFor_SLBPORT *string `json:"XForwardedFor_SLBPORT,omitempty" xml:"XForwardedFor_SLBPORT,omitempty"`
	// Indicates whether the `XForwardedFor_ClientCertFingerprint` header is used to retrieve the fingerprint of the client certificate. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	XForwardedFor_proto *string `json:"XForwardedFor_proto,omitempty" xml:"XForwardedFor_proto,omitempty"`
}

func (s DescribeLoadBalancerHTTPSListenerAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerHTTPSListenerAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetAclId(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.AclId = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetAclStatus(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.AclStatus = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetAclType(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.AclType = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetBackendServerPort(v int32) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.BackendServerPort = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetBandwidth(v int32) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.Bandwidth = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetCACertificateId(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.CACertificateId = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetCookie(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.Cookie = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetCookieTimeout(v int32) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.CookieTimeout = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetDescription(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.Description = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetDomainExtensions(v *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyDomainExtensions) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.DomainExtensions = v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetEnableHttp2(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.EnableHttp2 = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetGzip(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.Gzip = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetHealthCheck(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.HealthCheck = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetHealthCheckConnectPort(v int32) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.HealthCheckConnectPort = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetHealthCheckDomain(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.HealthCheckDomain = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetHealthCheckHttpCode(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.HealthCheckHttpCode = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetHealthCheckInterval(v int32) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.HealthCheckInterval = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetHealthCheckMethod(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.HealthCheckMethod = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetHealthCheckTimeout(v int32) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.HealthCheckTimeout = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetHealthCheckURI(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.HealthCheckURI = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetHealthyThreshold(v int32) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.HealthyThreshold = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetIdleTimeout(v int32) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.IdleTimeout = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetListenerPort(v int32) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.ListenerPort = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetLoadBalancerId(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.LoadBalancerId = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetRequestId(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetRequestTimeout(v int32) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.RequestTimeout = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetRules(v *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyRules) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.Rules = v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetScheduler(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.Scheduler = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetSecurityStatus(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.SecurityStatus = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetServerCertificateId(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.ServerCertificateId = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetStatus(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.Status = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetStickySession(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.StickySession = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetStickySessionType(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.StickySessionType = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetTLSCipherPolicy(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.TLSCipherPolicy = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetTags(v *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyTags) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.Tags = v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetUnhealthyThreshold(v int32) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.UnhealthyThreshold = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetVServerGroupId(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.VServerGroupId = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetXForwardedFor(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.XForwardedFor = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetXForwardedFor_ClientCertClientVerify(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.XForwardedFor_ClientCertClientVerify = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetXForwardedFor_ClientCertFingerprint(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.XForwardedFor_ClientCertFingerprint = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetXForwardedFor_ClientCertIssuerDN(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.XForwardedFor_ClientCertIssuerDN = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetXForwardedFor_ClientCertSubjectDN(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.XForwardedFor_ClientCertSubjectDN = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetXForwardedFor_ClientSrcPort(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.XForwardedFor_ClientSrcPort = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetXForwardedFor_SLBID(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.XForwardedFor_SLBID = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetXForwardedFor_SLBIP(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.XForwardedFor_SLBIP = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetXForwardedFor_SLBPORT(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.XForwardedFor_SLBPORT = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) SetXForwardedFor_proto(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBody {
	s.XForwardedFor_proto = &v
	return s
}

type DescribeLoadBalancerHTTPSListenerAttributeResponseBodyDomainExtensions struct {
	DomainExtension []*DescribeLoadBalancerHTTPSListenerAttributeResponseBodyDomainExtensionsDomainExtension `json:"DomainExtension,omitempty" xml:"DomainExtension,omitempty" type:"Repeated"`
}

func (s DescribeLoadBalancerHTTPSListenerAttributeResponseBodyDomainExtensions) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerHTTPSListenerAttributeResponseBodyDomainExtensions) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyDomainExtensions) SetDomainExtension(v []*DescribeLoadBalancerHTTPSListenerAttributeResponseBodyDomainExtensionsDomainExtension) *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyDomainExtensions {
	s.DomainExtension = v
	return s
}

type DescribeLoadBalancerHTTPSListenerAttributeResponseBodyDomainExtensionsDomainExtension struct {
	Domain              *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	DomainExtensionId   *string `json:"DomainExtensionId,omitempty" xml:"DomainExtensionId,omitempty"`
	ServerCertificateId *string `json:"ServerCertificateId,omitempty" xml:"ServerCertificateId,omitempty"`
}

func (s DescribeLoadBalancerHTTPSListenerAttributeResponseBodyDomainExtensionsDomainExtension) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerHTTPSListenerAttributeResponseBodyDomainExtensionsDomainExtension) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyDomainExtensionsDomainExtension) SetDomain(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyDomainExtensionsDomainExtension {
	s.Domain = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyDomainExtensionsDomainExtension) SetDomainExtensionId(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyDomainExtensionsDomainExtension {
	s.DomainExtensionId = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyDomainExtensionsDomainExtension) SetServerCertificateId(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyDomainExtensionsDomainExtension {
	s.ServerCertificateId = &v
	return s
}

type DescribeLoadBalancerHTTPSListenerAttributeResponseBodyRules struct {
	Rule []*DescribeLoadBalancerHTTPSListenerAttributeResponseBodyRulesRule `json:"Rule,omitempty" xml:"Rule,omitempty" type:"Repeated"`
}

func (s DescribeLoadBalancerHTTPSListenerAttributeResponseBodyRules) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerHTTPSListenerAttributeResponseBodyRules) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyRules) SetRule(v []*DescribeLoadBalancerHTTPSListenerAttributeResponseBodyRulesRule) *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyRules {
	s.Rule = v
	return s
}

type DescribeLoadBalancerHTTPSListenerAttributeResponseBodyRulesRule struct {
	// Queries the configurations of an HTTPS listener of Classic Load Balancer (CLB).
	Domain   *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	RuleId   *string `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	// The status of the listener. Valid values:
	//
	// *   **running**: The listener is running.
	// *   **stopped**: The listener is stopped.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
	// Indicates whether the health check feature is enabled. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
}

func (s DescribeLoadBalancerHTTPSListenerAttributeResponseBodyRulesRule) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerHTTPSListenerAttributeResponseBodyRulesRule) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyRulesRule) SetDomain(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyRulesRule {
	s.Domain = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyRulesRule) SetRuleId(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyRulesRule {
	s.RuleId = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyRulesRule) SetRuleName(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyRulesRule {
	s.RuleName = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyRulesRule) SetUrl(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyRulesRule {
	s.Url = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyRulesRule) SetVServerGroupId(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyRulesRule {
	s.VServerGroupId = &v
	return s
}

type DescribeLoadBalancerHTTPSListenerAttributeResponseBodyTags struct {
	Tag []*DescribeLoadBalancerHTTPSListenerAttributeResponseBodyTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeLoadBalancerHTTPSListenerAttributeResponseBodyTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerHTTPSListenerAttributeResponseBodyTags) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyTags) SetTag(v []*DescribeLoadBalancerHTTPSListenerAttributeResponseBodyTagsTag) *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyTags {
	s.Tag = v
	return s
}

type DescribeLoadBalancerHTTPSListenerAttributeResponseBodyTagsTag struct {
	TagKey   *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s DescribeLoadBalancerHTTPSListenerAttributeResponseBodyTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerHTTPSListenerAttributeResponseBodyTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyTagsTag) SetTagKey(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyTagsTag {
	s.TagKey = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyTagsTag) SetTagValue(v string) *DescribeLoadBalancerHTTPSListenerAttributeResponseBodyTagsTag {
	s.TagValue = &v
	return s
}

type DescribeLoadBalancerHTTPSListenerAttributeResponse struct {
	Headers    map[string]*string                                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeLoadBalancerHTTPSListenerAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeLoadBalancerHTTPSListenerAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerHTTPSListenerAttributeResponse) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponse) SetHeaders(v map[string]*string) *DescribeLoadBalancerHTTPSListenerAttributeResponse {
	s.Headers = v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponse) SetStatusCode(v int32) *DescribeLoadBalancerHTTPSListenerAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeLoadBalancerHTTPSListenerAttributeResponse) SetBody(v *DescribeLoadBalancerHTTPSListenerAttributeResponseBody) *DescribeLoadBalancerHTTPSListenerAttributeResponse {
	s.Body = v
	return s
}

type DescribeLoadBalancerListenersRequest struct {
	ListenerProtocol     *string                                    `json:"ListenerProtocol,omitempty" xml:"ListenerProtocol,omitempty"`
	LoadBalancerId       []*string                                  `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty" type:"Repeated"`
	MaxResults           *int32                                     `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	NextToken            *string                                    `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount         *string                                    `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64                                     `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	RegionId             *string                                    `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string                                    `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                                     `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tag                  []*DescribeLoadBalancerListenersRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeLoadBalancerListenersRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerListenersRequest) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerListenersRequest) SetListenerProtocol(v string) *DescribeLoadBalancerListenersRequest {
	s.ListenerProtocol = &v
	return s
}

func (s *DescribeLoadBalancerListenersRequest) SetLoadBalancerId(v []*string) *DescribeLoadBalancerListenersRequest {
	s.LoadBalancerId = v
	return s
}

func (s *DescribeLoadBalancerListenersRequest) SetMaxResults(v int32) *DescribeLoadBalancerListenersRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeLoadBalancerListenersRequest) SetNextToken(v string) *DescribeLoadBalancerListenersRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeLoadBalancerListenersRequest) SetOwnerAccount(v string) *DescribeLoadBalancerListenersRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeLoadBalancerListenersRequest) SetOwnerId(v int64) *DescribeLoadBalancerListenersRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeLoadBalancerListenersRequest) SetRegionId(v string) *DescribeLoadBalancerListenersRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeLoadBalancerListenersRequest) SetResourceOwnerAccount(v string) *DescribeLoadBalancerListenersRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeLoadBalancerListenersRequest) SetResourceOwnerId(v int64) *DescribeLoadBalancerListenersRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeLoadBalancerListenersRequest) SetTag(v []*DescribeLoadBalancerListenersRequestTag) *DescribeLoadBalancerListenersRequest {
	s.Tag = v
	return s
}

type DescribeLoadBalancerListenersRequestTag struct {
}

func (s DescribeLoadBalancerListenersRequestTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerListenersRequestTag) GoString() string {
	return s.String()
}

type DescribeLoadBalancerListenersResponseBody struct {
	Listeners  []*DescribeLoadBalancerListenersResponseBodyListeners `json:"Listeners,omitempty" xml:"Listeners,omitempty" type:"Repeated"`
	MaxResults *int32                                                `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	NextToken  *string                                               `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	RequestId  *string                                               `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TotalCount *int32                                                `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeLoadBalancerListenersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerListenersResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerListenersResponseBody) SetListeners(v []*DescribeLoadBalancerListenersResponseBodyListeners) *DescribeLoadBalancerListenersResponseBody {
	s.Listeners = v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBody) SetMaxResults(v int32) *DescribeLoadBalancerListenersResponseBody {
	s.MaxResults = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBody) SetNextToken(v string) *DescribeLoadBalancerListenersResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBody) SetRequestId(v string) *DescribeLoadBalancerListenersResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBody) SetTotalCount(v int32) *DescribeLoadBalancerListenersResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeLoadBalancerListenersResponseBodyListeners struct {
	AclId               *string                                                                `json:"AclId,omitempty" xml:"AclId,omitempty"`
	AclStatus           *string                                                                `json:"AclStatus,omitempty" xml:"AclStatus,omitempty"`
	AclType             *string                                                                `json:"AclType,omitempty" xml:"AclType,omitempty"`
	BackendServerPort   *int32                                                                 `json:"BackendServerPort,omitempty" xml:"BackendServerPort,omitempty"`
	Bandwidth           *int32                                                                 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	Description         *string                                                                `json:"Description,omitempty" xml:"Description,omitempty"`
	HTTPListenerConfig  *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig  `json:"HTTPListenerConfig,omitempty" xml:"HTTPListenerConfig,omitempty" type:"Struct"`
	HTTPSListenerConfig *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig `json:"HTTPSListenerConfig,omitempty" xml:"HTTPSListenerConfig,omitempty" type:"Struct"`
	ListenerPort        *int32                                                                 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	ListenerProtocol    *string                                                                `json:"ListenerProtocol,omitempty" xml:"ListenerProtocol,omitempty"`
	LoadBalancerId      *string                                                                `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	Scheduler           *string                                                                `json:"Scheduler,omitempty" xml:"Scheduler,omitempty"`
	Status              *string                                                                `json:"Status,omitempty" xml:"Status,omitempty"`
	TCPListenerConfig   *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig   `json:"TCPListenerConfig,omitempty" xml:"TCPListenerConfig,omitempty" type:"Struct"`
	Tags                []*DescribeLoadBalancerListenersResponseBodyListenersTags              `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	UDPListenerConfig   *DescribeLoadBalancerListenersResponseBodyListenersUDPListenerConfig   `json:"UDPListenerConfig,omitempty" xml:"UDPListenerConfig,omitempty" type:"Struct"`
	VServerGroupId      *string                                                                `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
}

func (s DescribeLoadBalancerListenersResponseBodyListeners) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerListenersResponseBodyListeners) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerListenersResponseBodyListeners) SetAclId(v string) *DescribeLoadBalancerListenersResponseBodyListeners {
	s.AclId = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListeners) SetAclStatus(v string) *DescribeLoadBalancerListenersResponseBodyListeners {
	s.AclStatus = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListeners) SetAclType(v string) *DescribeLoadBalancerListenersResponseBodyListeners {
	s.AclType = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListeners) SetBackendServerPort(v int32) *DescribeLoadBalancerListenersResponseBodyListeners {
	s.BackendServerPort = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListeners) SetBandwidth(v int32) *DescribeLoadBalancerListenersResponseBodyListeners {
	s.Bandwidth = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListeners) SetDescription(v string) *DescribeLoadBalancerListenersResponseBodyListeners {
	s.Description = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListeners) SetHTTPListenerConfig(v *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig) *DescribeLoadBalancerListenersResponseBodyListeners {
	s.HTTPListenerConfig = v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListeners) SetHTTPSListenerConfig(v *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) *DescribeLoadBalancerListenersResponseBodyListeners {
	s.HTTPSListenerConfig = v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListeners) SetListenerPort(v int32) *DescribeLoadBalancerListenersResponseBodyListeners {
	s.ListenerPort = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListeners) SetListenerProtocol(v string) *DescribeLoadBalancerListenersResponseBodyListeners {
	s.ListenerProtocol = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListeners) SetLoadBalancerId(v string) *DescribeLoadBalancerListenersResponseBodyListeners {
	s.LoadBalancerId = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListeners) SetScheduler(v string) *DescribeLoadBalancerListenersResponseBodyListeners {
	s.Scheduler = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListeners) SetStatus(v string) *DescribeLoadBalancerListenersResponseBodyListeners {
	s.Status = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListeners) SetTCPListenerConfig(v *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig) *DescribeLoadBalancerListenersResponseBodyListeners {
	s.TCPListenerConfig = v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListeners) SetTags(v []*DescribeLoadBalancerListenersResponseBodyListenersTags) *DescribeLoadBalancerListenersResponseBodyListeners {
	s.Tags = v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListeners) SetUDPListenerConfig(v *DescribeLoadBalancerListenersResponseBodyListenersUDPListenerConfig) *DescribeLoadBalancerListenersResponseBodyListeners {
	s.UDPListenerConfig = v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListeners) SetVServerGroupId(v string) *DescribeLoadBalancerListenersResponseBodyListeners {
	s.VServerGroupId = &v
	return s
}

type DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig struct {
	Cookie                      *string `json:"Cookie,omitempty" xml:"Cookie,omitempty"`
	CookieTimeout               *int32  `json:"CookieTimeout,omitempty" xml:"CookieTimeout,omitempty"`
	ForwardPort                 *int32  `json:"ForwardPort,omitempty" xml:"ForwardPort,omitempty"`
	Gzip                        *string `json:"Gzip,omitempty" xml:"Gzip,omitempty"`
	HealthCheck                 *string `json:"HealthCheck,omitempty" xml:"HealthCheck,omitempty"`
	HealthCheckConnectPort      *int32  `json:"HealthCheckConnectPort,omitempty" xml:"HealthCheckConnectPort,omitempty"`
	HealthCheckDomain           *string `json:"HealthCheckDomain,omitempty" xml:"HealthCheckDomain,omitempty"`
	HealthCheckHttpCode         *string `json:"HealthCheckHttpCode,omitempty" xml:"HealthCheckHttpCode,omitempty"`
	HealthCheckHttpVersion      *string `json:"HealthCheckHttpVersion,omitempty" xml:"HealthCheckHttpVersion,omitempty"`
	HealthCheckInterval         *int32  `json:"HealthCheckInterval,omitempty" xml:"HealthCheckInterval,omitempty"`
	HealthCheckMethod           *string `json:"HealthCheckMethod,omitempty" xml:"HealthCheckMethod,omitempty"`
	HealthCheckTimeout          *int32  `json:"HealthCheckTimeout,omitempty" xml:"HealthCheckTimeout,omitempty"`
	HealthCheckType             *string `json:"HealthCheckType,omitempty" xml:"HealthCheckType,omitempty"`
	HealthCheckURI              *string `json:"HealthCheckURI,omitempty" xml:"HealthCheckURI,omitempty"`
	HealthyThreshold            *int32  `json:"HealthyThreshold,omitempty" xml:"HealthyThreshold,omitempty"`
	IdleTimeout                 *int32  `json:"IdleTimeout,omitempty" xml:"IdleTimeout,omitempty"`
	ListenerForward             *string `json:"ListenerForward,omitempty" xml:"ListenerForward,omitempty"`
	RequestTimeout              *int32  `json:"RequestTimeout,omitempty" xml:"RequestTimeout,omitempty"`
	StickySession               *string `json:"StickySession,omitempty" xml:"StickySession,omitempty"`
	StickySessionType           *string `json:"StickySessionType,omitempty" xml:"StickySessionType,omitempty"`
	UnhealthyThreshold          *int32  `json:"UnhealthyThreshold,omitempty" xml:"UnhealthyThreshold,omitempty"`
	XForwardedFor               *string `json:"XForwardedFor,omitempty" xml:"XForwardedFor,omitempty"`
	XForwardedFor_ClientSrcPort *string `json:"XForwardedFor_ClientSrcPort,omitempty" xml:"XForwardedFor_ClientSrcPort,omitempty"`
	XForwardedFor_SLBID         *string `json:"XForwardedFor_SLBID,omitempty" xml:"XForwardedFor_SLBID,omitempty"`
	XForwardedFor_SLBIP         *string `json:"XForwardedFor_SLBIP,omitempty" xml:"XForwardedFor_SLBIP,omitempty"`
	XForwardedFor_SLBPORT       *string `json:"XForwardedFor_SLBPORT,omitempty" xml:"XForwardedFor_SLBPORT,omitempty"`
	XForwardedFor_proto         *string `json:"XForwardedFor_proto,omitempty" xml:"XForwardedFor_proto,omitempty"`
}

func (s DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig) SetCookie(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig {
	s.Cookie = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig) SetCookieTimeout(v int32) *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig {
	s.CookieTimeout = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig) SetForwardPort(v int32) *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig {
	s.ForwardPort = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig) SetGzip(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig {
	s.Gzip = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig) SetHealthCheck(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig {
	s.HealthCheck = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig) SetHealthCheckConnectPort(v int32) *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig {
	s.HealthCheckConnectPort = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig) SetHealthCheckDomain(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig {
	s.HealthCheckDomain = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig) SetHealthCheckHttpCode(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig {
	s.HealthCheckHttpCode = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig) SetHealthCheckHttpVersion(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig {
	s.HealthCheckHttpVersion = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig) SetHealthCheckInterval(v int32) *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig {
	s.HealthCheckInterval = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig) SetHealthCheckMethod(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig {
	s.HealthCheckMethod = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig) SetHealthCheckTimeout(v int32) *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig {
	s.HealthCheckTimeout = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig) SetHealthCheckType(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig {
	s.HealthCheckType = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig) SetHealthCheckURI(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig {
	s.HealthCheckURI = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig) SetHealthyThreshold(v int32) *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig {
	s.HealthyThreshold = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig) SetIdleTimeout(v int32) *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig {
	s.IdleTimeout = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig) SetListenerForward(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig {
	s.ListenerForward = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig) SetRequestTimeout(v int32) *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig {
	s.RequestTimeout = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig) SetStickySession(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig {
	s.StickySession = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig) SetStickySessionType(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig {
	s.StickySessionType = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig) SetUnhealthyThreshold(v int32) *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig {
	s.UnhealthyThreshold = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig) SetXForwardedFor(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig {
	s.XForwardedFor = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig) SetXForwardedFor_ClientSrcPort(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig {
	s.XForwardedFor_ClientSrcPort = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig) SetXForwardedFor_SLBID(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig {
	s.XForwardedFor_SLBID = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig) SetXForwardedFor_SLBIP(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig {
	s.XForwardedFor_SLBIP = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig) SetXForwardedFor_SLBPORT(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig {
	s.XForwardedFor_SLBPORT = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig) SetXForwardedFor_proto(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPListenerConfig {
	s.XForwardedFor_proto = &v
	return s
}

type DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig struct {
	CACertificateId                      *string `json:"CACertificateId,omitempty" xml:"CACertificateId,omitempty"`
	Cookie                               *string `json:"Cookie,omitempty" xml:"Cookie,omitempty"`
	CookieTimeout                        *int32  `json:"CookieTimeout,omitempty" xml:"CookieTimeout,omitempty"`
	EnableHttp2                          *string `json:"EnableHttp2,omitempty" xml:"EnableHttp2,omitempty"`
	Gzip                                 *string `json:"Gzip,omitempty" xml:"Gzip,omitempty"`
	HealthCheck                          *string `json:"HealthCheck,omitempty" xml:"HealthCheck,omitempty"`
	HealthCheckConnectPort               *int32  `json:"HealthCheckConnectPort,omitempty" xml:"HealthCheckConnectPort,omitempty"`
	HealthCheckDomain                    *string `json:"HealthCheckDomain,omitempty" xml:"HealthCheckDomain,omitempty"`
	HealthCheckHttpCode                  *string `json:"HealthCheckHttpCode,omitempty" xml:"HealthCheckHttpCode,omitempty"`
	HealthCheckHttpVersion               *string `json:"HealthCheckHttpVersion,omitempty" xml:"HealthCheckHttpVersion,omitempty"`
	HealthCheckInterval                  *int32  `json:"HealthCheckInterval,omitempty" xml:"HealthCheckInterval,omitempty"`
	HealthCheckMethod                    *string `json:"HealthCheckMethod,omitempty" xml:"HealthCheckMethod,omitempty"`
	HealthCheckTimeout                   *int32  `json:"HealthCheckTimeout,omitempty" xml:"HealthCheckTimeout,omitempty"`
	HealthCheckType                      *string `json:"HealthCheckType,omitempty" xml:"HealthCheckType,omitempty"`
	HealthCheckURI                       *string `json:"HealthCheckURI,omitempty" xml:"HealthCheckURI,omitempty"`
	HealthyThreshold                     *int32  `json:"HealthyThreshold,omitempty" xml:"HealthyThreshold,omitempty"`
	IdleTimeout                          *int32  `json:"IdleTimeout,omitempty" xml:"IdleTimeout,omitempty"`
	RequestTimeout                       *int32  `json:"RequestTimeout,omitempty" xml:"RequestTimeout,omitempty"`
	ServerCertificateId                  *string `json:"ServerCertificateId,omitempty" xml:"ServerCertificateId,omitempty"`
	StickySession                        *string `json:"StickySession,omitempty" xml:"StickySession,omitempty"`
	StickySessionType                    *string `json:"StickySessionType,omitempty" xml:"StickySessionType,omitempty"`
	TLSCipherPolicy                      *string `json:"TLSCipherPolicy,omitempty" xml:"TLSCipherPolicy,omitempty"`
	UnhealthyThreshold                   *int32  `json:"UnhealthyThreshold,omitempty" xml:"UnhealthyThreshold,omitempty"`
	XForwardedFor                        *string `json:"XForwardedFor,omitempty" xml:"XForwardedFor,omitempty"`
	XForwardedFor_ClientCertClientVerify *string `json:"XForwardedFor_ClientCertClientVerify,omitempty" xml:"XForwardedFor_ClientCertClientVerify,omitempty"`
	XForwardedFor_ClientCertFingerprint  *string `json:"XForwardedFor_ClientCertFingerprint,omitempty" xml:"XForwardedFor_ClientCertFingerprint,omitempty"`
	XForwardedFor_ClientCertIssuerDN     *string `json:"XForwardedFor_ClientCertIssuerDN,omitempty" xml:"XForwardedFor_ClientCertIssuerDN,omitempty"`
	XForwardedFor_ClientCertSubjectDN    *string `json:"XForwardedFor_ClientCertSubjectDN,omitempty" xml:"XForwardedFor_ClientCertSubjectDN,omitempty"`
	XForwardedFor_ClientSrcPort          *string `json:"XForwardedFor_ClientSrcPort,omitempty" xml:"XForwardedFor_ClientSrcPort,omitempty"`
	XForwardedFor_SLBID                  *string `json:"XForwardedFor_SLBID,omitempty" xml:"XForwardedFor_SLBID,omitempty"`
	XForwardedFor_SLBIP                  *string `json:"XForwardedFor_SLBIP,omitempty" xml:"XForwardedFor_SLBIP,omitempty"`
	XForwardedFor_SLBPORT                *string `json:"XForwardedFor_SLBPORT,omitempty" xml:"XForwardedFor_SLBPORT,omitempty"`
	XForwardedFor_proto                  *string `json:"XForwardedFor_proto,omitempty" xml:"XForwardedFor_proto,omitempty"`
}

func (s DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetCACertificateId(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.CACertificateId = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetCookie(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.Cookie = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetCookieTimeout(v int32) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.CookieTimeout = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetEnableHttp2(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.EnableHttp2 = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetGzip(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.Gzip = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetHealthCheck(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.HealthCheck = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetHealthCheckConnectPort(v int32) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.HealthCheckConnectPort = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetHealthCheckDomain(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.HealthCheckDomain = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetHealthCheckHttpCode(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.HealthCheckHttpCode = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetHealthCheckHttpVersion(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.HealthCheckHttpVersion = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetHealthCheckInterval(v int32) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.HealthCheckInterval = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetHealthCheckMethod(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.HealthCheckMethod = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetHealthCheckTimeout(v int32) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.HealthCheckTimeout = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetHealthCheckType(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.HealthCheckType = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetHealthCheckURI(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.HealthCheckURI = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetHealthyThreshold(v int32) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.HealthyThreshold = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetIdleTimeout(v int32) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.IdleTimeout = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetRequestTimeout(v int32) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.RequestTimeout = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetServerCertificateId(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.ServerCertificateId = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetStickySession(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.StickySession = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetStickySessionType(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.StickySessionType = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetTLSCipherPolicy(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.TLSCipherPolicy = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetUnhealthyThreshold(v int32) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.UnhealthyThreshold = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetXForwardedFor(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.XForwardedFor = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetXForwardedFor_ClientCertClientVerify(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.XForwardedFor_ClientCertClientVerify = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetXForwardedFor_ClientCertFingerprint(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.XForwardedFor_ClientCertFingerprint = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetXForwardedFor_ClientCertIssuerDN(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.XForwardedFor_ClientCertIssuerDN = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetXForwardedFor_ClientCertSubjectDN(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.XForwardedFor_ClientCertSubjectDN = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetXForwardedFor_ClientSrcPort(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.XForwardedFor_ClientSrcPort = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetXForwardedFor_SLBID(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.XForwardedFor_SLBID = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetXForwardedFor_SLBIP(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.XForwardedFor_SLBIP = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetXForwardedFor_SLBPORT(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.XForwardedFor_SLBPORT = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig) SetXForwardedFor_proto(v string) *DescribeLoadBalancerListenersResponseBodyListenersHTTPSListenerConfig {
	s.XForwardedFor_proto = &v
	return s
}

type DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig struct {
	ConnectionDrain           *string `json:"ConnectionDrain,omitempty" xml:"ConnectionDrain,omitempty"`
	ConnectionDrainTimeout    *int32  `json:"ConnectionDrainTimeout,omitempty" xml:"ConnectionDrainTimeout,omitempty"`
	EstablishedTimeout        *int32  `json:"EstablishedTimeout,omitempty" xml:"EstablishedTimeout,omitempty"`
	HealthCheck               *string `json:"HealthCheck,omitempty" xml:"HealthCheck,omitempty"`
	HealthCheckConnectPort    *int32  `json:"HealthCheckConnectPort,omitempty" xml:"HealthCheckConnectPort,omitempty"`
	HealthCheckConnectTimeout *int32  `json:"HealthCheckConnectTimeout,omitempty" xml:"HealthCheckConnectTimeout,omitempty"`
	HealthCheckDomain         *string `json:"HealthCheckDomain,omitempty" xml:"HealthCheckDomain,omitempty"`
	HealthCheckHttpCode       *string `json:"HealthCheckHttpCode,omitempty" xml:"HealthCheckHttpCode,omitempty"`
	HealthCheckInterval       *int32  `json:"HealthCheckInterval,omitempty" xml:"HealthCheckInterval,omitempty"`
	HealthCheckMethod         *string `json:"HealthCheckMethod,omitempty" xml:"HealthCheckMethod,omitempty"`
	HealthCheckType           *string `json:"HealthCheckType,omitempty" xml:"HealthCheckType,omitempty"`
	HealthCheckURI            *string `json:"HealthCheckURI,omitempty" xml:"HealthCheckURI,omitempty"`
	HealthyThreshold          *int32  `json:"HealthyThreshold,omitempty" xml:"HealthyThreshold,omitempty"`
	MasterSlaveServerGroupId  *string `json:"MasterSlaveServerGroupId,omitempty" xml:"MasterSlaveServerGroupId,omitempty"`
	PersistenceTimeout        *int32  `json:"PersistenceTimeout,omitempty" xml:"PersistenceTimeout,omitempty"`
	ProxyProtocolV2Enabled    *string `json:"ProxyProtocolV2Enabled,omitempty" xml:"ProxyProtocolV2Enabled,omitempty"`
	UnhealthyThreshold        *int32  `json:"UnhealthyThreshold,omitempty" xml:"UnhealthyThreshold,omitempty"`
}

func (s DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig) SetConnectionDrain(v string) *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig {
	s.ConnectionDrain = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig) SetConnectionDrainTimeout(v int32) *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig {
	s.ConnectionDrainTimeout = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig) SetEstablishedTimeout(v int32) *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig {
	s.EstablishedTimeout = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig) SetHealthCheck(v string) *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig {
	s.HealthCheck = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig) SetHealthCheckConnectPort(v int32) *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig {
	s.HealthCheckConnectPort = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig) SetHealthCheckConnectTimeout(v int32) *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig {
	s.HealthCheckConnectTimeout = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig) SetHealthCheckDomain(v string) *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig {
	s.HealthCheckDomain = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig) SetHealthCheckHttpCode(v string) *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig {
	s.HealthCheckHttpCode = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig) SetHealthCheckInterval(v int32) *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig {
	s.HealthCheckInterval = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig) SetHealthCheckMethod(v string) *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig {
	s.HealthCheckMethod = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig) SetHealthCheckType(v string) *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig {
	s.HealthCheckType = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig) SetHealthCheckURI(v string) *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig {
	s.HealthCheckURI = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig) SetHealthyThreshold(v int32) *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig {
	s.HealthyThreshold = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig) SetMasterSlaveServerGroupId(v string) *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig {
	s.MasterSlaveServerGroupId = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig) SetPersistenceTimeout(v int32) *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig {
	s.PersistenceTimeout = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig) SetProxyProtocolV2Enabled(v string) *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig {
	s.ProxyProtocolV2Enabled = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig) SetUnhealthyThreshold(v int32) *DescribeLoadBalancerListenersResponseBodyListenersTCPListenerConfig {
	s.UnhealthyThreshold = &v
	return s
}

type DescribeLoadBalancerListenersResponseBodyListenersTags struct {
	TagKey   *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s DescribeLoadBalancerListenersResponseBodyListenersTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerListenersResponseBodyListenersTags) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersTags) SetTagKey(v string) *DescribeLoadBalancerListenersResponseBodyListenersTags {
	s.TagKey = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersTags) SetTagValue(v string) *DescribeLoadBalancerListenersResponseBodyListenersTags {
	s.TagValue = &v
	return s
}

type DescribeLoadBalancerListenersResponseBodyListenersUDPListenerConfig struct {
	ConnectionDrain           *string `json:"ConnectionDrain,omitempty" xml:"ConnectionDrain,omitempty"`
	ConnectionDrainTimeout    *int32  `json:"ConnectionDrainTimeout,omitempty" xml:"ConnectionDrainTimeout,omitempty"`
	HealthCheck               *string `json:"HealthCheck,omitempty" xml:"HealthCheck,omitempty"`
	HealthCheckConnectPort    *int32  `json:"HealthCheckConnectPort,omitempty" xml:"HealthCheckConnectPort,omitempty"`
	HealthCheckConnectTimeout *int32  `json:"HealthCheckConnectTimeout,omitempty" xml:"HealthCheckConnectTimeout,omitempty"`
	HealthCheckExp            *string `json:"HealthCheckExp,omitempty" xml:"HealthCheckExp,omitempty"`
	HealthCheckInterval       *int32  `json:"HealthCheckInterval,omitempty" xml:"HealthCheckInterval,omitempty"`
	HealthCheckReq            *string `json:"HealthCheckReq,omitempty" xml:"HealthCheckReq,omitempty"`
	HealthyThreshold          *int32  `json:"HealthyThreshold,omitempty" xml:"HealthyThreshold,omitempty"`
	MasterSlaveServerGroupId  *string `json:"MasterSlaveServerGroupId,omitempty" xml:"MasterSlaveServerGroupId,omitempty"`
	ProxyProtocolV2Enabled    *string `json:"ProxyProtocolV2Enabled,omitempty" xml:"ProxyProtocolV2Enabled,omitempty"`
	UnhealthyThreshold        *int32  `json:"UnhealthyThreshold,omitempty" xml:"UnhealthyThreshold,omitempty"`
}

func (s DescribeLoadBalancerListenersResponseBodyListenersUDPListenerConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerListenersResponseBodyListenersUDPListenerConfig) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersUDPListenerConfig) SetConnectionDrain(v string) *DescribeLoadBalancerListenersResponseBodyListenersUDPListenerConfig {
	s.ConnectionDrain = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersUDPListenerConfig) SetConnectionDrainTimeout(v int32) *DescribeLoadBalancerListenersResponseBodyListenersUDPListenerConfig {
	s.ConnectionDrainTimeout = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersUDPListenerConfig) SetHealthCheck(v string) *DescribeLoadBalancerListenersResponseBodyListenersUDPListenerConfig {
	s.HealthCheck = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersUDPListenerConfig) SetHealthCheckConnectPort(v int32) *DescribeLoadBalancerListenersResponseBodyListenersUDPListenerConfig {
	s.HealthCheckConnectPort = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersUDPListenerConfig) SetHealthCheckConnectTimeout(v int32) *DescribeLoadBalancerListenersResponseBodyListenersUDPListenerConfig {
	s.HealthCheckConnectTimeout = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersUDPListenerConfig) SetHealthCheckExp(v string) *DescribeLoadBalancerListenersResponseBodyListenersUDPListenerConfig {
	s.HealthCheckExp = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersUDPListenerConfig) SetHealthCheckInterval(v int32) *DescribeLoadBalancerListenersResponseBodyListenersUDPListenerConfig {
	s.HealthCheckInterval = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersUDPListenerConfig) SetHealthCheckReq(v string) *DescribeLoadBalancerListenersResponseBodyListenersUDPListenerConfig {
	s.HealthCheckReq = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersUDPListenerConfig) SetHealthyThreshold(v int32) *DescribeLoadBalancerListenersResponseBodyListenersUDPListenerConfig {
	s.HealthyThreshold = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersUDPListenerConfig) SetMasterSlaveServerGroupId(v string) *DescribeLoadBalancerListenersResponseBodyListenersUDPListenerConfig {
	s.MasterSlaveServerGroupId = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersUDPListenerConfig) SetProxyProtocolV2Enabled(v string) *DescribeLoadBalancerListenersResponseBodyListenersUDPListenerConfig {
	s.ProxyProtocolV2Enabled = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponseBodyListenersUDPListenerConfig) SetUnhealthyThreshold(v int32) *DescribeLoadBalancerListenersResponseBodyListenersUDPListenerConfig {
	s.UnhealthyThreshold = &v
	return s
}

type DescribeLoadBalancerListenersResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeLoadBalancerListenersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeLoadBalancerListenersResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerListenersResponse) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerListenersResponse) SetHeaders(v map[string]*string) *DescribeLoadBalancerListenersResponse {
	s.Headers = v
	return s
}

func (s *DescribeLoadBalancerListenersResponse) SetStatusCode(v int32) *DescribeLoadBalancerListenersResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeLoadBalancerListenersResponse) SetBody(v *DescribeLoadBalancerListenersResponseBody) *DescribeLoadBalancerListenersResponse {
	s.Body = v
	return s
}

type DescribeLoadBalancerTCPListenerAttributeRequest struct {
	// The operation that you want to perform. Set the value to **DescribeLoadBalancerTCPListenerAttribute**.
	ListenerPort *int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	// The ID of the primary/secondary server group that is associated with the listener.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the CLB instance.
	//
	// You can query the region ID from the [Regions and zones](~~40654~~) list or by calling the [DescribeRegions](~~25609~~) operation.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeLoadBalancerTCPListenerAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerTCPListenerAttributeRequest) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerTCPListenerAttributeRequest) SetListenerPort(v int32) *DescribeLoadBalancerTCPListenerAttributeRequest {
	s.ListenerPort = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeRequest) SetLoadBalancerId(v string) *DescribeLoadBalancerTCPListenerAttributeRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeRequest) SetOwnerAccount(v string) *DescribeLoadBalancerTCPListenerAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeRequest) SetOwnerId(v int64) *DescribeLoadBalancerTCPListenerAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeRequest) SetRegionId(v string) *DescribeLoadBalancerTCPListenerAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeRequest) SetResourceOwnerAccount(v string) *DescribeLoadBalancerTCPListenerAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeRequest) SetResourceOwnerId(v int64) *DescribeLoadBalancerTCPListenerAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeLoadBalancerTCPListenerAttributeResponseBody struct {
	// The healthy threshold. The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. In this case, the health status is changed from **fail** to **success**. Valid values: **2** to **10**.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The ID of the associated server group.
	AclStatus *string `json:"AclStatus,omitempty" xml:"AclStatus,omitempty"`
	// Indicates whether the Proxy protocol is used to pass client IP addresses to backend servers. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	AclType *string `json:"AclType,omitempty" xml:"AclType,omitempty"`
	// Indicates whether connection draining is enabled. If **ConnectionDrain** is set to **on**, the parameter is returned. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	BackendServerPort *int32 `json:"BackendServerPort,omitempty" xml:"BackendServerPort,omitempty"`
	// The ID of the CLB instance.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// Queries the configurations of a TCP listener of Classic Load Balancer (CLB).
	ConnectionDrain *string `json:"ConnectionDrain,omitempty" xml:"ConnectionDrain,omitempty"`
	// The frontend port used by the CLB instance.
	ConnectionDrainTimeout *int32 `json:"ConnectionDrainTimeout,omitempty" xml:"ConnectionDrainTimeout,omitempty"`
	// Indicates whether access control is enabled. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether the health check feature is enabled. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	EstablishedTimeout *int32  `json:"EstablishedTimeout,omitempty" xml:"EstablishedTimeout,omitempty"`
	HealthCheck        *string `json:"HealthCheck,omitempty" xml:"HealthCheck,omitempty"`
	// The timeout period.
	HealthCheckConnectPort *int32 `json:"HealthCheckConnectPort,omitempty" xml:"HealthCheckConnectPort,omitempty"`
	// The backend port used by the CLB instance.
	//
	// >  If the listener is associated with a vServer group, this parameter is not returned.
	HealthCheckConnectTimeout *int32 `json:"HealthCheckConnectTimeout,omitempty" xml:"HealthCheckConnectTimeout,omitempty"`
	// The timeout period of connection draining. If **ConnectionDrain** is set to **on**, the parameter is returned.
	//
	// Valid values: 10 to 900. Unit: seconds.
	HealthCheckDomain *string `json:"HealthCheckDomain,omitempty" xml:"HealthCheckDomain,omitempty"`
	// The URL that is used for health checks. The URL must be 1 to 80 characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.), percent signs (%), question marks (?), number signs (#), and ampersands (&). The URL is not a single forward slash (/) but it starts with a forward slash (/).
	HealthCheckHttpCode *string `json:"HealthCheckHttpCode,omitempty" xml:"HealthCheckHttpCode,omitempty"`
	// The health check method that is used by the TCP listener.
	//
	// Valid values: **tcp** and **http**.
	HealthCheckInterval *int32  `json:"HealthCheckInterval,omitempty" xml:"HealthCheckInterval,omitempty"`
	HealthCheckMethod   *string `json:"HealthCheckMethod,omitempty" xml:"HealthCheckMethod,omitempty"`
	// Indicates whether the SynProxy feature of CLB is enabled for protection.
	//
	// We recommend that you use the default value of this parameter. Valid values:
	//
	// *   **enable**: yes
	// *   **disable**: no
	HealthCheckType *string `json:"HealthCheckType,omitempty" xml:"HealthCheckType,omitempty"`
	// The description of the listener.
	HealthCheckURI *string `json:"HealthCheckURI,omitempty" xml:"HealthCheckURI,omitempty"`
	// The status of the listener. Valid values:
	//
	// *   **running**
	// *   **stopped**
	HealthyThreshold *int32 `json:"HealthyThreshold,omitempty" xml:"HealthyThreshold,omitempty"`
	// The ID of the CLB instance.
	ListenerPort   *int32  `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// The frontend port used by the CLB instance.
	//
	// Valid values: **1** to **65535**.
	MasterSlaveServerGroupId *string `json:"MasterSlaveServerGroupId,omitempty" xml:"MasterSlaveServerGroupId,omitempty"`
	// The type of the ACL. Valid values:
	//
	// *   **white**: a whitelist. Only requests from the IP addresses or CIDR blocks in the network ACL are forwarded. Whitelists apply to scenarios in which you want to allow only specific IP addresses to access an application.
	//
	//     Your service may be adversely affected if the whitelist is not properly configured. After a whitelist is configured, only requests from IP addresses that are added to the whitelist are forwarded by the listener.
	//
	//     If you enable a whitelist but do not add an IP address to the ACL, the listener forwards all requests.
	//
	// *   **black**: a blacklist. All requests from the IP addresses or CIDR blocks in the network ACL are rejected. Blacklists apply to scenarios in which you want to block access from specified IP addresses to an application.
	//
	//     If a blacklist is configured for a listener but no IP address is added to the blacklist, the listener forwards all requests.
	//
	// >  If **AclStatus** is set to **on**, this parameter is returned.
	PersistenceTimeout *int32 `json:"PersistenceTimeout,omitempty" xml:"PersistenceTimeout,omitempty"`
	// The timeout period of session persistence.
	//
	// Valid values: **0** to **3600**. Unit: seconds. Default value: **0**. If the default value is used, the system disables session persistence.
	ProxyProtocolV2Enabled *bool `json:"ProxyProtocolV2Enabled,omitempty" xml:"ProxyProtocolV2Enabled,omitempty"`
	// The interval between two consecutive health checks. Valid values: **1** to **50**. Unit: seconds.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the request.
	Scheduler *string `json:"Scheduler,omitempty" xml:"Scheduler,omitempty"`
	// The maximum bandwidth of the listener. Unit: Mbit/s. Valid values:
	//
	// *   **-1**: For a pay-by-data-transfer Internet-facing CLB instance, this parameter is set to -1. This indicates that the bandwidth of the listener is unlimited.
	// *   **1** to **5120**: For a pay-by-bandwidth Internet-facing CLB instance, you can specify the maximum bandwidth of each listener. The sum of maximum bandwidth of all listeners cannot exceed the maximum bandwidth of the CLB instance.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The timeout period of a connection.
	SynProxy *string                                                   `json:"SynProxy,omitempty" xml:"SynProxy,omitempty"`
	Tags     *DescribeLoadBalancerTCPListenerAttributeResponseBodyTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The domain name that is used for health checks. Valid values:
	//
	// *   **$\_ip**: the private IP addresses of backend servers. If you do not set the HealthCheckDomain parameter or set the parameter to $\_ip, the CLB instance uses the private IP address of each backend server for health checks.
	// *   **domain**: The domain name is 1 to 80 characters in length, and can contain letters, digits, periods (.), and hyphens (-).
	UnhealthyThreshold *int32 `json:"UnhealthyThreshold,omitempty" xml:"UnhealthyThreshold,omitempty"`
	// The unhealthy threshold. The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. In this case, the health status is changed from **success** to **fail**. Valid values: **2** to **10**.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
}

func (s DescribeLoadBalancerTCPListenerAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerTCPListenerAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetAclId(v string) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.AclId = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetAclStatus(v string) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.AclStatus = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetAclType(v string) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.AclType = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetBackendServerPort(v int32) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.BackendServerPort = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetBandwidth(v int32) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.Bandwidth = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetConnectionDrain(v string) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.ConnectionDrain = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetConnectionDrainTimeout(v int32) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.ConnectionDrainTimeout = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetDescription(v string) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.Description = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetEstablishedTimeout(v int32) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.EstablishedTimeout = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetHealthCheck(v string) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.HealthCheck = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetHealthCheckConnectPort(v int32) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.HealthCheckConnectPort = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetHealthCheckConnectTimeout(v int32) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.HealthCheckConnectTimeout = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetHealthCheckDomain(v string) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.HealthCheckDomain = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetHealthCheckHttpCode(v string) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.HealthCheckHttpCode = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetHealthCheckInterval(v int32) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.HealthCheckInterval = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetHealthCheckMethod(v string) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.HealthCheckMethod = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetHealthCheckType(v string) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.HealthCheckType = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetHealthCheckURI(v string) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.HealthCheckURI = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetHealthyThreshold(v int32) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.HealthyThreshold = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetListenerPort(v int32) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.ListenerPort = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetLoadBalancerId(v string) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.LoadBalancerId = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetMasterSlaveServerGroupId(v string) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.MasterSlaveServerGroupId = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetPersistenceTimeout(v int32) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.PersistenceTimeout = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetProxyProtocolV2Enabled(v bool) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.ProxyProtocolV2Enabled = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetRequestId(v string) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetScheduler(v string) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.Scheduler = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetStatus(v string) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.Status = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetSynProxy(v string) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.SynProxy = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetTags(v *DescribeLoadBalancerTCPListenerAttributeResponseBodyTags) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.Tags = v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetUnhealthyThreshold(v int32) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.UnhealthyThreshold = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBody) SetVServerGroupId(v string) *DescribeLoadBalancerTCPListenerAttributeResponseBody {
	s.VServerGroupId = &v
	return s
}

type DescribeLoadBalancerTCPListenerAttributeResponseBodyTags struct {
	Tag []*DescribeLoadBalancerTCPListenerAttributeResponseBodyTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeLoadBalancerTCPListenerAttributeResponseBodyTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerTCPListenerAttributeResponseBodyTags) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBodyTags) SetTag(v []*DescribeLoadBalancerTCPListenerAttributeResponseBodyTagsTag) *DescribeLoadBalancerTCPListenerAttributeResponseBodyTags {
	s.Tag = v
	return s
}

type DescribeLoadBalancerTCPListenerAttributeResponseBodyTagsTag struct {
	TagKey   *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s DescribeLoadBalancerTCPListenerAttributeResponseBodyTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerTCPListenerAttributeResponseBodyTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBodyTagsTag) SetTagKey(v string) *DescribeLoadBalancerTCPListenerAttributeResponseBodyTagsTag {
	s.TagKey = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponseBodyTagsTag) SetTagValue(v string) *DescribeLoadBalancerTCPListenerAttributeResponseBodyTagsTag {
	s.TagValue = &v
	return s
}

type DescribeLoadBalancerTCPListenerAttributeResponse struct {
	Headers    map[string]*string                                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeLoadBalancerTCPListenerAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeLoadBalancerTCPListenerAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerTCPListenerAttributeResponse) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponse) SetHeaders(v map[string]*string) *DescribeLoadBalancerTCPListenerAttributeResponse {
	s.Headers = v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponse) SetStatusCode(v int32) *DescribeLoadBalancerTCPListenerAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeLoadBalancerTCPListenerAttributeResponse) SetBody(v *DescribeLoadBalancerTCPListenerAttributeResponseBody) *DescribeLoadBalancerTCPListenerAttributeResponse {
	s.Body = v
	return s
}

type DescribeLoadBalancerUDPListenerAttributeRequest struct {
	// The operation that you want to perform. Set the value to **DescribeLoadBalancerUDPListenerAttribute**.
	ListenerPort *int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	// The ID of the primary/secondary server group that is associated with the listener.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the Classic Load Balancer (CLB) instance is deployed.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeLoadBalancerUDPListenerAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerUDPListenerAttributeRequest) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerUDPListenerAttributeRequest) SetListenerPort(v int32) *DescribeLoadBalancerUDPListenerAttributeRequest {
	s.ListenerPort = &v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeRequest) SetLoadBalancerId(v string) *DescribeLoadBalancerUDPListenerAttributeRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeRequest) SetOwnerAccount(v string) *DescribeLoadBalancerUDPListenerAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeRequest) SetOwnerId(v int64) *DescribeLoadBalancerUDPListenerAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeRequest) SetRegionId(v string) *DescribeLoadBalancerUDPListenerAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeRequest) SetResourceOwnerAccount(v string) *DescribeLoadBalancerUDPListenerAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeRequest) SetResourceOwnerId(v int64) *DescribeLoadBalancerUDPListenerAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeLoadBalancerUDPListenerAttributeResponseBody struct {
	// The ID of the request.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The ID of the vServer group that is associated with the listener.
	AclStatus *string `json:"AclStatus,omitempty" xml:"AclStatus,omitempty"`
	// Indicates whether the Proxy protocol is used to pass client IP addresses to backend servers. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	AclType *string `json:"AclType,omitempty" xml:"AclType,omitempty"`
	// The frontend port used by the CLB instance.
	//
	// Valid values: **1** to **65535**.
	BackendServerPort *int32 `json:"BackendServerPort,omitempty" xml:"BackendServerPort,omitempty"`
	// Indicates whether access control is enabled. Valid values: **on** and **off**. Default value: off.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The timeout period of a health check. If a backend Elastic Compute Service (ECS) instance does not return a health check response within the specified timeout period, the server fails the health check. Valid values: **1** to **300**. Unit: seconds.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	HealthCheck *string `json:"HealthCheck,omitempty" xml:"HealthCheck,omitempty"`
	// The interval between two consecutive health checks. Valid values: **1** to **50**. Unit: seconds.
	HealthCheckConnectPort *int32 `json:"HealthCheckConnectPort,omitempty" xml:"HealthCheckConnectPort,omitempty"`
	// The backend port used by the CLB instance.
	//
	// >  If the listener is associated with a vServer group, this parameter is not returned.
	HealthCheckConnectTimeout *int32 `json:"HealthCheckConnectTimeout,omitempty" xml:"HealthCheckConnectTimeout,omitempty"`
	// The healthy threshold. The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. In this case, the health status is changed from **fail** to **success**. Valid values: **2** to **10**.
	HealthCheckExp *string `json:"HealthCheckExp,omitempty" xml:"HealthCheckExp,omitempty"`
	// The description of the listener.
	HealthCheckInterval *int32  `json:"HealthCheckInterval,omitempty" xml:"HealthCheckInterval,omitempty"`
	HealthCheckReq      *string `json:"HealthCheckReq,omitempty" xml:"HealthCheckReq,omitempty"`
	// The status of the listener. Valid values:
	//
	// *   **running**
	// *   **stopped**
	HealthyThreshold *int32 `json:"HealthyThreshold,omitempty" xml:"HealthyThreshold,omitempty"`
	// The ID of the CLB instance.
	ListenerPort   *int32  `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// The ID of the CLB instance.
	MasterSlaveServerGroupId *string `json:"MasterSlaveServerGroupId,omitempty" xml:"MasterSlaveServerGroupId,omitempty"`
	// The type of the ACL. Valid values:
	//
	// *   **white**: a whitelist. Only requests from the IP addresses or CIDR blocks in the network ACL are forwarded. Whitelists apply to scenarios in which you want to allow only specified IP addresses to access an application.
	//
	//     Your service may be adversely affected if the whitelist is not properly configured. After a whitelist is configured, only requests from IP addresses that are added to the whitelist are forwarded by the listener. If you enable a whitelist but do not add an IP address to the ACL, the listener forwards all requests.
	//
	// *   **black**: a blacklist. All requests from the IP addresses or CIDR blocks in the network ACL are blocked. Blacklists apply to scenarios in which you want to deny access from specific IP addresses or CIDR blocks to an application.
	//
	//     If a blacklist is configured for a listener but no IP address is added to the blacklist, the listener forwards all requests.
	ProxyProtocolV2Enabled *bool `json:"ProxyProtocolV2Enabled,omitempty" xml:"ProxyProtocolV2Enabled,omitempty"`
	// The frontend port used by the CLB instance.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the health check feature is enabled. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	Scheduler *string `json:"Scheduler,omitempty" xml:"Scheduler,omitempty"`
	// The maximum bandwidth of the listener. Unit: Mbit/s. Valid values:
	//
	// *   **-1**: For a pay-by-data-transfer Internet-facing CLB instance, this parameter is set to -1. This indicates that the bandwidth of the listener is unlimited.
	// *   **1** to **5120**: For a pay-by-bandwidth Internet-facing CLB instance, you can specify the maximum bandwidth of each listener. The sum of maximum bandwidth of all listeners cannot exceed the maximum bandwidth of the CLB instance.
	Status *string                                                   `json:"Status,omitempty" xml:"Status,omitempty"`
	Tags   *DescribeLoadBalancerUDPListenerAttributeResponseBodyTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The response string for UDP listener health checks. The string is up to 64 characters in length, and can contain letters and digits.
	UnhealthyThreshold *int32 `json:"UnhealthyThreshold,omitempty" xml:"UnhealthyThreshold,omitempty"`
	// The unhealthy threshold. The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. In this case, the health status is changed from **success** to **fail**. Valid values: **2** to **10**.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
}

func (s DescribeLoadBalancerUDPListenerAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerUDPListenerAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerUDPListenerAttributeResponseBody) SetAclId(v string) *DescribeLoadBalancerUDPListenerAttributeResponseBody {
	s.AclId = &v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeResponseBody) SetAclStatus(v string) *DescribeLoadBalancerUDPListenerAttributeResponseBody {
	s.AclStatus = &v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeResponseBody) SetAclType(v string) *DescribeLoadBalancerUDPListenerAttributeResponseBody {
	s.AclType = &v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeResponseBody) SetBackendServerPort(v int32) *DescribeLoadBalancerUDPListenerAttributeResponseBody {
	s.BackendServerPort = &v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeResponseBody) SetBandwidth(v int32) *DescribeLoadBalancerUDPListenerAttributeResponseBody {
	s.Bandwidth = &v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeResponseBody) SetDescription(v string) *DescribeLoadBalancerUDPListenerAttributeResponseBody {
	s.Description = &v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeResponseBody) SetHealthCheck(v string) *DescribeLoadBalancerUDPListenerAttributeResponseBody {
	s.HealthCheck = &v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeResponseBody) SetHealthCheckConnectPort(v int32) *DescribeLoadBalancerUDPListenerAttributeResponseBody {
	s.HealthCheckConnectPort = &v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeResponseBody) SetHealthCheckConnectTimeout(v int32) *DescribeLoadBalancerUDPListenerAttributeResponseBody {
	s.HealthCheckConnectTimeout = &v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeResponseBody) SetHealthCheckExp(v string) *DescribeLoadBalancerUDPListenerAttributeResponseBody {
	s.HealthCheckExp = &v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeResponseBody) SetHealthCheckInterval(v int32) *DescribeLoadBalancerUDPListenerAttributeResponseBody {
	s.HealthCheckInterval = &v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeResponseBody) SetHealthCheckReq(v string) *DescribeLoadBalancerUDPListenerAttributeResponseBody {
	s.HealthCheckReq = &v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeResponseBody) SetHealthyThreshold(v int32) *DescribeLoadBalancerUDPListenerAttributeResponseBody {
	s.HealthyThreshold = &v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeResponseBody) SetListenerPort(v int32) *DescribeLoadBalancerUDPListenerAttributeResponseBody {
	s.ListenerPort = &v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeResponseBody) SetLoadBalancerId(v string) *DescribeLoadBalancerUDPListenerAttributeResponseBody {
	s.LoadBalancerId = &v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeResponseBody) SetMasterSlaveServerGroupId(v string) *DescribeLoadBalancerUDPListenerAttributeResponseBody {
	s.MasterSlaveServerGroupId = &v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeResponseBody) SetProxyProtocolV2Enabled(v bool) *DescribeLoadBalancerUDPListenerAttributeResponseBody {
	s.ProxyProtocolV2Enabled = &v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeResponseBody) SetRequestId(v string) *DescribeLoadBalancerUDPListenerAttributeResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeResponseBody) SetScheduler(v string) *DescribeLoadBalancerUDPListenerAttributeResponseBody {
	s.Scheduler = &v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeResponseBody) SetStatus(v string) *DescribeLoadBalancerUDPListenerAttributeResponseBody {
	s.Status = &v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeResponseBody) SetTags(v *DescribeLoadBalancerUDPListenerAttributeResponseBodyTags) *DescribeLoadBalancerUDPListenerAttributeResponseBody {
	s.Tags = v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeResponseBody) SetUnhealthyThreshold(v int32) *DescribeLoadBalancerUDPListenerAttributeResponseBody {
	s.UnhealthyThreshold = &v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeResponseBody) SetVServerGroupId(v string) *DescribeLoadBalancerUDPListenerAttributeResponseBody {
	s.VServerGroupId = &v
	return s
}

type DescribeLoadBalancerUDPListenerAttributeResponseBodyTags struct {
	Tag []*DescribeLoadBalancerUDPListenerAttributeResponseBodyTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeLoadBalancerUDPListenerAttributeResponseBodyTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerUDPListenerAttributeResponseBodyTags) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerUDPListenerAttributeResponseBodyTags) SetTag(v []*DescribeLoadBalancerUDPListenerAttributeResponseBodyTagsTag) *DescribeLoadBalancerUDPListenerAttributeResponseBodyTags {
	s.Tag = v
	return s
}

type DescribeLoadBalancerUDPListenerAttributeResponseBodyTagsTag struct {
	TagKey   *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s DescribeLoadBalancerUDPListenerAttributeResponseBodyTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerUDPListenerAttributeResponseBodyTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerUDPListenerAttributeResponseBodyTagsTag) SetTagKey(v string) *DescribeLoadBalancerUDPListenerAttributeResponseBodyTagsTag {
	s.TagKey = &v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeResponseBodyTagsTag) SetTagValue(v string) *DescribeLoadBalancerUDPListenerAttributeResponseBodyTagsTag {
	s.TagValue = &v
	return s
}

type DescribeLoadBalancerUDPListenerAttributeResponse struct {
	Headers    map[string]*string                                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeLoadBalancerUDPListenerAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeLoadBalancerUDPListenerAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancerUDPListenerAttributeResponse) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancerUDPListenerAttributeResponse) SetHeaders(v map[string]*string) *DescribeLoadBalancerUDPListenerAttributeResponse {
	s.Headers = v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeResponse) SetStatusCode(v int32) *DescribeLoadBalancerUDPListenerAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeLoadBalancerUDPListenerAttributeResponse) SetBody(v *DescribeLoadBalancerUDPListenerAttributeResponseBody) *DescribeLoadBalancerUDPListenerAttributeResponse {
	s.Body = v
	return s
}

type DescribeLoadBalancersRequest struct {
	// The IP address that the CLB instance uses to provide services.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// The IP version that is used by the CLB instance. Valid values: **ipv4** and **ipv6**.
	AddressIPVersion *string `json:"AddressIPVersion,omitempty" xml:"AddressIPVersion,omitempty"`
	// The network type of the CLB instance. Valid values:
	//
	// *   **internet:** After an Internet-facing CLB instance is created, the system assigns a public IP address to the CLB instance. Then, the CLB instance can forward requests over the Internet.
	// *   **intranet:** After an internal-facing CLB instance is created, the system assigns a private IP address to the CLB instance. Then, the CLB instance can forward requests only over internal networks.
	AddressType *string `json:"AddressType,omitempty" xml:"AddressType,omitempty"`
	// The metering method of Internet data transfer. Valid values:
	//
	// *   **paybybandwidth:** pay-by-bandwidth.
	// *   **paybytraffic:** pay-by-data-transfer.
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The ID of the CLB instance.
	//
	// You can specify up to 10 IDs. Separate multiple IDs with commas (,).
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// The name of the CLB instance.
	//
	// The name must be 1 to 80 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). The name must start with a letter.
	//
	// You can specify up to 10 names. Separate multiple names with commas (,).
	LoadBalancerName *string `json:"LoadBalancerName,omitempty" xml:"LoadBalancerName,omitempty"`
	// The status of the CLB instance. Valid values:
	//
	// *   **inactive:** The CLB instance is disabled. CLB instances in the inactive state do not forward traffic.
	// *   **active:** The CLB instance runs as expected. By default, newly created CLB instances are in the **active** state.
	// *   **locked:** The CLB instance is locked. After a CLB instance expires, it is locked for seven days. A locked CLB instance cannot forward traffic and you cannot perform operations on the locked CLB instance. However, other settings such as the IP address are retained.
	LoadBalancerStatus *string `json:"LoadBalancerStatus,omitempty" xml:"LoadBalancerStatus,omitempty"`
	// The ID of the primary zone to which the CLB instance belongs.
	MasterZoneId *string `json:"MasterZoneId,omitempty" xml:"MasterZoneId,omitempty"`
	// The network type of the internal-facing CLB instance. Valid values:
	//
	// *   **vpc:** VPC.
	// *   **classic:** classic network.
	NetworkType  *string `json:"NetworkType,omitempty" xml:"NetworkType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The page number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	//
	// Valid values: **1** to **100**.
	//
	// >  If you specify the **PageSize** parameter, you must also specify the **PageNumber** parameter.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The billing method of the CLB instance. Valid values:
	//
	// *   Set the value to **PayOnDemand**.
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The ID of the region where the CLB instance is deployed.
	//
	// You can call the [DescribeRegions](~~27584~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the backend server that is added to the CLB instance.
	ServerId *string `json:"ServerId,omitempty" xml:"ServerId,omitempty"`
	// The private IP address of the backend server that is added to the CLB instance.
	//
	// You can specify multiple IP addresses. Separate multiple IP addresses with commas (,).
	ServerIntranetAddress *string `json:"ServerIntranetAddress,omitempty" xml:"ServerIntranetAddress,omitempty"`
	// The ID of the secondary zone to which the CLB instance belongs.
	//
	// CLB instances on Alibaba Finance Cloud do not support cross-zone deployment.
	SlaveZoneId *string `json:"SlaveZoneId,omitempty" xml:"SlaveZoneId,omitempty"`
	// The tags that are added to the CLB instance. The tags must be key-value pairs that are contained in a JSON dictionary.
	//
	// You can specify up to 10 tags in each call.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The ID of the vSwitch to which the CLB instance belongs.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The ID of the virtual private cloud (VPC) to which the CLB instance belongs.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DescribeLoadBalancersRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancersRequest) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancersRequest) SetAddress(v string) *DescribeLoadBalancersRequest {
	s.Address = &v
	return s
}

func (s *DescribeLoadBalancersRequest) SetAddressIPVersion(v string) *DescribeLoadBalancersRequest {
	s.AddressIPVersion = &v
	return s
}

func (s *DescribeLoadBalancersRequest) SetAddressType(v string) *DescribeLoadBalancersRequest {
	s.AddressType = &v
	return s
}

func (s *DescribeLoadBalancersRequest) SetInternetChargeType(v string) *DescribeLoadBalancersRequest {
	s.InternetChargeType = &v
	return s
}

func (s *DescribeLoadBalancersRequest) SetLoadBalancerId(v string) *DescribeLoadBalancersRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *DescribeLoadBalancersRequest) SetLoadBalancerName(v string) *DescribeLoadBalancersRequest {
	s.LoadBalancerName = &v
	return s
}

func (s *DescribeLoadBalancersRequest) SetLoadBalancerStatus(v string) *DescribeLoadBalancersRequest {
	s.LoadBalancerStatus = &v
	return s
}

func (s *DescribeLoadBalancersRequest) SetMasterZoneId(v string) *DescribeLoadBalancersRequest {
	s.MasterZoneId = &v
	return s
}

func (s *DescribeLoadBalancersRequest) SetNetworkType(v string) *DescribeLoadBalancersRequest {
	s.NetworkType = &v
	return s
}

func (s *DescribeLoadBalancersRequest) SetOwnerAccount(v string) *DescribeLoadBalancersRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeLoadBalancersRequest) SetOwnerId(v int64) *DescribeLoadBalancersRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeLoadBalancersRequest) SetPageNumber(v int32) *DescribeLoadBalancersRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeLoadBalancersRequest) SetPageSize(v int32) *DescribeLoadBalancersRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeLoadBalancersRequest) SetPayType(v string) *DescribeLoadBalancersRequest {
	s.PayType = &v
	return s
}

func (s *DescribeLoadBalancersRequest) SetRegionId(v string) *DescribeLoadBalancersRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeLoadBalancersRequest) SetResourceGroupId(v string) *DescribeLoadBalancersRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeLoadBalancersRequest) SetResourceOwnerAccount(v string) *DescribeLoadBalancersRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeLoadBalancersRequest) SetResourceOwnerId(v int64) *DescribeLoadBalancersRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeLoadBalancersRequest) SetServerId(v string) *DescribeLoadBalancersRequest {
	s.ServerId = &v
	return s
}

func (s *DescribeLoadBalancersRequest) SetServerIntranetAddress(v string) *DescribeLoadBalancersRequest {
	s.ServerIntranetAddress = &v
	return s
}

func (s *DescribeLoadBalancersRequest) SetSlaveZoneId(v string) *DescribeLoadBalancersRequest {
	s.SlaveZoneId = &v
	return s
}

func (s *DescribeLoadBalancersRequest) SetTags(v string) *DescribeLoadBalancersRequest {
	s.Tags = &v
	return s
}

func (s *DescribeLoadBalancersRequest) SetVSwitchId(v string) *DescribeLoadBalancersRequest {
	s.VSwitchId = &v
	return s
}

func (s *DescribeLoadBalancersRequest) SetVpcId(v string) *DescribeLoadBalancersRequest {
	s.VpcId = &v
	return s
}

type DescribeLoadBalancersResponseBody struct {
	// An array of CLB instances.
	LoadBalancers *DescribeLoadBalancersResponseBodyLoadBalancers `json:"LoadBalancers,omitempty" xml:"LoadBalancers,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned on the current page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of instances returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeLoadBalancersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancersResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancersResponseBody) SetLoadBalancers(v *DescribeLoadBalancersResponseBodyLoadBalancers) *DescribeLoadBalancersResponseBody {
	s.LoadBalancers = v
	return s
}

func (s *DescribeLoadBalancersResponseBody) SetPageNumber(v int32) *DescribeLoadBalancersResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeLoadBalancersResponseBody) SetPageSize(v int32) *DescribeLoadBalancersResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeLoadBalancersResponseBody) SetRequestId(v string) *DescribeLoadBalancersResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeLoadBalancersResponseBody) SetTotalCount(v int32) *DescribeLoadBalancersResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeLoadBalancersResponseBodyLoadBalancers struct {
	LoadBalancer []*DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer `json:"LoadBalancer,omitempty" xml:"LoadBalancer,omitempty" type:"Repeated"`
}

func (s DescribeLoadBalancersResponseBodyLoadBalancers) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancersResponseBodyLoadBalancers) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancersResponseBodyLoadBalancers) SetLoadBalancer(v []*DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer) *DescribeLoadBalancersResponseBodyLoadBalancers {
	s.LoadBalancer = v
	return s
}

type DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer struct {
	// The endpoint of the CLB instance.
	Address *string `json:"Address,omitempty" xml:"Address,omitempty"`
	// The IP version that is used by the CLB instance. Valid values: **ipv4** and **ipv6**.
	AddressIPVersion *string `json:"AddressIPVersion,omitempty" xml:"AddressIPVersion,omitempty"`
	// The network type of the CLB instance. Valid values:
	//
	// *   **internet:** After an Internet-facing CLB instance is created, the system assigns a public IP address to the CLB instance. Then, the CLB instance can forward requests over the Internet.
	// *   **intranet:** After an internal-facing CLB instance is created, the system assigns a private IP address to the CLB instance. Then, the CLB instance can forward requests only over internal networks.
	AddressType *string `json:"AddressType,omitempty" xml:"AddressType,omitempty"`
	// The maximum bandwidth of the listener. Unit: Mbit/s. Valid values:
	//
	// *   **-1:** For a pay-by-data-transfer Internet-facing CLB instance, this value is set to -1. This indicates that the bandwidth is unlimited.
	// *   **1 to 5120:** For a pay-by-bandwidth Internet-facing CLB instance, you can specify the maximum bandwidth for each listener. The sum of the maximum bandwidth of all listeners cannot exceed the maximum bandwidth of the CLB instance.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The time when the CLB instance was created. The time follows the `YYYY-MM-DDThh:mm:ssZ` format.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The timestamp when the instance was created.
	CreateTimeStamp *int64 `json:"CreateTimeStamp,omitempty" xml:"CreateTimeStamp,omitempty"`
	// Indicates whether deletion protection is enabled for the CLB instance. Valid values:
	//
	// *   **on:** Deletion protection is enabled.
	// *   **off:** Deletion protection is disabled.
	DeleteProtection *string `json:"DeleteProtection,omitempty" xml:"DeleteProtection,omitempty"`
	// The metering method of the CLB instance. Valid values:
	//
	// *   **PayBySpec:** pay-by-specification.
	// *   **PayByCLCU:** pay-by-LCU.
	//
	// >  This parameter takes effect only for accounts registered on the China site (aliyun.com) and when the **PayType** parameter is set to **PayOnDemand**.
	InstanceChargeType *string `json:"InstanceChargeType,omitempty" xml:"InstanceChargeType,omitempty"`
	// The metering method of the Internet-facing CLB instance. Valid values:
	//
	// *   **3:** pay-by-bandwidth (**paybybandwidth**).
	// *   **4:** pay-by-data-transfer (**paybytraffic**).
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The metering method of Internet data transfer. Valid values:
	//
	// *   **paybybandwidth:** pay-by-bandwidth.
	// *   **paybytraffic:** pay-by-data-transfer.
	InternetChargeTypeAlias *string `json:"InternetChargeTypeAlias,omitempty" xml:"InternetChargeTypeAlias,omitempty"`
	// The ID of the CLB instance.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// The name of the CLB instance.
	LoadBalancerName *string `json:"LoadBalancerName,omitempty" xml:"LoadBalancerName,omitempty"`
	// The specification of the CLB instance.
	LoadBalancerSpec *string `json:"LoadBalancerSpec,omitempty" xml:"LoadBalancerSpec,omitempty"`
	// The status of the CLB instance. Valid values:
	//
	// *   **inactive:** The CLB instance is disabled. CLB instances in the inactive state do not forward traffic.
	// *   **active:** The CLB instance runs as expected. By default, newly created CLB instances are in the **active** state.
	// *   **locked:** The CLB instance is locked.
	LoadBalancerStatus *string `json:"LoadBalancerStatus,omitempty" xml:"LoadBalancerStatus,omitempty"`
	// The ID of the primary zone to which the CLB instance belongs.
	MasterZoneId *string `json:"MasterZoneId,omitempty" xml:"MasterZoneId,omitempty"`
	// The reason why the configuration read-only mode was enabled. The reason must be 1 to 80 characters in length, and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). The reason must start with a letter.
	//
	// > This parameter takes effect only when you set the `ModificationProtectionStatus` parameter to **ConsoleProtection**.
	ModificationProtectionReason *string `json:"ModificationProtectionReason,omitempty" xml:"ModificationProtectionReason,omitempty"`
	// Indicates whether the configuration read-only mode is enabled for the CLB instance. Valid values:
	//
	// *   **NonProtection:** The configuration read-only mode is disabled. In this case, you cannot specify the ModificationProtectionReason parameter. If you specify the `ModificationProtectionReason` parameter, the value is cleared.
	// *   **ConsoleProtection:** The configuration read-only mode is enabled.
	//
	// >  If you set this parameter to **ConsoleProtection**, you cannot modify the configurations of the CLB instance in the CLB console. However, you can call API operations to modify the configurations of the CLB instance.
	ModificationProtectionStatus *string `json:"ModificationProtectionStatus,omitempty" xml:"ModificationProtectionStatus,omitempty"`
	// The network type of the internal-facing CLB instance. Valid values:
	//
	// *   **vpc:** VPC.
	// *   **classic:** classic network.
	NetworkType *string `json:"NetworkType,omitempty" xml:"NetworkType,omitempty"`
	// The billing method of the CLB instance.
	//
	// *   **PayOnDemand** is returned, which indicates the pay-as-you-go billing method.
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The ID of the region where the CLB instance was deployed.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The region where the CLB instance was deployed.
	RegionIdAlias *string `json:"RegionIdAlias,omitempty" xml:"RegionIdAlias,omitempty"`
	// The ID of the resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The ID of the secondary zone to which the CLB instance belongs.
	SlaveZoneId *string `json:"SlaveZoneId,omitempty" xml:"SlaveZoneId,omitempty"`
	// The tags of the CLB instance.
	Tags *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancerTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The ID of the vSwitch to which the internal-facing CLB instance belongs.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The ID of the VPC in which the internal-facing CLB instance was deployed.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer) SetAddress(v string) *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer {
	s.Address = &v
	return s
}

func (s *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer) SetAddressIPVersion(v string) *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer {
	s.AddressIPVersion = &v
	return s
}

func (s *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer) SetAddressType(v string) *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer {
	s.AddressType = &v
	return s
}

func (s *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer) SetBandwidth(v int32) *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer {
	s.Bandwidth = &v
	return s
}

func (s *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer) SetCreateTime(v string) *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer {
	s.CreateTime = &v
	return s
}

func (s *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer) SetCreateTimeStamp(v int64) *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer {
	s.CreateTimeStamp = &v
	return s
}

func (s *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer) SetDeleteProtection(v string) *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer {
	s.DeleteProtection = &v
	return s
}

func (s *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer) SetInstanceChargeType(v string) *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer {
	s.InstanceChargeType = &v
	return s
}

func (s *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer) SetInternetChargeType(v string) *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer {
	s.InternetChargeType = &v
	return s
}

func (s *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer) SetInternetChargeTypeAlias(v string) *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer {
	s.InternetChargeTypeAlias = &v
	return s
}

func (s *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer) SetLoadBalancerId(v string) *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer {
	s.LoadBalancerId = &v
	return s
}

func (s *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer) SetLoadBalancerName(v string) *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer {
	s.LoadBalancerName = &v
	return s
}

func (s *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer) SetLoadBalancerSpec(v string) *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer {
	s.LoadBalancerSpec = &v
	return s
}

func (s *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer) SetLoadBalancerStatus(v string) *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer {
	s.LoadBalancerStatus = &v
	return s
}

func (s *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer) SetMasterZoneId(v string) *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer {
	s.MasterZoneId = &v
	return s
}

func (s *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer) SetModificationProtectionReason(v string) *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer {
	s.ModificationProtectionReason = &v
	return s
}

func (s *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer) SetModificationProtectionStatus(v string) *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer {
	s.ModificationProtectionStatus = &v
	return s
}

func (s *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer) SetNetworkType(v string) *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer {
	s.NetworkType = &v
	return s
}

func (s *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer) SetPayType(v string) *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer {
	s.PayType = &v
	return s
}

func (s *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer) SetRegionId(v string) *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer {
	s.RegionId = &v
	return s
}

func (s *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer) SetRegionIdAlias(v string) *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer {
	s.RegionIdAlias = &v
	return s
}

func (s *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer) SetResourceGroupId(v string) *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer) SetSlaveZoneId(v string) *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer {
	s.SlaveZoneId = &v
	return s
}

func (s *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer) SetTags(v *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancerTags) *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer {
	s.Tags = v
	return s
}

func (s *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer) SetVSwitchId(v string) *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer {
	s.VSwitchId = &v
	return s
}

func (s *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer) SetVpcId(v string) *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancer {
	s.VpcId = &v
	return s
}

type DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancerTags struct {
	Tag []*DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancerTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancerTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancerTags) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancerTags) SetTag(v []*DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancerTagsTag) *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancerTags {
	s.Tag = v
	return s
}

type DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancerTagsTag struct {
	// The key of the tag.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The value of the tag.
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancerTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancerTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancerTagsTag) SetTagKey(v string) *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancerTagsTag {
	s.TagKey = &v
	return s
}

func (s *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancerTagsTag) SetTagValue(v string) *DescribeLoadBalancersResponseBodyLoadBalancersLoadBalancerTagsTag {
	s.TagValue = &v
	return s
}

type DescribeLoadBalancersResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeLoadBalancersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeLoadBalancersResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeLoadBalancersResponse) GoString() string {
	return s.String()
}

func (s *DescribeLoadBalancersResponse) SetHeaders(v map[string]*string) *DescribeLoadBalancersResponse {
	s.Headers = v
	return s
}

func (s *DescribeLoadBalancersResponse) SetStatusCode(v int32) *DescribeLoadBalancersResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeLoadBalancersResponse) SetBody(v *DescribeLoadBalancersResponseBody) *DescribeLoadBalancersResponse {
	s.Body = v
	return s
}

type DescribeMasterSlaveServerGroupAttributeRequest struct {
	// The operation that you want to perform. Set the value to **DescribeMasterSlaveServerGroupAttribute**.
	MasterSlaveServerGroupId *string `json:"MasterSlaveServerGroupId,omitempty" xml:"MasterSlaveServerGroupId,omitempty"`
	OwnerAccount             *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                  *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The list of backend servers in the primary/secondary server group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeMasterSlaveServerGroupAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeMasterSlaveServerGroupAttributeRequest) GoString() string {
	return s.String()
}

func (s *DescribeMasterSlaveServerGroupAttributeRequest) SetMasterSlaveServerGroupId(v string) *DescribeMasterSlaveServerGroupAttributeRequest {
	s.MasterSlaveServerGroupId = &v
	return s
}

func (s *DescribeMasterSlaveServerGroupAttributeRequest) SetOwnerAccount(v string) *DescribeMasterSlaveServerGroupAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeMasterSlaveServerGroupAttributeRequest) SetOwnerId(v int64) *DescribeMasterSlaveServerGroupAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeMasterSlaveServerGroupAttributeRequest) SetRegionId(v string) *DescribeMasterSlaveServerGroupAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeMasterSlaveServerGroupAttributeRequest) SetResourceOwnerAccount(v string) *DescribeMasterSlaveServerGroupAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeMasterSlaveServerGroupAttributeRequest) SetResourceOwnerId(v int64) *DescribeMasterSlaveServerGroupAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeMasterSlaveServerGroupAttributeResponseBody struct {
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The region ID of the Classic Load Balancer (CLB) instance.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// The ID of the associated CLB instance.
	MasterSlaveBackendServers *DescribeMasterSlaveServerGroupAttributeResponseBodyMasterSlaveBackendServers `json:"MasterSlaveBackendServers,omitempty" xml:"MasterSlaveBackendServers,omitempty" type:"Struct"`
	// The type of the backend server. Valid values:
	//
	// *   **ecs** (default): an Elastic Compute Service (ECS) instance
	// *   **eni**: an elastic network interface (ENI)
	MasterSlaveServerGroupId *string `json:"MasterSlaveServerGroupId,omitempty" xml:"MasterSlaveServerGroupId,omitempty"`
	// The name of the primary/secondary server group.
	MasterSlaveServerGroupName *string `json:"MasterSlaveServerGroupName,omitempty" xml:"MasterSlaveServerGroupName,omitempty"`
	// The ID of the primary/secondary server group.
	RequestId *string                                                  `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Tags      *DescribeMasterSlaveServerGroupAttributeResponseBodyTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
}

func (s DescribeMasterSlaveServerGroupAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeMasterSlaveServerGroupAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeMasterSlaveServerGroupAttributeResponseBody) SetCreateTime(v string) *DescribeMasterSlaveServerGroupAttributeResponseBody {
	s.CreateTime = &v
	return s
}

func (s *DescribeMasterSlaveServerGroupAttributeResponseBody) SetLoadBalancerId(v string) *DescribeMasterSlaveServerGroupAttributeResponseBody {
	s.LoadBalancerId = &v
	return s
}

func (s *DescribeMasterSlaveServerGroupAttributeResponseBody) SetMasterSlaveBackendServers(v *DescribeMasterSlaveServerGroupAttributeResponseBodyMasterSlaveBackendServers) *DescribeMasterSlaveServerGroupAttributeResponseBody {
	s.MasterSlaveBackendServers = v
	return s
}

func (s *DescribeMasterSlaveServerGroupAttributeResponseBody) SetMasterSlaveServerGroupId(v string) *DescribeMasterSlaveServerGroupAttributeResponseBody {
	s.MasterSlaveServerGroupId = &v
	return s
}

func (s *DescribeMasterSlaveServerGroupAttributeResponseBody) SetMasterSlaveServerGroupName(v string) *DescribeMasterSlaveServerGroupAttributeResponseBody {
	s.MasterSlaveServerGroupName = &v
	return s
}

func (s *DescribeMasterSlaveServerGroupAttributeResponseBody) SetRequestId(v string) *DescribeMasterSlaveServerGroupAttributeResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeMasterSlaveServerGroupAttributeResponseBody) SetTags(v *DescribeMasterSlaveServerGroupAttributeResponseBodyTags) *DescribeMasterSlaveServerGroupAttributeResponseBody {
	s.Tags = v
	return s
}

type DescribeMasterSlaveServerGroupAttributeResponseBodyMasterSlaveBackendServers struct {
	MasterSlaveBackendServer []*DescribeMasterSlaveServerGroupAttributeResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer `json:"MasterSlaveBackendServer,omitempty" xml:"MasterSlaveBackendServer,omitempty" type:"Repeated"`
}

func (s DescribeMasterSlaveServerGroupAttributeResponseBodyMasterSlaveBackendServers) String() string {
	return tea.Prettify(s)
}

func (s DescribeMasterSlaveServerGroupAttributeResponseBodyMasterSlaveBackendServers) GoString() string {
	return s.String()
}

func (s *DescribeMasterSlaveServerGroupAttributeResponseBodyMasterSlaveBackendServers) SetMasterSlaveBackendServer(v []*DescribeMasterSlaveServerGroupAttributeResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer) *DescribeMasterSlaveServerGroupAttributeResponseBodyMasterSlaveBackendServers {
	s.MasterSlaveBackendServer = v
	return s
}

type DescribeMasterSlaveServerGroupAttributeResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer struct {
	// The ID of the request.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	Port        *int32  `json:"Port,omitempty" xml:"Port,omitempty"`
	ServerId    *string `json:"ServerId,omitempty" xml:"ServerId,omitempty"`
	ServerType  *string `json:"ServerType,omitempty" xml:"ServerType,omitempty"`
	// The weight of the backend server.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The type of backend server. Valid values: **Master and Slave. Default value: Master.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeMasterSlaveServerGroupAttributeResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer) String() string {
	return tea.Prettify(s)
}

func (s DescribeMasterSlaveServerGroupAttributeResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer) GoString() string {
	return s.String()
}

func (s *DescribeMasterSlaveServerGroupAttributeResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer) SetDescription(v string) *DescribeMasterSlaveServerGroupAttributeResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer {
	s.Description = &v
	return s
}

func (s *DescribeMasterSlaveServerGroupAttributeResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer) SetPort(v int32) *DescribeMasterSlaveServerGroupAttributeResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer {
	s.Port = &v
	return s
}

func (s *DescribeMasterSlaveServerGroupAttributeResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer) SetServerId(v string) *DescribeMasterSlaveServerGroupAttributeResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer {
	s.ServerId = &v
	return s
}

func (s *DescribeMasterSlaveServerGroupAttributeResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer) SetServerType(v string) *DescribeMasterSlaveServerGroupAttributeResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer {
	s.ServerType = &v
	return s
}

func (s *DescribeMasterSlaveServerGroupAttributeResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer) SetType(v string) *DescribeMasterSlaveServerGroupAttributeResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer {
	s.Type = &v
	return s
}

func (s *DescribeMasterSlaveServerGroupAttributeResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer) SetWeight(v int32) *DescribeMasterSlaveServerGroupAttributeResponseBodyMasterSlaveBackendServersMasterSlaveBackendServer {
	s.Weight = &v
	return s
}

type DescribeMasterSlaveServerGroupAttributeResponseBodyTags struct {
	Tag []*DescribeMasterSlaveServerGroupAttributeResponseBodyTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeMasterSlaveServerGroupAttributeResponseBodyTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeMasterSlaveServerGroupAttributeResponseBodyTags) GoString() string {
	return s.String()
}

func (s *DescribeMasterSlaveServerGroupAttributeResponseBodyTags) SetTag(v []*DescribeMasterSlaveServerGroupAttributeResponseBodyTagsTag) *DescribeMasterSlaveServerGroupAttributeResponseBodyTags {
	s.Tag = v
	return s
}

type DescribeMasterSlaveServerGroupAttributeResponseBodyTagsTag struct {
	TagKey   *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s DescribeMasterSlaveServerGroupAttributeResponseBodyTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeMasterSlaveServerGroupAttributeResponseBodyTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeMasterSlaveServerGroupAttributeResponseBodyTagsTag) SetTagKey(v string) *DescribeMasterSlaveServerGroupAttributeResponseBodyTagsTag {
	s.TagKey = &v
	return s
}

func (s *DescribeMasterSlaveServerGroupAttributeResponseBodyTagsTag) SetTagValue(v string) *DescribeMasterSlaveServerGroupAttributeResponseBodyTagsTag {
	s.TagValue = &v
	return s
}

type DescribeMasterSlaveServerGroupAttributeResponse struct {
	Headers    map[string]*string                                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeMasterSlaveServerGroupAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeMasterSlaveServerGroupAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeMasterSlaveServerGroupAttributeResponse) GoString() string {
	return s.String()
}

func (s *DescribeMasterSlaveServerGroupAttributeResponse) SetHeaders(v map[string]*string) *DescribeMasterSlaveServerGroupAttributeResponse {
	s.Headers = v
	return s
}

func (s *DescribeMasterSlaveServerGroupAttributeResponse) SetStatusCode(v int32) *DescribeMasterSlaveServerGroupAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeMasterSlaveServerGroupAttributeResponse) SetBody(v *DescribeMasterSlaveServerGroupAttributeResponseBody) *DescribeMasterSlaveServerGroupAttributeResponse {
	s.Body = v
	return s
}

type DescribeMasterSlaveServerGroupsRequest struct {
	// The list of backend servers in the primary/secondary server group.
	IncludeListener *bool `json:"IncludeListener,omitempty" xml:"IncludeListener,omitempty"`
	// The ID of the primary/secondary server group.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The listening port.
	RegionId             *string                                      `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string                                      `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                                       `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tag                  []*DescribeMasterSlaveServerGroupsRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeMasterSlaveServerGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeMasterSlaveServerGroupsRequest) GoString() string {
	return s.String()
}

func (s *DescribeMasterSlaveServerGroupsRequest) SetIncludeListener(v bool) *DescribeMasterSlaveServerGroupsRequest {
	s.IncludeListener = &v
	return s
}

func (s *DescribeMasterSlaveServerGroupsRequest) SetLoadBalancerId(v string) *DescribeMasterSlaveServerGroupsRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *DescribeMasterSlaveServerGroupsRequest) SetOwnerAccount(v string) *DescribeMasterSlaveServerGroupsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeMasterSlaveServerGroupsRequest) SetOwnerId(v int64) *DescribeMasterSlaveServerGroupsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeMasterSlaveServerGroupsRequest) SetRegionId(v string) *DescribeMasterSlaveServerGroupsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeMasterSlaveServerGroupsRequest) SetResourceOwnerAccount(v string) *DescribeMasterSlaveServerGroupsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeMasterSlaveServerGroupsRequest) SetResourceOwnerId(v int64) *DescribeMasterSlaveServerGroupsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeMasterSlaveServerGroupsRequest) SetTag(v []*DescribeMasterSlaveServerGroupsRequestTag) *DescribeMasterSlaveServerGroupsRequest {
	s.Tag = v
	return s
}

type DescribeMasterSlaveServerGroupsRequestTag struct {
}

func (s DescribeMasterSlaveServerGroupsRequestTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeMasterSlaveServerGroupsRequestTag) GoString() string {
	return s.String()
}

type DescribeMasterSlaveServerGroupsResponseBody struct {
	// The associated resources.
	MasterSlaveServerGroups *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroups `json:"MasterSlaveServerGroups,omitempty" xml:"MasterSlaveServerGroups,omitempty" type:"Struct"`
	// The listening protocol.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeMasterSlaveServerGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeMasterSlaveServerGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeMasterSlaveServerGroupsResponseBody) SetMasterSlaveServerGroups(v *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroups) *DescribeMasterSlaveServerGroupsResponseBody {
	s.MasterSlaveServerGroups = v
	return s
}

func (s *DescribeMasterSlaveServerGroupsResponseBody) SetRequestId(v string) *DescribeMasterSlaveServerGroupsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroups struct {
	MasterSlaveServerGroup []*DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroup `json:"MasterSlaveServerGroup,omitempty" xml:"MasterSlaveServerGroup,omitempty" type:"Repeated"`
}

func (s DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroups) String() string {
	return tea.Prettify(s)
}

func (s DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroups) GoString() string {
	return s.String()
}

func (s *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroups) SetMasterSlaveServerGroup(v []*DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroup) *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroups {
	s.MasterSlaveServerGroup = v
	return s
}

type DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroup struct {
	// The name of the primary/secondary server group.
	AssociatedObjects *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupAssociatedObjects `json:"AssociatedObjects,omitempty" xml:"AssociatedObjects,omitempty" type:"Struct"`
	CreateTime        *string                                                                                                    `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the request.
	MasterSlaveServerGroupId *string `json:"MasterSlaveServerGroupId,omitempty" xml:"MasterSlaveServerGroupId,omitempty"`
	// The operation that you want to perform. Set the value to **DescribeMasterSlaveServerGroups**.
	MasterSlaveServerGroupName *string                                                                                       `json:"MasterSlaveServerGroupName,omitempty" xml:"MasterSlaveServerGroupName,omitempty"`
	Tags                       *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
}

func (s DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroup) String() string {
	return tea.Prettify(s)
}

func (s DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroup) GoString() string {
	return s.String()
}

func (s *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroup) SetAssociatedObjects(v *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupAssociatedObjects) *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroup {
	s.AssociatedObjects = v
	return s
}

func (s *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroup) SetCreateTime(v string) *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroup {
	s.CreateTime = &v
	return s
}

func (s *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroup) SetMasterSlaveServerGroupId(v string) *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroup {
	s.MasterSlaveServerGroupId = &v
	return s
}

func (s *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroup) SetMasterSlaveServerGroupName(v string) *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroup {
	s.MasterSlaveServerGroupName = &v
	return s
}

func (s *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroup) SetTags(v *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupTags) *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroup {
	s.Tags = v
	return s
}

type DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupAssociatedObjects struct {
	// Queries backend servers in a primary/secondary server group.
	Listeners *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupAssociatedObjectsListeners `json:"Listeners,omitempty" xml:"Listeners,omitempty" type:"Struct"`
}

func (s DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupAssociatedObjects) String() string {
	return tea.Prettify(s)
}

func (s DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupAssociatedObjects) GoString() string {
	return s.String()
}

func (s *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupAssociatedObjects) SetListeners(v *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupAssociatedObjectsListeners) *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupAssociatedObjects {
	s.Listeners = v
	return s
}

type DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupAssociatedObjectsListeners struct {
	Listener []*DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupAssociatedObjectsListenersListener `json:"Listener,omitempty" xml:"Listener,omitempty" type:"Repeated"`
}

func (s DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupAssociatedObjectsListeners) String() string {
	return tea.Prettify(s)
}

func (s DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupAssociatedObjectsListeners) GoString() string {
	return s.String()
}

func (s *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupAssociatedObjectsListeners) SetListener(v []*DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupAssociatedObjectsListenersListener) *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupAssociatedObjectsListeners {
	s.Listener = v
	return s
}

type DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupAssociatedObjectsListenersListener struct {
	Port     *int32  `json:"Port,omitempty" xml:"Port,omitempty"`
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
}

func (s DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupAssociatedObjectsListenersListener) String() string {
	return tea.Prettify(s)
}

func (s DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupAssociatedObjectsListenersListener) GoString() string {
	return s.String()
}

func (s *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupAssociatedObjectsListenersListener) SetPort(v int32) *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupAssociatedObjectsListenersListener {
	s.Port = &v
	return s
}

func (s *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupAssociatedObjectsListenersListener) SetProtocol(v string) *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupAssociatedObjectsListenersListener {
	s.Protocol = &v
	return s
}

type DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupTags struct {
	Tag []*DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupTags) GoString() string {
	return s.String()
}

func (s *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupTags) SetTag(v []*DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupTagsTag) *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupTags {
	s.Tag = v
	return s
}

type DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupTagsTag struct {
	TagKey   *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupTagsTag) SetTagKey(v string) *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupTagsTag {
	s.TagKey = &v
	return s
}

func (s *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupTagsTag) SetTagValue(v string) *DescribeMasterSlaveServerGroupsResponseBodyMasterSlaveServerGroupsMasterSlaveServerGroupTagsTag {
	s.TagValue = &v
	return s
}

type DescribeMasterSlaveServerGroupsResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeMasterSlaveServerGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeMasterSlaveServerGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeMasterSlaveServerGroupsResponse) GoString() string {
	return s.String()
}

func (s *DescribeMasterSlaveServerGroupsResponse) SetHeaders(v map[string]*string) *DescribeMasterSlaveServerGroupsResponse {
	s.Headers = v
	return s
}

func (s *DescribeMasterSlaveServerGroupsResponse) SetStatusCode(v int32) *DescribeMasterSlaveServerGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeMasterSlaveServerGroupsResponse) SetBody(v *DescribeMasterSlaveServerGroupsResponseBody) *DescribeMasterSlaveServerGroupsResponse {
	s.Body = v
	return s
}

type DescribeRegionsRequest struct {
	// The ID of the region.
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The operation that you want to perform.
	//
	// Set the value to **DescribeRegions**.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeRegionsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsRequest) GoString() string {
	return s.String()
}

func (s *DescribeRegionsRequest) SetAcceptLanguage(v string) *DescribeRegionsRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DescribeRegionsRequest) SetOwnerAccount(v string) *DescribeRegionsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeRegionsRequest) SetOwnerId(v int64) *DescribeRegionsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeRegionsRequest) SetRegionId(v string) *DescribeRegionsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeRegionsRequest) SetResourceOwnerAccount(v string) *DescribeRegionsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeRegionsRequest) SetResourceOwnerId(v int64) *DescribeRegionsRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeRegionsResponseBody struct {
	// The endpoint of the region.
	Regions *DescribeRegionsResponseBodyRegions `json:"Regions,omitempty" xml:"Regions,omitempty" type:"Struct"`
	// The list of regions.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeRegionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponseBody) SetRegions(v *DescribeRegionsResponseBodyRegions) *DescribeRegionsResponseBody {
	s.Regions = v
	return s
}

func (s *DescribeRegionsResponseBody) SetRequestId(v string) *DescribeRegionsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeRegionsResponseBodyRegions struct {
	Region []*DescribeRegionsResponseBodyRegionsRegion `json:"Region,omitempty" xml:"Region,omitempty" type:"Repeated"`
}

func (s DescribeRegionsResponseBodyRegions) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsResponseBodyRegions) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponseBodyRegions) SetRegion(v []*DescribeRegionsResponseBodyRegionsRegion) *DescribeRegionsResponseBodyRegions {
	s.Region = v
	return s
}

type DescribeRegionsResponseBodyRegionsRegion struct {
	// China (Beijing)
	LocalName *string `json:"LocalName,omitempty" xml:"LocalName,omitempty"`
	// The name of the region.
	RegionEndpoint *string `json:"RegionEndpoint,omitempty" xml:"RegionEndpoint,omitempty"`
	// Queries regions.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeRegionsResponseBodyRegionsRegion) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsResponseBodyRegionsRegion) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponseBodyRegionsRegion) SetLocalName(v string) *DescribeRegionsResponseBodyRegionsRegion {
	s.LocalName = &v
	return s
}

func (s *DescribeRegionsResponseBodyRegionsRegion) SetRegionEndpoint(v string) *DescribeRegionsResponseBodyRegionsRegion {
	s.RegionEndpoint = &v
	return s
}

func (s *DescribeRegionsResponseBodyRegionsRegion) SetRegionId(v string) *DescribeRegionsResponseBodyRegionsRegion {
	s.RegionId = &v
	return s
}

type DescribeRegionsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRegionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRegionsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRegionsResponse) GoString() string {
	return s.String()
}

func (s *DescribeRegionsResponse) SetHeaders(v map[string]*string) *DescribeRegionsResponse {
	s.Headers = v
	return s
}

func (s *DescribeRegionsResponse) SetStatusCode(v int32) *DescribeRegionsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRegionsResponse) SetBody(v *DescribeRegionsResponseBody) *DescribeRegionsResponse {
	s.Body = v
	return s
}

type DescribeRuleAttributeRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the forwarding rule.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The HTTP status code that indicates a successful health check. Separate multiple HTTP status codes with commas (,). Default value: **http\_2xx**.
	//
	// Valid values: **http\_2xx**, **http\_3xx**, **http\_4xx**, and **http\_5xx**.
	//
	// >  If you set the **HealthCheck** parameter to **on**, this parameter is required.
	RuleId *string `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
}

func (s DescribeRuleAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRuleAttributeRequest) GoString() string {
	return s.String()
}

func (s *DescribeRuleAttributeRequest) SetOwnerAccount(v string) *DescribeRuleAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeRuleAttributeRequest) SetOwnerId(v int64) *DescribeRuleAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeRuleAttributeRequest) SetRegionId(v string) *DescribeRuleAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeRuleAttributeRequest) SetResourceOwnerAccount(v string) *DescribeRuleAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeRuleAttributeRequest) SetResourceOwnerId(v int64) *DescribeRuleAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeRuleAttributeRequest) SetRuleId(v string) *DescribeRuleAttributeRequest {
	s.RuleId = &v
	return s
}

type DescribeRuleAttributeResponseBody struct {
	// The ID of the SLB instance.
	Cookie *string `json:"Cookie,omitempty" xml:"Cookie,omitempty"`
	// The domain name that is used for health checks. Valid values:
	//
	// *   **$\_ip**: The private IP address of the backend server. If the $\_ip parameter is set or the HealthCheckDomain parameter is not set, SLB uses the private IP addresses of backend servers as the domain names for health checks.
	// *   **domain**: The domain name must be 1 to 80 characters in length. It can contain only letters, digits, periods (.),and hyphens (-).
	//
	// >  If you set the **HealthCheck** parameter to **on**, this parameter is required.
	CookieTimeout *int32 `json:"CookieTimeout,omitempty" xml:"CookieTimeout,omitempty"`
	// The cookie to be configured on the backend server.
	//
	// The cookie must be 1 to 200 characters in length and can contain ASCII letters and digits. It cannot contain commas (,), semicolons (;), or whitespace characters. It cannot start with a dollar sign ($).
	//
	// If you set the **StickySession** parameter to **on** and the **StickySessionType** parameter to **server**, this parameter is required.
	Domain      *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	HealthCheck *string `json:"HealthCheck,omitempty" xml:"HealthCheck,omitempty"`
	// The scheduling algorithm. Valid values:
	//
	// *   **wrr** (default): Backend servers that have higher weights receive more requests than backend servers that have lower weights.
	// *   **rr**: Requests are distributed to backend servers in sequence.
	//
	// >  If you set the **ListenerSync** parameter to **off**, this parameter is required. If you set the parameter to **on**, the configuration of the listener is used.
	HealthCheckConnectPort *int32 `json:"HealthCheckConnectPort,omitempty" xml:"HealthCheckConnectPort,omitempty"`
	// The number of consecutive failed health checks that must occur before a healthy backend server is declared unhealthy. In this case, the health check state is changed from **success** to **fail**.
	//
	// Valid values: **2** to **10**.
	//
	// >  If you set the **HealthCheck** parameter to **on**, this parameter is required.
	HealthCheckDomain *string `json:"HealthCheckDomain,omitempty" xml:"HealthCheckDomain,omitempty"`
	// The ID of the vServer group that is associated with the forwarding rule.
	HealthCheckHttpCode *string `json:"HealthCheckHttpCode,omitempty" xml:"HealthCheckHttpCode,omitempty"`
	// The URL that is configured in the forwarding rule.
	HealthCheckInterval *int32 `json:"HealthCheckInterval,omitempty" xml:"HealthCheckInterval,omitempty"`
	// Indicates whether the forwarding rule uses the scheduling algorithm, session persistence, and health check configurations of the listener.
	//
	// Valid values: **on** and **off**.
	//
	// *   **off**: does not use the configurations of the listener. You can customize health check and session persistence configurations for the forwarding rule.
	// *   **on**: uses the configurations of the listener.
	HealthCheckTimeout *int32 `json:"HealthCheckTimeout,omitempty" xml:"HealthCheckTimeout,omitempty"`
	// The method that is used to handle a cookie. Valid values:
	//
	// *   **insert**: inserts a cookie into the response. SLB inserts a cookie (SERVERID) into the first HTTP or HTTPS response packet that is sent to a client. The next request from the client will contain this cookie, and the listener will distribute this request to the recorded backend server.
	// *   **server**: rewrites a cookie. When SLB detects a user-defined cookie, SLB overwrites the original cookie with the user-defined cookie. The next request from the client contains the user-defined cookie, and the listener distributes the request to the recorded backend server.
	//
	// >  If you set the **StickySession** parameter to **on**, this parameter is required.
	HealthCheckURI *string `json:"HealthCheckURI,omitempty" xml:"HealthCheckURI,omitempty"`
	// The timeout period of a cookie.
	//
	// Valid values: **1 to 86400**. Unit: seconds.
	//
	// >  If you set the **StickySession** parameter to **on** and the **StickySessionType** parameter to **insert**, this parameter is required.
	HealthyThreshold *int32 `json:"HealthyThreshold,omitempty" xml:"HealthyThreshold,omitempty"`
	// The time interval between two consecutive health checks.
	//
	// Valid values: **1** to **50**. Unit: seconds.
	//
	// >  If you set the **HealthCheck** parameter to **on**, this parameter is required.
	ListenerPort *string `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	// The number of consecutive successful health checks that must occur before an unhealthy backend server is declared healthy. In this case, the health check state is changed from **fail** to **success**.
	//
	// Valid values: **2** to **10**.
	//
	// >  If you set the **HealthCheck** parameter to **on**, this parameter is required.
	ListenerSync *string `json:"ListenerSync,omitempty" xml:"ListenerSync,omitempty"`
	// The listener port that is used by the SLB instance.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// The timeout period of a health check response. If a backend ECS instance does not send an expected response within the specified period of time, the ECS instance is considered unhealthy.
	//
	// Valid values: **1** to **300**. Unit: seconds.
	//
	// >  If the value of the **HealthCHeckTimeout** parameter is smaller than that of the **HealthCheckInterval** parameter, the value of the **HealthCHeckTimeout** parameter is ignored and the value of the **HealthCheckInterval** parameter is regarded as the waiting period. If you set the **HealthCheck** parameter to **on**, this parameter is required.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The port of the backend server that is used for health checks.
	//
	// Valid values: **1** to **65535**.
	//
	// >  If you set the **HealthCheck** parameter to **on**, this parameter is required. If you left this parameter empty and the **HealthCheck** parameter is set to **on**, the backend port configuration of the listener is used by default.
	RuleId *string `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	// The ID of the forwarding rule.
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	// The ID of the request.
	Scheduler *string `json:"Scheduler,omitempty" xml:"Scheduler,omitempty"`
	// Specifies whether to enable health checks.
	//
	// Valid values: **on** and **off**.
	//
	// >  If you set the **ListenerSync** parameter to **off**, this parameter is required. If you set the parameter to **on**, the configuration of the listener is used.
	StickySession *string `json:"StickySession,omitempty" xml:"StickySession,omitempty"`
	// The name of the forwarding rule.
	StickySessionType *string `json:"StickySessionType,omitempty" xml:"StickySessionType,omitempty"`
	// Indicates whether session persistence is enabled.
	//
	// Valid values: **on** and **off**.
	//
	// >  If you set the **ListenerSync** parameter to **off**, this parameter is required. If you set the parameter to **on**, the configuration of the listener is used.
	UnhealthyThreshold *int32 `json:"UnhealthyThreshold,omitempty" xml:"UnhealthyThreshold,omitempty"`
	// The URI that is used for health checks.
	//
	// >  If you set the **HealthCheck** parameter to **on**, this parameter is required.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
	// The domain name that is configured in the forwarding rule.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
}

func (s DescribeRuleAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRuleAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRuleAttributeResponseBody) SetCookie(v string) *DescribeRuleAttributeResponseBody {
	s.Cookie = &v
	return s
}

func (s *DescribeRuleAttributeResponseBody) SetCookieTimeout(v int32) *DescribeRuleAttributeResponseBody {
	s.CookieTimeout = &v
	return s
}

func (s *DescribeRuleAttributeResponseBody) SetDomain(v string) *DescribeRuleAttributeResponseBody {
	s.Domain = &v
	return s
}

func (s *DescribeRuleAttributeResponseBody) SetHealthCheck(v string) *DescribeRuleAttributeResponseBody {
	s.HealthCheck = &v
	return s
}

func (s *DescribeRuleAttributeResponseBody) SetHealthCheckConnectPort(v int32) *DescribeRuleAttributeResponseBody {
	s.HealthCheckConnectPort = &v
	return s
}

func (s *DescribeRuleAttributeResponseBody) SetHealthCheckDomain(v string) *DescribeRuleAttributeResponseBody {
	s.HealthCheckDomain = &v
	return s
}

func (s *DescribeRuleAttributeResponseBody) SetHealthCheckHttpCode(v string) *DescribeRuleAttributeResponseBody {
	s.HealthCheckHttpCode = &v
	return s
}

func (s *DescribeRuleAttributeResponseBody) SetHealthCheckInterval(v int32) *DescribeRuleAttributeResponseBody {
	s.HealthCheckInterval = &v
	return s
}

func (s *DescribeRuleAttributeResponseBody) SetHealthCheckTimeout(v int32) *DescribeRuleAttributeResponseBody {
	s.HealthCheckTimeout = &v
	return s
}

func (s *DescribeRuleAttributeResponseBody) SetHealthCheckURI(v string) *DescribeRuleAttributeResponseBody {
	s.HealthCheckURI = &v
	return s
}

func (s *DescribeRuleAttributeResponseBody) SetHealthyThreshold(v int32) *DescribeRuleAttributeResponseBody {
	s.HealthyThreshold = &v
	return s
}

func (s *DescribeRuleAttributeResponseBody) SetListenerPort(v string) *DescribeRuleAttributeResponseBody {
	s.ListenerPort = &v
	return s
}

func (s *DescribeRuleAttributeResponseBody) SetListenerSync(v string) *DescribeRuleAttributeResponseBody {
	s.ListenerSync = &v
	return s
}

func (s *DescribeRuleAttributeResponseBody) SetLoadBalancerId(v string) *DescribeRuleAttributeResponseBody {
	s.LoadBalancerId = &v
	return s
}

func (s *DescribeRuleAttributeResponseBody) SetRequestId(v string) *DescribeRuleAttributeResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeRuleAttributeResponseBody) SetRuleId(v string) *DescribeRuleAttributeResponseBody {
	s.RuleId = &v
	return s
}

func (s *DescribeRuleAttributeResponseBody) SetRuleName(v string) *DescribeRuleAttributeResponseBody {
	s.RuleName = &v
	return s
}

func (s *DescribeRuleAttributeResponseBody) SetScheduler(v string) *DescribeRuleAttributeResponseBody {
	s.Scheduler = &v
	return s
}

func (s *DescribeRuleAttributeResponseBody) SetStickySession(v string) *DescribeRuleAttributeResponseBody {
	s.StickySession = &v
	return s
}

func (s *DescribeRuleAttributeResponseBody) SetStickySessionType(v string) *DescribeRuleAttributeResponseBody {
	s.StickySessionType = &v
	return s
}

func (s *DescribeRuleAttributeResponseBody) SetUnhealthyThreshold(v int32) *DescribeRuleAttributeResponseBody {
	s.UnhealthyThreshold = &v
	return s
}

func (s *DescribeRuleAttributeResponseBody) SetUrl(v string) *DescribeRuleAttributeResponseBody {
	s.Url = &v
	return s
}

func (s *DescribeRuleAttributeResponseBody) SetVServerGroupId(v string) *DescribeRuleAttributeResponseBody {
	s.VServerGroupId = &v
	return s
}

type DescribeRuleAttributeResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRuleAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRuleAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRuleAttributeResponse) GoString() string {
	return s.String()
}

func (s *DescribeRuleAttributeResponse) SetHeaders(v map[string]*string) *DescribeRuleAttributeResponse {
	s.Headers = v
	return s
}

func (s *DescribeRuleAttributeResponse) SetStatusCode(v int32) *DescribeRuleAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRuleAttributeResponse) SetBody(v *DescribeRuleAttributeResponseBody) *DescribeRuleAttributeResponse {
	s.Body = v
	return s
}

type DescribeRulesRequest struct {
	// The ID of the request.
	ListenerPort *int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	// The frontend listener port that is used by the Server Load Balancer (SLB) instance.
	//
	// Valid values: **1 to 65535**.
	ListenerProtocol *string `json:"ListenerProtocol,omitempty" xml:"ListenerProtocol,omitempty"`
	// The frontend listener protocol that is used by the SLB instance.
	//
	// >  This parameter is required when listeners that use different protocols listen on the same port.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the SLB instance.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRulesRequest) GoString() string {
	return s.String()
}

func (s *DescribeRulesRequest) SetListenerPort(v int32) *DescribeRulesRequest {
	s.ListenerPort = &v
	return s
}

func (s *DescribeRulesRequest) SetListenerProtocol(v string) *DescribeRulesRequest {
	s.ListenerProtocol = &v
	return s
}

func (s *DescribeRulesRequest) SetLoadBalancerId(v string) *DescribeRulesRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *DescribeRulesRequest) SetOwnerAccount(v string) *DescribeRulesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeRulesRequest) SetOwnerId(v int64) *DescribeRulesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeRulesRequest) SetRegionId(v string) *DescribeRulesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeRulesRequest) SetResourceOwnerAccount(v string) *DescribeRulesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeRulesRequest) SetResourceOwnerId(v int64) *DescribeRulesRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeRulesResponseBody struct {
	// The list of forwarding rules.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The HTTP status code that indicates a successful health check. Multiple HTTP status codes are separated by commas (,). Default value: **http\_2xx**.
	//
	// Valid values: **http\_2xx**, **http\_3xx**, **http\_4xx**, and **http\_5xx**.
	//
	// >  If you set the **HealthCheck** parameter to **on**, this parameter is required.
	Rules *DescribeRulesResponseBodyRules `json:"Rules,omitempty" xml:"Rules,omitempty" type:"Struct"`
}

func (s DescribeRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRulesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRulesResponseBody) SetRequestId(v string) *DescribeRulesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeRulesResponseBody) SetRules(v *DescribeRulesResponseBodyRules) *DescribeRulesResponseBody {
	s.Rules = v
	return s
}

type DescribeRulesResponseBodyRules struct {
	Rule []*DescribeRulesResponseBodyRulesRule `json:"Rule,omitempty" xml:"Rule,omitempty" type:"Repeated"`
}

func (s DescribeRulesResponseBodyRules) String() string {
	return tea.Prettify(s)
}

func (s DescribeRulesResponseBodyRules) GoString() string {
	return s.String()
}

func (s *DescribeRulesResponseBodyRules) SetRule(v []*DescribeRulesResponseBodyRulesRule) *DescribeRulesResponseBodyRules {
	s.Rule = v
	return s
}

type DescribeRulesResponseBodyRulesRule struct {
	// The time interval between two consecutive health checks.
	//
	// Valid values: **1 to 50**. Unit: seconds.
	//
	// >  If you set the **HealthCheck** parameter to **on**, this parameter is required.
	Cookie *string `json:"Cookie,omitempty" xml:"Cookie,omitempty"`
	// The domain name that is used for health checks. Valid values:
	//
	// *   **$\_ip**: The private IP address of the backend server.
	//
	//     If you do not set this parameter or set the parameter to $\_ip, the SLB instance uses the private IP address of each backend server as the domain name for health checks.
	//
	// *   **domain**: The domain name must be 1 to 80 characters in length. The domain name can contain only letters, digits, periods (.),and hyphens (-).
	//
	// >  If you set the **HealthCheck** parameter to **on**, this parameter is required.
	CookieTimeout *int32 `json:"CookieTimeout,omitempty" xml:"CookieTimeout,omitempty"`
	// The cookie that is configured on the backend server.
	//
	// The value must be 1 to 200 characters in length, and can contain only ASCII letters and digits. It cannot contain commas (,), semicolons (;), or spaces. It cannot start with a dollar sign ($).
	//
	// >  If you set the **StickySession** parameter to **on** and the **StickySessionType** parameter to **server**, this parameter is required.
	Domain      *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	HealthCheck *string `json:"HealthCheck,omitempty" xml:"HealthCheck,omitempty"`
	// The scheduling algorithm. Valid values:
	//
	// *   **wrr** (default): Backend servers that have higher weights receive more requests than backend servers that have lower weights.
	// *   **rr**: Requests are distributed to backend servers in sequence.
	//
	// >  If you set the **ListenerSync** parameter to **off**, this parameter is required. If you set the parameter to **on**, the configuration of the listener is used.
	HealthCheckConnectPort *int32 `json:"HealthCheckConnectPort,omitempty" xml:"HealthCheckConnectPort,omitempty"`
	// Specifies the number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy (from **success** to **fail**).
	//
	// Valid values: **2 to 10**
	//
	// >  If you set the **HealthCheck** parameter to **on**, this parameter is required.
	HealthCheckDomain *string `json:"HealthCheckDomain,omitempty" xml:"HealthCheckDomain,omitempty"`
	// The ID of the destination vServer group specified in the forwarding rule.
	HealthCheckHttpCode *string `json:"HealthCheckHttpCode,omitempty" xml:"HealthCheckHttpCode,omitempty"`
	// The requested path specified in the forwarding rule.
	HealthCheckInterval *int32 `json:"HealthCheckInterval,omitempty" xml:"HealthCheckInterval,omitempty"`
	// Indicates whether the forwarding rule uses the scheduling algorithm, session persistence, and health check configurations of the listener.
	//
	// Valid values: **on** and **off**.
	//
	// *   **off**: does not use the configurations of the listener. You can customize health check and session persistence configurations for the forwarding rule.
	// *   **on**: uses the configurations of the listener.
	HealthCheckTimeout *int32 `json:"HealthCheckTimeout,omitempty" xml:"HealthCheckTimeout,omitempty"`
	// The method that is used to handle a cookie. Valid values:
	//
	// *   **insert**: inserts a cookie into the response. SLB inserts a cookie (SERVERID) into the first HTTP or HTTPS response packet that is sent to a client. The next request from the client will contain this cookie, and the listener will distribute this request to the recorded backend server.
	// *   **server**: rewrites a cookie. When SLB detects a user-defined cookie, SLB overwrites the original cookie with the user-defined cookie. The next request from the client contains the user-defined cookie, and the listener distributes the request to the recorded backend server.
	//
	// >  If you set the **StickySession** parameter to **on**, this parameter is required.
	HealthCheckURI *string `json:"HealthCheckURI,omitempty" xml:"HealthCheckURI,omitempty"`
	// The timeout period of a cookie. Valid values: **1 to 86400**. Unit: seconds.
	//
	// >  If you set the **StickySession** parameter to **on** and the **StickySessionType** parameter to **insert**, this parameter is required.
	HealthyThreshold *int32 `json:"HealthyThreshold,omitempty" xml:"HealthyThreshold,omitempty"`
	// Specifies the number of successful health checks that must be consecutively performed before a backend server can be declared healthy (from **fail** to **success**).
	//
	// Valid values: **2 to 10**.
	//
	// >  If you set the **HealthCheck** parameter to **on**, this parameter is required.
	ListenerSync *string `json:"ListenerSync,omitempty" xml:"ListenerSync,omitempty"`
	// The port of the backend server that is used for health check.
	//
	// Valid values: **1 to 65535**.
	//
	// >  If you set the **HealthCheck** parameter to **on**, this parameter is required. If you left this parameter empty and the **HealthCheck** parameter is set to **on**, the backend port configuration of the listener is used by default.
	RuleId *string `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	// The ID of the forwarding rule.
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	// The timeout period for a health check response. If the backend Elastic Compute Service (ECS) instance does not send an expected response within the specified period of time, the health check fails.
	//
	// Valid values: **1 to 300**. Unit: seconds.
	//
	// >  If the value of the **HealthCHeckTimeout** parameter is smaller than that of the **HealthCheckInterval** parameter, the value of the **HealthCHeckTimeout** parameter is ignored and the value of the **HealthCheckInterval** parameter is regarded as the waiting period. If you set the **HealthCheck** parameter to **on**, this parameter is required.
	Scheduler *string `json:"Scheduler,omitempty" xml:"Scheduler,omitempty"`
	// Indicates whether health checks are enabled.
	//
	// Valid values: **on** and **off**.
	//
	// >  If you set the **ListenerSync** parameter to **off**, this parameter is required. If you set the parameter to **on**, the configuration of the listener is used.
	StickySession *string `json:"StickySession,omitempty" xml:"StickySession,omitempty"`
	// The name of the forwarding rule. The name must be 1 to 80 characters in length, and can contain only letters, digits, hyphens (-), forward slashes (/), periods (.),and underscores (\_).
	//
	// >  The name of each forwarding rule must be unique within a listener.
	StickySessionType *string `json:"StickySessionType,omitempty" xml:"StickySessionType,omitempty"`
	// Specifies whether to enable session persistence.
	//
	// Valid values: **on** and **off**.
	//
	// >  If you set the **ListenerSync** parameter to **off**, this parameter is required. If you set the parameter to **on**, the configuration of the listener is used.
	UnhealthyThreshold *int32 `json:"UnhealthyThreshold,omitempty" xml:"UnhealthyThreshold,omitempty"`
	// The URI that is used for health checks.
	//
	// >  If you set the **HealthCheck** parameter to **on**, this parameter is required.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
	// The requested domain name specified in the forwarding rule.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
}

func (s DescribeRulesResponseBodyRulesRule) String() string {
	return tea.Prettify(s)
}

func (s DescribeRulesResponseBodyRulesRule) GoString() string {
	return s.String()
}

func (s *DescribeRulesResponseBodyRulesRule) SetCookie(v string) *DescribeRulesResponseBodyRulesRule {
	s.Cookie = &v
	return s
}

func (s *DescribeRulesResponseBodyRulesRule) SetCookieTimeout(v int32) *DescribeRulesResponseBodyRulesRule {
	s.CookieTimeout = &v
	return s
}

func (s *DescribeRulesResponseBodyRulesRule) SetDomain(v string) *DescribeRulesResponseBodyRulesRule {
	s.Domain = &v
	return s
}

func (s *DescribeRulesResponseBodyRulesRule) SetHealthCheck(v string) *DescribeRulesResponseBodyRulesRule {
	s.HealthCheck = &v
	return s
}

func (s *DescribeRulesResponseBodyRulesRule) SetHealthCheckConnectPort(v int32) *DescribeRulesResponseBodyRulesRule {
	s.HealthCheckConnectPort = &v
	return s
}

func (s *DescribeRulesResponseBodyRulesRule) SetHealthCheckDomain(v string) *DescribeRulesResponseBodyRulesRule {
	s.HealthCheckDomain = &v
	return s
}

func (s *DescribeRulesResponseBodyRulesRule) SetHealthCheckHttpCode(v string) *DescribeRulesResponseBodyRulesRule {
	s.HealthCheckHttpCode = &v
	return s
}

func (s *DescribeRulesResponseBodyRulesRule) SetHealthCheckInterval(v int32) *DescribeRulesResponseBodyRulesRule {
	s.HealthCheckInterval = &v
	return s
}

func (s *DescribeRulesResponseBodyRulesRule) SetHealthCheckTimeout(v int32) *DescribeRulesResponseBodyRulesRule {
	s.HealthCheckTimeout = &v
	return s
}

func (s *DescribeRulesResponseBodyRulesRule) SetHealthCheckURI(v string) *DescribeRulesResponseBodyRulesRule {
	s.HealthCheckURI = &v
	return s
}

func (s *DescribeRulesResponseBodyRulesRule) SetHealthyThreshold(v int32) *DescribeRulesResponseBodyRulesRule {
	s.HealthyThreshold = &v
	return s
}

func (s *DescribeRulesResponseBodyRulesRule) SetListenerSync(v string) *DescribeRulesResponseBodyRulesRule {
	s.ListenerSync = &v
	return s
}

func (s *DescribeRulesResponseBodyRulesRule) SetRuleId(v string) *DescribeRulesResponseBodyRulesRule {
	s.RuleId = &v
	return s
}

func (s *DescribeRulesResponseBodyRulesRule) SetRuleName(v string) *DescribeRulesResponseBodyRulesRule {
	s.RuleName = &v
	return s
}

func (s *DescribeRulesResponseBodyRulesRule) SetScheduler(v string) *DescribeRulesResponseBodyRulesRule {
	s.Scheduler = &v
	return s
}

func (s *DescribeRulesResponseBodyRulesRule) SetStickySession(v string) *DescribeRulesResponseBodyRulesRule {
	s.StickySession = &v
	return s
}

func (s *DescribeRulesResponseBodyRulesRule) SetStickySessionType(v string) *DescribeRulesResponseBodyRulesRule {
	s.StickySessionType = &v
	return s
}

func (s *DescribeRulesResponseBodyRulesRule) SetUnhealthyThreshold(v int32) *DescribeRulesResponseBodyRulesRule {
	s.UnhealthyThreshold = &v
	return s
}

func (s *DescribeRulesResponseBodyRulesRule) SetUrl(v string) *DescribeRulesResponseBodyRulesRule {
	s.Url = &v
	return s
}

func (s *DescribeRulesResponseBodyRulesRule) SetVServerGroupId(v string) *DescribeRulesResponseBodyRulesRule {
	s.VServerGroupId = &v
	return s
}

type DescribeRulesResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRulesResponse) GoString() string {
	return s.String()
}

func (s *DescribeRulesResponse) SetHeaders(v map[string]*string) *DescribeRulesResponse {
	s.Headers = v
	return s
}

func (s *DescribeRulesResponse) SetStatusCode(v int32) *DescribeRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRulesResponse) SetBody(v *DescribeRulesResponseBody) *DescribeRulesResponse {
	s.Body = v
	return s
}

type DescribeServerCertificatesRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the server certificate.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The domain name of the certificate. The domain name is specified in the `CommonName` field.
	ServerCertificateId *string `json:"ServerCertificateId,omitempty" xml:"ServerCertificateId,omitempty"`
}

func (s DescribeServerCertificatesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeServerCertificatesRequest) GoString() string {
	return s.String()
}

func (s *DescribeServerCertificatesRequest) SetOwnerAccount(v string) *DescribeServerCertificatesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeServerCertificatesRequest) SetOwnerId(v int64) *DescribeServerCertificatesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeServerCertificatesRequest) SetRegionId(v string) *DescribeServerCertificatesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeServerCertificatesRequest) SetResourceGroupId(v string) *DescribeServerCertificatesRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeServerCertificatesRequest) SetResourceOwnerAccount(v string) *DescribeServerCertificatesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeServerCertificatesRequest) SetResourceOwnerId(v int64) *DescribeServerCertificatesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeServerCertificatesRequest) SetServerCertificateId(v string) *DescribeServerCertificatesRequest {
	s.ServerCertificateId = &v
	return s
}

type DescribeServerCertificatesResponseBody struct {
	// The timestamp generated when the server certificate is uploaded.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of server certificates.
	ServerCertificates *DescribeServerCertificatesResponseBodyServerCertificates `json:"ServerCertificates,omitempty" xml:"ServerCertificates,omitempty" type:"Struct"`
}

func (s DescribeServerCertificatesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeServerCertificatesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeServerCertificatesResponseBody) SetRequestId(v string) *DescribeServerCertificatesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeServerCertificatesResponseBody) SetServerCertificates(v *DescribeServerCertificatesResponseBodyServerCertificates) *DescribeServerCertificatesResponseBody {
	s.ServerCertificates = v
	return s
}

type DescribeServerCertificatesResponseBodyServerCertificates struct {
	ServerCertificate []*DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate `json:"ServerCertificate,omitempty" xml:"ServerCertificate,omitempty" type:"Repeated"`
}

func (s DescribeServerCertificatesResponseBodyServerCertificates) String() string {
	return tea.Prettify(s)
}

func (s DescribeServerCertificatesResponseBodyServerCertificates) GoString() string {
	return s.String()
}

func (s *DescribeServerCertificatesResponseBodyServerCertificates) SetServerCertificate(v []*DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate) *DescribeServerCertificatesResponseBodyServerCertificates {
	s.ServerCertificate = v
	return s
}

type DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate struct {
	AliCloudCertificateId *string `json:"AliCloudCertificateId,omitempty" xml:"AliCloudCertificateId,omitempty"`
	// The time when the server certificate is uploaded.
	AliCloudCertificateName *string `json:"AliCloudCertificateName,omitempty" xml:"AliCloudCertificateName,omitempty"`
	// The ID of the server certificate from Alibaba Cloud Certificate Management Service.
	CommonName *string `json:"CommonName,omitempty" xml:"CommonName,omitempty"`
	// The ID of the region where the server certificate is created.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The operation that you want to perform. Set the value to **DescribeServerCertificates**.
	CreateTimeStamp *int64 `json:"CreateTimeStamp,omitempty" xml:"CreateTimeStamp,omitempty"`
	// The ID of the resource group.
	ExpireTime *string `json:"ExpireTime,omitempty" xml:"ExpireTime,omitempty"`
	// Indicates whether the server certificate is from Alibaba Cloud Certificate Management Service. Valid values:
	//
	// *   **1**: yes
	// *   **0**: no
	ExpireTimeStamp *int64 `json:"ExpireTimeStamp,omitempty" xml:"ExpireTimeStamp,omitempty"`
	// The name of the server certificate from Alibaba Cloud Certificate Management Service.
	Fingerprint           *string `json:"Fingerprint,omitempty" xml:"Fingerprint,omitempty"`
	IsAliCloudCertificate *int32  `json:"IsAliCloudCertificate,omitempty" xml:"IsAliCloudCertificate,omitempty"`
	// The ID of the server certificate.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the request.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The region where the CLB instances are deployed.
	//
	// You can call the [DescribeRegions](~~27584~~) operation to query the most recent region list.
	//
	// >  If the endpoint of the region is slb.aliyuncs.com, you must specify the `RegionId` parameter.
	ServerCertificateId *string `json:"ServerCertificateId,omitempty" xml:"ServerCertificateId,omitempty"`
	// The timestamp that indicates when the certificate expires.
	ServerCertificateName   *string                                                                                           `json:"ServerCertificateName,omitempty" xml:"ServerCertificateName,omitempty"`
	SubjectAlternativeNames *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificateSubjectAlternativeNames `json:"SubjectAlternativeNames,omitempty" xml:"SubjectAlternativeNames,omitempty" type:"Struct"`
	Tags                    *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificateTags                    `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
}

func (s DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate) String() string {
	return tea.Prettify(s)
}

func (s DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate) GoString() string {
	return s.String()
}

func (s *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate) SetAliCloudCertificateId(v string) *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate {
	s.AliCloudCertificateId = &v
	return s
}

func (s *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate) SetAliCloudCertificateName(v string) *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate {
	s.AliCloudCertificateName = &v
	return s
}

func (s *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate) SetCommonName(v string) *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate {
	s.CommonName = &v
	return s
}

func (s *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate) SetCreateTime(v string) *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate {
	s.CreateTime = &v
	return s
}

func (s *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate) SetCreateTimeStamp(v int64) *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate {
	s.CreateTimeStamp = &v
	return s
}

func (s *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate) SetExpireTime(v string) *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate {
	s.ExpireTime = &v
	return s
}

func (s *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate) SetExpireTimeStamp(v int64) *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate {
	s.ExpireTimeStamp = &v
	return s
}

func (s *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate) SetFingerprint(v string) *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate {
	s.Fingerprint = &v
	return s
}

func (s *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate) SetIsAliCloudCertificate(v int32) *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate {
	s.IsAliCloudCertificate = &v
	return s
}

func (s *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate) SetRegionId(v string) *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate {
	s.RegionId = &v
	return s
}

func (s *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate) SetResourceGroupId(v string) *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate) SetServerCertificateId(v string) *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate {
	s.ServerCertificateId = &v
	return s
}

func (s *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate) SetServerCertificateName(v string) *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate {
	s.ServerCertificateName = &v
	return s
}

func (s *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate) SetSubjectAlternativeNames(v *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificateSubjectAlternativeNames) *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate {
	s.SubjectAlternativeNames = v
	return s
}

func (s *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate) SetTags(v *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificateTags) *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificate {
	s.Tags = v
	return s
}

type DescribeServerCertificatesResponseBodyServerCertificatesServerCertificateSubjectAlternativeNames struct {
	SubjectAlternativeName []*string `json:"SubjectAlternativeName,omitempty" xml:"SubjectAlternativeName,omitempty" type:"Repeated"`
}

func (s DescribeServerCertificatesResponseBodyServerCertificatesServerCertificateSubjectAlternativeNames) String() string {
	return tea.Prettify(s)
}

func (s DescribeServerCertificatesResponseBodyServerCertificatesServerCertificateSubjectAlternativeNames) GoString() string {
	return s.String()
}

func (s *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificateSubjectAlternativeNames) SetSubjectAlternativeName(v []*string) *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificateSubjectAlternativeNames {
	s.SubjectAlternativeName = v
	return s
}

type DescribeServerCertificatesResponseBodyServerCertificatesServerCertificateTags struct {
	Tag []*DescribeServerCertificatesResponseBodyServerCertificatesServerCertificateTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeServerCertificatesResponseBodyServerCertificatesServerCertificateTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeServerCertificatesResponseBodyServerCertificatesServerCertificateTags) GoString() string {
	return s.String()
}

func (s *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificateTags) SetTag(v []*DescribeServerCertificatesResponseBodyServerCertificatesServerCertificateTagsTag) *DescribeServerCertificatesResponseBodyServerCertificatesServerCertificateTags {
	s.Tag = v
	return s
}

type DescribeServerCertificatesResponseBodyServerCertificatesServerCertificateTagsTag struct {
}

func (s DescribeServerCertificatesResponseBodyServerCertificatesServerCertificateTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeServerCertificatesResponseBodyServerCertificatesServerCertificateTagsTag) GoString() string {
	return s.String()
}

type DescribeServerCertificatesResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeServerCertificatesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeServerCertificatesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeServerCertificatesResponse) GoString() string {
	return s.String()
}

func (s *DescribeServerCertificatesResponse) SetHeaders(v map[string]*string) *DescribeServerCertificatesResponse {
	s.Headers = v
	return s
}

func (s *DescribeServerCertificatesResponse) SetStatusCode(v int32) *DescribeServerCertificatesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeServerCertificatesResponse) SetBody(v *DescribeServerCertificatesResponseBody) *DescribeServerCertificatesResponse {
	s.Body = v
	return s
}

type DescribeTagsRequest struct {
	// Specifies whether the tag is DistinctKey.
	//
	// Valid values: **true and false**.
	DistinctKey *bool `json:"DistinctKey,omitempty" xml:"DistinctKey,omitempty"`
	// The ID of the SLB instance.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Minimum value: 1. Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: 50. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region where the Server Load Balancer (SLB) instance is deployed.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The tags that you want to query.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s DescribeTagsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagsRequest) GoString() string {
	return s.String()
}

func (s *DescribeTagsRequest) SetDistinctKey(v bool) *DescribeTagsRequest {
	s.DistinctKey = &v
	return s
}

func (s *DescribeTagsRequest) SetLoadBalancerId(v string) *DescribeTagsRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *DescribeTagsRequest) SetOwnerAccount(v string) *DescribeTagsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeTagsRequest) SetOwnerId(v int64) *DescribeTagsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeTagsRequest) SetPageNumber(v int32) *DescribeTagsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeTagsRequest) SetPageSize(v int32) *DescribeTagsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeTagsRequest) SetRegionId(v string) *DescribeTagsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeTagsRequest) SetResourceOwnerAccount(v string) *DescribeTagsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeTagsRequest) SetResourceOwnerId(v int64) *DescribeTagsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeTagsRequest) SetTags(v string) *DescribeTagsRequest {
	s.Tags = &v
	return s
}

type DescribeTagsResponseBody struct {
	// The number of the returned page. Minimum value: 1. Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// Default value: 50. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// A list of tags.
	TagSets *DescribeTagsResponseBodyTagSets `json:"TagSets,omitempty" xml:"TagSets,omitempty" type:"Struct"`
	// The number of instances returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeTagsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeTagsResponseBody) SetPageNumber(v int32) *DescribeTagsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeTagsResponseBody) SetPageSize(v int32) *DescribeTagsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeTagsResponseBody) SetRequestId(v string) *DescribeTagsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeTagsResponseBody) SetTagSets(v *DescribeTagsResponseBodyTagSets) *DescribeTagsResponseBody {
	s.TagSets = v
	return s
}

func (s *DescribeTagsResponseBody) SetTotalCount(v int32) *DescribeTagsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeTagsResponseBodyTagSets struct {
	TagSet []*DescribeTagsResponseBodyTagSetsTagSet `json:"TagSet,omitempty" xml:"TagSet,omitempty" type:"Repeated"`
}

func (s DescribeTagsResponseBodyTagSets) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagsResponseBodyTagSets) GoString() string {
	return s.String()
}

func (s *DescribeTagsResponseBodyTagSets) SetTagSet(v []*DescribeTagsResponseBodyTagSetsTagSet) *DescribeTagsResponseBodyTagSets {
	s.TagSet = v
	return s
}

type DescribeTagsResponseBodyTagSetsTagSet struct {
	// The number of instances to which the tag is added.
	InstanceCount *int32 `json:"InstanceCount,omitempty" xml:"InstanceCount,omitempty"`
	// The tag key.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The tag value.
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s DescribeTagsResponseBodyTagSetsTagSet) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagsResponseBodyTagSetsTagSet) GoString() string {
	return s.String()
}

func (s *DescribeTagsResponseBodyTagSetsTagSet) SetInstanceCount(v int32) *DescribeTagsResponseBodyTagSetsTagSet {
	s.InstanceCount = &v
	return s
}

func (s *DescribeTagsResponseBodyTagSetsTagSet) SetTagKey(v string) *DescribeTagsResponseBodyTagSetsTagSet {
	s.TagKey = &v
	return s
}

func (s *DescribeTagsResponseBodyTagSetsTagSet) SetTagValue(v string) *DescribeTagsResponseBodyTagSetsTagSet {
	s.TagValue = &v
	return s
}

type DescribeTagsResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeTagsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeTagsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeTagsResponse) GoString() string {
	return s.String()
}

func (s *DescribeTagsResponse) SetHeaders(v map[string]*string) *DescribeTagsResponse {
	s.Headers = v
	return s
}

func (s *DescribeTagsResponse) SetStatusCode(v int32) *DescribeTagsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeTagsResponse) SetBody(v *DescribeTagsResponseBody) *DescribeTagsResponse {
	s.Body = v
	return s
}

type DescribeVServerGroupAttributeRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the vServer group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The operation that you want to perform. Set the value to **DescribeVServerGroupAttribute**.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
}

func (s DescribeVServerGroupAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVServerGroupAttributeRequest) GoString() string {
	return s.String()
}

func (s *DescribeVServerGroupAttributeRequest) SetOwnerAccount(v string) *DescribeVServerGroupAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeVServerGroupAttributeRequest) SetOwnerId(v int64) *DescribeVServerGroupAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVServerGroupAttributeRequest) SetRegionId(v string) *DescribeVServerGroupAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeVServerGroupAttributeRequest) SetResourceOwnerAccount(v string) *DescribeVServerGroupAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeVServerGroupAttributeRequest) SetResourceOwnerId(v int64) *DescribeVServerGroupAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeVServerGroupAttributeRequest) SetVServerGroupId(v string) *DescribeVServerGroupAttributeRequest {
	s.VServerGroupId = &v
	return s
}

type DescribeVServerGroupAttributeResponseBody struct {
	// The name of the vServer group.
	BackendServers *DescribeVServerGroupAttributeResponseBodyBackendServers `json:"BackendServers,omitempty" xml:"BackendServers,omitempty" type:"Struct"`
	CreateTime     *string                                                  `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the CLB instance.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// The region ID of the Classic Load Balancer (CLB) instance.
	RequestId *string                                        `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Tags      *DescribeVServerGroupAttributeResponseBodyTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The port used by the backend server.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
	// The IP address of the ECS instance, ENI, or elastic container instance.
	VServerGroupName *string `json:"VServerGroupName,omitempty" xml:"VServerGroupName,omitempty"`
}

func (s DescribeVServerGroupAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVServerGroupAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVServerGroupAttributeResponseBody) SetBackendServers(v *DescribeVServerGroupAttributeResponseBodyBackendServers) *DescribeVServerGroupAttributeResponseBody {
	s.BackendServers = v
	return s
}

func (s *DescribeVServerGroupAttributeResponseBody) SetCreateTime(v string) *DescribeVServerGroupAttributeResponseBody {
	s.CreateTime = &v
	return s
}

func (s *DescribeVServerGroupAttributeResponseBody) SetLoadBalancerId(v string) *DescribeVServerGroupAttributeResponseBody {
	s.LoadBalancerId = &v
	return s
}

func (s *DescribeVServerGroupAttributeResponseBody) SetRequestId(v string) *DescribeVServerGroupAttributeResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVServerGroupAttributeResponseBody) SetTags(v *DescribeVServerGroupAttributeResponseBodyTags) *DescribeVServerGroupAttributeResponseBody {
	s.Tags = v
	return s
}

func (s *DescribeVServerGroupAttributeResponseBody) SetVServerGroupId(v string) *DescribeVServerGroupAttributeResponseBody {
	s.VServerGroupId = &v
	return s
}

func (s *DescribeVServerGroupAttributeResponseBody) SetVServerGroupName(v string) *DescribeVServerGroupAttributeResponseBody {
	s.VServerGroupName = &v
	return s
}

type DescribeVServerGroupAttributeResponseBodyBackendServers struct {
	BackendServer []*DescribeVServerGroupAttributeResponseBodyBackendServersBackendServer `json:"BackendServer,omitempty" xml:"BackendServer,omitempty" type:"Repeated"`
}

func (s DescribeVServerGroupAttributeResponseBodyBackendServers) String() string {
	return tea.Prettify(s)
}

func (s DescribeVServerGroupAttributeResponseBodyBackendServers) GoString() string {
	return s.String()
}

func (s *DescribeVServerGroupAttributeResponseBodyBackendServers) SetBackendServer(v []*DescribeVServerGroupAttributeResponseBodyBackendServersBackendServer) *DescribeVServerGroupAttributeResponseBodyBackendServers {
	s.BackendServer = v
	return s
}

type DescribeVServerGroupAttributeResponseBodyBackendServersBackendServer struct {
	// The ID of the request.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	Port        *int32  `json:"Port,omitempty" xml:"Port,omitempty"`
	ServerId    *string `json:"ServerId,omitempty" xml:"ServerId,omitempty"`
	ServerIp    *string `json:"ServerIp,omitempty" xml:"ServerIp,omitempty"`
	// The type of the backend server. Valid values:
	//
	// *   **ecs** (default): an Elastic Compute Service (ECS) instance
	// *   **eni**: an elastic network interface (ENI)
	// *   **eci**: an elastic container instance
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The list of backend servers.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeVServerGroupAttributeResponseBodyBackendServersBackendServer) String() string {
	return tea.Prettify(s)
}

func (s DescribeVServerGroupAttributeResponseBodyBackendServersBackendServer) GoString() string {
	return s.String()
}

func (s *DescribeVServerGroupAttributeResponseBodyBackendServersBackendServer) SetDescription(v string) *DescribeVServerGroupAttributeResponseBodyBackendServersBackendServer {
	s.Description = &v
	return s
}

func (s *DescribeVServerGroupAttributeResponseBodyBackendServersBackendServer) SetPort(v int32) *DescribeVServerGroupAttributeResponseBodyBackendServersBackendServer {
	s.Port = &v
	return s
}

func (s *DescribeVServerGroupAttributeResponseBodyBackendServersBackendServer) SetServerId(v string) *DescribeVServerGroupAttributeResponseBodyBackendServersBackendServer {
	s.ServerId = &v
	return s
}

func (s *DescribeVServerGroupAttributeResponseBodyBackendServersBackendServer) SetServerIp(v string) *DescribeVServerGroupAttributeResponseBodyBackendServersBackendServer {
	s.ServerIp = &v
	return s
}

func (s *DescribeVServerGroupAttributeResponseBodyBackendServersBackendServer) SetType(v string) *DescribeVServerGroupAttributeResponseBodyBackendServersBackendServer {
	s.Type = &v
	return s
}

func (s *DescribeVServerGroupAttributeResponseBodyBackendServersBackendServer) SetWeight(v int32) *DescribeVServerGroupAttributeResponseBodyBackendServersBackendServer {
	s.Weight = &v
	return s
}

type DescribeVServerGroupAttributeResponseBodyTags struct {
	Tag []*DescribeVServerGroupAttributeResponseBodyTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeVServerGroupAttributeResponseBodyTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeVServerGroupAttributeResponseBodyTags) GoString() string {
	return s.String()
}

func (s *DescribeVServerGroupAttributeResponseBodyTags) SetTag(v []*DescribeVServerGroupAttributeResponseBodyTagsTag) *DescribeVServerGroupAttributeResponseBodyTags {
	s.Tag = v
	return s
}

type DescribeVServerGroupAttributeResponseBodyTagsTag struct {
	TagKey   *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s DescribeVServerGroupAttributeResponseBodyTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeVServerGroupAttributeResponseBodyTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeVServerGroupAttributeResponseBodyTagsTag) SetTagKey(v string) *DescribeVServerGroupAttributeResponseBodyTagsTag {
	s.TagKey = &v
	return s
}

func (s *DescribeVServerGroupAttributeResponseBodyTagsTag) SetTagValue(v string) *DescribeVServerGroupAttributeResponseBodyTagsTag {
	s.TagValue = &v
	return s
}

type DescribeVServerGroupAttributeResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVServerGroupAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVServerGroupAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVServerGroupAttributeResponse) GoString() string {
	return s.String()
}

func (s *DescribeVServerGroupAttributeResponse) SetHeaders(v map[string]*string) *DescribeVServerGroupAttributeResponse {
	s.Headers = v
	return s
}

func (s *DescribeVServerGroupAttributeResponse) SetStatusCode(v int32) *DescribeVServerGroupAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVServerGroupAttributeResponse) SetBody(v *DescribeVServerGroupAttributeResponseBody) *DescribeVServerGroupAttributeResponse {
	s.Body = v
	return s
}

type DescribeVServerGroupsRequest struct {
	// The ID of the server group.
	IncludeListener *bool `json:"IncludeListener,omitempty" xml:"IncludeListener,omitempty"`
	// The region ID of the Classic Load Balancer (CLB) instance.
	//
	// You can call the [DescribeRegions](~~27584~~) operation to query the most recent region list.
	IncludeRule *bool `json:"IncludeRule,omitempty" xml:"IncludeRule,omitempty"`
	// The operation that you want to perform. Set the value to **DescribeVServerGroups**.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The items associated with the server groups.
	RegionId             *string                            `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string                            `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                             `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tag                  []*DescribeVServerGroupsRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeVServerGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVServerGroupsRequest) GoString() string {
	return s.String()
}

func (s *DescribeVServerGroupsRequest) SetIncludeListener(v bool) *DescribeVServerGroupsRequest {
	s.IncludeListener = &v
	return s
}

func (s *DescribeVServerGroupsRequest) SetIncludeRule(v bool) *DescribeVServerGroupsRequest {
	s.IncludeRule = &v
	return s
}

func (s *DescribeVServerGroupsRequest) SetLoadBalancerId(v string) *DescribeVServerGroupsRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *DescribeVServerGroupsRequest) SetOwnerAccount(v string) *DescribeVServerGroupsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeVServerGroupsRequest) SetOwnerId(v int64) *DescribeVServerGroupsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVServerGroupsRequest) SetRegionId(v string) *DescribeVServerGroupsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeVServerGroupsRequest) SetResourceOwnerAccount(v string) *DescribeVServerGroupsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeVServerGroupsRequest) SetResourceOwnerId(v int64) *DescribeVServerGroupsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeVServerGroupsRequest) SetTag(v []*DescribeVServerGroupsRequestTag) *DescribeVServerGroupsRequest {
	s.Tag = v
	return s
}

type DescribeVServerGroupsRequestTag struct {
}

func (s DescribeVServerGroupsRequestTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeVServerGroupsRequestTag) GoString() string {
	return s.String()
}

type DescribeVServerGroupsResponseBody struct {
	// The listening port.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The name of the server group.
	VServerGroups *DescribeVServerGroupsResponseBodyVServerGroups `json:"VServerGroups,omitempty" xml:"VServerGroups,omitempty" type:"Struct"`
}

func (s DescribeVServerGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVServerGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVServerGroupsResponseBody) SetRequestId(v string) *DescribeVServerGroupsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVServerGroupsResponseBody) SetVServerGroups(v *DescribeVServerGroupsResponseBodyVServerGroups) *DescribeVServerGroupsResponseBody {
	s.VServerGroups = v
	return s
}

type DescribeVServerGroupsResponseBodyVServerGroups struct {
	VServerGroup []*DescribeVServerGroupsResponseBodyVServerGroupsVServerGroup `json:"VServerGroup,omitempty" xml:"VServerGroup,omitempty" type:"Repeated"`
}

func (s DescribeVServerGroupsResponseBodyVServerGroups) String() string {
	return tea.Prettify(s)
}

func (s DescribeVServerGroupsResponseBodyVServerGroups) GoString() string {
	return s.String()
}

func (s *DescribeVServerGroupsResponseBodyVServerGroups) SetVServerGroup(v []*DescribeVServerGroupsResponseBodyVServerGroupsVServerGroup) *DescribeVServerGroupsResponseBodyVServerGroups {
	s.VServerGroup = v
	return s
}

type DescribeVServerGroupsResponseBodyVServerGroupsVServerGroup struct {
	// The ID of the request.
	AssociatedObjects *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjects `json:"AssociatedObjects,omitempty" xml:"AssociatedObjects,omitempty" type:"Struct"`
	CreateTime        *string                                                                      `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	ServerCount       *int64                                                                       `json:"ServerCount,omitempty" xml:"ServerCount,omitempty"`
	Tags              *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupTags              `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// Specifies whether to return information about the associated listeners. Valid values:
	//
	// *   **true**: yes
	// *   **false** (default): no
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
	// The list of backend servers.
	VServerGroupName *string `json:"VServerGroupName,omitempty" xml:"VServerGroupName,omitempty"`
}

func (s DescribeVServerGroupsResponseBodyVServerGroupsVServerGroup) String() string {
	return tea.Prettify(s)
}

func (s DescribeVServerGroupsResponseBodyVServerGroupsVServerGroup) GoString() string {
	return s.String()
}

func (s *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroup) SetAssociatedObjects(v *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjects) *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroup {
	s.AssociatedObjects = v
	return s
}

func (s *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroup) SetCreateTime(v string) *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroup {
	s.CreateTime = &v
	return s
}

func (s *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroup) SetServerCount(v int64) *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroup {
	s.ServerCount = &v
	return s
}

func (s *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroup) SetTags(v *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupTags) *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroup {
	s.Tags = v
	return s
}

func (s *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroup) SetVServerGroupId(v string) *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroup {
	s.VServerGroupId = &v
	return s
}

func (s *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroup) SetVServerGroupName(v string) *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroup {
	s.VServerGroupName = &v
	return s
}

type DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjects struct {
	// Queries server groups of a Classic Load Balancer (CLB) instance.
	Listeners *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsListeners `json:"Listeners,omitempty" xml:"Listeners,omitempty" type:"Struct"`
	Rules     *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsRules     `json:"Rules,omitempty" xml:"Rules,omitempty" type:"Struct"`
}

func (s DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjects) String() string {
	return tea.Prettify(s)
}

func (s DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjects) GoString() string {
	return s.String()
}

func (s *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjects) SetListeners(v *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsListeners) *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjects {
	s.Listeners = v
	return s
}

func (s *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjects) SetRules(v *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsRules) *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjects {
	s.Rules = v
	return s
}

type DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsListeners struct {
	Listener []*DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsListenersListener `json:"Listener,omitempty" xml:"Listener,omitempty" type:"Repeated"`
}

func (s DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsListeners) String() string {
	return tea.Prettify(s)
}

func (s DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsListeners) GoString() string {
	return s.String()
}

func (s *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsListeners) SetListener(v []*DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsListenersListener) *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsListeners {
	s.Listener = v
	return s
}

type DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsListenersListener struct {
	Port     *int32  `json:"Port,omitempty" xml:"Port,omitempty"`
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
}

func (s DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsListenersListener) String() string {
	return tea.Prettify(s)
}

func (s DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsListenersListener) GoString() string {
	return s.String()
}

func (s *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsListenersListener) SetPort(v int32) *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsListenersListener {
	s.Port = &v
	return s
}

func (s *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsListenersListener) SetProtocol(v string) *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsListenersListener {
	s.Protocol = &v
	return s
}

type DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsRules struct {
	Rule []*DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsRulesRule `json:"Rule,omitempty" xml:"Rule,omitempty" type:"Repeated"`
}

func (s DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsRules) String() string {
	return tea.Prettify(s)
}

func (s DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsRules) GoString() string {
	return s.String()
}

func (s *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsRules) SetRule(v []*DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsRulesRule) *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsRules {
	s.Rule = v
	return s
}

type DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsRulesRule struct {
	Domain   *string `json:"Domain,omitempty" xml:"Domain,omitempty"`
	RuleId   *string `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	Url      *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsRulesRule) String() string {
	return tea.Prettify(s)
}

func (s DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsRulesRule) GoString() string {
	return s.String()
}

func (s *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsRulesRule) SetDomain(v string) *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsRulesRule {
	s.Domain = &v
	return s
}

func (s *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsRulesRule) SetRuleId(v string) *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsRulesRule {
	s.RuleId = &v
	return s
}

func (s *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsRulesRule) SetRuleName(v string) *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsRulesRule {
	s.RuleName = &v
	return s
}

func (s *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsRulesRule) SetUrl(v string) *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupAssociatedObjectsRulesRule {
	s.Url = &v
	return s
}

type DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupTags struct {
	Tag []*DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupTags) GoString() string {
	return s.String()
}

func (s *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupTags) SetTag(v []*DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupTagsTag) *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupTags {
	s.Tag = v
	return s
}

type DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupTagsTag struct {
	TagKey   *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupTagsTag) SetTagKey(v string) *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupTagsTag {
	s.TagKey = &v
	return s
}

func (s *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupTagsTag) SetTagValue(v string) *DescribeVServerGroupsResponseBodyVServerGroupsVServerGroupTagsTag {
	s.TagValue = &v
	return s
}

type DescribeVServerGroupsResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVServerGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVServerGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVServerGroupsResponse) GoString() string {
	return s.String()
}

func (s *DescribeVServerGroupsResponse) SetHeaders(v map[string]*string) *DescribeVServerGroupsResponse {
	s.Headers = v
	return s
}

func (s *DescribeVServerGroupsResponse) SetStatusCode(v int32) *DescribeVServerGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVServerGroupsResponse) SetBody(v *DescribeVServerGroupsResponseBody) *DescribeVServerGroupsResponse {
	s.Body = v
	return s
}

type DescribeZonesRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the request.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeZonesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeZonesRequest) GoString() string {
	return s.String()
}

func (s *DescribeZonesRequest) SetOwnerAccount(v string) *DescribeZonesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeZonesRequest) SetOwnerId(v int64) *DescribeZonesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeZonesRequest) SetRegionId(v string) *DescribeZonesRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeZonesRequest) SetResourceOwnerAccount(v string) *DescribeZonesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeZonesRequest) SetResourceOwnerId(v int64) *DescribeZonesRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeZonesResponseBody struct {
	// The list of zones.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the zone.
	Zones *DescribeZonesResponseBodyZones `json:"Zones,omitempty" xml:"Zones,omitempty" type:"Struct"`
}

func (s DescribeZonesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeZonesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeZonesResponseBody) SetRequestId(v string) *DescribeZonesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeZonesResponseBody) SetZones(v *DescribeZonesResponseBodyZones) *DescribeZonesResponseBody {
	s.Zones = v
	return s
}

type DescribeZonesResponseBodyZones struct {
	Zone []*DescribeZonesResponseBodyZonesZone `json:"Zone,omitempty" xml:"Zone,omitempty" type:"Repeated"`
}

func (s DescribeZonesResponseBodyZones) String() string {
	return tea.Prettify(s)
}

func (s DescribeZonesResponseBodyZones) GoString() string {
	return s.String()
}

func (s *DescribeZonesResponseBodyZones) SetZone(v []*DescribeZonesResponseBodyZonesZone) *DescribeZonesResponseBodyZones {
	s.Zone = v
	return s
}

type DescribeZonesResponseBodyZonesZone struct {
	// Hangzhou Zone B
	LocalName *string `json:"LocalName,omitempty" xml:"LocalName,omitempty"`
	// The ID of the secondary zone.
	SlaveZones *DescribeZonesResponseBodyZonesZoneSlaveZones `json:"SlaveZones,omitempty" xml:"SlaveZones,omitempty" type:"Struct"`
	// The name of the zone.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribeZonesResponseBodyZonesZone) String() string {
	return tea.Prettify(s)
}

func (s DescribeZonesResponseBodyZonesZone) GoString() string {
	return s.String()
}

func (s *DescribeZonesResponseBodyZonesZone) SetLocalName(v string) *DescribeZonesResponseBodyZonesZone {
	s.LocalName = &v
	return s
}

func (s *DescribeZonesResponseBodyZonesZone) SetSlaveZones(v *DescribeZonesResponseBodyZonesZoneSlaveZones) *DescribeZonesResponseBodyZonesZone {
	s.SlaveZones = v
	return s
}

func (s *DescribeZonesResponseBodyZonesZone) SetZoneId(v string) *DescribeZonesResponseBodyZonesZone {
	s.ZoneId = &v
	return s
}

type DescribeZonesResponseBodyZonesZoneSlaveZones struct {
	SlaveZone []*DescribeZonesResponseBodyZonesZoneSlaveZonesSlaveZone `json:"SlaveZone,omitempty" xml:"SlaveZone,omitempty" type:"Repeated"`
}

func (s DescribeZonesResponseBodyZonesZoneSlaveZones) String() string {
	return tea.Prettify(s)
}

func (s DescribeZonesResponseBodyZonesZoneSlaveZones) GoString() string {
	return s.String()
}

func (s *DescribeZonesResponseBodyZonesZoneSlaveZones) SetSlaveZone(v []*DescribeZonesResponseBodyZonesZoneSlaveZonesSlaveZone) *DescribeZonesResponseBodyZonesZoneSlaveZones {
	s.SlaveZone = v
	return s
}

type DescribeZonesResponseBodyZonesZoneSlaveZonesSlaveZone struct {
	// Hangzhou Zone G
	LocalName *string `json:"LocalName,omitempty" xml:"LocalName,omitempty"`
	// The name of the secondary zone.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s DescribeZonesResponseBodyZonesZoneSlaveZonesSlaveZone) String() string {
	return tea.Prettify(s)
}

func (s DescribeZonesResponseBodyZonesZoneSlaveZonesSlaveZone) GoString() string {
	return s.String()
}

func (s *DescribeZonesResponseBodyZonesZoneSlaveZonesSlaveZone) SetLocalName(v string) *DescribeZonesResponseBodyZonesZoneSlaveZonesSlaveZone {
	s.LocalName = &v
	return s
}

func (s *DescribeZonesResponseBodyZonesZoneSlaveZonesSlaveZone) SetZoneId(v string) *DescribeZonesResponseBodyZonesZoneSlaveZonesSlaveZone {
	s.ZoneId = &v
	return s
}

type DescribeZonesResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeZonesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeZonesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeZonesResponse) GoString() string {
	return s.String()
}

func (s *DescribeZonesResponse) SetHeaders(v map[string]*string) *DescribeZonesResponse {
	s.Headers = v
	return s
}

func (s *DescribeZonesResponse) SetStatusCode(v int32) *DescribeZonesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeZonesResponse) SetBody(v *DescribeZonesResponseBody) *DescribeZonesResponse {
	s.Body = v
	return s
}

type EnableHighDefinationMonitorRequest struct {
	// The ID of the request.
	LogProject *string `json:"LogProject,omitempty" xml:"LogProject,omitempty"`
	// The operation that you want to perform. Set the value to **EnableHighDefinationMonitor**.
	LogStore     *string `json:"LogStore,omitempty" xml:"LogStore,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The name of the Logstore of Log Service. The name must be 2 to 64 characters in length and can contain digits, lowercase letters, hyphens (-) and underscores (\_). It must start and end with a digit or a letter.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The name of the project of Log Service. The name must be 4 to 63 characters in length, and can contain digits and lowercase letters. It must start and end with a digit or a letter.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s EnableHighDefinationMonitorRequest) String() string {
	return tea.Prettify(s)
}

func (s EnableHighDefinationMonitorRequest) GoString() string {
	return s.String()
}

func (s *EnableHighDefinationMonitorRequest) SetLogProject(v string) *EnableHighDefinationMonitorRequest {
	s.LogProject = &v
	return s
}

func (s *EnableHighDefinationMonitorRequest) SetLogStore(v string) *EnableHighDefinationMonitorRequest {
	s.LogStore = &v
	return s
}

func (s *EnableHighDefinationMonitorRequest) SetOwnerAccount(v string) *EnableHighDefinationMonitorRequest {
	s.OwnerAccount = &v
	return s
}

func (s *EnableHighDefinationMonitorRequest) SetOwnerId(v int64) *EnableHighDefinationMonitorRequest {
	s.OwnerId = &v
	return s
}

func (s *EnableHighDefinationMonitorRequest) SetRegionId(v string) *EnableHighDefinationMonitorRequest {
	s.RegionId = &v
	return s
}

func (s *EnableHighDefinationMonitorRequest) SetResourceOwnerAccount(v string) *EnableHighDefinationMonitorRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *EnableHighDefinationMonitorRequest) SetResourceOwnerId(v int64) *EnableHighDefinationMonitorRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *EnableHighDefinationMonitorRequest) SetTags(v string) *EnableHighDefinationMonitorRequest {
	s.Tags = &v
	return s
}

type EnableHighDefinationMonitorResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s EnableHighDefinationMonitorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EnableHighDefinationMonitorResponseBody) GoString() string {
	return s.String()
}

func (s *EnableHighDefinationMonitorResponseBody) SetRequestId(v string) *EnableHighDefinationMonitorResponseBody {
	s.RequestId = &v
	return s
}

func (s *EnableHighDefinationMonitorResponseBody) SetSuccess(v string) *EnableHighDefinationMonitorResponseBody {
	s.Success = &v
	return s
}

type EnableHighDefinationMonitorResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *EnableHighDefinationMonitorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s EnableHighDefinationMonitorResponse) String() string {
	return tea.Prettify(s)
}

func (s EnableHighDefinationMonitorResponse) GoString() string {
	return s.String()
}

func (s *EnableHighDefinationMonitorResponse) SetHeaders(v map[string]*string) *EnableHighDefinationMonitorResponse {
	s.Headers = v
	return s
}

func (s *EnableHighDefinationMonitorResponse) SetStatusCode(v int32) *EnableHighDefinationMonitorResponse {
	s.StatusCode = &v
	return s
}

func (s *EnableHighDefinationMonitorResponse) SetBody(v *EnableHighDefinationMonitorResponseBody) *EnableHighDefinationMonitorResponse {
	s.Body = v
	return s
}

type ListTLSCipherPoliciesRequest struct {
	// The name of the TLS policy. The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). The name must start with a letter.
	IncludeListener *bool `json:"IncludeListener,omitempty" xml:"IncludeListener,omitempty"`
	// The timestamp generated when the TLS policy is created.
	MaxItems *int32 `json:"MaxItems,omitempty" xml:"MaxItems,omitempty"`
	// The status of the TLS policy. Valid values:
	//
	// *   **configuring**: The TLS policy is being configured.
	// *   **normal**: The TLS policy works as expected.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the TLS policy.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The list of TLS policies.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the TLS policy.
	TLSCipherPolicyId *string `json:"TLSCipherPolicyId,omitempty" xml:"TLSCipherPolicyId,omitempty"`
}

func (s ListTLSCipherPoliciesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTLSCipherPoliciesRequest) GoString() string {
	return s.String()
}

func (s *ListTLSCipherPoliciesRequest) SetIncludeListener(v bool) *ListTLSCipherPoliciesRequest {
	s.IncludeListener = &v
	return s
}

func (s *ListTLSCipherPoliciesRequest) SetMaxItems(v int32) *ListTLSCipherPoliciesRequest {
	s.MaxItems = &v
	return s
}

func (s *ListTLSCipherPoliciesRequest) SetName(v string) *ListTLSCipherPoliciesRequest {
	s.Name = &v
	return s
}

func (s *ListTLSCipherPoliciesRequest) SetNextToken(v string) *ListTLSCipherPoliciesRequest {
	s.NextToken = &v
	return s
}

func (s *ListTLSCipherPoliciesRequest) SetOwnerAccount(v string) *ListTLSCipherPoliciesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListTLSCipherPoliciesRequest) SetOwnerId(v int64) *ListTLSCipherPoliciesRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTLSCipherPoliciesRequest) SetRegionId(v string) *ListTLSCipherPoliciesRequest {
	s.RegionId = &v
	return s
}

func (s *ListTLSCipherPoliciesRequest) SetResourceOwnerAccount(v string) *ListTLSCipherPoliciesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTLSCipherPoliciesRequest) SetResourceOwnerId(v int64) *ListTLSCipherPoliciesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListTLSCipherPoliciesRequest) SetTLSCipherPolicyId(v string) *ListTLSCipherPoliciesRequest {
	s.TLSCipherPolicyId = &v
	return s
}

type ListTLSCipherPoliciesResponseBody struct {
	// The maximum number of TLS policies to be queried in this call. Valid values: **1** to **100**. If you do not set this parameter, the default value **20** is used.
	IsTruncated *bool `json:"IsTruncated,omitempty" xml:"IsTruncated,omitempty"`
	// The operation that you want to perform. Set the value to **ListTLSCipherPolicies**.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The token that is used for the next query. Valid values:
	//
	// *   If this is your first query or no next query is to be sent, ignore this parameter.
	// *   If a next query is to be sent, set the value to the value of NextToken that is returned from the last call.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the region where the Classic Load Balancer (CLB) instance is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	TLSCipherPolicies []*ListTLSCipherPoliciesResponseBodyTLSCipherPolicies `json:"TLSCipherPolicies,omitempty" xml:"TLSCipherPolicies,omitempty" type:"Repeated"`
	// The ID of the CLB instance.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListTLSCipherPoliciesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTLSCipherPoliciesResponseBody) GoString() string {
	return s.String()
}

func (s *ListTLSCipherPoliciesResponseBody) SetIsTruncated(v bool) *ListTLSCipherPoliciesResponseBody {
	s.IsTruncated = &v
	return s
}

func (s *ListTLSCipherPoliciesResponseBody) SetNextToken(v string) *ListTLSCipherPoliciesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTLSCipherPoliciesResponseBody) SetRequestId(v string) *ListTLSCipherPoliciesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTLSCipherPoliciesResponseBody) SetTLSCipherPolicies(v []*ListTLSCipherPoliciesResponseBodyTLSCipherPolicies) *ListTLSCipherPoliciesResponseBody {
	s.TLSCipherPolicies = v
	return s
}

func (s *ListTLSCipherPoliciesResponseBody) SetTotalCount(v int32) *ListTLSCipherPoliciesResponseBody {
	s.TotalCount = &v
	return s
}

type ListTLSCipherPoliciesResponseBodyTLSCipherPolicies struct {
	Ciphers []*string `json:"Ciphers,omitempty" xml:"Ciphers,omitempty" type:"Repeated"`
	// The listening port. Valid values: **1** to **65535**.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The listening protocol. Valid values:
	//
	// *   **TCP**
	// *   **UDP**
	// *   **HTTP**
	// *   **HTTPS**
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The list of associated listeners.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Specifies whether to return the information about the associated listeners. Valid values:
	//
	// *   **true**: returns the information about the associated listeners.
	// *   **false** (default): does not return the information about the associated listeners.
	RelateListeners []*ListTLSCipherPoliciesResponseBodyTLSCipherPoliciesRelateListeners `json:"RelateListeners,omitempty" xml:"RelateListeners,omitempty" type:"Repeated"`
	// Indicates whether the current page is the last page. Valid values:
	//
	// *   **true**: The current page is the last page.
	// *   **false**: The current page is not the last page.
	Status      *string   `json:"Status,omitempty" xml:"Status,omitempty"`
	TLSVersions []*string `json:"TLSVersions,omitempty" xml:"TLSVersions,omitempty" type:"Repeated"`
}

func (s ListTLSCipherPoliciesResponseBodyTLSCipherPolicies) String() string {
	return tea.Prettify(s)
}

func (s ListTLSCipherPoliciesResponseBodyTLSCipherPolicies) GoString() string {
	return s.String()
}

func (s *ListTLSCipherPoliciesResponseBodyTLSCipherPolicies) SetCiphers(v []*string) *ListTLSCipherPoliciesResponseBodyTLSCipherPolicies {
	s.Ciphers = v
	return s
}

func (s *ListTLSCipherPoliciesResponseBodyTLSCipherPolicies) SetCreateTime(v int64) *ListTLSCipherPoliciesResponseBodyTLSCipherPolicies {
	s.CreateTime = &v
	return s
}

func (s *ListTLSCipherPoliciesResponseBodyTLSCipherPolicies) SetInstanceId(v string) *ListTLSCipherPoliciesResponseBodyTLSCipherPolicies {
	s.InstanceId = &v
	return s
}

func (s *ListTLSCipherPoliciesResponseBodyTLSCipherPolicies) SetName(v string) *ListTLSCipherPoliciesResponseBodyTLSCipherPolicies {
	s.Name = &v
	return s
}

func (s *ListTLSCipherPoliciesResponseBodyTLSCipherPolicies) SetRelateListeners(v []*ListTLSCipherPoliciesResponseBodyTLSCipherPoliciesRelateListeners) *ListTLSCipherPoliciesResponseBodyTLSCipherPolicies {
	s.RelateListeners = v
	return s
}

func (s *ListTLSCipherPoliciesResponseBodyTLSCipherPolicies) SetStatus(v string) *ListTLSCipherPoliciesResponseBodyTLSCipherPolicies {
	s.Status = &v
	return s
}

func (s *ListTLSCipherPoliciesResponseBodyTLSCipherPolicies) SetTLSVersions(v []*string) *ListTLSCipherPoliciesResponseBodyTLSCipherPolicies {
	s.TLSVersions = v
	return s
}

type ListTLSCipherPoliciesResponseBodyTLSCipherPoliciesRelateListeners struct {
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// The name of the TLS policy.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The ID of the request.
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
}

func (s ListTLSCipherPoliciesResponseBodyTLSCipherPoliciesRelateListeners) String() string {
	return tea.Prettify(s)
}

func (s ListTLSCipherPoliciesResponseBodyTLSCipherPoliciesRelateListeners) GoString() string {
	return s.String()
}

func (s *ListTLSCipherPoliciesResponseBodyTLSCipherPoliciesRelateListeners) SetLoadBalancerId(v string) *ListTLSCipherPoliciesResponseBodyTLSCipherPoliciesRelateListeners {
	s.LoadBalancerId = &v
	return s
}

func (s *ListTLSCipherPoliciesResponseBodyTLSCipherPoliciesRelateListeners) SetPort(v int32) *ListTLSCipherPoliciesResponseBodyTLSCipherPoliciesRelateListeners {
	s.Port = &v
	return s
}

func (s *ListTLSCipherPoliciesResponseBodyTLSCipherPoliciesRelateListeners) SetProtocol(v string) *ListTLSCipherPoliciesResponseBodyTLSCipherPoliciesRelateListeners {
	s.Protocol = &v
	return s
}

type ListTLSCipherPoliciesResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTLSCipherPoliciesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTLSCipherPoliciesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTLSCipherPoliciesResponse) GoString() string {
	return s.String()
}

func (s *ListTLSCipherPoliciesResponse) SetHeaders(v map[string]*string) *ListTLSCipherPoliciesResponse {
	s.Headers = v
	return s
}

func (s *ListTLSCipherPoliciesResponse) SetStatusCode(v int32) *ListTLSCipherPoliciesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTLSCipherPoliciesResponse) SetBody(v *ListTLSCipherPoliciesResponseBody) *ListTLSCipherPoliciesResponse {
	s.Body = v
	return s
}

type ListTagResourcesRequest struct {
	// The token that determines the start point of the query. Valid values:
	//
	// *   If this is your first query or no subsequent query is to be sent, ignore this parameter.
	// *   If a subsequent query is to be sent, set the parameter to the value of NextToken that is returned from the last call.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the Server Load Balancer (SLB) instance is created.
	//
	// You can call the [DescribeRegions](~~27584~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of a resource. You can specify up to 20 resources.
	ResourceId           []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the resource. Valid values:
	//
	// *   **instance**: an SLB instance
	// *   **certificate**: a certificate
	// *   **acl**: a network access control list (ACL)
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tags.
	Tag []*ListTagResourcesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s ListTagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesRequest) GoString() string {
	return s.String()
}

func (s *ListTagResourcesRequest) SetNextToken(v string) *ListTagResourcesRequest {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesRequest) SetOwnerAccount(v string) *ListTagResourcesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListTagResourcesRequest) SetOwnerId(v int64) *ListTagResourcesRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTagResourcesRequest) SetRegionId(v string) *ListTagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *ListTagResourcesRequest) SetResourceId(v []*string) *ListTagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *ListTagResourcesRequest) SetResourceOwnerAccount(v string) *ListTagResourcesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTagResourcesRequest) SetResourceOwnerId(v int64) *ListTagResourcesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListTagResourcesRequest) SetResourceType(v string) *ListTagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesRequest) SetTag(v []*ListTagResourcesRequestTag) *ListTagResourcesRequest {
	s.Tag = v
	return s
}

type ListTagResourcesRequestTag struct {
	// The tag key. You can specify at most 20 tag keys.
	//
	// The tag key cannot be an empty string. The tag key must be 1 to 64 characters in length and cannot start with `aliyun` or `acs:`. It cannot contain `http://` or `https://`.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value. You can specify at most 20 tag values. The tag value cannot be an empty string.
	//
	// The tag value must be 1 to 128 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTagResourcesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesRequestTag) GoString() string {
	return s.String()
}

func (s *ListTagResourcesRequestTag) SetKey(v string) *ListTagResourcesRequestTag {
	s.Key = &v
	return s
}

func (s *ListTagResourcesRequestTag) SetValue(v string) *ListTagResourcesRequestTag {
	s.Value = &v
	return s
}

type ListTagResourcesResponseBody struct {
	// The token that determines the start point of the query. Valid values:
	//
	// *   If **NextToken** is empty, it indicates that no subsequent query is to be sent.
	// *   If a value of **NextToken** is returned, the value is the token that is used for the subsequent query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The details about the resource to which the tags are added.
	TagResources *ListTagResourcesResponseBodyTagResources `json:"TagResources,omitempty" xml:"TagResources,omitempty" type:"Struct"`
}

func (s ListTagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBody) SetNextToken(v string) *ListTagResourcesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetRequestId(v string) *ListTagResourcesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetTagResources(v *ListTagResourcesResponseBodyTagResources) *ListTagResourcesResponseBody {
	s.TagResources = v
	return s
}

type ListTagResourcesResponseBodyTagResources struct {
	TagResource []*ListTagResourcesResponseBodyTagResourcesTagResource `json:"TagResource,omitempty" xml:"TagResource,omitempty" type:"Repeated"`
}

func (s ListTagResourcesResponseBodyTagResources) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBodyTagResources) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBodyTagResources) SetTagResource(v []*ListTagResourcesResponseBodyTagResourcesTagResource) *ListTagResourcesResponseBodyTagResources {
	s.TagResource = v
	return s
}

type ListTagResourcesResponseBodyTagResourcesTagResource struct {
	// The ID of the resource.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The resource type.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tag key.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The tag value.
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s ListTagResourcesResponseBodyTagResourcesTagResource) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBodyTagResourcesTagResource) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetResourceId(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.ResourceId = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetResourceType(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetTagKey(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.TagKey = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetTagValue(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.TagValue = &v
	return s
}

type ListTagResourcesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponse) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponse) SetHeaders(v map[string]*string) *ListTagResourcesResponse {
	s.Headers = v
	return s
}

func (s *ListTagResourcesResponse) SetStatusCode(v int32) *ListTagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTagResourcesResponse) SetBody(v *ListTagResourcesResponseBody) *ListTagResourcesResponse {
	s.Body = v
	return s
}

type ModifyHighDefinationMonitorRequest struct {
	// The operation that you want to perform. Set the value to **ModifyHighDefinationMonitor**.
	LogProject *string `json:"LogProject,omitempty" xml:"LogProject,omitempty"`
	// The new name of the project of Log Service. The name must be 4 to 63 characters in length, and can contain digits and lowercase letters. It must start and end with a digit or a letter.
	LogStore     *string `json:"LogStore,omitempty" xml:"LogStore,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the request.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyHighDefinationMonitorRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyHighDefinationMonitorRequest) GoString() string {
	return s.String()
}

func (s *ModifyHighDefinationMonitorRequest) SetLogProject(v string) *ModifyHighDefinationMonitorRequest {
	s.LogProject = &v
	return s
}

func (s *ModifyHighDefinationMonitorRequest) SetLogStore(v string) *ModifyHighDefinationMonitorRequest {
	s.LogStore = &v
	return s
}

func (s *ModifyHighDefinationMonitorRequest) SetOwnerAccount(v string) *ModifyHighDefinationMonitorRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyHighDefinationMonitorRequest) SetOwnerId(v int64) *ModifyHighDefinationMonitorRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyHighDefinationMonitorRequest) SetRegionId(v string) *ModifyHighDefinationMonitorRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyHighDefinationMonitorRequest) SetResourceOwnerAccount(v string) *ModifyHighDefinationMonitorRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyHighDefinationMonitorRequest) SetResourceOwnerId(v int64) *ModifyHighDefinationMonitorRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyHighDefinationMonitorResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ModifyHighDefinationMonitorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyHighDefinationMonitorResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyHighDefinationMonitorResponseBody) SetRequestId(v string) *ModifyHighDefinationMonitorResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyHighDefinationMonitorResponseBody) SetSuccess(v string) *ModifyHighDefinationMonitorResponseBody {
	s.Success = &v
	return s
}

type ModifyHighDefinationMonitorResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyHighDefinationMonitorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyHighDefinationMonitorResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyHighDefinationMonitorResponse) GoString() string {
	return s.String()
}

func (s *ModifyHighDefinationMonitorResponse) SetHeaders(v map[string]*string) *ModifyHighDefinationMonitorResponse {
	s.Headers = v
	return s
}

func (s *ModifyHighDefinationMonitorResponse) SetStatusCode(v int32) *ModifyHighDefinationMonitorResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyHighDefinationMonitorResponse) SetBody(v *ModifyHighDefinationMonitorResponseBody) *ModifyHighDefinationMonitorResponse {
	s.Body = v
	return s
}

type ModifyLoadBalancerInstanceChargeTypeRequest struct {
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The specification of the CLB instance.
	//
	// You do not need to set this parameter. For pay-as-you-go CLB instances, you can only change the metering method from pay-by-specification to pay-by-LCU. You cannot change the metering method from pay-by-LCU to pay-by-specification.
	InstanceChargeType *string `json:"InstanceChargeType,omitempty" xml:"InstanceChargeType,omitempty"`
	// The region ID of the CLB instance.
	//
	// You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The ID of the request.
	LoadBalancerId   *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	LoadBalancerSpec *string `json:"LoadBalancerSpec,omitempty" xml:"LoadBalancerSpec,omitempty"`
	OwnerAccount     *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId          *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The metering method of Internet data transfer after the change.
	//
	// Valid value: **paybytraffic**.
	//
	// >
	//
	// *   If the value of the **InstanceChargeType** parameter is set to **PayByCLCU**, only pay-by-data-transfer is supported.
	// *   When you change the metering method, the new metering method takes effect at 00:00:00 the next day.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyLoadBalancerInstanceChargeTypeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyLoadBalancerInstanceChargeTypeRequest) GoString() string {
	return s.String()
}

func (s *ModifyLoadBalancerInstanceChargeTypeRequest) SetBandwidth(v int32) *ModifyLoadBalancerInstanceChargeTypeRequest {
	s.Bandwidth = &v
	return s
}

func (s *ModifyLoadBalancerInstanceChargeTypeRequest) SetInstanceChargeType(v string) *ModifyLoadBalancerInstanceChargeTypeRequest {
	s.InstanceChargeType = &v
	return s
}

func (s *ModifyLoadBalancerInstanceChargeTypeRequest) SetInternetChargeType(v string) *ModifyLoadBalancerInstanceChargeTypeRequest {
	s.InternetChargeType = &v
	return s
}

func (s *ModifyLoadBalancerInstanceChargeTypeRequest) SetLoadBalancerId(v string) *ModifyLoadBalancerInstanceChargeTypeRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *ModifyLoadBalancerInstanceChargeTypeRequest) SetLoadBalancerSpec(v string) *ModifyLoadBalancerInstanceChargeTypeRequest {
	s.LoadBalancerSpec = &v
	return s
}

func (s *ModifyLoadBalancerInstanceChargeTypeRequest) SetOwnerAccount(v string) *ModifyLoadBalancerInstanceChargeTypeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyLoadBalancerInstanceChargeTypeRequest) SetOwnerId(v int64) *ModifyLoadBalancerInstanceChargeTypeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyLoadBalancerInstanceChargeTypeRequest) SetRegionId(v string) *ModifyLoadBalancerInstanceChargeTypeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyLoadBalancerInstanceChargeTypeRequest) SetResourceOwnerAccount(v string) *ModifyLoadBalancerInstanceChargeTypeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyLoadBalancerInstanceChargeTypeRequest) SetResourceOwnerId(v int64) *ModifyLoadBalancerInstanceChargeTypeRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyLoadBalancerInstanceChargeTypeResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyLoadBalancerInstanceChargeTypeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyLoadBalancerInstanceChargeTypeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyLoadBalancerInstanceChargeTypeResponseBody) SetRequestId(v string) *ModifyLoadBalancerInstanceChargeTypeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyLoadBalancerInstanceChargeTypeResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyLoadBalancerInstanceChargeTypeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyLoadBalancerInstanceChargeTypeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyLoadBalancerInstanceChargeTypeResponse) GoString() string {
	return s.String()
}

func (s *ModifyLoadBalancerInstanceChargeTypeResponse) SetHeaders(v map[string]*string) *ModifyLoadBalancerInstanceChargeTypeResponse {
	s.Headers = v
	return s
}

func (s *ModifyLoadBalancerInstanceChargeTypeResponse) SetStatusCode(v int32) *ModifyLoadBalancerInstanceChargeTypeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyLoadBalancerInstanceChargeTypeResponse) SetBody(v *ModifyLoadBalancerInstanceChargeTypeResponseBody) *ModifyLoadBalancerInstanceChargeTypeResponse {
	s.Body = v
	return s
}

type ModifyLoadBalancerInstanceSpecRequest struct {
	// Specifies whether to enable automatic payment. Valid values:
	//
	// *   **true**: automatically completes the payment.
	// *   **false** (default): If you select this option, you must complete the payment in the Order Center.
	//
	// > This parameter takes effect only for subscription instances.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The ID of the CLB instance.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// The specification of the CLB instance. Valid values:
	//
	// *   **slb.s1.small**
	// *   **slb.s2.small**
	// *   **slb.s2.medium**
	// *   **slb.s3.small**
	// *   **slb.s3.medium**
	// *   **slb.s3.large**
	//
	// The specifications available vary by region. For more information about the specifications, see [High-performance CLB instance](~~85931~~).
	//
	// > When you switch a shared-resource CLB instance to a high-performance CLB instance, your service may be interrupted for 10 to 30 seconds. We recommend that you modify the specification during off-peak hours or use Alibaba Cloud DNS to schedule your workloads to another CLB instance before you modify the specification.
	LoadBalancerSpec *string `json:"LoadBalancerSpec,omitempty" xml:"LoadBalancerSpec,omitempty"`
	OwnerAccount     *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId          *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the CLB instance.
	//
	// You can query the region ID from the [Regions and zones](~~40654~~) list or by calling the [DescribeRegions](~~27584~~) operation.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyLoadBalancerInstanceSpecRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyLoadBalancerInstanceSpecRequest) GoString() string {
	return s.String()
}

func (s *ModifyLoadBalancerInstanceSpecRequest) SetAutoPay(v bool) *ModifyLoadBalancerInstanceSpecRequest {
	s.AutoPay = &v
	return s
}

func (s *ModifyLoadBalancerInstanceSpecRequest) SetLoadBalancerId(v string) *ModifyLoadBalancerInstanceSpecRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *ModifyLoadBalancerInstanceSpecRequest) SetLoadBalancerSpec(v string) *ModifyLoadBalancerInstanceSpecRequest {
	s.LoadBalancerSpec = &v
	return s
}

func (s *ModifyLoadBalancerInstanceSpecRequest) SetOwnerAccount(v string) *ModifyLoadBalancerInstanceSpecRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyLoadBalancerInstanceSpecRequest) SetOwnerId(v int64) *ModifyLoadBalancerInstanceSpecRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyLoadBalancerInstanceSpecRequest) SetRegionId(v string) *ModifyLoadBalancerInstanceSpecRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyLoadBalancerInstanceSpecRequest) SetResourceOwnerAccount(v string) *ModifyLoadBalancerInstanceSpecRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyLoadBalancerInstanceSpecRequest) SetResourceOwnerId(v int64) *ModifyLoadBalancerInstanceSpecRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyLoadBalancerInstanceSpecResponseBody struct {
	// The order ID of the subscription CLB instance.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyLoadBalancerInstanceSpecResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyLoadBalancerInstanceSpecResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyLoadBalancerInstanceSpecResponseBody) SetOrderId(v int64) *ModifyLoadBalancerInstanceSpecResponseBody {
	s.OrderId = &v
	return s
}

func (s *ModifyLoadBalancerInstanceSpecResponseBody) SetRequestId(v string) *ModifyLoadBalancerInstanceSpecResponseBody {
	s.RequestId = &v
	return s
}

type ModifyLoadBalancerInstanceSpecResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyLoadBalancerInstanceSpecResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyLoadBalancerInstanceSpecResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyLoadBalancerInstanceSpecResponse) GoString() string {
	return s.String()
}

func (s *ModifyLoadBalancerInstanceSpecResponse) SetHeaders(v map[string]*string) *ModifyLoadBalancerInstanceSpecResponse {
	s.Headers = v
	return s
}

func (s *ModifyLoadBalancerInstanceSpecResponse) SetStatusCode(v int32) *ModifyLoadBalancerInstanceSpecResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyLoadBalancerInstanceSpecResponse) SetBody(v *ModifyLoadBalancerInstanceSpecResponseBody) *ModifyLoadBalancerInstanceSpecResponse {
	s.Body = v
	return s
}

type ModifyLoadBalancerInternetSpecRequest struct {
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// Specifies whether to automatically pay the subscription fee of the Internet-facing CLB instance. Valid values:
	//
	// *   **true**: enables automatic payments. This is the default value.
	// *   **false**: disables automatic payment. You must complete the payment in Order Center.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The ID of the region where the CLB instance is deployed.
	//
	// You can call the [DescribeRegions](~~27584~~) operation to query the most recent region list.
	InternetChargeType *string `json:"InternetChargeType,omitempty" xml:"InternetChargeType,omitempty"`
	// The ID of the request.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The metering method of the Internet-facing CLB instance. Valid values:
	//
	// *   **paybybandwidth**: pay-by-bandwidth
	// *   **paybytraffic**: pay-by-data-transfer
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyLoadBalancerInternetSpecRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyLoadBalancerInternetSpecRequest) GoString() string {
	return s.String()
}

func (s *ModifyLoadBalancerInternetSpecRequest) SetAutoPay(v bool) *ModifyLoadBalancerInternetSpecRequest {
	s.AutoPay = &v
	return s
}

func (s *ModifyLoadBalancerInternetSpecRequest) SetBandwidth(v int32) *ModifyLoadBalancerInternetSpecRequest {
	s.Bandwidth = &v
	return s
}

func (s *ModifyLoadBalancerInternetSpecRequest) SetInternetChargeType(v string) *ModifyLoadBalancerInternetSpecRequest {
	s.InternetChargeType = &v
	return s
}

func (s *ModifyLoadBalancerInternetSpecRequest) SetLoadBalancerId(v string) *ModifyLoadBalancerInternetSpecRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *ModifyLoadBalancerInternetSpecRequest) SetOwnerAccount(v string) *ModifyLoadBalancerInternetSpecRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyLoadBalancerInternetSpecRequest) SetOwnerId(v int64) *ModifyLoadBalancerInternetSpecRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyLoadBalancerInternetSpecRequest) SetRegionId(v string) *ModifyLoadBalancerInternetSpecRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyLoadBalancerInternetSpecRequest) SetResourceOwnerAccount(v string) *ModifyLoadBalancerInternetSpecRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyLoadBalancerInternetSpecRequest) SetResourceOwnerId(v int64) *ModifyLoadBalancerInternetSpecRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyLoadBalancerInternetSpecResponseBody struct {
	OrderId   *int64  `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyLoadBalancerInternetSpecResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyLoadBalancerInternetSpecResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyLoadBalancerInternetSpecResponseBody) SetOrderId(v int64) *ModifyLoadBalancerInternetSpecResponseBody {
	s.OrderId = &v
	return s
}

func (s *ModifyLoadBalancerInternetSpecResponseBody) SetRequestId(v string) *ModifyLoadBalancerInternetSpecResponseBody {
	s.RequestId = &v
	return s
}

type ModifyLoadBalancerInternetSpecResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyLoadBalancerInternetSpecResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyLoadBalancerInternetSpecResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyLoadBalancerInternetSpecResponse) GoString() string {
	return s.String()
}

func (s *ModifyLoadBalancerInternetSpecResponse) SetHeaders(v map[string]*string) *ModifyLoadBalancerInternetSpecResponse {
	s.Headers = v
	return s
}

func (s *ModifyLoadBalancerInternetSpecResponse) SetStatusCode(v int32) *ModifyLoadBalancerInternetSpecResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyLoadBalancerInternetSpecResponse) SetBody(v *ModifyLoadBalancerInternetSpecResponseBody) *ModifyLoadBalancerInternetSpecResponse {
	s.Body = v
	return s
}

type ModifyLoadBalancerPayTypeRequest struct {
	// Specifies whether to enable automatic payment. Valid values:
	//
	// *   **true**: yes
	// *   **false** (default): no
	//
	// >  This parameter is valid only when the `PayType` parameter is set to **PrePay**. This parameter is valid only for pay-as-you-go instances.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// The subscription duration.
	//
	// *   If **PricingCycle** is set to **month**, the valid values are **1** to **9**.
	// *   If **PricingCycle** is set to **year**, the valid values are **1** to **3**.
	//
	// >  This parameter is valid only when the **PayType** parameter is set to **PrePay**. This parameter is valid only for pay-as-you-go instances.
	Duration *int32 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The ID of the CLB instance.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The billing method of the CLB instance. Valid values:
	//
	// *   **PayOnDemand** (default): pay-as-you-go
	//
	// To change the billing method of a pay-as-you-go CLB instance to subscription, you must set the parameter to **PrePay**. In addition, the previous billing method of the CLB instance must be **PayOnDemand**.
	PayType *string `json:"PayType,omitempty" xml:"PayType,omitempty"`
	// The billing cycle.
	//
	// Valid values: **year** and **month**.
	//
	// >  This parameter is valid only when the **PayType** parameter is set to **PrePay**. This parameter is valid only for pay-as-you-go instances.
	PricingCycle *string `json:"PricingCycle,omitempty" xml:"PricingCycle,omitempty"`
	// The ID of the region where the CLB instance is deployed.
	//
	// You can query the region ID from the [Regions and zones](~~40654~~) list or by calling the [DescribeRegions](~~25609~~) operation.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyLoadBalancerPayTypeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyLoadBalancerPayTypeRequest) GoString() string {
	return s.String()
}

func (s *ModifyLoadBalancerPayTypeRequest) SetAutoPay(v bool) *ModifyLoadBalancerPayTypeRequest {
	s.AutoPay = &v
	return s
}

func (s *ModifyLoadBalancerPayTypeRequest) SetDuration(v int32) *ModifyLoadBalancerPayTypeRequest {
	s.Duration = &v
	return s
}

func (s *ModifyLoadBalancerPayTypeRequest) SetLoadBalancerId(v string) *ModifyLoadBalancerPayTypeRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *ModifyLoadBalancerPayTypeRequest) SetOwnerAccount(v string) *ModifyLoadBalancerPayTypeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyLoadBalancerPayTypeRequest) SetOwnerId(v int64) *ModifyLoadBalancerPayTypeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyLoadBalancerPayTypeRequest) SetPayType(v string) *ModifyLoadBalancerPayTypeRequest {
	s.PayType = &v
	return s
}

func (s *ModifyLoadBalancerPayTypeRequest) SetPricingCycle(v string) *ModifyLoadBalancerPayTypeRequest {
	s.PricingCycle = &v
	return s
}

func (s *ModifyLoadBalancerPayTypeRequest) SetRegionId(v string) *ModifyLoadBalancerPayTypeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyLoadBalancerPayTypeRequest) SetResourceOwnerAccount(v string) *ModifyLoadBalancerPayTypeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyLoadBalancerPayTypeRequest) SetResourceOwnerId(v int64) *ModifyLoadBalancerPayTypeRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyLoadBalancerPayTypeResponseBody struct {
	// The order ID of the subscription CLB instance.
	OrderId *int64 `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyLoadBalancerPayTypeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyLoadBalancerPayTypeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyLoadBalancerPayTypeResponseBody) SetOrderId(v int64) *ModifyLoadBalancerPayTypeResponseBody {
	s.OrderId = &v
	return s
}

func (s *ModifyLoadBalancerPayTypeResponseBody) SetRequestId(v string) *ModifyLoadBalancerPayTypeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyLoadBalancerPayTypeResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyLoadBalancerPayTypeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyLoadBalancerPayTypeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyLoadBalancerPayTypeResponse) GoString() string {
	return s.String()
}

func (s *ModifyLoadBalancerPayTypeResponse) SetHeaders(v map[string]*string) *ModifyLoadBalancerPayTypeResponse {
	s.Headers = v
	return s
}

func (s *ModifyLoadBalancerPayTypeResponse) SetStatusCode(v int32) *ModifyLoadBalancerPayTypeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyLoadBalancerPayTypeResponse) SetBody(v *ModifyLoadBalancerPayTypeResponseBody) *ModifyLoadBalancerPayTypeResponse {
	s.Body = v
	return s
}

type ModifyVServerGroupBackendServersRequest struct {
	// The ID of the request.
	NewBackendServers *string `json:"NewBackendServers,omitempty" xml:"NewBackendServers,omitempty"`
	// The ID of the vServer group.
	OldBackendServers *string `json:"OldBackendServers,omitempty" xml:"OldBackendServers,omitempty"`
	OwnerAccount      *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId           *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The list of backend servers that you want to replace in the vServer group. You can specify at most 20 backend servers for a vServer group in each call.
	//
	// *   **ServerId**: required. The ID of the Elastic Compute Service (ECS) instance or elastic network interface (ENI) that serves as a backend server. This parameter must be of the STRING type.
	//
	// *   **Port**: required. The port that is used by the backend server. This parameter must be of the INTEGER type. Valid values: **1 to 65535**.
	//
	// *   **Weight**: required. The weight of the backend server. This parameter must be of the INTEGER type. Valid values: **0 to 100**.
	//
	// *   **Description**: optional. The description of the backend server. This parameter must be of the STRING type. The description must be 1 to 80 characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.),and underscores (\_).
	//
	// *   **Type**: the type of backend server. This parameter must be of the STRING type. Valid values:
	//
	//     *   **ecs**: an ECS instance. This is the default value.
	//     *   **eni**: an ENI.
	//
	// *   **ServerIp**: the IP address of the ECS instance or ENI.
	//
	// Examples:
	//
	// *   An ECS instance: `[{ "ServerId": "i-xxxxxxxxx", "Weight": "100", "Type": "ecs", "Port":"80","Description":"test-112" }]`
	// *   An ENI: `[{ "ServerId": "eni-xxxxxxxxx", "Weight": "100", "Type": "eni", "ServerIp": "192.168.**.**", "Port":"80","Description":"test-112" }]`
	// *   An ENI with multiple IP addresses: `[{ "ServerId": "eni-xxxxxxxxx", "Weight": "100", "Type": "eni", "ServerIp": "192.168.**.**", "Port":"80","Description":"test-112" },{ "ServerId": "eni-xxxxxxxxx", "Weight": "100", "Type": "eni", "ServerIp": "172.166.**.**", "Port":"80","Description":"test-113" }]`
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The list of new backend servers that you want to use to replace those in the vServer group. You can specify at most 20 backend servers for a vServer group in each call.
	//
	// *   **ServerId**: required. The ID of the ECS instance or ENI that serves as a backend server. This parameter must be of the STRING type.
	//
	// *   **Port**: required. The port that is used by the backend server. This parameter must be of the INTEGER type. Valid values: **1 to 65535**.
	//
	// *   **Weight**: required. The weight of the backend server. This parameter must be of the INTEGER type. Valid values: **0 to 100**.
	//
	// *   **Description**: optional. The description of the backend server. This parameter must be of the STRING type. The description can contain letters, digits, hyphens (-), forward slashes (/), periods (.),and underscores (\_).
	//
	// *   **Type**: the type of backend server. This parameter must be of the STRING type. Valid values:
	//
	//     *   **ecs**: an ECS instance. This is the default value.
	//     *   **eni**: an ENI.
	//
	// *   **ServerIp**: the IP address of the ECS instance or ENI.
	//
	// Examples:
	//
	// *   An ECS instance: `[{ "ServerId": "i-xxxxxxxxx", "Weight": "100", "Type": "ecs", "Port":"80","Description":"test-112" }]`
	// *   An ENI: `[{ "ServerId": "eni-xxxxxxxxx", "Weight": "100", "Type": "eni", "ServerIp": "192.168.**.**", "Port":"80","Description":"test-112" }]`
	// *   An ENI with multiple IP addresses: `[{ "ServerId": "eni-xxxxxxxxx", "Weight": "100", "Type": "eni", "ServerIp": "192.168.**.**", "Port":"80","Description":"test-112" },{ "ServerId": "eni-xxxxxxxxx", "Weight": "100", "Type": "eni", "ServerIp": "172.166.**.**", "Port":"80","Description":"test-113" }]`
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
}

func (s ModifyVServerGroupBackendServersRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyVServerGroupBackendServersRequest) GoString() string {
	return s.String()
}

func (s *ModifyVServerGroupBackendServersRequest) SetNewBackendServers(v string) *ModifyVServerGroupBackendServersRequest {
	s.NewBackendServers = &v
	return s
}

func (s *ModifyVServerGroupBackendServersRequest) SetOldBackendServers(v string) *ModifyVServerGroupBackendServersRequest {
	s.OldBackendServers = &v
	return s
}

func (s *ModifyVServerGroupBackendServersRequest) SetOwnerAccount(v string) *ModifyVServerGroupBackendServersRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyVServerGroupBackendServersRequest) SetOwnerId(v int64) *ModifyVServerGroupBackendServersRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyVServerGroupBackendServersRequest) SetRegionId(v string) *ModifyVServerGroupBackendServersRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyVServerGroupBackendServersRequest) SetResourceOwnerAccount(v string) *ModifyVServerGroupBackendServersRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyVServerGroupBackendServersRequest) SetResourceOwnerId(v int64) *ModifyVServerGroupBackendServersRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyVServerGroupBackendServersRequest) SetVServerGroupId(v string) *ModifyVServerGroupBackendServersRequest {
	s.VServerGroupId = &v
	return s
}

type ModifyVServerGroupBackendServersResponseBody struct {
	// The weight of the backend server.
	BackendServers *ModifyVServerGroupBackendServersResponseBodyBackendServers `json:"BackendServers,omitempty" xml:"BackendServers,omitempty" type:"Struct"`
	// The type of backend server. Valid values:
	//
	// *   **ecs**: an ECS instance. This is the default value.
	// *   **eni**: an ENI.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of backend servers.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
}

func (s ModifyVServerGroupBackendServersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyVServerGroupBackendServersResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyVServerGroupBackendServersResponseBody) SetBackendServers(v *ModifyVServerGroupBackendServersResponseBodyBackendServers) *ModifyVServerGroupBackendServersResponseBody {
	s.BackendServers = v
	return s
}

func (s *ModifyVServerGroupBackendServersResponseBody) SetRequestId(v string) *ModifyVServerGroupBackendServersResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyVServerGroupBackendServersResponseBody) SetVServerGroupId(v string) *ModifyVServerGroupBackendServersResponseBody {
	s.VServerGroupId = &v
	return s
}

type ModifyVServerGroupBackendServersResponseBodyBackendServers struct {
	BackendServer []*ModifyVServerGroupBackendServersResponseBodyBackendServersBackendServer `json:"BackendServer,omitempty" xml:"BackendServer,omitempty" type:"Repeated"`
}

func (s ModifyVServerGroupBackendServersResponseBodyBackendServers) String() string {
	return tea.Prettify(s)
}

func (s ModifyVServerGroupBackendServersResponseBodyBackendServers) GoString() string {
	return s.String()
}

func (s *ModifyVServerGroupBackendServersResponseBodyBackendServers) SetBackendServer(v []*ModifyVServerGroupBackendServersResponseBodyBackendServersBackendServer) *ModifyVServerGroupBackendServersResponseBodyBackendServers {
	s.BackendServer = v
	return s
}

type ModifyVServerGroupBackendServersResponseBodyBackendServersBackendServer struct {
	// The port that is used by the backend server.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// You can call this operation to replace the backend servers in a specified vServer group. To modify the configurations of the backend servers, such as their weights, you can call the [SetVServerGroupAttribute](~~35217~~) operation.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// Replaces backend servers in a specified vServer group.
	ServerId *string `json:"ServerId,omitempty" xml:"ServerId,omitempty"`
	// The description of the backend server.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// Backend server description
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s ModifyVServerGroupBackendServersResponseBodyBackendServersBackendServer) String() string {
	return tea.Prettify(s)
}

func (s ModifyVServerGroupBackendServersResponseBodyBackendServersBackendServer) GoString() string {
	return s.String()
}

func (s *ModifyVServerGroupBackendServersResponseBodyBackendServersBackendServer) SetDescription(v string) *ModifyVServerGroupBackendServersResponseBodyBackendServersBackendServer {
	s.Description = &v
	return s
}

func (s *ModifyVServerGroupBackendServersResponseBodyBackendServersBackendServer) SetPort(v int32) *ModifyVServerGroupBackendServersResponseBodyBackendServersBackendServer {
	s.Port = &v
	return s
}

func (s *ModifyVServerGroupBackendServersResponseBodyBackendServersBackendServer) SetServerId(v string) *ModifyVServerGroupBackendServersResponseBodyBackendServersBackendServer {
	s.ServerId = &v
	return s
}

func (s *ModifyVServerGroupBackendServersResponseBodyBackendServersBackendServer) SetType(v string) *ModifyVServerGroupBackendServersResponseBodyBackendServersBackendServer {
	s.Type = &v
	return s
}

func (s *ModifyVServerGroupBackendServersResponseBodyBackendServersBackendServer) SetWeight(v int32) *ModifyVServerGroupBackendServersResponseBodyBackendServersBackendServer {
	s.Weight = &v
	return s
}

type ModifyVServerGroupBackendServersResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyVServerGroupBackendServersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyVServerGroupBackendServersResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyVServerGroupBackendServersResponse) GoString() string {
	return s.String()
}

func (s *ModifyVServerGroupBackendServersResponse) SetHeaders(v map[string]*string) *ModifyVServerGroupBackendServersResponse {
	s.Headers = v
	return s
}

func (s *ModifyVServerGroupBackendServersResponse) SetStatusCode(v int32) *ModifyVServerGroupBackendServersResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyVServerGroupBackendServersResponse) SetBody(v *ModifyVServerGroupBackendServersResponseBody) *ModifyVServerGroupBackendServersResponse {
	s.Body = v
	return s
}

type MoveResourceGroupRequest struct {
	NewResourceGroupId   *string `json:"NewResourceGroupId,omitempty" xml:"NewResourceGroupId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceId           *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	ResourceType         *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	AccessKeyId          *string `json:"access_key_id,omitempty" xml:"access_key_id,omitempty"`
}

func (s MoveResourceGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s MoveResourceGroupRequest) GoString() string {
	return s.String()
}

func (s *MoveResourceGroupRequest) SetNewResourceGroupId(v string) *MoveResourceGroupRequest {
	s.NewResourceGroupId = &v
	return s
}

func (s *MoveResourceGroupRequest) SetOwnerAccount(v string) *MoveResourceGroupRequest {
	s.OwnerAccount = &v
	return s
}

func (s *MoveResourceGroupRequest) SetOwnerId(v int64) *MoveResourceGroupRequest {
	s.OwnerId = &v
	return s
}

func (s *MoveResourceGroupRequest) SetRegionId(v string) *MoveResourceGroupRequest {
	s.RegionId = &v
	return s
}

func (s *MoveResourceGroupRequest) SetResourceGroupId(v string) *MoveResourceGroupRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *MoveResourceGroupRequest) SetResourceId(v string) *MoveResourceGroupRequest {
	s.ResourceId = &v
	return s
}

func (s *MoveResourceGroupRequest) SetResourceOwnerAccount(v string) *MoveResourceGroupRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *MoveResourceGroupRequest) SetResourceOwnerId(v int64) *MoveResourceGroupRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *MoveResourceGroupRequest) SetResourceType(v string) *MoveResourceGroupRequest {
	s.ResourceType = &v
	return s
}

func (s *MoveResourceGroupRequest) SetAccessKeyId(v string) *MoveResourceGroupRequest {
	s.AccessKeyId = &v
	return s
}

type MoveResourceGroupResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s MoveResourceGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s MoveResourceGroupResponseBody) GoString() string {
	return s.String()
}

func (s *MoveResourceGroupResponseBody) SetRequestId(v string) *MoveResourceGroupResponseBody {
	s.RequestId = &v
	return s
}

type MoveResourceGroupResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *MoveResourceGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s MoveResourceGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s MoveResourceGroupResponse) GoString() string {
	return s.String()
}

func (s *MoveResourceGroupResponse) SetHeaders(v map[string]*string) *MoveResourceGroupResponse {
	s.Headers = v
	return s
}

func (s *MoveResourceGroupResponse) SetStatusCode(v int32) *MoveResourceGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *MoveResourceGroupResponse) SetBody(v *MoveResourceGroupResponseBody) *MoveResourceGroupResponse {
	s.Body = v
	return s
}

type RemoveAccessControlListEntryRequest struct {
	AclEntrys    *string `json:"AclEntrys,omitempty" xml:"AclEntrys,omitempty"`
	AclId        *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the network ACL.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s RemoveAccessControlListEntryRequest) String() string {
	return tea.Prettify(s)
}

func (s RemoveAccessControlListEntryRequest) GoString() string {
	return s.String()
}

func (s *RemoveAccessControlListEntryRequest) SetAclEntrys(v string) *RemoveAccessControlListEntryRequest {
	s.AclEntrys = &v
	return s
}

func (s *RemoveAccessControlListEntryRequest) SetAclId(v string) *RemoveAccessControlListEntryRequest {
	s.AclId = &v
	return s
}

func (s *RemoveAccessControlListEntryRequest) SetOwnerAccount(v string) *RemoveAccessControlListEntryRequest {
	s.OwnerAccount = &v
	return s
}

func (s *RemoveAccessControlListEntryRequest) SetOwnerId(v int64) *RemoveAccessControlListEntryRequest {
	s.OwnerId = &v
	return s
}

func (s *RemoveAccessControlListEntryRequest) SetRegionId(v string) *RemoveAccessControlListEntryRequest {
	s.RegionId = &v
	return s
}

func (s *RemoveAccessControlListEntryRequest) SetResourceOwnerAccount(v string) *RemoveAccessControlListEntryRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RemoveAccessControlListEntryRequest) SetResourceOwnerId(v int64) *RemoveAccessControlListEntryRequest {
	s.ResourceOwnerId = &v
	return s
}

type RemoveAccessControlListEntryResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RemoveAccessControlListEntryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RemoveAccessControlListEntryResponseBody) GoString() string {
	return s.String()
}

func (s *RemoveAccessControlListEntryResponseBody) SetRequestId(v string) *RemoveAccessControlListEntryResponseBody {
	s.RequestId = &v
	return s
}

type RemoveAccessControlListEntryResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RemoveAccessControlListEntryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RemoveAccessControlListEntryResponse) String() string {
	return tea.Prettify(s)
}

func (s RemoveAccessControlListEntryResponse) GoString() string {
	return s.String()
}

func (s *RemoveAccessControlListEntryResponse) SetHeaders(v map[string]*string) *RemoveAccessControlListEntryResponse {
	s.Headers = v
	return s
}

func (s *RemoveAccessControlListEntryResponse) SetStatusCode(v int32) *RemoveAccessControlListEntryResponse {
	s.StatusCode = &v
	return s
}

func (s *RemoveAccessControlListEntryResponse) SetBody(v *RemoveAccessControlListEntryResponseBody) *RemoveAccessControlListEntryResponse {
	s.Body = v
	return s
}

type RemoveBackendServersRequest struct {
	// The ID of the request.
	BackendServers *string `json:"BackendServers,omitempty" xml:"BackendServers,omitempty"`
	// The ID of the CLB instance.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the CLB instance.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s RemoveBackendServersRequest) String() string {
	return tea.Prettify(s)
}

func (s RemoveBackendServersRequest) GoString() string {
	return s.String()
}

func (s *RemoveBackendServersRequest) SetBackendServers(v string) *RemoveBackendServersRequest {
	s.BackendServers = &v
	return s
}

func (s *RemoveBackendServersRequest) SetLoadBalancerId(v string) *RemoveBackendServersRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *RemoveBackendServersRequest) SetOwnerAccount(v string) *RemoveBackendServersRequest {
	s.OwnerAccount = &v
	return s
}

func (s *RemoveBackendServersRequest) SetOwnerId(v int64) *RemoveBackendServersRequest {
	s.OwnerId = &v
	return s
}

func (s *RemoveBackendServersRequest) SetRegionId(v string) *RemoveBackendServersRequest {
	s.RegionId = &v
	return s
}

func (s *RemoveBackendServersRequest) SetResourceOwnerAccount(v string) *RemoveBackendServersRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RemoveBackendServersRequest) SetResourceOwnerId(v int64) *RemoveBackendServersRequest {
	s.ResourceOwnerId = &v
	return s
}

type RemoveBackendServersResponseBody struct {
	// The weight of the backend server. Valid values: **0 to 100**.
	BackendServers *RemoveBackendServersResponseBodyBackendServers `json:"BackendServers,omitempty" xml:"BackendServers,omitempty" type:"Struct"`
	// The list of backend servers.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// The type of the backend server. Valid values:
	//
	// *   **ecs**: an ECS instance
	// *   **eni**: an ENI
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RemoveBackendServersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RemoveBackendServersResponseBody) GoString() string {
	return s.String()
}

func (s *RemoveBackendServersResponseBody) SetBackendServers(v *RemoveBackendServersResponseBodyBackendServers) *RemoveBackendServersResponseBody {
	s.BackendServers = v
	return s
}

func (s *RemoveBackendServersResponseBody) SetLoadBalancerId(v string) *RemoveBackendServersResponseBody {
	s.LoadBalancerId = &v
	return s
}

func (s *RemoveBackendServersResponseBody) SetRequestId(v string) *RemoveBackendServersResponseBody {
	s.RequestId = &v
	return s
}

type RemoveBackendServersResponseBodyBackendServers struct {
	BackendServer []*RemoveBackendServersResponseBodyBackendServersBackendServer `json:"BackendServer,omitempty" xml:"BackendServer,omitempty" type:"Repeated"`
}

func (s RemoveBackendServersResponseBodyBackendServers) String() string {
	return tea.Prettify(s)
}

func (s RemoveBackendServersResponseBodyBackendServers) GoString() string {
	return s.String()
}

func (s *RemoveBackendServersResponseBodyBackendServers) SetBackendServer(v []*RemoveBackendServersResponseBodyBackendServersBackendServer) *RemoveBackendServersResponseBodyBackendServers {
	s.BackendServer = v
	return s
}

type RemoveBackendServersResponseBodyBackendServersBackendServer struct {
	// >  If the backend servers that you want to remove are not in the server list of the Classic Load Balancer (CLB) instance, the request fails. However, the system does not report an error.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Removes backend servers.
	ServerId *string `json:"ServerId,omitempty" xml:"ServerId,omitempty"`
	// The description of the server group.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The ID of the backend server.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s RemoveBackendServersResponseBodyBackendServersBackendServer) String() string {
	return tea.Prettify(s)
}

func (s RemoveBackendServersResponseBodyBackendServersBackendServer) GoString() string {
	return s.String()
}

func (s *RemoveBackendServersResponseBodyBackendServersBackendServer) SetDescription(v string) *RemoveBackendServersResponseBodyBackendServersBackendServer {
	s.Description = &v
	return s
}

func (s *RemoveBackendServersResponseBodyBackendServersBackendServer) SetServerId(v string) *RemoveBackendServersResponseBodyBackendServersBackendServer {
	s.ServerId = &v
	return s
}

func (s *RemoveBackendServersResponseBodyBackendServersBackendServer) SetType(v string) *RemoveBackendServersResponseBodyBackendServersBackendServer {
	s.Type = &v
	return s
}

func (s *RemoveBackendServersResponseBodyBackendServersBackendServer) SetWeight(v int32) *RemoveBackendServersResponseBodyBackendServersBackendServer {
	s.Weight = &v
	return s
}

type RemoveBackendServersResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RemoveBackendServersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RemoveBackendServersResponse) String() string {
	return tea.Prettify(s)
}

func (s RemoveBackendServersResponse) GoString() string {
	return s.String()
}

func (s *RemoveBackendServersResponse) SetHeaders(v map[string]*string) *RemoveBackendServersResponse {
	s.Headers = v
	return s
}

func (s *RemoveBackendServersResponse) SetStatusCode(v int32) *RemoveBackendServersResponse {
	s.StatusCode = &v
	return s
}

func (s *RemoveBackendServersResponse) SetBody(v *RemoveBackendServersResponseBody) *RemoveBackendServersResponse {
	s.Body = v
	return s
}

type RemoveListenerWhiteListItemRequest struct {
	// The frontend protocol that is used by the CLB instance.
	//
	// >  This parameter is required when listeners that use different protocols listen on the same port.
	ListenerPort     *int32  `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	ListenerProtocol *string `json:"ListenerProtocol,omitempty" xml:"ListenerProtocol,omitempty"`
	// The region where the Classic Load Balancer (CLB) instance is created.
	//
	// You can call the [DescribeRegions](~~27584~~) operation to query the most recent region list.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The list of IP addresses or CIDR blocks that you want to remove from the whitelist. Separate multiple IP addresses or CIDR blocks with commas (,).
	//
	// >  If all IP addresses are removed from the whitelist, the listener does not forward requests.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	SourceItems          *string `json:"SourceItems,omitempty" xml:"SourceItems,omitempty"`
}

func (s RemoveListenerWhiteListItemRequest) String() string {
	return tea.Prettify(s)
}

func (s RemoveListenerWhiteListItemRequest) GoString() string {
	return s.String()
}

func (s *RemoveListenerWhiteListItemRequest) SetListenerPort(v int32) *RemoveListenerWhiteListItemRequest {
	s.ListenerPort = &v
	return s
}

func (s *RemoveListenerWhiteListItemRequest) SetListenerProtocol(v string) *RemoveListenerWhiteListItemRequest {
	s.ListenerProtocol = &v
	return s
}

func (s *RemoveListenerWhiteListItemRequest) SetLoadBalancerId(v string) *RemoveListenerWhiteListItemRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *RemoveListenerWhiteListItemRequest) SetOwnerAccount(v string) *RemoveListenerWhiteListItemRequest {
	s.OwnerAccount = &v
	return s
}

func (s *RemoveListenerWhiteListItemRequest) SetOwnerId(v int64) *RemoveListenerWhiteListItemRequest {
	s.OwnerId = &v
	return s
}

func (s *RemoveListenerWhiteListItemRequest) SetRegionId(v string) *RemoveListenerWhiteListItemRequest {
	s.RegionId = &v
	return s
}

func (s *RemoveListenerWhiteListItemRequest) SetResourceOwnerAccount(v string) *RemoveListenerWhiteListItemRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RemoveListenerWhiteListItemRequest) SetResourceOwnerId(v int64) *RemoveListenerWhiteListItemRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *RemoveListenerWhiteListItemRequest) SetSourceItems(v string) *RemoveListenerWhiteListItemRequest {
	s.SourceItems = &v
	return s
}

type RemoveListenerWhiteListItemResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RemoveListenerWhiteListItemResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RemoveListenerWhiteListItemResponseBody) GoString() string {
	return s.String()
}

func (s *RemoveListenerWhiteListItemResponseBody) SetRequestId(v string) *RemoveListenerWhiteListItemResponseBody {
	s.RequestId = &v
	return s
}

type RemoveListenerWhiteListItemResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RemoveListenerWhiteListItemResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RemoveListenerWhiteListItemResponse) String() string {
	return tea.Prettify(s)
}

func (s RemoveListenerWhiteListItemResponse) GoString() string {
	return s.String()
}

func (s *RemoveListenerWhiteListItemResponse) SetHeaders(v map[string]*string) *RemoveListenerWhiteListItemResponse {
	s.Headers = v
	return s
}

func (s *RemoveListenerWhiteListItemResponse) SetStatusCode(v int32) *RemoveListenerWhiteListItemResponse {
	s.StatusCode = &v
	return s
}

func (s *RemoveListenerWhiteListItemResponse) SetBody(v *RemoveListenerWhiteListItemResponseBody) *RemoveListenerWhiteListItemResponse {
	s.Body = v
	return s
}

type RemoveTagsRequest struct {
	// The ID of the SLB instance.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region to which the SLB instance belongs.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// A list of tags to be removed.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s RemoveTagsRequest) String() string {
	return tea.Prettify(s)
}

func (s RemoveTagsRequest) GoString() string {
	return s.String()
}

func (s *RemoveTagsRequest) SetLoadBalancerId(v string) *RemoveTagsRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *RemoveTagsRequest) SetOwnerAccount(v string) *RemoveTagsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *RemoveTagsRequest) SetOwnerId(v int64) *RemoveTagsRequest {
	s.OwnerId = &v
	return s
}

func (s *RemoveTagsRequest) SetRegionId(v string) *RemoveTagsRequest {
	s.RegionId = &v
	return s
}

func (s *RemoveTagsRequest) SetResourceOwnerAccount(v string) *RemoveTagsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RemoveTagsRequest) SetResourceOwnerId(v int64) *RemoveTagsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *RemoveTagsRequest) SetTags(v string) *RemoveTagsRequest {
	s.Tags = &v
	return s
}

type RemoveTagsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RemoveTagsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RemoveTagsResponseBody) GoString() string {
	return s.String()
}

func (s *RemoveTagsResponseBody) SetRequestId(v string) *RemoveTagsResponseBody {
	s.RequestId = &v
	return s
}

type RemoveTagsResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RemoveTagsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RemoveTagsResponse) String() string {
	return tea.Prettify(s)
}

func (s RemoveTagsResponse) GoString() string {
	return s.String()
}

func (s *RemoveTagsResponse) SetHeaders(v map[string]*string) *RemoveTagsResponse {
	s.Headers = v
	return s
}

func (s *RemoveTagsResponse) SetStatusCode(v int32) *RemoveTagsResponse {
	s.StatusCode = &v
	return s
}

func (s *RemoveTagsResponse) SetBody(v *RemoveTagsResponseBody) *RemoveTagsResponse {
	s.Body = v
	return s
}

type RemoveVServerGroupBackendServersRequest struct {
	// The ID of the request.
	BackendServers *string `json:"BackendServers,omitempty" xml:"BackendServers,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The list of backend servers that you want to remove from the vServer group.
	//
	// You can specify at most 20 backend servers for a vServer group in each call.
	//
	// The value of this parameter is a JSON list of the STRING type. You can specify at most 20 elements in a list for each request.
	//
	// *   **ServerId**: the ID of the Elastic Compute Service (ECS) instance or elastic network interface (ENI) that serves as a backend server.
	//
	// *   **Port**: the port that is used by the backend server. Valid values: **1 to 65535**.
	//
	// *   **Weight**: the weight of the backend server. Valid values: **0 to 100**.
	//
	// *   **Description**: the description of the backend server. The description must be 1 to 80 characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.),and underscores (\_).
	//
	// *   **Type**: the type of backend server. Valid values:
	//
	//     *   **ecs**: an ECS instance. This is the default value.
	//     *   **eni**: an ENI.
	//
	// *   **ServerIp**: the IP address of the ECS instance or ENI.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the vServer group.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
}

func (s RemoveVServerGroupBackendServersRequest) String() string {
	return tea.Prettify(s)
}

func (s RemoveVServerGroupBackendServersRequest) GoString() string {
	return s.String()
}

func (s *RemoveVServerGroupBackendServersRequest) SetBackendServers(v string) *RemoveVServerGroupBackendServersRequest {
	s.BackendServers = &v
	return s
}

func (s *RemoveVServerGroupBackendServersRequest) SetOwnerAccount(v string) *RemoveVServerGroupBackendServersRequest {
	s.OwnerAccount = &v
	return s
}

func (s *RemoveVServerGroupBackendServersRequest) SetOwnerId(v int64) *RemoveVServerGroupBackendServersRequest {
	s.OwnerId = &v
	return s
}

func (s *RemoveVServerGroupBackendServersRequest) SetRegionId(v string) *RemoveVServerGroupBackendServersRequest {
	s.RegionId = &v
	return s
}

func (s *RemoveVServerGroupBackendServersRequest) SetResourceOwnerAccount(v string) *RemoveVServerGroupBackendServersRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RemoveVServerGroupBackendServersRequest) SetResourceOwnerId(v int64) *RemoveVServerGroupBackendServersRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *RemoveVServerGroupBackendServersRequest) SetVServerGroupId(v string) *RemoveVServerGroupBackendServersRequest {
	s.VServerGroupId = &v
	return s
}

type RemoveVServerGroupBackendServersResponseBody struct {
	// The weight of the backend server.
	BackendServers *RemoveVServerGroupBackendServersResponseBodyBackendServers `json:"BackendServers,omitempty" xml:"BackendServers,omitempty" type:"Struct"`
	// The type of backend server. Valid values:
	//
	// *   **ecs**: an ECS instance
	// *   **eni**: an ENI
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of backend servers.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
}

func (s RemoveVServerGroupBackendServersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RemoveVServerGroupBackendServersResponseBody) GoString() string {
	return s.String()
}

func (s *RemoveVServerGroupBackendServersResponseBody) SetBackendServers(v *RemoveVServerGroupBackendServersResponseBodyBackendServers) *RemoveVServerGroupBackendServersResponseBody {
	s.BackendServers = v
	return s
}

func (s *RemoveVServerGroupBackendServersResponseBody) SetRequestId(v string) *RemoveVServerGroupBackendServersResponseBody {
	s.RequestId = &v
	return s
}

func (s *RemoveVServerGroupBackendServersResponseBody) SetVServerGroupId(v string) *RemoveVServerGroupBackendServersResponseBody {
	s.VServerGroupId = &v
	return s
}

type RemoveVServerGroupBackendServersResponseBodyBackendServers struct {
	BackendServer []*RemoveVServerGroupBackendServersResponseBodyBackendServersBackendServer `json:"BackendServer,omitempty" xml:"BackendServer,omitempty" type:"Repeated"`
}

func (s RemoveVServerGroupBackendServersResponseBodyBackendServers) String() string {
	return tea.Prettify(s)
}

func (s RemoveVServerGroupBackendServersResponseBodyBackendServers) GoString() string {
	return s.String()
}

func (s *RemoveVServerGroupBackendServersResponseBodyBackendServers) SetBackendServer(v []*RemoveVServerGroupBackendServersResponseBodyBackendServersBackendServer) *RemoveVServerGroupBackendServersResponseBodyBackendServers {
	s.BackendServer = v
	return s
}

type RemoveVServerGroupBackendServersResponseBodyBackendServersBackendServer struct {
	// >  If one or more backend servers specified by the **BackendServers** parameter do not exist in the specified vServer group, these backend servers are ignored and no error message is returned.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// Removes one or more backend servers from a specified vServer group.
	ServerId *string `json:"ServerId,omitempty" xml:"ServerId,omitempty"`
	// The port that is used by the backend server.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The ID of the ECS instance or ENI.
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s RemoveVServerGroupBackendServersResponseBodyBackendServersBackendServer) String() string {
	return tea.Prettify(s)
}

func (s RemoveVServerGroupBackendServersResponseBodyBackendServersBackendServer) GoString() string {
	return s.String()
}

func (s *RemoveVServerGroupBackendServersResponseBodyBackendServersBackendServer) SetPort(v int32) *RemoveVServerGroupBackendServersResponseBodyBackendServersBackendServer {
	s.Port = &v
	return s
}

func (s *RemoveVServerGroupBackendServersResponseBodyBackendServersBackendServer) SetServerId(v string) *RemoveVServerGroupBackendServersResponseBodyBackendServersBackendServer {
	s.ServerId = &v
	return s
}

func (s *RemoveVServerGroupBackendServersResponseBodyBackendServersBackendServer) SetType(v string) *RemoveVServerGroupBackendServersResponseBodyBackendServersBackendServer {
	s.Type = &v
	return s
}

func (s *RemoveVServerGroupBackendServersResponseBodyBackendServersBackendServer) SetWeight(v int32) *RemoveVServerGroupBackendServersResponseBodyBackendServersBackendServer {
	s.Weight = &v
	return s
}

type RemoveVServerGroupBackendServersResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RemoveVServerGroupBackendServersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RemoveVServerGroupBackendServersResponse) String() string {
	return tea.Prettify(s)
}

func (s RemoveVServerGroupBackendServersResponse) GoString() string {
	return s.String()
}

func (s *RemoveVServerGroupBackendServersResponse) SetHeaders(v map[string]*string) *RemoveVServerGroupBackendServersResponse {
	s.Headers = v
	return s
}

func (s *RemoveVServerGroupBackendServersResponse) SetStatusCode(v int32) *RemoveVServerGroupBackendServersResponse {
	s.StatusCode = &v
	return s
}

func (s *RemoveVServerGroupBackendServersResponse) SetBody(v *RemoveVServerGroupBackendServersResponseBody) *RemoveVServerGroupBackendServersResponse {
	s.Body = v
	return s
}

type SetAccessControlListAttributeRequest struct {
	AclId        *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	AclName      *string `json:"AclName,omitempty" xml:"AclName,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the network ACL.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s SetAccessControlListAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s SetAccessControlListAttributeRequest) GoString() string {
	return s.String()
}

func (s *SetAccessControlListAttributeRequest) SetAclId(v string) *SetAccessControlListAttributeRequest {
	s.AclId = &v
	return s
}

func (s *SetAccessControlListAttributeRequest) SetAclName(v string) *SetAccessControlListAttributeRequest {
	s.AclName = &v
	return s
}

func (s *SetAccessControlListAttributeRequest) SetOwnerAccount(v string) *SetAccessControlListAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SetAccessControlListAttributeRequest) SetOwnerId(v int64) *SetAccessControlListAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *SetAccessControlListAttributeRequest) SetRegionId(v string) *SetAccessControlListAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *SetAccessControlListAttributeRequest) SetResourceOwnerAccount(v string) *SetAccessControlListAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SetAccessControlListAttributeRequest) SetResourceOwnerId(v int64) *SetAccessControlListAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type SetAccessControlListAttributeResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetAccessControlListAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetAccessControlListAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *SetAccessControlListAttributeResponseBody) SetRequestId(v string) *SetAccessControlListAttributeResponseBody {
	s.RequestId = &v
	return s
}

type SetAccessControlListAttributeResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetAccessControlListAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetAccessControlListAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s SetAccessControlListAttributeResponse) GoString() string {
	return s.String()
}

func (s *SetAccessControlListAttributeResponse) SetHeaders(v map[string]*string) *SetAccessControlListAttributeResponse {
	s.Headers = v
	return s
}

func (s *SetAccessControlListAttributeResponse) SetStatusCode(v int32) *SetAccessControlListAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *SetAccessControlListAttributeResponse) SetBody(v *SetAccessControlListAttributeResponseBody) *SetAccessControlListAttributeResponse {
	s.Body = v
	return s
}

type SetAccessLogsDownloadAttributeRequest struct {
	// The tags that are added to the CLB instance. The tags must be key-value pairs that are contained in a JSON dictionary.
	//
	// You can specify up to 10 tags in each call.
	LoadBalancerId         *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	LogsDownloadAttributes *string `json:"LogsDownloadAttributes,omitempty" xml:"LogsDownloadAttributes,omitempty"`
	OwnerAccount           *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the request.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The operation that you want to perform. Set the value to **SetAccessLogsDownloadAttribute**.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s SetAccessLogsDownloadAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s SetAccessLogsDownloadAttributeRequest) GoString() string {
	return s.String()
}

func (s *SetAccessLogsDownloadAttributeRequest) SetLoadBalancerId(v string) *SetAccessLogsDownloadAttributeRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *SetAccessLogsDownloadAttributeRequest) SetLogsDownloadAttributes(v string) *SetAccessLogsDownloadAttributeRequest {
	s.LogsDownloadAttributes = &v
	return s
}

func (s *SetAccessLogsDownloadAttributeRequest) SetOwnerAccount(v string) *SetAccessLogsDownloadAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SetAccessLogsDownloadAttributeRequest) SetOwnerId(v int64) *SetAccessLogsDownloadAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *SetAccessLogsDownloadAttributeRequest) SetRegionId(v string) *SetAccessLogsDownloadAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *SetAccessLogsDownloadAttributeRequest) SetResourceOwnerAccount(v string) *SetAccessLogsDownloadAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SetAccessLogsDownloadAttributeRequest) SetResourceOwnerId(v int64) *SetAccessLogsDownloadAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *SetAccessLogsDownloadAttributeRequest) SetTags(v string) *SetAccessLogsDownloadAttributeRequest {
	s.Tags = &v
	return s
}

type SetAccessLogsDownloadAttributeResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetAccessLogsDownloadAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetAccessLogsDownloadAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *SetAccessLogsDownloadAttributeResponseBody) SetRequestId(v string) *SetAccessLogsDownloadAttributeResponseBody {
	s.RequestId = &v
	return s
}

type SetAccessLogsDownloadAttributeResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetAccessLogsDownloadAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetAccessLogsDownloadAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s SetAccessLogsDownloadAttributeResponse) GoString() string {
	return s.String()
}

func (s *SetAccessLogsDownloadAttributeResponse) SetHeaders(v map[string]*string) *SetAccessLogsDownloadAttributeResponse {
	s.Headers = v
	return s
}

func (s *SetAccessLogsDownloadAttributeResponse) SetStatusCode(v int32) *SetAccessLogsDownloadAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *SetAccessLogsDownloadAttributeResponse) SetBody(v *SetAccessLogsDownloadAttributeResponseBody) *SetAccessLogsDownloadAttributeResponse {
	s.Body = v
	return s
}

type SetBackendServersRequest struct {
	// The description of the backend server.
	BackendServers *string `json:"BackendServers,omitempty" xml:"BackendServers,omitempty"`
	// The ID of the CLB instance.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The list of backend servers that you want to modify.
	//
	// The value of this parameter must be a STRING list in the JSON format. You can specify up to 20 elements in each request.
	//
	// *   **ServerId**: Required. Specify the ID of the backend server. This parameter must be of the STRING type.
	//
	// *   **Port**: Required. Specify the port that is used by the backend server. This parameter must be of the INTEGER type. Valid values: **1** to **65535**.
	//
	// *   **Weight**: Specify the weight of the backend server. This parameter must be of the INTEGER type. Valid values: **0** to **100**.
	//
	// *   **Description**: Optional. The description of the backend server. This value must be a string. The description must be 1 to 80 characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.), and underscores (\_).
	//
	// *   **Type**: the type of backend server. This parameter must be of the STRING type. Valid values:
	//
	//     *   **ecs** (default): an Elastic Compute Service (ECS) instance
	//     *   **eni**: an elastic network interface (ENI). You can specify ENIs as the backend servers only for high-performance CLB instances.
	//
	// *   **ServerIp**: the IP address of the ECS instance or ENI
	//
	// Examples:
	//
	// *   ECS instance: `[{ "ServerId": "ecs-******FmYAXG", "Weight": "100", "Type": "ecs", "Port":"80","Description":"test-112" }]`
	// *   ENI: `[{ "ServerId": "eni-xxxxxxxxx", "Weight": "100", "Type": "eni", "ServerIp": "192.168.**.**", "Port":"80","Description":"test-112" }]`
	// *   ENI with multiple IP addresses: `[{ "ServerId": "eni-xxxxxxxxx", "Weight": "100", "Type": "eni", "ServerIp": "192.168.**.**", "Port":"80","Description":"test-112" },{ "ServerId": "eni-xxxxxxxxx", "Weight": "100", "Type": "eni", "ServerIp": "172.166.**.**", "Port":"80","Description":"test-113" }]`
	//
	// >
	// *   The backend servers must be in the Running state. You can specify up to 20 backend servers in each request.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s SetBackendServersRequest) String() string {
	return tea.Prettify(s)
}

func (s SetBackendServersRequest) GoString() string {
	return s.String()
}

func (s *SetBackendServersRequest) SetBackendServers(v string) *SetBackendServersRequest {
	s.BackendServers = &v
	return s
}

func (s *SetBackendServersRequest) SetLoadBalancerId(v string) *SetBackendServersRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *SetBackendServersRequest) SetOwnerAccount(v string) *SetBackendServersRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SetBackendServersRequest) SetOwnerId(v int64) *SetBackendServersRequest {
	s.OwnerId = &v
	return s
}

func (s *SetBackendServersRequest) SetRegionId(v string) *SetBackendServersRequest {
	s.RegionId = &v
	return s
}

func (s *SetBackendServersRequest) SetResourceOwnerAccount(v string) *SetBackendServersRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SetBackendServersRequest) SetResourceOwnerId(v int64) *SetBackendServersRequest {
	s.ResourceOwnerId = &v
	return s
}

type SetBackendServersResponseBody struct {
	// The ID of the request.
	BackendServers *SetBackendServersResponseBodyBackendServers `json:"BackendServers,omitempty" xml:"BackendServers,omitempty" type:"Struct"`
	// The type of the backend server. Valid values:
	//
	// *   **ecs** (default): an ECS instance
	// *   **eni**: an elastic network interface (ENI)
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// The list of backend servers.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetBackendServersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetBackendServersResponseBody) GoString() string {
	return s.String()
}

func (s *SetBackendServersResponseBody) SetBackendServers(v *SetBackendServersResponseBodyBackendServers) *SetBackendServersResponseBody {
	s.BackendServers = v
	return s
}

func (s *SetBackendServersResponseBody) SetLoadBalancerId(v string) *SetBackendServersResponseBody {
	s.LoadBalancerId = &v
	return s
}

func (s *SetBackendServersResponseBody) SetRequestId(v string) *SetBackendServersResponseBody {
	s.RequestId = &v
	return s
}

type SetBackendServersResponseBodyBackendServers struct {
	BackendServer []*SetBackendServersResponseBodyBackendServersBackendServer `json:"BackendServer,omitempty" xml:"BackendServer,omitempty" type:"Repeated"`
}

func (s SetBackendServersResponseBodyBackendServers) String() string {
	return tea.Prettify(s)
}

func (s SetBackendServersResponseBodyBackendServers) GoString() string {
	return s.String()
}

func (s *SetBackendServersResponseBodyBackendServers) SetBackendServer(v []*SetBackendServersResponseBodyBackendServersBackendServer) *SetBackendServersResponseBodyBackendServers {
	s.BackendServer = v
	return s
}

type SetBackendServersResponseBodyBackendServersBackendServer struct {
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	ServerId    *string `json:"ServerId,omitempty" xml:"ServerId,omitempty"`
	// The region ID of the Classic Load Balancer (CLB) instance.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// Sets the weights of backend servers.
	Weight *string `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s SetBackendServersResponseBodyBackendServersBackendServer) String() string {
	return tea.Prettify(s)
}

func (s SetBackendServersResponseBodyBackendServersBackendServer) GoString() string {
	return s.String()
}

func (s *SetBackendServersResponseBodyBackendServersBackendServer) SetDescription(v string) *SetBackendServersResponseBodyBackendServersBackendServer {
	s.Description = &v
	return s
}

func (s *SetBackendServersResponseBodyBackendServersBackendServer) SetServerId(v string) *SetBackendServersResponseBodyBackendServersBackendServer {
	s.ServerId = &v
	return s
}

func (s *SetBackendServersResponseBodyBackendServersBackendServer) SetType(v string) *SetBackendServersResponseBodyBackendServersBackendServer {
	s.Type = &v
	return s
}

func (s *SetBackendServersResponseBodyBackendServersBackendServer) SetWeight(v string) *SetBackendServersResponseBodyBackendServersBackendServer {
	s.Weight = &v
	return s
}

type SetBackendServersResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetBackendServersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetBackendServersResponse) String() string {
	return tea.Prettify(s)
}

func (s SetBackendServersResponse) GoString() string {
	return s.String()
}

func (s *SetBackendServersResponse) SetHeaders(v map[string]*string) *SetBackendServersResponse {
	s.Headers = v
	return s
}

func (s *SetBackendServersResponse) SetStatusCode(v int32) *SetBackendServersResponse {
	s.StatusCode = &v
	return s
}

func (s *SetBackendServersResponse) SetBody(v *SetBackendServersResponseBody) *SetBackendServersResponse {
	s.Body = v
	return s
}

type SetCACertificateNameRequest struct {
	// The name of the CA certificate.
	//
	// The name must be 1 to 80 characters in length and start with an English letter or a Chinese character. It can contain numbers, underscores (\_), periods (.), and hyphens (-).
	CACertificateId *string `json:"CACertificateId,omitempty" xml:"CACertificateId,omitempty"`
	// The ID of the request.
	CACertificateName *string `json:"CACertificateName,omitempty" xml:"CACertificateName,omitempty"`
	OwnerAccount      *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId           *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the CA certificate.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s SetCACertificateNameRequest) String() string {
	return tea.Prettify(s)
}

func (s SetCACertificateNameRequest) GoString() string {
	return s.String()
}

func (s *SetCACertificateNameRequest) SetCACertificateId(v string) *SetCACertificateNameRequest {
	s.CACertificateId = &v
	return s
}

func (s *SetCACertificateNameRequest) SetCACertificateName(v string) *SetCACertificateNameRequest {
	s.CACertificateName = &v
	return s
}

func (s *SetCACertificateNameRequest) SetOwnerAccount(v string) *SetCACertificateNameRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SetCACertificateNameRequest) SetOwnerId(v int64) *SetCACertificateNameRequest {
	s.OwnerId = &v
	return s
}

func (s *SetCACertificateNameRequest) SetRegionId(v string) *SetCACertificateNameRequest {
	s.RegionId = &v
	return s
}

func (s *SetCACertificateNameRequest) SetResourceOwnerAccount(v string) *SetCACertificateNameRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SetCACertificateNameRequest) SetResourceOwnerId(v int64) *SetCACertificateNameRequest {
	s.ResourceOwnerId = &v
	return s
}

type SetCACertificateNameResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetCACertificateNameResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetCACertificateNameResponseBody) GoString() string {
	return s.String()
}

func (s *SetCACertificateNameResponseBody) SetRequestId(v string) *SetCACertificateNameResponseBody {
	s.RequestId = &v
	return s
}

type SetCACertificateNameResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetCACertificateNameResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetCACertificateNameResponse) String() string {
	return tea.Prettify(s)
}

func (s SetCACertificateNameResponse) GoString() string {
	return s.String()
}

func (s *SetCACertificateNameResponse) SetHeaders(v map[string]*string) *SetCACertificateNameResponse {
	s.Headers = v
	return s
}

func (s *SetCACertificateNameResponse) SetStatusCode(v int32) *SetCACertificateNameResponse {
	s.StatusCode = &v
	return s
}

func (s *SetCACertificateNameResponse) SetBody(v *SetCACertificateNameResponseBody) *SetCACertificateNameResponse {
	s.Body = v
	return s
}

type SetDomainExtensionAttributeRequest struct {
	// The ID of the request.
	DomainExtensionId *string `json:"DomainExtensionId,omitempty" xml:"DomainExtensionId,omitempty"`
	OwnerAccount      *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId           *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the new certificate.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// >  You cannot replace an additional certificate for a listener that is added to a shared-resource Server Load Balancer (SLB) instance.
	ServerCertificateId *string `json:"ServerCertificateId,omitempty" xml:"ServerCertificateId,omitempty"`
}

func (s SetDomainExtensionAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s SetDomainExtensionAttributeRequest) GoString() string {
	return s.String()
}

func (s *SetDomainExtensionAttributeRequest) SetDomainExtensionId(v string) *SetDomainExtensionAttributeRequest {
	s.DomainExtensionId = &v
	return s
}

func (s *SetDomainExtensionAttributeRequest) SetOwnerAccount(v string) *SetDomainExtensionAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SetDomainExtensionAttributeRequest) SetOwnerId(v int64) *SetDomainExtensionAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *SetDomainExtensionAttributeRequest) SetRegionId(v string) *SetDomainExtensionAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *SetDomainExtensionAttributeRequest) SetResourceOwnerAccount(v string) *SetDomainExtensionAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SetDomainExtensionAttributeRequest) SetResourceOwnerId(v int64) *SetDomainExtensionAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *SetDomainExtensionAttributeRequest) SetServerCertificateId(v string) *SetDomainExtensionAttributeRequest {
	s.ServerCertificateId = &v
	return s
}

type SetDomainExtensionAttributeResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetDomainExtensionAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetDomainExtensionAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *SetDomainExtensionAttributeResponseBody) SetRequestId(v string) *SetDomainExtensionAttributeResponseBody {
	s.RequestId = &v
	return s
}

type SetDomainExtensionAttributeResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetDomainExtensionAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetDomainExtensionAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s SetDomainExtensionAttributeResponse) GoString() string {
	return s.String()
}

func (s *SetDomainExtensionAttributeResponse) SetHeaders(v map[string]*string) *SetDomainExtensionAttributeResponse {
	s.Headers = v
	return s
}

func (s *SetDomainExtensionAttributeResponse) SetStatusCode(v int32) *SetDomainExtensionAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *SetDomainExtensionAttributeResponse) SetBody(v *SetDomainExtensionAttributeResponseBody) *SetDomainExtensionAttributeResponse {
	s.Body = v
	return s
}

type SetListenerAccessControlStatusRequest struct {
	AccessControlStatus *string `json:"AccessControlStatus,omitempty" xml:"AccessControlStatus,omitempty"`
	// The frontend protocol that is used by the CLB instance.
	//
	// >  This parameter is required when listeners that use different protocols listen on the same port.
	ListenerPort     *int32  `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	ListenerProtocol *string `json:"ListenerProtocol,omitempty" xml:"ListenerProtocol,omitempty"`
	// The region where the Classic Load Balancer (CLB) instance is created.
	//
	// You can call the [DescribeRegions](~~27584~~) operation to query the most recent region list.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// Specifies whether to enable the whitelist. Valid values:
	//
	// *   **open_white_list**: enables the whitelist.
	// *   **close**: disables the whitelist.
	//
	// >  After the whitelist is enabled, if no IP address is added to the whitelist, the CLB instance does not distribute network traffic.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s SetListenerAccessControlStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s SetListenerAccessControlStatusRequest) GoString() string {
	return s.String()
}

func (s *SetListenerAccessControlStatusRequest) SetAccessControlStatus(v string) *SetListenerAccessControlStatusRequest {
	s.AccessControlStatus = &v
	return s
}

func (s *SetListenerAccessControlStatusRequest) SetListenerPort(v int32) *SetListenerAccessControlStatusRequest {
	s.ListenerPort = &v
	return s
}

func (s *SetListenerAccessControlStatusRequest) SetListenerProtocol(v string) *SetListenerAccessControlStatusRequest {
	s.ListenerProtocol = &v
	return s
}

func (s *SetListenerAccessControlStatusRequest) SetLoadBalancerId(v string) *SetListenerAccessControlStatusRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *SetListenerAccessControlStatusRequest) SetOwnerAccount(v string) *SetListenerAccessControlStatusRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SetListenerAccessControlStatusRequest) SetOwnerId(v int64) *SetListenerAccessControlStatusRequest {
	s.OwnerId = &v
	return s
}

func (s *SetListenerAccessControlStatusRequest) SetRegionId(v string) *SetListenerAccessControlStatusRequest {
	s.RegionId = &v
	return s
}

func (s *SetListenerAccessControlStatusRequest) SetResourceOwnerAccount(v string) *SetListenerAccessControlStatusRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SetListenerAccessControlStatusRequest) SetResourceOwnerId(v int64) *SetListenerAccessControlStatusRequest {
	s.ResourceOwnerId = &v
	return s
}

type SetListenerAccessControlStatusResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetListenerAccessControlStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetListenerAccessControlStatusResponseBody) GoString() string {
	return s.String()
}

func (s *SetListenerAccessControlStatusResponseBody) SetRequestId(v string) *SetListenerAccessControlStatusResponseBody {
	s.RequestId = &v
	return s
}

type SetListenerAccessControlStatusResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetListenerAccessControlStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetListenerAccessControlStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s SetListenerAccessControlStatusResponse) GoString() string {
	return s.String()
}

func (s *SetListenerAccessControlStatusResponse) SetHeaders(v map[string]*string) *SetListenerAccessControlStatusResponse {
	s.Headers = v
	return s
}

func (s *SetListenerAccessControlStatusResponse) SetStatusCode(v int32) *SetListenerAccessControlStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *SetListenerAccessControlStatusResponse) SetBody(v *SetListenerAccessControlStatusResponseBody) *SetListenerAccessControlStatusResponse {
	s.Body = v
	return s
}

type SetLoadBalancerDeleteProtectionRequest struct {
	// The ID of the request.
	DeleteProtection *string `json:"DeleteProtection,omitempty" xml:"DeleteProtection,omitempty"`
	// Specify whether to enable or disable deletion protection for the SLB instance.
	//
	// Valid values: **on and off**.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The operation that you want to perform.
	//
	// Set the value to **SetLoadBalancerDeleteProtection**.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s SetLoadBalancerDeleteProtectionRequest) String() string {
	return tea.Prettify(s)
}

func (s SetLoadBalancerDeleteProtectionRequest) GoString() string {
	return s.String()
}

func (s *SetLoadBalancerDeleteProtectionRequest) SetDeleteProtection(v string) *SetLoadBalancerDeleteProtectionRequest {
	s.DeleteProtection = &v
	return s
}

func (s *SetLoadBalancerDeleteProtectionRequest) SetLoadBalancerId(v string) *SetLoadBalancerDeleteProtectionRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *SetLoadBalancerDeleteProtectionRequest) SetOwnerAccount(v string) *SetLoadBalancerDeleteProtectionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SetLoadBalancerDeleteProtectionRequest) SetOwnerId(v int64) *SetLoadBalancerDeleteProtectionRequest {
	s.OwnerId = &v
	return s
}

func (s *SetLoadBalancerDeleteProtectionRequest) SetRegionId(v string) *SetLoadBalancerDeleteProtectionRequest {
	s.RegionId = &v
	return s
}

func (s *SetLoadBalancerDeleteProtectionRequest) SetResourceOwnerAccount(v string) *SetLoadBalancerDeleteProtectionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SetLoadBalancerDeleteProtectionRequest) SetResourceOwnerId(v int64) *SetLoadBalancerDeleteProtectionRequest {
	s.ResourceOwnerId = &v
	return s
}

type SetLoadBalancerDeleteProtectionResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetLoadBalancerDeleteProtectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetLoadBalancerDeleteProtectionResponseBody) GoString() string {
	return s.String()
}

func (s *SetLoadBalancerDeleteProtectionResponseBody) SetRequestId(v string) *SetLoadBalancerDeleteProtectionResponseBody {
	s.RequestId = &v
	return s
}

type SetLoadBalancerDeleteProtectionResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetLoadBalancerDeleteProtectionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetLoadBalancerDeleteProtectionResponse) String() string {
	return tea.Prettify(s)
}

func (s SetLoadBalancerDeleteProtectionResponse) GoString() string {
	return s.String()
}

func (s *SetLoadBalancerDeleteProtectionResponse) SetHeaders(v map[string]*string) *SetLoadBalancerDeleteProtectionResponse {
	s.Headers = v
	return s
}

func (s *SetLoadBalancerDeleteProtectionResponse) SetStatusCode(v int32) *SetLoadBalancerDeleteProtectionResponse {
	s.StatusCode = &v
	return s
}

func (s *SetLoadBalancerDeleteProtectionResponse) SetBody(v *SetLoadBalancerDeleteProtectionResponseBody) *SetLoadBalancerDeleteProtectionResponse {
	s.Body = v
	return s
}

type SetLoadBalancerHTTPListenerAttributeRequest struct {
	// The type of the ACL. Valid values:
	//
	// *   **white**: a whitelist. Only requests from the IP addresses or CIDR blocks in the network ACL are forwarded. Whitelists apply to scenarios where you want to allow only specific IP addresses to access an application. Risks may arise if the whitelist is improperly set. After the whitelist is set, only requests from IP addresses that are added to the whitelist are forwarded by the listener.
	//
	//     If the whitelist does not contain IP addresses, the CLB listener forwards all requests.
	//
	// *   **black**: a blacklist. All requests from the IP addresses or CIDR blocks in the ACL are rejected. Blacklists apply to scenarios where you want to block access from specified IP addresses to an application.
	//
	//     If no IP address is added to the blacklist, the listener forwards all requests.
	//
	// >  If **AclStatus** is set to **on**, this parameter is required.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The timeout period of an idle connection. Unit: seconds. Valid values: **1 to 60**. Default value: **15**.
	//
	// If no request is received within the specified timeout period, CLB closes the connection. When another request is received, CLB establishes a new connection.
	AclStatus *string `json:"AclStatus,omitempty" xml:"AclStatus,omitempty"`
	// Specifies whether to enable the access control feature. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	AclType *string `json:"AclType,omitempty" xml:"AclType,omitempty"`
	// Specifies whether to use the `X-Forwarded-For` header to preserve the real IP address of the client. Valid values:
	//
	// *   **on** (default): yes
	// *   **off**: no
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// Specifies whether to enable health checks. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	Cookie *string `json:"Cookie,omitempty" xml:"Cookie,omitempty"`
	// The cookie that is configured on the server.
	//
	// The cookie must be 1 to 200 characters in length, and can contain ASCII characters and digits. It cannot contain commas (,), semicolons (;), or spaces. It cannot start with a dollar sign ($).
	//
	// >  This parameter is required if the **StickySession** parameter is set to **on** and the **StickySessionType** parameter is set to **server**.
	CookieTimeout *int32 `json:"CookieTimeout,omitempty" xml:"CookieTimeout,omitempty"`
	// The ID of the request.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the access control list (ACL) to be associated with the listener.
	//
	// >  If **AclStatus** is set to **on**, this parameter is required.
	Gzip *string `json:"Gzip,omitempty" xml:"Gzip,omitempty"`
	// The health check method used in HTTP health checks. Valid values: **head** and **get**.
	//
	// >  This parameter takes effect only if the **HealthCheck** parameter is set to **on**.
	HealthCheck *string `json:"HealthCheck,omitempty" xml:"HealthCheck,omitempty"`
	// The HTTP status code that indicates a successful health check. Separate HTTP status codes with commas (,).
	//
	// Valid values: **http\_2xx**, **http\_3xx**, **http\_4xx**, and **http\_5xx**.
	//
	// >  This parameter takes effect only when the **HealthCheck** parameter is set to **on**.
	HealthCheckConnectPort *int32 `json:"HealthCheckConnectPort,omitempty" xml:"HealthCheckConnectPort,omitempty"`
	// The uniform resource identifier (URI) that is used for health checks.
	//
	// The URI must be 1 to 80 characters in length, and can contain letters, digits, and the following characters: - / . % ? # & The URI must start with a forward slash (/) but cannot be a single forward slash (/).
	//
	// >  This parameter takes effect only if the **HealthCheck** parameter is set to **on**.
	HealthCheckDomain *string `json:"HealthCheckDomain,omitempty" xml:"HealthCheckDomain,omitempty"`
	// Specifies whether to use a vServer group. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	HealthCheckHttpCode *string `json:"HealthCheckHttpCode,omitempty" xml:"HealthCheckHttpCode,omitempty"`
	// The port that is used for health checks.
	//
	// Valid values: **1** to **65535**.
	//
	// >  This parameter takes effect only if the **HealthCheck** parameter is set to **on**.
	HealthCheckInterval *int32 `json:"HealthCheckInterval,omitempty" xml:"HealthCheckInterval,omitempty"`
	// The domain name that is used for health checks. Valid values:
	//
	// *   **$\_ip**: the private IP address of a backend server. If **HealthCheckDomain** is set to **$\_ip** or is not set, CLB uses the private IP address of each backend server as the domain name for health checks.
	// *   **domain**: The domain name must be 1 to 80 characters in length, and can contain letters, digits, periods (.),and hyphens (-).
	//
	// >  This parameter takes effect only if the **HealthCheck** parameter is set to **on**.
	HealthCheckMethod *string `json:"HealthCheckMethod,omitempty" xml:"HealthCheckMethod,omitempty"`
	// The time interval between two consecutive health checks.
	//
	// Valid values: **1** to **50**. Unit: seconds.
	//
	// >  This parameter takes effect only when the **HealthCheck** parameter is set to **on**.
	HealthCheckTimeout *int32 `json:"HealthCheckTimeout,omitempty" xml:"HealthCheckTimeout,omitempty"`
	// The number of health checks that an unhealthy backend server must consecutively pass before it can be declared healthy (from **fail** to **success**).
	//
	// Valid values: **2** to **10**.
	//
	// >  This parameter takes effect only when the **HealthCheck** parameter is set to **on**.
	HealthCheckURI *string `json:"HealthCheckURI,omitempty" xml:"HealthCheckURI,omitempty"`
	// The number of consecutive health check failures before a backend server is declared unhealthy (from **success** to **fail**).
	//
	// Valid values: **2** to **10**.
	//
	// >  This parameter takes effect only if the **HealthCheck** parameter is set to **on**.
	HealthyThreshold *int32 `json:"HealthyThreshold,omitempty" xml:"HealthyThreshold,omitempty"`
	// The timeout period of a request. Unit: seconds. Valid values: **1 to 180**. Default value: **60**.
	//
	// If no response is received from the backend server within the request timeout period, CLB returns an HTTP 504 error code to the client.
	IdleTimeout *int32 `json:"IdleTimeout,omitempty" xml:"IdleTimeout,omitempty"`
	// The maximum bandwidth of the listener. Unit: Mbit/s. Valid values:
	//
	// *   **-1**: For a pay-by-data-transfer Internet-facing CLB instance, you can set this parameter to **-1**. In this case, the bandwidth of the listener is unlimited.
	ListenerPort *int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	// The frontend port that is used by the CLB instance.
	//
	// Valid values: **1** to **65535**.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The operation that you want to perform.
	//
	// Set the value to **SetLoadBalancerHTTPListenerAttribute**.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The description of the listener.
	RequestTimeout       *int32  `json:"RequestTimeout,omitempty" xml:"RequestTimeout,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// Specifies whether to enable session persistence. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	Scheduler *string `json:"Scheduler,omitempty" xml:"Scheduler,omitempty"`
	// The method that is used to handle a cookie. Valid values:
	//
	// *   **insert**: inserts a cookie.
	//
	//     CLB inserts a cookie (SERVERID) into the first HTTP or HTTPS response packet that is sent to a client. The next request from the client will contain this cookie, and the listener will distribute this request to the recorded backend server.
	//
	// *   **server**: rewrites a cookie.
	//
	//     When CLB detects a user-defined cookie, it overwrites the original cookie with the user-defined cookie. The next request from the client will contain the user-defined cookie, and the listener will distribute this request to the recorded backend server.
	//
	// >This parameter is required if the **StickySession** parameter is set to **on**.
	StickySession *string `json:"StickySession,omitempty" xml:"StickySession,omitempty"`
	// The timeout period of the cookie. Unit: seconds.
	//
	// Valid values: **1** to **86400**.
	//
	// >  If **StickySession** is set to **on** and **StickySessionType** is set to **insert**, this parameter is required.
	StickySessionType *string `json:"StickySessionType,omitempty" xml:"StickySessionType,omitempty"`
	// The timeout period of a health check response. If a backend Elastic Compute Service (ECS) instance does not send an expected response within the specified period of time, the ECS instance is considered unhealthy. This parameter takes effect only when the **HealthCheck** parameter is set to **on**.
	//
	// Valid values: **1** to **300**. Unit: seconds.
	//
	// >  If the value of the **HealthCheckTimeout** parameter is smaller than that of the **HealthCheckInterval** parameter, the timeout period specified by the **HealthCheckTimeout** parameter is ignored and the period of time specified by the **HealthCheckInterval** parameter is used as the timeout period.
	UnhealthyThreshold *int32 `json:"UnhealthyThreshold,omitempty" xml:"UnhealthyThreshold,omitempty"`
	// The ID of the vServer group.
	VServerGroup *string `json:"VServerGroup,omitempty" xml:"VServerGroup,omitempty"`
	// Indicates whether to use the `SLB-IP` header to retrieve the virtual IP address (VIP) requested by the client. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
	// The scheduling algorithm. Valid values:
	//
	// *   **wrr**: Backend servers that have higher weights receive more requests than backend servers that have lower weights.
	// *   **rr**: Requests are distributed to backend servers in sequence.
	XForwardedFor *string `json:"XForwardedFor,omitempty" xml:"XForwardedFor,omitempty"`
	// Specifies whether to use the `X-Forwarded-Proto` header to retrieve the listener protocol. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	XForwardedFor_SLBID *string `json:"XForwardedFor_SLBID,omitempty" xml:"XForwardedFor_SLBID,omitempty"`
	// Specifies whether to use the `SLB-ID` header to retrieve the ID of the CLB instance. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	XForwardedFor_SLBIP *string `json:"XForwardedFor_SLBIP,omitempty" xml:"XForwardedFor_SLBIP,omitempty"`
	// Specifies whether to enable `Gzip` compression to compress specific types of files. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	XForwardedFor_proto *string `json:"XForwardedFor_proto,omitempty" xml:"XForwardedFor_proto,omitempty"`
}

func (s SetLoadBalancerHTTPListenerAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s SetLoadBalancerHTTPListenerAttributeRequest) GoString() string {
	return s.String()
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetAclId(v string) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.AclId = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetAclStatus(v string) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.AclStatus = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetAclType(v string) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.AclType = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetBandwidth(v int32) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.Bandwidth = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetCookie(v string) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.Cookie = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetCookieTimeout(v int32) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.CookieTimeout = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetDescription(v string) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.Description = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetGzip(v string) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.Gzip = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetHealthCheck(v string) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.HealthCheck = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetHealthCheckConnectPort(v int32) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.HealthCheckConnectPort = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetHealthCheckDomain(v string) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.HealthCheckDomain = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetHealthCheckHttpCode(v string) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.HealthCheckHttpCode = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetHealthCheckInterval(v int32) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.HealthCheckInterval = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetHealthCheckMethod(v string) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.HealthCheckMethod = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetHealthCheckTimeout(v int32) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.HealthCheckTimeout = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetHealthCheckURI(v string) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.HealthCheckURI = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetHealthyThreshold(v int32) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.HealthyThreshold = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetIdleTimeout(v int32) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.IdleTimeout = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetListenerPort(v int32) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.ListenerPort = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetLoadBalancerId(v string) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetOwnerAccount(v string) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetOwnerId(v int64) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetRegionId(v string) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetRequestTimeout(v int32) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.RequestTimeout = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetResourceOwnerAccount(v string) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetResourceOwnerId(v int64) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetScheduler(v string) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.Scheduler = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetStickySession(v string) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.StickySession = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetStickySessionType(v string) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.StickySessionType = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetUnhealthyThreshold(v int32) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.UnhealthyThreshold = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetVServerGroup(v string) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.VServerGroup = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetVServerGroupId(v string) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.VServerGroupId = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetXForwardedFor(v string) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.XForwardedFor = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetXForwardedFor_SLBID(v string) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.XForwardedFor_SLBID = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetXForwardedFor_SLBIP(v string) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.XForwardedFor_SLBIP = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeRequest) SetXForwardedFor_proto(v string) *SetLoadBalancerHTTPListenerAttributeRequest {
	s.XForwardedFor_proto = &v
	return s
}

type SetLoadBalancerHTTPListenerAttributeResponseBody struct {
	// ## Prerequisites
	//
	// *   A Classic Load Balancer (CLB) instance is created. For more information, see [CreateLoadBalancer](~~27577~~).
	// *   An HTTP listener is created. For more information about how to create an HTTP listener, see [CreateLoadBalancerHTTPListener](~~27592~~).
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetLoadBalancerHTTPListenerAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetLoadBalancerHTTPListenerAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *SetLoadBalancerHTTPListenerAttributeResponseBody) SetRequestId(v string) *SetLoadBalancerHTTPListenerAttributeResponseBody {
	s.RequestId = &v
	return s
}

type SetLoadBalancerHTTPListenerAttributeResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetLoadBalancerHTTPListenerAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetLoadBalancerHTTPListenerAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s SetLoadBalancerHTTPListenerAttributeResponse) GoString() string {
	return s.String()
}

func (s *SetLoadBalancerHTTPListenerAttributeResponse) SetHeaders(v map[string]*string) *SetLoadBalancerHTTPListenerAttributeResponse {
	s.Headers = v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeResponse) SetStatusCode(v int32) *SetLoadBalancerHTTPListenerAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *SetLoadBalancerHTTPListenerAttributeResponse) SetBody(v *SetLoadBalancerHTTPListenerAttributeResponseBody) *SetLoadBalancerHTTPListenerAttributeResponse {
	s.Body = v
	return s
}

type SetLoadBalancerHTTPSListenerAttributeRequest struct {
	// Specifies whether to enable access control. Valid values:
	//
	// *   **on**: enables access control
	// *   **off**: disables access control
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The timeout period of a request. Unit: seconds. Valid values: **1 to 180**. Default value: **60**.
	//
	// If no response is received from the backend server during the request timeout period, CLB sends an HTTP 504 error code to the client.
	AclStatus *string `json:"AclStatus,omitempty" xml:"AclStatus,omitempty"`
	// The timeout period of an idle connection. Unit: seconds. Valid values: **1 to 60**. Default value: **15**.
	//
	// If no request is received within the specified timeout period, CLB closes the connection. When another request is received, CLB establishes a new connection.
	AclType *string `json:"AclType,omitempty" xml:"AclType,omitempty"`
	// The scheduling algorithm. Valid values:
	//
	// *   **wrr**: Backend servers that have higher weights receive more requests than backend servers that have lower weights.
	// *   **rr**: Requests are distributed to backend servers in sequence.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The ID of the vServer group.
	CACertificateId *string `json:"CACertificateId,omitempty" xml:"CACertificateId,omitempty"`
	// The HTTP method that is used for health checks. Valid values: **head** and **get**.
	//
	// >  This parameter takes effect only when the **HealthCheck** parameter is set to **on**.
	Cookie *string `json:"Cookie,omitempty" xml:"Cookie,omitempty"`
	// Specifies whether to enable health checks. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	CookieTimeout *int32 `json:"CookieTimeout,omitempty" xml:"CookieTimeout,omitempty"`
	// ## Prerequisites
	//
	// *   A Classic Load Balancer (CLB) instance is created. For more information, see [CreateLoadBalancer](~~27577~~).
	// *   An HTTPS listener is created. For more information about how to create an HTTPS listener, see [CreateLoadBalancerHTTPSListener](~~27593~~).
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The description of the listener.
	EnableHttp2 *string `json:"EnableHttp2,omitempty" xml:"EnableHttp2,omitempty"`
	// The type of network ACL. Valid values:
	//
	// *   **white**: a whitelist. Only requests from the IP addresses or CIDR blocks in the network ACL are forwarded. Whitelists apply to scenarios where you want to allow only specific IP addresses to access an application. Your business may be adversely affected if the whitelist is not set properly. After a whitelist is configured, only IP addresses in the whitelist can access the CLB listener.
	//
	//     If no IP address is added to the whitelist, the CLB listener forwards all requests.
	//
	// *   **black**: a blacklist. All requests from the IP addresses or CIDR blocks in the network ACL are denied. Blacklists apply to scenarios where you want to deny access from specified IP addresses to an application.
	//
	//     If no IP address is added to the blacklist, the listener forwards all requests.
	//
	// >  This parameter takes effect only when **AclStatus** is set to **on**.
	Gzip *string `json:"Gzip,omitempty" xml:"Gzip,omitempty"`
	// The domain name that is used for health checks. Valid values:
	//
	// *   **$\_ip**: the private IP address of a backend server. If you do not set this parameter or set the parameter to $\_ip, the CLB instance uses the private IP address of each backend server as the domain name for health checks.
	// *   **domain**: The domain name must be 1 to 80 characters in length, and can contain letters, digits, periods (.),and hyphens (-).
	//
	// >  This parameter takes effect only when the **HealthCheck** parameter is set to **on**.
	HealthCheck *string `json:"HealthCheck,omitempty" xml:"HealthCheck,omitempty"`
	// The ID of the server certificate.
	HealthCheckConnectPort *int32 `json:"HealthCheckConnectPort,omitempty" xml:"HealthCheckConnectPort,omitempty"`
	// The number of health checks that an unhealthy backend server must consecutively pass before it can be declared healthy (from **fail** to **success**).
	//
	// Valid values: **2** to **10**.
	//
	// >  This parameter takes effect only when the **HealthCheck** parameter is set to **on**.
	HealthCheckDomain *string `json:"HealthCheckDomain,omitempty" xml:"HealthCheckDomain,omitempty"`
	// The ID of the CA certificate.
	//
	// *   If both the CA certificate and the server certificate are uploaded, mutual authentication is used.
	// *   If you upload only the server certificate, one-way authentication is used.
	HealthCheckHttpCode *string `json:"HealthCheckHttpCode,omitempty" xml:"HealthCheckHttpCode,omitempty"`
	// The HTTP status code of a successful health check. Separate multiple HTTP status codes with commas (,).
	//
	// Valid values: **http\_2xx**, **http\_3xx**, **http\_4xx**, and **http\_5xx**.
	//
	// >  This parameter takes effect only when the **HealthCheck** parameter is set to **on**.
	HealthCheckInterval *int32 `json:"HealthCheckInterval,omitempty" xml:"HealthCheckInterval,omitempty"`
	// The URL that is used for health checks.
	//
	// The URL must be 1 to 80 characters in length and can contain letters, digits, and the following characters: - / . % ? # &. The URL must not be a single forward slash (/) but it must start with a forward slash (/).
	//
	// >  This parameter takes effect only when the **HealthCheck** parameter is set to **on**.
	HealthCheckMethod *string `json:"HealthCheckMethod,omitempty" xml:"HealthCheckMethod,omitempty"`
	// The port that is used for health checks.
	//
	// Valid values: **1** to **65535**.
	//
	// >  This parameter takes effect only when the **HealthCheck** parameter is set to **on**.
	HealthCheckTimeout *int32 `json:"HealthCheckTimeout,omitempty" xml:"HealthCheckTimeout,omitempty"`
	// The number of health checks that a healthy backend server must consecutively fail before it can be declared unhealthy (from **success** to **fail**).
	//
	// Valid values: **2** to **10**.
	//
	// >  This parameter takes effect only when the **HealthCheck** parameter is set to **on**.
	HealthCheckURI *string `json:"HealthCheckURI,omitempty" xml:"HealthCheckURI,omitempty"`
	// The timeout period of a health check response. If a backend server does not respond within the specified timeout period, the health check fails. Unit: seconds.
	//
	// Valid values: **1** to **300**.
	//
	// If the value of the **HealthCheckTimeout** parameter is smaller than that of the **HealthCheckInterval** parameter, the timeout period specified by the **HealthCheckTimeout** parameter is ignored and the period of time specified by the **HealthCheckInterval** parameter is used as the timeout period.
	//
	// >  This parameter takes effect only when the **HealthCheck** parameter is set to **on**.
	HealthyThreshold *int32 `json:"HealthyThreshold,omitempty" xml:"HealthyThreshold,omitempty"`
	// Specifies whether to use `HTTP 2.0`. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	IdleTimeout *int32 `json:"IdleTimeout,omitempty" xml:"IdleTimeout,omitempty"`
	// Specifies whether to use the `X-Forwarded-For` header to retrieve client IP addresses. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	ListenerPort *int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	// The bandwidth limit of the listener. Unit: Mbit/s.
	//
	// Valid values: **-1** and **1** to **5120**.
	//
	// *   **-1**: If you set the value to -1, the bandwidth of the listener is unlimited.
	// *   **1** to **5120**: If you set a value from 1 to 5120, the value that you specify equals the bandwidth limit of the listener. The sum of bandwidth limit values that you specify for all listeners of the CLB instance cannot exceed the bandwidth limit of the CLB instance.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the CLB instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The Transport Layer Security (TLS) security policy. Each security policy contains TLS protocol versions and cipher suites available for HTTPS.
	//
	// *   **tls_cipher_policy\_1\_0**:
	//
	//     Supported TLS versions: TLS 1.0, TLS 1.1, and TLS 1.2
	//
	//     Supported cipher suites: ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, AES128-GCM-SHA256, AES256-GCM-SHA384, AES128-SHA256, AES256-SHA256, ECDHE-RSA-AES128-SHA, ECDHE-RSA-AES256-SHA, AES128-SHA, AES256-SHA, and DES-CBC3-SHA
	//
	// *   **tls_cipher_policy\_1\_1**:
	//
	//     Supported TLS versions: TLS 1.1 and TLS 1.2
	//
	//     Supported cipher suites: ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, AES128-GCM-SHA256, AES256-GCM-SHA384, AES128-SHA256, AES256-SHA256, ECDHE-RSA-AES128-SHA, ECDHE-RSA-AES256-SHA, AES128-SHA, AES256-SHA, and DES-CBC3-SHA
	//
	// *   **tls_cipher_policy\_1\_2**
	//
	//     Supported TLS version: TLS 1.2
	//
	//     Supported cipher suites: ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, AES128-GCM-SHA256, AES256-GCM-SHA384, AES128-SHA256, AES256-SHA256, ECDHE-RSA-AES128-SHA, ECDHE-RSA-AES256-SHA, AES128-SHA, AES256-SHA, and DES-CBC3-SHA
	//
	// *   **tls_cipher_policy\_1\_2\_strict**
	//
	//     Supported TLS version: TLS 1.2
	//
	//     Supported cipher suites: ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, ECDHE-RSA-AES128-SHA, and ECDHE-RSA-AES256-SHA
	//
	// *   **tls_cipher_policy\_1\_2\_strict_with\_1\_3**
	//
	//     Supported TLS versions: TLS 1.2 and TLS 1.3
	//
	//     Supported cipher suites: TLS_AES\_128\_GCM_SHA256, TLS_AES\_256\_GCM_SHA384, TLS_CHACHA20\_POLY1305\_SHA256, TLS_AES\_128\_CCM_SHA256, TLS_AES\_128\_CCM\_8\_SHA256, ECDHE-ECDSA-AES128-GCM-SHA256, ECDHE-ECDSA-AES256-GCM-SHA384, ECDHE-ECDSA-AES128-SHA256, ECDHE-ECDSA-AES256-SHA384, ECDHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, ECDHE-ECDSA-AES128-SHA, ECDHE-ECDSA-AES256-SHA, ECDHE-RSA-AES128-SHA, and ECDHE-RSA-AES256-SHA
	RequestTimeout       *int32  `json:"RequestTimeout,omitempty" xml:"RequestTimeout,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The method that is used to handle a cookie. Valid values:
	//
	// *   **insert**: inserts a cookie.
	//
	//     CLB inserts a cookie (SERVERID) into the first HTTP or HTTPS response that is sent to a client. The next request from the client will contain this cookie, and the listener will distribute this request to the recorded backend server.
	//
	// *   **server**: rewrites a cookie.
	//
	//     When CLB detects a user-defined cookie, it overwrites the original cookie with the user-defined cookie. The next request from the client will contain the user-defined cookie, and the listener will distribute this request to the recorded backend server.
	//
	// >  This parameter is required if the **StickySession** parameter is set to **on**.
	Scheduler *string `json:"Scheduler,omitempty" xml:"Scheduler,omitempty"`
	// Specifies whether to use a vServer group. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	ServerCertificateId *string `json:"ServerCertificateId,omitempty" xml:"ServerCertificateId,omitempty"`
	// The timeout period of the cookie. Unit: seconds.
	//
	// Valid values: **1** to **86400**.
	//
	// >  This parameter is required if the **StickySession** parameter is set to **on** and the **StickySessionType** parameter is set to **insert**.
	StickySession *string `json:"StickySession,omitempty" xml:"StickySession,omitempty"`
	// The cookie to be configured on the backend server.
	//
	// The cookie must be 1 to 200 characters in length, and can contain only ASCII characters and digits. It cannot contain commas (,), semicolons (;), or space characters. It cannot start with a dollar sign ($).
	//
	// >  This parameter is required if the **StickySession** parameter is set to **on** and the **StickySessionType** parameter is set to **server**.
	StickySessionType *string `json:"StickySessionType,omitempty" xml:"StickySessionType,omitempty"`
	// The ID of the request.
	TLSCipherPolicy *string `json:"TLSCipherPolicy,omitempty" xml:"TLSCipherPolicy,omitempty"`
	// The interval between two consecutive health checks. Unit: seconds.
	//
	// Valid values: **1** to **50**.
	//
	// >  This parameter takes effect only when the **HealthCheck** parameter is set to **on**.
	UnhealthyThreshold *int32 `json:"UnhealthyThreshold,omitempty" xml:"UnhealthyThreshold,omitempty"`
	// Specifies whether to use the `SLB-IP` header to obtain the virtual IP address (VIP) requested by the client. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	VServerGroup *string `json:"VServerGroup,omitempty" xml:"VServerGroup,omitempty"`
	// Specifies whether to use the `SLB-ID` header to retrieve the ID of the CLB instance. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
	// Specifies whether to enable session persistence. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	XForwardedFor *string `json:"XForwardedFor,omitempty" xml:"XForwardedFor,omitempty"`
	// Specifies whether to enable `Gzip` compression to compress specific types of files. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	XForwardedFor_SLBID *string `json:"XForwardedFor_SLBID,omitempty" xml:"XForwardedFor_SLBID,omitempty"`
	// Specifies whether to use the `X-Forwarded-Proto` header to retrieve the listener protocol. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	XForwardedFor_SLBIP *string `json:"XForwardedFor_SLBIP,omitempty" xml:"XForwardedFor_SLBIP,omitempty"`
	// The ID of the network access control list (ACL) that you want to associate with the listener.
	//
	// If **AclStatus** is set to **on**, this parameter is required.
	XForwardedFor_proto *string `json:"XForwardedFor_proto,omitempty" xml:"XForwardedFor_proto,omitempty"`
}

func (s SetLoadBalancerHTTPSListenerAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s SetLoadBalancerHTTPSListenerAttributeRequest) GoString() string {
	return s.String()
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetAclId(v string) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.AclId = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetAclStatus(v string) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.AclStatus = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetAclType(v string) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.AclType = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetBandwidth(v int32) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.Bandwidth = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetCACertificateId(v string) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.CACertificateId = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetCookie(v string) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.Cookie = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetCookieTimeout(v int32) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.CookieTimeout = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetDescription(v string) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.Description = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetEnableHttp2(v string) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.EnableHttp2 = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetGzip(v string) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.Gzip = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetHealthCheck(v string) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.HealthCheck = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetHealthCheckConnectPort(v int32) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.HealthCheckConnectPort = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetHealthCheckDomain(v string) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.HealthCheckDomain = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetHealthCheckHttpCode(v string) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.HealthCheckHttpCode = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetHealthCheckInterval(v int32) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.HealthCheckInterval = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetHealthCheckMethod(v string) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.HealthCheckMethod = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetHealthCheckTimeout(v int32) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.HealthCheckTimeout = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetHealthCheckURI(v string) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.HealthCheckURI = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetHealthyThreshold(v int32) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.HealthyThreshold = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetIdleTimeout(v int32) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.IdleTimeout = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetListenerPort(v int32) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.ListenerPort = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetLoadBalancerId(v string) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetOwnerAccount(v string) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetOwnerId(v int64) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetRegionId(v string) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetRequestTimeout(v int32) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.RequestTimeout = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetResourceOwnerAccount(v string) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetResourceOwnerId(v int64) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetScheduler(v string) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.Scheduler = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetServerCertificateId(v string) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.ServerCertificateId = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetStickySession(v string) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.StickySession = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetStickySessionType(v string) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.StickySessionType = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetTLSCipherPolicy(v string) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.TLSCipherPolicy = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetUnhealthyThreshold(v int32) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.UnhealthyThreshold = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetVServerGroup(v string) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.VServerGroup = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetVServerGroupId(v string) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.VServerGroupId = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetXForwardedFor(v string) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.XForwardedFor = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetXForwardedFor_SLBID(v string) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.XForwardedFor_SLBID = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetXForwardedFor_SLBIP(v string) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.XForwardedFor_SLBIP = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeRequest) SetXForwardedFor_proto(v string) *SetLoadBalancerHTTPSListenerAttributeRequest {
	s.XForwardedFor_proto = &v
	return s
}

type SetLoadBalancerHTTPSListenerAttributeResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetLoadBalancerHTTPSListenerAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetLoadBalancerHTTPSListenerAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *SetLoadBalancerHTTPSListenerAttributeResponseBody) SetRequestId(v string) *SetLoadBalancerHTTPSListenerAttributeResponseBody {
	s.RequestId = &v
	return s
}

type SetLoadBalancerHTTPSListenerAttributeResponse struct {
	Headers    map[string]*string                                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetLoadBalancerHTTPSListenerAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetLoadBalancerHTTPSListenerAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s SetLoadBalancerHTTPSListenerAttributeResponse) GoString() string {
	return s.String()
}

func (s *SetLoadBalancerHTTPSListenerAttributeResponse) SetHeaders(v map[string]*string) *SetLoadBalancerHTTPSListenerAttributeResponse {
	s.Headers = v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeResponse) SetStatusCode(v int32) *SetLoadBalancerHTTPSListenerAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *SetLoadBalancerHTTPSListenerAttributeResponse) SetBody(v *SetLoadBalancerHTTPSListenerAttributeResponseBody) *SetLoadBalancerHTTPSListenerAttributeResponse {
	s.Body = v
	return s
}

type SetLoadBalancerModificationProtectionRequest struct {
	// The ID of the CLB instance.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// The reason why the configuration read-only mode is enabled. The value must be 1 to 80 characters in length. It must start with a letter and can contain letters, digits, periods (.), underscores (\_), and hyphens (-).
	//
	// >  This parameter is valid only if the **ModificationProtectionStatus** parameter is set to **ConsoleProtection**.
	ModificationProtectionReason *string `json:"ModificationProtectionReason,omitempty" xml:"ModificationProtectionReason,omitempty"`
	// Specifies whether to enable the configuration read-only mode. Valid values:
	//
	// *   **NonProtection**: disables the configuration read-only mode. After you disable the configuration read-only mode, the value of **ModificationProtectionReason** is cleared.
	// *   **ConsoleProtection**: enables the configuration read-only mode.
	//
	// >  If you set this parameter to **ConsoleProtection**, you cannot use the CLB console to modify instance configurations. However, you can call API operations to modify instance configurations.
	ModificationProtectionStatus *string `json:"ModificationProtectionStatus,omitempty" xml:"ModificationProtectionStatus,omitempty"`
	OwnerAccount                 *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the CLB instance.
	//
	// You can call the [DescribeRegions](~~27584~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s SetLoadBalancerModificationProtectionRequest) String() string {
	return tea.Prettify(s)
}

func (s SetLoadBalancerModificationProtectionRequest) GoString() string {
	return s.String()
}

func (s *SetLoadBalancerModificationProtectionRequest) SetLoadBalancerId(v string) *SetLoadBalancerModificationProtectionRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *SetLoadBalancerModificationProtectionRequest) SetModificationProtectionReason(v string) *SetLoadBalancerModificationProtectionRequest {
	s.ModificationProtectionReason = &v
	return s
}

func (s *SetLoadBalancerModificationProtectionRequest) SetModificationProtectionStatus(v string) *SetLoadBalancerModificationProtectionRequest {
	s.ModificationProtectionStatus = &v
	return s
}

func (s *SetLoadBalancerModificationProtectionRequest) SetOwnerAccount(v string) *SetLoadBalancerModificationProtectionRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SetLoadBalancerModificationProtectionRequest) SetOwnerId(v int64) *SetLoadBalancerModificationProtectionRequest {
	s.OwnerId = &v
	return s
}

func (s *SetLoadBalancerModificationProtectionRequest) SetRegionId(v string) *SetLoadBalancerModificationProtectionRequest {
	s.RegionId = &v
	return s
}

func (s *SetLoadBalancerModificationProtectionRequest) SetResourceOwnerAccount(v string) *SetLoadBalancerModificationProtectionRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SetLoadBalancerModificationProtectionRequest) SetResourceOwnerId(v int64) *SetLoadBalancerModificationProtectionRequest {
	s.ResourceOwnerId = &v
	return s
}

type SetLoadBalancerModificationProtectionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetLoadBalancerModificationProtectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetLoadBalancerModificationProtectionResponseBody) GoString() string {
	return s.String()
}

func (s *SetLoadBalancerModificationProtectionResponseBody) SetRequestId(v string) *SetLoadBalancerModificationProtectionResponseBody {
	s.RequestId = &v
	return s
}

type SetLoadBalancerModificationProtectionResponse struct {
	Headers    map[string]*string                                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetLoadBalancerModificationProtectionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetLoadBalancerModificationProtectionResponse) String() string {
	return tea.Prettify(s)
}

func (s SetLoadBalancerModificationProtectionResponse) GoString() string {
	return s.String()
}

func (s *SetLoadBalancerModificationProtectionResponse) SetHeaders(v map[string]*string) *SetLoadBalancerModificationProtectionResponse {
	s.Headers = v
	return s
}

func (s *SetLoadBalancerModificationProtectionResponse) SetStatusCode(v int32) *SetLoadBalancerModificationProtectionResponse {
	s.StatusCode = &v
	return s
}

func (s *SetLoadBalancerModificationProtectionResponse) SetBody(v *SetLoadBalancerModificationProtectionResponseBody) *SetLoadBalancerModificationProtectionResponse {
	s.Body = v
	return s
}

type SetLoadBalancerNameRequest struct {
	LoadBalancerId   *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	LoadBalancerName *string `json:"LoadBalancerName,omitempty" xml:"LoadBalancerName,omitempty"`
	OwnerAccount     *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId          *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the CLB instance is deployed.
	//
	// You can call the [DescribeRegions](~~25609~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s SetLoadBalancerNameRequest) String() string {
	return tea.Prettify(s)
}

func (s SetLoadBalancerNameRequest) GoString() string {
	return s.String()
}

func (s *SetLoadBalancerNameRequest) SetLoadBalancerId(v string) *SetLoadBalancerNameRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *SetLoadBalancerNameRequest) SetLoadBalancerName(v string) *SetLoadBalancerNameRequest {
	s.LoadBalancerName = &v
	return s
}

func (s *SetLoadBalancerNameRequest) SetOwnerAccount(v string) *SetLoadBalancerNameRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SetLoadBalancerNameRequest) SetOwnerId(v int64) *SetLoadBalancerNameRequest {
	s.OwnerId = &v
	return s
}

func (s *SetLoadBalancerNameRequest) SetRegionId(v string) *SetLoadBalancerNameRequest {
	s.RegionId = &v
	return s
}

func (s *SetLoadBalancerNameRequest) SetResourceOwnerAccount(v string) *SetLoadBalancerNameRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SetLoadBalancerNameRequest) SetResourceOwnerId(v int64) *SetLoadBalancerNameRequest {
	s.ResourceOwnerId = &v
	return s
}

type SetLoadBalancerNameResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetLoadBalancerNameResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetLoadBalancerNameResponseBody) GoString() string {
	return s.String()
}

func (s *SetLoadBalancerNameResponseBody) SetRequestId(v string) *SetLoadBalancerNameResponseBody {
	s.RequestId = &v
	return s
}

type SetLoadBalancerNameResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetLoadBalancerNameResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetLoadBalancerNameResponse) String() string {
	return tea.Prettify(s)
}

func (s SetLoadBalancerNameResponse) GoString() string {
	return s.String()
}

func (s *SetLoadBalancerNameResponse) SetHeaders(v map[string]*string) *SetLoadBalancerNameResponse {
	s.Headers = v
	return s
}

func (s *SetLoadBalancerNameResponse) SetStatusCode(v int32) *SetLoadBalancerNameResponse {
	s.StatusCode = &v
	return s
}

func (s *SetLoadBalancerNameResponse) SetBody(v *SetLoadBalancerNameResponseBody) *SetLoadBalancerNameResponse {
	s.Body = v
	return s
}

type SetLoadBalancerStatusRequest struct {
	// The ID of the CLB instance.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// The state of the CLB instance. Valid values: **active** and **inactive**.
	//
	// *   **active** (default)
	//
	//     If a CLB instance is in the **active** state, listeners of the CLB instance can forward traffic based on forwarding rules.
	//
	//     By default, newly created CLB instances are in the **active** state.
	//
	// *   **inactive**
	//
	//     If a CLB instance is in the **inactive** state, listeners of the CLB instance do not forward traffic.
	//
	// >  If all listeners of a CLB instance are deleted, the CLB instance automatically switches to the **inactive** state.
	LoadBalancerStatus *string `json:"LoadBalancerStatus,omitempty" xml:"LoadBalancerStatus,omitempty"`
	OwnerAccount       *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId            *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the CLB instance is deployed.
	//
	// You can query region IDs from the [Regions and zones](~~40654~~) list or by calling the [DescribeRegions](~~25609~~) operation.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s SetLoadBalancerStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s SetLoadBalancerStatusRequest) GoString() string {
	return s.String()
}

func (s *SetLoadBalancerStatusRequest) SetLoadBalancerId(v string) *SetLoadBalancerStatusRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *SetLoadBalancerStatusRequest) SetLoadBalancerStatus(v string) *SetLoadBalancerStatusRequest {
	s.LoadBalancerStatus = &v
	return s
}

func (s *SetLoadBalancerStatusRequest) SetOwnerAccount(v string) *SetLoadBalancerStatusRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SetLoadBalancerStatusRequest) SetOwnerId(v int64) *SetLoadBalancerStatusRequest {
	s.OwnerId = &v
	return s
}

func (s *SetLoadBalancerStatusRequest) SetRegionId(v string) *SetLoadBalancerStatusRequest {
	s.RegionId = &v
	return s
}

func (s *SetLoadBalancerStatusRequest) SetResourceOwnerAccount(v string) *SetLoadBalancerStatusRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SetLoadBalancerStatusRequest) SetResourceOwnerId(v int64) *SetLoadBalancerStatusRequest {
	s.ResourceOwnerId = &v
	return s
}

type SetLoadBalancerStatusResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetLoadBalancerStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetLoadBalancerStatusResponseBody) GoString() string {
	return s.String()
}

func (s *SetLoadBalancerStatusResponseBody) SetRequestId(v string) *SetLoadBalancerStatusResponseBody {
	s.RequestId = &v
	return s
}

type SetLoadBalancerStatusResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetLoadBalancerStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetLoadBalancerStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s SetLoadBalancerStatusResponse) GoString() string {
	return s.String()
}

func (s *SetLoadBalancerStatusResponse) SetHeaders(v map[string]*string) *SetLoadBalancerStatusResponse {
	s.Headers = v
	return s
}

func (s *SetLoadBalancerStatusResponse) SetStatusCode(v int32) *SetLoadBalancerStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *SetLoadBalancerStatusResponse) SetBody(v *SetLoadBalancerStatusResponseBody) *SetLoadBalancerStatusResponse {
	s.Body = v
	return s
}

type SetLoadBalancerTCPListenerAttributeRequest struct {
	// The type of the health check. Valid values: **tcp** and **http**.
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The ID of the primary/secondary server group.
	//
	// >  You can set only one of the VServerGroupId and MasterSlaveServerGroupId parameters.
	AclStatus *string `json:"AclStatus,omitempty" xml:"AclStatus,omitempty"`
	// Specifies whether to enable the SynProxy feature of CLB for protection. Valid values:
	//
	// *   **enable**: yes
	// *   **disable**: no
	//
	// We recommend that you use the default value of this parameter.
	AclType *string `json:"AclType,omitempty" xml:"AclType,omitempty"`
	// The ID of the network access control list (ACL) that is associated with the listener.
	//
	// If **AclStatus** is set to **on**, this parameter is required.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The name of the listener.
	//
	// The name must be 1 to 256 characters in length and can contain letters, digits, hyphens (-), forward slashes (/), periods (.), and underscores (\_).
	ConnectionDrain *string `json:"ConnectionDrain,omitempty" xml:"ConnectionDrain,omitempty"`
	// The ID of the request.
	ConnectionDrainTimeout *int32 `json:"ConnectionDrainTimeout,omitempty" xml:"ConnectionDrainTimeout,omitempty"`
	// The maximum bandwidth of the listener. Unit: Mbit/s. Valid values: **-1** and **1** to **5120**.
	//
	// *   **-1**: For a pay-by-data-transfer Internet-facing CLB instance, you can set this parameter to **-1**, which specifies unlimited bandwidth.
	// *   **1** to **5120**: For a pay-by-bandwidth Internet-facing CLB instance, you can specify the maximum bandwidth of each listener. The sum of the maximum bandwidth values of all listeners cannot exceed the maximum bandwidth of the CLB instance.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The timeout period of connection draining. This parameter is required if **ConnectionDrain** is set to **on**. Unit: seconds.
	//
	// Valid values: **10** to **900**.
	EstablishedTimeout *int32 `json:"EstablishedTimeout,omitempty" xml:"EstablishedTimeout,omitempty"`
	// The interval between two consecutive health checks. Unit: seconds.
	//
	// Valid values: **1** to **50**.
	HealthCheckConnectPort *int32 `json:"HealthCheckConnectPort,omitempty" xml:"HealthCheckConnectPort,omitempty"`
	// The URI that is used for health checks. The URI must be 1 to 80 characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.), percent signs (%), question marks (?), number signs (#), and ampersands (&). The URI must start with a forward slash (/) but cannot be a single forward slash (/).
	//
	// You can set this parameter when the TCP listener requires HTTP health checks.
	//
	// If you do not set this parameter, TCP health checks are performed.
	HealthCheckConnectTimeout *int32 `json:"HealthCheckConnectTimeout,omitempty" xml:"HealthCheckConnectTimeout,omitempty"`
	// The ID of the CLB instance.
	HealthCheckDomain *string `json:"HealthCheckDomain,omitempty" xml:"HealthCheckDomain,omitempty"`
	// Specifies whether to enable access control. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	HealthCheckHttpCode *string `json:"HealthCheckHttpCode,omitempty" xml:"HealthCheckHttpCode,omitempty"`
	// The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. In this case, the health status is changed from **fail** to **success**.
	//
	// Valid values: **2** to **10**.
	HealthCheckInterval *int32  `json:"HealthCheckInterval,omitempty" xml:"HealthCheckInterval,omitempty"`
	HealthCheckSwitch   *string `json:"HealthCheckSwitch,omitempty" xml:"HealthCheckSwitch,omitempty"`
	// The frontend port used by the CLB instance.
	//
	// Valid values: **1** to **65535**.
	HealthCheckType *string `json:"HealthCheckType,omitempty" xml:"HealthCheckType,omitempty"`
	// The domain name that is used for health checks. You can set this parameter when the TCP listener requires HTTP health checks. If you do not set this parameter, TCP health checks are performed.
	//
	// *   **$\_ip**: the private IP addresses of the backend servers.
	//
	//     If you do not set the HealthCheckHost parameter or set the parameter to $SERVER_IP, the CLB instance uses the private IP addresses of backend servers for health checks.
	//
	// *   **domain**: The domain name is 1 to 80 characters in length, and can contain letters, digits, periods (.), and hyphens (-).
	HealthCheckURI *string `json:"HealthCheckURI,omitempty" xml:"HealthCheckURI,omitempty"`
	// Specifies whether to use the Proxy protocol to pass client IP addresses to backend servers. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	HealthyThreshold *int32 `json:"HealthyThreshold,omitempty" xml:"HealthyThreshold,omitempty"`
	// The ID of the vServer group.
	ListenerPort *int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	// The scheduling algorithm. Valid values:
	//
	// *   **wrr**: Backend servers that have higher weights receive more requests than backend servers that have lower weights.
	// *   **rr**: Requests are distributed to backend servers in sequence.
	// *   **sch**: specifies consistent hashing that is based on source IP addresses. Requests from the same source IP address are distributed to the same backend server.
	// *   **tch**: specifies consistent hashing that is based on four factors: source IP address, destination IP address, source port, and destination port. Requests that contain the same information based on the four factors are distributed to the same backend server.
	//
	// >
	//
	// *   Only high-performance CLB instances support the **sch** and **tch** algorithms.
	// *   CLB does not support converting the **wrr** and **rr** algorithms to sch or tch. You cannot switch the hash algorithm from one to another.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. In this case, the health status is changed from **success** to **fail**.
	//
	// Valid values: **2** to **10**.
	MasterSlaveServerGroup *string `json:"MasterSlaveServerGroup,omitempty" xml:"MasterSlaveServerGroup,omitempty"`
	// The port that is used for health checks. Valid values: **1** to **65535**.
	//
	// If you do not set this parameter, the port specified by the **BackendServerPort** parameter is used.
	MasterSlaveServerGroupId *string `json:"MasterSlaveServerGroupId,omitempty" xml:"MasterSlaveServerGroupId,omitempty"`
	OwnerAccount             *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                  *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The operation that you want to perform. Set the value to **SetLoadBalancerTCPListenerAttribute**.
	PersistenceTimeout     *int32 `json:"PersistenceTimeout,omitempty" xml:"PersistenceTimeout,omitempty"`
	ProxyProtocolV2Enabled *bool  `json:"ProxyProtocolV2Enabled,omitempty" xml:"ProxyProtocolV2Enabled,omitempty"`
	// Specifies whether to use a primary/secondary server group. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	//
	// You cannot set both **VserverGroup** and **MasterSlaveServerGroup** to **on**.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The timeout period of session persistence. Valid values: **0** to **3600**. Unit: seconds.
	//
	// Default value: **0**. If the default value is used, the system disables session persistence.
	Scheduler *string `json:"Scheduler,omitempty" xml:"Scheduler,omitempty"`
	// The timeout period of a connection. Unit: seconds. Valid values: **10** to **900**.
	SynProxy *string `json:"SynProxy,omitempty" xml:"SynProxy,omitempty"`
	// The type of the network ACL. Valid values:
	//
	// *   **white**: a whitelist. Only requests from the IP addresses or CIDR blocks in the network ACL are forwarded. Whitelists apply to scenarios where you want to allow only specific IP addresses to access an application. Your service may be adversely affected if the allowlist is not properly configured. After a whitelist is configured, only requests from IP addresses that are added to the whitelist are forwarded by the listener.
	//
	//     If you enable a whitelist but do not add an IP address to the ACL, the listener forwards all requests.
	//
	// *   **black**: a blacklist. All requests from the IP addresses or CIDR blocks in the ACL are rejected. Blacklists apply to scenarios where you want to block access from specified IP addresses to an application.
	//
	//     If a blacklist is configured for a listener but no IP address is added to the blacklist, the listener forwards all requests.
	//
	// >  If **AclStatus** is set to **on**, this parameter is required.
	UnhealthyThreshold *int32 `json:"UnhealthyThreshold,omitempty" xml:"UnhealthyThreshold,omitempty"`
	// Specifies whether to use a vServer group. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	//
	// >  You cannot set both **VserverGroup** and **MasterSlaveServerGroup** to **on**.
	VServerGroup *string `json:"VServerGroup,omitempty" xml:"VServerGroup,omitempty"`
	// Specifies whether to enable the health check feature. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
}

func (s SetLoadBalancerTCPListenerAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s SetLoadBalancerTCPListenerAttributeRequest) GoString() string {
	return s.String()
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetAclId(v string) *SetLoadBalancerTCPListenerAttributeRequest {
	s.AclId = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetAclStatus(v string) *SetLoadBalancerTCPListenerAttributeRequest {
	s.AclStatus = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetAclType(v string) *SetLoadBalancerTCPListenerAttributeRequest {
	s.AclType = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetBandwidth(v int32) *SetLoadBalancerTCPListenerAttributeRequest {
	s.Bandwidth = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetConnectionDrain(v string) *SetLoadBalancerTCPListenerAttributeRequest {
	s.ConnectionDrain = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetConnectionDrainTimeout(v int32) *SetLoadBalancerTCPListenerAttributeRequest {
	s.ConnectionDrainTimeout = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetDescription(v string) *SetLoadBalancerTCPListenerAttributeRequest {
	s.Description = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetEstablishedTimeout(v int32) *SetLoadBalancerTCPListenerAttributeRequest {
	s.EstablishedTimeout = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetHealthCheckConnectPort(v int32) *SetLoadBalancerTCPListenerAttributeRequest {
	s.HealthCheckConnectPort = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetHealthCheckConnectTimeout(v int32) *SetLoadBalancerTCPListenerAttributeRequest {
	s.HealthCheckConnectTimeout = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetHealthCheckDomain(v string) *SetLoadBalancerTCPListenerAttributeRequest {
	s.HealthCheckDomain = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetHealthCheckHttpCode(v string) *SetLoadBalancerTCPListenerAttributeRequest {
	s.HealthCheckHttpCode = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetHealthCheckInterval(v int32) *SetLoadBalancerTCPListenerAttributeRequest {
	s.HealthCheckInterval = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetHealthCheckSwitch(v string) *SetLoadBalancerTCPListenerAttributeRequest {
	s.HealthCheckSwitch = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetHealthCheckType(v string) *SetLoadBalancerTCPListenerAttributeRequest {
	s.HealthCheckType = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetHealthCheckURI(v string) *SetLoadBalancerTCPListenerAttributeRequest {
	s.HealthCheckURI = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetHealthyThreshold(v int32) *SetLoadBalancerTCPListenerAttributeRequest {
	s.HealthyThreshold = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetListenerPort(v int32) *SetLoadBalancerTCPListenerAttributeRequest {
	s.ListenerPort = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetLoadBalancerId(v string) *SetLoadBalancerTCPListenerAttributeRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetMasterSlaveServerGroup(v string) *SetLoadBalancerTCPListenerAttributeRequest {
	s.MasterSlaveServerGroup = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetMasterSlaveServerGroupId(v string) *SetLoadBalancerTCPListenerAttributeRequest {
	s.MasterSlaveServerGroupId = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetOwnerAccount(v string) *SetLoadBalancerTCPListenerAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetOwnerId(v int64) *SetLoadBalancerTCPListenerAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetPersistenceTimeout(v int32) *SetLoadBalancerTCPListenerAttributeRequest {
	s.PersistenceTimeout = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetProxyProtocolV2Enabled(v bool) *SetLoadBalancerTCPListenerAttributeRequest {
	s.ProxyProtocolV2Enabled = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetRegionId(v string) *SetLoadBalancerTCPListenerAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetResourceOwnerAccount(v string) *SetLoadBalancerTCPListenerAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetResourceOwnerId(v int64) *SetLoadBalancerTCPListenerAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetScheduler(v string) *SetLoadBalancerTCPListenerAttributeRequest {
	s.Scheduler = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetSynProxy(v string) *SetLoadBalancerTCPListenerAttributeRequest {
	s.SynProxy = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetUnhealthyThreshold(v int32) *SetLoadBalancerTCPListenerAttributeRequest {
	s.UnhealthyThreshold = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetVServerGroup(v string) *SetLoadBalancerTCPListenerAttributeRequest {
	s.VServerGroup = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeRequest) SetVServerGroupId(v string) *SetLoadBalancerTCPListenerAttributeRequest {
	s.VServerGroupId = &v
	return s
}

type SetLoadBalancerTCPListenerAttributeResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetLoadBalancerTCPListenerAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetLoadBalancerTCPListenerAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *SetLoadBalancerTCPListenerAttributeResponseBody) SetRequestId(v string) *SetLoadBalancerTCPListenerAttributeResponseBody {
	s.RequestId = &v
	return s
}

type SetLoadBalancerTCPListenerAttributeResponse struct {
	Headers    map[string]*string                               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetLoadBalancerTCPListenerAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetLoadBalancerTCPListenerAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s SetLoadBalancerTCPListenerAttributeResponse) GoString() string {
	return s.String()
}

func (s *SetLoadBalancerTCPListenerAttributeResponse) SetHeaders(v map[string]*string) *SetLoadBalancerTCPListenerAttributeResponse {
	s.Headers = v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeResponse) SetStatusCode(v int32) *SetLoadBalancerTCPListenerAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *SetLoadBalancerTCPListenerAttributeResponse) SetBody(v *SetLoadBalancerTCPListenerAttributeResponseBody) *SetLoadBalancerTCPListenerAttributeResponse {
	s.Body = v
	return s
}

type SetLoadBalancerUDPListenerAttributeRequest struct {
	// The name of the listener.
	//
	// The name must be 1 to 256 characters in length and can contain letters, digits, hyphens (-), forward slashes (/), periods (.), and underscores (\_).
	AclId *string `json:"AclId,omitempty" xml:"AclId,omitempty"`
	// The ID of the vServer group.
	AclStatus *string `json:"AclStatus,omitempty" xml:"AclStatus,omitempty"`
	// The maximum bandwidth of the listener. Unit: Mbit/s. Valid values:
	//
	// *   **-1**: For a pay-by-data-transfer Internet-facing CLB instance, you can set this parameter to **-1**. This way, the bandwidth of the listener is unlimited.
	// *   **1** to **5120**: For a pay-by-bandwidth Internet-facing CLB instance, you can specify the maximum bandwidth of each listener. The sum of bandwidth limits that you set for all listeners cannot exceed the maximum bandwidth of the CLB instance.
	AclType *string `json:"AclType,omitempty" xml:"AclType,omitempty"`
	// The frontend port used by the CLB instance.
	//
	// Valid values: **1** to **65535**.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The ID of the request.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Specifies whether to enable access control. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	HealthCheckConnectPort *int32 `json:"HealthCheckConnectPort,omitempty" xml:"HealthCheckConnectPort,omitempty"`
	// The scheduling algorithm. Valid values:
	//
	// *   **wrr**: Backend servers with higher weights receive more requests than those with lower weights.
	//
	//     If two backend servers have the same weight, the backend server that has fewer connections is expected to receive more requests.
	//
	// *   **rr**: Requests are distributed to backend servers in sequence.
	//
	// *   **sch**: specifies consistent hashing that is based on source IP addresses. Requests from the same source IP address are distributed to the same backend server.
	//
	// *   **tch**: specifies consistent hashing that is based on the following parameters: source IP address, destination IP address, source port, and destination port. Requests that contain the same preceding information are distributed to the same backend server.
	//
	// *   **qch**: specifies consistent hashing that is based on QUIC connection IDs. Requests that contain the same QUIC connection ID are distributed to the same backend server.
	//
	// >
	//
	// *   Only high-performance CLB instances support **sch**, **tch**, and **qch**.
	// *   You cannot switch the algorithm used by a CLB instance from **wrr** or **rr** to consistent hashing or from consistent hashing to weighted round robin or round robin.
	HealthCheckConnectTimeout *int32 `json:"HealthCheckConnectTimeout,omitempty" xml:"HealthCheckConnectTimeout,omitempty"`
	// The request string for UDP listener health checks. The string must be 1 to 64 characters in length and can contain only letters and digits.
	HealthCheckInterval *int32  `json:"HealthCheckInterval,omitempty" xml:"HealthCheckInterval,omitempty"`
	HealthCheckSwitch   *string `json:"HealthCheckSwitch,omitempty" xml:"HealthCheckSwitch,omitempty"`
	// The type of the network ACL. Valid values:
	//
	// *   **white**: a whitelist. Only requests from the IP addresses or CIDR blocks in the network ACL are forwarded. Whitelists apply to scenarios where you want to allow only specific IP addresses to access an application. Your service may be adversely affected if the whitelist is not properly configured. After a whitelist is configured, only requests from IP addresses that are added to the whitelist are forwarded by the listener.
	//
	//     If you enable a whitelist but do not add an IP address to the ACL, the listener forwards all requests.
	//
	// *   **black**: a blacklist. All requests from the IP addresses or CIDR blocks in the network ACL are denied. Blacklists apply to scenarios where you want to block access from specified IP addresses to an application.
	//
	//     If a blacklist is configured for a listener but no IP address is added to the blacklist, the listener forwards all requests.
	//
	// >  If **AclStatus** is set to **on**, this parameter is required.
	HealthyThreshold *int32 `json:"HealthyThreshold,omitempty" xml:"HealthyThreshold,omitempty"`
	// Specifies whether to use a vServer group. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	//
	// >  You cannot set both **VserverGroup** and **MasterSlaveServerGroup** to **on**.
	ListenerPort *int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	// The ID of the CLB instance.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	// The ID of the network access control list (ACL) that is associated with the listener.
	//
	// >  If **AclStatus** is set to **on**, this parameter is required.
	MasterSlaveServerGroup *string `json:"MasterSlaveServerGroup,omitempty" xml:"MasterSlaveServerGroup,omitempty"`
	// Specifies whether to use a primary/secondary server group. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	//
	// >  You cannot set **VserverGroup** and **MasterSlaveServerGroup** both to **on**.
	MasterSlaveServerGroupId *string `json:"MasterSlaveServerGroupId,omitempty" xml:"MasterSlaveServerGroupId,omitempty"`
	OwnerAccount             *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                  *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ProxyProtocolV2Enabled   *bool   `json:"ProxyProtocolV2Enabled,omitempty" xml:"ProxyProtocolV2Enabled,omitempty"`
	// The timeout period of a health check. If a backend server, such as an Elastic Compute Service (ECS) instance, does not return a health check response within the specified timeout period, the server fails the health check. Unit: seconds.
	//
	// Valid values: **1** to **300**.
	//
	// >  If the value of the **HealthCheckConnectTimeout** parameter is smaller than that of the **HealthCheckInterval** parameter, the timeout period specified by the **HealthCheckConnectTimeout** parameter is ignored and the period of time specified by the **HealthCheckInterval** parameter is used as the timeout period.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. In this case, the health status is changed from **success** to **fail**.
	//
	// Valid values: **1** to **10**.
	Scheduler *string `json:"Scheduler,omitempty" xml:"Scheduler,omitempty"`
	// The region ID of the CLB instance.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	UnhealthyThreshold *int32 `json:"UnhealthyThreshold,omitempty" xml:"UnhealthyThreshold,omitempty"`
	// The port that is used for health checks.
	//
	// Valid values: **1** to **65535**.
	VServerGroup *string `json:"VServerGroup,omitempty" xml:"VServerGroup,omitempty"`
	// The operation that you want to perform. Set the value to
	//
	// **SetLoadBalancerUDPListenerAttribute**.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
	// The number of times that an unhealthy backend server must consecutively pass health checks before it can be declared healthy (from **fail** to **success**).
	//
	// Valid values: **1** to **10**.
	HealthCheckExp *string `json:"healthCheckExp,omitempty" xml:"healthCheckExp,omitempty"`
	// Specifies whether to enable the health check feature. Valid values:
	//
	// *   **on** (default): yes
	// *   **off**: no
	HealthCheckReq *string `json:"healthCheckReq,omitempty" xml:"healthCheckReq,omitempty"`
}

func (s SetLoadBalancerUDPListenerAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s SetLoadBalancerUDPListenerAttributeRequest) GoString() string {
	return s.String()
}

func (s *SetLoadBalancerUDPListenerAttributeRequest) SetAclId(v string) *SetLoadBalancerUDPListenerAttributeRequest {
	s.AclId = &v
	return s
}

func (s *SetLoadBalancerUDPListenerAttributeRequest) SetAclStatus(v string) *SetLoadBalancerUDPListenerAttributeRequest {
	s.AclStatus = &v
	return s
}

func (s *SetLoadBalancerUDPListenerAttributeRequest) SetAclType(v string) *SetLoadBalancerUDPListenerAttributeRequest {
	s.AclType = &v
	return s
}

func (s *SetLoadBalancerUDPListenerAttributeRequest) SetBandwidth(v int32) *SetLoadBalancerUDPListenerAttributeRequest {
	s.Bandwidth = &v
	return s
}

func (s *SetLoadBalancerUDPListenerAttributeRequest) SetDescription(v string) *SetLoadBalancerUDPListenerAttributeRequest {
	s.Description = &v
	return s
}

func (s *SetLoadBalancerUDPListenerAttributeRequest) SetHealthCheckConnectPort(v int32) *SetLoadBalancerUDPListenerAttributeRequest {
	s.HealthCheckConnectPort = &v
	return s
}

func (s *SetLoadBalancerUDPListenerAttributeRequest) SetHealthCheckConnectTimeout(v int32) *SetLoadBalancerUDPListenerAttributeRequest {
	s.HealthCheckConnectTimeout = &v
	return s
}

func (s *SetLoadBalancerUDPListenerAttributeRequest) SetHealthCheckInterval(v int32) *SetLoadBalancerUDPListenerAttributeRequest {
	s.HealthCheckInterval = &v
	return s
}

func (s *SetLoadBalancerUDPListenerAttributeRequest) SetHealthCheckSwitch(v string) *SetLoadBalancerUDPListenerAttributeRequest {
	s.HealthCheckSwitch = &v
	return s
}

func (s *SetLoadBalancerUDPListenerAttributeRequest) SetHealthyThreshold(v int32) *SetLoadBalancerUDPListenerAttributeRequest {
	s.HealthyThreshold = &v
	return s
}

func (s *SetLoadBalancerUDPListenerAttributeRequest) SetListenerPort(v int32) *SetLoadBalancerUDPListenerAttributeRequest {
	s.ListenerPort = &v
	return s
}

func (s *SetLoadBalancerUDPListenerAttributeRequest) SetLoadBalancerId(v string) *SetLoadBalancerUDPListenerAttributeRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *SetLoadBalancerUDPListenerAttributeRequest) SetMasterSlaveServerGroup(v string) *SetLoadBalancerUDPListenerAttributeRequest {
	s.MasterSlaveServerGroup = &v
	return s
}

func (s *SetLoadBalancerUDPListenerAttributeRequest) SetMasterSlaveServerGroupId(v string) *SetLoadBalancerUDPListenerAttributeRequest {
	s.MasterSlaveServerGroupId = &v
	return s
}

func (s *SetLoadBalancerUDPListenerAttributeRequest) SetOwnerAccount(v string) *SetLoadBalancerUDPListenerAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SetLoadBalancerUDPListenerAttributeRequest) SetOwnerId(v int64) *SetLoadBalancerUDPListenerAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *SetLoadBalancerUDPListenerAttributeRequest) SetProxyProtocolV2Enabled(v bool) *SetLoadBalancerUDPListenerAttributeRequest {
	s.ProxyProtocolV2Enabled = &v
	return s
}

func (s *SetLoadBalancerUDPListenerAttributeRequest) SetRegionId(v string) *SetLoadBalancerUDPListenerAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *SetLoadBalancerUDPListenerAttributeRequest) SetResourceOwnerAccount(v string) *SetLoadBalancerUDPListenerAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SetLoadBalancerUDPListenerAttributeRequest) SetResourceOwnerId(v int64) *SetLoadBalancerUDPListenerAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *SetLoadBalancerUDPListenerAttributeRequest) SetScheduler(v string) *SetLoadBalancerUDPListenerAttributeRequest {
	s.Scheduler = &v
	return s
}

func (s *SetLoadBalancerUDPListenerAttributeRequest) SetUnhealthyThreshold(v int32) *SetLoadBalancerUDPListenerAttributeRequest {
	s.UnhealthyThreshold = &v
	return s
}

func (s *SetLoadBalancerUDPListenerAttributeRequest) SetVServerGroup(v string) *SetLoadBalancerUDPListenerAttributeRequest {
	s.VServerGroup = &v
	return s
}

func (s *SetLoadBalancerUDPListenerAttributeRequest) SetVServerGroupId(v string) *SetLoadBalancerUDPListenerAttributeRequest {
	s.VServerGroupId = &v
	return s
}

func (s *SetLoadBalancerUDPListenerAttributeRequest) SetHealthCheckExp(v string) *SetLoadBalancerUDPListenerAttributeRequest {
	s.HealthCheckExp = &v
	return s
}

func (s *SetLoadBalancerUDPListenerAttributeRequest) SetHealthCheckReq(v string) *SetLoadBalancerUDPListenerAttributeRequest {
	s.HealthCheckReq = &v
	return s
}

type SetLoadBalancerUDPListenerAttributeResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetLoadBalancerUDPListenerAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetLoadBalancerUDPListenerAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *SetLoadBalancerUDPListenerAttributeResponseBody) SetRequestId(v string) *SetLoadBalancerUDPListenerAttributeResponseBody {
	s.RequestId = &v
	return s
}

type SetLoadBalancerUDPListenerAttributeResponse struct {
	Headers    map[string]*string                               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetLoadBalancerUDPListenerAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetLoadBalancerUDPListenerAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s SetLoadBalancerUDPListenerAttributeResponse) GoString() string {
	return s.String()
}

func (s *SetLoadBalancerUDPListenerAttributeResponse) SetHeaders(v map[string]*string) *SetLoadBalancerUDPListenerAttributeResponse {
	s.Headers = v
	return s
}

func (s *SetLoadBalancerUDPListenerAttributeResponse) SetStatusCode(v int32) *SetLoadBalancerUDPListenerAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *SetLoadBalancerUDPListenerAttributeResponse) SetBody(v *SetLoadBalancerUDPListenerAttributeResponseBody) *SetLoadBalancerUDPListenerAttributeResponse {
	s.Body = v
	return s
}

type SetRuleRequest struct {
	// The interval between two consecutive health checks. Unit: seconds. Valid values: **1** to **50**.
	//
	// >  This parameter is required and takes effect if the **HealthCheck** parameter is set to **on**.
	Cookie *string `json:"Cookie,omitempty" xml:"Cookie,omitempty"`
	// The timeout period of a health check response. If a backend server, such as an Elastic Compute Service (ECS) instance, does not return a health check response within the specified timeout period, the server fails the health check. Unit: seconds. Valid values: **1** to **300**.
	//
	// >  This parameter is required and takes effect if the **HealthCheck** parameter is set to **on**.
	CookieTimeout *int32 `json:"CookieTimeout,omitempty" xml:"CookieTimeout,omitempty"`
	// rsp-cige6****
	HealthCheck            *string `json:"HealthCheck,omitempty" xml:"HealthCheck,omitempty"`
	HealthCheckConnectPort *int32  `json:"HealthCheckConnectPort,omitempty" xml:"HealthCheckConnectPort,omitempty"`
	// 80
	HealthCheckDomain   *string `json:"HealthCheckDomain,omitempty" xml:"HealthCheckDomain,omitempty"`
	HealthCheckHttpCode *string `json:"HealthCheckHttpCode,omitempty" xml:"HealthCheckHttpCode,omitempty"`
	// The ID of the request.
	HealthCheckInterval *int32 `json:"HealthCheckInterval,omitempty" xml:"HealthCheckInterval,omitempty"`
	// wrr
	HealthCheckTimeout *int32 `json:"HealthCheckTimeout,omitempty" xml:"HealthCheckTimeout,omitempty"`
	// The name of the forwarding rule. The name must be 1 to 80 characters in length and can contain letters, digits, hyphens (-), forward slashes (/), periods (.), and underscores (\_).
	//
	// >  Forwarding rule names must be unique within the same listener.
	HealthCheckURI *string `json:"HealthCheckURI,omitempty" xml:"HealthCheckURI,omitempty"`
	// The number of times that an unhealthy backend server must consecutively pass health checks before it is declared healthy. In this case, the health status is changed from **fail** to **success**.
	//
	// Valid values: **2** to **10**.
	//
	// >  This parameter is required and takes effect if the **HealthCheck** parameter is set to **on**.
	HealthyThreshold *int32 `json:"HealthyThreshold,omitempty" xml:"HealthyThreshold,omitempty"`
	// The scheduling algorithm. Valid values:
	//
	// *   **wrr**: Backend servers with higher weights receive more requests than those with lower weights.
	// *   **rr**: Requests are distributed to backend servers in sequence.
	//
	// >  This parameter is required and takes effect if the **ListenerSync** parameter is set to **off**.
	ListenerSync *string `json:"ListenerSync,omitempty" xml:"ListenerSync,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// Specifies whether to use the scheduling algorithm, session persistence, and health check configurations of the listener. Valid values:
	//
	// *   **on**: uses the configurations of the listener.
	// *   **off**: does not use the configurations of the listener. You can customize the health check and session persistence configurations for the forwarding rule.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The HTTP status code for a successful health check. Multiple HTTP status codes are separated by commas (,).
	//
	// Valid values: **http\_2xx**, **http\_3xx**, **http\_4xx**, and **http\_5xx**.
	//
	// >  This parameter is required and takes effect if the **HealthCheck** parameter is set to **on**.
	RuleId *string `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	// Specifies whether to enable the health check feature. Valid values:
	//
	// *   **on**: yes
	// *   **off**: no
	//
	// >  This parameter is required and takes effect if the **ListenerSync** parameter is set to **off**.
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	// insert
	Scheduler *string `json:"Scheduler,omitempty" xml:"Scheduler,omitempty"`
	// The timeout period of a cookie. Unit: seconds. Valid values: **1** to **86400**.
	//
	// >  This parameter is required and takes effect if **StickySession** is set to **on** and **StickySessionType** is set to **insert**.
	StickySession *string `json:"StickySession,omitempty" xml:"StickySession,omitempty"`
	// rule-3ejhkt****
	StickySessionType *string `json:"StickySessionType,omitempty" xml:"StickySessionType,omitempty"`
	// $_ip
	UnhealthyThreshold *int32 `json:"UnhealthyThreshold,omitempty" xml:"UnhealthyThreshold,omitempty"`
	// off
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
}

func (s SetRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s SetRuleRequest) GoString() string {
	return s.String()
}

func (s *SetRuleRequest) SetCookie(v string) *SetRuleRequest {
	s.Cookie = &v
	return s
}

func (s *SetRuleRequest) SetCookieTimeout(v int32) *SetRuleRequest {
	s.CookieTimeout = &v
	return s
}

func (s *SetRuleRequest) SetHealthCheck(v string) *SetRuleRequest {
	s.HealthCheck = &v
	return s
}

func (s *SetRuleRequest) SetHealthCheckConnectPort(v int32) *SetRuleRequest {
	s.HealthCheckConnectPort = &v
	return s
}

func (s *SetRuleRequest) SetHealthCheckDomain(v string) *SetRuleRequest {
	s.HealthCheckDomain = &v
	return s
}

func (s *SetRuleRequest) SetHealthCheckHttpCode(v string) *SetRuleRequest {
	s.HealthCheckHttpCode = &v
	return s
}

func (s *SetRuleRequest) SetHealthCheckInterval(v int32) *SetRuleRequest {
	s.HealthCheckInterval = &v
	return s
}

func (s *SetRuleRequest) SetHealthCheckTimeout(v int32) *SetRuleRequest {
	s.HealthCheckTimeout = &v
	return s
}

func (s *SetRuleRequest) SetHealthCheckURI(v string) *SetRuleRequest {
	s.HealthCheckURI = &v
	return s
}

func (s *SetRuleRequest) SetHealthyThreshold(v int32) *SetRuleRequest {
	s.HealthyThreshold = &v
	return s
}

func (s *SetRuleRequest) SetListenerSync(v string) *SetRuleRequest {
	s.ListenerSync = &v
	return s
}

func (s *SetRuleRequest) SetOwnerAccount(v string) *SetRuleRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SetRuleRequest) SetOwnerId(v int64) *SetRuleRequest {
	s.OwnerId = &v
	return s
}

func (s *SetRuleRequest) SetRegionId(v string) *SetRuleRequest {
	s.RegionId = &v
	return s
}

func (s *SetRuleRequest) SetResourceOwnerAccount(v string) *SetRuleRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SetRuleRequest) SetResourceOwnerId(v int64) *SetRuleRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *SetRuleRequest) SetRuleId(v string) *SetRuleRequest {
	s.RuleId = &v
	return s
}

func (s *SetRuleRequest) SetRuleName(v string) *SetRuleRequest {
	s.RuleName = &v
	return s
}

func (s *SetRuleRequest) SetScheduler(v string) *SetRuleRequest {
	s.Scheduler = &v
	return s
}

func (s *SetRuleRequest) SetStickySession(v string) *SetRuleRequest {
	s.StickySession = &v
	return s
}

func (s *SetRuleRequest) SetStickySessionType(v string) *SetRuleRequest {
	s.StickySessionType = &v
	return s
}

func (s *SetRuleRequest) SetUnhealthyThreshold(v int32) *SetRuleRequest {
	s.UnhealthyThreshold = &v
	return s
}

func (s *SetRuleRequest) SetVServerGroupId(v string) *SetRuleRequest {
	s.VServerGroupId = &v
	return s
}

type SetRuleResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetRuleResponseBody) GoString() string {
	return s.String()
}

func (s *SetRuleResponseBody) SetRequestId(v string) *SetRuleResponseBody {
	s.RequestId = &v
	return s
}

type SetRuleResponse struct {
	Headers    map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s SetRuleResponse) GoString() string {
	return s.String()
}

func (s *SetRuleResponse) SetHeaders(v map[string]*string) *SetRuleResponse {
	s.Headers = v
	return s
}

func (s *SetRuleResponse) SetStatusCode(v int32) *SetRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *SetRuleResponse) SetBody(v *SetRuleResponseBody) *SetRuleResponse {
	s.Body = v
	return s
}

type SetServerCertificateNameRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the server certificate.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The name of the server certificate.
	//
	// The name must be 1 to 80 characters in length. It must start with an English letter. It can contain letters, numbers, periods (.), underscores (\_), and hyphens (-).
	ServerCertificateId *string `json:"ServerCertificateId,omitempty" xml:"ServerCertificateId,omitempty"`
	// The ID of the request.
	ServerCertificateName *string `json:"ServerCertificateName,omitempty" xml:"ServerCertificateName,omitempty"`
}

func (s SetServerCertificateNameRequest) String() string {
	return tea.Prettify(s)
}

func (s SetServerCertificateNameRequest) GoString() string {
	return s.String()
}

func (s *SetServerCertificateNameRequest) SetOwnerAccount(v string) *SetServerCertificateNameRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SetServerCertificateNameRequest) SetOwnerId(v int64) *SetServerCertificateNameRequest {
	s.OwnerId = &v
	return s
}

func (s *SetServerCertificateNameRequest) SetRegionId(v string) *SetServerCertificateNameRequest {
	s.RegionId = &v
	return s
}

func (s *SetServerCertificateNameRequest) SetResourceOwnerAccount(v string) *SetServerCertificateNameRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SetServerCertificateNameRequest) SetResourceOwnerId(v int64) *SetServerCertificateNameRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *SetServerCertificateNameRequest) SetServerCertificateId(v string) *SetServerCertificateNameRequest {
	s.ServerCertificateId = &v
	return s
}

func (s *SetServerCertificateNameRequest) SetServerCertificateName(v string) *SetServerCertificateNameRequest {
	s.ServerCertificateName = &v
	return s
}

type SetServerCertificateNameResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetServerCertificateNameResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetServerCertificateNameResponseBody) GoString() string {
	return s.String()
}

func (s *SetServerCertificateNameResponseBody) SetRequestId(v string) *SetServerCertificateNameResponseBody {
	s.RequestId = &v
	return s
}

type SetServerCertificateNameResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetServerCertificateNameResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetServerCertificateNameResponse) String() string {
	return tea.Prettify(s)
}

func (s SetServerCertificateNameResponse) GoString() string {
	return s.String()
}

func (s *SetServerCertificateNameResponse) SetHeaders(v map[string]*string) *SetServerCertificateNameResponse {
	s.Headers = v
	return s
}

func (s *SetServerCertificateNameResponse) SetStatusCode(v int32) *SetServerCertificateNameResponse {
	s.StatusCode = &v
	return s
}

func (s *SetServerCertificateNameResponse) SetBody(v *SetServerCertificateNameResponseBody) *SetServerCertificateNameResponse {
	s.Body = v
	return s
}

type SetTLSCipherPolicyAttributeRequest struct {
	// The cipher suites supported by the TLS version.
	//
	// The specified cipher suites must be supported by at least one TLS protocol version that you specify. For example, if you set the TLSVersions parameter to TLSv1.3, you must specify cipher suites that are supported by this protocol version.
	//
	// TLS 1.0 and TLS 1.1 support the following cipher suites:
	//
	// *   ECDHE-ECDSA-AES128-SHA
	// *   ECDHE-ECDSA-AES256-SHA
	// *   ECDHE-RSA-AES128-SHA
	// *   ECDHE-RSA-AES256-SHA
	// *   AES128-SHA AES256-SHA
	// *   DES-CBC3-SHA
	//
	// TLS 1.2 supports the following cipher suites:
	//
	// *   ECDHE-ECDSA-AES128-SHA
	// *   ECDHE-ECDSA-AES256-SHA
	// *   ECDHE-RSA-AES128-SHA
	// *   ECDHE-RSA-AES256-SHA
	// *   AES128-SHA AES256-SHA
	// *   DES-CBC3-SHA
	// *   ECDHE-ECDSA-AES128-GCM-SHA256
	// *   ECDHE-ECDSA-AES256-GCM-SHA384
	// *   ECDHE-ECDSA-AES128-SHA256
	// *   ECDHE-ECDSA-AES256-SHA384
	// *   ECDHE-RSA-AES128-GCM-SHA256
	// *   ECDHE-RSA-AES256-GCM-SHA384
	// *   ECDHE-RSA-AES128-SHA256
	// *   ECDHE-RSA-AES256-SHA384
	// *   AES128-GCM-SHA256
	// *   AES256-GCM-SHA384
	// *   AES128-SHA256 AES256-SHA256
	//
	// TLS 1.3 supports the following cipher suites:
	//
	// *   TLS_AES\_128\_GCM_SHA256
	// *   TLS_AES\_256\_GCM_SHA384
	// *   TLS_CHACHA20\_POLY1305\_SHA256
	// *   TLS_AES\_128\_CCM_SHA256
	// *   TLS_AES\_128\_CCM\_8\_SHA256
	Ciphers []*string `json:"Ciphers,omitempty" xml:"Ciphers,omitempty" type:"Repeated"`
	// The name of the TLS policy. The name must be 2 to 128 characters in length and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). The name must start with a letter.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the Server Load Balancer (SLB) instance is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the TLS policy.
	TLSCipherPolicyId *string `json:"TLSCipherPolicyId,omitempty" xml:"TLSCipherPolicyId,omitempty"`
	// The version of the TLS protocol. Valid values: **TLSv1.0**, **TLSv1.1**, **TLSv1.2**, and **TLSv1.3**.
	TLSVersions []*string `json:"TLSVersions,omitempty" xml:"TLSVersions,omitempty" type:"Repeated"`
}

func (s SetTLSCipherPolicyAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s SetTLSCipherPolicyAttributeRequest) GoString() string {
	return s.String()
}

func (s *SetTLSCipherPolicyAttributeRequest) SetCiphers(v []*string) *SetTLSCipherPolicyAttributeRequest {
	s.Ciphers = v
	return s
}

func (s *SetTLSCipherPolicyAttributeRequest) SetName(v string) *SetTLSCipherPolicyAttributeRequest {
	s.Name = &v
	return s
}

func (s *SetTLSCipherPolicyAttributeRequest) SetOwnerAccount(v string) *SetTLSCipherPolicyAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SetTLSCipherPolicyAttributeRequest) SetOwnerId(v int64) *SetTLSCipherPolicyAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *SetTLSCipherPolicyAttributeRequest) SetRegionId(v string) *SetTLSCipherPolicyAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *SetTLSCipherPolicyAttributeRequest) SetResourceOwnerAccount(v string) *SetTLSCipherPolicyAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SetTLSCipherPolicyAttributeRequest) SetResourceOwnerId(v int64) *SetTLSCipherPolicyAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *SetTLSCipherPolicyAttributeRequest) SetTLSCipherPolicyId(v string) *SetTLSCipherPolicyAttributeRequest {
	s.TLSCipherPolicyId = &v
	return s
}

func (s *SetTLSCipherPolicyAttributeRequest) SetTLSVersions(v []*string) *SetTLSCipherPolicyAttributeRequest {
	s.TLSVersions = v
	return s
}

type SetTLSCipherPolicyAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the asynchronous task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s SetTLSCipherPolicyAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetTLSCipherPolicyAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *SetTLSCipherPolicyAttributeResponseBody) SetRequestId(v string) *SetTLSCipherPolicyAttributeResponseBody {
	s.RequestId = &v
	return s
}

func (s *SetTLSCipherPolicyAttributeResponseBody) SetTaskId(v string) *SetTLSCipherPolicyAttributeResponseBody {
	s.TaskId = &v
	return s
}

type SetTLSCipherPolicyAttributeResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetTLSCipherPolicyAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetTLSCipherPolicyAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s SetTLSCipherPolicyAttributeResponse) GoString() string {
	return s.String()
}

func (s *SetTLSCipherPolicyAttributeResponse) SetHeaders(v map[string]*string) *SetTLSCipherPolicyAttributeResponse {
	s.Headers = v
	return s
}

func (s *SetTLSCipherPolicyAttributeResponse) SetStatusCode(v int32) *SetTLSCipherPolicyAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *SetTLSCipherPolicyAttributeResponse) SetBody(v *SetTLSCipherPolicyAttributeResponseBody) *SetTLSCipherPolicyAttributeResponse {
	s.Body = v
	return s
}

type SetVServerGroupAttributeRequest struct {
	// The name of the vServer group.
	BackendServers *string `json:"BackendServers,omitempty" xml:"BackendServers,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The name of the vServer group. You can specify a custom name for the vServer group.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The list of backend servers in the vServer group. You can specify at most 20 backend servers for a vServer group in each call.
	//
	// *   **ServerId**: required. The ID of the Elastic Compute Service (ECS) instance or elastic network interface (ENI) that serves as a backend server. This parameter must be of the STRING type.
	//
	// *   **Port**: required. The port that is used by the backend server. This parameter must be of the INTEGER type. Valid values: **1 to 65535**.
	//
	// *   **Weight**: required. The weight of the backend server. This parameter must be of the INTEGER type. You can modify this parameter. Valid values: **0 to 100**.
	//
	// *   **Description**: optional. The description of the backend server. This parameter must be of the STRING type. You can modify this parameter. The description must be 1 to 80 characters in length, and can contain letters, digits, hyphens (-), forward slashes (/), periods (.),and underscores (\_).
	//
	// *   **Type**: the type of backend server. This parameter must be of the STRING type. Valid values:
	//
	//     *   **ecs**: an ECS instance. This is the default value.
	//     *   **eni**: an ENI.
	//
	// *   **ServerIp**: the IP address of the ECS instance or ENI.
	//
	// Examples:
	//
	// *   An ECS instance: `[{ "ServerId": "i-xxxxxxxxx", "Weight": "100", "Type": "ecs", "Port":"80","Description":"test-112" }]`
	// *   An ENI: `[{ "ServerId": "eni-xxxxxxxxx", "Weight": "100", "Type": "eni", "ServerIp": "192.168.**.**", "Port":"80","Description":"test-112" }]`
	// *   An ENI with multiple IP addresses: `[{ "ServerId": "eni-xxxxxxxxx", "Weight": "100", "Type": "eni", "ServerIp": "192.168.**.**", "Port":"80","Description":"test-112" },{ "ServerId": "eni-xxxxxxxxx", "Weight": "100", "Type": "eni", "ServerIp": "172.166.**.**", "Port":"80","Description":"test-113" }]`
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
	// The ID of the vServer group.
	VServerGroupName *string `json:"VServerGroupName,omitempty" xml:"VServerGroupName,omitempty"`
}

func (s SetVServerGroupAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s SetVServerGroupAttributeRequest) GoString() string {
	return s.String()
}

func (s *SetVServerGroupAttributeRequest) SetBackendServers(v string) *SetVServerGroupAttributeRequest {
	s.BackendServers = &v
	return s
}

func (s *SetVServerGroupAttributeRequest) SetOwnerAccount(v string) *SetVServerGroupAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SetVServerGroupAttributeRequest) SetOwnerId(v int64) *SetVServerGroupAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *SetVServerGroupAttributeRequest) SetRegionId(v string) *SetVServerGroupAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *SetVServerGroupAttributeRequest) SetResourceOwnerAccount(v string) *SetVServerGroupAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SetVServerGroupAttributeRequest) SetResourceOwnerId(v int64) *SetVServerGroupAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *SetVServerGroupAttributeRequest) SetVServerGroupId(v string) *SetVServerGroupAttributeRequest {
	s.VServerGroupId = &v
	return s
}

func (s *SetVServerGroupAttributeRequest) SetVServerGroupName(v string) *SetVServerGroupAttributeRequest {
	s.VServerGroupName = &v
	return s
}

type SetVServerGroupAttributeResponseBody struct {
	// The weight of the backend server.
	BackendServers *SetVServerGroupAttributeResponseBodyBackendServers `json:"BackendServers,omitempty" xml:"BackendServers,omitempty" type:"Struct"`
	// The type of backend server. Valid values:
	//
	// *   **ecs**: an ECS instance
	// *   **eni**: an ENI
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the request.
	VServerGroupId *string `json:"VServerGroupId,omitempty" xml:"VServerGroupId,omitempty"`
	// The list of backend servers.
	VServerGroupName *string `json:"VServerGroupName,omitempty" xml:"VServerGroupName,omitempty"`
}

func (s SetVServerGroupAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetVServerGroupAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *SetVServerGroupAttributeResponseBody) SetBackendServers(v *SetVServerGroupAttributeResponseBodyBackendServers) *SetVServerGroupAttributeResponseBody {
	s.BackendServers = v
	return s
}

func (s *SetVServerGroupAttributeResponseBody) SetRequestId(v string) *SetVServerGroupAttributeResponseBody {
	s.RequestId = &v
	return s
}

func (s *SetVServerGroupAttributeResponseBody) SetVServerGroupId(v string) *SetVServerGroupAttributeResponseBody {
	s.VServerGroupId = &v
	return s
}

func (s *SetVServerGroupAttributeResponseBody) SetVServerGroupName(v string) *SetVServerGroupAttributeResponseBody {
	s.VServerGroupName = &v
	return s
}

type SetVServerGroupAttributeResponseBodyBackendServers struct {
	BackendServer []*SetVServerGroupAttributeResponseBodyBackendServersBackendServer `json:"BackendServer,omitempty" xml:"BackendServer,omitempty" type:"Repeated"`
}

func (s SetVServerGroupAttributeResponseBodyBackendServers) String() string {
	return tea.Prettify(s)
}

func (s SetVServerGroupAttributeResponseBodyBackendServers) GoString() string {
	return s.String()
}

func (s *SetVServerGroupAttributeResponseBodyBackendServers) SetBackendServer(v []*SetVServerGroupAttributeResponseBodyBackendServersBackendServer) *SetVServerGroupAttributeResponseBodyBackendServers {
	s.BackendServer = v
	return s
}

type SetVServerGroupAttributeResponseBodyBackendServersBackendServer struct {
	// The port that is used by the backend server.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// This operation allows you to modify only the name of a vServer group and the weights of the backend servers in the vServer group.
	//
	// *   If you want to modify backend servers in a specified vServer group, call the [ModifyVServerGroupBackendServers](~~35220~~) operation.
	// *   If you want to add backend servers to a specified vServer group, call the [AddVServerGroupBackendServers](~~35218~~) operation.
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// Modifies the configurations of a vServer group.
	ServerId *string `json:"ServerId,omitempty" xml:"ServerId,omitempty"`
	// The description of the vServer group.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// Backend server group description
	Weight *int32 `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s SetVServerGroupAttributeResponseBodyBackendServersBackendServer) String() string {
	return tea.Prettify(s)
}

func (s SetVServerGroupAttributeResponseBodyBackendServersBackendServer) GoString() string {
	return s.String()
}

func (s *SetVServerGroupAttributeResponseBodyBackendServersBackendServer) SetDescription(v string) *SetVServerGroupAttributeResponseBodyBackendServersBackendServer {
	s.Description = &v
	return s
}

func (s *SetVServerGroupAttributeResponseBodyBackendServersBackendServer) SetPort(v int32) *SetVServerGroupAttributeResponseBodyBackendServersBackendServer {
	s.Port = &v
	return s
}

func (s *SetVServerGroupAttributeResponseBodyBackendServersBackendServer) SetServerId(v string) *SetVServerGroupAttributeResponseBodyBackendServersBackendServer {
	s.ServerId = &v
	return s
}

func (s *SetVServerGroupAttributeResponseBodyBackendServersBackendServer) SetType(v string) *SetVServerGroupAttributeResponseBodyBackendServersBackendServer {
	s.Type = &v
	return s
}

func (s *SetVServerGroupAttributeResponseBodyBackendServersBackendServer) SetWeight(v int32) *SetVServerGroupAttributeResponseBodyBackendServersBackendServer {
	s.Weight = &v
	return s
}

type SetVServerGroupAttributeResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetVServerGroupAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetVServerGroupAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s SetVServerGroupAttributeResponse) GoString() string {
	return s.String()
}

func (s *SetVServerGroupAttributeResponse) SetHeaders(v map[string]*string) *SetVServerGroupAttributeResponse {
	s.Headers = v
	return s
}

func (s *SetVServerGroupAttributeResponse) SetStatusCode(v int32) *SetVServerGroupAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *SetVServerGroupAttributeResponse) SetBody(v *SetVServerGroupAttributeResponseBody) *SetVServerGroupAttributeResponse {
	s.Body = v
	return s
}

type StartLoadBalancerListenerRequest struct {
	// The ID of the request.
	ListenerPort *int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	// When you call this operation, note the following items:
	//
	// *   You can call the operation only when the listener is in the Stopped state.
	// *   After the operation is called, the status of the listener changes to Starting.
	// *   You cannot call this operation when the SLB instance to which the listener is bound is in the Locked state.
	ListenerProtocol *string `json:"ListenerProtocol,omitempty" xml:"ListenerProtocol,omitempty"`
	// The protocol used by the listener of the SLB instance.
	//
	// >  If different listeners use the same port, you must specify this parameter.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the SLB instance.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s StartLoadBalancerListenerRequest) String() string {
	return tea.Prettify(s)
}

func (s StartLoadBalancerListenerRequest) GoString() string {
	return s.String()
}

func (s *StartLoadBalancerListenerRequest) SetListenerPort(v int32) *StartLoadBalancerListenerRequest {
	s.ListenerPort = &v
	return s
}

func (s *StartLoadBalancerListenerRequest) SetListenerProtocol(v string) *StartLoadBalancerListenerRequest {
	s.ListenerProtocol = &v
	return s
}

func (s *StartLoadBalancerListenerRequest) SetLoadBalancerId(v string) *StartLoadBalancerListenerRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *StartLoadBalancerListenerRequest) SetOwnerAccount(v string) *StartLoadBalancerListenerRequest {
	s.OwnerAccount = &v
	return s
}

func (s *StartLoadBalancerListenerRequest) SetOwnerId(v int64) *StartLoadBalancerListenerRequest {
	s.OwnerId = &v
	return s
}

func (s *StartLoadBalancerListenerRequest) SetRegionId(v string) *StartLoadBalancerListenerRequest {
	s.RegionId = &v
	return s
}

func (s *StartLoadBalancerListenerRequest) SetResourceOwnerAccount(v string) *StartLoadBalancerListenerRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *StartLoadBalancerListenerRequest) SetResourceOwnerId(v int64) *StartLoadBalancerListenerRequest {
	s.ResourceOwnerId = &v
	return s
}

type StartLoadBalancerListenerResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s StartLoadBalancerListenerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StartLoadBalancerListenerResponseBody) GoString() string {
	return s.String()
}

func (s *StartLoadBalancerListenerResponseBody) SetRequestId(v string) *StartLoadBalancerListenerResponseBody {
	s.RequestId = &v
	return s
}

type StartLoadBalancerListenerResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *StartLoadBalancerListenerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s StartLoadBalancerListenerResponse) String() string {
	return tea.Prettify(s)
}

func (s StartLoadBalancerListenerResponse) GoString() string {
	return s.String()
}

func (s *StartLoadBalancerListenerResponse) SetHeaders(v map[string]*string) *StartLoadBalancerListenerResponse {
	s.Headers = v
	return s
}

func (s *StartLoadBalancerListenerResponse) SetStatusCode(v int32) *StartLoadBalancerListenerResponse {
	s.StatusCode = &v
	return s
}

func (s *StartLoadBalancerListenerResponse) SetBody(v *StartLoadBalancerListenerResponseBody) *StartLoadBalancerListenerResponse {
	s.Body = v
	return s
}

type StopLoadBalancerListenerRequest struct {
	// The ID of the request.
	ListenerPort *int32 `json:"ListenerPort,omitempty" xml:"ListenerPort,omitempty"`
	// Before you make this API call, note the following:
	//
	// *   After the API call is successfully made, the listener enters the stopped state.
	// *   If the Server Load Balancer (SLB) instance to which the listener to be stopped belongs is in the locked state, this API call cannot be made.
	//
	// >  If you stop the listener, your services will be disrupted. Exercise caution when you perform this action.
	ListenerProtocol *string `json:"ListenerProtocol,omitempty" xml:"ListenerProtocol,omitempty"`
	// The frontend listening protocol used by the SLB instance.
	//
	// >  This parameter is required when listeners with different protocols use the same port.
	LoadBalancerId *string `json:"LoadBalancerId,omitempty" xml:"LoadBalancerId,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the SLB instance to which the listener belongs.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s StopLoadBalancerListenerRequest) String() string {
	return tea.Prettify(s)
}

func (s StopLoadBalancerListenerRequest) GoString() string {
	return s.String()
}

func (s *StopLoadBalancerListenerRequest) SetListenerPort(v int32) *StopLoadBalancerListenerRequest {
	s.ListenerPort = &v
	return s
}

func (s *StopLoadBalancerListenerRequest) SetListenerProtocol(v string) *StopLoadBalancerListenerRequest {
	s.ListenerProtocol = &v
	return s
}

func (s *StopLoadBalancerListenerRequest) SetLoadBalancerId(v string) *StopLoadBalancerListenerRequest {
	s.LoadBalancerId = &v
	return s
}

func (s *StopLoadBalancerListenerRequest) SetOwnerAccount(v string) *StopLoadBalancerListenerRequest {
	s.OwnerAccount = &v
	return s
}

func (s *StopLoadBalancerListenerRequest) SetOwnerId(v int64) *StopLoadBalancerListenerRequest {
	s.OwnerId = &v
	return s
}

func (s *StopLoadBalancerListenerRequest) SetRegionId(v string) *StopLoadBalancerListenerRequest {
	s.RegionId = &v
	return s
}

func (s *StopLoadBalancerListenerRequest) SetResourceOwnerAccount(v string) *StopLoadBalancerListenerRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *StopLoadBalancerListenerRequest) SetResourceOwnerId(v int64) *StopLoadBalancerListenerRequest {
	s.ResourceOwnerId = &v
	return s
}

type StopLoadBalancerListenerResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s StopLoadBalancerListenerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StopLoadBalancerListenerResponseBody) GoString() string {
	return s.String()
}

func (s *StopLoadBalancerListenerResponseBody) SetRequestId(v string) *StopLoadBalancerListenerResponseBody {
	s.RequestId = &v
	return s
}

type StopLoadBalancerListenerResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *StopLoadBalancerListenerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s StopLoadBalancerListenerResponse) String() string {
	return tea.Prettify(s)
}

func (s StopLoadBalancerListenerResponse) GoString() string {
	return s.String()
}

func (s *StopLoadBalancerListenerResponse) SetHeaders(v map[string]*string) *StopLoadBalancerListenerResponse {
	s.Headers = v
	return s
}

func (s *StopLoadBalancerListenerResponse) SetStatusCode(v int32) *StopLoadBalancerListenerResponse {
	s.StatusCode = &v
	return s
}

func (s *StopLoadBalancerListenerResponse) SetBody(v *StopLoadBalancerListenerResponseBody) *StopLoadBalancerListenerResponse {
	s.Body = v
	return s
}

type TagResourcesRequest struct {
	OwnerAccount         *string                   `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64                    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	RegionId             *string                   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceId           []*string                 `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	ResourceOwnerAccount *string                   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	ResourceType         *string                   `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	Tag                  []*TagResourcesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s TagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequest) GoString() string {
	return s.String()
}

func (s *TagResourcesRequest) SetOwnerAccount(v string) *TagResourcesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *TagResourcesRequest) SetOwnerId(v int64) *TagResourcesRequest {
	s.OwnerId = &v
	return s
}

func (s *TagResourcesRequest) SetRegionId(v string) *TagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *TagResourcesRequest) SetResourceId(v []*string) *TagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *TagResourcesRequest) SetResourceOwnerAccount(v string) *TagResourcesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *TagResourcesRequest) SetResourceOwnerId(v int64) *TagResourcesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *TagResourcesRequest) SetResourceType(v string) *TagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *TagResourcesRequest) SetTag(v []*TagResourcesRequestTag) *TagResourcesRequest {
	s.Tag = v
	return s
}

type TagResourcesRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s TagResourcesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequestTag) GoString() string {
	return s.String()
}

func (s *TagResourcesRequestTag) SetKey(v string) *TagResourcesRequestTag {
	s.Key = &v
	return s
}

func (s *TagResourcesRequestTag) SetValue(v string) *TagResourcesRequestTag {
	s.Value = &v
	return s
}

type TagResourcesResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s TagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *TagResourcesResponseBody) SetRequestId(v string) *TagResourcesResponseBody {
	s.RequestId = &v
	return s
}

type TagResourcesResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *TagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s TagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponse) GoString() string {
	return s.String()
}

func (s *TagResourcesResponse) SetHeaders(v map[string]*string) *TagResourcesResponse {
	s.Headers = v
	return s
}

func (s *TagResourcesResponse) SetStatusCode(v int32) *TagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *TagResourcesResponse) SetBody(v *TagResourcesResponseBody) *TagResourcesResponse {
	s.Body = v
	return s
}

type UntagResourcesRequest struct {
	// Specifies whether to remove all tags from the specified one or more resources. This parameter takes effect only if the **TagKey.N** parameter is not set.
	//
	// Valid values: **true** and **false**.
	All          *bool   `json:"All,omitempty" xml:"All,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the Server Load Balancer (SLB) instance is created.
	//
	// You can call the [DescribeRegions](~~27584~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource. Valid values of N: 1 to 20.
	ResourceId           []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the resource. Valid values:
	//
	// *   **instance**: an SLB instance
	// *   **certificate**: a certificate
	// *   **acl**: a network access control list (ACL)
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tag value. Valid values of N: **1** to **20**.
	//
	// The tag value can be up to 128 characters in length and cannot contain `http://` or `https://`. The tag value cannot start with `acs:` or `aliyun`.
	//
	// >  If you do not set **TagKey**, all tags of the specified instance are removed.
	TagKey []*string `json:"TagKey,omitempty" xml:"TagKey,omitempty" type:"Repeated"`
}

func (s UntagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesRequest) GoString() string {
	return s.String()
}

func (s *UntagResourcesRequest) SetAll(v bool) *UntagResourcesRequest {
	s.All = &v
	return s
}

func (s *UntagResourcesRequest) SetOwnerAccount(v string) *UntagResourcesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UntagResourcesRequest) SetOwnerId(v int64) *UntagResourcesRequest {
	s.OwnerId = &v
	return s
}

func (s *UntagResourcesRequest) SetRegionId(v string) *UntagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *UntagResourcesRequest) SetResourceId(v []*string) *UntagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *UntagResourcesRequest) SetResourceOwnerAccount(v string) *UntagResourcesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UntagResourcesRequest) SetResourceOwnerId(v int64) *UntagResourcesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UntagResourcesRequest) SetResourceType(v string) *UntagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *UntagResourcesRequest) SetTagKey(v []*string) *UntagResourcesRequest {
	s.TagKey = v
	return s
}

type UntagResourcesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UntagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponseBody) SetRequestId(v string) *UntagResourcesResponseBody {
	s.RequestId = &v
	return s
}

type UntagResourcesResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UntagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UntagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponse) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponse) SetHeaders(v map[string]*string) *UntagResourcesResponse {
	s.Headers = v
	return s
}

func (s *UntagResourcesResponse) SetStatusCode(v int32) *UntagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *UntagResourcesResponse) SetBody(v *UntagResourcesResponseBody) *UntagResourcesResponse {
	s.Body = v
	return s
}

type UploadCACertificateRequest struct {
	// The ID of the enterprise resource group.
	CACertificate *string `json:"CACertificate,omitempty" xml:"CACertificate,omitempty"`
	// The timestamp generated when the CA certificate is uploaded.
	CACertificateName *string `json:"CACertificateName,omitempty" xml:"CACertificateName,omitempty"`
	OwnerAccount      *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId           *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The name of the CA certificate.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the request.
	ResourceGroupId      *string                          `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string                          `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                           `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Tag                  []*UploadCACertificateRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s UploadCACertificateRequest) String() string {
	return tea.Prettify(s)
}

func (s UploadCACertificateRequest) GoString() string {
	return s.String()
}

func (s *UploadCACertificateRequest) SetCACertificate(v string) *UploadCACertificateRequest {
	s.CACertificate = &v
	return s
}

func (s *UploadCACertificateRequest) SetCACertificateName(v string) *UploadCACertificateRequest {
	s.CACertificateName = &v
	return s
}

func (s *UploadCACertificateRequest) SetOwnerAccount(v string) *UploadCACertificateRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UploadCACertificateRequest) SetOwnerId(v int64) *UploadCACertificateRequest {
	s.OwnerId = &v
	return s
}

func (s *UploadCACertificateRequest) SetRegionId(v string) *UploadCACertificateRequest {
	s.RegionId = &v
	return s
}

func (s *UploadCACertificateRequest) SetResourceGroupId(v string) *UploadCACertificateRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *UploadCACertificateRequest) SetResourceOwnerAccount(v string) *UploadCACertificateRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UploadCACertificateRequest) SetResourceOwnerId(v int64) *UploadCACertificateRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UploadCACertificateRequest) SetTag(v []*UploadCACertificateRequestTag) *UploadCACertificateRequest {
	s.Tag = v
	return s
}

type UploadCACertificateRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s UploadCACertificateRequestTag) String() string {
	return tea.Prettify(s)
}

func (s UploadCACertificateRequestTag) GoString() string {
	return s.String()
}

func (s *UploadCACertificateRequestTag) SetKey(v string) *UploadCACertificateRequestTag {
	s.Key = &v
	return s
}

func (s *UploadCACertificateRequestTag) SetValue(v string) *UploadCACertificateRequestTag {
	s.Value = &v
	return s
}

type UploadCACertificateResponseBody struct {
	CACertificateId *string `json:"CACertificateId,omitempty" xml:"CACertificateId,omitempty"`
	// The ID of the CA certificate.
	CACertificateName *string `json:"CACertificateName,omitempty" xml:"CACertificateName,omitempty"`
	// The name of the CA certificate.
	CommonName *string `json:"CommonName,omitempty" xml:"CommonName,omitempty"`
	// The ID of the enterprise resource group.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The time when the CA certificate expires.
	CreateTimeStamp *int64 `json:"CreateTimeStamp,omitempty" xml:"CreateTimeStamp,omitempty"`
	// The time when the CA certificate is uploaded.
	ExpireTime *string `json:"ExpireTime,omitempty" xml:"ExpireTime,omitempty"`
	// You can upload only one CA certificate at a time. After a CA certificate is uploaded, the certificate ID, name, and fingerprint are returned.
	ExpireTimeStamp *int64 `json:"ExpireTimeStamp,omitempty" xml:"ExpireTimeStamp,omitempty"`
	// The domain name of the CA certificate.
	Fingerprint *string `json:"Fingerprint,omitempty" xml:"Fingerprint,omitempty"`
	// The fingerprint of the CA certificate.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The timestamp generated when the CA certificate expires.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s UploadCACertificateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UploadCACertificateResponseBody) GoString() string {
	return s.String()
}

func (s *UploadCACertificateResponseBody) SetCACertificateId(v string) *UploadCACertificateResponseBody {
	s.CACertificateId = &v
	return s
}

func (s *UploadCACertificateResponseBody) SetCACertificateName(v string) *UploadCACertificateResponseBody {
	s.CACertificateName = &v
	return s
}

func (s *UploadCACertificateResponseBody) SetCommonName(v string) *UploadCACertificateResponseBody {
	s.CommonName = &v
	return s
}

func (s *UploadCACertificateResponseBody) SetCreateTime(v string) *UploadCACertificateResponseBody {
	s.CreateTime = &v
	return s
}

func (s *UploadCACertificateResponseBody) SetCreateTimeStamp(v int64) *UploadCACertificateResponseBody {
	s.CreateTimeStamp = &v
	return s
}

func (s *UploadCACertificateResponseBody) SetExpireTime(v string) *UploadCACertificateResponseBody {
	s.ExpireTime = &v
	return s
}

func (s *UploadCACertificateResponseBody) SetExpireTimeStamp(v int64) *UploadCACertificateResponseBody {
	s.ExpireTimeStamp = &v
	return s
}

func (s *UploadCACertificateResponseBody) SetFingerprint(v string) *UploadCACertificateResponseBody {
	s.Fingerprint = &v
	return s
}

func (s *UploadCACertificateResponseBody) SetRequestId(v string) *UploadCACertificateResponseBody {
	s.RequestId = &v
	return s
}

func (s *UploadCACertificateResponseBody) SetResourceGroupId(v string) *UploadCACertificateResponseBody {
	s.ResourceGroupId = &v
	return s
}

type UploadCACertificateResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UploadCACertificateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UploadCACertificateResponse) String() string {
	return tea.Prettify(s)
}

func (s UploadCACertificateResponse) GoString() string {
	return s.String()
}

func (s *UploadCACertificateResponse) SetHeaders(v map[string]*string) *UploadCACertificateResponse {
	s.Headers = v
	return s
}

func (s *UploadCACertificateResponse) SetStatusCode(v int32) *UploadCACertificateResponse {
	s.StatusCode = &v
	return s
}

func (s *UploadCACertificateResponse) SetBody(v *UploadCACertificateResponseBody) *UploadCACertificateResponse {
	s.Body = v
	return s
}

type UploadServerCertificateRequest struct {
	AliCloudCertificateId       *string                              `json:"AliCloudCertificateId,omitempty" xml:"AliCloudCertificateId,omitempty"`
	AliCloudCertificateName     *string                              `json:"AliCloudCertificateName,omitempty" xml:"AliCloudCertificateName,omitempty"`
	AliCloudCertificateRegionId *string                              `json:"AliCloudCertificateRegionId,omitempty" xml:"AliCloudCertificateRegionId,omitempty"`
	OwnerAccount                *string                              `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                     *int64                               `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	PrivateKey                  *string                              `json:"PrivateKey,omitempty" xml:"PrivateKey,omitempty"`
	RegionId                    *string                              `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceGroupId             *string                              `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount        *string                              `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId             *int64                               `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	ServerCertificate           *string                              `json:"ServerCertificate,omitempty" xml:"ServerCertificate,omitempty"`
	ServerCertificateName       *string                              `json:"ServerCertificateName,omitempty" xml:"ServerCertificateName,omitempty"`
	Tag                         []*UploadServerCertificateRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s UploadServerCertificateRequest) String() string {
	return tea.Prettify(s)
}

func (s UploadServerCertificateRequest) GoString() string {
	return s.String()
}

func (s *UploadServerCertificateRequest) SetAliCloudCertificateId(v string) *UploadServerCertificateRequest {
	s.AliCloudCertificateId = &v
	return s
}

func (s *UploadServerCertificateRequest) SetAliCloudCertificateName(v string) *UploadServerCertificateRequest {
	s.AliCloudCertificateName = &v
	return s
}

func (s *UploadServerCertificateRequest) SetAliCloudCertificateRegionId(v string) *UploadServerCertificateRequest {
	s.AliCloudCertificateRegionId = &v
	return s
}

func (s *UploadServerCertificateRequest) SetOwnerAccount(v string) *UploadServerCertificateRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UploadServerCertificateRequest) SetOwnerId(v int64) *UploadServerCertificateRequest {
	s.OwnerId = &v
	return s
}

func (s *UploadServerCertificateRequest) SetPrivateKey(v string) *UploadServerCertificateRequest {
	s.PrivateKey = &v
	return s
}

func (s *UploadServerCertificateRequest) SetRegionId(v string) *UploadServerCertificateRequest {
	s.RegionId = &v
	return s
}

func (s *UploadServerCertificateRequest) SetResourceGroupId(v string) *UploadServerCertificateRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *UploadServerCertificateRequest) SetResourceOwnerAccount(v string) *UploadServerCertificateRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UploadServerCertificateRequest) SetResourceOwnerId(v int64) *UploadServerCertificateRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UploadServerCertificateRequest) SetServerCertificate(v string) *UploadServerCertificateRequest {
	s.ServerCertificate = &v
	return s
}

func (s *UploadServerCertificateRequest) SetServerCertificateName(v string) *UploadServerCertificateRequest {
	s.ServerCertificateName = &v
	return s
}

func (s *UploadServerCertificateRequest) SetTag(v []*UploadServerCertificateRequestTag) *UploadServerCertificateRequest {
	s.Tag = v
	return s
}

type UploadServerCertificateRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s UploadServerCertificateRequestTag) String() string {
	return tea.Prettify(s)
}

func (s UploadServerCertificateRequestTag) GoString() string {
	return s.String()
}

func (s *UploadServerCertificateRequestTag) SetKey(v string) *UploadServerCertificateRequestTag {
	s.Key = &v
	return s
}

func (s *UploadServerCertificateRequestTag) SetValue(v string) *UploadServerCertificateRequestTag {
	s.Value = &v
	return s
}

type UploadServerCertificateResponseBody struct {
	AliCloudCertificateId   *string                                                     `json:"AliCloudCertificateId,omitempty" xml:"AliCloudCertificateId,omitempty"`
	AliCloudCertificateName *string                                                     `json:"AliCloudCertificateName,omitempty" xml:"AliCloudCertificateName,omitempty"`
	CommonName              *string                                                     `json:"CommonName,omitempty" xml:"CommonName,omitempty"`
	CreateTime              *string                                                     `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	CreateTimeStamp         *int64                                                      `json:"CreateTimeStamp,omitempty" xml:"CreateTimeStamp,omitempty"`
	ExpireTime              *string                                                     `json:"ExpireTime,omitempty" xml:"ExpireTime,omitempty"`
	ExpireTimeStamp         *int64                                                      `json:"ExpireTimeStamp,omitempty" xml:"ExpireTimeStamp,omitempty"`
	Fingerprint             *string                                                     `json:"Fingerprint,omitempty" xml:"Fingerprint,omitempty"`
	IsAliCloudCertificate   *int32                                                      `json:"IsAliCloudCertificate,omitempty" xml:"IsAliCloudCertificate,omitempty"`
	RegionId                *string                                                     `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	RequestId               *string                                                     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	ResourceGroupId         *string                                                     `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ServerCertificateId     *string                                                     `json:"ServerCertificateId,omitempty" xml:"ServerCertificateId,omitempty"`
	ServerCertificateName   *string                                                     `json:"ServerCertificateName,omitempty" xml:"ServerCertificateName,omitempty"`
	SubjectAlternativeNames *UploadServerCertificateResponseBodySubjectAlternativeNames `json:"SubjectAlternativeNames,omitempty" xml:"SubjectAlternativeNames,omitempty" type:"Struct"`
}

func (s UploadServerCertificateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UploadServerCertificateResponseBody) GoString() string {
	return s.String()
}

func (s *UploadServerCertificateResponseBody) SetAliCloudCertificateId(v string) *UploadServerCertificateResponseBody {
	s.AliCloudCertificateId = &v
	return s
}

func (s *UploadServerCertificateResponseBody) SetAliCloudCertificateName(v string) *UploadServerCertificateResponseBody {
	s.AliCloudCertificateName = &v
	return s
}

func (s *UploadServerCertificateResponseBody) SetCommonName(v string) *UploadServerCertificateResponseBody {
	s.CommonName = &v
	return s
}

func (s *UploadServerCertificateResponseBody) SetCreateTime(v string) *UploadServerCertificateResponseBody {
	s.CreateTime = &v
	return s
}

func (s *UploadServerCertificateResponseBody) SetCreateTimeStamp(v int64) *UploadServerCertificateResponseBody {
	s.CreateTimeStamp = &v
	return s
}

func (s *UploadServerCertificateResponseBody) SetExpireTime(v string) *UploadServerCertificateResponseBody {
	s.ExpireTime = &v
	return s
}

func (s *UploadServerCertificateResponseBody) SetExpireTimeStamp(v int64) *UploadServerCertificateResponseBody {
	s.ExpireTimeStamp = &v
	return s
}

func (s *UploadServerCertificateResponseBody) SetFingerprint(v string) *UploadServerCertificateResponseBody {
	s.Fingerprint = &v
	return s
}

func (s *UploadServerCertificateResponseBody) SetIsAliCloudCertificate(v int32) *UploadServerCertificateResponseBody {
	s.IsAliCloudCertificate = &v
	return s
}

func (s *UploadServerCertificateResponseBody) SetRegionId(v string) *UploadServerCertificateResponseBody {
	s.RegionId = &v
	return s
}

func (s *UploadServerCertificateResponseBody) SetRequestId(v string) *UploadServerCertificateResponseBody {
	s.RequestId = &v
	return s
}

func (s *UploadServerCertificateResponseBody) SetResourceGroupId(v string) *UploadServerCertificateResponseBody {
	s.ResourceGroupId = &v
	return s
}

func (s *UploadServerCertificateResponseBody) SetServerCertificateId(v string) *UploadServerCertificateResponseBody {
	s.ServerCertificateId = &v
	return s
}

func (s *UploadServerCertificateResponseBody) SetServerCertificateName(v string) *UploadServerCertificateResponseBody {
	s.ServerCertificateName = &v
	return s
}

func (s *UploadServerCertificateResponseBody) SetSubjectAlternativeNames(v *UploadServerCertificateResponseBodySubjectAlternativeNames) *UploadServerCertificateResponseBody {
	s.SubjectAlternativeNames = v
	return s
}

type UploadServerCertificateResponseBodySubjectAlternativeNames struct {
	SubjectAlternativeName []*string `json:"SubjectAlternativeName,omitempty" xml:"SubjectAlternativeName,omitempty" type:"Repeated"`
}

func (s UploadServerCertificateResponseBodySubjectAlternativeNames) String() string {
	return tea.Prettify(s)
}

func (s UploadServerCertificateResponseBodySubjectAlternativeNames) GoString() string {
	return s.String()
}

func (s *UploadServerCertificateResponseBodySubjectAlternativeNames) SetSubjectAlternativeName(v []*string) *UploadServerCertificateResponseBodySubjectAlternativeNames {
	s.SubjectAlternativeName = v
	return s
}

type UploadServerCertificateResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UploadServerCertificateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UploadServerCertificateResponse) String() string {
	return tea.Prettify(s)
}

func (s UploadServerCertificateResponse) GoString() string {
	return s.String()
}

func (s *UploadServerCertificateResponse) SetHeaders(v map[string]*string) *UploadServerCertificateResponse {
	s.Headers = v
	return s
}

func (s *UploadServerCertificateResponse) SetStatusCode(v int32) *UploadServerCertificateResponse {
	s.StatusCode = &v
	return s
}

func (s *UploadServerCertificateResponse) SetBody(v *UploadServerCertificateResponseBody) *UploadServerCertificateResponse {
	s.Body = v
	return s
}

type Client struct {
	openapi.Client
}

func NewClient(config *openapi.Config) (*Client, error) {
	client := new(Client)
	err := client.Init(config)
	return client, err
}

func (client *Client) Init(config *openapi.Config) (_err error) {
	_err = client.Client.Init(config)
	if _err != nil {
		return _err
	}
	client.EndpointRule = tea.String("regional")
	client.EndpointMap = map[string]*string{
		"cn-qingdao":                  tea.String("slb.aliyuncs.com"),
		"cn-beijing":                  tea.String("slb.aliyuncs.com"),
		"cn-hangzhou":                 tea.String("slb.aliyuncs.com"),
		"cn-shanghai":                 tea.String("slb.aliyuncs.com"),
		"cn-shenzhen":                 tea.String("slb.aliyuncs.com"),
		"cn-hongkong":                 tea.String("slb.aliyuncs.com"),
		"ap-southeast-1":              tea.String("slb.aliyuncs.com"),
		"us-east-1":                   tea.String("slb.aliyuncs.com"),
		"us-west-1":                   tea.String("slb.aliyuncs.com"),
		"cn-shanghai-finance-1":       tea.String("slb.aliyuncs.com"),
		"cn-shenzhen-finance-1":       tea.String("slb.aliyuncs.com"),
		"cn-north-2-gov-1":            tea.String("slb.aliyuncs.com"),
		"ap-northeast-2-pop":          tea.String("slb.aliyuncs.com"),
		"cn-beijing-finance-pop":      tea.String("slb.aliyuncs.com"),
		"cn-beijing-gov-1":            tea.String("slb.aliyuncs.com"),
		"cn-beijing-nu16-b01":         tea.String("slb.aliyuncs.com"),
		"cn-edge-1":                   tea.String("slb.aliyuncs.com"),
		"cn-fujian":                   tea.String("slb.aliyuncs.com"),
		"cn-haidian-cm12-c01":         tea.String("slb.aliyuncs.com"),
		"cn-hangzhou-bj-b01":          tea.String("slb.aliyuncs.com"),
		"cn-hangzhou-finance":         tea.String("slb.aliyuncs.com"),
		"cn-hangzhou-internal-prod-1": tea.String("slb.aliyuncs.com"),
		"cn-hangzhou-internal-test-1": tea.String("slb.aliyuncs.com"),
		"cn-hangzhou-internal-test-2": tea.String("slb.aliyuncs.com"),
		"cn-hangzhou-internal-test-3": tea.String("slb.aliyuncs.com"),
		"cn-hangzhou-test-306":        tea.String("slb.aliyuncs.com"),
		"cn-hongkong-finance-pop":     tea.String("slb.aliyuncs.com"),
		"cn-huhehaote-nebula-1":       tea.String("slb-api.cn-qingdao-nebula.aliyuncs.com"),
		"cn-shanghai-et15-b01":        tea.String("slb.aliyuncs.com"),
		"cn-shanghai-et2-b01":         tea.String("slb.aliyuncs.com"),
		"cn-shanghai-inner":           tea.String("slb.aliyuncs.com"),
		"cn-shanghai-internal-test-1": tea.String("slb.aliyuncs.com"),
		"cn-shenzhen-inner":           tea.String("slb.aliyuncs.com"),
		"cn-shenzhen-st4-d01":         tea.String("slb.aliyuncs.com"),
		"cn-shenzhen-su18-b01":        tea.String("slb.aliyuncs.com"),
		"cn-wuhan":                    tea.String("slb.aliyuncs.com"),
		"cn-yushanfang":               tea.String("slb.aliyuncs.com"),
		"cn-zhangbei":                 tea.String("slb.aliyuncs.com"),
		"cn-zhangbei-na61-b01":        tea.String("slb.aliyuncs.com"),
		"cn-zhangjiakou-na62-a01":     tea.String("slb.aliyuncs.com"),
		"cn-zhengzhou-nebula-1":       tea.String("slb.aliyuncs.com"),
		"eu-west-1-oxs":               tea.String("slb.aliyuncs.com"),
		"rus-west-1-pop":              tea.String("slb.aliyuncs.com"),
	}
	_err = client.CheckConfig(config)
	if _err != nil {
		return _err
	}
	client.Endpoint, _err = client.GetEndpoint(tea.String("slb"), client.RegionId, client.EndpointRule, client.Network, client.Suffix, client.EndpointMap, client.Endpoint)
	if _err != nil {
		return _err
	}

	return nil
}

func (client *Client) GetEndpoint(productId *string, regionId *string, endpointRule *string, network *string, suffix *string, endpointMap map[string]*string, endpoint *string) (_result *string, _err error) {
	if !tea.BoolValue(util.Empty(endpoint)) {
		_result = endpoint
		return _result, _err
	}

	if !tea.BoolValue(util.IsUnset(endpointMap)) && !tea.BoolValue(util.Empty(endpointMap[tea.StringValue(regionId)])) {
		_result = endpointMap[tea.StringValue(regionId)]
		return _result, _err
	}

	_body, _err := endpointutil.GetEndpointRules(productId, regionId, endpointRule, network, suffix)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Each network ACL can contain one or more IP addresses or CIDR blocks. Take note of the following limits on network ACLs:
 * *   The number of IP entries that can be added to a network ACL with each Alibaba Cloud account at a time: 50
 * *   The maximum number of IP entries that each network ACL can contain: 300
 *
 * @param request AddAccessControlListEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddAccessControlListEntryResponse
 */
func (client *Client) AddAccessControlListEntryWithOptions(request *AddAccessControlListEntryRequest, runtime *util.RuntimeOptions) (_result *AddAccessControlListEntryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclEntrys)) {
		query["AclEntrys"] = request.AclEntrys
	}

	if !tea.BoolValue(util.IsUnset(request.AclId)) {
		query["AclId"] = request.AclId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddAccessControlListEntry"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddAccessControlListEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Each network ACL can contain one or more IP addresses or CIDR blocks. Take note of the following limits on network ACLs:
 * *   The number of IP entries that can be added to a network ACL with each Alibaba Cloud account at a time: 50
 * *   The maximum number of IP entries that each network ACL can contain: 300
 *
 * @param request AddAccessControlListEntryRequest
 * @return AddAccessControlListEntryResponse
 */
func (client *Client) AddAccessControlListEntry(request *AddAccessControlListEntryRequest) (_result *AddAccessControlListEntryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddAccessControlListEntryResponse{}
	_body, _err := client.AddAccessControlListEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the CLB instance.
 *
 * @param request AddBackendServersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddBackendServersResponse
 */
func (client *Client) AddBackendServersWithOptions(request *AddBackendServersRequest, runtime *util.RuntimeOptions) (_result *AddBackendServersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackendServers)) {
		query["BackendServers"] = request.BackendServers
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddBackendServers"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddBackendServersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the CLB instance.
 *
 * @param request AddBackendServersRequest
 * @return AddBackendServersResponse
 */
func (client *Client) AddBackendServers(request *AddBackendServersRequest) (_result *AddBackendServersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddBackendServersResponse{}
	_body, _err := client.AddBackendServersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddListenerWhiteListItemWithOptions(request *AddListenerWhiteListItemRequest, runtime *util.RuntimeOptions) (_result *AddListenerWhiteListItemResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ListenerPort)) {
		query["ListenerPort"] = request.ListenerPort
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerProtocol)) {
		query["ListenerProtocol"] = request.ListenerProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SourceItems)) {
		query["SourceItems"] = request.SourceItems
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddListenerWhiteListItem"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddListenerWhiteListItemResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddListenerWhiteListItem(request *AddListenerWhiteListItemRequest) (_result *AddListenerWhiteListItemResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddListenerWhiteListItemResponse{}
	_body, _err := client.AddListenerWhiteListItemWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The name of this action.
 * Value: **AddTags**
 *
 * @param request AddTagsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddTagsResponse
 */
func (client *Client) AddTagsWithOptions(request *AddTagsRequest, runtime *util.RuntimeOptions) (_result *AddTagsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddTags"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddTagsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The name of this action.
 * Value: **AddTags**
 *
 * @param request AddTagsRequest
 * @return AddTagsResponse
 */
func (client *Client) AddTags(request *AddTagsRequest) (_result *AddTagsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddTagsResponse{}
	_body, _err := client.AddTagsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddVServerGroupBackendServersWithOptions(request *AddVServerGroupBackendServersRequest, runtime *util.RuntimeOptions) (_result *AddVServerGroupBackendServersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackendServers)) {
		query["BackendServers"] = request.BackendServers
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroupId)) {
		query["VServerGroupId"] = request.VServerGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddVServerGroupBackendServers"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddVServerGroupBackendServersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddVServerGroupBackendServers(request *AddVServerGroupBackendServersRequest) (_result *AddVServerGroupBackendServersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddVServerGroupBackendServersResponse{}
	_body, _err := client.AddVServerGroupBackendServersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the region where you want to create the ACL.
 *
 * @param request CreateAccessControlListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAccessControlListResponse
 */
func (client *Client) CreateAccessControlListWithOptions(request *CreateAccessControlListRequest, runtime *util.RuntimeOptions) (_result *CreateAccessControlListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclName)) {
		query["AclName"] = request.AclName
	}

	if !tea.BoolValue(util.IsUnset(request.AddressIPVersion)) {
		query["AddressIPVersion"] = request.AddressIPVersion
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateAccessControlList"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateAccessControlListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the region where you want to create the ACL.
 *
 * @param request CreateAccessControlListRequest
 * @return CreateAccessControlListResponse
 */
func (client *Client) CreateAccessControlList(request *CreateAccessControlListRequest) (_result *CreateAccessControlListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateAccessControlListResponse{}
	_body, _err := client.CreateAccessControlListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateDomainExtensionWithOptions(request *CreateDomainExtensionRequest, runtime *util.RuntimeOptions) (_result *CreateDomainExtensionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Domain)) {
		query["Domain"] = request.Domain
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerPort)) {
		query["ListenerPort"] = request.ListenerPort
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ServerCertificateId)) {
		query["ServerCertificateId"] = request.ServerCertificateId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDomainExtension"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDomainExtensionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateDomainExtension(request *CreateDomainExtensionRequest) (_result *CreateDomainExtensionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDomainExtensionResponse{}
	_body, _err := client.CreateDomainExtensionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The order ID of the subscription CLB instance.
 *
 * @param request CreateLoadBalancerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateLoadBalancerResponse
 */
func (client *Client) CreateLoadBalancerWithOptions(request *CreateLoadBalancerRequest, runtime *util.RuntimeOptions) (_result *CreateLoadBalancerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Address)) {
		query["Address"] = request.Address
	}

	if !tea.BoolValue(util.IsUnset(request.AddressIPVersion)) {
		query["AddressIPVersion"] = request.AddressIPVersion
	}

	if !tea.BoolValue(util.IsUnset(request.AddressType)) {
		query["AddressType"] = request.AddressType
	}

	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DeleteProtection)) {
		query["DeleteProtection"] = request.DeleteProtection
	}

	if !tea.BoolValue(util.IsUnset(request.Duration)) {
		query["Duration"] = request.Duration
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceChargeType)) {
		query["InstanceChargeType"] = request.InstanceChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.InternetChargeType)) {
		query["InternetChargeType"] = request.InternetChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerName)) {
		query["LoadBalancerName"] = request.LoadBalancerName
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerSpec)) {
		query["LoadBalancerSpec"] = request.LoadBalancerSpec
	}

	if !tea.BoolValue(util.IsUnset(request.MasterZoneId)) {
		query["MasterZoneId"] = request.MasterZoneId
	}

	if !tea.BoolValue(util.IsUnset(request.ModificationProtectionReason)) {
		query["ModificationProtectionReason"] = request.ModificationProtectionReason
	}

	if !tea.BoolValue(util.IsUnset(request.ModificationProtectionStatus)) {
		query["ModificationProtectionStatus"] = request.ModificationProtectionStatus
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PayType)) {
		query["PayType"] = request.PayType
	}

	if !tea.BoolValue(util.IsUnset(request.PricingCycle)) {
		query["PricingCycle"] = request.PricingCycle
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SlaveZoneId)) {
		query["SlaveZoneId"] = request.SlaveZoneId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateLoadBalancer"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateLoadBalancerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The order ID of the subscription CLB instance.
 *
 * @param request CreateLoadBalancerRequest
 * @return CreateLoadBalancerResponse
 */
func (client *Client) CreateLoadBalancer(request *CreateLoadBalancerRequest) (_result *CreateLoadBalancerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateLoadBalancerResponse{}
	_body, _err := client.CreateLoadBalancerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The timeout period of a cookie. Unit: seconds.
 * Valid values: **1** to **86400**.
 * >  If **StickySession** is set to **on** and **StickySessionType** is set to **insert**, this parameter is required.
 *
 * @param request CreateLoadBalancerHTTPListenerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateLoadBalancerHTTPListenerResponse
 */
func (client *Client) CreateLoadBalancerHTTPListenerWithOptions(request *CreateLoadBalancerHTTPListenerRequest, runtime *util.RuntimeOptions) (_result *CreateLoadBalancerHTTPListenerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclId)) {
		query["AclId"] = request.AclId
	}

	if !tea.BoolValue(util.IsUnset(request.AclStatus)) {
		query["AclStatus"] = request.AclStatus
	}

	if !tea.BoolValue(util.IsUnset(request.AclType)) {
		query["AclType"] = request.AclType
	}

	if !tea.BoolValue(util.IsUnset(request.BackendServerPort)) {
		query["BackendServerPort"] = request.BackendServerPort
	}

	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.Cookie)) {
		query["Cookie"] = request.Cookie
	}

	if !tea.BoolValue(util.IsUnset(request.CookieTimeout)) {
		query["CookieTimeout"] = request.CookieTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.ForwardPort)) {
		query["ForwardPort"] = request.ForwardPort
	}

	if !tea.BoolValue(util.IsUnset(request.Gzip)) {
		query["Gzip"] = request.Gzip
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheck)) {
		query["HealthCheck"] = request.HealthCheck
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckConnectPort)) {
		query["HealthCheckConnectPort"] = request.HealthCheckConnectPort
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckDomain)) {
		query["HealthCheckDomain"] = request.HealthCheckDomain
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckHttpCode)) {
		query["HealthCheckHttpCode"] = request.HealthCheckHttpCode
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckInterval)) {
		query["HealthCheckInterval"] = request.HealthCheckInterval
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckMethod)) {
		query["HealthCheckMethod"] = request.HealthCheckMethod
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckTimeout)) {
		query["HealthCheckTimeout"] = request.HealthCheckTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckURI)) {
		query["HealthCheckURI"] = request.HealthCheckURI
	}

	if !tea.BoolValue(util.IsUnset(request.HealthyThreshold)) {
		query["HealthyThreshold"] = request.HealthyThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.IdleTimeout)) {
		query["IdleTimeout"] = request.IdleTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerForward)) {
		query["ListenerForward"] = request.ListenerForward
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerPort)) {
		query["ListenerPort"] = request.ListenerPort
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestTimeout)) {
		query["RequestTimeout"] = request.RequestTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Scheduler)) {
		query["Scheduler"] = request.Scheduler
	}

	if !tea.BoolValue(util.IsUnset(request.StickySession)) {
		query["StickySession"] = request.StickySession
	}

	if !tea.BoolValue(util.IsUnset(request.StickySessionType)) {
		query["StickySessionType"] = request.StickySessionType
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.UnhealthyThreshold)) {
		query["UnhealthyThreshold"] = request.UnhealthyThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroupId)) {
		query["VServerGroupId"] = request.VServerGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.XForwardedFor)) {
		query["XForwardedFor"] = request.XForwardedFor
	}

	if !tea.BoolValue(util.IsUnset(request.XForwardedFor_SLBID)) {
		query["XForwardedFor_SLBID"] = request.XForwardedFor_SLBID
	}

	if !tea.BoolValue(util.IsUnset(request.XForwardedFor_SLBIP)) {
		query["XForwardedFor_SLBIP"] = request.XForwardedFor_SLBIP
	}

	if !tea.BoolValue(util.IsUnset(request.XForwardedFor_proto)) {
		query["XForwardedFor_proto"] = request.XForwardedFor_proto
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateLoadBalancerHTTPListener"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateLoadBalancerHTTPListenerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The timeout period of a cookie. Unit: seconds.
 * Valid values: **1** to **86400**.
 * >  If **StickySession** is set to **on** and **StickySessionType** is set to **insert**, this parameter is required.
 *
 * @param request CreateLoadBalancerHTTPListenerRequest
 * @return CreateLoadBalancerHTTPListenerResponse
 */
func (client *Client) CreateLoadBalancerHTTPListener(request *CreateLoadBalancerHTTPListenerRequest) (_result *CreateLoadBalancerHTTPListenerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateLoadBalancerHTTPListenerResponse{}
	_body, _err := client.CreateLoadBalancerHTTPListenerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The timeout period of a cookie. Unit: seconds.
 * Valid values: **1** to **86400**.
 * >  If **StickySession** is set to **on** and **StickySessionType** is set to **insert**, this parameter is required.
 *
 * @param request CreateLoadBalancerHTTPSListenerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateLoadBalancerHTTPSListenerResponse
 */
func (client *Client) CreateLoadBalancerHTTPSListenerWithOptions(request *CreateLoadBalancerHTTPSListenerRequest, runtime *util.RuntimeOptions) (_result *CreateLoadBalancerHTTPSListenerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclId)) {
		query["AclId"] = request.AclId
	}

	if !tea.BoolValue(util.IsUnset(request.AclStatus)) {
		query["AclStatus"] = request.AclStatus
	}

	if !tea.BoolValue(util.IsUnset(request.AclType)) {
		query["AclType"] = request.AclType
	}

	if !tea.BoolValue(util.IsUnset(request.BackendServerPort)) {
		query["BackendServerPort"] = request.BackendServerPort
	}

	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.CACertificateId)) {
		query["CACertificateId"] = request.CACertificateId
	}

	if !tea.BoolValue(util.IsUnset(request.Cookie)) {
		query["Cookie"] = request.Cookie
	}

	if !tea.BoolValue(util.IsUnset(request.CookieTimeout)) {
		query["CookieTimeout"] = request.CookieTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EnableHttp2)) {
		query["EnableHttp2"] = request.EnableHttp2
	}

	if !tea.BoolValue(util.IsUnset(request.Gzip)) {
		query["Gzip"] = request.Gzip
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheck)) {
		query["HealthCheck"] = request.HealthCheck
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckConnectPort)) {
		query["HealthCheckConnectPort"] = request.HealthCheckConnectPort
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckDomain)) {
		query["HealthCheckDomain"] = request.HealthCheckDomain
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckHttpCode)) {
		query["HealthCheckHttpCode"] = request.HealthCheckHttpCode
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckInterval)) {
		query["HealthCheckInterval"] = request.HealthCheckInterval
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckMethod)) {
		query["HealthCheckMethod"] = request.HealthCheckMethod
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckTimeout)) {
		query["HealthCheckTimeout"] = request.HealthCheckTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckURI)) {
		query["HealthCheckURI"] = request.HealthCheckURI
	}

	if !tea.BoolValue(util.IsUnset(request.HealthyThreshold)) {
		query["HealthyThreshold"] = request.HealthyThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.IdleTimeout)) {
		query["IdleTimeout"] = request.IdleTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerPort)) {
		query["ListenerPort"] = request.ListenerPort
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestTimeout)) {
		query["RequestTimeout"] = request.RequestTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Scheduler)) {
		query["Scheduler"] = request.Scheduler
	}

	if !tea.BoolValue(util.IsUnset(request.ServerCertificateId)) {
		query["ServerCertificateId"] = request.ServerCertificateId
	}

	if !tea.BoolValue(util.IsUnset(request.StickySession)) {
		query["StickySession"] = request.StickySession
	}

	if !tea.BoolValue(util.IsUnset(request.StickySessionType)) {
		query["StickySessionType"] = request.StickySessionType
	}

	if !tea.BoolValue(util.IsUnset(request.TLSCipherPolicy)) {
		query["TLSCipherPolicy"] = request.TLSCipherPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.UnhealthyThreshold)) {
		query["UnhealthyThreshold"] = request.UnhealthyThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroupId)) {
		query["VServerGroupId"] = request.VServerGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.XForwardedFor)) {
		query["XForwardedFor"] = request.XForwardedFor
	}

	if !tea.BoolValue(util.IsUnset(request.XForwardedFor_SLBID)) {
		query["XForwardedFor_SLBID"] = request.XForwardedFor_SLBID
	}

	if !tea.BoolValue(util.IsUnset(request.XForwardedFor_SLBIP)) {
		query["XForwardedFor_SLBIP"] = request.XForwardedFor_SLBIP
	}

	if !tea.BoolValue(util.IsUnset(request.XForwardedFor_proto)) {
		query["XForwardedFor_proto"] = request.XForwardedFor_proto
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateLoadBalancerHTTPSListener"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateLoadBalancerHTTPSListenerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The timeout period of a cookie. Unit: seconds.
 * Valid values: **1** to **86400**.
 * >  If **StickySession** is set to **on** and **StickySessionType** is set to **insert**, this parameter is required.
 *
 * @param request CreateLoadBalancerHTTPSListenerRequest
 * @return CreateLoadBalancerHTTPSListenerResponse
 */
func (client *Client) CreateLoadBalancerHTTPSListener(request *CreateLoadBalancerHTTPSListenerRequest) (_result *CreateLoadBalancerHTTPSListenerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateLoadBalancerHTTPSListenerResponse{}
	_body, _err := client.CreateLoadBalancerHTTPSListenerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. In this case, the health status is changed from **success** to **fail**.
 * Valid values: **2** to **10**.
 *
 * @param request CreateLoadBalancerTCPListenerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateLoadBalancerTCPListenerResponse
 */
func (client *Client) CreateLoadBalancerTCPListenerWithOptions(request *CreateLoadBalancerTCPListenerRequest, runtime *util.RuntimeOptions) (_result *CreateLoadBalancerTCPListenerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclId)) {
		query["AclId"] = request.AclId
	}

	if !tea.BoolValue(util.IsUnset(request.AclStatus)) {
		query["AclStatus"] = request.AclStatus
	}

	if !tea.BoolValue(util.IsUnset(request.AclType)) {
		query["AclType"] = request.AclType
	}

	if !tea.BoolValue(util.IsUnset(request.BackendServerPort)) {
		query["BackendServerPort"] = request.BackendServerPort
	}

	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectionDrain)) {
		query["ConnectionDrain"] = request.ConnectionDrain
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectionDrainTimeout)) {
		query["ConnectionDrainTimeout"] = request.ConnectionDrainTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EstablishedTimeout)) {
		query["EstablishedTimeout"] = request.EstablishedTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckConnectPort)) {
		query["HealthCheckConnectPort"] = request.HealthCheckConnectPort
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckConnectTimeout)) {
		query["HealthCheckConnectTimeout"] = request.HealthCheckConnectTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckDomain)) {
		query["HealthCheckDomain"] = request.HealthCheckDomain
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckHttpCode)) {
		query["HealthCheckHttpCode"] = request.HealthCheckHttpCode
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckSwitch)) {
		query["HealthCheckSwitch"] = request.HealthCheckSwitch
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckType)) {
		query["HealthCheckType"] = request.HealthCheckType
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckURI)) {
		query["HealthCheckURI"] = request.HealthCheckURI
	}

	if !tea.BoolValue(util.IsUnset(request.HealthyThreshold)) {
		query["HealthyThreshold"] = request.HealthyThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerPort)) {
		query["ListenerPort"] = request.ListenerPort
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.MasterSlaveServerGroupId)) {
		query["MasterSlaveServerGroupId"] = request.MasterSlaveServerGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PersistenceTimeout)) {
		query["PersistenceTimeout"] = request.PersistenceTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.ProxyProtocolV2Enabled)) {
		query["ProxyProtocolV2Enabled"] = request.ProxyProtocolV2Enabled
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Scheduler)) {
		query["Scheduler"] = request.Scheduler
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.UnhealthyThreshold)) {
		query["UnhealthyThreshold"] = request.UnhealthyThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroupId)) {
		query["VServerGroupId"] = request.VServerGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckInterval)) {
		query["healthCheckInterval"] = request.HealthCheckInterval
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateLoadBalancerTCPListener"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateLoadBalancerTCPListenerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The number of times that a healthy backend server must consecutively fail health checks before it is declared unhealthy. In this case, the health status is changed from **success** to **fail**.
 * Valid values: **2** to **10**.
 *
 * @param request CreateLoadBalancerTCPListenerRequest
 * @return CreateLoadBalancerTCPListenerResponse
 */
func (client *Client) CreateLoadBalancerTCPListener(request *CreateLoadBalancerTCPListenerRequest) (_result *CreateLoadBalancerTCPListenerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateLoadBalancerTCPListenerResponse{}
	_body, _err := client.CreateLoadBalancerTCPListenerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The port that is used for health checks.
 * Valid values: **1** to **65535**.
 * If this parameter is not set, the backend port specified by **BackendServerPort** is used for health checks.
 *
 * @param request CreateLoadBalancerUDPListenerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateLoadBalancerUDPListenerResponse
 */
func (client *Client) CreateLoadBalancerUDPListenerWithOptions(request *CreateLoadBalancerUDPListenerRequest, runtime *util.RuntimeOptions) (_result *CreateLoadBalancerUDPListenerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclId)) {
		query["AclId"] = request.AclId
	}

	if !tea.BoolValue(util.IsUnset(request.AclStatus)) {
		query["AclStatus"] = request.AclStatus
	}

	if !tea.BoolValue(util.IsUnset(request.AclType)) {
		query["AclType"] = request.AclType
	}

	if !tea.BoolValue(util.IsUnset(request.BackendServerPort)) {
		query["BackendServerPort"] = request.BackendServerPort
	}

	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckConnectPort)) {
		query["HealthCheckConnectPort"] = request.HealthCheckConnectPort
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckConnectTimeout)) {
		query["HealthCheckConnectTimeout"] = request.HealthCheckConnectTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckSwitch)) {
		query["HealthCheckSwitch"] = request.HealthCheckSwitch
	}

	if !tea.BoolValue(util.IsUnset(request.HealthyThreshold)) {
		query["HealthyThreshold"] = request.HealthyThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerPort)) {
		query["ListenerPort"] = request.ListenerPort
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.MasterSlaveServerGroupId)) {
		query["MasterSlaveServerGroupId"] = request.MasterSlaveServerGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProxyProtocolV2Enabled)) {
		query["ProxyProtocolV2Enabled"] = request.ProxyProtocolV2Enabled
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Scheduler)) {
		query["Scheduler"] = request.Scheduler
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.UnhealthyThreshold)) {
		query["UnhealthyThreshold"] = request.UnhealthyThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroupId)) {
		query["VServerGroupId"] = request.VServerGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckExp)) {
		query["healthCheckExp"] = request.HealthCheckExp
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckInterval)) {
		query["healthCheckInterval"] = request.HealthCheckInterval
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckReq)) {
		query["healthCheckReq"] = request.HealthCheckReq
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateLoadBalancerUDPListener"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateLoadBalancerUDPListenerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The port that is used for health checks.
 * Valid values: **1** to **65535**.
 * If this parameter is not set, the backend port specified by **BackendServerPort** is used for health checks.
 *
 * @param request CreateLoadBalancerUDPListenerRequest
 * @return CreateLoadBalancerUDPListenerResponse
 */
func (client *Client) CreateLoadBalancerUDPListener(request *CreateLoadBalancerUDPListenerRequest) (_result *CreateLoadBalancerUDPListenerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateLoadBalancerUDPListenerResponse{}
	_body, _err := client.CreateLoadBalancerUDPListenerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateMasterSlaveServerGroupWithOptions(request *CreateMasterSlaveServerGroupRequest, runtime *util.RuntimeOptions) (_result *CreateMasterSlaveServerGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.MasterSlaveBackendServers)) {
		query["MasterSlaveBackendServers"] = request.MasterSlaveBackendServers
	}

	if !tea.BoolValue(util.IsUnset(request.MasterSlaveServerGroupName)) {
		query["MasterSlaveServerGroupName"] = request.MasterSlaveServerGroupName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateMasterSlaveServerGroup"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateMasterSlaveServerGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateMasterSlaveServerGroup(request *CreateMasterSlaveServerGroupRequest) (_result *CreateMasterSlaveServerGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateMasterSlaveServerGroupResponse{}
	_body, _err := client.CreateMasterSlaveServerGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateRulesWithOptions(request *CreateRulesRequest, runtime *util.RuntimeOptions) (_result *CreateRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ListenerPort)) {
		query["ListenerPort"] = request.ListenerPort
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerProtocol)) {
		query["ListenerProtocol"] = request.ListenerProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleList)) {
		query["RuleList"] = request.RuleList
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateRules"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateRules(request *CreateRulesRequest) (_result *CreateRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateRulesResponse{}
	_body, _err := client.CreateRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateTLSCipherPolicyWithOptions(request *CreateTLSCipherPolicyRequest, runtime *util.RuntimeOptions) (_result *CreateTLSCipherPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Ciphers)) {
		query["Ciphers"] = request.Ciphers
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TLSVersions)) {
		query["TLSVersions"] = request.TLSVersions
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateTLSCipherPolicy"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateTLSCipherPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateTLSCipherPolicy(request *CreateTLSCipherPolicyRequest) (_result *CreateTLSCipherPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateTLSCipherPolicyResponse{}
	_body, _err := client.CreateTLSCipherPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateVServerGroupWithOptions(request *CreateVServerGroupRequest, runtime *util.RuntimeOptions) (_result *CreateVServerGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackendServers)) {
		query["BackendServers"] = request.BackendServers
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroupName)) {
		query["VServerGroupName"] = request.VServerGroupName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateVServerGroup"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateVServerGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateVServerGroup(request *CreateVServerGroupRequest) (_result *CreateVServerGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateVServerGroupResponse{}
	_body, _err := client.CreateVServerGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the region to which the access control list belongs.
 * To query the region ID, call [DescribeRegions](~~27584~~).
 *
 * @param request DeleteAccessControlListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAccessControlListResponse
 */
func (client *Client) DeleteAccessControlListWithOptions(request *DeleteAccessControlListRequest, runtime *util.RuntimeOptions) (_result *DeleteAccessControlListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclId)) {
		query["AclId"] = request.AclId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAccessControlList"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteAccessControlListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the region to which the access control list belongs.
 * To query the region ID, call [DescribeRegions](~~27584~~).
 *
 * @param request DeleteAccessControlListRequest
 * @return DeleteAccessControlListResponse
 */
func (client *Client) DeleteAccessControlList(request *DeleteAccessControlListRequest) (_result *DeleteAccessControlListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAccessControlListResponse{}
	_body, _err := client.DeleteAccessControlListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteAccessLogsDownloadAttributeWithOptions(request *DeleteAccessLogsDownloadAttributeRequest, runtime *util.RuntimeOptions) (_result *DeleteAccessLogsDownloadAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.LogsDownloadAttributes)) {
		query["LogsDownloadAttributes"] = request.LogsDownloadAttributes
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAccessLogsDownloadAttribute"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteAccessLogsDownloadAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteAccessLogsDownloadAttribute(request *DeleteAccessLogsDownloadAttributeRequest) (_result *DeleteAccessLogsDownloadAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAccessLogsDownloadAttributeResponse{}
	_body, _err := client.DeleteAccessLogsDownloadAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The region to which the CA certificate belongs.
 * To query the region ID, call [DescribeRegions](~~27584~~).
 *
 * @param request DeleteCACertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCACertificateResponse
 */
func (client *Client) DeleteCACertificateWithOptions(request *DeleteCACertificateRequest, runtime *util.RuntimeOptions) (_result *DeleteCACertificateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CACertificateId)) {
		query["CACertificateId"] = request.CACertificateId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteCACertificate"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteCACertificateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The region to which the CA certificate belongs.
 * To query the region ID, call [DescribeRegions](~~27584~~).
 *
 * @param request DeleteCACertificateRequest
 * @return DeleteCACertificateResponse
 */
func (client *Client) DeleteCACertificate(request *DeleteCACertificateRequest) (_result *DeleteCACertificateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteCACertificateResponse{}
	_body, _err := client.DeleteCACertificateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteDomainExtensionWithOptions(request *DeleteDomainExtensionRequest, runtime *util.RuntimeOptions) (_result *DeleteDomainExtensionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainExtensionId)) {
		query["DomainExtensionId"] = request.DomainExtensionId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDomainExtension"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDomainExtensionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteDomainExtension(request *DeleteDomainExtensionRequest) (_result *DeleteDomainExtensionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDomainExtensionResponse{}
	_body, _err := client.DeleteDomainExtensionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The operation that you want to perform.
 * Set the value to **DeleteLoadBalancer**.
 *
 * @param request DeleteLoadBalancerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteLoadBalancerResponse
 */
func (client *Client) DeleteLoadBalancerWithOptions(request *DeleteLoadBalancerRequest, runtime *util.RuntimeOptions) (_result *DeleteLoadBalancerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteLoadBalancer"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteLoadBalancerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The operation that you want to perform.
 * Set the value to **DeleteLoadBalancer**.
 *
 * @param request DeleteLoadBalancerRequest
 * @return DeleteLoadBalancerResponse
 */
func (client *Client) DeleteLoadBalancer(request *DeleteLoadBalancerRequest) (_result *DeleteLoadBalancerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteLoadBalancerResponse{}
	_body, _err := client.DeleteLoadBalancerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  You can delete only listeners that are in the **stopped** or **running** state.
 *
 * @param request DeleteLoadBalancerListenerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteLoadBalancerListenerResponse
 */
func (client *Client) DeleteLoadBalancerListenerWithOptions(request *DeleteLoadBalancerListenerRequest, runtime *util.RuntimeOptions) (_result *DeleteLoadBalancerListenerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ListenerPort)) {
		query["ListenerPort"] = request.ListenerPort
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerProtocol)) {
		query["ListenerProtocol"] = request.ListenerProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteLoadBalancerListener"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteLoadBalancerListenerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  You can delete only listeners that are in the **stopped** or **running** state.
 *
 * @param request DeleteLoadBalancerListenerRequest
 * @return DeleteLoadBalancerListenerResponse
 */
func (client *Client) DeleteLoadBalancerListener(request *DeleteLoadBalancerListenerRequest) (_result *DeleteLoadBalancerListenerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteLoadBalancerListenerResponse{}
	_body, _err := client.DeleteLoadBalancerListenerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteMasterSlaveServerGroupWithOptions(request *DeleteMasterSlaveServerGroupRequest, runtime *util.RuntimeOptions) (_result *DeleteMasterSlaveServerGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MasterSlaveServerGroupId)) {
		query["MasterSlaveServerGroupId"] = request.MasterSlaveServerGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteMasterSlaveServerGroup"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteMasterSlaveServerGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteMasterSlaveServerGroup(request *DeleteMasterSlaveServerGroupRequest) (_result *DeleteMasterSlaveServerGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteMasterSlaveServerGroupResponse{}
	_body, _err := client.DeleteMasterSlaveServerGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the region where the Server Load Balancer (SLB) instance is deployed.
 * You can call the [DescribeRegions](~~27584~~) operation to query region IDs.
 *
 * @param request DeleteRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRulesResponse
 */
func (client *Client) DeleteRulesWithOptions(request *DeleteRulesRequest, runtime *util.RuntimeOptions) (_result *DeleteRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleIds)) {
		query["RuleIds"] = request.RuleIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteRules"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the region where the Server Load Balancer (SLB) instance is deployed.
 * You can call the [DescribeRegions](~~27584~~) operation to query region IDs.
 *
 * @param request DeleteRulesRequest
 * @return DeleteRulesResponse
 */
func (client *Client) DeleteRules(request *DeleteRulesRequest) (_result *DeleteRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteRulesResponse{}
	_body, _err := client.DeleteRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The region where the Server Load Balancer (SLB) instance is created.
 * You can call the [DescribeRegions](~~27584~~) operation to query region IDs.
 *
 * @param request DeleteServerCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteServerCertificateResponse
 */
func (client *Client) DeleteServerCertificateWithOptions(request *DeleteServerCertificateRequest, runtime *util.RuntimeOptions) (_result *DeleteServerCertificateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ServerCertificateId)) {
		query["ServerCertificateId"] = request.ServerCertificateId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteServerCertificate"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteServerCertificateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The region where the Server Load Balancer (SLB) instance is created.
 * You can call the [DescribeRegions](~~27584~~) operation to query region IDs.
 *
 * @param request DeleteServerCertificateRequest
 * @return DeleteServerCertificateResponse
 */
func (client *Client) DeleteServerCertificate(request *DeleteServerCertificateRequest) (_result *DeleteServerCertificateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteServerCertificateResponse{}
	_body, _err := client.DeleteServerCertificateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteTLSCipherPolicyWithOptions(request *DeleteTLSCipherPolicyRequest, runtime *util.RuntimeOptions) (_result *DeleteTLSCipherPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TLSCipherPolicyId)) {
		query["TLSCipherPolicyId"] = request.TLSCipherPolicyId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteTLSCipherPolicy"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteTLSCipherPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteTLSCipherPolicy(request *DeleteTLSCipherPolicyRequest) (_result *DeleteTLSCipherPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteTLSCipherPolicyResponse{}
	_body, _err := client.DeleteTLSCipherPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteVServerGroupWithOptions(request *DeleteVServerGroupRequest, runtime *util.RuntimeOptions) (_result *DeleteVServerGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroupId)) {
		query["VServerGroupId"] = request.VServerGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteVServerGroup"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteVServerGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteVServerGroup(request *DeleteVServerGroupRequest) (_result *DeleteVServerGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteVServerGroupResponse{}
	_body, _err := client.DeleteVServerGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeAccessControlListAttributeWithOptions(request *DescribeAccessControlListAttributeRequest, runtime *util.RuntimeOptions) (_result *DescribeAccessControlListAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclEntryComment)) {
		query["AclEntryComment"] = request.AclEntryComment
	}

	if !tea.BoolValue(util.IsUnset(request.AclId)) {
		query["AclId"] = request.AclId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["Page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeAccessControlListAttribute"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeAccessControlListAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeAccessControlListAttribute(request *DescribeAccessControlListAttributeRequest) (_result *DescribeAccessControlListAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeAccessControlListAttributeResponse{}
	_body, _err := client.DescribeAccessControlListAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeAccessControlListsWithOptions(request *DescribeAccessControlListsRequest, runtime *util.RuntimeOptions) (_result *DescribeAccessControlListsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclName)) {
		query["AclName"] = request.AclName
	}

	if !tea.BoolValue(util.IsUnset(request.AddressIPVersion)) {
		query["AddressIPVersion"] = request.AddressIPVersion
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeAccessControlLists"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeAccessControlListsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeAccessControlLists(request *DescribeAccessControlListsRequest) (_result *DescribeAccessControlListsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeAccessControlListsResponse{}
	_body, _err := client.DescribeAccessControlListsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeAccessLogsDownloadAttributeWithOptions(request *DescribeAccessLogsDownloadAttributeRequest, runtime *util.RuntimeOptions) (_result *DescribeAccessLogsDownloadAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.LogType)) {
		query["LogType"] = request.LogType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeAccessLogsDownloadAttribute"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeAccessLogsDownloadAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeAccessLogsDownloadAttribute(request *DescribeAccessLogsDownloadAttributeRequest) (_result *DescribeAccessLogsDownloadAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeAccessLogsDownloadAttributeResponse{}
	_body, _err := client.DescribeAccessLogsDownloadAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the region.
 *
 * @param request DescribeAvailableResourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAvailableResourceResponse
 */
func (client *Client) DescribeAvailableResourceWithOptions(request *DescribeAvailableResourceRequest, runtime *util.RuntimeOptions) (_result *DescribeAvailableResourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AddressIPVersion)) {
		query["AddressIPVersion"] = request.AddressIPVersion
	}

	if !tea.BoolValue(util.IsUnset(request.AddressType)) {
		query["AddressType"] = request.AddressType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeAvailableResource"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeAvailableResourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the region.
 *
 * @param request DescribeAvailableResourceRequest
 * @return DescribeAvailableResourceResponse
 */
func (client *Client) DescribeAvailableResource(request *DescribeAvailableResourceRequest) (_result *DescribeAvailableResourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeAvailableResourceResponse{}
	_body, _err := client.DescribeAvailableResourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The time when the CA certificate was created. The time is in the `YYYY-MM-DDThh:mm:ssZ` format.
 *
 * @param request DescribeCACertificatesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCACertificatesResponse
 */
func (client *Client) DescribeCACertificatesWithOptions(request *DescribeCACertificatesRequest, runtime *util.RuntimeOptions) (_result *DescribeCACertificatesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CACertificateId)) {
		query["CACertificateId"] = request.CACertificateId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCACertificates"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCACertificatesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The time when the CA certificate was created. The time is in the `YYYY-MM-DDThh:mm:ssZ` format.
 *
 * @param request DescribeCACertificatesRequest
 * @return DescribeCACertificatesResponse
 */
func (client *Client) DescribeCACertificates(request *DescribeCACertificatesRequest) (_result *DescribeCACertificatesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCACertificatesResponse{}
	_body, _err := client.DescribeCACertificatesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDomainExtensionAttributeWithOptions(request *DescribeDomainExtensionAttributeRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainExtensionAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainExtensionId)) {
		query["DomainExtensionId"] = request.DomainExtensionId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainExtensionAttribute"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainExtensionAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDomainExtensionAttribute(request *DescribeDomainExtensionAttributeRequest) (_result *DescribeDomainExtensionAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainExtensionAttributeResponse{}
	_body, _err := client.DescribeDomainExtensionAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeDomainExtensionsWithOptions(request *DescribeDomainExtensionsRequest, runtime *util.RuntimeOptions) (_result *DescribeDomainExtensionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainExtensionId)) {
		query["DomainExtensionId"] = request.DomainExtensionId
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerPort)) {
		query["ListenerPort"] = request.ListenerPort
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeDomainExtensions"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeDomainExtensionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeDomainExtensions(request *DescribeDomainExtensionsRequest) (_result *DescribeDomainExtensionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeDomainExtensionsResponse{}
	_body, _err := client.DescribeDomainExtensionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeHealthStatusWithOptions(request *DescribeHealthStatusRequest, runtime *util.RuntimeOptions) (_result *DescribeHealthStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ListenerPort)) {
		query["ListenerPort"] = request.ListenerPort
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerProtocol)) {
		query["ListenerProtocol"] = request.ListenerProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeHealthStatus"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeHealthStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeHealthStatus(request *DescribeHealthStatusRequest) (_result *DescribeHealthStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeHealthStatusResponse{}
	_body, _err := client.DescribeHealthStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeHighDefinationMonitorWithOptions(request *DescribeHighDefinationMonitorRequest, runtime *util.RuntimeOptions) (_result *DescribeHighDefinationMonitorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeHighDefinationMonitor"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeHighDefinationMonitorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeHighDefinationMonitor(request *DescribeHighDefinationMonitorRequest) (_result *DescribeHighDefinationMonitorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeHighDefinationMonitorResponse{}
	_body, _err := client.DescribeHighDefinationMonitorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeListenerAccessControlAttributeWithOptions(request *DescribeListenerAccessControlAttributeRequest, runtime *util.RuntimeOptions) (_result *DescribeListenerAccessControlAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ListenerPort)) {
		query["ListenerPort"] = request.ListenerPort
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerProtocol)) {
		query["ListenerProtocol"] = request.ListenerProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeListenerAccessControlAttribute"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeListenerAccessControlAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeListenerAccessControlAttribute(request *DescribeListenerAccessControlAttributeRequest) (_result *DescribeListenerAccessControlAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeListenerAccessControlAttributeResponse{}
	_body, _err := client.DescribeListenerAccessControlAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The metering method of the CLB instance. Valid values:
 * *   **PayBySpec:** pay-by-specification.
 * *   **PayByCLCU:** pay-by-LCU.
 *
 * @param request DescribeLoadBalancerAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLoadBalancerAttributeResponse
 */
func (client *Client) DescribeLoadBalancerAttributeWithOptions(request *DescribeLoadBalancerAttributeRequest, runtime *util.RuntimeOptions) (_result *DescribeLoadBalancerAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeLoadBalancerAttribute"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeLoadBalancerAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The metering method of the CLB instance. Valid values:
 * *   **PayBySpec:** pay-by-specification.
 * *   **PayByCLCU:** pay-by-LCU.
 *
 * @param request DescribeLoadBalancerAttributeRequest
 * @return DescribeLoadBalancerAttributeResponse
 */
func (client *Client) DescribeLoadBalancerAttribute(request *DescribeLoadBalancerAttributeRequest) (_result *DescribeLoadBalancerAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeLoadBalancerAttributeResponse{}
	_body, _err := client.DescribeLoadBalancerAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The HTTP status codes that are used to determine whether the backend server passes the health check.
 *
 * @param request DescribeLoadBalancerHTTPListenerAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLoadBalancerHTTPListenerAttributeResponse
 */
func (client *Client) DescribeLoadBalancerHTTPListenerAttributeWithOptions(request *DescribeLoadBalancerHTTPListenerAttributeRequest, runtime *util.RuntimeOptions) (_result *DescribeLoadBalancerHTTPListenerAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ListenerPort)) {
		query["ListenerPort"] = request.ListenerPort
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeLoadBalancerHTTPListenerAttribute"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeLoadBalancerHTTPListenerAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The HTTP status codes that are used to determine whether the backend server passes the health check.
 *
 * @param request DescribeLoadBalancerHTTPListenerAttributeRequest
 * @return DescribeLoadBalancerHTTPListenerAttributeResponse
 */
func (client *Client) DescribeLoadBalancerHTTPListenerAttribute(request *DescribeLoadBalancerHTTPListenerAttributeRequest) (_result *DescribeLoadBalancerHTTPListenerAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeLoadBalancerHTTPListenerAttributeResponse{}
	_body, _err := client.DescribeLoadBalancerHTTPListenerAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Indicates whether the `XForwardedFor_ClientCertClientVerify` header is used to retrieve the verification result of the client certificate. Valid values:
 * *   **on**: yes
 * *   **off**: no
 *
 * @param request DescribeLoadBalancerHTTPSListenerAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLoadBalancerHTTPSListenerAttributeResponse
 */
func (client *Client) DescribeLoadBalancerHTTPSListenerAttributeWithOptions(request *DescribeLoadBalancerHTTPSListenerAttributeRequest, runtime *util.RuntimeOptions) (_result *DescribeLoadBalancerHTTPSListenerAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ListenerPort)) {
		query["ListenerPort"] = request.ListenerPort
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeLoadBalancerHTTPSListenerAttribute"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeLoadBalancerHTTPSListenerAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Indicates whether the `XForwardedFor_ClientCertClientVerify` header is used to retrieve the verification result of the client certificate. Valid values:
 * *   **on**: yes
 * *   **off**: no
 *
 * @param request DescribeLoadBalancerHTTPSListenerAttributeRequest
 * @return DescribeLoadBalancerHTTPSListenerAttributeResponse
 */
func (client *Client) DescribeLoadBalancerHTTPSListenerAttribute(request *DescribeLoadBalancerHTTPSListenerAttributeRequest) (_result *DescribeLoadBalancerHTTPSListenerAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeLoadBalancerHTTPSListenerAttributeResponse{}
	_body, _err := client.DescribeLoadBalancerHTTPSListenerAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Indicates whether the Proxy protocol is used to pass client IP addresses to backend servers. Valid values:
 * *   **true**: yes
 * *   **false**: no
 *
 * @param request DescribeLoadBalancerListenersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLoadBalancerListenersResponse
 */
func (client *Client) DescribeLoadBalancerListenersWithOptions(request *DescribeLoadBalancerListenersRequest, runtime *util.RuntimeOptions) (_result *DescribeLoadBalancerListenersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ListenerProtocol)) {
		query["ListenerProtocol"] = request.ListenerProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeLoadBalancerListeners"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeLoadBalancerListenersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Indicates whether the Proxy protocol is used to pass client IP addresses to backend servers. Valid values:
 * *   **true**: yes
 * *   **false**: no
 *
 * @param request DescribeLoadBalancerListenersRequest
 * @return DescribeLoadBalancerListenersResponse
 */
func (client *Client) DescribeLoadBalancerListeners(request *DescribeLoadBalancerListenersRequest) (_result *DescribeLoadBalancerListenersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeLoadBalancerListenersResponse{}
	_body, _err := client.DescribeLoadBalancerListenersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeLoadBalancerTCPListenerAttributeWithOptions(request *DescribeLoadBalancerTCPListenerAttributeRequest, runtime *util.RuntimeOptions) (_result *DescribeLoadBalancerTCPListenerAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ListenerPort)) {
		query["ListenerPort"] = request.ListenerPort
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeLoadBalancerTCPListenerAttribute"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeLoadBalancerTCPListenerAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeLoadBalancerTCPListenerAttribute(request *DescribeLoadBalancerTCPListenerAttributeRequest) (_result *DescribeLoadBalancerTCPListenerAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeLoadBalancerTCPListenerAttributeResponse{}
	_body, _err := client.DescribeLoadBalancerTCPListenerAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeLoadBalancerUDPListenerAttributeWithOptions(request *DescribeLoadBalancerUDPListenerAttributeRequest, runtime *util.RuntimeOptions) (_result *DescribeLoadBalancerUDPListenerAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ListenerPort)) {
		query["ListenerPort"] = request.ListenerPort
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeLoadBalancerUDPListenerAttribute"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeLoadBalancerUDPListenerAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeLoadBalancerUDPListenerAttribute(request *DescribeLoadBalancerUDPListenerAttributeRequest) (_result *DescribeLoadBalancerUDPListenerAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeLoadBalancerUDPListenerAttributeResponse{}
	_body, _err := client.DescribeLoadBalancerUDPListenerAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeLoadBalancersWithOptions(request *DescribeLoadBalancersRequest, runtime *util.RuntimeOptions) (_result *DescribeLoadBalancersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Address)) {
		query["Address"] = request.Address
	}

	if !tea.BoolValue(util.IsUnset(request.AddressIPVersion)) {
		query["AddressIPVersion"] = request.AddressIPVersion
	}

	if !tea.BoolValue(util.IsUnset(request.AddressType)) {
		query["AddressType"] = request.AddressType
	}

	if !tea.BoolValue(util.IsUnset(request.InternetChargeType)) {
		query["InternetChargeType"] = request.InternetChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerName)) {
		query["LoadBalancerName"] = request.LoadBalancerName
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerStatus)) {
		query["LoadBalancerStatus"] = request.LoadBalancerStatus
	}

	if !tea.BoolValue(util.IsUnset(request.MasterZoneId)) {
		query["MasterZoneId"] = request.MasterZoneId
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkType)) {
		query["NetworkType"] = request.NetworkType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.PayType)) {
		query["PayType"] = request.PayType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ServerId)) {
		query["ServerId"] = request.ServerId
	}

	if !tea.BoolValue(util.IsUnset(request.ServerIntranetAddress)) {
		query["ServerIntranetAddress"] = request.ServerIntranetAddress
	}

	if !tea.BoolValue(util.IsUnset(request.SlaveZoneId)) {
		query["SlaveZoneId"] = request.SlaveZoneId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeLoadBalancers"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeLoadBalancersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeLoadBalancers(request *DescribeLoadBalancersRequest) (_result *DescribeLoadBalancersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeLoadBalancersResponse{}
	_body, _err := client.DescribeLoadBalancersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeMasterSlaveServerGroupAttributeWithOptions(request *DescribeMasterSlaveServerGroupAttributeRequest, runtime *util.RuntimeOptions) (_result *DescribeMasterSlaveServerGroupAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MasterSlaveServerGroupId)) {
		query["MasterSlaveServerGroupId"] = request.MasterSlaveServerGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeMasterSlaveServerGroupAttribute"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeMasterSlaveServerGroupAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeMasterSlaveServerGroupAttribute(request *DescribeMasterSlaveServerGroupAttributeRequest) (_result *DescribeMasterSlaveServerGroupAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeMasterSlaveServerGroupAttributeResponse{}
	_body, _err := client.DescribeMasterSlaveServerGroupAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeMasterSlaveServerGroupsWithOptions(request *DescribeMasterSlaveServerGroupsRequest, runtime *util.RuntimeOptions) (_result *DescribeMasterSlaveServerGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IncludeListener)) {
		query["IncludeListener"] = request.IncludeListener
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeMasterSlaveServerGroups"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeMasterSlaveServerGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeMasterSlaveServerGroups(request *DescribeMasterSlaveServerGroupsRequest) (_result *DescribeMasterSlaveServerGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeMasterSlaveServerGroupsResponse{}
	_body, _err := client.DescribeMasterSlaveServerGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeRegionsWithOptions(request *DescribeRegionsRequest, runtime *util.RuntimeOptions) (_result *DescribeRegionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRegions"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRegionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeRegions(request *DescribeRegionsRequest) (_result *DescribeRegionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRegionsResponse{}
	_body, _err := client.DescribeRegionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeRuleAttributeWithOptions(request *DescribeRuleAttributeRequest, runtime *util.RuntimeOptions) (_result *DescribeRuleAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleId)) {
		query["RuleId"] = request.RuleId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRuleAttribute"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRuleAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeRuleAttribute(request *DescribeRuleAttributeRequest) (_result *DescribeRuleAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRuleAttributeResponse{}
	_body, _err := client.DescribeRuleAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeRulesWithOptions(request *DescribeRulesRequest, runtime *util.RuntimeOptions) (_result *DescribeRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ListenerPort)) {
		query["ListenerPort"] = request.ListenerPort
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerProtocol)) {
		query["ListenerProtocol"] = request.ListenerProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRules"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeRules(request *DescribeRulesRequest) (_result *DescribeRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRulesResponse{}
	_body, _err := client.DescribeRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The name of the server certificate.
 *
 * @param request DescribeServerCertificatesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeServerCertificatesResponse
 */
func (client *Client) DescribeServerCertificatesWithOptions(request *DescribeServerCertificatesRequest, runtime *util.RuntimeOptions) (_result *DescribeServerCertificatesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ServerCertificateId)) {
		query["ServerCertificateId"] = request.ServerCertificateId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeServerCertificates"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeServerCertificatesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The name of the server certificate.
 *
 * @param request DescribeServerCertificatesRequest
 * @return DescribeServerCertificatesResponse
 */
func (client *Client) DescribeServerCertificates(request *DescribeServerCertificatesRequest) (_result *DescribeServerCertificatesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeServerCertificatesResponse{}
	_body, _err := client.DescribeServerCertificatesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you call this operation, take note of the following items:
 * *   You can query tags by instance ID, tag key, and tag value. If the operation is successful, the system returns all tags that match the specified conditions.
 * *   The logical relationship among the specified conditions is AND. Only tags that match all the specified conditions are returned.
 * *   If the Tagkey parameter is set and the Tagvalue parameter is not set, all tags that contain the specified tag key are returned.
 * *   If you set the Tagvalue parameter in a request, you must also set the Tagkey parameter in the request.
 * *   If you set both the Tagkey and Tagvalue parameters, only tags that contain the specified keys and values are returned.
 *
 * @param request DescribeTagsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTagsResponse
 */
func (client *Client) DescribeTagsWithOptions(request *DescribeTagsRequest, runtime *util.RuntimeOptions) (_result *DescribeTagsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DistinctKey)) {
		query["DistinctKey"] = request.DistinctKey
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeTags"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeTagsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you call this operation, take note of the following items:
 * *   You can query tags by instance ID, tag key, and tag value. If the operation is successful, the system returns all tags that match the specified conditions.
 * *   The logical relationship among the specified conditions is AND. Only tags that match all the specified conditions are returned.
 * *   If the Tagkey parameter is set and the Tagvalue parameter is not set, all tags that contain the specified tag key are returned.
 * *   If you set the Tagvalue parameter in a request, you must also set the Tagkey parameter in the request.
 * *   If you set both the Tagkey and Tagvalue parameters, only tags that contain the specified keys and values are returned.
 *
 * @param request DescribeTagsRequest
 * @return DescribeTagsResponse
 */
func (client *Client) DescribeTags(request *DescribeTagsRequest) (_result *DescribeTagsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeTagsResponse{}
	_body, _err := client.DescribeTagsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeVServerGroupAttributeWithOptions(request *DescribeVServerGroupAttributeRequest, runtime *util.RuntimeOptions) (_result *DescribeVServerGroupAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroupId)) {
		query["VServerGroupId"] = request.VServerGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVServerGroupAttribute"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVServerGroupAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeVServerGroupAttribute(request *DescribeVServerGroupAttributeRequest) (_result *DescribeVServerGroupAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVServerGroupAttributeResponse{}
	_body, _err := client.DescribeVServerGroupAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeVServerGroupsWithOptions(request *DescribeVServerGroupsRequest, runtime *util.RuntimeOptions) (_result *DescribeVServerGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IncludeListener)) {
		query["IncludeListener"] = request.IncludeListener
	}

	if !tea.BoolValue(util.IsUnset(request.IncludeRule)) {
		query["IncludeRule"] = request.IncludeRule
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVServerGroups"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVServerGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeVServerGroups(request *DescribeVServerGroupsRequest) (_result *DescribeVServerGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVServerGroupsResponse{}
	_body, _err := client.DescribeVServerGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeZonesWithOptions(request *DescribeZonesRequest, runtime *util.RuntimeOptions) (_result *DescribeZonesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeZones"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeZonesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeZones(request *DescribeZonesRequest) (_result *DescribeZonesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeZonesResponse{}
	_body, _err := client.DescribeZonesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) EnableHighDefinationMonitorWithOptions(request *EnableHighDefinationMonitorRequest, runtime *util.RuntimeOptions) (_result *EnableHighDefinationMonitorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LogProject)) {
		query["LogProject"] = request.LogProject
	}

	if !tea.BoolValue(util.IsUnset(request.LogStore)) {
		query["LogStore"] = request.LogStore
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EnableHighDefinationMonitor"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EnableHighDefinationMonitorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) EnableHighDefinationMonitor(request *EnableHighDefinationMonitorRequest) (_result *EnableHighDefinationMonitorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EnableHighDefinationMonitorResponse{}
	_body, _err := client.EnableHighDefinationMonitorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTLSCipherPoliciesWithOptions(request *ListTLSCipherPoliciesRequest, runtime *util.RuntimeOptions) (_result *ListTLSCipherPoliciesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IncludeListener)) {
		query["IncludeListener"] = request.IncludeListener
	}

	if !tea.BoolValue(util.IsUnset(request.MaxItems)) {
		query["MaxItems"] = request.MaxItems
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TLSCipherPolicyId)) {
		query["TLSCipherPolicyId"] = request.TLSCipherPolicyId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTLSCipherPolicies"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTLSCipherPoliciesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTLSCipherPolicies(request *ListTLSCipherPoliciesRequest) (_result *ListTLSCipherPoliciesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTLSCipherPoliciesResponse{}
	_body, _err := client.ListTLSCipherPoliciesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   Set **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object to be queried.
 * *   **Tag.N** is a resource tag that consists of a key-value pair. If you set only **Tag.N.Key**, all tag values that are associated with the specified tag key are returned. If you set only **Tag.N.Value**, an error message is returned.
 * *   If you set **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
 * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
 *
 * @param request ListTagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTagResourcesResponse
 */
func (client *Client) ListTagResourcesWithOptions(request *ListTagResourcesRequest, runtime *util.RuntimeOptions) (_result *ListTagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTagResources"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   Set **ResourceId.N** or **Tag.N** that consists of **Tag.N.Key** and **Tag.N.Value** in the request to specify the object to be queried.
 * *   **Tag.N** is a resource tag that consists of a key-value pair. If you set only **Tag.N.Key**, all tag values that are associated with the specified tag key are returned. If you set only **Tag.N.Value**, an error message is returned.
 * *   If you set **Tag.N** and **ResourceId.N** to filter tags, **ResourceId.N** must match all specified key-value pairs.
 * *   If you specify multiple key-value pairs, resources that contain these key-value pairs are returned.
 *
 * @param request ListTagResourcesRequest
 * @return ListTagResourcesResponse
 */
func (client *Client) ListTagResources(request *ListTagResourcesRequest) (_result *ListTagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTagResourcesResponse{}
	_body, _err := client.ListTagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyHighDefinationMonitorWithOptions(request *ModifyHighDefinationMonitorRequest, runtime *util.RuntimeOptions) (_result *ModifyHighDefinationMonitorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LogProject)) {
		query["LogProject"] = request.LogProject
	}

	if !tea.BoolValue(util.IsUnset(request.LogStore)) {
		query["LogStore"] = request.LogStore
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyHighDefinationMonitor"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyHighDefinationMonitorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyHighDefinationMonitor(request *ModifyHighDefinationMonitorRequest) (_result *ModifyHighDefinationMonitorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyHighDefinationMonitorResponse{}
	_body, _err := client.ModifyHighDefinationMonitorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the CLB instance.
 *
 * @param request ModifyLoadBalancerInstanceChargeTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyLoadBalancerInstanceChargeTypeResponse
 */
func (client *Client) ModifyLoadBalancerInstanceChargeTypeWithOptions(request *ModifyLoadBalancerInstanceChargeTypeRequest, runtime *util.RuntimeOptions) (_result *ModifyLoadBalancerInstanceChargeTypeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceChargeType)) {
		query["InstanceChargeType"] = request.InstanceChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.InternetChargeType)) {
		query["InternetChargeType"] = request.InternetChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerSpec)) {
		query["LoadBalancerSpec"] = request.LoadBalancerSpec
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyLoadBalancerInstanceChargeType"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyLoadBalancerInstanceChargeTypeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the CLB instance.
 *
 * @param request ModifyLoadBalancerInstanceChargeTypeRequest
 * @return ModifyLoadBalancerInstanceChargeTypeResponse
 */
func (client *Client) ModifyLoadBalancerInstanceChargeType(request *ModifyLoadBalancerInstanceChargeTypeRequest) (_result *ModifyLoadBalancerInstanceChargeTypeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyLoadBalancerInstanceChargeTypeResponse{}
	_body, _err := client.ModifyLoadBalancerInstanceChargeTypeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyLoadBalancerInstanceSpecWithOptions(request *ModifyLoadBalancerInstanceSpecRequest, runtime *util.RuntimeOptions) (_result *ModifyLoadBalancerInstanceSpecResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerSpec)) {
		query["LoadBalancerSpec"] = request.LoadBalancerSpec
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyLoadBalancerInstanceSpec"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyLoadBalancerInstanceSpecResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyLoadBalancerInstanceSpec(request *ModifyLoadBalancerInstanceSpecRequest) (_result *ModifyLoadBalancerInstanceSpecResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyLoadBalancerInstanceSpecResponse{}
	_body, _err := client.ModifyLoadBalancerInstanceSpecWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the CLB instance.
 *
 * @param request ModifyLoadBalancerInternetSpecRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyLoadBalancerInternetSpecResponse
 */
func (client *Client) ModifyLoadBalancerInternetSpecWithOptions(request *ModifyLoadBalancerInternetSpecRequest, runtime *util.RuntimeOptions) (_result *ModifyLoadBalancerInternetSpecResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.InternetChargeType)) {
		query["InternetChargeType"] = request.InternetChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyLoadBalancerInternetSpec"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyLoadBalancerInternetSpecResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the CLB instance.
 *
 * @param request ModifyLoadBalancerInternetSpecRequest
 * @return ModifyLoadBalancerInternetSpecResponse
 */
func (client *Client) ModifyLoadBalancerInternetSpec(request *ModifyLoadBalancerInternetSpecRequest) (_result *ModifyLoadBalancerInternetSpecResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyLoadBalancerInternetSpecResponse{}
	_body, _err := client.ModifyLoadBalancerInternetSpecWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyLoadBalancerPayTypeWithOptions(request *ModifyLoadBalancerPayTypeRequest, runtime *util.RuntimeOptions) (_result *ModifyLoadBalancerPayTypeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.Duration)) {
		query["Duration"] = request.Duration
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PayType)) {
		query["PayType"] = request.PayType
	}

	if !tea.BoolValue(util.IsUnset(request.PricingCycle)) {
		query["PricingCycle"] = request.PricingCycle
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyLoadBalancerPayType"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyLoadBalancerPayTypeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyLoadBalancerPayType(request *ModifyLoadBalancerPayTypeRequest) (_result *ModifyLoadBalancerPayTypeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyLoadBalancerPayTypeResponse{}
	_body, _err := client.ModifyLoadBalancerPayTypeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the region where the Classic Load Balancer (CLB) instance is deployed.
 *
 * @param request ModifyVServerGroupBackendServersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyVServerGroupBackendServersResponse
 */
func (client *Client) ModifyVServerGroupBackendServersWithOptions(request *ModifyVServerGroupBackendServersRequest, runtime *util.RuntimeOptions) (_result *ModifyVServerGroupBackendServersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NewBackendServers)) {
		query["NewBackendServers"] = request.NewBackendServers
	}

	if !tea.BoolValue(util.IsUnset(request.OldBackendServers)) {
		query["OldBackendServers"] = request.OldBackendServers
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroupId)) {
		query["VServerGroupId"] = request.VServerGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyVServerGroupBackendServers"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyVServerGroupBackendServersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the region where the Classic Load Balancer (CLB) instance is deployed.
 *
 * @param request ModifyVServerGroupBackendServersRequest
 * @return ModifyVServerGroupBackendServersResponse
 */
func (client *Client) ModifyVServerGroupBackendServers(request *ModifyVServerGroupBackendServersRequest) (_result *ModifyVServerGroupBackendServersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyVServerGroupBackendServersResponse{}
	_body, _err := client.ModifyVServerGroupBackendServersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) MoveResourceGroupWithOptions(request *MoveResourceGroupRequest, runtime *util.RuntimeOptions) (_result *MoveResourceGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NewResourceGroupId)) {
		query["NewResourceGroupId"] = request.NewResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.AccessKeyId)) {
		query["access_key_id"] = request.AccessKeyId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("MoveResourceGroup"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &MoveResourceGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) MoveResourceGroup(request *MoveResourceGroupRequest) (_result *MoveResourceGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &MoveResourceGroupResponse{}
	_body, _err := client.MoveResourceGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RemoveAccessControlListEntryWithOptions(request *RemoveAccessControlListEntryRequest, runtime *util.RuntimeOptions) (_result *RemoveAccessControlListEntryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclEntrys)) {
		query["AclEntrys"] = request.AclEntrys
	}

	if !tea.BoolValue(util.IsUnset(request.AclId)) {
		query["AclId"] = request.AclId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RemoveAccessControlListEntry"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RemoveAccessControlListEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RemoveAccessControlListEntry(request *RemoveAccessControlListEntryRequest) (_result *RemoveAccessControlListEntryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RemoveAccessControlListEntryResponse{}
	_body, _err := client.RemoveAccessControlListEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The operation that you want to perform.
 * Set the value to **RemoveBackendServers**.
 *
 * @param request RemoveBackendServersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveBackendServersResponse
 */
func (client *Client) RemoveBackendServersWithOptions(request *RemoveBackendServersRequest, runtime *util.RuntimeOptions) (_result *RemoveBackendServersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackendServers)) {
		query["BackendServers"] = request.BackendServers
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RemoveBackendServers"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RemoveBackendServersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The operation that you want to perform.
 * Set the value to **RemoveBackendServers**.
 *
 * @param request RemoveBackendServersRequest
 * @return RemoveBackendServersResponse
 */
func (client *Client) RemoveBackendServers(request *RemoveBackendServersRequest) (_result *RemoveBackendServersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RemoveBackendServersResponse{}
	_body, _err := client.RemoveBackendServersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RemoveListenerWhiteListItemWithOptions(request *RemoveListenerWhiteListItemRequest, runtime *util.RuntimeOptions) (_result *RemoveListenerWhiteListItemResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ListenerPort)) {
		query["ListenerPort"] = request.ListenerPort
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerProtocol)) {
		query["ListenerProtocol"] = request.ListenerProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SourceItems)) {
		query["SourceItems"] = request.SourceItems
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RemoveListenerWhiteListItem"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RemoveListenerWhiteListItemResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RemoveListenerWhiteListItem(request *RemoveListenerWhiteListItemRequest) (_result *RemoveListenerWhiteListItemResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RemoveListenerWhiteListItemResponse{}
	_body, _err := client.RemoveListenerWhiteListItemWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RemoveTagsWithOptions(request *RemoveTagsRequest, runtime *util.RuntimeOptions) (_result *RemoveTagsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RemoveTags"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RemoveTagsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RemoveTags(request *RemoveTagsRequest) (_result *RemoveTagsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RemoveTagsResponse{}
	_body, _err := client.RemoveTagsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the region where the Classic Load Balancer (CLB) instance is deployed.
 *
 * @param request RemoveVServerGroupBackendServersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveVServerGroupBackendServersResponse
 */
func (client *Client) RemoveVServerGroupBackendServersWithOptions(request *RemoveVServerGroupBackendServersRequest, runtime *util.RuntimeOptions) (_result *RemoveVServerGroupBackendServersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackendServers)) {
		query["BackendServers"] = request.BackendServers
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroupId)) {
		query["VServerGroupId"] = request.VServerGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RemoveVServerGroupBackendServers"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RemoveVServerGroupBackendServersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the region where the Classic Load Balancer (CLB) instance is deployed.
 *
 * @param request RemoveVServerGroupBackendServersRequest
 * @return RemoveVServerGroupBackendServersResponse
 */
func (client *Client) RemoveVServerGroupBackendServers(request *RemoveVServerGroupBackendServersRequest) (_result *RemoveVServerGroupBackendServersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RemoveVServerGroupBackendServersResponse{}
	_body, _err := client.RemoveVServerGroupBackendServersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetAccessControlListAttributeWithOptions(request *SetAccessControlListAttributeRequest, runtime *util.RuntimeOptions) (_result *SetAccessControlListAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclId)) {
		query["AclId"] = request.AclId
	}

	if !tea.BoolValue(util.IsUnset(request.AclName)) {
		query["AclName"] = request.AclName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetAccessControlListAttribute"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetAccessControlListAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetAccessControlListAttribute(request *SetAccessControlListAttributeRequest) (_result *SetAccessControlListAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetAccessControlListAttributeResponse{}
	_body, _err := client.SetAccessControlListAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetAccessLogsDownloadAttributeWithOptions(request *SetAccessLogsDownloadAttributeRequest, runtime *util.RuntimeOptions) (_result *SetAccessLogsDownloadAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.LogsDownloadAttributes)) {
		query["LogsDownloadAttributes"] = request.LogsDownloadAttributes
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetAccessLogsDownloadAttribute"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetAccessLogsDownloadAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetAccessLogsDownloadAttribute(request *SetAccessLogsDownloadAttributeRequest) (_result *SetAccessLogsDownloadAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetAccessLogsDownloadAttributeResponse{}
	_body, _err := client.SetAccessLogsDownloadAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetBackendServersWithOptions(request *SetBackendServersRequest, runtime *util.RuntimeOptions) (_result *SetBackendServersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackendServers)) {
		query["BackendServers"] = request.BackendServers
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetBackendServers"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetBackendServersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetBackendServers(request *SetBackendServersRequest) (_result *SetBackendServersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetBackendServersResponse{}
	_body, _err := client.SetBackendServersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetCACertificateNameWithOptions(request *SetCACertificateNameRequest, runtime *util.RuntimeOptions) (_result *SetCACertificateNameResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CACertificateId)) {
		query["CACertificateId"] = request.CACertificateId
	}

	if !tea.BoolValue(util.IsUnset(request.CACertificateName)) {
		query["CACertificateName"] = request.CACertificateName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetCACertificateName"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetCACertificateNameResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetCACertificateName(request *SetCACertificateNameRequest) (_result *SetCACertificateNameResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetCACertificateNameResponse{}
	_body, _err := client.SetCACertificateNameWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the region where the SLB instance is created.
 *
 * @param request SetDomainExtensionAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetDomainExtensionAttributeResponse
 */
func (client *Client) SetDomainExtensionAttributeWithOptions(request *SetDomainExtensionAttributeRequest, runtime *util.RuntimeOptions) (_result *SetDomainExtensionAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainExtensionId)) {
		query["DomainExtensionId"] = request.DomainExtensionId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ServerCertificateId)) {
		query["ServerCertificateId"] = request.ServerCertificateId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetDomainExtensionAttribute"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetDomainExtensionAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the region where the SLB instance is created.
 *
 * @param request SetDomainExtensionAttributeRequest
 * @return SetDomainExtensionAttributeResponse
 */
func (client *Client) SetDomainExtensionAttribute(request *SetDomainExtensionAttributeRequest) (_result *SetDomainExtensionAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetDomainExtensionAttributeResponse{}
	_body, _err := client.SetDomainExtensionAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetListenerAccessControlStatusWithOptions(request *SetListenerAccessControlStatusRequest, runtime *util.RuntimeOptions) (_result *SetListenerAccessControlStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccessControlStatus)) {
		query["AccessControlStatus"] = request.AccessControlStatus
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerPort)) {
		query["ListenerPort"] = request.ListenerPort
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerProtocol)) {
		query["ListenerProtocol"] = request.ListenerProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetListenerAccessControlStatus"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetListenerAccessControlStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetListenerAccessControlStatus(request *SetListenerAccessControlStatusRequest) (_result *SetListenerAccessControlStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetListenerAccessControlStatusResponse{}
	_body, _err := client.SetListenerAccessControlStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetLoadBalancerDeleteProtectionWithOptions(request *SetLoadBalancerDeleteProtectionRequest, runtime *util.RuntimeOptions) (_result *SetLoadBalancerDeleteProtectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeleteProtection)) {
		query["DeleteProtection"] = request.DeleteProtection
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetLoadBalancerDeleteProtection"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetLoadBalancerDeleteProtectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetLoadBalancerDeleteProtection(request *SetLoadBalancerDeleteProtectionRequest) (_result *SetLoadBalancerDeleteProtectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetLoadBalancerDeleteProtectionResponse{}
	_body, _err := client.SetLoadBalancerDeleteProtectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the region where the CLB instance is deployed.
 * You can query the region ID from the [Regions and zones](~~27585~~) list or by calling the [DescribeRegions](~~27584~~) operation.
 *
 * @param request SetLoadBalancerHTTPListenerAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetLoadBalancerHTTPListenerAttributeResponse
 */
func (client *Client) SetLoadBalancerHTTPListenerAttributeWithOptions(request *SetLoadBalancerHTTPListenerAttributeRequest, runtime *util.RuntimeOptions) (_result *SetLoadBalancerHTTPListenerAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclId)) {
		query["AclId"] = request.AclId
	}

	if !tea.BoolValue(util.IsUnset(request.AclStatus)) {
		query["AclStatus"] = request.AclStatus
	}

	if !tea.BoolValue(util.IsUnset(request.AclType)) {
		query["AclType"] = request.AclType
	}

	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.Cookie)) {
		query["Cookie"] = request.Cookie
	}

	if !tea.BoolValue(util.IsUnset(request.CookieTimeout)) {
		query["CookieTimeout"] = request.CookieTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Gzip)) {
		query["Gzip"] = request.Gzip
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheck)) {
		query["HealthCheck"] = request.HealthCheck
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckConnectPort)) {
		query["HealthCheckConnectPort"] = request.HealthCheckConnectPort
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckDomain)) {
		query["HealthCheckDomain"] = request.HealthCheckDomain
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckHttpCode)) {
		query["HealthCheckHttpCode"] = request.HealthCheckHttpCode
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckInterval)) {
		query["HealthCheckInterval"] = request.HealthCheckInterval
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckMethod)) {
		query["HealthCheckMethod"] = request.HealthCheckMethod
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckTimeout)) {
		query["HealthCheckTimeout"] = request.HealthCheckTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckURI)) {
		query["HealthCheckURI"] = request.HealthCheckURI
	}

	if !tea.BoolValue(util.IsUnset(request.HealthyThreshold)) {
		query["HealthyThreshold"] = request.HealthyThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.IdleTimeout)) {
		query["IdleTimeout"] = request.IdleTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerPort)) {
		query["ListenerPort"] = request.ListenerPort
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestTimeout)) {
		query["RequestTimeout"] = request.RequestTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Scheduler)) {
		query["Scheduler"] = request.Scheduler
	}

	if !tea.BoolValue(util.IsUnset(request.StickySession)) {
		query["StickySession"] = request.StickySession
	}

	if !tea.BoolValue(util.IsUnset(request.StickySessionType)) {
		query["StickySessionType"] = request.StickySessionType
	}

	if !tea.BoolValue(util.IsUnset(request.UnhealthyThreshold)) {
		query["UnhealthyThreshold"] = request.UnhealthyThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroup)) {
		query["VServerGroup"] = request.VServerGroup
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroupId)) {
		query["VServerGroupId"] = request.VServerGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.XForwardedFor)) {
		query["XForwardedFor"] = request.XForwardedFor
	}

	if !tea.BoolValue(util.IsUnset(request.XForwardedFor_SLBID)) {
		query["XForwardedFor_SLBID"] = request.XForwardedFor_SLBID
	}

	if !tea.BoolValue(util.IsUnset(request.XForwardedFor_SLBIP)) {
		query["XForwardedFor_SLBIP"] = request.XForwardedFor_SLBIP
	}

	if !tea.BoolValue(util.IsUnset(request.XForwardedFor_proto)) {
		query["XForwardedFor_proto"] = request.XForwardedFor_proto
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetLoadBalancerHTTPListenerAttribute"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetLoadBalancerHTTPListenerAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the region where the CLB instance is deployed.
 * You can query the region ID from the [Regions and zones](~~27585~~) list or by calling the [DescribeRegions](~~27584~~) operation.
 *
 * @param request SetLoadBalancerHTTPListenerAttributeRequest
 * @return SetLoadBalancerHTTPListenerAttributeResponse
 */
func (client *Client) SetLoadBalancerHTTPListenerAttribute(request *SetLoadBalancerHTTPListenerAttributeRequest) (_result *SetLoadBalancerHTTPListenerAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetLoadBalancerHTTPListenerAttributeResponse{}
	_body, _err := client.SetLoadBalancerHTTPListenerAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The operation that you want to perform.
 * Set the value to **SetLoadBalancerHTTPSListenerAttribute**.
 *
 * @param request SetLoadBalancerHTTPSListenerAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetLoadBalancerHTTPSListenerAttributeResponse
 */
func (client *Client) SetLoadBalancerHTTPSListenerAttributeWithOptions(request *SetLoadBalancerHTTPSListenerAttributeRequest, runtime *util.RuntimeOptions) (_result *SetLoadBalancerHTTPSListenerAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclId)) {
		query["AclId"] = request.AclId
	}

	if !tea.BoolValue(util.IsUnset(request.AclStatus)) {
		query["AclStatus"] = request.AclStatus
	}

	if !tea.BoolValue(util.IsUnset(request.AclType)) {
		query["AclType"] = request.AclType
	}

	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.CACertificateId)) {
		query["CACertificateId"] = request.CACertificateId
	}

	if !tea.BoolValue(util.IsUnset(request.Cookie)) {
		query["Cookie"] = request.Cookie
	}

	if !tea.BoolValue(util.IsUnset(request.CookieTimeout)) {
		query["CookieTimeout"] = request.CookieTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EnableHttp2)) {
		query["EnableHttp2"] = request.EnableHttp2
	}

	if !tea.BoolValue(util.IsUnset(request.Gzip)) {
		query["Gzip"] = request.Gzip
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheck)) {
		query["HealthCheck"] = request.HealthCheck
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckConnectPort)) {
		query["HealthCheckConnectPort"] = request.HealthCheckConnectPort
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckDomain)) {
		query["HealthCheckDomain"] = request.HealthCheckDomain
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckHttpCode)) {
		query["HealthCheckHttpCode"] = request.HealthCheckHttpCode
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckInterval)) {
		query["HealthCheckInterval"] = request.HealthCheckInterval
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckMethod)) {
		query["HealthCheckMethod"] = request.HealthCheckMethod
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckTimeout)) {
		query["HealthCheckTimeout"] = request.HealthCheckTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckURI)) {
		query["HealthCheckURI"] = request.HealthCheckURI
	}

	if !tea.BoolValue(util.IsUnset(request.HealthyThreshold)) {
		query["HealthyThreshold"] = request.HealthyThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.IdleTimeout)) {
		query["IdleTimeout"] = request.IdleTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerPort)) {
		query["ListenerPort"] = request.ListenerPort
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RequestTimeout)) {
		query["RequestTimeout"] = request.RequestTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Scheduler)) {
		query["Scheduler"] = request.Scheduler
	}

	if !tea.BoolValue(util.IsUnset(request.ServerCertificateId)) {
		query["ServerCertificateId"] = request.ServerCertificateId
	}

	if !tea.BoolValue(util.IsUnset(request.StickySession)) {
		query["StickySession"] = request.StickySession
	}

	if !tea.BoolValue(util.IsUnset(request.StickySessionType)) {
		query["StickySessionType"] = request.StickySessionType
	}

	if !tea.BoolValue(util.IsUnset(request.TLSCipherPolicy)) {
		query["TLSCipherPolicy"] = request.TLSCipherPolicy
	}

	if !tea.BoolValue(util.IsUnset(request.UnhealthyThreshold)) {
		query["UnhealthyThreshold"] = request.UnhealthyThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroup)) {
		query["VServerGroup"] = request.VServerGroup
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroupId)) {
		query["VServerGroupId"] = request.VServerGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.XForwardedFor)) {
		query["XForwardedFor"] = request.XForwardedFor
	}

	if !tea.BoolValue(util.IsUnset(request.XForwardedFor_SLBID)) {
		query["XForwardedFor_SLBID"] = request.XForwardedFor_SLBID
	}

	if !tea.BoolValue(util.IsUnset(request.XForwardedFor_SLBIP)) {
		query["XForwardedFor_SLBIP"] = request.XForwardedFor_SLBIP
	}

	if !tea.BoolValue(util.IsUnset(request.XForwardedFor_proto)) {
		query["XForwardedFor_proto"] = request.XForwardedFor_proto
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetLoadBalancerHTTPSListenerAttribute"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetLoadBalancerHTTPSListenerAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The operation that you want to perform.
 * Set the value to **SetLoadBalancerHTTPSListenerAttribute**.
 *
 * @param request SetLoadBalancerHTTPSListenerAttributeRequest
 * @return SetLoadBalancerHTTPSListenerAttributeResponse
 */
func (client *Client) SetLoadBalancerHTTPSListenerAttribute(request *SetLoadBalancerHTTPSListenerAttributeRequest) (_result *SetLoadBalancerHTTPSListenerAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetLoadBalancerHTTPSListenerAttributeResponse{}
	_body, _err := client.SetLoadBalancerHTTPSListenerAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetLoadBalancerModificationProtectionWithOptions(request *SetLoadBalancerModificationProtectionRequest, runtime *util.RuntimeOptions) (_result *SetLoadBalancerModificationProtectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.ModificationProtectionReason)) {
		query["ModificationProtectionReason"] = request.ModificationProtectionReason
	}

	if !tea.BoolValue(util.IsUnset(request.ModificationProtectionStatus)) {
		query["ModificationProtectionStatus"] = request.ModificationProtectionStatus
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetLoadBalancerModificationProtection"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetLoadBalancerModificationProtectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetLoadBalancerModificationProtection(request *SetLoadBalancerModificationProtectionRequest) (_result *SetLoadBalancerModificationProtectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetLoadBalancerModificationProtectionResponse{}
	_body, _err := client.SetLoadBalancerModificationProtectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetLoadBalancerNameWithOptions(request *SetLoadBalancerNameRequest, runtime *util.RuntimeOptions) (_result *SetLoadBalancerNameResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerName)) {
		query["LoadBalancerName"] = request.LoadBalancerName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetLoadBalancerName"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetLoadBalancerNameResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetLoadBalancerName(request *SetLoadBalancerNameRequest) (_result *SetLoadBalancerNameResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetLoadBalancerNameResponse{}
	_body, _err := client.SetLoadBalancerNameWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetLoadBalancerStatusWithOptions(request *SetLoadBalancerStatusRequest, runtime *util.RuntimeOptions) (_result *SetLoadBalancerStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerStatus)) {
		query["LoadBalancerStatus"] = request.LoadBalancerStatus
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetLoadBalancerStatus"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetLoadBalancerStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetLoadBalancerStatus(request *SetLoadBalancerStatusRequest) (_result *SetLoadBalancerStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetLoadBalancerStatusResponse{}
	_body, _err := client.SetLoadBalancerStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The timeout period of a health check.
 * If a backend ECS instance does not return a health check response within the specified timeout period, the server fails the health check.
 * Valid values: **1** to **300**. Unit: seconds.
 * >  If the value of the **HealthCheckConnectTimeout** parameter is smaller than that of the **HealthCheckInterval** parameter, the timeout period specified by the **HCTimeout** parameter is ignored and the period of time specified by the **HealthCheckInterval** parameter is used as the timeout period.
 *
 * @param request SetLoadBalancerTCPListenerAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetLoadBalancerTCPListenerAttributeResponse
 */
func (client *Client) SetLoadBalancerTCPListenerAttributeWithOptions(request *SetLoadBalancerTCPListenerAttributeRequest, runtime *util.RuntimeOptions) (_result *SetLoadBalancerTCPListenerAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclId)) {
		query["AclId"] = request.AclId
	}

	if !tea.BoolValue(util.IsUnset(request.AclStatus)) {
		query["AclStatus"] = request.AclStatus
	}

	if !tea.BoolValue(util.IsUnset(request.AclType)) {
		query["AclType"] = request.AclType
	}

	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectionDrain)) {
		query["ConnectionDrain"] = request.ConnectionDrain
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectionDrainTimeout)) {
		query["ConnectionDrainTimeout"] = request.ConnectionDrainTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EstablishedTimeout)) {
		query["EstablishedTimeout"] = request.EstablishedTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckConnectPort)) {
		query["HealthCheckConnectPort"] = request.HealthCheckConnectPort
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckConnectTimeout)) {
		query["HealthCheckConnectTimeout"] = request.HealthCheckConnectTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckDomain)) {
		query["HealthCheckDomain"] = request.HealthCheckDomain
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckHttpCode)) {
		query["HealthCheckHttpCode"] = request.HealthCheckHttpCode
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckInterval)) {
		query["HealthCheckInterval"] = request.HealthCheckInterval
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckSwitch)) {
		query["HealthCheckSwitch"] = request.HealthCheckSwitch
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckType)) {
		query["HealthCheckType"] = request.HealthCheckType
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckURI)) {
		query["HealthCheckURI"] = request.HealthCheckURI
	}

	if !tea.BoolValue(util.IsUnset(request.HealthyThreshold)) {
		query["HealthyThreshold"] = request.HealthyThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerPort)) {
		query["ListenerPort"] = request.ListenerPort
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.MasterSlaveServerGroup)) {
		query["MasterSlaveServerGroup"] = request.MasterSlaveServerGroup
	}

	if !tea.BoolValue(util.IsUnset(request.MasterSlaveServerGroupId)) {
		query["MasterSlaveServerGroupId"] = request.MasterSlaveServerGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PersistenceTimeout)) {
		query["PersistenceTimeout"] = request.PersistenceTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.ProxyProtocolV2Enabled)) {
		query["ProxyProtocolV2Enabled"] = request.ProxyProtocolV2Enabled
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Scheduler)) {
		query["Scheduler"] = request.Scheduler
	}

	if !tea.BoolValue(util.IsUnset(request.SynProxy)) {
		query["SynProxy"] = request.SynProxy
	}

	if !tea.BoolValue(util.IsUnset(request.UnhealthyThreshold)) {
		query["UnhealthyThreshold"] = request.UnhealthyThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroup)) {
		query["VServerGroup"] = request.VServerGroup
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroupId)) {
		query["VServerGroupId"] = request.VServerGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetLoadBalancerTCPListenerAttribute"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetLoadBalancerTCPListenerAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The timeout period of a health check.
 * If a backend ECS instance does not return a health check response within the specified timeout period, the server fails the health check.
 * Valid values: **1** to **300**. Unit: seconds.
 * >  If the value of the **HealthCheckConnectTimeout** parameter is smaller than that of the **HealthCheckInterval** parameter, the timeout period specified by the **HCTimeout** parameter is ignored and the period of time specified by the **HealthCheckInterval** parameter is used as the timeout period.
 *
 * @param request SetLoadBalancerTCPListenerAttributeRequest
 * @return SetLoadBalancerTCPListenerAttributeResponse
 */
func (client *Client) SetLoadBalancerTCPListenerAttribute(request *SetLoadBalancerTCPListenerAttributeRequest) (_result *SetLoadBalancerTCPListenerAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetLoadBalancerTCPListenerAttributeResponse{}
	_body, _err := client.SetLoadBalancerTCPListenerAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The response string for UDP listener health checks. The string must be 1 to 64 characters in length and can contain only letters and digits.
 *
 * @param request SetLoadBalancerUDPListenerAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetLoadBalancerUDPListenerAttributeResponse
 */
func (client *Client) SetLoadBalancerUDPListenerAttributeWithOptions(request *SetLoadBalancerUDPListenerAttributeRequest, runtime *util.RuntimeOptions) (_result *SetLoadBalancerUDPListenerAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AclId)) {
		query["AclId"] = request.AclId
	}

	if !tea.BoolValue(util.IsUnset(request.AclStatus)) {
		query["AclStatus"] = request.AclStatus
	}

	if !tea.BoolValue(util.IsUnset(request.AclType)) {
		query["AclType"] = request.AclType
	}

	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckConnectPort)) {
		query["HealthCheckConnectPort"] = request.HealthCheckConnectPort
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckConnectTimeout)) {
		query["HealthCheckConnectTimeout"] = request.HealthCheckConnectTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckInterval)) {
		query["HealthCheckInterval"] = request.HealthCheckInterval
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckSwitch)) {
		query["HealthCheckSwitch"] = request.HealthCheckSwitch
	}

	if !tea.BoolValue(util.IsUnset(request.HealthyThreshold)) {
		query["HealthyThreshold"] = request.HealthyThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerPort)) {
		query["ListenerPort"] = request.ListenerPort
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.MasterSlaveServerGroup)) {
		query["MasterSlaveServerGroup"] = request.MasterSlaveServerGroup
	}

	if !tea.BoolValue(util.IsUnset(request.MasterSlaveServerGroupId)) {
		query["MasterSlaveServerGroupId"] = request.MasterSlaveServerGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProxyProtocolV2Enabled)) {
		query["ProxyProtocolV2Enabled"] = request.ProxyProtocolV2Enabled
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Scheduler)) {
		query["Scheduler"] = request.Scheduler
	}

	if !tea.BoolValue(util.IsUnset(request.UnhealthyThreshold)) {
		query["UnhealthyThreshold"] = request.UnhealthyThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroup)) {
		query["VServerGroup"] = request.VServerGroup
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroupId)) {
		query["VServerGroupId"] = request.VServerGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckExp)) {
		query["healthCheckExp"] = request.HealthCheckExp
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckReq)) {
		query["healthCheckReq"] = request.HealthCheckReq
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetLoadBalancerUDPListenerAttribute"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetLoadBalancerUDPListenerAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The response string for UDP listener health checks. The string must be 1 to 64 characters in length and can contain only letters and digits.
 *
 * @param request SetLoadBalancerUDPListenerAttributeRequest
 * @return SetLoadBalancerUDPListenerAttributeResponse
 */
func (client *Client) SetLoadBalancerUDPListenerAttribute(request *SetLoadBalancerUDPListenerAttributeRequest) (_result *SetLoadBalancerUDPListenerAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetLoadBalancerUDPListenerAttributeResponse{}
	_body, _err := client.SetLoadBalancerUDPListenerAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetRuleWithOptions(request *SetRuleRequest, runtime *util.RuntimeOptions) (_result *SetRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Cookie)) {
		query["Cookie"] = request.Cookie
	}

	if !tea.BoolValue(util.IsUnset(request.CookieTimeout)) {
		query["CookieTimeout"] = request.CookieTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheck)) {
		query["HealthCheck"] = request.HealthCheck
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckConnectPort)) {
		query["HealthCheckConnectPort"] = request.HealthCheckConnectPort
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckDomain)) {
		query["HealthCheckDomain"] = request.HealthCheckDomain
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckHttpCode)) {
		query["HealthCheckHttpCode"] = request.HealthCheckHttpCode
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckInterval)) {
		query["HealthCheckInterval"] = request.HealthCheckInterval
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckTimeout)) {
		query["HealthCheckTimeout"] = request.HealthCheckTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckURI)) {
		query["HealthCheckURI"] = request.HealthCheckURI
	}

	if !tea.BoolValue(util.IsUnset(request.HealthyThreshold)) {
		query["HealthyThreshold"] = request.HealthyThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerSync)) {
		query["ListenerSync"] = request.ListenerSync
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleId)) {
		query["RuleId"] = request.RuleId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleName)) {
		query["RuleName"] = request.RuleName
	}

	if !tea.BoolValue(util.IsUnset(request.Scheduler)) {
		query["Scheduler"] = request.Scheduler
	}

	if !tea.BoolValue(util.IsUnset(request.StickySession)) {
		query["StickySession"] = request.StickySession
	}

	if !tea.BoolValue(util.IsUnset(request.StickySessionType)) {
		query["StickySessionType"] = request.StickySessionType
	}

	if !tea.BoolValue(util.IsUnset(request.UnhealthyThreshold)) {
		query["UnhealthyThreshold"] = request.UnhealthyThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroupId)) {
		query["VServerGroupId"] = request.VServerGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetRule"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetRule(request *SetRuleRequest) (_result *SetRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetRuleResponse{}
	_body, _err := client.SetRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetServerCertificateNameWithOptions(request *SetServerCertificateNameRequest, runtime *util.RuntimeOptions) (_result *SetServerCertificateNameResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ServerCertificateId)) {
		query["ServerCertificateId"] = request.ServerCertificateId
	}

	if !tea.BoolValue(util.IsUnset(request.ServerCertificateName)) {
		query["ServerCertificateName"] = request.ServerCertificateName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetServerCertificateName"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetServerCertificateNameResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetServerCertificateName(request *SetServerCertificateNameRequest) (_result *SetServerCertificateNameResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetServerCertificateNameResponse{}
	_body, _err := client.SetServerCertificateNameWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetTLSCipherPolicyAttributeWithOptions(request *SetTLSCipherPolicyAttributeRequest, runtime *util.RuntimeOptions) (_result *SetTLSCipherPolicyAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Ciphers)) {
		query["Ciphers"] = request.Ciphers
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TLSCipherPolicyId)) {
		query["TLSCipherPolicyId"] = request.TLSCipherPolicyId
	}

	if !tea.BoolValue(util.IsUnset(request.TLSVersions)) {
		query["TLSVersions"] = request.TLSVersions
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetTLSCipherPolicyAttribute"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetTLSCipherPolicyAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetTLSCipherPolicyAttribute(request *SetTLSCipherPolicyAttributeRequest) (_result *SetTLSCipherPolicyAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetTLSCipherPolicyAttributeResponse{}
	_body, _err := client.SetTLSCipherPolicyAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the region where the Classic Load Balancer (CLB) instance is deployed. This parameter cannot be modified.
 *
 * @param request SetVServerGroupAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetVServerGroupAttributeResponse
 */
func (client *Client) SetVServerGroupAttributeWithOptions(request *SetVServerGroupAttributeRequest, runtime *util.RuntimeOptions) (_result *SetVServerGroupAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BackendServers)) {
		query["BackendServers"] = request.BackendServers
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroupId)) {
		query["VServerGroupId"] = request.VServerGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.VServerGroupName)) {
		query["VServerGroupName"] = request.VServerGroupName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetVServerGroupAttribute"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetVServerGroupAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the region where the Classic Load Balancer (CLB) instance is deployed. This parameter cannot be modified.
 *
 * @param request SetVServerGroupAttributeRequest
 * @return SetVServerGroupAttributeResponse
 */
func (client *Client) SetVServerGroupAttribute(request *SetVServerGroupAttributeRequest) (_result *SetVServerGroupAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetVServerGroupAttributeResponse{}
	_body, _err := client.SetVServerGroupAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The operation that you want to perform.
 * Set the value to **StartLoadBalancerListener**.
 *
 * @param request StartLoadBalancerListenerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartLoadBalancerListenerResponse
 */
func (client *Client) StartLoadBalancerListenerWithOptions(request *StartLoadBalancerListenerRequest, runtime *util.RuntimeOptions) (_result *StartLoadBalancerListenerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ListenerPort)) {
		query["ListenerPort"] = request.ListenerPort
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerProtocol)) {
		query["ListenerProtocol"] = request.ListenerProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StartLoadBalancerListener"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StartLoadBalancerListenerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The operation that you want to perform.
 * Set the value to **StartLoadBalancerListener**.
 *
 * @param request StartLoadBalancerListenerRequest
 * @return StartLoadBalancerListenerResponse
 */
func (client *Client) StartLoadBalancerListener(request *StartLoadBalancerListenerRequest) (_result *StartLoadBalancerListenerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StartLoadBalancerListenerResponse{}
	_body, _err := client.StartLoadBalancerListenerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The name of this action.
 * Value: **StopLoadBalancerListener**
 *
 * @param request StopLoadBalancerListenerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopLoadBalancerListenerResponse
 */
func (client *Client) StopLoadBalancerListenerWithOptions(request *StopLoadBalancerListenerRequest, runtime *util.RuntimeOptions) (_result *StopLoadBalancerListenerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ListenerPort)) {
		query["ListenerPort"] = request.ListenerPort
	}

	if !tea.BoolValue(util.IsUnset(request.ListenerProtocol)) {
		query["ListenerProtocol"] = request.ListenerProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.LoadBalancerId)) {
		query["LoadBalancerId"] = request.LoadBalancerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StopLoadBalancerListener"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StopLoadBalancerListenerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The name of this action.
 * Value: **StopLoadBalancerListener**
 *
 * @param request StopLoadBalancerListenerRequest
 * @return StopLoadBalancerListenerResponse
 */
func (client *Client) StopLoadBalancerListener(request *StopLoadBalancerListenerRequest) (_result *StopLoadBalancerListenerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StopLoadBalancerListenerResponse{}
	_body, _err := client.StopLoadBalancerListenerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request TagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TagResourcesResponse
 */
func (client *Client) TagResourcesWithOptions(request *TagResourcesRequest, runtime *util.RuntimeOptions) (_result *TagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("TagResources"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request TagResourcesRequest
 * @return TagResourcesResponse
 */
func (client *Client) TagResources(request *TagResourcesRequest) (_result *TagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TagResourcesResponse{}
	_body, _err := client.TagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UntagResourcesWithOptions(request *UntagResourcesRequest, runtime *util.RuntimeOptions) (_result *UntagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.All)) {
		query["All"] = request.All
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TagKey)) {
		query["TagKey"] = request.TagKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UntagResources"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UntagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UntagResources(request *UntagResourcesRequest) (_result *UntagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UntagResourcesResponse{}
	_body, _err := client.UntagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the region to which the CA certificate belongs.
 * To query the region ID, call [DescribeRegions](~~27584~~).
 *
 * @param request UploadCACertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UploadCACertificateResponse
 */
func (client *Client) UploadCACertificateWithOptions(request *UploadCACertificateRequest, runtime *util.RuntimeOptions) (_result *UploadCACertificateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CACertificate)) {
		query["CACertificate"] = request.CACertificate
	}

	if !tea.BoolValue(util.IsUnset(request.CACertificateName)) {
		query["CACertificateName"] = request.CACertificateName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UploadCACertificate"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UploadCACertificateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the region to which the CA certificate belongs.
 * To query the region ID, call [DescribeRegions](~~27584~~).
 *
 * @param request UploadCACertificateRequest
 * @return UploadCACertificateResponse
 */
func (client *Client) UploadCACertificate(request *UploadCACertificateRequest) (_result *UploadCACertificateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UploadCACertificateResponse{}
	_body, _err := client.UploadCACertificateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The alternative domain names of the server certificate.
 *
 * @param request UploadServerCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UploadServerCertificateResponse
 */
func (client *Client) UploadServerCertificateWithOptions(request *UploadServerCertificateRequest, runtime *util.RuntimeOptions) (_result *UploadServerCertificateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AliCloudCertificateId)) {
		query["AliCloudCertificateId"] = request.AliCloudCertificateId
	}

	if !tea.BoolValue(util.IsUnset(request.AliCloudCertificateName)) {
		query["AliCloudCertificateName"] = request.AliCloudCertificateName
	}

	if !tea.BoolValue(util.IsUnset(request.AliCloudCertificateRegionId)) {
		query["AliCloudCertificateRegionId"] = request.AliCloudCertificateRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PrivateKey)) {
		query["PrivateKey"] = request.PrivateKey
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ServerCertificate)) {
		query["ServerCertificate"] = request.ServerCertificate
	}

	if !tea.BoolValue(util.IsUnset(request.ServerCertificateName)) {
		query["ServerCertificateName"] = request.ServerCertificateName
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UploadServerCertificate"),
		Version:     tea.String("2014-05-15"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UploadServerCertificateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The alternative domain names of the server certificate.
 *
 * @param request UploadServerCertificateRequest
 * @return UploadServerCertificateResponse
 */
func (client *Client) UploadServerCertificate(request *UploadServerCertificateRequest) (_result *UploadServerCertificateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UploadServerCertificateResponse{}
	_body, _err := client.UploadServerCertificateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}
