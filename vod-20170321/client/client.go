// This file is auto-generated, don't edit it. Thanks.
package client

import (
	openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
	endpointutil "github.com/alibabacloud-go/endpoint-util/service"
	openapiutil "github.com/alibabacloud-go/openapi-util/service"
	util "github.com/alibabacloud-go/tea-utils/v2/service"
	"github.com/alibabacloud-go/tea/tea"
)

type AppInfoDTO struct {
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// example:
	//
	// 1-普通应用，2-内嵌SDK.
	AppType   *int32                 `json:"AppType,omitempty" xml:"AppType,omitempty"`
	GmtCreate *string                `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	ItemId    *string                `json:"ItemId,omitempty" xml:"ItemId,omitempty"`
	Platforms []*AppInfoDTOPlatforms `json:"Platforms,omitempty" xml:"Platforms,omitempty" type:"Repeated"`
	UserId    *int64                 `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s AppInfoDTO) String() string {
	return tea.Prettify(s)
}

func (s AppInfoDTO) GoString() string {
	return s.String()
}

func (s *AppInfoDTO) SetAppName(v string) *AppInfoDTO {
	s.AppName = &v
	return s
}

func (s *AppInfoDTO) SetAppType(v int32) *AppInfoDTO {
	s.AppType = &v
	return s
}

func (s *AppInfoDTO) SetGmtCreate(v string) *AppInfoDTO {
	s.GmtCreate = &v
	return s
}

func (s *AppInfoDTO) SetItemId(v string) *AppInfoDTO {
	s.ItemId = &v
	return s
}

func (s *AppInfoDTO) SetPlatforms(v []*AppInfoDTOPlatforms) *AppInfoDTO {
	s.Platforms = v
	return s
}

func (s *AppInfoDTO) SetUserId(v int64) *AppInfoDTO {
	s.UserId = &v
	return s
}

type AppInfoDTOPlatforms struct {
	ItemId         *string   `json:"ItemId,omitempty" xml:"ItemId,omitempty"`
	LicenseItemIds []*string `json:"LicenseItemIds,omitempty" xml:"LicenseItemIds,omitempty" type:"Repeated"`
	PkgName        *string   `json:"PkgName,omitempty" xml:"PkgName,omitempty"`
	PkgSignature   *string   `json:"PkgSignature,omitempty" xml:"PkgSignature,omitempty"`
	PlatformType   *int64    `json:"PlatformType,omitempty" xml:"PlatformType,omitempty"`
	Type           *int64    `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s AppInfoDTOPlatforms) String() string {
	return tea.Prettify(s)
}

func (s AppInfoDTOPlatforms) GoString() string {
	return s.String()
}

func (s *AppInfoDTOPlatforms) SetItemId(v string) *AppInfoDTOPlatforms {
	s.ItemId = &v
	return s
}

func (s *AppInfoDTOPlatforms) SetLicenseItemIds(v []*string) *AppInfoDTOPlatforms {
	s.LicenseItemIds = v
	return s
}

func (s *AppInfoDTOPlatforms) SetPkgName(v string) *AppInfoDTOPlatforms {
	s.PkgName = &v
	return s
}

func (s *AppInfoDTOPlatforms) SetPkgSignature(v string) *AppInfoDTOPlatforms {
	s.PkgSignature = &v
	return s
}

func (s *AppInfoDTOPlatforms) SetPlatformType(v int64) *AppInfoDTOPlatforms {
	s.PlatformType = &v
	return s
}

func (s *AppInfoDTOPlatforms) SetType(v int64) *AppInfoDTOPlatforms {
	s.Type = &v
	return s
}

type LicenseInstanceAppDTO struct {
	AppId            *string                                `json:"AppId,omitempty" xml:"AppId,omitempty"`
	BeginOn          *string                                `json:"BeginOn,omitempty" xml:"BeginOn,omitempty"`
	ContractNo       *string                                `json:"ContractNo,omitempty" xml:"ContractNo,omitempty"`
	CreationTime     *string                                `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	ExpiredOn        *string                                `json:"ExpiredOn,omitempty" xml:"ExpiredOn,omitempty"`
	InstanceId       *string                                `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	ItemId           *string                                `json:"ItemId,omitempty" xml:"ItemId,omitempty"`
	LicenseConfigs   []*LicenseInstanceAppDTOLicenseConfigs `json:"LicenseConfigs,omitempty" xml:"LicenseConfigs,omitempty" type:"Repeated"`
	ModificationTime *string                                `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	Status           *string                                `json:"Status,omitempty" xml:"Status,omitempty"`
	UserId           *int64                                 `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s LicenseInstanceAppDTO) String() string {
	return tea.Prettify(s)
}

func (s LicenseInstanceAppDTO) GoString() string {
	return s.String()
}

func (s *LicenseInstanceAppDTO) SetAppId(v string) *LicenseInstanceAppDTO {
	s.AppId = &v
	return s
}

func (s *LicenseInstanceAppDTO) SetBeginOn(v string) *LicenseInstanceAppDTO {
	s.BeginOn = &v
	return s
}

func (s *LicenseInstanceAppDTO) SetContractNo(v string) *LicenseInstanceAppDTO {
	s.ContractNo = &v
	return s
}

func (s *LicenseInstanceAppDTO) SetCreationTime(v string) *LicenseInstanceAppDTO {
	s.CreationTime = &v
	return s
}

func (s *LicenseInstanceAppDTO) SetExpiredOn(v string) *LicenseInstanceAppDTO {
	s.ExpiredOn = &v
	return s
}

func (s *LicenseInstanceAppDTO) SetInstanceId(v string) *LicenseInstanceAppDTO {
	s.InstanceId = &v
	return s
}

func (s *LicenseInstanceAppDTO) SetItemId(v string) *LicenseInstanceAppDTO {
	s.ItemId = &v
	return s
}

func (s *LicenseInstanceAppDTO) SetLicenseConfigs(v []*LicenseInstanceAppDTOLicenseConfigs) *LicenseInstanceAppDTO {
	s.LicenseConfigs = v
	return s
}

func (s *LicenseInstanceAppDTO) SetModificationTime(v string) *LicenseInstanceAppDTO {
	s.ModificationTime = &v
	return s
}

func (s *LicenseInstanceAppDTO) SetStatus(v string) *LicenseInstanceAppDTO {
	s.Status = &v
	return s
}

func (s *LicenseInstanceAppDTO) SetUserId(v int64) *LicenseInstanceAppDTO {
	s.UserId = &v
	return s
}

type LicenseInstanceAppDTOLicenseConfigs struct {
	BusinessType    *string `json:"BusinessType,omitempty" xml:"BusinessType,omitempty"`
	FeatureIds      *string `json:"FeatureIds,omitempty" xml:"FeatureIds,omitempty"`
	IsTrial         *bool   `json:"IsTrial,omitempty" xml:"IsTrial,omitempty"`
	SdkId           *int32  `json:"SdkId,omitempty" xml:"SdkId,omitempty"`
	SdkName         *string `json:"SdkName,omitempty" xml:"SdkName,omitempty"`
	Subscription    *string `json:"Subscription,omitempty" xml:"Subscription,omitempty"`
	SubscriptionImp *string `json:"SubscriptionImp,omitempty" xml:"SubscriptionImp,omitempty"`
	SubscriptionPkg *string `json:"SubscriptionPkg,omitempty" xml:"SubscriptionPkg,omitempty"`
}

func (s LicenseInstanceAppDTOLicenseConfigs) String() string {
	return tea.Prettify(s)
}

func (s LicenseInstanceAppDTOLicenseConfigs) GoString() string {
	return s.String()
}

func (s *LicenseInstanceAppDTOLicenseConfigs) SetBusinessType(v string) *LicenseInstanceAppDTOLicenseConfigs {
	s.BusinessType = &v
	return s
}

func (s *LicenseInstanceAppDTOLicenseConfigs) SetFeatureIds(v string) *LicenseInstanceAppDTOLicenseConfigs {
	s.FeatureIds = &v
	return s
}

func (s *LicenseInstanceAppDTOLicenseConfigs) SetIsTrial(v bool) *LicenseInstanceAppDTOLicenseConfigs {
	s.IsTrial = &v
	return s
}

func (s *LicenseInstanceAppDTOLicenseConfigs) SetSdkId(v int32) *LicenseInstanceAppDTOLicenseConfigs {
	s.SdkId = &v
	return s
}

func (s *LicenseInstanceAppDTOLicenseConfigs) SetSdkName(v string) *LicenseInstanceAppDTOLicenseConfigs {
	s.SdkName = &v
	return s
}

func (s *LicenseInstanceAppDTOLicenseConfigs) SetSubscription(v string) *LicenseInstanceAppDTOLicenseConfigs {
	s.Subscription = &v
	return s
}

func (s *LicenseInstanceAppDTOLicenseConfigs) SetSubscriptionImp(v string) *LicenseInstanceAppDTOLicenseConfigs {
	s.SubscriptionImp = &v
	return s
}

func (s *LicenseInstanceAppDTOLicenseConfigs) SetSubscriptionPkg(v string) *LicenseInstanceAppDTOLicenseConfigs {
	s.SubscriptionPkg = &v
	return s
}

type AddAITemplateRequest struct {
	// The detailed configurations of the AI template. The value must be a JSON string. For more information, see [AITemplateConfig](~~89863#title-vd3-499-o36~~).
	//
	// This parameter is required.
	//
	// example:
	//
	// {"AuditItem":["terrorism","porn"],"AuditRange":["image-cover","text-title","video"],"AuditContent":["screen"],"AuditAutoBlock":"yes"}
	TemplateConfig *string `json:"TemplateConfig,omitempty" xml:"TemplateConfig,omitempty"`
	// The name of the AI template. The name can be up to 128 bytes in length.
	//
	// This parameter is required.
	//
	// example:
	//
	// AI-media-test
	TemplateName *string `json:"TemplateName,omitempty" xml:"TemplateName,omitempty"`
	// The type of the AI template. Valid values:
	//
	// 	- **AIMediaAudit**: automated review
	//
	// 	- **AIImage**: smart thumbnail
	//
	// This parameter is required.
	//
	// example:
	//
	// AIMediaAudit
	TemplateType *string `json:"TemplateType,omitempty" xml:"TemplateType,omitempty"`
}

func (s AddAITemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s AddAITemplateRequest) GoString() string {
	return s.String()
}

func (s *AddAITemplateRequest) SetTemplateConfig(v string) *AddAITemplateRequest {
	s.TemplateConfig = &v
	return s
}

func (s *AddAITemplateRequest) SetTemplateName(v string) *AddAITemplateRequest {
	s.TemplateName = &v
	return s
}

func (s *AddAITemplateRequest) SetTemplateType(v string) *AddAITemplateRequest {
	s.TemplateType = &v
	return s
}

type AddAITemplateResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 25818875-5F78-4A13-BEF6-****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the AI template.
	//
	// example:
	//
	// 1706a0063dd733f6a823ef32e0a5****
	TemplateId *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
}

func (s AddAITemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddAITemplateResponseBody) GoString() string {
	return s.String()
}

func (s *AddAITemplateResponseBody) SetRequestId(v string) *AddAITemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddAITemplateResponseBody) SetTemplateId(v string) *AddAITemplateResponseBody {
	s.TemplateId = &v
	return s
}

type AddAITemplateResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *AddAITemplateResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AddAITemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s AddAITemplateResponse) GoString() string {
	return s.String()
}

func (s *AddAITemplateResponse) SetHeaders(v map[string]*string) *AddAITemplateResponse {
	s.Headers = v
	return s
}

func (s *AddAITemplateResponse) SetStatusCode(v int32) *AddAITemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *AddAITemplateResponse) SetBody(v *AddAITemplateResponseBody) *AddAITemplateResponse {
	s.Body = v
	return s
}

type AddCategoryRequest struct {
	// The name of the category.
	//
	// 	- The value can be up to 64 bytes in length.
	//
	// 	- The value must be encoded in UTF-8.
	//
	// This parameter is required.
	//
	// example:
	//
	// test
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	// The ID of the parent category.
	//
	// To obtain the category ID, perform the following steps: Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). Choose **Configuration Management*	- > **Media Management*	- > **Categories**. On the **Audio and Video / Image Category*	- or **Short Video Material Category*	- tab, view the category ID.
	//
	// > 	- If you specify this parameter, the system creates a subcategory under the parent category. If you leave this parameter empty, the system creates a level 1 category.
	//
	// >	- You cannot modify, add, or delete level 1 categories of short video materials. You can create only subcategories under level 1 categories for short video materials. This parameter is required when you set `Type` to `material`.
	//
	// example:
	//
	// 100012****
	ParentId *int64 `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
	// The type of the category. Valid values:
	//
	// 	- **default*	- (default): audio, video, and image files
	//
	// 	- **material**: short video materials
	//
	// example:
	//
	// default
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s AddCategoryRequest) String() string {
	return tea.Prettify(s)
}

func (s AddCategoryRequest) GoString() string {
	return s.String()
}

func (s *AddCategoryRequest) SetCateName(v string) *AddCategoryRequest {
	s.CateName = &v
	return s
}

func (s *AddCategoryRequest) SetParentId(v int64) *AddCategoryRequest {
	s.ParentId = &v
	return s
}

func (s *AddCategoryRequest) SetType(v string) *AddCategoryRequest {
	s.Type = &v
	return s
}

type AddCategoryResponseBody struct {
	// The information about the category.
	Category *AddCategoryResponseBodyCategory `json:"Category,omitempty" xml:"Category,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4AF6-D7393642CA58****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddCategoryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddCategoryResponseBody) GoString() string {
	return s.String()
}

func (s *AddCategoryResponseBody) SetCategory(v *AddCategoryResponseBodyCategory) *AddCategoryResponseBody {
	s.Category = v
	return s
}

func (s *AddCategoryResponseBody) SetRequestId(v string) *AddCategoryResponseBody {
	s.RequestId = &v
	return s
}

type AddCategoryResponseBodyCategory struct {
	// The ID of the category. You can use the value of this parameter when you call the [UpdateCategory](~~UpdateCategory~~), [DeleteCategory](~~DeleteCategory~~), and [GetCategories](~~GetCategories~~) operations.
	//
	// example:
	//
	// 10020
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The name of the category.
	//
	// example:
	//
	// test
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	// The level of the category. Valid values:
	//
	// 	- **0**: level 1 category
	//
	// 	- **1**: level 2 category
	//
	// 	- **1**: level 3 category
	//
	// example:
	//
	// 1
	Level *int64 `json:"Level,omitempty" xml:"Level,omitempty"`
	// The ID of the parent category.
	//
	// example:
	//
	// 100012
	ParentId *int64 `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
	// The type of the category. Valid values:
	//
	// 	- **default**: audio, video, and image files
	//
	// 	- **material**: short video materials
	//
	// example:
	//
	// default
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s AddCategoryResponseBodyCategory) String() string {
	return tea.Prettify(s)
}

func (s AddCategoryResponseBodyCategory) GoString() string {
	return s.String()
}

func (s *AddCategoryResponseBodyCategory) SetCateId(v int64) *AddCategoryResponseBodyCategory {
	s.CateId = &v
	return s
}

func (s *AddCategoryResponseBodyCategory) SetCateName(v string) *AddCategoryResponseBodyCategory {
	s.CateName = &v
	return s
}

func (s *AddCategoryResponseBodyCategory) SetLevel(v int64) *AddCategoryResponseBodyCategory {
	s.Level = &v
	return s
}

func (s *AddCategoryResponseBodyCategory) SetParentId(v int64) *AddCategoryResponseBodyCategory {
	s.ParentId = &v
	return s
}

func (s *AddCategoryResponseBodyCategory) SetType(v string) *AddCategoryResponseBodyCategory {
	s.Type = &v
	return s
}

type AddCategoryResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *AddCategoryResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AddCategoryResponse) String() string {
	return tea.Prettify(s)
}

func (s AddCategoryResponse) GoString() string {
	return s.String()
}

func (s *AddCategoryResponse) SetHeaders(v map[string]*string) *AddCategoryResponse {
	s.Headers = v
	return s
}

func (s *AddCategoryResponse) SetStatusCode(v int32) *AddCategoryResponse {
	s.StatusCode = &v
	return s
}

func (s *AddCategoryResponse) SetBody(v *AddCategoryResponseBody) *AddCategoryResponse {
	s.Body = v
	return s
}

type AddEditingProjectRequest struct {
	// The thumbnail URL of the online editing project. If you leave this parameter empty and materials exist on the video track in the timeline, the thumbnail of the first material is used by default.
	//
	// example:
	//
	// https://demo.aliyundoc.com/6AB4D0E1E1C74468883516C2349D1FC2-6-2.png
	CoverURL *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	// The description of the online editing project.
	//
	// example:
	//
	// testtimeline001desciption
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The region in which ApsaraVideo VOD is activated.
	//
	// example:
	//
	// cn-shanghai
	Division             *string `json:"Division,omitempty" xml:"Division,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The timeline of the online editing project in JSON format. For more information about the structure, see [Timeline](https://help.aliyun.com/document_detail/52839.html).
	//
	// If you leave this parameter empty, an empty timeline is created and the duration of the online editing project is zero.
	//
	// example:
	//
	// {"VideoTracks":[{"VideoTrackClips":[{"MediaId":"cc3308ac5006aed55a54328bc3443****"},{"MediaId":"95948ddba24446b6aed5db985e78****"}]}]}
	Timeline *string `json:"Timeline,omitempty" xml:"Timeline,omitempty"`
	// The title of the online editing project.
	//
	// This parameter is required.
	//
	// example:
	//
	// testtimeline
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
}

func (s AddEditingProjectRequest) String() string {
	return tea.Prettify(s)
}

func (s AddEditingProjectRequest) GoString() string {
	return s.String()
}

func (s *AddEditingProjectRequest) SetCoverURL(v string) *AddEditingProjectRequest {
	s.CoverURL = &v
	return s
}

func (s *AddEditingProjectRequest) SetDescription(v string) *AddEditingProjectRequest {
	s.Description = &v
	return s
}

func (s *AddEditingProjectRequest) SetDivision(v string) *AddEditingProjectRequest {
	s.Division = &v
	return s
}

func (s *AddEditingProjectRequest) SetOwnerAccount(v string) *AddEditingProjectRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AddEditingProjectRequest) SetOwnerId(v string) *AddEditingProjectRequest {
	s.OwnerId = &v
	return s
}

func (s *AddEditingProjectRequest) SetResourceOwnerAccount(v string) *AddEditingProjectRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AddEditingProjectRequest) SetResourceOwnerId(v string) *AddEditingProjectRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *AddEditingProjectRequest) SetTimeline(v string) *AddEditingProjectRequest {
	s.Timeline = &v
	return s
}

func (s *AddEditingProjectRequest) SetTitle(v string) *AddEditingProjectRequest {
	s.Title = &v
	return s
}

type AddEditingProjectResponseBody struct {
	// The information about the online editing project. For more information about the structure, see [EditingProject](https://help.aliyun.com/document_detail/52839.html).
	Project *AddEditingProjectResponseBodyProject `json:"Project,omitempty" xml:"Project,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// E4EBD2BF-5EB0-4476-8829-9D94E1B1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddEditingProjectResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddEditingProjectResponseBody) GoString() string {
	return s.String()
}

func (s *AddEditingProjectResponseBody) SetProject(v *AddEditingProjectResponseBodyProject) *AddEditingProjectResponseBody {
	s.Project = v
	return s
}

func (s *AddEditingProjectResponseBody) SetRequestId(v string) *AddEditingProjectResponseBody {
	s.RequestId = &v
	return s
}

type AddEditingProjectResponseBodyProject struct {
	// The time when the online editing project was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-01-11T12:00:00Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the online editing project.
	//
	// example:
	//
	// testtimeline001desciption
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The time when the online editing project was last modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-01-11T13:00:00Z
	ModifiedTime *string `json:"ModifiedTime,omitempty" xml:"ModifiedTime,omitempty"`
	// The ID of the online editing project.
	//
	// example:
	//
	// fb2101bf24bf4df34c4cb3187****
	ProjectId *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The status of the online editing project. Valid values:
	//
	// 	- **Normal**: the online editing project is in draft.
	//
	// 	- **Producing**: the video is being produced.
	//
	// 	- **Produced**: the video is produced.
	//
	// 	- **ProduceFailed**: the video failed to be produced.
	//
	// example:
	//
	// Normal
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The title of the online editing project.
	//
	// example:
	//
	// testtimeline
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
}

func (s AddEditingProjectResponseBodyProject) String() string {
	return tea.Prettify(s)
}

func (s AddEditingProjectResponseBodyProject) GoString() string {
	return s.String()
}

func (s *AddEditingProjectResponseBodyProject) SetCreationTime(v string) *AddEditingProjectResponseBodyProject {
	s.CreationTime = &v
	return s
}

func (s *AddEditingProjectResponseBodyProject) SetDescription(v string) *AddEditingProjectResponseBodyProject {
	s.Description = &v
	return s
}

func (s *AddEditingProjectResponseBodyProject) SetModifiedTime(v string) *AddEditingProjectResponseBodyProject {
	s.ModifiedTime = &v
	return s
}

func (s *AddEditingProjectResponseBodyProject) SetProjectId(v string) *AddEditingProjectResponseBodyProject {
	s.ProjectId = &v
	return s
}

func (s *AddEditingProjectResponseBodyProject) SetStatus(v string) *AddEditingProjectResponseBodyProject {
	s.Status = &v
	return s
}

func (s *AddEditingProjectResponseBodyProject) SetTitle(v string) *AddEditingProjectResponseBodyProject {
	s.Title = &v
	return s
}

type AddEditingProjectResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *AddEditingProjectResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AddEditingProjectResponse) String() string {
	return tea.Prettify(s)
}

func (s AddEditingProjectResponse) GoString() string {
	return s.String()
}

func (s *AddEditingProjectResponse) SetHeaders(v map[string]*string) *AddEditingProjectResponse {
	s.Headers = v
	return s
}

func (s *AddEditingProjectResponse) SetStatusCode(v int32) *AddEditingProjectResponse {
	s.StatusCode = &v
	return s
}

func (s *AddEditingProjectResponse) SetBody(v *AddEditingProjectResponseBody) *AddEditingProjectResponse {
	s.Body = v
	return s
}

type AddEditingProjectMaterialsRequest struct {
	// Separate multiple material IDs with commas (,). You can specify up to 10 IDs.
	//
	// >  If you specify multiple materials, make sure that the materials are of the same type as specified in MaterialType.
	//
	// This parameter is required.
	//
	// example:
	//
	// d3251979f9fd41f2acb29ccda5a6f772
	MaterialIds *string `json:"MaterialIds,omitempty" xml:"MaterialIds,omitempty"`
	// The type of the material. Valid values:
	//
	// 	- **video**
	//
	// 	- **audio**
	//
	// 	- **image**
	//
	// This parameter is required.
	//
	// example:
	//
	// video
	MaterialType *string `json:"MaterialType,omitempty" xml:"MaterialType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the online editing project.
	//
	// This parameter is required.
	//
	// example:
	//
	// afa31b483b5c41609185de0e1b790579
	ProjectId            *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s AddEditingProjectMaterialsRequest) String() string {
	return tea.Prettify(s)
}

func (s AddEditingProjectMaterialsRequest) GoString() string {
	return s.String()
}

func (s *AddEditingProjectMaterialsRequest) SetMaterialIds(v string) *AddEditingProjectMaterialsRequest {
	s.MaterialIds = &v
	return s
}

func (s *AddEditingProjectMaterialsRequest) SetMaterialType(v string) *AddEditingProjectMaterialsRequest {
	s.MaterialType = &v
	return s
}

func (s *AddEditingProjectMaterialsRequest) SetOwnerAccount(v string) *AddEditingProjectMaterialsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AddEditingProjectMaterialsRequest) SetOwnerId(v string) *AddEditingProjectMaterialsRequest {
	s.OwnerId = &v
	return s
}

func (s *AddEditingProjectMaterialsRequest) SetProjectId(v string) *AddEditingProjectMaterialsRequest {
	s.ProjectId = &v
	return s
}

func (s *AddEditingProjectMaterialsRequest) SetResourceOwnerAccount(v string) *AddEditingProjectMaterialsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AddEditingProjectMaterialsRequest) SetResourceOwnerId(v string) *AddEditingProjectMaterialsRequest {
	s.ResourceOwnerId = &v
	return s
}

type AddEditingProjectMaterialsResponseBody struct {
	// The materials.
	MaterialList []*AddEditingProjectMaterialsResponseBodyMaterialList `json:"MaterialList,omitempty" xml:"MaterialList,omitempty" type:"Repeated"`
	// The ID of the request.
	//
	// example:
	//
	// 85237CDA-0B54-5CED-BA10-A8A71AA13C1A
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddEditingProjectMaterialsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddEditingProjectMaterialsResponseBody) GoString() string {
	return s.String()
}

func (s *AddEditingProjectMaterialsResponseBody) SetMaterialList(v []*AddEditingProjectMaterialsResponseBodyMaterialList) *AddEditingProjectMaterialsResponseBody {
	s.MaterialList = v
	return s
}

func (s *AddEditingProjectMaterialsResponseBody) SetRequestId(v string) *AddEditingProjectMaterialsResponseBody {
	s.RequestId = &v
	return s
}

type AddEditingProjectMaterialsResponseBodyMaterialList struct {
	// The ID of the category.
	//
	// example:
	//
	// 1000487543
	CateId *int32 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The category name of the material.
	//
	// example:
	//
	// cate1
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	// The thumbnail URL.
	CoverURL *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	// The time when the material was created. The time follows the ISO 8601 standard in the *YYYY-MM-DD**Thh:mm:ss	- format. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-10-02T08:26Z
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the user.
	//
	// example:
	//
	// 1234751840694470
	CustomerId *int64 `json:"CustomerId,omitempty" xml:"CustomerId,omitempty"`
	// The description of the material.
	//
	// example:
	//
	// test material
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The duration of the material. Unit: seconds. The value is accurate to four decimal places.
	//
	// example:
	//
	// 3690.2332
	Duration *float32 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The ID of the material.
	//
	// example:
	//
	// 85befc4118b84c6723e53b80b1****
	MaterialId *string `json:"MaterialId,omitempty" xml:"MaterialId,omitempty"`
	// The type of the material. Valid values:
	//
	// 	- **video**
	//
	// 	- **audio**
	//
	// 	- **image**
	//
	// example:
	//
	// video
	MaterialType *string `json:"MaterialType,omitempty" xml:"MaterialType,omitempty"`
	// The time when the material was last updated. The time follows the ISO 8601 standard in the *YYYY-MM-DD**Thh:mm:ss	- format. The time is displayed in UTC.
	//
	// example:
	//
	// 2022-11-25T07:28:34Z
	ModifyTime *string `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	// The size of the material.
	//
	// example:
	//
	// 1682694
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The URLs of snapshots.
	Snapshots []*string `json:"Snapshots,omitempty" xml:"Snapshots,omitempty" type:"Repeated"`
	// The configuration of the sprite snapshot.
	//
	// example:
	//
	// xxx
	SpriteConfig *string `json:"SpriteConfig,omitempty" xml:"SpriteConfig,omitempty"`
	// The URLs of sprite snapshots.
	Sprites []*string `json:"Sprites,omitempty" xml:"Sprites,omitempty" type:"Repeated"`
	// The status of the material. Valid values:
	//
	// 	- **Normal**
	//
	// 	- **Uploading**
	//
	// 	- **UploadFail**
	//
	// example:
	//
	// Normal
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tag of the material. Multiple tags are separated by commas (,).
	//
	// example:
	//
	// tag1,tag2
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The title of the material.
	//
	// example:
	//
	// test
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
}

func (s AddEditingProjectMaterialsResponseBodyMaterialList) String() string {
	return tea.Prettify(s)
}

func (s AddEditingProjectMaterialsResponseBodyMaterialList) GoString() string {
	return s.String()
}

func (s *AddEditingProjectMaterialsResponseBodyMaterialList) SetCateId(v int32) *AddEditingProjectMaterialsResponseBodyMaterialList {
	s.CateId = &v
	return s
}

func (s *AddEditingProjectMaterialsResponseBodyMaterialList) SetCateName(v string) *AddEditingProjectMaterialsResponseBodyMaterialList {
	s.CateName = &v
	return s
}

func (s *AddEditingProjectMaterialsResponseBodyMaterialList) SetCoverURL(v string) *AddEditingProjectMaterialsResponseBodyMaterialList {
	s.CoverURL = &v
	return s
}

func (s *AddEditingProjectMaterialsResponseBodyMaterialList) SetCreateTime(v string) *AddEditingProjectMaterialsResponseBodyMaterialList {
	s.CreateTime = &v
	return s
}

func (s *AddEditingProjectMaterialsResponseBodyMaterialList) SetCustomerId(v int64) *AddEditingProjectMaterialsResponseBodyMaterialList {
	s.CustomerId = &v
	return s
}

func (s *AddEditingProjectMaterialsResponseBodyMaterialList) SetDescription(v string) *AddEditingProjectMaterialsResponseBodyMaterialList {
	s.Description = &v
	return s
}

func (s *AddEditingProjectMaterialsResponseBodyMaterialList) SetDuration(v float32) *AddEditingProjectMaterialsResponseBodyMaterialList {
	s.Duration = &v
	return s
}

func (s *AddEditingProjectMaterialsResponseBodyMaterialList) SetMaterialId(v string) *AddEditingProjectMaterialsResponseBodyMaterialList {
	s.MaterialId = &v
	return s
}

func (s *AddEditingProjectMaterialsResponseBodyMaterialList) SetMaterialType(v string) *AddEditingProjectMaterialsResponseBodyMaterialList {
	s.MaterialType = &v
	return s
}

func (s *AddEditingProjectMaterialsResponseBodyMaterialList) SetModifyTime(v string) *AddEditingProjectMaterialsResponseBodyMaterialList {
	s.ModifyTime = &v
	return s
}

func (s *AddEditingProjectMaterialsResponseBodyMaterialList) SetSize(v int64) *AddEditingProjectMaterialsResponseBodyMaterialList {
	s.Size = &v
	return s
}

func (s *AddEditingProjectMaterialsResponseBodyMaterialList) SetSnapshots(v []*string) *AddEditingProjectMaterialsResponseBodyMaterialList {
	s.Snapshots = v
	return s
}

func (s *AddEditingProjectMaterialsResponseBodyMaterialList) SetSpriteConfig(v string) *AddEditingProjectMaterialsResponseBodyMaterialList {
	s.SpriteConfig = &v
	return s
}

func (s *AddEditingProjectMaterialsResponseBodyMaterialList) SetSprites(v []*string) *AddEditingProjectMaterialsResponseBodyMaterialList {
	s.Sprites = v
	return s
}

func (s *AddEditingProjectMaterialsResponseBodyMaterialList) SetStatus(v string) *AddEditingProjectMaterialsResponseBodyMaterialList {
	s.Status = &v
	return s
}

func (s *AddEditingProjectMaterialsResponseBodyMaterialList) SetTags(v string) *AddEditingProjectMaterialsResponseBodyMaterialList {
	s.Tags = &v
	return s
}

func (s *AddEditingProjectMaterialsResponseBodyMaterialList) SetTitle(v string) *AddEditingProjectMaterialsResponseBodyMaterialList {
	s.Title = &v
	return s
}

type AddEditingProjectMaterialsResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *AddEditingProjectMaterialsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AddEditingProjectMaterialsResponse) String() string {
	return tea.Prettify(s)
}

func (s AddEditingProjectMaterialsResponse) GoString() string {
	return s.String()
}

func (s *AddEditingProjectMaterialsResponse) SetHeaders(v map[string]*string) *AddEditingProjectMaterialsResponse {
	s.Headers = v
	return s
}

func (s *AddEditingProjectMaterialsResponse) SetStatusCode(v int32) *AddEditingProjectMaterialsResponse {
	s.StatusCode = &v
	return s
}

func (s *AddEditingProjectMaterialsResponse) SetBody(v *AddEditingProjectMaterialsResponseBody) *AddEditingProjectMaterialsResponse {
	s.Body = v
	return s
}

type AddTranscodeTemplateGroupRequest struct {
	// The application ID. Default value: **app-1000000**. For more information, see [Use the multi-application service](https://help.aliyun.com/document_detail/113600.html).
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the transcoding template group.
	//
	// 	- The name can be up to 128 bytes in length.
	//
	// 	- The value must be encoded in UTF-8.
	//
	// > You must specify TranscodeTemplateGroupId or Name in the request.
	//
	// example:
	//
	// transcodetemplate
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the transcoding template group. If a transcoding template group ID is specified, you can add transcoding templates to the template group.
	//
	// > You must specify TranscodeTemplateGroupId or Name in the request.
	//
	// example:
	//
	// 4c71a339fe52b4fa6f4527****
	TranscodeTemplateGroupId *string `json:"TranscodeTemplateGroupId,omitempty" xml:"TranscodeTemplateGroupId,omitempty"`
	// The configurations of the transcoding template. The value is a string in JSON format. For more information about the data structure, see [TranscodeTemplate](https://help.aliyun.com/document_detail/52839.html).
	//
	// > 	- If you do not specify this parameter, the transcoding job cannot be automatically created after you upload a video.
	//
	// > 	- If you do not need to set Width or Height, do not specify the corresponding parameter. You cannot set the value to an empty string, such as "Height":"".
	//
	// example:
	//
	// [{"Video":{"Bitrate":"400","Codec":"H.264","Fps":"30","Height":""},"Definition":"SD","Container":{"Format":"mp4"},"TemplateName":"testName","MuxConfig":{},"Audio":{"Codec":"AAC","Bitrate":"64","Samplerate":"44100"}}]
	TranscodeTemplateList *string `json:"TranscodeTemplateList,omitempty" xml:"TranscodeTemplateList,omitempty"`
}

func (s AddTranscodeTemplateGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s AddTranscodeTemplateGroupRequest) GoString() string {
	return s.String()
}

func (s *AddTranscodeTemplateGroupRequest) SetAppId(v string) *AddTranscodeTemplateGroupRequest {
	s.AppId = &v
	return s
}

func (s *AddTranscodeTemplateGroupRequest) SetName(v string) *AddTranscodeTemplateGroupRequest {
	s.Name = &v
	return s
}

func (s *AddTranscodeTemplateGroupRequest) SetTranscodeTemplateGroupId(v string) *AddTranscodeTemplateGroupRequest {
	s.TranscodeTemplateGroupId = &v
	return s
}

func (s *AddTranscodeTemplateGroupRequest) SetTranscodeTemplateList(v string) *AddTranscodeTemplateGroupRequest {
	s.TranscodeTemplateList = &v
	return s
}

type AddTranscodeTemplateGroupResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 25818875-5F78-4AF6-D7393642CA58****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the transcoding template group.
	//
	// example:
	//
	// 34e908aa4024af7821c31f93a2a****
	TranscodeTemplateGroupId *string `json:"TranscodeTemplateGroupId,omitempty" xml:"TranscodeTemplateGroupId,omitempty"`
}

func (s AddTranscodeTemplateGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddTranscodeTemplateGroupResponseBody) GoString() string {
	return s.String()
}

func (s *AddTranscodeTemplateGroupResponseBody) SetRequestId(v string) *AddTranscodeTemplateGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddTranscodeTemplateGroupResponseBody) SetTranscodeTemplateGroupId(v string) *AddTranscodeTemplateGroupResponseBody {
	s.TranscodeTemplateGroupId = &v
	return s
}

type AddTranscodeTemplateGroupResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *AddTranscodeTemplateGroupResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AddTranscodeTemplateGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s AddTranscodeTemplateGroupResponse) GoString() string {
	return s.String()
}

func (s *AddTranscodeTemplateGroupResponse) SetHeaders(v map[string]*string) *AddTranscodeTemplateGroupResponse {
	s.Headers = v
	return s
}

func (s *AddTranscodeTemplateGroupResponse) SetStatusCode(v int32) *AddTranscodeTemplateGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *AddTranscodeTemplateGroupResponse) SetBody(v *AddTranscodeTemplateGroupResponseBody) *AddTranscodeTemplateGroupResponse {
	s.Body = v
	return s
}

type AddVodDomainRequest struct {
	// The URL that is used for health checks.
	//
	// example:
	//
	// www.example.com/test.html
	CheckUrl *string `json:"CheckUrl,omitempty" xml:"CheckUrl,omitempty"`
	// The domain name that you want to accelerate. Wildcard domain names that start with periods (.) are supported. Example: .example.com.
	//
	// This parameter is required.
	//
	// example:
	//
	// example.com
	DomainName   *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// This parameter is applicable to users of level 3 or higher in the Chinese mainland and users outside the Chinese mainland. Default value: domestic. Valid values:
	//
	// 	- **domestic**: Chinese mainland
	//
	// 	- **overseas**: outside the Chinese mainland
	//
	// 	- **global**: regions in and outside the Chinese mainland
	//
	// example:
	//
	// domestic
	Scope         *string `json:"Scope,omitempty" xml:"Scope,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The information about the addresses of origin servers. For more information, see the **Sources*	- table in this topic.
	//
	// This parameter is required.
	//
	// example:
	//
	// [{"content":"1.1.1.1","type":"ipaddr","priority":"20","port":80}]
	Sources *string `json:"Sources,omitempty" xml:"Sources,omitempty"`
	// The top-level domain.
	//
	// example:
	//
	// example.com
	TopLevelDomain *string `json:"TopLevelDomain,omitempty" xml:"TopLevelDomain,omitempty"`
}

func (s AddVodDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s AddVodDomainRequest) GoString() string {
	return s.String()
}

func (s *AddVodDomainRequest) SetCheckUrl(v string) *AddVodDomainRequest {
	s.CheckUrl = &v
	return s
}

func (s *AddVodDomainRequest) SetDomainName(v string) *AddVodDomainRequest {
	s.DomainName = &v
	return s
}

func (s *AddVodDomainRequest) SetOwnerAccount(v string) *AddVodDomainRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AddVodDomainRequest) SetOwnerId(v int64) *AddVodDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *AddVodDomainRequest) SetScope(v string) *AddVodDomainRequest {
	s.Scope = &v
	return s
}

func (s *AddVodDomainRequest) SetSecurityToken(v string) *AddVodDomainRequest {
	s.SecurityToken = &v
	return s
}

func (s *AddVodDomainRequest) SetSources(v string) *AddVodDomainRequest {
	s.Sources = &v
	return s
}

func (s *AddVodDomainRequest) SetTopLevelDomain(v string) *AddVodDomainRequest {
	s.TopLevelDomain = &v
	return s
}

type AddVodDomainResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 15C66C7B-671A-4297-****-2C4477247A74
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddVodDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddVodDomainResponseBody) GoString() string {
	return s.String()
}

func (s *AddVodDomainResponseBody) SetRequestId(v string) *AddVodDomainResponseBody {
	s.RequestId = &v
	return s
}

type AddVodDomainResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *AddVodDomainResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AddVodDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s AddVodDomainResponse) GoString() string {
	return s.String()
}

func (s *AddVodDomainResponse) SetHeaders(v map[string]*string) *AddVodDomainResponse {
	s.Headers = v
	return s
}

func (s *AddVodDomainResponse) SetStatusCode(v int32) *AddVodDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *AddVodDomainResponse) SetBody(v *AddVodDomainResponseBody) *AddVodDomainResponse {
	s.Body = v
	return s
}

type AddVodStorageForAppRequest struct {
	// The IDs of applications. You can obtain the application ID from the `AppId` parameter in the response to the [CreateAppInfo](~~CreateAppInfo~~) or [ListAppInfo](~~ListAppInfo~~) operation.
	//
	// This parameter is required.
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The address of an Object Storage Service (OSS) bucket. This parameter does not take effect. You can call this operation to add only VOD buckets.
	//
	// example:
	//
	// out-****.oss-cn-shanghai.aliyuncs.com
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	// The storage class. Default value: **vod_oss_bucket**.
	//
	// example:
	//
	// vod_oss_bucket
	StorageType *string `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
}

func (s AddVodStorageForAppRequest) String() string {
	return tea.Prettify(s)
}

func (s AddVodStorageForAppRequest) GoString() string {
	return s.String()
}

func (s *AddVodStorageForAppRequest) SetAppId(v string) *AddVodStorageForAppRequest {
	s.AppId = &v
	return s
}

func (s *AddVodStorageForAppRequest) SetStorageLocation(v string) *AddVodStorageForAppRequest {
	s.StorageLocation = &v
	return s
}

func (s *AddVodStorageForAppRequest) SetStorageType(v string) *AddVodStorageForAppRequest {
	s.StorageType = &v
	return s
}

type AddVodStorageForAppResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A*****F6-D7393642CA58
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The address of the VOD bucket.
	//
	// example:
	//
	// out-****.oss-cn-shanghai.aliyuncs.com
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
}

func (s AddVodStorageForAppResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddVodStorageForAppResponseBody) GoString() string {
	return s.String()
}

func (s *AddVodStorageForAppResponseBody) SetRequestId(v string) *AddVodStorageForAppResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddVodStorageForAppResponseBody) SetStorageLocation(v string) *AddVodStorageForAppResponseBody {
	s.StorageLocation = &v
	return s
}

type AddVodStorageForAppResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *AddVodStorageForAppResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AddVodStorageForAppResponse) String() string {
	return tea.Prettify(s)
}

func (s AddVodStorageForAppResponse) GoString() string {
	return s.String()
}

func (s *AddVodStorageForAppResponse) SetHeaders(v map[string]*string) *AddVodStorageForAppResponse {
	s.Headers = v
	return s
}

func (s *AddVodStorageForAppResponse) SetStatusCode(v int32) *AddVodStorageForAppResponse {
	s.StatusCode = &v
	return s
}

func (s *AddVodStorageForAppResponse) SetBody(v *AddVodStorageForAppResponseBody) *AddVodStorageForAppResponse {
	s.Body = v
	return s
}

type AddVodTemplateRequest struct {
	// The ID of the application. Default value: **app-1000000**. For more information, see [Multi-application service](https://help.aliyun.com/document_detail/113600.html).
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the template.
	//
	// 	- The name cannot exceed 128 bytes.
	//
	// 	- The value must be encoded in UTF-8.
	//
	// This parameter is required.
	//
	// example:
	//
	// test
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The configurations of the snapshot template. The value must be a JSON string. For more information about the data structure, see [SnapshotTemplateConfig](https://help.aliyun.com/document_detail/98618.html) and [DynamicImageTemplateConfig](https://help.aliyun.com/document_detail/98618.html).
	//
	// This parameter is required.
	//
	// example:
	//
	// {"SnapshotConfig":{"Count":10,"SpecifiedOffsetTime":0,"Interval":1,"FrameType":"normal"},"SnapshotType":"NormalSnapshot"}
	TemplateConfig *string `json:"TemplateConfig,omitempty" xml:"TemplateConfig,omitempty"`
	// The type of the template. Set the value to **Snapshot**.
	//
	// This parameter is required.
	//
	// example:
	//
	// Snapshot
	TemplateType *string `json:"TemplateType,omitempty" xml:"TemplateType,omitempty"`
}

func (s AddVodTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s AddVodTemplateRequest) GoString() string {
	return s.String()
}

func (s *AddVodTemplateRequest) SetAppId(v string) *AddVodTemplateRequest {
	s.AppId = &v
	return s
}

func (s *AddVodTemplateRequest) SetName(v string) *AddVodTemplateRequest {
	s.Name = &v
	return s
}

func (s *AddVodTemplateRequest) SetTemplateConfig(v string) *AddVodTemplateRequest {
	s.TemplateConfig = &v
	return s
}

func (s *AddVodTemplateRequest) SetTemplateType(v string) *AddVodTemplateRequest {
	s.TemplateType = &v
	return s
}

type AddVodTemplateResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A*****F6-D7393642CA58
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the snapshot template. You can call the [SubmitSnapshotJob](https://help.aliyun.com/document_detail/72213.html) operation to submit snapshot jobs.
	//
	// example:
	//
	// f5b228fe6930e*****0d6bf55bd87789
	VodTemplateId *string `json:"VodTemplateId,omitempty" xml:"VodTemplateId,omitempty"`
}

func (s AddVodTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddVodTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *AddVodTemplateResponseBody) SetRequestId(v string) *AddVodTemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddVodTemplateResponseBody) SetVodTemplateId(v string) *AddVodTemplateResponseBody {
	s.VodTemplateId = &v
	return s
}

type AddVodTemplateResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *AddVodTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AddVodTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s AddVodTemplateResponse) GoString() string {
	return s.String()
}

func (s *AddVodTemplateResponse) SetHeaders(v map[string]*string) *AddVodTemplateResponse {
	s.Headers = v
	return s
}

func (s *AddVodTemplateResponse) SetStatusCode(v int32) *AddVodTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *AddVodTemplateResponse) SetBody(v *AddVodTemplateResponseBody) *AddVodTemplateResponse {
	s.Body = v
	return s
}

type AddWatermarkRequest struct {
	// The ID of the application. Default value: **app-1000000**. If you have activated the multi-application service, specify the ID of the application to add the watermark template in the specified application. For more information, see [Overview](https://help.aliyun.com/document_detail/113600.html).
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The URL of the watermark file. The URL must be an Object Storage Service (OSS) URL and cannot contain the information used for URL signing.
	//
	// > 	- This parameter is required if you set `Type` to `Image`.
	//
	// > 	- You can obtain the URL from the `FileURL` parameter in the response to the [CreateUploadAttachedMedia](~~CreateUploadAttachedMedia~~) operation that you call to upload the watermark image to ApsaraVideo VOD.
	//
	// example:
	//
	// http://outin-326268*****63e1403e7.oss-cn-shanghai.aliyuncs.com/image/cover/C99345*****E7FDEC-6-2.png
	FileUrl *string `json:"FileUrl,omitempty" xml:"FileUrl,omitempty"`
	// The name of the watermark template.
	//
	// 	- Only letters and digits are supported.
	//
	// 	- The name cannot exceed 128 bytes.
	//
	// 	- The value must be encoded in UTF-8.
	//
	// This parameter is required.
	//
	// example:
	//
	// watermark
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of the watermark template. Valid values:
	//
	// 	- **Image*	- (default): image watermark template
	//
	// 	- **Text**: text watermark template
	//
	// This parameter is required.
	//
	// example:
	//
	// Text
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The configuration information of the watermark such as the display position and special effects. The value must be a JSON string. The configuration parameters for image and text watermarks are different. For more information about the parameter structure, see [WatermarkConfig](~~98618#section-h01-44s-2lr~~).
	//
	// This parameter is required.
	//
	// example:
	//
	// {"Width":"55","Height":"55","Dx":"9","Dy":"9","ReferPos":"BottonLeft"}
	WatermarkConfig *string `json:"WatermarkConfig,omitempty" xml:"WatermarkConfig,omitempty"`
}

func (s AddWatermarkRequest) String() string {
	return tea.Prettify(s)
}

func (s AddWatermarkRequest) GoString() string {
	return s.String()
}

func (s *AddWatermarkRequest) SetAppId(v string) *AddWatermarkRequest {
	s.AppId = &v
	return s
}

func (s *AddWatermarkRequest) SetFileUrl(v string) *AddWatermarkRequest {
	s.FileUrl = &v
	return s
}

func (s *AddWatermarkRequest) SetName(v string) *AddWatermarkRequest {
	s.Name = &v
	return s
}

func (s *AddWatermarkRequest) SetType(v string) *AddWatermarkRequest {
	s.Type = &v
	return s
}

func (s *AddWatermarkRequest) SetWatermarkConfig(v string) *AddWatermarkRequest {
	s.WatermarkConfig = &v
	return s
}

type AddWatermarkResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A*****F6-D7393642CA58
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the watermark template.
	WatermarkInfo *AddWatermarkResponseBodyWatermarkInfo `json:"WatermarkInfo,omitempty" xml:"WatermarkInfo,omitempty" type:"Struct"`
}

func (s AddWatermarkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddWatermarkResponseBody) GoString() string {
	return s.String()
}

func (s *AddWatermarkResponseBody) SetRequestId(v string) *AddWatermarkResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddWatermarkResponseBody) SetWatermarkInfo(v *AddWatermarkResponseBodyWatermarkInfo) *AddWatermarkResponseBody {
	s.WatermarkInfo = v
	return s
}

type AddWatermarkResponseBodyWatermarkInfo struct {
	// The time when the watermark template was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2018-11-07T09:05:52Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The URL of the watermark file. The URL is an Object Storage Service (OSS) URL or an Alibaba Cloud CDN URL.
	//
	// >  This parameter is returned only for image watermark templates.
	//
	// example:
	//
	// https://outin-3262*****9f4b3e7.oss-cn-shanghai.aliyuncs.com/image/cover/E6C3448CC8B715E6F8A72EC6B-6-2.png?Expires=1541600583&OSSAccessKeyId=****&Signature=gmf1eYMoDVg%2BHQCb4UGozBW****
	FileUrl *string `json:"FileUrl,omitempty" xml:"FileUrl,omitempty"`
	// Indicates whether the watermark template is the default one. Valid values:
	//
	// 	- **Default**
	//
	// 	- **NotDefault**
	//
	// example:
	//
	// NotDefault
	IsDefault *string `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	// The name of the watermark template.
	//
	// example:
	//
	// text watermark test
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of the watermark template.
	//
	// 	- **Image**: image watermark template
	//
	// 	- **Text**: text watermark template
	//
	// example:
	//
	// Text
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The configuration information of the watermark such as the display position and special effects. The value is a JSON string. The configuration parameters for image and text watermarks are different. For more information about the parameter structure, see [WatermarkConfig](~~98618#section-h01-44s-2lr~~).
	//
	// example:
	//
	// {"FontColor": "Blue","FontSize": 80, "Content": "watermark test" }
	WatermarkConfig *string `json:"WatermarkConfig,omitempty" xml:"WatermarkConfig,omitempty"`
	// The ID of the watermark template.
	//
	// example:
	//
	// 9bcc8bfadb84*****109a2671d0df97
	WatermarkId *string `json:"WatermarkId,omitempty" xml:"WatermarkId,omitempty"`
}

func (s AddWatermarkResponseBodyWatermarkInfo) String() string {
	return tea.Prettify(s)
}

func (s AddWatermarkResponseBodyWatermarkInfo) GoString() string {
	return s.String()
}

func (s *AddWatermarkResponseBodyWatermarkInfo) SetCreationTime(v string) *AddWatermarkResponseBodyWatermarkInfo {
	s.CreationTime = &v
	return s
}

func (s *AddWatermarkResponseBodyWatermarkInfo) SetFileUrl(v string) *AddWatermarkResponseBodyWatermarkInfo {
	s.FileUrl = &v
	return s
}

func (s *AddWatermarkResponseBodyWatermarkInfo) SetIsDefault(v string) *AddWatermarkResponseBodyWatermarkInfo {
	s.IsDefault = &v
	return s
}

func (s *AddWatermarkResponseBodyWatermarkInfo) SetName(v string) *AddWatermarkResponseBodyWatermarkInfo {
	s.Name = &v
	return s
}

func (s *AddWatermarkResponseBodyWatermarkInfo) SetType(v string) *AddWatermarkResponseBodyWatermarkInfo {
	s.Type = &v
	return s
}

func (s *AddWatermarkResponseBodyWatermarkInfo) SetWatermarkConfig(v string) *AddWatermarkResponseBodyWatermarkInfo {
	s.WatermarkConfig = &v
	return s
}

func (s *AddWatermarkResponseBodyWatermarkInfo) SetWatermarkId(v string) *AddWatermarkResponseBodyWatermarkInfo {
	s.WatermarkId = &v
	return s
}

type AddWatermarkResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *AddWatermarkResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AddWatermarkResponse) String() string {
	return tea.Prettify(s)
}

func (s AddWatermarkResponse) GoString() string {
	return s.String()
}

func (s *AddWatermarkResponse) SetHeaders(v map[string]*string) *AddWatermarkResponse {
	s.Headers = v
	return s
}

func (s *AddWatermarkResponse) SetStatusCode(v int32) *AddWatermarkResponse {
	s.StatusCode = &v
	return s
}

func (s *AddWatermarkResponse) SetBody(v *AddWatermarkResponseBody) *AddWatermarkResponse {
	s.Body = v
	return s
}

type AttachAppPolicyToIdentityRequest struct {
	// The ID of the application. Default value: **app-1000000**. For more information, see [Multi-application service](https://help.aliyun.com/document_detail/113600.html).
	//
	// > This parameter is optional only if you set the policy name to VODAppAdministratorAccess.
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the RAM user or the name of the RAM role.
	//
	// 	- Specify the ID of the RAM user when the IdentityType parameter is set to RamUser.
	//
	// 	- Specify the name of the RAM role when the IdentityType parameter is set to RamRole.
	//
	// This parameter is required.
	//
	// example:
	//
	// ****
	IdentityName *string `json:"IdentityName,omitempty" xml:"IdentityName,omitempty"`
	// The type of the identity. Valid values:
	//
	// 	- **RamUser**: a RAM user
	//
	// 	- **RamRole**: a RAM role
	//
	// This parameter is required.
	//
	// example:
	//
	// RamRole
	IdentityType *string `json:"IdentityType,omitempty" xml:"IdentityType,omitempty"`
	// The name of the policy. Only system policies are supported. Separate multiple policy names with commas (,). Valid values:
	//
	// 	- **VODAppFullAccess**: permissions to manage all resources in an application.
	//
	// 	- **VODAppReadOnlyAccess**: permissions to read all resources in an application.
	//
	// 	- **VODAppAdministratorAccess**: permissions of the application administrator.
	//
	// This parameter is required.
	//
	// example:
	//
	// VODAppFullAccess
	PolicyNames *string `json:"PolicyNames,omitempty" xml:"PolicyNames,omitempty"`
}

func (s AttachAppPolicyToIdentityRequest) String() string {
	return tea.Prettify(s)
}

func (s AttachAppPolicyToIdentityRequest) GoString() string {
	return s.String()
}

func (s *AttachAppPolicyToIdentityRequest) SetAppId(v string) *AttachAppPolicyToIdentityRequest {
	s.AppId = &v
	return s
}

func (s *AttachAppPolicyToIdentityRequest) SetIdentityName(v string) *AttachAppPolicyToIdentityRequest {
	s.IdentityName = &v
	return s
}

func (s *AttachAppPolicyToIdentityRequest) SetIdentityType(v string) *AttachAppPolicyToIdentityRequest {
	s.IdentityType = &v
	return s
}

func (s *AttachAppPolicyToIdentityRequest) SetPolicyNames(v string) *AttachAppPolicyToIdentityRequest {
	s.PolicyNames = &v
	return s
}

type AttachAppPolicyToIdentityResponseBody struct {
	// The names of the policies that failed to be granted to the RAM user or RAM role.
	FailedPolicyNames []*string `json:"FailedPolicyNames,omitempty" xml:"FailedPolicyNames,omitempty" type:"Repeated"`
	// The names of the policies that were not found.
	NonExistPolicyNames []*string `json:"NonExistPolicyNames,omitempty" xml:"NonExistPolicyNames,omitempty" type:"Repeated"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A13-****-D7393642CA58
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AttachAppPolicyToIdentityResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AttachAppPolicyToIdentityResponseBody) GoString() string {
	return s.String()
}

func (s *AttachAppPolicyToIdentityResponseBody) SetFailedPolicyNames(v []*string) *AttachAppPolicyToIdentityResponseBody {
	s.FailedPolicyNames = v
	return s
}

func (s *AttachAppPolicyToIdentityResponseBody) SetNonExistPolicyNames(v []*string) *AttachAppPolicyToIdentityResponseBody {
	s.NonExistPolicyNames = v
	return s
}

func (s *AttachAppPolicyToIdentityResponseBody) SetRequestId(v string) *AttachAppPolicyToIdentityResponseBody {
	s.RequestId = &v
	return s
}

type AttachAppPolicyToIdentityResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *AttachAppPolicyToIdentityResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AttachAppPolicyToIdentityResponse) String() string {
	return tea.Prettify(s)
}

func (s AttachAppPolicyToIdentityResponse) GoString() string {
	return s.String()
}

func (s *AttachAppPolicyToIdentityResponse) SetHeaders(v map[string]*string) *AttachAppPolicyToIdentityResponse {
	s.Headers = v
	return s
}

func (s *AttachAppPolicyToIdentityResponse) SetStatusCode(v int32) *AttachAppPolicyToIdentityResponse {
	s.StatusCode = &v
	return s
}

func (s *AttachAppPolicyToIdentityResponse) SetBody(v *AttachAppPolicyToIdentityResponseBody) *AttachAppPolicyToIdentityResponse {
	s.Body = v
	return s
}

type BatchGetMediaInfosRequest struct {
	// The ID of the media asset. The ID can be the video ID or audio ID. Separate IDs with commas (,). You can specify a maximum of 20 IDs. You can use one of the following methods to obtain the ID of the media asset:
	//
	// 	- Log on to the ApsaraVideo VOD console. In the left-side navigation pane, choose Media Files > Audio/Video. On the Video and Audio page, view the ID of the media asset. This method is applicable to files that are uploaded by using the ApsaraVideo VOD console.
	//
	// 	- Obtain the value of VideoId from the response to the CreateUploadVideo operation that you call to upload media assets.
	//
	// 	- Obtain the value of VideoId from the response to the SearchMedia operation that you call to query the media ID after the media asset is uploaded.
	//
	// This parameter is required.
	//
	// example:
	//
	// 61ccbdb06fa83012be4d8083f6****,7d2fbc380b0e08e55f****
	MediaIds *string `json:"MediaIds,omitempty" xml:"MediaIds,omitempty"`
}

func (s BatchGetMediaInfosRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchGetMediaInfosRequest) GoString() string {
	return s.String()
}

func (s *BatchGetMediaInfosRequest) SetMediaIds(v string) *BatchGetMediaInfosRequest {
	s.MediaIds = &v
	return s
}

type BatchGetMediaInfosResponseBody struct {
	// The IDs of the media assets that do not support the operation typically because you are not authorized to perform the operation. For more information, see [Overview](https://help.aliyun.com/document_detail/113600.html).
	ForbiddenMediaIds []*string `json:"ForbiddenMediaIds,omitempty" xml:"ForbiddenMediaIds,omitempty" type:"Repeated"`
	// Details about media assets.
	MediaInfos []*BatchGetMediaInfosResponseBodyMediaInfos `json:"MediaInfos,omitempty" xml:"MediaInfos,omitempty" type:"Repeated"`
	// The IDs of the media assets that do not exist.
	NonExistMediaIds []*string `json:"NonExistMediaIds,omitempty" xml:"NonExistMediaIds,omitempty" type:"Repeated"`
	// The request ID.
	//
	// example:
	//
	// 9E290613-04F4-47F4-795D30732077****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BatchGetMediaInfosResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchGetMediaInfosResponseBody) GoString() string {
	return s.String()
}

func (s *BatchGetMediaInfosResponseBody) SetForbiddenMediaIds(v []*string) *BatchGetMediaInfosResponseBody {
	s.ForbiddenMediaIds = v
	return s
}

func (s *BatchGetMediaInfosResponseBody) SetMediaInfos(v []*BatchGetMediaInfosResponseBodyMediaInfos) *BatchGetMediaInfosResponseBody {
	s.MediaInfos = v
	return s
}

func (s *BatchGetMediaInfosResponseBody) SetNonExistMediaIds(v []*string) *BatchGetMediaInfosResponseBody {
	s.NonExistMediaIds = v
	return s
}

func (s *BatchGetMediaInfosResponseBody) SetRequestId(v string) *BatchGetMediaInfosResponseBody {
	s.RequestId = &v
	return s
}

type BatchGetMediaInfosResponseBodyMediaInfos struct {
	// The ID of the media asset.
	//
	// example:
	//
	// 10a5fa364a5b71ef89246733a78e****
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The basic information of the media asset.
	MediaInfo *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo `json:"MediaInfo,omitempty" xml:"MediaInfo,omitempty" type:"Struct"`
	// The source file information.
	MezzanineInfo *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo `json:"MezzanineInfo,omitempty" xml:"MezzanineInfo,omitempty" type:"Struct"`
	// The information about the audio or video stream.
	PlayInfoList []*BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList `json:"PlayInfoList,omitempty" xml:"PlayInfoList,omitempty" type:"Repeated"`
}

func (s BatchGetMediaInfosResponseBodyMediaInfos) String() string {
	return tea.Prettify(s)
}

func (s BatchGetMediaInfosResponseBodyMediaInfos) GoString() string {
	return s.String()
}

func (s *BatchGetMediaInfosResponseBodyMediaInfos) SetMediaId(v string) *BatchGetMediaInfosResponseBodyMediaInfos {
	s.MediaId = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfos) SetMediaInfo(v *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo) *BatchGetMediaInfosResponseBodyMediaInfos {
	s.MediaInfo = v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfos) SetMezzanineInfo(v *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo) *BatchGetMediaInfosResponseBodyMediaInfos {
	s.MezzanineInfo = v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfos) SetPlayInfoList(v []*BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList) *BatchGetMediaInfosResponseBodyMediaInfos {
	s.PlayInfoList = v
	return s
}

type BatchGetMediaInfosResponseBodyMediaInfosMediaInfo struct {
	// The ID of the application.
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the category.
	//
	// example:
	//
	// 781111****
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The name of the category.
	//
	// example:
	//
	// CateName
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	// The thumbnail URL of the media asset.
	//
	// example:
	//
	// https://example.aliyundoc.com/****.jpg
	CoverURL *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	// The time when the media asset was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-11-14T09:15:50Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the media asset.
	//
	// example:
	//
	// Aliyun VOD Video Description
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether the offline download feature is enabled. If you enable the offline download feature, users can download and play videos by using the ApsaraVideo Player on a local PC. For more information, see [Configure download settings](https://help.aliyun.com/document_detail/86107.html). Valid values:
	//
	// 	- **on**
	//
	// 	- **off**
	//
	// example:
	//
	// on
	DownloadSwitch *string `json:"DownloadSwitch,omitempty" xml:"DownloadSwitch,omitempty"`
	// The ID of the media asset.
	//
	// example:
	//
	// 7753d144efd74d6c45fe0570****
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The time when the media asset was last updated. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-06-26T06:38:48Z
	ModificationTime *string `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	// The period of time in which the audio file remains in the restored state.
	//
	// example:
	//
	// 2023-03-30T10:14:14Z
	RestoreExpiration *string `json:"RestoreExpiration,omitempty" xml:"RestoreExpiration,omitempty"`
	// The restoration status of the media asset. Valid values:
	//
	// 	- **Processing**
	//
	// 	- **Success**
	//
	// 	- **Failed**
	//
	// example:
	//
	// Success
	RestoreStatus *string `json:"RestoreStatus,omitempty" xml:"RestoreStatus,omitempty"`
	// The array of video snapshot URLs.
	Snapshots []*string `json:"Snapshots,omitempty" xml:"Snapshots,omitempty" type:"Repeated"`
	// The status of the video. Valid values:
	//
	// 	- **Uploading**
	//
	// 	- **UploadFail**
	//
	// 	- **UploadSucc**
	//
	// 	- **Transcoding**
	//
	// 	- **TranscodeFail**
	//
	// 	- **Blocked**
	//
	// 	- **Normal**
	//
	// example:
	//
	// Normal
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The storage type. Valid values:
	//
	// 	- **Standard**: All media assets are stored as Standard objects.
	//
	// 	- **IA**: All media assets are stored as IA objects.
	//
	// 	- **Archive**: All media assets are stored as Archive objects.
	//
	// 	- **ColdArchive**: All media assets are stored as Cold Archive objects.
	//
	// 	- **SourceIA**: Only the source files are IA objects.
	//
	// 	- **SourceArchive**: Only the source files are Archive objects.
	//
	// 	- **SourceColdArchive**: Only the source file is stored as a Cold Archive object.
	//
	// 	- **Changing**: The storage class of the media asset is being changed.
	//
	// 	- **SourceChanging**: The storage class of the media asset is being changed.
	//
	// example:
	//
	// Standard
	StorageClass *string `json:"StorageClass,omitempty" xml:"StorageClass,omitempty"`
	// The storage address of the media asset.
	//
	// example:
	//
	// outin-***.oss-cn-shanghai.aliyuncs.com
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	// The tags of the media asset. Separate tags with commas (,).
	//
	// example:
	//
	// tag1,tag2
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The ID of the transcoding template group.
	//
	// example:
	//
	// b4039216985f4312a5382a4ed****
	TemplateGroupId *string `json:"TemplateGroupId,omitempty" xml:"TemplateGroupId,omitempty"`
	// The title of the media asset.
	//
	// example:
	//
	// Aliyun VOD Video Title
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The custom parameters.
	//
	// example:
	//
	// {"Extend":"xxx","MessageCallback":"xxx"}
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
}

func (s BatchGetMediaInfosResponseBodyMediaInfosMediaInfo) String() string {
	return tea.Prettify(s)
}

func (s BatchGetMediaInfosResponseBodyMediaInfosMediaInfo) GoString() string {
	return s.String()
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo) SetAppId(v string) *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo {
	s.AppId = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo) SetCateId(v int64) *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo {
	s.CateId = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo) SetCateName(v string) *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo {
	s.CateName = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo) SetCoverURL(v string) *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo {
	s.CoverURL = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo) SetCreationTime(v string) *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo {
	s.CreationTime = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo) SetDescription(v string) *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo {
	s.Description = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo) SetDownloadSwitch(v string) *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo {
	s.DownloadSwitch = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo) SetMediaId(v string) *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo {
	s.MediaId = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo) SetModificationTime(v string) *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo {
	s.ModificationTime = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo) SetRestoreExpiration(v string) *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo {
	s.RestoreExpiration = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo) SetRestoreStatus(v string) *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo {
	s.RestoreStatus = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo) SetSnapshots(v []*string) *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo {
	s.Snapshots = v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo) SetStatus(v string) *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo {
	s.Status = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo) SetStorageClass(v string) *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo {
	s.StorageClass = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo) SetStorageLocation(v string) *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo {
	s.StorageLocation = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo) SetTags(v string) *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo {
	s.Tags = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo) SetTemplateGroupId(v string) *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo {
	s.TemplateGroupId = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo) SetTitle(v string) *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo {
	s.Title = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo) SetUserData(v string) *BatchGetMediaInfosResponseBodyMediaInfosMediaInfo {
	s.UserData = &v
	return s
}

type BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo struct {
	// The information about the audio stream.
	AudioStreamList []*BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList `json:"AudioStreamList,omitempty" xml:"AudioStreamList,omitempty" type:"Repeated"`
	// The bitrate of the file. Unit: Kbit/s.
	//
	// example:
	//
	// 771.2280
	Bitrate *string `json:"Bitrate,omitempty" xml:"Bitrate,omitempty"`
	// The time when the source file was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-11-14T09:15:50Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The duration of the file. Unit: seconds.
	//
	// example:
	//
	// 42.4930
	Duration *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The name of the file.
	//
	// example:
	//
	// 27ffc438-164h67f57ef-0005-6884-51a-1****.mp4
	FileName *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	// The OSS URL of the source file.
	//
	// example:
	//
	// http://example-bucket-****.oss-cn-shanghai.aliyuncs.com/27ffc438-164h67f57ef-0005-6884-51a-1****.mp4
	FileURL *string `json:"FileURL,omitempty" xml:"FileURL,omitempty"`
	// The frame rate of the file.
	//
	// example:
	//
	// 25.0000
	Fps *string `json:"Fps,omitempty" xml:"Fps,omitempty"`
	// The height of the file. Unit: pixels.
	//
	// example:
	//
	// 540
	Height *int64 `json:"Height,omitempty" xml:"Height,omitempty"`
	// The ID of the media asset.
	//
	// example:
	//
	// 1f1a6fc03ca04814031b8a6559e****
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The size of the file. Unit: bytes.
	//
	// example:
	//
	// 4096477
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The state of the file. Valid values:
	//
	// 	- **Uploading**: The file is being uploaded. This is the initial status.
	//
	// 	- **Normal**: The file is uploaded.
	//
	// 	- **UploadFail**: The file failed to be uploaded.
	//
	// 	- **Deleted**: The file is deleted.
	//
	// example:
	//
	// Normal
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The information about the video streams.
	VideoStreamList []*BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList `json:"VideoStreamList,omitempty" xml:"VideoStreamList,omitempty" type:"Repeated"`
	// The width of the file. Unit: pixels.
	//
	// example:
	//
	// 960
	Width *int64 `json:"Width,omitempty" xml:"Width,omitempty"`
}

func (s BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo) String() string {
	return tea.Prettify(s)
}

func (s BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo) GoString() string {
	return s.String()
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo) SetAudioStreamList(v []*BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo {
	s.AudioStreamList = v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo) SetBitrate(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo {
	s.Bitrate = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo) SetCreationTime(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo {
	s.CreationTime = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo) SetDuration(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo {
	s.Duration = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo) SetFileName(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo {
	s.FileName = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo) SetFileURL(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo {
	s.FileURL = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo) SetFps(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo {
	s.Fps = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo) SetHeight(v int64) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo {
	s.Height = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo) SetMediaId(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo {
	s.MediaId = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo) SetSize(v int64) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo {
	s.Size = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo) SetStatus(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo {
	s.Status = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo) SetVideoStreamList(v []*BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo {
	s.VideoStreamList = v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo) SetWidth(v int64) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfo {
	s.Width = &v
	return s
}

type BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList struct {
	// The bitrate.
	//
	// example:
	//
	// 62.885
	Bitrate *string `json:"Bitrate,omitempty" xml:"Bitrate,omitempty"`
	// The output layout of the audio channels. Valid values:
	//
	// 	- **mono**
	//
	// 	- **stereo**
	//
	// example:
	//
	// mono
	ChannelLayout *string `json:"ChannelLayout,omitempty" xml:"ChannelLayout,omitempty"`
	// The number of sound tracks.
	//
	// example:
	//
	// 1
	Channels *string `json:"Channels,omitempty" xml:"Channels,omitempty"`
	// The full name of the encoding format.
	//
	// example:
	//
	// AAC (Advanced Audio Coding)
	CodecLongName *string `json:"CodecLongName,omitempty" xml:"CodecLongName,omitempty"`
	// The short name of the encoding format.
	//
	// example:
	//
	// aac
	CodecName *string `json:"CodecName,omitempty" xml:"CodecName,omitempty"`
	// The tag of the encoding format.
	//
	// example:
	//
	// 0x6134706d
	CodecTag *string `json:"CodecTag,omitempty" xml:"CodecTag,omitempty"`
	// The tag string of the encoding format.
	//
	// example:
	//
	// mp4a
	CodecTagString *string `json:"CodecTagString,omitempty" xml:"CodecTagString,omitempty"`
	// The time base of the encoder.
	//
	// example:
	//
	// 1/44100
	CodecTimeBase *string `json:"CodecTimeBase,omitempty" xml:"CodecTimeBase,omitempty"`
	// The duration.
	//
	// example:
	//
	// 3.227574
	Duration *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The sequence number of the audio stream. The value indicates the position of the audio stream in all audio streams.
	//
	// example:
	//
	// 0
	Index *string `json:"Index,omitempty" xml:"Index,omitempty"`
	// The language.
	//
	// example:
	//
	// und
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The total number of frames.
	//
	// example:
	//
	// 1
	NumFrames *string `json:"NumFrames,omitempty" xml:"NumFrames,omitempty"`
	// The sampling format.
	//
	// example:
	//
	// fltp
	SampleFmt *string `json:"SampleFmt,omitempty" xml:"SampleFmt,omitempty"`
	// The sampling rate.
	//
	// example:
	//
	// 44100
	SampleRate *string `json:"SampleRate,omitempty" xml:"SampleRate,omitempty"`
	// The start time. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-01-11T12:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The time base.
	//
	// example:
	//
	// 0.000000
	Timebase *string `json:"Timebase,omitempty" xml:"Timebase,omitempty"`
}

func (s BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList) String() string {
	return tea.Prettify(s)
}

func (s BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList) GoString() string {
	return s.String()
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList) SetBitrate(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList {
	s.Bitrate = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList) SetChannelLayout(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList {
	s.ChannelLayout = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList) SetChannels(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList {
	s.Channels = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList) SetCodecLongName(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList {
	s.CodecLongName = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList) SetCodecName(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList {
	s.CodecName = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList) SetCodecTag(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList {
	s.CodecTag = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList) SetCodecTagString(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList {
	s.CodecTagString = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList) SetCodecTimeBase(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList {
	s.CodecTimeBase = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList) SetDuration(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList {
	s.Duration = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList) SetIndex(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList {
	s.Index = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList) SetLang(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList {
	s.Lang = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList) SetNumFrames(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList {
	s.NumFrames = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList) SetSampleFmt(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList {
	s.SampleFmt = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList) SetSampleRate(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList {
	s.SampleRate = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList) SetStartTime(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList {
	s.StartTime = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList) SetTimebase(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoAudioStreamList {
	s.Timebase = &v
	return s
}

type BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList struct {
	// The average frame rate.
	//
	// example:
	//
	// 30.0
	AvgFPS *string `json:"AvgFPS,omitempty" xml:"AvgFPS,omitempty"`
	// The bitrate of the file. Unit: Kbit/s.
	//
	// example:
	//
	// 500
	Bitrate *string `json:"Bitrate,omitempty" xml:"Bitrate,omitempty"`
	// The full name of the encoding format.
	//
	// example:
	//
	// H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10
	CodecLongName *string `json:"CodecLongName,omitempty" xml:"CodecLongName,omitempty"`
	// The short name of the encoding format.
	//
	// example:
	//
	// h264
	CodecName *string `json:"CodecName,omitempty" xml:"CodecName,omitempty"`
	// The tag of the encoding format.
	//
	// example:
	//
	// 0x31637661
	CodecTag *string `json:"CodecTag,omitempty" xml:"CodecTag,omitempty"`
	// The tag string of the encoding format.
	//
	// example:
	//
	// avc1
	CodecTagString *string `json:"CodecTagString,omitempty" xml:"CodecTagString,omitempty"`
	// The time base of the encoder.
	//
	// example:
	//
	// 1/60
	CodecTimeBase *string `json:"CodecTimeBase,omitempty" xml:"CodecTimeBase,omitempty"`
	// The display aspect ratio (DAR).
	//
	// example:
	//
	// 0:1
	Dar *string `json:"Dar,omitempty" xml:"Dar,omitempty"`
	// The duration.
	//
	// example:
	//
	// 3.166667
	Duration *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The frame rate of the output file.
	//
	// example:
	//
	// 30.0
	Fps *string `json:"Fps,omitempty" xml:"Fps,omitempty"`
	// The HDR type of the video stream.
	//
	// example:
	//
	// HDR
	HDRType *string `json:"HDRType,omitempty" xml:"HDRType,omitempty"`
	// Indicates whether the video stream contains bidirectional frames (B-frames).
	//
	// example:
	//
	// 0
	HasBFrames *string `json:"HasBFrames,omitempty" xml:"HasBFrames,omitempty"`
	// The height of the video stream.
	//
	// example:
	//
	// 320
	Height *string `json:"Height,omitempty" xml:"Height,omitempty"`
	// The sequence number of the video stream. The value identifies the position of the video stream in all video streams.
	//
	// example:
	//
	// 1
	Index *string `json:"Index,omitempty" xml:"Index,omitempty"`
	// The language.
	//
	// example:
	//
	// und
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The codec level.
	//
	// example:
	//
	// 30
	Level *string `json:"Level,omitempty" xml:"Level,omitempty"`
	// The total number of frames.
	//
	// example:
	//
	// 0
	NumFrames *string `json:"NumFrames,omitempty" xml:"NumFrames,omitempty"`
	// The pixel format of the video stream.
	//
	// example:
	//
	// yuv420p
	PixFmt *string `json:"PixFmt,omitempty" xml:"PixFmt,omitempty"`
	// The codec profile.
	//
	// example:
	//
	// Main
	Profile *string `json:"Profile,omitempty" xml:"Profile,omitempty"`
	// The rotation angle of the video. Valid values: [0,360).
	//
	// example:
	//
	// 90
	Rotate *string `json:"Rotate,omitempty" xml:"Rotate,omitempty"`
	// The sample aspect ratio (SAR).
	//
	// example:
	//
	// 0:1
	Sar *string `json:"Sar,omitempty" xml:"Sar,omitempty"`
	// The start time. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-01-11T12:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The time base.
	//
	// example:
	//
	// 0.000000
	Timebase *string `json:"Timebase,omitempty" xml:"Timebase,omitempty"`
	// The horizontal resolution of the video.
	//
	// example:
	//
	// 568
	Width *string `json:"Width,omitempty" xml:"Width,omitempty"`
}

func (s BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList) String() string {
	return tea.Prettify(s)
}

func (s BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList) GoString() string {
	return s.String()
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList) SetAvgFPS(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList {
	s.AvgFPS = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList) SetBitrate(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList {
	s.Bitrate = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList) SetCodecLongName(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList {
	s.CodecLongName = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList) SetCodecName(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList {
	s.CodecName = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList) SetCodecTag(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList {
	s.CodecTag = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList) SetCodecTagString(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList {
	s.CodecTagString = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList) SetCodecTimeBase(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList {
	s.CodecTimeBase = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList) SetDar(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList {
	s.Dar = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList) SetDuration(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList {
	s.Duration = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList) SetFps(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList {
	s.Fps = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList) SetHDRType(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList {
	s.HDRType = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList) SetHasBFrames(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList {
	s.HasBFrames = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList) SetHeight(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList {
	s.Height = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList) SetIndex(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList {
	s.Index = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList) SetLang(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList {
	s.Lang = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList) SetLevel(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList {
	s.Level = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList) SetNumFrames(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList {
	s.NumFrames = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList) SetPixFmt(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList {
	s.PixFmt = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList) SetProfile(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList {
	s.Profile = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList) SetRotate(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList {
	s.Rotate = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList) SetSar(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList {
	s.Sar = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList) SetStartTime(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList {
	s.StartTime = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList) SetTimebase(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList {
	s.Timebase = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList) SetWidth(v string) *BatchGetMediaInfosResponseBodyMediaInfosMezzanineInfoVideoStreamList {
	s.Width = &v
	return s
}

type BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList struct {
	// The color depth. This value is an integer.
	//
	// example:
	//
	// 8
	BitDepth *int32 `json:"BitDepth,omitempty" xml:"BitDepth,omitempty"`
	// The bitrate of the media stream. Unit: Kbit/s.
	//
	// example:
	//
	// 450.878
	Bitrate *string `json:"Bitrate,omitempty" xml:"Bitrate,omitempty"`
	// The short name of the codec.
	//
	// example:
	//
	// h264
	CodecName *string `json:"CodecName,omitempty" xml:"CodecName,omitempty"`
	// The creation time. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	//
	// example:
	//
	// 2022-04-18T07:37:15Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The quality of the video stream. Valid values:
	//
	// 	- **FD**: low definition
	//
	// 	- **LD**: standard definition
	//
	// 	- **SD**: high definition
	//
	// 	- **HD**: ultra-high definition
	//
	// 	- **OD**: original definition
	//
	// 	- **2K**
	//
	// 	- **4K**
	//
	// 	- **SQ**: standard sound quality
	//
	// 	- **HQ**: high sound quality
	//
	// 	- **AUTO**: adaptive bitrate
	//
	// example:
	//
	// LD
	Definition *string `json:"Definition,omitempty" xml:"Definition,omitempty"`
	// The duration of the media stream. Unit: seconds.
	//
	// example:
	//
	// 9.0464
	Duration *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// Indicates whether the media stream was encrypted. Valid values:
	//
	// 	- **0**: The media stream is not encrypted.
	//
	// 	- **1**: The media stream is encrypted.
	//
	// example:
	//
	// 1
	Encrypt *int64 `json:"Encrypt,omitempty" xml:"Encrypt,omitempty"`
	// The encryption type of the media stream. Valid values:
	//
	// 	- **License**: decryption on local devices.
	//
	// >  If the encryption type is **License**, only ApsaraVideo Player SDK can be used to play videos.
	//
	// example:
	//
	// License
	EncryptMode *string `json:"EncryptMode,omitempty" xml:"EncryptMode,omitempty"`
	// The encryption type of the media stream. Valid values:
	//
	// 	- **AliyunVoDEncryption**: Alibaba Cloud proprietary cryptography
	//
	// 	- **HLSEncryption**: HTTP Live Streaming (HLS) encryption
	//
	// >  If the encryption type is AliyunVoDEncryption, only ApsaraVideo Player SDK can be used to play videos.
	//
	// example:
	//
	// AliyunVoDEncryption
	EncryptType *string `json:"EncryptType,omitempty" xml:"EncryptType,omitempty"`
	// The format of the media stream.
	//
	// 	- If the media file is a video file, the valid values are **mp4*	- and **m3u8**.
	//
	// 	- If the media asset is an audio-only file, the value is **mp3**.
	//
	// example:
	//
	// m3u8
	Format *string `json:"Format,omitempty" xml:"Format,omitempty"`
	// The frame rate of the media stream. Unit: frames per second (FPS).
	//
	// example:
	//
	// 25
	Fps *string `json:"Fps,omitempty" xml:"Fps,omitempty"`
	// The HDR type of the media stream. Valid values:
	//
	// 	- HDR
	//
	// 	- HDR10
	//
	// 	- HLG
	//
	// 	- DolbyVision
	//
	// 	- HDRVivid
	//
	// 	- SDR+
	//
	// example:
	//
	// HLG
	HDRType *string `json:"HDRType,omitempty" xml:"HDRType,omitempty"`
	// The height of the media stream. Unit: pixels.
	//
	// example:
	//
	// 640
	Height *int64 `json:"Height,omitempty" xml:"Height,omitempty"`
	// The custom watermark information of the copyright watermark. This parameter is returned if you set `JobType` to `2`.
	//
	// example:
	//
	// CopyrightMarkTest
	JobExt *string `json:"JobExt,omitempty" xml:"JobExt,omitempty"`
	// The job ID for transcoding the media stream. This ID uniquely identifies a media stream.
	//
	// example:
	//
	// 80e9c6580e754a798c3c19c59b16****
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The type of the digital watermark. Valid values:
	//
	// 	- **1**: user-tracing watermark
	//
	// 	- **2**: copyright watermark
	//
	// example:
	//
	// 2
	JobType *int32 `json:"JobType,omitempty" xml:"JobType,omitempty"`
	// The update time. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	//
	// example:
	//
	// 2022-04-20T06:32:19Z
	ModificationTime *string `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	// The transcoding type. Valid values:
	//
	// 	- **0**: regular transcoding
	//
	// 	- **1.0**: Narrowband HD™ 1.0 transcoding
	//
	// 	- **2.0**: Narrowband HD™ 2.0 transcoding
	//
	// example:
	//
	// 0
	NarrowBandType *string `json:"NarrowBandType,omitempty" xml:"NarrowBandType,omitempty"`
	// The playback URL of the video stream.
	PlayURL *string `json:"PlayURL,omitempty" xml:"PlayURL,omitempty"`
	// The size of the media stream. Unit: bytes.
	//
	// example:
	//
	// 418112
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The specifications of transcoded audio and video streams. For more information about the valid values, see [Output specifications](~~124671#section-6bv-l0g-opq~~).
	//
	// example:
	//
	// H264.LD
	Specification *string `json:"Specification,omitempty" xml:"Specification,omitempty"`
	// The status of the audio or video stream. Valid values:
	//
	// 	- **Normal**: The latest transcoded stream in each quality and format is in the Normal status.
	//
	// 	- **Invisible**: If multiple streams are transcoded in the same quality and format, the latest transcoded stream is in the Normal status and other streams are in the Invisible status.
	//
	// example:
	//
	// Normal
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the media stream. If the media stream is a video stream, the value is **video**. If the media stream is an audio-only stream, the value is **audio**.
	//
	// example:
	//
	// video
	StreamType *string `json:"StreamType,omitempty" xml:"StreamType,omitempty"`
	// The ID of the transcoding template group.
	//
	// example:
	//
	// fb0716154b21a4ecb5b70a26ccc8****
	TemplateGroupId *string `json:"TemplateGroupId,omitempty" xml:"TemplateGroupId,omitempty"`
	// The ID of the transcoding template.
	//
	// example:
	//
	// a86a4338dd2e83da45154004a541****
	TemplateId *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The ID of the watermark that is associated with the media stream.
	//
	// example:
	//
	// dgfn26457856****
	WatermarkId *string `json:"WatermarkId,omitempty" xml:"WatermarkId,omitempty"`
	// The width of the media stream. Unit: pixels.
	//
	// example:
	//
	// 360
	Width *int64 `json:"Width,omitempty" xml:"Width,omitempty"`
}

func (s BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList) String() string {
	return tea.Prettify(s)
}

func (s BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList) GoString() string {
	return s.String()
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList) SetBitDepth(v int32) *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList {
	s.BitDepth = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList) SetBitrate(v string) *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList {
	s.Bitrate = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList) SetCodecName(v string) *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList {
	s.CodecName = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList) SetCreationTime(v string) *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList {
	s.CreationTime = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList) SetDefinition(v string) *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList {
	s.Definition = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList) SetDuration(v string) *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList {
	s.Duration = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList) SetEncrypt(v int64) *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList {
	s.Encrypt = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList) SetEncryptMode(v string) *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList {
	s.EncryptMode = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList) SetEncryptType(v string) *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList {
	s.EncryptType = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList) SetFormat(v string) *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList {
	s.Format = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList) SetFps(v string) *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList {
	s.Fps = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList) SetHDRType(v string) *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList {
	s.HDRType = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList) SetHeight(v int64) *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList {
	s.Height = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList) SetJobExt(v string) *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList {
	s.JobExt = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList) SetJobId(v string) *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList {
	s.JobId = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList) SetJobType(v int32) *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList {
	s.JobType = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList) SetModificationTime(v string) *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList {
	s.ModificationTime = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList) SetNarrowBandType(v string) *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList {
	s.NarrowBandType = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList) SetPlayURL(v string) *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList {
	s.PlayURL = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList) SetSize(v int64) *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList {
	s.Size = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList) SetSpecification(v string) *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList {
	s.Specification = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList) SetStatus(v string) *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList {
	s.Status = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList) SetStreamType(v string) *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList {
	s.StreamType = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList) SetTemplateGroupId(v string) *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList {
	s.TemplateGroupId = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList) SetTemplateId(v string) *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList {
	s.TemplateId = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList) SetWatermarkId(v string) *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList {
	s.WatermarkId = &v
	return s
}

func (s *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList) SetWidth(v int64) *BatchGetMediaInfosResponseBodyMediaInfosPlayInfoList {
	s.Width = &v
	return s
}

type BatchGetMediaInfosResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *BatchGetMediaInfosResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s BatchGetMediaInfosResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchGetMediaInfosResponse) GoString() string {
	return s.String()
}

func (s *BatchGetMediaInfosResponse) SetHeaders(v map[string]*string) *BatchGetMediaInfosResponse {
	s.Headers = v
	return s
}

func (s *BatchGetMediaInfosResponse) SetStatusCode(v int32) *BatchGetMediaInfosResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchGetMediaInfosResponse) SetBody(v *BatchGetMediaInfosResponseBody) *BatchGetMediaInfosResponse {
	s.Body = v
	return s
}

type BatchSetVodDomainConfigsRequest struct {
	// The domain name for CDN. Separate multiple domain names with commas (,).
	//
	// This parameter is required.
	//
	// example:
	//
	// example.com
	DomainNames *string `json:"DomainNames,omitempty" xml:"DomainNames,omitempty"`
	// The features to configure.
	//
	// 	- Set this parameter in the following format: `[{"functionArgs":[{"argName":"domain_name","argValue":"www.example.com"}],"functionName":"set_req_host_header"}]`.
	//
	// 	- Specific features, such as filetype_based_ttl_set, support more than one configuration record. To update one of the configuration records, use the configId field to specify the record. `[{"functionArgs":[{"argName":"file_type","argValue":"jpg"},{"argName":"ttl","argValue":"18"},{"argName":"weight","argValue":"30"}],"functionName":"filetype_based_ttl_set","configId":5068995}]`
	//
	// 	- For more information, see the **Feature description*	- section.
	//
	// This parameter is required.
	//
	// example:
	//
	// [{"functionArgs":[{"argName":"domain_name","argValue":"www.example.com"}],"functionName":"set_req_host_header"}]
	Functions     *string `json:"Functions,omitempty" xml:"Functions,omitempty"`
	OwnerAccount  *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s BatchSetVodDomainConfigsRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchSetVodDomainConfigsRequest) GoString() string {
	return s.String()
}

func (s *BatchSetVodDomainConfigsRequest) SetDomainNames(v string) *BatchSetVodDomainConfigsRequest {
	s.DomainNames = &v
	return s
}

func (s *BatchSetVodDomainConfigsRequest) SetFunctions(v string) *BatchSetVodDomainConfigsRequest {
	s.Functions = &v
	return s
}

func (s *BatchSetVodDomainConfigsRequest) SetOwnerAccount(v string) *BatchSetVodDomainConfigsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *BatchSetVodDomainConfigsRequest) SetOwnerId(v int64) *BatchSetVodDomainConfigsRequest {
	s.OwnerId = &v
	return s
}

func (s *BatchSetVodDomainConfigsRequest) SetSecurityToken(v string) *BatchSetVodDomainConfigsRequest {
	s.SecurityToken = &v
	return s
}

type BatchSetVodDomainConfigsResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 04F0F334-1335-436C-****-6C044FE73368
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BatchSetVodDomainConfigsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchSetVodDomainConfigsResponseBody) GoString() string {
	return s.String()
}

func (s *BatchSetVodDomainConfigsResponseBody) SetRequestId(v string) *BatchSetVodDomainConfigsResponseBody {
	s.RequestId = &v
	return s
}

type BatchSetVodDomainConfigsResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *BatchSetVodDomainConfigsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s BatchSetVodDomainConfigsResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchSetVodDomainConfigsResponse) GoString() string {
	return s.String()
}

func (s *BatchSetVodDomainConfigsResponse) SetHeaders(v map[string]*string) *BatchSetVodDomainConfigsResponse {
	s.Headers = v
	return s
}

func (s *BatchSetVodDomainConfigsResponse) SetStatusCode(v int32) *BatchSetVodDomainConfigsResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchSetVodDomainConfigsResponse) SetBody(v *BatchSetVodDomainConfigsResponseBody) *BatchSetVodDomainConfigsResponse {
	s.Body = v
	return s
}

type BatchStartVodDomainRequest struct {
	// The accelerated domain name. Separate multiple domain names with commas (,).
	//
	// This parameter is required.
	//
	// example:
	//
	// example.com
	DomainNames   *string `json:"DomainNames,omitempty" xml:"DomainNames,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s BatchStartVodDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchStartVodDomainRequest) GoString() string {
	return s.String()
}

func (s *BatchStartVodDomainRequest) SetDomainNames(v string) *BatchStartVodDomainRequest {
	s.DomainNames = &v
	return s
}

func (s *BatchStartVodDomainRequest) SetOwnerId(v int64) *BatchStartVodDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *BatchStartVodDomainRequest) SetSecurityToken(v string) *BatchStartVodDomainRequest {
	s.SecurityToken = &v
	return s
}

type BatchStartVodDomainResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 15C66C7B-671A-4297-****-2C4477247A74
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BatchStartVodDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchStartVodDomainResponseBody) GoString() string {
	return s.String()
}

func (s *BatchStartVodDomainResponseBody) SetRequestId(v string) *BatchStartVodDomainResponseBody {
	s.RequestId = &v
	return s
}

type BatchStartVodDomainResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *BatchStartVodDomainResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s BatchStartVodDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchStartVodDomainResponse) GoString() string {
	return s.String()
}

func (s *BatchStartVodDomainResponse) SetHeaders(v map[string]*string) *BatchStartVodDomainResponse {
	s.Headers = v
	return s
}

func (s *BatchStartVodDomainResponse) SetStatusCode(v int32) *BatchStartVodDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchStartVodDomainResponse) SetBody(v *BatchStartVodDomainResponseBody) *BatchStartVodDomainResponse {
	s.Body = v
	return s
}

type BatchStopVodDomainRequest struct {
	// The accelerated domain name. Separate multiple domain names with commas (,).
	//
	// This parameter is required.
	//
	// example:
	//
	// example.com
	DomainNames   *string `json:"DomainNames,omitempty" xml:"DomainNames,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s BatchStopVodDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchStopVodDomainRequest) GoString() string {
	return s.String()
}

func (s *BatchStopVodDomainRequest) SetDomainNames(v string) *BatchStopVodDomainRequest {
	s.DomainNames = &v
	return s
}

func (s *BatchStopVodDomainRequest) SetOwnerId(v int64) *BatchStopVodDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *BatchStopVodDomainRequest) SetSecurityToken(v string) *BatchStopVodDomainRequest {
	s.SecurityToken = &v
	return s
}

type BatchStopVodDomainResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 15C66C7B-671A-4297-****-2C4477247A74
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BatchStopVodDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchStopVodDomainResponseBody) GoString() string {
	return s.String()
}

func (s *BatchStopVodDomainResponseBody) SetRequestId(v string) *BatchStopVodDomainResponseBody {
	s.RequestId = &v
	return s
}

type BatchStopVodDomainResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *BatchStopVodDomainResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s BatchStopVodDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchStopVodDomainResponse) GoString() string {
	return s.String()
}

func (s *BatchStopVodDomainResponse) SetHeaders(v map[string]*string) *BatchStopVodDomainResponse {
	s.Headers = v
	return s
}

func (s *BatchStopVodDomainResponse) SetStatusCode(v int32) *BatchStopVodDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchStopVodDomainResponse) SetBody(v *BatchStopVodDomainResponseBody) *BatchStopVodDomainResponse {
	s.Body = v
	return s
}

type CancelUrlUploadJobsRequest struct {
	// The IDs of the upload jobs. You can obtain the job IDs from PlayInfo in the response to the [GetPlayInfo](https://help.aliyun.com/document_detail/56124.html) operation.
	//
	// 	- You can specify a maximum of 10 IDs.
	//
	// 	- Separate multiple IDs with commas (,).
	//
	// >  You must specify either JobIds or UploadUrls. If you specify both the JobIds and UploadUrls parameters, only the value of the JobIds parameter takes effect.
	//
	// example:
	//
	// 341c92e6c18dc435ee31253685****,0193d395194a83ad6ee2ef27a5b5****
	JobIds *string `json:"JobIds,omitempty" xml:"JobIds,omitempty"`
	// The upload URLs of source video files. Separate multiple URLs with commas (,). You can specify a maximum of 10 URLs.
	//
	// > 	- You must encode the URLs before you use the URLs.
	//
	// > 	- You must specify either JobIds or UploadUrls. If you specify both the JobIds and UploadUrls parameters, only the value of the JobIds parameter takes effect.
	UploadUrls *string `json:"UploadUrls,omitempty" xml:"UploadUrls,omitempty"`
}

func (s CancelUrlUploadJobsRequest) String() string {
	return tea.Prettify(s)
}

func (s CancelUrlUploadJobsRequest) GoString() string {
	return s.String()
}

func (s *CancelUrlUploadJobsRequest) SetJobIds(v string) *CancelUrlUploadJobsRequest {
	s.JobIds = &v
	return s
}

func (s *CancelUrlUploadJobsRequest) SetUploadUrls(v string) *CancelUrlUploadJobsRequest {
	s.UploadUrls = &v
	return s
}

type CancelUrlUploadJobsResponseBody struct {
	// The IDs of canceled jobs.
	CanceledJobs []*string `json:"CanceledJobs,omitempty" xml:"CanceledJobs,omitempty" type:"Repeated"`
	// The jobs that do not exist.
	NonExists []*string `json:"NonExists,omitempty" xml:"NonExists,omitempty" type:"Repeated"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4D5C-3C3D-D7393642****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CancelUrlUploadJobsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CancelUrlUploadJobsResponseBody) GoString() string {
	return s.String()
}

func (s *CancelUrlUploadJobsResponseBody) SetCanceledJobs(v []*string) *CancelUrlUploadJobsResponseBody {
	s.CanceledJobs = v
	return s
}

func (s *CancelUrlUploadJobsResponseBody) SetNonExists(v []*string) *CancelUrlUploadJobsResponseBody {
	s.NonExists = v
	return s
}

func (s *CancelUrlUploadJobsResponseBody) SetRequestId(v string) *CancelUrlUploadJobsResponseBody {
	s.RequestId = &v
	return s
}

type CancelUrlUploadJobsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CancelUrlUploadJobsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CancelUrlUploadJobsResponse) String() string {
	return tea.Prettify(s)
}

func (s CancelUrlUploadJobsResponse) GoString() string {
	return s.String()
}

func (s *CancelUrlUploadJobsResponse) SetHeaders(v map[string]*string) *CancelUrlUploadJobsResponse {
	s.Headers = v
	return s
}

func (s *CancelUrlUploadJobsResponse) SetStatusCode(v int32) *CancelUrlUploadJobsResponse {
	s.StatusCode = &v
	return s
}

func (s *CancelUrlUploadJobsResponse) SetBody(v *CancelUrlUploadJobsResponseBody) *CancelUrlUploadJobsResponse {
	s.Body = v
	return s
}

type ChangeResourceGroupRequest struct {
	// The ID of the resource group.
	//
	// This parameter is required.
	//
	// example:
	//
	// rg-aekzko7fsuj****
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The ID of resource
	//
	// This parameter is required.
	//
	// example:
	//
	// app-xxxxxxx
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The ID of the region.
	//
	// This parameter is required.
	//
	// example:
	//
	// cn-shanghai
	ResourceRegionId *string `json:"ResourceRegionId,omitempty" xml:"ResourceRegionId,omitempty"`
	// The type of resource
	//
	// example:
	//
	// AppInfo
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s ChangeResourceGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s ChangeResourceGroupRequest) GoString() string {
	return s.String()
}

func (s *ChangeResourceGroupRequest) SetResourceGroupId(v string) *ChangeResourceGroupRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ChangeResourceGroupRequest) SetResourceId(v string) *ChangeResourceGroupRequest {
	s.ResourceId = &v
	return s
}

func (s *ChangeResourceGroupRequest) SetResourceRegionId(v string) *ChangeResourceGroupRequest {
	s.ResourceRegionId = &v
	return s
}

func (s *ChangeResourceGroupRequest) SetResourceType(v string) *ChangeResourceGroupRequest {
	s.ResourceType = &v
	return s
}

type ChangeResourceGroupResponseBody struct {
	// Id of the request
	//
	// example:
	//
	// 25818875-5F78-4A*****F6-D7393642CA58
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ChangeResourceGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ChangeResourceGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ChangeResourceGroupResponseBody) SetRequestId(v string) *ChangeResourceGroupResponseBody {
	s.RequestId = &v
	return s
}

type ChangeResourceGroupResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ChangeResourceGroupResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ChangeResourceGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ChangeResourceGroupResponse) GoString() string {
	return s.String()
}

func (s *ChangeResourceGroupResponse) SetHeaders(v map[string]*string) *ChangeResourceGroupResponse {
	s.Headers = v
	return s
}

func (s *ChangeResourceGroupResponse) SetStatusCode(v int32) *ChangeResourceGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ChangeResourceGroupResponse) SetBody(v *ChangeResourceGroupResponseBody) *ChangeResourceGroupResponse {
	s.Body = v
	return s
}

type CreateAppInfoRequest struct {
	// The name of the application. The application name must be unique.
	//
	// 	- The name can contain letters, digits, periods (.), hyphens (-), and at signs (@). The name can be up to 128 characters in length.
	//
	// 	- The value must be encoded in UTF-8.
	//
	// This parameter is required.
	//
	// example:
	//
	// test
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The description of the application.
	//
	// 	- The description can contain up to 512 characters in length.
	//
	// 	- The value must be encoded in UTF-8.
	//
	// example:
	//
	// myfirstapp
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The resource group ID.
	//
	// example:
	//
	// rg-aekzko7fsuj****
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s CreateAppInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAppInfoRequest) GoString() string {
	return s.String()
}

func (s *CreateAppInfoRequest) SetAppName(v string) *CreateAppInfoRequest {
	s.AppName = &v
	return s
}

func (s *CreateAppInfoRequest) SetDescription(v string) *CreateAppInfoRequest {
	s.Description = &v
	return s
}

func (s *CreateAppInfoRequest) SetResourceGroupId(v string) *CreateAppInfoRequest {
	s.ResourceGroupId = &v
	return s
}

type CreateAppInfoResponseBody struct {
	// The ID of the application.
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A13-34D5-D7393642****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateAppInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateAppInfoResponseBody) GoString() string {
	return s.String()
}

func (s *CreateAppInfoResponseBody) SetAppId(v string) *CreateAppInfoResponseBody {
	s.AppId = &v
	return s
}

func (s *CreateAppInfoResponseBody) SetRequestId(v string) *CreateAppInfoResponseBody {
	s.RequestId = &v
	return s
}

type CreateAppInfoResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateAppInfoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateAppInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateAppInfoResponse) GoString() string {
	return s.String()
}

func (s *CreateAppInfoResponse) SetHeaders(v map[string]*string) *CreateAppInfoResponse {
	s.Headers = v
	return s
}

func (s *CreateAppInfoResponse) SetStatusCode(v int32) *CreateAppInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateAppInfoResponse) SetBody(v *CreateAppInfoResponseBody) *CreateAppInfoResponse {
	s.Body = v
	return s
}

type CreateAuditRequest struct {
	// The review content. You can specify up to **100*	- audio or video files in a request. The value must be converted to a string.\\
	//
	// For more information about this parameter, see the **AuditContent*	- section of this topic.
	//
	// This parameter is required.
	//
	// example:
	//
	// [{"VideoId":"93ab850b4f*****b54b6e91d24d81d4","Status":"Normal"},{"VideoId":"f867fbfb58*****8bbab65c4480ae1d","Status":"Blocked","Reason":"porn video","Comment":"porn video"}]
	AuditContent *string `json:"AuditContent,omitempty" xml:"AuditContent,omitempty"`
}

func (s CreateAuditRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAuditRequest) GoString() string {
	return s.String()
}

func (s *CreateAuditRequest) SetAuditContent(v string) *CreateAuditRequest {
	s.AuditContent = &v
	return s
}

type CreateAuditResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A*****F6-D7393642CA58
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateAuditResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateAuditResponseBody) GoString() string {
	return s.String()
}

func (s *CreateAuditResponseBody) SetRequestId(v string) *CreateAuditResponseBody {
	s.RequestId = &v
	return s
}

type CreateAuditResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateAuditResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateAuditResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateAuditResponse) GoString() string {
	return s.String()
}

func (s *CreateAuditResponse) SetHeaders(v map[string]*string) *CreateAuditResponse {
	s.Headers = v
	return s
}

func (s *CreateAuditResponse) SetStatusCode(v int32) *CreateAuditResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateAuditResponse) SetBody(v *CreateAuditResponseBody) *CreateAuditResponse {
	s.Body = v
	return s
}

type CreateUploadAttachedMediaRequest struct {
	// The ID of the application. Default value: **app-1000000**. If you have activated the multi-application service, specify the ID of the application to add the watermark template in the specified application. For more information, see [Overview](https://help.aliyun.com/document_detail/113600.html).
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The type of the auxiliary media asset. Valid values:
	//
	// 	- **watermark**
	//
	// 	- **subtitle**
	//
	// 	- **material**
	//
	// This parameter is required.
	//
	// example:
	//
	// watermark
	BusinessType *string `json:"BusinessType,omitempty" xml:"BusinessType,omitempty"`
	// The ID of the category. Separate multiple IDs with commas (,). You can specify up to five IDs. You can use one of the following methods to obtain the ID:
	//
	// 	- Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Configuration Management*	- > **Media Management*	- > **Categories*	- to view the category ID of the media file.
	//
	// 	- Obtain the category ID from the response to the [AddCategory](~~AddCategory~~) operation that you call to create a category.
	//
	// 	- Obtain the category ID from the response to the [GetCategories](~~GetCategories~~) operation that you call to query categories.
	//
	// example:
	//
	// 1298****,0813****
	CateIds *string `json:"CateIds,omitempty" xml:"CateIds,omitempty"`
	// The description of the auxiliary media asset. Take note of the following items:
	//
	// 	- The description can be up to 1,024 bytes in length.
	//
	// 	- The value must be encoded in UTF-8.
	//
	// example:
	//
	// uploadTest
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The source file URL of the auxiliary media asset.
	//
	// >  The file name extension is optional. If the file name extension that you specified for this parameter is different from the value of MediaExt, the value of MediaExt takes effect.
	//
	// example:
	//
	// D:\\test.png
	FileName *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	// The size of the auxiliary media asset. Unit: byte.
	//
	// example:
	//
	// 123
	FileSize *string `json:"FileSize,omitempty" xml:"FileSize,omitempty"`
	// The file name extension of the auxiliary media asset.
	//
	// 	- Valid values for watermarks: **png, gif, apng, and mov**
	//
	// 	- Valid values for subtitles: **srt, ass, stl, ttml, and vtt**
	//
	// 	- Valid values for materials: **jpg, gif, png, mp4, mat, zip, and apk**
	//
	// example:
	//
	// png
	MediaExt *string `json:"MediaExt,omitempty" xml:"MediaExt,omitempty"`
	// The storage address. Perform the following operations to obtain the storage address:
	//
	// Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Configuration Management*	- > **Media Management*	- > **Storage**. On the Storage page, view the storage address.
	//
	// >  If you leave this parameter empty, the auxiliary media asset is uploaded to the default storage address. If you specify this parameter, the auxiliary media asset is uploaded to the specified storage address.
	//
	// example:
	//
	// out-****.oss-cn-shanghai.aliyuncs.com
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	// The one or more tags of the auxiliary media asset. Take note of the following items:
	//
	// 	- You can specify a maximum of 16 tags.
	//
	// 	- If you need to specify multiple tags, separate the tags with commas (,).
	//
	// 	- Each tag can be up to 32 characters in length.
	//
	// 	- The value must be encoded in UTF-8.
	//
	// example:
	//
	// tag1,tag2
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The title of the auxiliary media asset. The following rules apply:
	//
	// 	- The title cannot exceed 128 bytes.
	//
	// 	- The title must be encoded in UTF-8.
	//
	// example:
	//
	// testTitle
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The custom configurations. For example, you can specify callback configurations and upload acceleration configurations. The value must be a JSON string. For more information, see [Request parameters](~~86952#section-6fg-qll-v3w~~).
	//
	// > 	- The callback configurations take effect only after you specify the HTTP callback URL and select the specific callback events in the ApsaraVideo VOD console. For more information about how to configure HTTP callback settings in the ApsaraVideo VOD console, see [Configure callback settings](https://help.aliyun.com/document_detail/86071.html).
	//
	// > 	- If you want to enable the upload acceleration feature, submit a ticket. For more information, see [Overview](https://help.aliyun.com/document_detail/55396.html). For more information about how to submit a ticket, see [Contact us](https://help.aliyun.com/document_detail/464625.html).
	//
	// example:
	//
	// {"MessageCallback":{"CallbackURL":"http://example.aliyundoc.com"},"Extend":{"localId":"xxx","test":"www"}}
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
}

func (s CreateUploadAttachedMediaRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateUploadAttachedMediaRequest) GoString() string {
	return s.String()
}

func (s *CreateUploadAttachedMediaRequest) SetAppId(v string) *CreateUploadAttachedMediaRequest {
	s.AppId = &v
	return s
}

func (s *CreateUploadAttachedMediaRequest) SetBusinessType(v string) *CreateUploadAttachedMediaRequest {
	s.BusinessType = &v
	return s
}

func (s *CreateUploadAttachedMediaRequest) SetCateIds(v string) *CreateUploadAttachedMediaRequest {
	s.CateIds = &v
	return s
}

func (s *CreateUploadAttachedMediaRequest) SetDescription(v string) *CreateUploadAttachedMediaRequest {
	s.Description = &v
	return s
}

func (s *CreateUploadAttachedMediaRequest) SetFileName(v string) *CreateUploadAttachedMediaRequest {
	s.FileName = &v
	return s
}

func (s *CreateUploadAttachedMediaRequest) SetFileSize(v string) *CreateUploadAttachedMediaRequest {
	s.FileSize = &v
	return s
}

func (s *CreateUploadAttachedMediaRequest) SetMediaExt(v string) *CreateUploadAttachedMediaRequest {
	s.MediaExt = &v
	return s
}

func (s *CreateUploadAttachedMediaRequest) SetStorageLocation(v string) *CreateUploadAttachedMediaRequest {
	s.StorageLocation = &v
	return s
}

func (s *CreateUploadAttachedMediaRequest) SetTags(v string) *CreateUploadAttachedMediaRequest {
	s.Tags = &v
	return s
}

func (s *CreateUploadAttachedMediaRequest) SetTitle(v string) *CreateUploadAttachedMediaRequest {
	s.Title = &v
	return s
}

func (s *CreateUploadAttachedMediaRequest) SetUserData(v string) *CreateUploadAttachedMediaRequest {
	s.UserData = &v
	return s
}

type CreateUploadAttachedMediaResponseBody struct {
	// The URL of the auxiliary media asset file. The URL is an Object Storage Service (OSS) URL and does not contain the information used for URL signing.
	//
	// You can use specify this value for the `FileUrl` parameter when you call the [AddWatermark](~~AddWatermark~~) operation to create a watermark template.
	//
	// example:
	//
	// https://****.oss-cn-shanghai.aliyuncs.com/watermark/****.mov
	FileURL *string `json:"FileURL,omitempty" xml:"FileURL,omitempty"`
	// The ID of the auxiliary media asset.
	//
	// example:
	//
	// 97dc17a5abc3668489b84ce9****
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The URL of the auxiliary media asset.
	//
	// If a domain name for Alibaba Cloud CDN is specified, a CDN URL is returned. Otherwise, an OSS URL is returned.
	//
	// >  If you enable the URL signing feature of ApsaraVideo VOD, you may be unable to access the returned URL of the auxiliary media asset by using a browser and the HTTP status code 403 may be returned. To resolve this issue, you can disable the [URL signing](https://help.aliyun.com/document_detail/86090.html) feature or [generate a signed URL](https://help.aliyun.com/document_detail/57007.html).
	//
	// example:
	//
	// http://example.aliyundoc.com/watermark/****.mov?auth_key=****
	MediaURL *string `json:"MediaURL,omitempty" xml:"MediaURL,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// 73254DE5-F260-4720-D06856B63C01****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The upload URL.
	//
	// >  The upload URL returned by this operation is Base64-encoded. Before you can use an SDK or an API operation to upload a media asset based on the upload URL, you must decode the upload URL by using the Base64 algorithm. You must parse the upload URL only if you use native OSS SDKs or OSS API for uploads.
	//
	// example:
	//
	// LWNuLXNoYW5naGFpLmFsaXl1b****
	UploadAddress *string `json:"UploadAddress,omitempty" xml:"UploadAddress,omitempty"`
	// The upload credential.
	//
	// >  The upload credential returned by this operation is Base64-encoded. Before you can use an SDK or an API operation to upload a media asset based on the upload credential, you must decode the upload credential by using the Base64 algorithm. You must parse the upload credential only if you use native OSS SDKs or OSS API for uploads.
	//
	// example:
	//
	// UzFnUjFxNkZ0NUIZTaklyNWJoQ00zdHF****
	UploadAuth *string `json:"UploadAuth,omitempty" xml:"UploadAuth,omitempty"`
}

func (s CreateUploadAttachedMediaResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateUploadAttachedMediaResponseBody) GoString() string {
	return s.String()
}

func (s *CreateUploadAttachedMediaResponseBody) SetFileURL(v string) *CreateUploadAttachedMediaResponseBody {
	s.FileURL = &v
	return s
}

func (s *CreateUploadAttachedMediaResponseBody) SetMediaId(v string) *CreateUploadAttachedMediaResponseBody {
	s.MediaId = &v
	return s
}

func (s *CreateUploadAttachedMediaResponseBody) SetMediaURL(v string) *CreateUploadAttachedMediaResponseBody {
	s.MediaURL = &v
	return s
}

func (s *CreateUploadAttachedMediaResponseBody) SetRequestId(v string) *CreateUploadAttachedMediaResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateUploadAttachedMediaResponseBody) SetUploadAddress(v string) *CreateUploadAttachedMediaResponseBody {
	s.UploadAddress = &v
	return s
}

func (s *CreateUploadAttachedMediaResponseBody) SetUploadAuth(v string) *CreateUploadAttachedMediaResponseBody {
	s.UploadAuth = &v
	return s
}

type CreateUploadAttachedMediaResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateUploadAttachedMediaResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateUploadAttachedMediaResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateUploadAttachedMediaResponse) GoString() string {
	return s.String()
}

func (s *CreateUploadAttachedMediaResponse) SetHeaders(v map[string]*string) *CreateUploadAttachedMediaResponse {
	s.Headers = v
	return s
}

func (s *CreateUploadAttachedMediaResponse) SetStatusCode(v int32) *CreateUploadAttachedMediaResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateUploadAttachedMediaResponse) SetBody(v *CreateUploadAttachedMediaResponseBody) *CreateUploadAttachedMediaResponse {
	s.Body = v
	return s
}

type CreateUploadImageRequest struct {
	// The ID of the application. Default value: **app-1000000**. For more information, see [Overview](https://help.aliyun.com/document_detail/113600.html).
	//
	// example:
	//
	// app-1000000
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The category ID of the image. You can use one of the following methods to obtain the category ID:
	//
	// 	- Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Configuration Management*	- > **Media Management*	- > **Categories**. On the Categories page, you can view the category ID of the image.
	//
	// 	- Obtain the value of CateId from the response to the [AddCategory](https://help.aliyun.com/document_detail/56401.html) operation.
	//
	// 	- Obtain the value of CateId from the response to the [GetCategories](https://help.aliyun.com/document_detail/56406.html) operation.
	//
	// example:
	//
	// 100036****
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The description of the image.
	//
	// 	- The description can be up to 1,024 characters in length.
	//
	// 	- The value must be encoded in UTF-8.
	//
	// example:
	//
	// The description of the image
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The file name extension of the image. Valid values:
	//
	// 	- **png*	- (default)
	//
	// 	- **jpg**
	//
	// 	- **jpeg**
	//
	// 	- **gif**
	//
	// example:
	//
	// png
	ImageExt *string `json:"ImageExt,omitempty" xml:"ImageExt,omitempty"`
	// The type of the image. Valid values:
	//
	// 	- **default**: the default image type.
	//
	// 	- **cover**: the thumbnail.
	//
	// > You can manage only images of the **default*	- type in the ApsaraVideo VOD console.
	//
	// This parameter is required.
	//
	// example:
	//
	// default
	ImageType *string `json:"ImageType,omitempty" xml:"ImageType,omitempty"`
	// The name of the source file.
	//
	// > The name must contain a file name extension. The file name extension is not case-sensitive.
	//
	// example:
	//
	// D:\\picture_01.png
	OriginalFileName *string `json:"OriginalFileName,omitempty" xml:"OriginalFileName,omitempty"`
	// The storage address. Perform the following operations to obtain the storage address: Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Configuration Management*	- > **Media Management*	- > **Storage**. On the Storage page, view the storage address.
	//
	// > If you specify a storage address, media files are uploaded to the specified address.
	//
	// example:
	//
	// outin-****..oss-cn-shanghai.aliyuncs.com
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	// The tags of the image. The following rules apply:
	//
	// 	- Each tag can be up to 32 characters in length.
	//
	// 	- You can specify a maximum of 16 tags for an image.
	//
	// 	- Separate multiple tags with commas (,).
	//
	// 	- The value must be encoded in UTF-8.
	//
	// example:
	//
	// test
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The title of the image. The following rules apply:
	//
	// 	- The title can be up to 128 characters in length.
	//
	// 	- The value must be encoded in UTF-8.
	//
	// example:
	//
	// mytitle
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The custom configurations, including callback configurations and upload acceleration configurations. The value must be a JSON string. For more information, see the "UserData: specifies the custom configurations for media upload" section of the [Request parameters](https://help.aliyun.com/document_detail/86952.html) topic.
	//
	// > 	- The callback configurations take effect only after you specify the HTTP callback URL and select specific callback events in the ApsaraVideo VOD console. For more information about how to configure HTTP callback settings in the ApsaraVideo VOD console, see [Configure callback settings](https://help.aliyun.com/document_detail/86071.html).
	//
	// > 	- If you want to enable the upload acceleration feature, submit a ticket. For more information, see [Overview](https://help.aliyun.com/document_detail/55396.html). For more information about how to submit a ticket, see [Contact us](https://help.aliyun.com/document_detail/464625.html).
	//
	// example:
	//
	// {"MessageCallback":{"CallbackURL":"http://example.aliyundoc.com"},"Extend":{"localId":"xxx","test":"www"}}
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
}

func (s CreateUploadImageRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateUploadImageRequest) GoString() string {
	return s.String()
}

func (s *CreateUploadImageRequest) SetAppId(v string) *CreateUploadImageRequest {
	s.AppId = &v
	return s
}

func (s *CreateUploadImageRequest) SetCateId(v int64) *CreateUploadImageRequest {
	s.CateId = &v
	return s
}

func (s *CreateUploadImageRequest) SetDescription(v string) *CreateUploadImageRequest {
	s.Description = &v
	return s
}

func (s *CreateUploadImageRequest) SetImageExt(v string) *CreateUploadImageRequest {
	s.ImageExt = &v
	return s
}

func (s *CreateUploadImageRequest) SetImageType(v string) *CreateUploadImageRequest {
	s.ImageType = &v
	return s
}

func (s *CreateUploadImageRequest) SetOriginalFileName(v string) *CreateUploadImageRequest {
	s.OriginalFileName = &v
	return s
}

func (s *CreateUploadImageRequest) SetStorageLocation(v string) *CreateUploadImageRequest {
	s.StorageLocation = &v
	return s
}

func (s *CreateUploadImageRequest) SetTags(v string) *CreateUploadImageRequest {
	s.Tags = &v
	return s
}

func (s *CreateUploadImageRequest) SetTitle(v string) *CreateUploadImageRequest {
	s.Title = &v
	return s
}

func (s *CreateUploadImageRequest) SetUserData(v string) *CreateUploadImageRequest {
	s.UserData = &v
	return s
}

type CreateUploadImageResponseBody struct {
	// The OSS URL of the file. The URL does not contain the information used for URL signing. You can specify FileUrl when you call the [AddWatermark](https://help.aliyun.com/document_detail/98617.html) operation.
	//
	// example:
	//
	// http://example.aliyundoc.com/cover/2017-34DB-4F4C-9373-003AA060****.png
	FileURL *string `json:"FileURL,omitempty" xml:"FileURL,omitempty"`
	// The ID of the image file.
	//
	// example:
	//
	// 93ab850b4f6f46e91d24d81d4****
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The URL of the image.
	//
	// > If the returned URL is inaccessible from a browser and the HTTP 403 status code is returned, the URL signing feature in ApsaraVideo VOD is enabled. To resolve this issue, you can disable the [URL signing](https://help.aliyun.com/document_detail/86090.html) feature or [generate a signed URL](https://help.aliyun.com/document_detail/57007.html).
	//
	// example:
	//
	// http://example.aliyundoc.com/cover/2017-34DB-4F4C-9373-003AA060****.png
	ImageURL *string `json:"ImageURL,omitempty" xml:"ImageURL,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-AEF6-D7393642****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The upload URL.
	//
	// > The returned upload URL is a Base64-encoded URL. You must decode the Base64-encoded URL before you use an SDK or call an API operation to upload auxiliary media assets. You need to parse UploadAddress only if you use the OSS SDK or call an OSS API operation to upload auxiliary media assets.
	//
	// example:
	//
	// eyJTZWN1cmuIjoiQ0FJU3p3TjF****
	UploadAddress *string `json:"UploadAddress,omitempty" xml:"UploadAddress,omitempty"`
	// The upload credential.
	//
	// > The returned upload credential is a Base64-encoded value. You must decode the Base64-encoded credential before you use an SDK or call an API operation to upload auxiliary media assets. You need to parse UploadAuth only if you use the OSS SDK or call an OSS API operation to upload auxiliary media assets.
	//
	// example:
	//
	// eyJFbmmRCI6Im****
	UploadAuth *string `json:"UploadAuth,omitempty" xml:"UploadAuth,omitempty"`
}

func (s CreateUploadImageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateUploadImageResponseBody) GoString() string {
	return s.String()
}

func (s *CreateUploadImageResponseBody) SetFileURL(v string) *CreateUploadImageResponseBody {
	s.FileURL = &v
	return s
}

func (s *CreateUploadImageResponseBody) SetImageId(v string) *CreateUploadImageResponseBody {
	s.ImageId = &v
	return s
}

func (s *CreateUploadImageResponseBody) SetImageURL(v string) *CreateUploadImageResponseBody {
	s.ImageURL = &v
	return s
}

func (s *CreateUploadImageResponseBody) SetRequestId(v string) *CreateUploadImageResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateUploadImageResponseBody) SetUploadAddress(v string) *CreateUploadImageResponseBody {
	s.UploadAddress = &v
	return s
}

func (s *CreateUploadImageResponseBody) SetUploadAuth(v string) *CreateUploadImageResponseBody {
	s.UploadAuth = &v
	return s
}

type CreateUploadImageResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateUploadImageResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateUploadImageResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateUploadImageResponse) GoString() string {
	return s.String()
}

func (s *CreateUploadImageResponse) SetHeaders(v map[string]*string) *CreateUploadImageResponse {
	s.Headers = v
	return s
}

func (s *CreateUploadImageResponse) SetStatusCode(v int32) *CreateUploadImageResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateUploadImageResponse) SetBody(v *CreateUploadImageResponseBody) *CreateUploadImageResponse {
	s.Body = v
	return s
}

type CreateUploadVideoRequest struct {
	// The ID of the application. Default value: **app-1000000**. For more information, see [Overview](https://help.aliyun.com/document_detail/113600.html).
	//
	// example:
	//
	// app-1000000
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the category. You can use one of the following methods to obtain the ID:
	//
	// 	- Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Configuration Management*	- > **Media Management*	- > **Categories*	- to view the category ID of the media file.
	//
	// 	- Obtain the value of CateId from the response to the [AddCategory](~~AddCategory~~) operation.
	//
	// 	- Obtain the value of CateId from the response to the [GetCategories](~~GetCategories~~) operation.
	//
	// example:
	//
	// 100036****
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The URL of the custom video thumbnail.
	//
	// example:
	//
	// https://example.aliyundoc.com/image/D22F553TEST****.jpeg
	CoverURL *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	// The description of the audio or video file.
	//
	// 	- The value can be up to 1,024 characters in length.
	//
	// 	- The value must be encoded in UTF-8.
	//
	// example:
	//
	// UploadTest
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the source file.
	//
	// 	- The name must contain a file name extension, which is not case-sensitive.
	//
	// 	- For more information about file name extensions supported by ApsaraVideo VOD, see [Overview](https://help.aliyun.com/document_detail/55396.html).
	//
	// This parameter is required.
	//
	// example:
	//
	// D:\\video_01.mp4
	FileName *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	// The size of the source file. Unit: bytes.
	//
	// example:
	//
	// 123
	FileSize *int64 `json:"FileSize,omitempty" xml:"FileSize,omitempty"`
	// The storage address. Perform the following operations to obtain the storage address: Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Configuration Management*	- > **Media Management*	- > **Storage**. On the Storage page, view the storage address.
	//
	// >  If you leave this parameter empty, audio and video files are uploaded to the default storage address. If you specify a storage address, audio and video files are uploaded to the specified address.
	//
	// example:
	//
	// out-****.oss-cn-shanghai.aliyuncs.com
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	// The tags of the audio or video file.
	//
	// 	- You can specify a maximum of 16 tags.
	//
	// 	- If you want to specify multiple tags, separate the tags with commas (,).
	//
	// 	- Each tag can be up to 32 characters in length.
	//
	// 	- The value must be encoded in UTF-8.
	//
	// example:
	//
	// tag1,tag2
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The ID of the transcoding template group. You can use one of the following methods to obtain the ID:
	//
	// 	- Log on to the ApsaraVideo VOD console. In the left-side navigation pane, choose Configuration Management > Media Processing > Transcoding Template Groups. On the Transcoding Template Groups page, you can view the ID of the transcoding template group.[](https://vod.console.aliyun.com)************
	//
	// 	- Obtain the value of the TranscodeTemplateGroupId parameter from the response to the [AddTranscodeTemplateGroup](https://help.aliyun.com/document_detail/102665.html) operation that you called to create a transcoding template group.
	//
	// 	- Obtain the value of the TranscodeTemplateGroupId parameter from the response to the [ListTranscodeTemplateGroup](https://help.aliyun.com/document_detail/102669.html) operation that you called to query transcoding template groups.
	//
	// > 	- If you specify both WorkflowId and TemplateGroupId, the value of the WorkflowId parameter takes effect.
	//
	// > 	- If this parameter is not specified, transcoding is performed based on the default transcoding template group. If the transcoding template group ID is specified, transcoding is performed based on the specified template group.
	//
	// > 	- If the **No Transcoding*	- template group is used, only the [FileUploadComplete](https://help.aliyun.com/document_detail/55630.html) event notification is returned after a video is uploaded. The [StreamTranscodeComplete](https://help.aliyun.com/document_detail/55636.html) event notification is not returned.
	//
	// > 	- If you use the **No Transcoding*	- template group to upload videos, only videos in the format of MP4, FLV, MP3, M3U8, or WebM can be played. Videos in other formats can only be stored in ApsaraVideo VOD. You can view the file name extension to obtain the video format. If you want to use ApsaraVideo Player, make sure that the version of the player is V3.1.0 or later.
	//
	// example:
	//
	// 405477f9e214d19ea2c7c854****
	TemplateGroupId *string `json:"TemplateGroupId,omitempty" xml:"TemplateGroupId,omitempty"`
	// The title of the audio or video file.
	//
	// 	- The title can be up to 128 characters in length.
	//
	// 	- The value must be encoded in UTF-8.
	//
	// This parameter is required.
	//
	// example:
	//
	// UploadTest
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The custom configurations such as callback configurations and upload acceleration configurations. The value must be a JSON string. For more information, see [Request parameters](https://help.aliyun.com/document_detail/86952.html).
	//
	// > 	- The callback configurations take effect only after you specify the HTTP callback URL and select specific callback events in the ApsaraVideo VOD console. For more information about how to configure HTTP callback settings in the ApsaraVideo VOD console, see [Configure callback settings](https://help.aliyun.com/document_detail/86071.html).
	//
	// >	- If you want to enable the upload acceleration feature, [submit a request on Yida](https://yida.alibaba-inc.com/o/ticketapply). For more information, see [Overview](https://help.aliyun.com/document_detail/55396.html).
	//
	// example:
	//
	// {"MessageCallback":{"CallbackURL":"http://example.aliyundoc.com"},"Extend":{"localId":"*****","test":"www"}}
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
	// The ID of the workflow. To view the ID of the workflow, log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Configuration Management*	- > **Media Processing*	- > **Workflows**.
	//
	// > If you specify the WorkflowId and TemplateGroupId parameters, the value of the WorkflowId parameter takes effect. For more information, see [Workflows](https://help.aliyun.com/document_detail/115347.html).
	//
	// example:
	//
	// 613efff3887ec34af685714cc461****
	WorkflowId *string `json:"WorkflowId,omitempty" xml:"WorkflowId,omitempty"`
}

func (s CreateUploadVideoRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateUploadVideoRequest) GoString() string {
	return s.String()
}

func (s *CreateUploadVideoRequest) SetAppId(v string) *CreateUploadVideoRequest {
	s.AppId = &v
	return s
}

func (s *CreateUploadVideoRequest) SetCateId(v int64) *CreateUploadVideoRequest {
	s.CateId = &v
	return s
}

func (s *CreateUploadVideoRequest) SetCoverURL(v string) *CreateUploadVideoRequest {
	s.CoverURL = &v
	return s
}

func (s *CreateUploadVideoRequest) SetDescription(v string) *CreateUploadVideoRequest {
	s.Description = &v
	return s
}

func (s *CreateUploadVideoRequest) SetFileName(v string) *CreateUploadVideoRequest {
	s.FileName = &v
	return s
}

func (s *CreateUploadVideoRequest) SetFileSize(v int64) *CreateUploadVideoRequest {
	s.FileSize = &v
	return s
}

func (s *CreateUploadVideoRequest) SetStorageLocation(v string) *CreateUploadVideoRequest {
	s.StorageLocation = &v
	return s
}

func (s *CreateUploadVideoRequest) SetTags(v string) *CreateUploadVideoRequest {
	s.Tags = &v
	return s
}

func (s *CreateUploadVideoRequest) SetTemplateGroupId(v string) *CreateUploadVideoRequest {
	s.TemplateGroupId = &v
	return s
}

func (s *CreateUploadVideoRequest) SetTitle(v string) *CreateUploadVideoRequest {
	s.Title = &v
	return s
}

func (s *CreateUploadVideoRequest) SetUserData(v string) *CreateUploadVideoRequest {
	s.UserData = &v
	return s
}

func (s *CreateUploadVideoRequest) SetWorkflowId(v string) *CreateUploadVideoRequest {
	s.WorkflowId = &v
	return s
}

type CreateUploadVideoResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4AF6-04D5-D7393642****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The upload URL.
	//
	// > The returned upload URL is a Base64-encoded URL. You must decode the Base64-encoded URL before you use an SDK or call an API operation to upload media files. You need to parse UploadAddress only if you use the Object Storage Service (OSS) SDK or call an OSS API operation to upload media files.
	//
	// example:
	//
	// eyJTZWN1cml0a2VuIjoiQ0FJU3p3TjF****
	UploadAddress *string `json:"UploadAddress,omitempty" xml:"UploadAddress,omitempty"`
	// The upload credential.
	//
	// > The returned upload credential is a Base64-encoded value. You must decode the Base64-encoded credential before you use an SDK or call an API operation to upload media files. You need to parse UploadAuth only if you use the OSS SDK or call an OSS API operation to upload media files.
	//
	// example:
	//
	// eyJFbmRwb2ludCI6Imm****
	UploadAuth *string `json:"UploadAuth,omitempty" xml:"UploadAuth,omitempty"`
	// The ID of the audio or video file. VideoId can be used as a request parameter when you call an operation for media asset management, media processing, or media review.
	//
	// example:
	//
	// 93ab850b4f6f54b6e91d24d81d44****
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s CreateUploadVideoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateUploadVideoResponseBody) GoString() string {
	return s.String()
}

func (s *CreateUploadVideoResponseBody) SetRequestId(v string) *CreateUploadVideoResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateUploadVideoResponseBody) SetUploadAddress(v string) *CreateUploadVideoResponseBody {
	s.UploadAddress = &v
	return s
}

func (s *CreateUploadVideoResponseBody) SetUploadAuth(v string) *CreateUploadVideoResponseBody {
	s.UploadAuth = &v
	return s
}

func (s *CreateUploadVideoResponseBody) SetVideoId(v string) *CreateUploadVideoResponseBody {
	s.VideoId = &v
	return s
}

type CreateUploadVideoResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateUploadVideoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateUploadVideoResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateUploadVideoResponse) GoString() string {
	return s.String()
}

func (s *CreateUploadVideoResponse) SetHeaders(v map[string]*string) *CreateUploadVideoResponse {
	s.Headers = v
	return s
}

func (s *CreateUploadVideoResponse) SetStatusCode(v int32) *CreateUploadVideoResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateUploadVideoResponse) SetBody(v *CreateUploadVideoResponseBody) *CreateUploadVideoResponse {
	s.Body = v
	return s
}

type DecryptKMSDataKeyRequest struct {
	// The ciphertext to be decrypted.
	//
	// This parameter is required.
	//
	// example:
	//
	// DZhOWVmZDktM2QxNi00ODk0LWJkNGYtMWZjNDNmM2YyYWJmaaSl+TztSIMe43nbTH/Z1Wr4XfLftKhAciUmDQXuMRl4WTvKhxjMThjK****
	CipherText           *string `json:"CipherText,omitempty" xml:"CipherText,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DecryptKMSDataKeyRequest) String() string {
	return tea.Prettify(s)
}

func (s DecryptKMSDataKeyRequest) GoString() string {
	return s.String()
}

func (s *DecryptKMSDataKeyRequest) SetCipherText(v string) *DecryptKMSDataKeyRequest {
	s.CipherText = &v
	return s
}

func (s *DecryptKMSDataKeyRequest) SetOwnerAccount(v string) *DecryptKMSDataKeyRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DecryptKMSDataKeyRequest) SetOwnerId(v string) *DecryptKMSDataKeyRequest {
	s.OwnerId = &v
	return s
}

func (s *DecryptKMSDataKeyRequest) SetResourceOwnerAccount(v string) *DecryptKMSDataKeyRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DecryptKMSDataKeyRequest) SetResourceOwnerId(v string) *DecryptKMSDataKeyRequest {
	s.ResourceOwnerId = &v
	return s
}

type DecryptKMSDataKeyResponseBody struct {
	// The ID of the customer master key (CMK) that was used to decrypt the ciphertext.
	//
	// example:
	//
	// 202b9877-5a25-46e3-a763-e20791b5****
	KeyId *string `json:"KeyId,omitempty" xml:"KeyId,omitempty"`
	// The plaintext that is generated after decryption.
	//
	// example:
	//
	// tRYXuCwgja12xxO1N/gZERDDCLw9doZEQiPDk/Bv****
	Plaintext *string `json:"Plaintext,omitempty" xml:"Plaintext,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 25818875-5F78-4A*****F6-D7393642CA58
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DecryptKMSDataKeyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DecryptKMSDataKeyResponseBody) GoString() string {
	return s.String()
}

func (s *DecryptKMSDataKeyResponseBody) SetKeyId(v string) *DecryptKMSDataKeyResponseBody {
	s.KeyId = &v
	return s
}

func (s *DecryptKMSDataKeyResponseBody) SetPlaintext(v string) *DecryptKMSDataKeyResponseBody {
	s.Plaintext = &v
	return s
}

func (s *DecryptKMSDataKeyResponseBody) SetRequestId(v string) *DecryptKMSDataKeyResponseBody {
	s.RequestId = &v
	return s
}

type DecryptKMSDataKeyResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DecryptKMSDataKeyResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DecryptKMSDataKeyResponse) String() string {
	return tea.Prettify(s)
}

func (s DecryptKMSDataKeyResponse) GoString() string {
	return s.String()
}

func (s *DecryptKMSDataKeyResponse) SetHeaders(v map[string]*string) *DecryptKMSDataKeyResponse {
	s.Headers = v
	return s
}

func (s *DecryptKMSDataKeyResponse) SetStatusCode(v int32) *DecryptKMSDataKeyResponse {
	s.StatusCode = &v
	return s
}

func (s *DecryptKMSDataKeyResponse) SetBody(v *DecryptKMSDataKeyResponseBody) *DecryptKMSDataKeyResponse {
	s.Body = v
	return s
}

type DeleteAIImageInfosRequest struct {
	// The IDs of the images that are submitted for AI processing. You can obtain the value of AIImageInfoId from the response to the [ListAIImageInfo](~~ListAIImageInfo~~) operation.
	//
	// - You can specify a maximum of 10 IDs.
	//
	// - Separate multiple IDs with commas (,).
	//
	// This parameter is required.
	//
	// example:
	//
	// b89a6aabf144*****6197ebd6fe6cf29
	AIImageInfoIds *string `json:"AIImageInfoIds,omitempty" xml:"AIImageInfoIds,omitempty"`
}

func (s DeleteAIImageInfosRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAIImageInfosRequest) GoString() string {
	return s.String()
}

func (s *DeleteAIImageInfosRequest) SetAIImageInfoIds(v string) *DeleteAIImageInfosRequest {
	s.AIImageInfoIds = &v
	return s
}

type DeleteAIImageInfosResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// FCDC80EA-363C-41*****B8-0DF14033D643
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteAIImageInfosResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAIImageInfosResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAIImageInfosResponseBody) SetRequestId(v string) *DeleteAIImageInfosResponseBody {
	s.RequestId = &v
	return s
}

type DeleteAIImageInfosResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteAIImageInfosResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteAIImageInfosResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAIImageInfosResponse) GoString() string {
	return s.String()
}

func (s *DeleteAIImageInfosResponse) SetHeaders(v map[string]*string) *DeleteAIImageInfosResponse {
	s.Headers = v
	return s
}

func (s *DeleteAIImageInfosResponse) SetStatusCode(v int32) *DeleteAIImageInfosResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAIImageInfosResponse) SetBody(v *DeleteAIImageInfosResponseBody) *DeleteAIImageInfosResponse {
	s.Body = v
	return s
}

type DeleteAITemplateRequest struct {
	// The ID of the AI template. You can use one of the following methods to obtain the ID of the AI template:
	//
	// 	- Call the [AddAITemplate](https://help.aliyun.com/document_detail/102930.html) operation to add an AI template if no AI template exists. The value of TemplateId in the response is the ID of the AI template.
	//
	// 	- Call the [ListAITemplate](https://help.aliyun.com/document_detail/102936.html) operation if the template already exists. The value of TemplateId in the response is the ID of the AI template.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1706a0063dd733f6a823ef32e0a5****
	TemplateId *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
}

func (s DeleteAITemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAITemplateRequest) GoString() string {
	return s.String()
}

func (s *DeleteAITemplateRequest) SetTemplateId(v string) *DeleteAITemplateRequest {
	s.TemplateId = &v
	return s
}

type DeleteAITemplateResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 25818875-5F78-4A13-BEF6-****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the AI template.
	//
	// example:
	//
	// 1706a0063dd733f6a823ef32e0a5****
	TemplateId *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
}

func (s DeleteAITemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAITemplateResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAITemplateResponseBody) SetRequestId(v string) *DeleteAITemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteAITemplateResponseBody) SetTemplateId(v string) *DeleteAITemplateResponseBody {
	s.TemplateId = &v
	return s
}

type DeleteAITemplateResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteAITemplateResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteAITemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAITemplateResponse) GoString() string {
	return s.String()
}

func (s *DeleteAITemplateResponse) SetHeaders(v map[string]*string) *DeleteAITemplateResponse {
	s.Headers = v
	return s
}

func (s *DeleteAITemplateResponse) SetStatusCode(v int32) *DeleteAITemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAITemplateResponse) SetBody(v *DeleteAITemplateResponseBody) *DeleteAITemplateResponse {
	s.Body = v
	return s
}

type DeleteAppInfoRequest struct {
	// The ID of the application. Default value: **app-1000000**. For more information, see [Overview](https://help.aliyun.com/document_detail/113600.html).
	//
	// This parameter is required.
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
}

func (s DeleteAppInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAppInfoRequest) GoString() string {
	return s.String()
}

func (s *DeleteAppInfoRequest) SetAppId(v string) *DeleteAppInfoRequest {
	s.AppId = &v
	return s
}

type DeleteAppInfoResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A13-BEF6-****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteAppInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAppInfoResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAppInfoResponseBody) SetRequestId(v string) *DeleteAppInfoResponseBody {
	s.RequestId = &v
	return s
}

type DeleteAppInfoResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteAppInfoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteAppInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAppInfoResponse) GoString() string {
	return s.String()
}

func (s *DeleteAppInfoResponse) SetHeaders(v map[string]*string) *DeleteAppInfoResponse {
	s.Headers = v
	return s
}

func (s *DeleteAppInfoResponse) SetStatusCode(v int32) *DeleteAppInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAppInfoResponse) SetBody(v *DeleteAppInfoResponseBody) *DeleteAppInfoResponse {
	s.Body = v
	return s
}

type DeleteAttachedMediaRequest struct {
	// The ID of the auxiliary media asset that you want to delete.
	//
	// 	- Separate multiple IDs with commas (,). You can specify up to 20 IDs.
	//
	// 	- You can obtain the ID from the response to the [CreateUploadAttachedMedia](~~CreateUploadAttachedMedia~~) operation that you call to obtain the upload URL and credential.
	//
	// This parameter is required.
	//
	// example:
	//
	// 8bc8e94fe4e55abde85718****,eb186180e989dd56****
	MediaIds *string `json:"MediaIds,omitempty" xml:"MediaIds,omitempty"`
}

func (s DeleteAttachedMediaRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAttachedMediaRequest) GoString() string {
	return s.String()
}

func (s *DeleteAttachedMediaRequest) SetMediaIds(v string) *DeleteAttachedMediaRequest {
	s.MediaIds = &v
	return s
}

type DeleteAttachedMediaResponseBody struct {
	// The IDs of the auxiliary media assets that failed to be deleted.
	NonExistMediaIds []*string `json:"NonExistMediaIds,omitempty" xml:"NonExistMediaIds,omitempty" type:"Repeated"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4AF6-D7393642CA58****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteAttachedMediaResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAttachedMediaResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAttachedMediaResponseBody) SetNonExistMediaIds(v []*string) *DeleteAttachedMediaResponseBody {
	s.NonExistMediaIds = v
	return s
}

func (s *DeleteAttachedMediaResponseBody) SetRequestId(v string) *DeleteAttachedMediaResponseBody {
	s.RequestId = &v
	return s
}

type DeleteAttachedMediaResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteAttachedMediaResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteAttachedMediaResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAttachedMediaResponse) GoString() string {
	return s.String()
}

func (s *DeleteAttachedMediaResponse) SetHeaders(v map[string]*string) *DeleteAttachedMediaResponse {
	s.Headers = v
	return s
}

func (s *DeleteAttachedMediaResponse) SetStatusCode(v int32) *DeleteAttachedMediaResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAttachedMediaResponse) SetBody(v *DeleteAttachedMediaResponseBody) *DeleteAttachedMediaResponse {
	s.Body = v
	return s
}

type DeleteCategoryRequest struct {
	// The ID of the category. You can specify only one ID. You can use one of the following methods to obtain the ID:
	//
	// 	- Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). Choose **Configuration Management*	- > **Media Management*	- > **Categories**. On the Audio and Video / Image Category or Short Video Material Category tab, view the category ID.
	//
	// 	- Obtain the category ID from the response to the [AddCategory](~~AddCategory~~) operation.
	//
	// >  If you specify the ID of a parent category, all subcategories under the parent category are deleted at the same time.
	//
	// This parameter is required.
	//
	// example:
	//
	// 3300****
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
}

func (s DeleteCategoryRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteCategoryRequest) GoString() string {
	return s.String()
}

func (s *DeleteCategoryRequest) SetCateId(v int64) *DeleteCategoryRequest {
	s.CateId = &v
	return s
}

type DeleteCategoryResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4AF6-D7393642CA58****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteCategoryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteCategoryResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteCategoryResponseBody) SetRequestId(v string) *DeleteCategoryResponseBody {
	s.RequestId = &v
	return s
}

type DeleteCategoryResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteCategoryResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteCategoryResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteCategoryResponse) GoString() string {
	return s.String()
}

func (s *DeleteCategoryResponse) SetHeaders(v map[string]*string) *DeleteCategoryResponse {
	s.Headers = v
	return s
}

func (s *DeleteCategoryResponse) SetStatusCode(v int32) *DeleteCategoryResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteCategoryResponse) SetBody(v *DeleteCategoryResponseBody) *DeleteCategoryResponse {
	s.Body = v
	return s
}

type DeleteDynamicImageRequest struct {
	// The IDs of the animated stickers.
	//
	// - Separate multiple IDs with commas (,). You can specify a maximum of 10 IDs.
	//
	// - If you do not set this parameter, the system finds the video specified by the VideoId parameter and deletes the information about the animated stickers associated with the video. If more than 10 animated stickers are associated with the video specified by the VideoId parameter, the deletion request is denied.
	//
	// example:
	//
	// beafec3834a4e52ea52042a4****,8281c8519847fd8970e79e80b6****
	DynamicImageIds *string `json:"DynamicImageIds,omitempty" xml:"DynamicImageIds,omitempty"`
	// The ID of the video associated with the animated stickers whose information you want to delete.
	//
	// This parameter is required.
	//
	// example:
	//
	// 2321077d460b028700ef6c2f4d****
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s DeleteDynamicImageRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDynamicImageRequest) GoString() string {
	return s.String()
}

func (s *DeleteDynamicImageRequest) SetDynamicImageIds(v string) *DeleteDynamicImageRequest {
	s.DynamicImageIds = &v
	return s
}

func (s *DeleteDynamicImageRequest) SetVideoId(v string) *DeleteDynamicImageRequest {
	s.VideoId = &v
	return s
}

type DeleteDynamicImageResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 0C8F0FDD-A99F-4188-B41934C97A54****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDynamicImageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDynamicImageResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDynamicImageResponseBody) SetRequestId(v string) *DeleteDynamicImageResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDynamicImageResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteDynamicImageResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteDynamicImageResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDynamicImageResponse) GoString() string {
	return s.String()
}

func (s *DeleteDynamicImageResponse) SetHeaders(v map[string]*string) *DeleteDynamicImageResponse {
	s.Headers = v
	return s
}

func (s *DeleteDynamicImageResponse) SetStatusCode(v int32) *DeleteDynamicImageResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDynamicImageResponse) SetBody(v *DeleteDynamicImageResponseBody) *DeleteDynamicImageResponse {
	s.Body = v
	return s
}

type DeleteEditingProjectRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the online editing project. Separate multiple IDs with commas (,).
	//
	// This parameter is required.
	//
	// example:
	//
	// fb2101bf24bf41*****cb318787dc
	ProjectIds           *string `json:"ProjectIds,omitempty" xml:"ProjectIds,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteEditingProjectRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteEditingProjectRequest) GoString() string {
	return s.String()
}

func (s *DeleteEditingProjectRequest) SetOwnerAccount(v string) *DeleteEditingProjectRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteEditingProjectRequest) SetOwnerId(v string) *DeleteEditingProjectRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteEditingProjectRequest) SetProjectIds(v string) *DeleteEditingProjectRequest {
	s.ProjectIds = &v
	return s
}

func (s *DeleteEditingProjectRequest) SetResourceOwnerAccount(v string) *DeleteEditingProjectRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteEditingProjectRequest) SetResourceOwnerId(v string) *DeleteEditingProjectRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteEditingProjectResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A*****F6-D7393642CA58
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteEditingProjectResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteEditingProjectResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteEditingProjectResponseBody) SetRequestId(v string) *DeleteEditingProjectResponseBody {
	s.RequestId = &v
	return s
}

type DeleteEditingProjectResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteEditingProjectResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteEditingProjectResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteEditingProjectResponse) GoString() string {
	return s.String()
}

func (s *DeleteEditingProjectResponse) SetHeaders(v map[string]*string) *DeleteEditingProjectResponse {
	s.Headers = v
	return s
}

func (s *DeleteEditingProjectResponse) SetStatusCode(v int32) *DeleteEditingProjectResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteEditingProjectResponse) SetBody(v *DeleteEditingProjectResponseBody) *DeleteEditingProjectResponse {
	s.Body = v
	return s
}

type DeleteEditingProjectMaterialsRequest struct {
	// The material ID. Separate multiple material IDs with commas (,).
	//
	// This parameter is required.
	//
	// example:
	//
	// 9e3101bf24bf41c*****123318788ca
	MaterialIds *string `json:"MaterialIds,omitempty" xml:"MaterialIds,omitempty"`
	// The type of the material. Valid values:
	//
	// 	- **video**
	//
	// 	- **audio**
	//
	// 	- **image**
	//
	// This parameter is required.
	//
	// example:
	//
	// video
	MaterialType *string `json:"MaterialType,omitempty" xml:"MaterialType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the online editing project.
	//
	// This parameter is required.
	//
	// example:
	//
	// 198236101*****1093374
	ProjectId            *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteEditingProjectMaterialsRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteEditingProjectMaterialsRequest) GoString() string {
	return s.String()
}

func (s *DeleteEditingProjectMaterialsRequest) SetMaterialIds(v string) *DeleteEditingProjectMaterialsRequest {
	s.MaterialIds = &v
	return s
}

func (s *DeleteEditingProjectMaterialsRequest) SetMaterialType(v string) *DeleteEditingProjectMaterialsRequest {
	s.MaterialType = &v
	return s
}

func (s *DeleteEditingProjectMaterialsRequest) SetOwnerAccount(v string) *DeleteEditingProjectMaterialsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteEditingProjectMaterialsRequest) SetOwnerId(v string) *DeleteEditingProjectMaterialsRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteEditingProjectMaterialsRequest) SetProjectId(v string) *DeleteEditingProjectMaterialsRequest {
	s.ProjectId = &v
	return s
}

func (s *DeleteEditingProjectMaterialsRequest) SetResourceOwnerAccount(v string) *DeleteEditingProjectMaterialsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteEditingProjectMaterialsRequest) SetResourceOwnerId(v string) *DeleteEditingProjectMaterialsRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteEditingProjectMaterialsResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 746FFA07-8BBB-46*****B1-3E94E3B2915E
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteEditingProjectMaterialsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteEditingProjectMaterialsResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteEditingProjectMaterialsResponseBody) SetRequestId(v string) *DeleteEditingProjectMaterialsResponseBody {
	s.RequestId = &v
	return s
}

type DeleteEditingProjectMaterialsResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteEditingProjectMaterialsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteEditingProjectMaterialsResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteEditingProjectMaterialsResponse) GoString() string {
	return s.String()
}

func (s *DeleteEditingProjectMaterialsResponse) SetHeaders(v map[string]*string) *DeleteEditingProjectMaterialsResponse {
	s.Headers = v
	return s
}

func (s *DeleteEditingProjectMaterialsResponse) SetStatusCode(v int32) *DeleteEditingProjectMaterialsResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteEditingProjectMaterialsResponse) SetBody(v *DeleteEditingProjectMaterialsResponseBody) *DeleteEditingProjectMaterialsResponse {
	s.Body = v
	return s
}

type DeleteImageRequest struct {
	// The method that is used to delete images. Valid values:
	//
	// 	- **ImageURL**: deletes images based on URLs.
	//
	// 	- **ImageId**: deletes images based on image IDs.
	//
	// 	- **VideoId**: deletes images associated with a video based on the video ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// VideoId
	DeleteImageType *string `json:"DeleteImageType,omitempty" xml:"DeleteImageType,omitempty"`
	// The ID of the image. You can specify up to 20 image IDs and separate them with commas (,). You can use one of the following methods to obtain the image ID:
	//
	// 	- Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Media Files*	- > **Image*	- to view the image ID.
	//
	// 	- Obtain the image ID from the response to the [CreateUploadImage](~~CreateUploadImage~~) operation that you call to obtain the upload credential and URL.
	//
	// 	- Obtain the image ID from the response to the [SearchMedia](~~SearchMedia~~) operation that you call to query images.
	//
	// >  This parameter takes effect and is required only if you set **DeleteImageType*	- to **ImageId**.
	//
	// example:
	//
	// bbc65bba53fed90de118a7849****,594228cdd14b4d069fc17a8c4a****
	ImageIds *string `json:"ImageIds,omitempty" xml:"ImageIds,omitempty"`
	// The type of images that you want to delete. The images are associated with the video. Valid values:
	//
	// 	- **CoverSnapshot**: thumbnail snapshot.
	//
	// 	- **NormalSnapshot**: regular snapshot.
	//
	// 	- **SpriteSnapshot**: sprite snapshot.
	//
	// 	- **SpriteOriginSnapshot**: sprite source snapshot.
	//
	// 	- **All**: images of all the preceding types. You can specify multiple types other than `All` for this parameter. Separate multiple types with commas (,).
	//
	// >  This parameter takes effect and is required only if you set **DeleteImageType*	- to **VideoId**.
	//
	// example:
	//
	// All
	ImageType *string `json:"ImageType,omitempty" xml:"ImageType,omitempty"`
	// The URL of the image. You can obtain the value of `ImageURL` from the response to the [CreateUploadImage](~~CreateUploadImage~~) operation. You can specify up to 20 URLs and separate them with commas (,).
	//
	// >  This parameter takes effect and is required only if you set **DeleteImageType*	- to **ImageURL**.
	//
	// example:
	//
	// https://example.aliyundoc.com/image/default/41AE7ADABBE*****.png
	ImageURLs *string `json:"ImageURLs,omitempty" xml:"ImageURLs,omitempty"`
	// The ID of the video. You can specify only one ID. You can use one of the following methods to obtain the ID:
	//
	// 	- Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Media Files*	- > **Audio/Video**. On the Video and Audio page, view the ID of the media file.
	//
	// 	- Obtain the video ID from the response to the [CreateUploadVideo](~~CreateUploadVideo~~) operation that you call to obtain the upload credential and URL.
	//
	// 	- Obtain the video ID from the response to the [SearchMedia](~~SearchMedia~~) operation that you call to query videos.
	//
	// >  This parameter takes effect and is required only if you set **DeleteImageType*	- to **VideoId**.
	//
	// example:
	//
	// eb1861d2c9a8842340e989dd56****
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s DeleteImageRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteImageRequest) GoString() string {
	return s.String()
}

func (s *DeleteImageRequest) SetDeleteImageType(v string) *DeleteImageRequest {
	s.DeleteImageType = &v
	return s
}

func (s *DeleteImageRequest) SetImageIds(v string) *DeleteImageRequest {
	s.ImageIds = &v
	return s
}

func (s *DeleteImageRequest) SetImageType(v string) *DeleteImageRequest {
	s.ImageType = &v
	return s
}

func (s *DeleteImageRequest) SetImageURLs(v string) *DeleteImageRequest {
	s.ImageURLs = &v
	return s
}

func (s *DeleteImageRequest) SetVideoId(v string) *DeleteImageRequest {
	s.VideoId = &v
	return s
}

type DeleteImageResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4AF6-D7393642CA58****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteImageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteImageResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteImageResponseBody) SetRequestId(v string) *DeleteImageResponseBody {
	s.RequestId = &v
	return s
}

type DeleteImageResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteImageResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteImageResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteImageResponse) GoString() string {
	return s.String()
}

func (s *DeleteImageResponse) SetHeaders(v map[string]*string) *DeleteImageResponse {
	s.Headers = v
	return s
}

func (s *DeleteImageResponse) SetStatusCode(v int32) *DeleteImageResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteImageResponse) SetBody(v *DeleteImageResponseBody) *DeleteImageResponse {
	s.Body = v
	return s
}

type DeleteMessageCallbackRequest struct {
	// The ID of the application. If you do not set this parameter, the default value **app-1000000*	- is used.
	//
	// example:
	//
	// app-1000000
	AppId        *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
}

func (s DeleteMessageCallbackRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteMessageCallbackRequest) GoString() string {
	return s.String()
}

func (s *DeleteMessageCallbackRequest) SetAppId(v string) *DeleteMessageCallbackRequest {
	s.AppId = &v
	return s
}

func (s *DeleteMessageCallbackRequest) SetOwnerAccount(v string) *DeleteMessageCallbackRequest {
	s.OwnerAccount = &v
	return s
}

type DeleteMessageCallbackResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A13-****-D7393642CA58
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteMessageCallbackResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteMessageCallbackResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteMessageCallbackResponseBody) SetRequestId(v string) *DeleteMessageCallbackResponseBody {
	s.RequestId = &v
	return s
}

type DeleteMessageCallbackResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteMessageCallbackResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteMessageCallbackResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteMessageCallbackResponse) GoString() string {
	return s.String()
}

func (s *DeleteMessageCallbackResponse) SetHeaders(v map[string]*string) *DeleteMessageCallbackResponse {
	s.Headers = v
	return s
}

func (s *DeleteMessageCallbackResponse) SetStatusCode(v int32) *DeleteMessageCallbackResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteMessageCallbackResponse) SetBody(v *DeleteMessageCallbackResponseBody) *DeleteMessageCallbackResponse {
	s.Body = v
	return s
}

type DeleteMezzaninesRequest struct {
	// Specifies whether to forcibly delete the source file. Valid values:
	//
	// 	- **false*	- (default)
	//
	// 	- **true**
	//
	// >  If a video is uploaded without transcoding or is asynchronously transcoded, the source file of the video is used for original-quality playback. By default, the source file of the video cannot be deleted. To forcibly delete the mezzanine file, set this parameter to **true**.
	//
	// example:
	//
	// false
	Force *bool `json:"Force,omitempty" xml:"Force,omitempty"`
	// The IDs of audio or video files whose source files that you want to delete. You can specify up to 20 IDs. Separate multiple IDs with commas (,). You can use one of the following methods to obtain the ID:
	//
	// 	- After you upload a video in the [ApsaraVideo VOD console](https://vod.console.aliyun.com), you can log on to the ApsaraVideo VOD console and choose **Media Files*	- > **Audio/Video*	- to view the ID of the video.
	//
	// 	- Obtain the value of VideoId from the response to the [CreateUploadVideo](https://help.aliyun.com/document_detail/55407.html) operation that you called to obtain the upload URL and credential.
	//
	// 	- Obtain the value of VideoId from the response to the [SearchMedia](https://help.aliyun.com/document_detail/86044.html) operation that you called to query media information after the audio or video file is uploaded.
	//
	// This parameter is required.
	//
	// example:
	//
	// 23ab850b4f654b6e91d24d8157****,93ab850b4f6f4b6e91d24d81d4****
	VideoIds *string `json:"VideoIds,omitempty" xml:"VideoIds,omitempty"`
}

func (s DeleteMezzaninesRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteMezzaninesRequest) GoString() string {
	return s.String()
}

func (s *DeleteMezzaninesRequest) SetForce(v bool) *DeleteMezzaninesRequest {
	s.Force = &v
	return s
}

func (s *DeleteMezzaninesRequest) SetVideoIds(v string) *DeleteMezzaninesRequest {
	s.VideoIds = &v
	return s
}

type DeleteMezzaninesResponseBody struct {
	// The IDs of the audio or video files that do not exist.
	NonExistVideoIds []*string `json:"NonExistVideoIds,omitempty" xml:"NonExistVideoIds,omitempty" type:"Repeated"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4AF6-D7393642CA58****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The IDs of the audio or video files whose source files cannot be deleted.
	//
	// >  In most cases, source files cannot be deleted if they are used for original-quality playback or you do not have required permissions to delete them. For more information, see [Overview](https://help.aliyun.com/document_detail/113600.html).
	UnRemoveableVideoIds []*string `json:"UnRemoveableVideoIds,omitempty" xml:"UnRemoveableVideoIds,omitempty" type:"Repeated"`
}

func (s DeleteMezzaninesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteMezzaninesResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteMezzaninesResponseBody) SetNonExistVideoIds(v []*string) *DeleteMezzaninesResponseBody {
	s.NonExistVideoIds = v
	return s
}

func (s *DeleteMezzaninesResponseBody) SetRequestId(v string) *DeleteMezzaninesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteMezzaninesResponseBody) SetUnRemoveableVideoIds(v []*string) *DeleteMezzaninesResponseBody {
	s.UnRemoveableVideoIds = v
	return s
}

type DeleteMezzaninesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteMezzaninesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteMezzaninesResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteMezzaninesResponse) GoString() string {
	return s.String()
}

func (s *DeleteMezzaninesResponse) SetHeaders(v map[string]*string) *DeleteMezzaninesResponse {
	s.Headers = v
	return s
}

func (s *DeleteMezzaninesResponse) SetStatusCode(v int32) *DeleteMezzaninesResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteMezzaninesResponse) SetBody(v *DeleteMezzaninesResponseBody) *DeleteMezzaninesResponse {
	s.Body = v
	return s
}

type DeleteMultipartUploadRequest struct {
	// The ID of the media file (VideoId). You can use one of the following methods to obtain the ID:
	//
	// 	- After you upload a video in the [ApsaraVideo VOD console](https://vod.console.aliyun.com), you can log on to the ApsaraVideo VOD console and choose **Media Files*	- > **Audio/Video*	- to view the ID of the video.
	//
	// 	- Obtain the value of VideoId from the response to the [CreateUploadVideo](https://help.aliyun.com/document_detail/55407.html) operation that you called to obtain the upload URL and credential.
	//
	// 	- Obtain the value of VideoId from the response to the [SearchMedia](https://help.aliyun.com/document_detail/86044.html) operation that you called to query media information after the audio or video file is uploaded.
	//
	// This parameter is required.
	//
	// example:
	//
	// 61ccbdb06fa3012be4d8083f6****
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The type of the media file. Set the value to **video**. video indicates audio and video files.
	//
	// This parameter is required.
	//
	// example:
	//
	// video
	MediaType    *string `json:"MediaType,omitempty" xml:"MediaType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
}

func (s DeleteMultipartUploadRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteMultipartUploadRequest) GoString() string {
	return s.String()
}

func (s *DeleteMultipartUploadRequest) SetMediaId(v string) *DeleteMultipartUploadRequest {
	s.MediaId = &v
	return s
}

func (s *DeleteMultipartUploadRequest) SetMediaType(v string) *DeleteMultipartUploadRequest {
	s.MediaType = &v
	return s
}

func (s *DeleteMultipartUploadRequest) SetOwnerAccount(v string) *DeleteMultipartUploadRequest {
	s.OwnerAccount = &v
	return s
}

type DeleteMultipartUploadResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4AF6-D7393642CA58****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteMultipartUploadResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteMultipartUploadResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteMultipartUploadResponseBody) SetRequestId(v string) *DeleteMultipartUploadResponseBody {
	s.RequestId = &v
	return s
}

type DeleteMultipartUploadResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteMultipartUploadResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteMultipartUploadResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteMultipartUploadResponse) GoString() string {
	return s.String()
}

func (s *DeleteMultipartUploadResponse) SetHeaders(v map[string]*string) *DeleteMultipartUploadResponse {
	s.Headers = v
	return s
}

func (s *DeleteMultipartUploadResponse) SetStatusCode(v int32) *DeleteMultipartUploadResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteMultipartUploadResponse) SetBody(v *DeleteMultipartUploadResponseBody) *DeleteMultipartUploadResponse {
	s.Body = v
	return s
}

type DeleteStreamRequest struct {
	// The job IDs for deleting media streams.
	//
	// 	- Separate multiple IDs with commas (,). A maximum of 20 IDs can be specified for one video.
	//
	// 	- You can obtain job IDs from the PlayInfo parameter that is returned after you call the [GetPlayInfo](https://help.aliyun.com/document_detail/56124.html) operation. Each media stream has a unique job ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// 35eb4dbda18c49cc0025df374b46****
	JobIds *string `json:"JobIds,omitempty" xml:"JobIds,omitempty"`
	// The ID of the video.
	//
	// This parameter is required.
	//
	// example:
	//
	// 95948ddba24446b6aed5db985e78****
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s DeleteStreamRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteStreamRequest) GoString() string {
	return s.String()
}

func (s *DeleteStreamRequest) SetJobIds(v string) *DeleteStreamRequest {
	s.JobIds = &v
	return s
}

func (s *DeleteStreamRequest) SetVideoId(v string) *DeleteStreamRequest {
	s.VideoId = &v
	return s
}

type DeleteStreamResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A7U43F6-D7393642****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteStreamResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteStreamResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteStreamResponseBody) SetRequestId(v string) *DeleteStreamResponseBody {
	s.RequestId = &v
	return s
}

type DeleteStreamResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteStreamResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteStreamResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteStreamResponse) GoString() string {
	return s.String()
}

func (s *DeleteStreamResponse) SetHeaders(v map[string]*string) *DeleteStreamResponse {
	s.Headers = v
	return s
}

func (s *DeleteStreamResponse) SetStatusCode(v int32) *DeleteStreamResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteStreamResponse) SetBody(v *DeleteStreamResponseBody) *DeleteStreamResponse {
	s.Body = v
	return s
}

type DeleteTranscodeTemplateGroupRequest struct {
	// Specifies whether to forcibly delete the transcoding template group. Valid values:
	//
	// 	- **true**: deletes the transcoding template group and all the transcoding templates in the group.
	//
	// 	- **false*	- (default): deletes only the specified transcoding templates from the transcoding template group.
	//
	// example:
	//
	// true
	ForceDelGroup *string `json:"ForceDelGroup,omitempty" xml:"ForceDelGroup,omitempty"`
	// The ID of the transcoding template group.
	//
	// This parameter is required.
	//
	// example:
	//
	// 4c71a339fec*****152b4fa6f4527
	TranscodeTemplateGroupId *string `json:"TranscodeTemplateGroupId,omitempty" xml:"TranscodeTemplateGroupId,omitempty"`
	// The IDs of the transcoding templates that you want to delete.
	//
	// 	- Separate multiple IDs with commas (,).
	//
	// 	- You can specify a maximum of 10 IDs.
	//
	// 	- This parameter is required if you set ForceDelGroup to false or leave ForceDelGroup empty.
	//
	// example:
	//
	// ["613702defdc4*****6a3b94cace1129e","bfd6c90253a2*****7fc054d7c5825"]
	TranscodeTemplateIds *string `json:"TranscodeTemplateIds,omitempty" xml:"TranscodeTemplateIds,omitempty"`
}

func (s DeleteTranscodeTemplateGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteTranscodeTemplateGroupRequest) GoString() string {
	return s.String()
}

func (s *DeleteTranscodeTemplateGroupRequest) SetForceDelGroup(v string) *DeleteTranscodeTemplateGroupRequest {
	s.ForceDelGroup = &v
	return s
}

func (s *DeleteTranscodeTemplateGroupRequest) SetTranscodeTemplateGroupId(v string) *DeleteTranscodeTemplateGroupRequest {
	s.TranscodeTemplateGroupId = &v
	return s
}

func (s *DeleteTranscodeTemplateGroupRequest) SetTranscodeTemplateIds(v string) *DeleteTranscodeTemplateGroupRequest {
	s.TranscodeTemplateIds = &v
	return s
}

type DeleteTranscodeTemplateGroupResponseBody struct {
	// The IDs of transcoding templates that were not found.
	NonExistTranscodeTemplateIds []*string `json:"NonExistTranscodeTemplateIds,omitempty" xml:"NonExistTranscodeTemplateIds,omitempty" type:"Repeated"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A*****F6-D7393642CA58
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteTranscodeTemplateGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteTranscodeTemplateGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteTranscodeTemplateGroupResponseBody) SetNonExistTranscodeTemplateIds(v []*string) *DeleteTranscodeTemplateGroupResponseBody {
	s.NonExistTranscodeTemplateIds = v
	return s
}

func (s *DeleteTranscodeTemplateGroupResponseBody) SetRequestId(v string) *DeleteTranscodeTemplateGroupResponseBody {
	s.RequestId = &v
	return s
}

type DeleteTranscodeTemplateGroupResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteTranscodeTemplateGroupResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteTranscodeTemplateGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteTranscodeTemplateGroupResponse) GoString() string {
	return s.String()
}

func (s *DeleteTranscodeTemplateGroupResponse) SetHeaders(v map[string]*string) *DeleteTranscodeTemplateGroupResponse {
	s.Headers = v
	return s
}

func (s *DeleteTranscodeTemplateGroupResponse) SetStatusCode(v int32) *DeleteTranscodeTemplateGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteTranscodeTemplateGroupResponse) SetBody(v *DeleteTranscodeTemplateGroupResponseBody) *DeleteTranscodeTemplateGroupResponse {
	s.Body = v
	return s
}

type DeleteVideoRequest struct {
	// The list of video IDs. Separate multiple IDs with commas (,). A maximum of 20 IDs can be specified. You can obtain a video ID in one of the following ways:
	//
	// 	- If the video is uploaded by using the [ApsaraVideo VOD console](https://vod.console.aliyun.com), log on to the console and choose **Media Files*	- > **Audio/Video*	- to view the ID of the video.
	//
	// 	- If the video is uploaded by calling the [CreateUploadVideo](https://help.aliyun.com/document_detail/55407.html) operation, the video ID is the VideoId value in the response.
	//
	// 	- You can also call the [SearchMedia](https://help.aliyun.com/document_detail/86044.html) operation to obtain the video ID, which is the VideoId value in the response.
	//
	// This parameter is required.
	//
	// example:
	//
	// e44ebf1147hdsa2d2adbea8b****,e44ebf11oj984adbea8****,73ab850b4f6f4b6e91d24d81d54****
	VideoIds *string `json:"VideoIds,omitempty" xml:"VideoIds,omitempty"`
}

func (s DeleteVideoRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteVideoRequest) GoString() string {
	return s.String()
}

func (s *DeleteVideoRequest) SetVideoIds(v string) *DeleteVideoRequest {
	s.VideoIds = &v
	return s
}

type DeleteVideoResponseBody struct {
	// The IDs of the videos that cannot be deleted.
	//
	// > Generally, videos cannot be deleted if you do not have the required [permissions](https://help.aliyun.com/document_detail/113600.html).
	ForbiddenVideoIds []*string `json:"ForbiddenVideoIds,omitempty" xml:"ForbiddenVideoIds,omitempty" type:"Repeated"`
	// The IDs of the videos that do not exist.
	//
	// > If the list of videos to be deleted contains one or more videos that do not exist, the IDs of these non-existing videos are returned. If none of the videos in the list exists, a 404 error is returned.
	NonExistVideoIds []*string `json:"NonExistVideoIds,omitempty" xml:"NonExistVideoIds,omitempty" type:"Repeated"`
	// The ID of the request.
	//
	// example:
	//
	// E4EBD2BF-5EB0-4476-8829-9D94E1B1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteVideoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteVideoResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteVideoResponseBody) SetForbiddenVideoIds(v []*string) *DeleteVideoResponseBody {
	s.ForbiddenVideoIds = v
	return s
}

func (s *DeleteVideoResponseBody) SetNonExistVideoIds(v []*string) *DeleteVideoResponseBody {
	s.NonExistVideoIds = v
	return s
}

func (s *DeleteVideoResponseBody) SetRequestId(v string) *DeleteVideoResponseBody {
	s.RequestId = &v
	return s
}

type DeleteVideoResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteVideoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteVideoResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteVideoResponse) GoString() string {
	return s.String()
}

func (s *DeleteVideoResponse) SetHeaders(v map[string]*string) *DeleteVideoResponse {
	s.Headers = v
	return s
}

func (s *DeleteVideoResponse) SetStatusCode(v int32) *DeleteVideoResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteVideoResponse) SetBody(v *DeleteVideoResponseBody) *DeleteVideoResponse {
	s.Body = v
	return s
}

type DeleteVodDomainRequest struct {
	// The domain name for CDN that you want to delete.
	//
	// This parameter is required.
	//
	// example:
	//
	// example.com
	DomainName    *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerAccount  *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DeleteVodDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteVodDomainRequest) GoString() string {
	return s.String()
}

func (s *DeleteVodDomainRequest) SetDomainName(v string) *DeleteVodDomainRequest {
	s.DomainName = &v
	return s
}

func (s *DeleteVodDomainRequest) SetOwnerAccount(v string) *DeleteVodDomainRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteVodDomainRequest) SetOwnerId(v int64) *DeleteVodDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteVodDomainRequest) SetSecurityToken(v string) *DeleteVodDomainRequest {
	s.SecurityToken = &v
	return s
}

type DeleteVodDomainResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 15C66C7B-671A-4297-****-2C4477247A74
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteVodDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteVodDomainResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteVodDomainResponseBody) SetRequestId(v string) *DeleteVodDomainResponseBody {
	s.RequestId = &v
	return s
}

type DeleteVodDomainResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteVodDomainResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteVodDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteVodDomainResponse) GoString() string {
	return s.String()
}

func (s *DeleteVodDomainResponse) SetHeaders(v map[string]*string) *DeleteVodDomainResponse {
	s.Headers = v
	return s
}

func (s *DeleteVodDomainResponse) SetStatusCode(v int32) *DeleteVodDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteVodDomainResponse) SetBody(v *DeleteVodDomainResponseBody) *DeleteVodDomainResponse {
	s.Body = v
	return s
}

type DeleteVodSpecificConfigRequest struct {
	// The ID of the configuration.
	//
	// This parameter is required.
	//
	// example:
	//
	// 2317****
	ConfigId *string `json:"ConfigId,omitempty" xml:"ConfigId,omitempty"`
	// The accelerated domain name.
	//
	// This parameter is required.
	//
	// example:
	//
	// www.example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The environment from which the domain name configurations are deleted. Valid values:
	//
	// 	- online: production environment
	//
	// 	- gray: simulation environment
	//
	// example:
	//
	// online
	Env           *string `json:"Env,omitempty" xml:"Env,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DeleteVodSpecificConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteVodSpecificConfigRequest) GoString() string {
	return s.String()
}

func (s *DeleteVodSpecificConfigRequest) SetConfigId(v string) *DeleteVodSpecificConfigRequest {
	s.ConfigId = &v
	return s
}

func (s *DeleteVodSpecificConfigRequest) SetDomainName(v string) *DeleteVodSpecificConfigRequest {
	s.DomainName = &v
	return s
}

func (s *DeleteVodSpecificConfigRequest) SetEnv(v string) *DeleteVodSpecificConfigRequest {
	s.Env = &v
	return s
}

func (s *DeleteVodSpecificConfigRequest) SetOwnerId(v int64) *DeleteVodSpecificConfigRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteVodSpecificConfigRequest) SetSecurityToken(v string) *DeleteVodSpecificConfigRequest {
	s.SecurityToken = &v
	return s
}

type DeleteVodSpecificConfigResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 04F0F334-1335-436C-****-6C044FE73368
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteVodSpecificConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteVodSpecificConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteVodSpecificConfigResponseBody) SetRequestId(v string) *DeleteVodSpecificConfigResponseBody {
	s.RequestId = &v
	return s
}

type DeleteVodSpecificConfigResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteVodSpecificConfigResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteVodSpecificConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteVodSpecificConfigResponse) GoString() string {
	return s.String()
}

func (s *DeleteVodSpecificConfigResponse) SetHeaders(v map[string]*string) *DeleteVodSpecificConfigResponse {
	s.Headers = v
	return s
}

func (s *DeleteVodSpecificConfigResponse) SetStatusCode(v int32) *DeleteVodSpecificConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteVodSpecificConfigResponse) SetBody(v *DeleteVodSpecificConfigResponseBody) *DeleteVodSpecificConfigResponse {
	s.Body = v
	return s
}

type DeleteVodTemplateRequest struct {
	// The ID of the snapshot template.
	//
	// This parameter is required.
	//
	// example:
	//
	// f5b228fe6930e*****d6bf55bd87789
	VodTemplateId *string `json:"VodTemplateId,omitempty" xml:"VodTemplateId,omitempty"`
}

func (s DeleteVodTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteVodTemplateRequest) GoString() string {
	return s.String()
}

func (s *DeleteVodTemplateRequest) SetVodTemplateId(v string) *DeleteVodTemplateRequest {
	s.VodTemplateId = &v
	return s
}

type DeleteVodTemplateResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A*****F6-D7393642CA58
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the snapshot template.
	//
	// example:
	//
	// f5b228fe6930e*****d6bf55bd87789
	VodTemplateId *string `json:"VodTemplateId,omitempty" xml:"VodTemplateId,omitempty"`
}

func (s DeleteVodTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteVodTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteVodTemplateResponseBody) SetRequestId(v string) *DeleteVodTemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteVodTemplateResponseBody) SetVodTemplateId(v string) *DeleteVodTemplateResponseBody {
	s.VodTemplateId = &v
	return s
}

type DeleteVodTemplateResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteVodTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteVodTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteVodTemplateResponse) GoString() string {
	return s.String()
}

func (s *DeleteVodTemplateResponse) SetHeaders(v map[string]*string) *DeleteVodTemplateResponse {
	s.Headers = v
	return s
}

func (s *DeleteVodTemplateResponse) SetStatusCode(v int32) *DeleteVodTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteVodTemplateResponse) SetBody(v *DeleteVodTemplateResponseBody) *DeleteVodTemplateResponse {
	s.Body = v
	return s
}

type DeleteWatermarkRequest struct {
	// The ID of watermark template that you want to delete. You can specify only one watermark template ID. You can obtain the ID by using one of the following methods:
	//
	// 	- Obtain the watermark template ID from the response to the [AddWatermark](~~AddWatermark~~) operation that you call to create a watermark template.
	//
	// 	- Obtain the watermark template ID from the response to the [ListWatermark](~~ListWatermark~~) operation that you call to query all watermark templates within your account.
	//
	// This parameter is required.
	//
	// example:
	//
	// 9bcc8bfadb843f*****09a2671d0df97
	WatermarkId *string `json:"WatermarkId,omitempty" xml:"WatermarkId,omitempty"`
}

func (s DeleteWatermarkRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteWatermarkRequest) GoString() string {
	return s.String()
}

func (s *DeleteWatermarkRequest) SetWatermarkId(v string) *DeleteWatermarkRequest {
	s.WatermarkId = &v
	return s
}

type DeleteWatermarkResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A*****F6-D7393642CA58
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteWatermarkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteWatermarkResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteWatermarkResponseBody) SetRequestId(v string) *DeleteWatermarkResponseBody {
	s.RequestId = &v
	return s
}

type DeleteWatermarkResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteWatermarkResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteWatermarkResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteWatermarkResponse) GoString() string {
	return s.String()
}

func (s *DeleteWatermarkResponse) SetHeaders(v map[string]*string) *DeleteWatermarkResponse {
	s.Headers = v
	return s
}

func (s *DeleteWatermarkResponse) SetStatusCode(v int32) *DeleteWatermarkResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteWatermarkResponse) SetBody(v *DeleteWatermarkResponseBody) *DeleteWatermarkResponse {
	s.Body = v
	return s
}

type DescribeMediaDistributionRequest struct {
	// The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. The maximum time range to query is 6 months.
	//
	// example:
	//
	// 2017-01-11T12:59:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The statistical interval. Default value: day. Valid values:
	//
	// 	- hour: natural hour of the start and end time.
	//
	// 	- day: natural day of the start and end time.
	//
	// 	- week: natural week of the start and end time.
	//
	// 	- month: natural month of the start and end time.
	//
	// example:
	//
	// day
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. The maximum time range to query is 6 months.
	//
	// example:
	//
	// 2017-01-11T12:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The hierarchical storage type. Valid values:
	//
	// 	- Standard
	//
	// 	- IA
	//
	// 	- Archive
	//
	// 	- ColdArchive
	//
	// 	- SourceIA
	//
	// 	- SourceArchive
	//
	// 	- SourceColdArchive
	//
	// 	- Changing
	//
	// 	- SourceChanging
	//
	// example:
	//
	// Standard
	StorageClass *string `json:"StorageClass,omitempty" xml:"StorageClass,omitempty"`
}

func (s DescribeMediaDistributionRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeMediaDistributionRequest) GoString() string {
	return s.String()
}

func (s *DescribeMediaDistributionRequest) SetEndTime(v string) *DescribeMediaDistributionRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeMediaDistributionRequest) SetInterval(v string) *DescribeMediaDistributionRequest {
	s.Interval = &v
	return s
}

func (s *DescribeMediaDistributionRequest) SetStartTime(v string) *DescribeMediaDistributionRequest {
	s.StartTime = &v
	return s
}

func (s *DescribeMediaDistributionRequest) SetStorageClass(v string) *DescribeMediaDistributionRequest {
	s.StorageClass = &v
	return s
}

type DescribeMediaDistributionResponseBody struct {
	// The distribution list of media assets. The data is displayed based on the statistical cycle of the natural hour, day, week, or month of the start and end time.
	MediaDistributionList []*DescribeMediaDistributionResponseBodyMediaDistributionList `json:"MediaDistributionList,omitempty" xml:"MediaDistributionList,omitempty" type:"Repeated"`
	// The request ID.
	//
	// example:
	//
	// 25818875-5F78-4AF6-D7393642CA58****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of media assets returned.
	//
	// example:
	//
	// 100
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s DescribeMediaDistributionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeMediaDistributionResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeMediaDistributionResponseBody) SetMediaDistributionList(v []*DescribeMediaDistributionResponseBodyMediaDistributionList) *DescribeMediaDistributionResponseBody {
	s.MediaDistributionList = v
	return s
}

func (s *DescribeMediaDistributionResponseBody) SetRequestId(v string) *DescribeMediaDistributionResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeMediaDistributionResponseBody) SetTotal(v int64) *DescribeMediaDistributionResponseBody {
	s.Total = &v
	return s
}

type DescribeMediaDistributionResponseBodyMediaDistributionList struct {
	// The number of media assets that are queried during the specified time range.
	//
	// example:
	//
	// 12
	Count *int64 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The end of the time range during which data is queried (exclusive). The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-11-14T00:00:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The start of the time range during which data is queried (inclusive). The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-11-13T00:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeMediaDistributionResponseBodyMediaDistributionList) String() string {
	return tea.Prettify(s)
}

func (s DescribeMediaDistributionResponseBodyMediaDistributionList) GoString() string {
	return s.String()
}

func (s *DescribeMediaDistributionResponseBodyMediaDistributionList) SetCount(v int64) *DescribeMediaDistributionResponseBodyMediaDistributionList {
	s.Count = &v
	return s
}

func (s *DescribeMediaDistributionResponseBodyMediaDistributionList) SetEndTime(v string) *DescribeMediaDistributionResponseBodyMediaDistributionList {
	s.EndTime = &v
	return s
}

func (s *DescribeMediaDistributionResponseBodyMediaDistributionList) SetStartTime(v string) *DescribeMediaDistributionResponseBodyMediaDistributionList {
	s.StartTime = &v
	return s
}

type DescribeMediaDistributionResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeMediaDistributionResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeMediaDistributionResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeMediaDistributionResponse) GoString() string {
	return s.String()
}

func (s *DescribeMediaDistributionResponse) SetHeaders(v map[string]*string) *DescribeMediaDistributionResponse {
	s.Headers = v
	return s
}

func (s *DescribeMediaDistributionResponse) SetStatusCode(v int32) *DescribeMediaDistributionResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeMediaDistributionResponse) SetBody(v *DescribeMediaDistributionResponseBody) *DescribeMediaDistributionResponse {
	s.Body = v
	return s
}

type DescribePlayTopVideosRequest struct {
	// The time to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// This parameter is required.
	//
	// example:
	//
	// 2016-06-29T13:00:00Z
	BizDate *string `json:"BizDate,omitempty" xml:"BizDate,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The page number. Default value: **1**.
	//
	// example:
	//
	// 1
	PageNo *int64 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The number of entries to return on each page. The default value is **100**. The maximum value is **1000**.
	//
	// example:
	//
	// 100
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribePlayTopVideosRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayTopVideosRequest) GoString() string {
	return s.String()
}

func (s *DescribePlayTopVideosRequest) SetBizDate(v string) *DescribePlayTopVideosRequest {
	s.BizDate = &v
	return s
}

func (s *DescribePlayTopVideosRequest) SetOwnerId(v int64) *DescribePlayTopVideosRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribePlayTopVideosRequest) SetPageNo(v int64) *DescribePlayTopVideosRequest {
	s.PageNo = &v
	return s
}

func (s *DescribePlayTopVideosRequest) SetPageSize(v int64) *DescribePlayTopVideosRequest {
	s.PageSize = &v
	return s
}

type DescribePlayTopVideosResponseBody struct {
	// The page number.
	//
	// example:
	//
	// 1
	PageNo *int64 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The number of entries per page.
	//
	// example:
	//
	// 100
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// 4B0BCF9F-2FD5-4817-****-7BEBBE3AF90B"
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The daily playback statistics on each top video.
	TopPlayVideos *DescribePlayTopVideosResponseBodyTopPlayVideos `json:"TopPlayVideos,omitempty" xml:"TopPlayVideos,omitempty" type:"Struct"`
	// The total number of entries that were collected in playback statistics on top videos.
	//
	// example:
	//
	// 2
	TotalNum *int64 `json:"TotalNum,omitempty" xml:"TotalNum,omitempty"`
}

func (s DescribePlayTopVideosResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayTopVideosResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePlayTopVideosResponseBody) SetPageNo(v int64) *DescribePlayTopVideosResponseBody {
	s.PageNo = &v
	return s
}

func (s *DescribePlayTopVideosResponseBody) SetPageSize(v int64) *DescribePlayTopVideosResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribePlayTopVideosResponseBody) SetRequestId(v string) *DescribePlayTopVideosResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribePlayTopVideosResponseBody) SetTopPlayVideos(v *DescribePlayTopVideosResponseBodyTopPlayVideos) *DescribePlayTopVideosResponseBody {
	s.TopPlayVideos = v
	return s
}

func (s *DescribePlayTopVideosResponseBody) SetTotalNum(v int64) *DescribePlayTopVideosResponseBody {
	s.TotalNum = &v
	return s
}

type DescribePlayTopVideosResponseBodyTopPlayVideos struct {
	TopPlayVideoStatis []*DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis `json:"TopPlayVideoStatis,omitempty" xml:"TopPlayVideoStatis,omitempty" type:"Repeated"`
}

func (s DescribePlayTopVideosResponseBodyTopPlayVideos) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayTopVideosResponseBodyTopPlayVideos) GoString() string {
	return s.String()
}

func (s *DescribePlayTopVideosResponseBodyTopPlayVideos) SetTopPlayVideoStatis(v []*DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis) *DescribePlayTopVideosResponseBodyTopPlayVideos {
	s.TopPlayVideoStatis = v
	return s
}

type DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis struct {
	// The total playback duration. Unit: milliseconds.
	//
	// example:
	//
	// 4640369
	PlayDuration *string `json:"PlayDuration,omitempty" xml:"PlayDuration,omitempty"`
	// The title of the video.
	//
	// example:
	//
	// Four streams (two streams encrypted): LD-HLS-encrypted + SD-MP4 + HD-H
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The number of unique visitors.
	//
	// example:
	//
	// 1
	UV *string `json:"UV,omitempty" xml:"UV,omitempty"`
	// The number of video views.
	//
	// example:
	//
	// 107
	VV *string `json:"VV,omitempty" xml:"VV,omitempty"`
	// The ID of the video.
	//
	// example:
	//
	// 2a8d4cb9ecbb487681473a15****8fda
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis) GoString() string {
	return s.String()
}

func (s *DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis) SetPlayDuration(v string) *DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis {
	s.PlayDuration = &v
	return s
}

func (s *DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis) SetTitle(v string) *DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis {
	s.Title = &v
	return s
}

func (s *DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis) SetUV(v string) *DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis {
	s.UV = &v
	return s
}

func (s *DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis) SetVV(v string) *DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis {
	s.VV = &v
	return s
}

func (s *DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis) SetVideoId(v string) *DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis {
	s.VideoId = &v
	return s
}

type DescribePlayTopVideosResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribePlayTopVideosResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribePlayTopVideosResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayTopVideosResponse) GoString() string {
	return s.String()
}

func (s *DescribePlayTopVideosResponse) SetHeaders(v map[string]*string) *DescribePlayTopVideosResponse {
	s.Headers = v
	return s
}

func (s *DescribePlayTopVideosResponse) SetStatusCode(v int32) *DescribePlayTopVideosResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePlayTopVideosResponse) SetBody(v *DescribePlayTopVideosResponseBody) *DescribePlayTopVideosResponse {
	s.Body = v
	return s
}

type DescribePlayUserAvgRequest struct {
	// The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// This parameter is required.
	//
	// example:
	//
	// 2016-06-30T13:00:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// This parameter is required.
	//
	// example:
	//
	// 2016-06-29T13:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribePlayUserAvgRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayUserAvgRequest) GoString() string {
	return s.String()
}

func (s *DescribePlayUserAvgRequest) SetEndTime(v string) *DescribePlayUserAvgRequest {
	s.EndTime = &v
	return s
}

func (s *DescribePlayUserAvgRequest) SetOwnerId(v int64) *DescribePlayUserAvgRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribePlayUserAvgRequest) SetStartTime(v string) *DescribePlayUserAvgRequest {
	s.StartTime = &v
	return s
}

type DescribePlayUserAvgResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 6C7F90B2-BDA4-4FAC-****-A38A121DFE19
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The statistics on average playback each day.
	UserPlayStatisAvgs *DescribePlayUserAvgResponseBodyUserPlayStatisAvgs `json:"UserPlayStatisAvgs,omitempty" xml:"UserPlayStatisAvgs,omitempty" type:"Struct"`
}

func (s DescribePlayUserAvgResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayUserAvgResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePlayUserAvgResponseBody) SetRequestId(v string) *DescribePlayUserAvgResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribePlayUserAvgResponseBody) SetUserPlayStatisAvgs(v *DescribePlayUserAvgResponseBodyUserPlayStatisAvgs) *DescribePlayUserAvgResponseBody {
	s.UserPlayStatisAvgs = v
	return s
}

type DescribePlayUserAvgResponseBodyUserPlayStatisAvgs struct {
	UserPlayStatisAvg []*DescribePlayUserAvgResponseBodyUserPlayStatisAvgsUserPlayStatisAvg `json:"UserPlayStatisAvg,omitempty" xml:"UserPlayStatisAvg,omitempty" type:"Repeated"`
}

func (s DescribePlayUserAvgResponseBodyUserPlayStatisAvgs) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayUserAvgResponseBodyUserPlayStatisAvgs) GoString() string {
	return s.String()
}

func (s *DescribePlayUserAvgResponseBodyUserPlayStatisAvgs) SetUserPlayStatisAvg(v []*DescribePlayUserAvgResponseBodyUserPlayStatisAvgsUserPlayStatisAvg) *DescribePlayUserAvgResponseBodyUserPlayStatisAvgs {
	s.UserPlayStatisAvg = v
	return s
}

type DescribePlayUserAvgResponseBodyUserPlayStatisAvgsUserPlayStatisAvg struct {
	// The average number of video views.
	//
	// example:
	//
	// 170
	AvgPlayCount *string `json:"AvgPlayCount,omitempty" xml:"AvgPlayCount,omitempty"`
	// The average playback duration. Unit: milliseconds.
	//
	// example:
	//
	// 1035902.8
	AvgPlayDuration *string `json:"AvgPlayDuration,omitempty" xml:"AvgPlayDuration,omitempty"`
	// The date when the statistics were generated. The date follows the *yyyy-MM-dd	- format.
	//
	// example:
	//
	// 20170120
	Date *string `json:"Date,omitempty" xml:"Date,omitempty"`
}

func (s DescribePlayUserAvgResponseBodyUserPlayStatisAvgsUserPlayStatisAvg) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayUserAvgResponseBodyUserPlayStatisAvgsUserPlayStatisAvg) GoString() string {
	return s.String()
}

func (s *DescribePlayUserAvgResponseBodyUserPlayStatisAvgsUserPlayStatisAvg) SetAvgPlayCount(v string) *DescribePlayUserAvgResponseBodyUserPlayStatisAvgsUserPlayStatisAvg {
	s.AvgPlayCount = &v
	return s
}

func (s *DescribePlayUserAvgResponseBodyUserPlayStatisAvgsUserPlayStatisAvg) SetAvgPlayDuration(v string) *DescribePlayUserAvgResponseBodyUserPlayStatisAvgsUserPlayStatisAvg {
	s.AvgPlayDuration = &v
	return s
}

func (s *DescribePlayUserAvgResponseBodyUserPlayStatisAvgsUserPlayStatisAvg) SetDate(v string) *DescribePlayUserAvgResponseBodyUserPlayStatisAvgsUserPlayStatisAvg {
	s.Date = &v
	return s
}

type DescribePlayUserAvgResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribePlayUserAvgResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribePlayUserAvgResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayUserAvgResponse) GoString() string {
	return s.String()
}

func (s *DescribePlayUserAvgResponse) SetHeaders(v map[string]*string) *DescribePlayUserAvgResponse {
	s.Headers = v
	return s
}

func (s *DescribePlayUserAvgResponse) SetStatusCode(v int32) *DescribePlayUserAvgResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePlayUserAvgResponse) SetBody(v *DescribePlayUserAvgResponseBody) *DescribePlayUserAvgResponse {
	s.Body = v
	return s
}

type DescribePlayUserTotalRequest struct {
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// >  The end time must be later than the start time. The interval between the start time and the end time cannot exceed 180 days.
	//
	// This parameter is required.
	//
	// example:
	//
	// 2016-06-30T13:00:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// This parameter is required.
	//
	// example:
	//
	// 2016-06-29T13:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribePlayUserTotalRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayUserTotalRequest) GoString() string {
	return s.String()
}

func (s *DescribePlayUserTotalRequest) SetEndTime(v string) *DescribePlayUserTotalRequest {
	s.EndTime = &v
	return s
}

func (s *DescribePlayUserTotalRequest) SetOwnerId(v int64) *DescribePlayUserTotalRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribePlayUserTotalRequest) SetStartTime(v string) *DescribePlayUserTotalRequest {
	s.StartTime = &v
	return s
}

type DescribePlayUserTotalResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 1FAFB884-D5A7-47D1-****-8928AA9C8720
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The daily playback statistics.
	UserPlayStatisTotals *DescribePlayUserTotalResponseBodyUserPlayStatisTotals `json:"UserPlayStatisTotals,omitempty" xml:"UserPlayStatisTotals,omitempty" type:"Struct"`
}

func (s DescribePlayUserTotalResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayUserTotalResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePlayUserTotalResponseBody) SetRequestId(v string) *DescribePlayUserTotalResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribePlayUserTotalResponseBody) SetUserPlayStatisTotals(v *DescribePlayUserTotalResponseBodyUserPlayStatisTotals) *DescribePlayUserTotalResponseBody {
	s.UserPlayStatisTotals = v
	return s
}

type DescribePlayUserTotalResponseBodyUserPlayStatisTotals struct {
	UserPlayStatisTotal []*DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal `json:"UserPlayStatisTotal,omitempty" xml:"UserPlayStatisTotal,omitempty" type:"Repeated"`
}

func (s DescribePlayUserTotalResponseBodyUserPlayStatisTotals) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayUserTotalResponseBodyUserPlayStatisTotals) GoString() string {
	return s.String()
}

func (s *DescribePlayUserTotalResponseBodyUserPlayStatisTotals) SetUserPlayStatisTotal(v []*DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal) *DescribePlayUserTotalResponseBodyUserPlayStatisTotals {
	s.UserPlayStatisTotal = v
	return s
}

type DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal struct {
	// The date. The date is displayed in the yyyy-MM-dd format.
	//
	// example:
	//
	// 20170120
	Date *string `json:"Date,omitempty" xml:"Date,omitempty"`
	// The total playback duration. Unit: milliseconds.
	//
	// example:
	//
	// 9340070
	PlayDuration *string `json:"PlayDuration,omitempty" xml:"PlayDuration,omitempty"`
	// The distribution of the playback duration.
	//
	// example:
	//
	// "<=1m:74.3%;>1<=5m:22.8%;>5<=10m:1.0%;>10<=15m:1.0%;>15<=30m:1.0%"
	PlayRange *string `json:"PlayRange,omitempty" xml:"PlayRange,omitempty"`
	// The total number of unique visitors.
	UV *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV `json:"UV,omitempty" xml:"UV,omitempty" type:"Struct"`
	// The total number of video views.
	VV *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV `json:"VV,omitempty" xml:"VV,omitempty" type:"Struct"`
}

func (s DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal) GoString() string {
	return s.String()
}

func (s *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal) SetDate(v string) *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal {
	s.Date = &v
	return s
}

func (s *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal) SetPlayDuration(v string) *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal {
	s.PlayDuration = &v
	return s
}

func (s *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal) SetPlayRange(v string) *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal {
	s.PlayRange = &v
	return s
}

func (s *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal) SetUV(v *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV) *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal {
	s.UV = v
	return s
}

func (s *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal) SetVV(v *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV) *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal {
	s.VV = v
	return s
}

type DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV struct {
	// The total number of unique visitors who use ApsaraVideo Player SDK for Android.
	//
	// example:
	//
	// 2
	Android *string `json:"Android,omitempty" xml:"Android,omitempty"`
	// The total number of unique visitors who use the Flash player.
	//
	// example:
	//
	// 1
	Flash *string `json:"Flash,omitempty" xml:"Flash,omitempty"`
	// The total number of unique visitors who use the HTML5 player.
	//
	// example:
	//
	// 1
	HTML5 *string `json:"HTML5,omitempty" xml:"HTML5,omitempty"`
	// The total number of unique visitors who use ApsaraVideo Player SDK for iOS.
	//
	// example:
	//
	// 0
	IOS *string `json:"iOS,omitempty" xml:"iOS,omitempty"`
}

func (s DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV) GoString() string {
	return s.String()
}

func (s *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV) SetAndroid(v string) *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV {
	s.Android = &v
	return s
}

func (s *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV) SetFlash(v string) *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV {
	s.Flash = &v
	return s
}

func (s *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV) SetHTML5(v string) *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV {
	s.HTML5 = &v
	return s
}

func (s *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV) SetIOS(v string) *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV {
	s.IOS = &v
	return s
}

type DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV struct {
	// The total number of video views played by using ApsaraVideo Player SDK for Android.
	//
	// example:
	//
	// 161
	Android *string `json:"Android,omitempty" xml:"Android,omitempty"`
	// The total number of video views played by using the Flash player.
	//
	// example:
	//
	// 2
	Flash *string `json:"Flash,omitempty" xml:"Flash,omitempty"`
	// The total number of video views played by using the HTML5 player.
	//
	// example:
	//
	// 2
	HTML5 *string `json:"HTML5,omitempty" xml:"HTML5,omitempty"`
	// The total number of video views played by using ApsaraVideo Player SDK for iOS.
	//
	// example:
	//
	// 0
	IOS *string `json:"iOS,omitempty" xml:"iOS,omitempty"`
}

func (s DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV) GoString() string {
	return s.String()
}

func (s *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV) SetAndroid(v string) *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV {
	s.Android = &v
	return s
}

func (s *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV) SetFlash(v string) *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV {
	s.Flash = &v
	return s
}

func (s *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV) SetHTML5(v string) *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV {
	s.HTML5 = &v
	return s
}

func (s *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV) SetIOS(v string) *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV {
	s.IOS = &v
	return s
}

type DescribePlayUserTotalResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribePlayUserTotalResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribePlayUserTotalResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayUserTotalResponse) GoString() string {
	return s.String()
}

func (s *DescribePlayUserTotalResponse) SetHeaders(v map[string]*string) *DescribePlayUserTotalResponse {
	s.Headers = v
	return s
}

func (s *DescribePlayUserTotalResponse) SetStatusCode(v int32) *DescribePlayUserTotalResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePlayUserTotalResponse) SetBody(v *DescribePlayUserTotalResponseBody) *DescribePlayUserTotalResponse {
	s.Body = v
	return s
}

type DescribePlayVideoStatisRequest struct {
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// >  The end time must be later than the start time. The interval between the start time and the end time cannot exceed 180 days.
	//
	// This parameter is required.
	//
	// example:
	//
	// 2016-06-30T13:00:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// This parameter is required.
	//
	// example:
	//
	// 2016-06-29T13:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The ID of the video. You can specify only one ID. You can use one of the following methods to obtain the ID:
	//
	// 	- Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Media Files*	- > **Audio/Video**. On the page that appears, view the video ID.
	//
	// 	- Obtain the video ID from the response to the [CreateUploadVideo](~~CreateUploadVideo~~) operation that you call to obtain the upload URL and credential.
	//
	// 	- Obtain the video ID from the response to the [SearchMedia](~~SearchMedia~~) operation that you call to query the audio or video file.
	//
	// This parameter is required.
	//
	// example:
	//
	// 2a8d4cb9ecbb487681473****aba8fda
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s DescribePlayVideoStatisRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayVideoStatisRequest) GoString() string {
	return s.String()
}

func (s *DescribePlayVideoStatisRequest) SetEndTime(v string) *DescribePlayVideoStatisRequest {
	s.EndTime = &v
	return s
}

func (s *DescribePlayVideoStatisRequest) SetOwnerId(v int64) *DescribePlayVideoStatisRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribePlayVideoStatisRequest) SetStartTime(v string) *DescribePlayVideoStatisRequest {
	s.StartTime = &v
	return s
}

func (s *DescribePlayVideoStatisRequest) SetVideoId(v string) *DescribePlayVideoStatisRequest {
	s.VideoId = &v
	return s
}

type DescribePlayVideoStatisResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// A92D3600-A3E7-43D6-****-B6E3B4A1FE6B
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The daily playback statistics on the video.
	VideoPlayStatisDetails *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetails `json:"VideoPlayStatisDetails,omitempty" xml:"VideoPlayStatisDetails,omitempty" type:"Struct"`
}

func (s DescribePlayVideoStatisResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayVideoStatisResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePlayVideoStatisResponseBody) SetRequestId(v string) *DescribePlayVideoStatisResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribePlayVideoStatisResponseBody) SetVideoPlayStatisDetails(v *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetails) *DescribePlayVideoStatisResponseBody {
	s.VideoPlayStatisDetails = v
	return s
}

type DescribePlayVideoStatisResponseBodyVideoPlayStatisDetails struct {
	VideoPlayStatisDetail []*DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail `json:"VideoPlayStatisDetail,omitempty" xml:"VideoPlayStatisDetail,omitempty" type:"Repeated"`
}

func (s DescribePlayVideoStatisResponseBodyVideoPlayStatisDetails) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayVideoStatisResponseBodyVideoPlayStatisDetails) GoString() string {
	return s.String()
}

func (s *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetails) SetVideoPlayStatisDetail(v []*DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail) *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetails {
	s.VideoPlayStatisDetail = v
	return s
}

type DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail struct {
	// The date. The time follows the ISO 8601 standard in the *YYYY-MM-DD*T*hh:mm:ss	- format. The time is displayed in UTC.
	//
	// example:
	//
	// 20170120
	Date *string `json:"Date,omitempty" xml:"Date,omitempty"`
	// The total playback duration. Unit: milliseconds.
	//
	// example:
	//
	// 967277
	PlayDuration *string `json:"PlayDuration,omitempty" xml:"PlayDuration,omitempty"`
	// The distribution of the playback duration.
	//
	// example:
	//
	// <=1m:79.2%;>1<=5m:16.7%;>5<=10m:4.2%
	PlayRange *string `json:"PlayRange,omitempty" xml:"PlayRange,omitempty"`
	// The video title.
	//
	// example:
	//
	// Four streams (one stream encrypted): LD-HLS + SD-MP4 + HD-HLS-encrypted + UHD-MP4
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The number of unique visitors.
	//
	// example:
	//
	// 1
	UV *string `json:"UV,omitempty" xml:"UV,omitempty"`
	// The number of video views.
	//
	// example:
	//
	// 24
	VV *string `json:"VV,omitempty" xml:"VV,omitempty"`
}

func (s DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail) GoString() string {
	return s.String()
}

func (s *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail) SetDate(v string) *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail {
	s.Date = &v
	return s
}

func (s *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail) SetPlayDuration(v string) *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail {
	s.PlayDuration = &v
	return s
}

func (s *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail) SetPlayRange(v string) *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail {
	s.PlayRange = &v
	return s
}

func (s *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail) SetTitle(v string) *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail {
	s.Title = &v
	return s
}

func (s *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail) SetUV(v string) *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail {
	s.UV = &v
	return s
}

func (s *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail) SetVV(v string) *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail {
	s.VV = &v
	return s
}

type DescribePlayVideoStatisResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribePlayVideoStatisResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribePlayVideoStatisResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayVideoStatisResponse) GoString() string {
	return s.String()
}

func (s *DescribePlayVideoStatisResponse) SetHeaders(v map[string]*string) *DescribePlayVideoStatisResponse {
	s.Headers = v
	return s
}

func (s *DescribePlayVideoStatisResponse) SetStatusCode(v int32) *DescribePlayVideoStatisResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePlayVideoStatisResponse) SetBody(v *DescribePlayVideoStatisResponseBody) *DescribePlayVideoStatisResponse {
	s.Body = v
	return s
}

type DescribeVodAIDataRequest struct {
	// The type of video AI. If you leave this parameter empty, statistics on video AI of all types are returned. Separate multiple types with commas (,). Valid values:
	//
	// 	- **AIVideoCensor**: automated review
	//
	// 	- **AIVideoFPShot**: media fingerprinting
	//
	// 	- **AIVideoTag**: smart tagging
	//
	// example:
	//
	// AIVideoCensor
	AIType *string `json:"AIType,omitempty" xml:"AIType,omitempty"`
	// The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time must be in UTC.
	//
	// This parameter is required.
	//
	// example:
	//
	// 2019-02-01T15:00:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region in which you want to query data. If you leave this parameter empty, data in all regions is returned. Separate multiple regions with commas (,). Valid values:
	//
	// 	- **cn-shanghai**: China (Shanghai)
	//
	// 	- **cn-beijing**: China (Beijing)
	//
	// 	- **eu-central-1**: Germany (Frankfurt)
	//
	// 	- **ap-southeast-1**: Singapore
	//
	// example:
	//
	// cn-beijing
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time must be in UTC.
	//
	// This parameter is required.
	//
	// example:
	//
	// 2019-02-01T13:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodAIDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodAIDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodAIDataRequest) SetAIType(v string) *DescribeVodAIDataRequest {
	s.AIType = &v
	return s
}

func (s *DescribeVodAIDataRequest) SetEndTime(v string) *DescribeVodAIDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodAIDataRequest) SetOwnerId(v int64) *DescribeVodAIDataRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodAIDataRequest) SetRegion(v string) *DescribeVodAIDataRequest {
	s.Region = &v
	return s
}

func (s *DescribeVodAIDataRequest) SetStartTime(v string) *DescribeVodAIDataRequest {
	s.StartTime = &v
	return s
}

type DescribeVodAIDataResponseBody struct {
	// The statistics on video AI.
	AIData *DescribeVodAIDataResponseBodyAIData `json:"AIData,omitempty" xml:"AIData,omitempty" type:"Struct"`
	// The time granularity at which the data was queried. Valid values:
	//
	// 	- **hour**
	//
	// 	- **day**
	//
	// example:
	//
	// day
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// C370DAF1-C838-4288-****-9A87633D248E
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeVodAIDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodAIDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodAIDataResponseBody) SetAIData(v *DescribeVodAIDataResponseBodyAIData) *DescribeVodAIDataResponseBody {
	s.AIData = v
	return s
}

func (s *DescribeVodAIDataResponseBody) SetDataInterval(v string) *DescribeVodAIDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeVodAIDataResponseBody) SetRequestId(v string) *DescribeVodAIDataResponseBody {
	s.RequestId = &v
	return s
}

type DescribeVodAIDataResponseBodyAIData struct {
	AIDataItem []*DescribeVodAIDataResponseBodyAIDataAIDataItem `json:"AIDataItem,omitempty" xml:"AIDataItem,omitempty" type:"Repeated"`
}

func (s DescribeVodAIDataResponseBodyAIData) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodAIDataResponseBodyAIData) GoString() string {
	return s.String()
}

func (s *DescribeVodAIDataResponseBodyAIData) SetAIDataItem(v []*DescribeVodAIDataResponseBodyAIDataAIDataItem) *DescribeVodAIDataResponseBodyAIData {
	s.AIDataItem = v
	return s
}

type DescribeVodAIDataResponseBodyAIDataAIDataItem struct {
	// The statistics on video AI of each type.
	Data *DescribeVodAIDataResponseBodyAIDataAIDataItemData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The timestamp of the returned data. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-02-01T13:00:00Z
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeVodAIDataResponseBodyAIDataAIDataItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodAIDataResponseBodyAIDataAIDataItem) GoString() string {
	return s.String()
}

func (s *DescribeVodAIDataResponseBodyAIDataAIDataItem) SetData(v *DescribeVodAIDataResponseBodyAIDataAIDataItemData) *DescribeVodAIDataResponseBodyAIDataAIDataItem {
	s.Data = v
	return s
}

func (s *DescribeVodAIDataResponseBodyAIDataAIDataItem) SetTimeStamp(v string) *DescribeVodAIDataResponseBodyAIDataAIDataItem {
	s.TimeStamp = &v
	return s
}

type DescribeVodAIDataResponseBodyAIDataAIDataItemData struct {
	DataItem []*DescribeVodAIDataResponseBodyAIDataAIDataItemDataDataItem `json:"DataItem,omitempty" xml:"DataItem,omitempty" type:"Repeated"`
}

func (s DescribeVodAIDataResponseBodyAIDataAIDataItemData) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodAIDataResponseBodyAIDataAIDataItemData) GoString() string {
	return s.String()
}

func (s *DescribeVodAIDataResponseBodyAIDataAIDataItemData) SetDataItem(v []*DescribeVodAIDataResponseBodyAIDataAIDataItemDataDataItem) *DescribeVodAIDataResponseBodyAIDataAIDataItemData {
	s.DataItem = v
	return s
}

type DescribeVodAIDataResponseBodyAIDataAIDataItemDataDataItem struct {
	// The type of video AI. Valid values:
	//
	// 	- **AIVideoCensor**: automated review
	//
	// 	- **AIVideoFPShot**: media fingerprinting
	//
	// 	- **AIVideoTag**: smart tagging
	//
	// example:
	//
	// AIVideoCensor
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The processing duration. Unit: seconds.
	//
	// example:
	//
	// 111
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVodAIDataResponseBodyAIDataAIDataItemDataDataItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodAIDataResponseBodyAIDataAIDataItemDataDataItem) GoString() string {
	return s.String()
}

func (s *DescribeVodAIDataResponseBodyAIDataAIDataItemDataDataItem) SetName(v string) *DescribeVodAIDataResponseBodyAIDataAIDataItemDataDataItem {
	s.Name = &v
	return s
}

func (s *DescribeVodAIDataResponseBodyAIDataAIDataItemDataDataItem) SetValue(v string) *DescribeVodAIDataResponseBodyAIDataAIDataItemDataDataItem {
	s.Value = &v
	return s
}

type DescribeVodAIDataResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodAIDataResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodAIDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodAIDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodAIDataResponse) SetHeaders(v map[string]*string) *DescribeVodAIDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodAIDataResponse) SetStatusCode(v int32) *DescribeVodAIDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodAIDataResponse) SetBody(v *DescribeVodAIDataResponseBody) *DescribeVodAIDataResponse {
	s.Body = v
	return s
}

type DescribeVodCertificateListRequest struct {
	// The domain name for CDN.
	//
	// example:
	//
	// example.com
	DomainName    *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeVodCertificateListRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodCertificateListRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodCertificateListRequest) SetDomainName(v string) *DescribeVodCertificateListRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodCertificateListRequest) SetOwnerId(v int64) *DescribeVodCertificateListRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodCertificateListRequest) SetSecurityToken(v string) *DescribeVodCertificateListRequest {
	s.SecurityToken = &v
	return s
}

type DescribeVodCertificateListResponseBody struct {
	// The information about each certificate.
	CertificateListModel *DescribeVodCertificateListResponseBodyCertificateListModel `json:"CertificateListModel,omitempty" xml:"CertificateListModel,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// FC0E34AC-0239-44A7-****-800DE522C8DA
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeVodCertificateListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodCertificateListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodCertificateListResponseBody) SetCertificateListModel(v *DescribeVodCertificateListResponseBodyCertificateListModel) *DescribeVodCertificateListResponseBody {
	s.CertificateListModel = v
	return s
}

func (s *DescribeVodCertificateListResponseBody) SetRequestId(v string) *DescribeVodCertificateListResponseBody {
	s.RequestId = &v
	return s
}

type DescribeVodCertificateListResponseBodyCertificateListModel struct {
	// The list of certificates.
	CertList *DescribeVodCertificateListResponseBodyCertificateListModelCertList `json:"CertList,omitempty" xml:"CertList,omitempty" type:"Struct"`
	// The number of certificates that are returned.
	//
	// example:
	//
	// 2
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
}

func (s DescribeVodCertificateListResponseBodyCertificateListModel) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodCertificateListResponseBodyCertificateListModel) GoString() string {
	return s.String()
}

func (s *DescribeVodCertificateListResponseBodyCertificateListModel) SetCertList(v *DescribeVodCertificateListResponseBodyCertificateListModelCertList) *DescribeVodCertificateListResponseBodyCertificateListModel {
	s.CertList = v
	return s
}

func (s *DescribeVodCertificateListResponseBodyCertificateListModel) SetCount(v int32) *DescribeVodCertificateListResponseBodyCertificateListModel {
	s.Count = &v
	return s
}

type DescribeVodCertificateListResponseBodyCertificateListModelCertList struct {
	Cert []*DescribeVodCertificateListResponseBodyCertificateListModelCertListCert `json:"Cert,omitempty" xml:"Cert,omitempty" type:"Repeated"`
}

func (s DescribeVodCertificateListResponseBodyCertificateListModelCertList) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodCertificateListResponseBodyCertificateListModelCertList) GoString() string {
	return s.String()
}

func (s *DescribeVodCertificateListResponseBodyCertificateListModelCertList) SetCert(v []*DescribeVodCertificateListResponseBodyCertificateListModelCertListCert) *DescribeVodCertificateListResponseBodyCertificateListModelCertList {
	s.Cert = v
	return s
}

type DescribeVodCertificateListResponseBodyCertificateListModelCertListCert struct {
	// The algorithm.
	//
	// example:
	//
	// RSA
	Algorithm *string `json:"Algorithm,omitempty" xml:"Algorithm,omitempty"`
	// The ID of the certificate.
	//
	// example:
	//
	// 235437
	CertId *int64 `json:"CertId,omitempty" xml:"CertId,omitempty"`
	// The ID of the certificate.
	//
	// example:
	//
	// 14173772-cn-hangzhou
	CertIdentifier *string `json:"CertIdentifier,omitempty" xml:"CertIdentifier,omitempty"`
	// The name of the certificate.
	//
	// example:
	//
	// certificate
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The common name of the certificate.
	//
	// example:
	//
	// test
	Common *string `json:"Common,omitempty" xml:"Common,omitempty"`
	// The time when the certificate was created.
	//
	// example:
	//
	// 1725206400000
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// DomainMatchCert.
	//
	// example:
	//
	// false
	DomainMatchCert *bool `json:"DomainMatchCert,omitempty" xml:"DomainMatchCert,omitempty"`
	// The time when the certificate expired.
	//
	// example:
	//
	// 1759507200000
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The fingerprint of the certificate.
	//
	// example:
	//
	// ****
	Fingerprint *string `json:"Fingerprint,omitempty" xml:"Fingerprint,omitempty"`
	// The ID of the instance.
	//
	// example:
	//
	// cert-cn-cd806ae0fdfbfa60
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The certificate authority (CA) that issued the certificate.
	//
	// example:
	//
	// ****
	Issuer *string `json:"Issuer,omitempty" xml:"Issuer,omitempty"`
	// The time when the certificate was issued. Unit: seconds.
	//
	// example:
	//
	// 1512388610
	LastTime *int64 `json:"LastTime,omitempty" xml:"LastTime,omitempty"`
	// The signAlgorithm.
	//
	// example:
	//
	// sha256withrsa
	SignAlgorithm *string `json:"SignAlgorithm,omitempty" xml:"SignAlgorithm,omitempty"`
}

func (s DescribeVodCertificateListResponseBodyCertificateListModelCertListCert) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodCertificateListResponseBodyCertificateListModelCertListCert) GoString() string {
	return s.String()
}

func (s *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert) SetAlgorithm(v string) *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert {
	s.Algorithm = &v
	return s
}

func (s *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert) SetCertId(v int64) *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert {
	s.CertId = &v
	return s
}

func (s *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert) SetCertIdentifier(v string) *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert {
	s.CertIdentifier = &v
	return s
}

func (s *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert) SetCertName(v string) *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert {
	s.CertName = &v
	return s
}

func (s *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert) SetCommon(v string) *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert {
	s.Common = &v
	return s
}

func (s *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert) SetCreateTime(v int64) *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert {
	s.CreateTime = &v
	return s
}

func (s *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert) SetDomainMatchCert(v bool) *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert {
	s.DomainMatchCert = &v
	return s
}

func (s *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert) SetEndTime(v int64) *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert {
	s.EndTime = &v
	return s
}

func (s *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert) SetFingerprint(v string) *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert {
	s.Fingerprint = &v
	return s
}

func (s *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert) SetInstanceId(v string) *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert {
	s.InstanceId = &v
	return s
}

func (s *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert) SetIssuer(v string) *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert {
	s.Issuer = &v
	return s
}

func (s *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert) SetLastTime(v int64) *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert {
	s.LastTime = &v
	return s
}

func (s *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert) SetSignAlgorithm(v string) *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert {
	s.SignAlgorithm = &v
	return s
}

type DescribeVodCertificateListResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodCertificateListResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodCertificateListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodCertificateListResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodCertificateListResponse) SetHeaders(v map[string]*string) *DescribeVodCertificateListResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodCertificateListResponse) SetStatusCode(v int32) *DescribeVodCertificateListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodCertificateListResponse) SetBody(v *DescribeVodCertificateListResponseBody) *DescribeVodCertificateListResponse {
	s.Body = v
	return s
}

type DescribeVodDomainBpsDataRequest struct {
	// The domain name to be queried. If you do not specify this parameter, the merged data of all your domain names for CDN is returned. You can specify multiple domain names. Separate them with commas (,).
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// example:
	//
	// 2015-12-10T14:00:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The query interval. Unit: seconds. Valid values: **300**, **3600**, and **86400**.
	//
	// 	- If the time range to query is less than 3 days, valid values are **300**, **3600**, and **86400**. The default value is 300.
	//
	// 	- If the time range to query is from 3 to less than 31 days, valid values are **3600*	- and **86400**. The default value is 3600.
	//
	// 	- If the time range to query is from 31 to 90 days, the valid value is **86400**.
	//
	// example:
	//
	// 300
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The name of the Internet service provider (ISP). If you do not specify this parameter, the data of all ISPs is returned.
	//
	// example:
	//
	// Alibaba
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region. If you do not specify this parameter, the data in all regions is returned. Only data in the China (Shanghai) region can be queried.
	//
	// example:
	//
	// cn-shanghai
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// > The minimum query interval is 5 minutes. If you do not specify this parameter, the data in the last 24 hours is queried.
	//
	// example:
	//
	// 2015-12-10T13:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainBpsDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainBpsDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainBpsDataRequest) SetDomainName(v string) *DescribeVodDomainBpsDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainBpsDataRequest) SetEndTime(v string) *DescribeVodDomainBpsDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainBpsDataRequest) SetInterval(v string) *DescribeVodDomainBpsDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeVodDomainBpsDataRequest) SetIspNameEn(v string) *DescribeVodDomainBpsDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeVodDomainBpsDataRequest) SetLocationNameEn(v string) *DescribeVodDomainBpsDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeVodDomainBpsDataRequest) SetOwnerId(v int64) *DescribeVodDomainBpsDataRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodDomainBpsDataRequest) SetStartTime(v string) *DescribeVodDomainBpsDataRequest {
	s.StartTime = &v
	return s
}

type DescribeVodDomainBpsDataResponseBody struct {
	// The bandwidth data that is collected for each interval.
	BpsDataPerInterval *DescribeVodDomainBpsDataResponseBodyBpsDataPerInterval `json:"BpsDataPerInterval,omitempty" xml:"BpsDataPerInterval,omitempty" type:"Struct"`
	// The time interval between the returned entries. Unit: seconds.
	//
	// example:
	//
	// 300
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The domain name for CDN.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range in which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2015-12-10T14:00:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The name of the ISP. By default, the data of all ISPs is returned.
	//
	// example:
	//
	// Alibaba
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region. By default, the data in all regions is returned.
	//
	// example:
	//
	// cn-shanghai
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// 3C6CCEC4-6B88-4D4A-****-D47B3D92CF8F
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range in which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2015-12-10T13:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainBpsDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainBpsDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainBpsDataResponseBody) SetBpsDataPerInterval(v *DescribeVodDomainBpsDataResponseBodyBpsDataPerInterval) *DescribeVodDomainBpsDataResponseBody {
	s.BpsDataPerInterval = v
	return s
}

func (s *DescribeVodDomainBpsDataResponseBody) SetDataInterval(v string) *DescribeVodDomainBpsDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeVodDomainBpsDataResponseBody) SetDomainName(v string) *DescribeVodDomainBpsDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainBpsDataResponseBody) SetEndTime(v string) *DescribeVodDomainBpsDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainBpsDataResponseBody) SetIspNameEn(v string) *DescribeVodDomainBpsDataResponseBody {
	s.IspNameEn = &v
	return s
}

func (s *DescribeVodDomainBpsDataResponseBody) SetLocationNameEn(v string) *DescribeVodDomainBpsDataResponseBody {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeVodDomainBpsDataResponseBody) SetRequestId(v string) *DescribeVodDomainBpsDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVodDomainBpsDataResponseBody) SetStartTime(v string) *DescribeVodDomainBpsDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeVodDomainBpsDataResponseBodyBpsDataPerInterval struct {
	DataModule []*DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainBpsDataResponseBodyBpsDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainBpsDataResponseBodyBpsDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainBpsDataResponseBodyBpsDataPerInterval) SetDataModule(v []*DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) *DescribeVodDomainBpsDataResponseBodyBpsDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule struct {
	// The bandwidth in mainland China. Unit: bit/s. When the bandwidth data is queried by ISP, no value is returned.
	//
	// example:
	//
	// 11286111
	DomesticValue *string `json:"DomesticValue,omitempty" xml:"DomesticValue,omitempty"`
	// The HTTPS bandwidth on L1 nodes in mainland China. Unit: bit/s. When the bandwidth data is queried by ISP, no value is returned.
	//
	// example:
	//
	// 11286111
	HttpsDomesticValue *string `json:"HttpsDomesticValue,omitempty" xml:"HttpsDomesticValue,omitempty"`
	// The HTTPS bandwidth on L1 nodes outside mainland China. Unit: bit/s. When the bandwidth data is queried by ISP, no value is returned.
	//
	// example:
	//
	// 2000
	HttpsOverseasValue *string `json:"HttpsOverseasValue,omitempty" xml:"HttpsOverseasValue,omitempty"`
	// The total HTTPS bandwidth on L1 nodes. Unit: bit/s.
	//
	// example:
	//
	// 11288111
	HttpsValue *string `json:"HttpsValue,omitempty" xml:"HttpsValue,omitempty"`
	// The bandwidth outside mainland China. Unit: bit/s. When the bandwidth data is queried by ISP, no value is returned.
	//
	// example:
	//
	// 2000
	OverseasValue *string `json:"OverseasValue,omitempty" xml:"OverseasValue,omitempty"`
	// The timestamp of the returned data. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	//
	// example:
	//
	// 2015-12-10T13:00:00Z
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The bandwidth. Unit: bit/s.
	//
	// example:
	//
	// 11288111
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) SetDomesticValue(v string) *DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.DomesticValue = &v
	return s
}

func (s *DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) SetHttpsDomesticValue(v string) *DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.HttpsDomesticValue = &v
	return s
}

func (s *DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) SetHttpsOverseasValue(v string) *DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.HttpsOverseasValue = &v
	return s
}

func (s *DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) SetHttpsValue(v string) *DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.HttpsValue = &v
	return s
}

func (s *DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) SetOverseasValue(v string) *DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.OverseasValue = &v
	return s
}

func (s *DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) SetValue(v string) *DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeVodDomainBpsDataResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodDomainBpsDataResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodDomainBpsDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainBpsDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainBpsDataResponse) SetHeaders(v map[string]*string) *DescribeVodDomainBpsDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodDomainBpsDataResponse) SetStatusCode(v int32) *DescribeVodDomainBpsDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodDomainBpsDataResponse) SetBody(v *DescribeVodDomainBpsDataResponseBody) *DescribeVodDomainBpsDataResponse {
	s.Body = v
	return s
}

type DescribeVodDomainBpsDataByLayerRequest struct {
	// The accelerated domain name. You can specify a maximum of 500 accelerated domain names. Separate multiple domain names with commas (,).
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// example:
	//
	// 2019-01-23T12:40:12Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time interval between the data entries. Unit: seconds.
	//
	// The time granularity varies based on the maximum time range per query. Valid values: 300 (5 minutes), 3600 (1 hour), and 86400 (1 day). For more information, see the supported time granularity described in Usage notes.
	//
	// example:
	//
	// 300
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The name of the Internet service provider (ISP).
	//
	// example:
	//
	// unicom
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The layer at which you want to query the data.
	//
	// Network layer: IPv4 and IPv6. Application layer: http, https, and quic. all: specifies that both the network and application layers are included. Default value: all.
	//
	// example:
	//
	// IPv4
	Layer *string `json:"Layer,omitempty" xml:"Layer,omitempty"`
	// The name of the region.
	//
	// example:
	//
	// beijing
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// example:
	//
	// 2019-01-23T12:35:12Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainBpsDataByLayerRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainBpsDataByLayerRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainBpsDataByLayerRequest) SetDomainName(v string) *DescribeVodDomainBpsDataByLayerRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainBpsDataByLayerRequest) SetEndTime(v string) *DescribeVodDomainBpsDataByLayerRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainBpsDataByLayerRequest) SetInterval(v string) *DescribeVodDomainBpsDataByLayerRequest {
	s.Interval = &v
	return s
}

func (s *DescribeVodDomainBpsDataByLayerRequest) SetIspNameEn(v string) *DescribeVodDomainBpsDataByLayerRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeVodDomainBpsDataByLayerRequest) SetLayer(v string) *DescribeVodDomainBpsDataByLayerRequest {
	s.Layer = &v
	return s
}

func (s *DescribeVodDomainBpsDataByLayerRequest) SetLocationNameEn(v string) *DescribeVodDomainBpsDataByLayerRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeVodDomainBpsDataByLayerRequest) SetOwnerId(v int64) *DescribeVodDomainBpsDataByLayerRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodDomainBpsDataByLayerRequest) SetStartTime(v string) *DescribeVodDomainBpsDataByLayerRequest {
	s.StartTime = &v
	return s
}

type DescribeVodDomainBpsDataByLayerResponseBody struct {
	// The bandwidth returned at each time interval. Unit: bit/s.
	BpsDataInterval *DescribeVodDomainBpsDataByLayerResponseBodyBpsDataInterval `json:"BpsDataInterval,omitempty" xml:"BpsDataInterval,omitempty" type:"Struct"`
	// The time interval between the entries returned. Unit: seconds.
	//
	// example:
	//
	// 300
	DataInterval *int32 `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A*****F6-D7393642CA58
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeVodDomainBpsDataByLayerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainBpsDataByLayerResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainBpsDataByLayerResponseBody) SetBpsDataInterval(v *DescribeVodDomainBpsDataByLayerResponseBodyBpsDataInterval) *DescribeVodDomainBpsDataByLayerResponseBody {
	s.BpsDataInterval = v
	return s
}

func (s *DescribeVodDomainBpsDataByLayerResponseBody) SetDataInterval(v int32) *DescribeVodDomainBpsDataByLayerResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeVodDomainBpsDataByLayerResponseBody) SetRequestId(v string) *DescribeVodDomainBpsDataByLayerResponseBody {
	s.RequestId = &v
	return s
}

type DescribeVodDomainBpsDataByLayerResponseBodyBpsDataInterval struct {
	DataModule []*DescribeVodDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainBpsDataByLayerResponseBodyBpsDataInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainBpsDataByLayerResponseBodyBpsDataInterval) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainBpsDataByLayerResponseBodyBpsDataInterval) SetDataModule(v []*DescribeVodDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule) *DescribeVodDomainBpsDataByLayerResponseBodyBpsDataInterval {
	s.DataModule = v
	return s
}

type DescribeVodDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule struct {
	// The timestamp of the data returned. The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.
	//
	// example:
	//
	// 2024-02-08T10:09:19Z
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The total traffic. Unit: bytes.
	//
	// example:
	//
	// 1000
	TrafficValue *int64 `json:"TrafficValue,omitempty" xml:"TrafficValue,omitempty"`
	// The peak bandwidth. Unit: bit/s.
	//
	// example:
	//
	// 75.33
	Value *float64 `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVodDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule) SetTimeStamp(v string) *DescribeVodDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeVodDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule) SetTrafficValue(v int64) *DescribeVodDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule {
	s.TrafficValue = &v
	return s
}

func (s *DescribeVodDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule) SetValue(v float64) *DescribeVodDomainBpsDataByLayerResponseBodyBpsDataIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeVodDomainBpsDataByLayerResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodDomainBpsDataByLayerResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodDomainBpsDataByLayerResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainBpsDataByLayerResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainBpsDataByLayerResponse) SetHeaders(v map[string]*string) *DescribeVodDomainBpsDataByLayerResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodDomainBpsDataByLayerResponse) SetStatusCode(v int32) *DescribeVodDomainBpsDataByLayerResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodDomainBpsDataByLayerResponse) SetBody(v *DescribeVodDomainBpsDataByLayerResponseBody) *DescribeVodDomainBpsDataByLayerResponse {
	s.Body = v
	return s
}

type DescribeVodDomainCertificateInfoRequest struct {
	// The accelerated domain name.
	//
	// This parameter is required.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId    *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
}

func (s DescribeVodDomainCertificateInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainCertificateInfoRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainCertificateInfoRequest) SetDomainName(v string) *DescribeVodDomainCertificateInfoRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainCertificateInfoRequest) SetOwnerId(v int64) *DescribeVodDomainCertificateInfoRequest {
	s.OwnerId = &v
	return s
}

type DescribeVodDomainCertificateInfoResponseBody struct {
	// The certificate information.
	CertInfos *DescribeVodDomainCertificateInfoResponseBodyCertInfos `json:"CertInfos,omitempty" xml:"CertInfos,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// 5C1E43DC-9E51-4771-****-7D5ECEB547A1
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeVodDomainCertificateInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainCertificateInfoResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainCertificateInfoResponseBody) SetCertInfos(v *DescribeVodDomainCertificateInfoResponseBodyCertInfos) *DescribeVodDomainCertificateInfoResponseBody {
	s.CertInfos = v
	return s
}

func (s *DescribeVodDomainCertificateInfoResponseBody) SetRequestId(v string) *DescribeVodDomainCertificateInfoResponseBody {
	s.RequestId = &v
	return s
}

type DescribeVodDomainCertificateInfoResponseBodyCertInfos struct {
	CertInfo []*DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo `json:"CertInfo,omitempty" xml:"CertInfo,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainCertificateInfoResponseBodyCertInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainCertificateInfoResponseBodyCertInfos) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainCertificateInfoResponseBodyCertInfos) SetCertInfo(v []*DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo) *DescribeVodDomainCertificateInfoResponseBodyCertInfos {
	s.CertInfo = v
	return s
}

type DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo struct {
	// The domain name that matches the certificate.
	//
	// example:
	//
	// example.com
	CertDomainName *string `json:"CertDomainName,omitempty" xml:"CertDomainName,omitempty"`
	// The time at which the certificate expires. The time is in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2018-06-03T13:03:39Z
	CertExpireTime *string `json:"CertExpireTime,omitempty" xml:"CertExpireTime,omitempty"`
	// The ID of the certificate.
	//
	// example:
	//
	// 13227737-cn-hangzhou
	CertId *string `json:"CertId,omitempty" xml:"CertId,omitempty"`
	// The validity period of the certificate. Unit: months or years.
	//
	// example:
	//
	// 3 months
	CertLife *string `json:"CertLife,omitempty" xml:"CertLife,omitempty"`
	// The certificate name.
	//
	// example:
	//
	// cert-example.com
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The certificate authority (CA) that issued the certificate.
	//
	// example:
	//
	// Let\\"s Encrypt
	CertOrg *string `json:"CertOrg,omitempty" xml:"CertOrg,omitempty"`
	// The region where the certificate is used.
	//
	// example:
	//
	// cn-hangzhou
	CertRegion *string `json:"CertRegion,omitempty" xml:"CertRegion,omitempty"`
	// The time when the certificate became effective.
	//
	// example:
	//
	// 2023-04-26T20:23:38Z
	CertStartTime *string `json:"CertStartTime,omitempty" xml:"CertStartTime,omitempty"`
	// The type of the certificate. Valid values:
	//
	// 	- **free**: a free certificate.
	//
	// 	- **cas**: a certificate that is purchased from Certificate Management Service.
	//
	// 	- **upload**: a user-uploaded certificate.
	//
	// example:
	//
	// free
	CertType *string `json:"CertType,omitempty" xml:"CertType,omitempty"`
	// The time at which the certificate was updated.
	//
	// example:
	//
	// 2023-04-26T20:23:38Z
	CertUpdateTime *string `json:"CertUpdateTime,omitempty" xml:"CertUpdateTime,omitempty"`
	// The CNAME status of the domain name.
	//
	// 	- **ok**: The domain name points to the CNAME assigned by Alibaba Cloud CDN.
	//
	// 	- **cname_error**: An error occurred and the domain name cannot point to the CNAME.
	//
	// 	- **op_domain_cname_error*	- : An error occurred to the CNAME of the top-level domain. The domain name cannot point to the CNAME.
	//
	// 	- **unsupport_wildcard**: The wildcard domain name is not supported.
	//
	// example:
	//
	// ok
	DomainCnameStatus *string `json:"DomainCnameStatus,omitempty" xml:"DomainCnameStatus,omitempty"`
	// The accelerated domain name whose ICP filing status you want to update.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The public key of the certificate.
	//
	// example:
	//
	// ****
	ServerCertificate *string `json:"ServerCertificate,omitempty" xml:"ServerCertificate,omitempty"`
	// The status of the SSL certificate.
	//
	// 	- **on**
	//
	// 	- **off**
	//
	// example:
	//
	// checking
	ServerCertificateStatus *string `json:"ServerCertificateStatus,omitempty" xml:"ServerCertificateStatus,omitempty"`
	// The status of the certificate.
	//
	// 	- **success**: The certificate is in effect.
	//
	// 	- **checking**: The system is checking whether the domain name is added to ApsaraVideo VOD.
	//
	// 	- **cname_error**: The domain name is not added to ApsaraVideo VOD.
	//
	// 	- **domain_invalid**: The domain name contains invalid characters.
	//
	// 	- **unsupport_wildcard**: The domain name is a wildcard domain name. Wildcard domain names are not supported.
	//
	// 	- **applying**: The certificate application is in progress.
	//
	// 	- **failed**: The certificate application failed.
	//
	// >  A value is returned for this parameter only when you set `CertType` to `free`. Otherwise, an empty value is returned for this parameter.
	//
	// example:
	//
	// success
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertDomainName(v string) *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertDomainName = &v
	return s
}

func (s *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertExpireTime(v string) *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertExpireTime = &v
	return s
}

func (s *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertId(v string) *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertId = &v
	return s
}

func (s *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertLife(v string) *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertLife = &v
	return s
}

func (s *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertName(v string) *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertName = &v
	return s
}

func (s *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertOrg(v string) *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertOrg = &v
	return s
}

func (s *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertRegion(v string) *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertRegion = &v
	return s
}

func (s *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertStartTime(v string) *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertStartTime = &v
	return s
}

func (s *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertType(v string) *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertType = &v
	return s
}

func (s *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertUpdateTime(v string) *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertUpdateTime = &v
	return s
}

func (s *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo) SetDomainCnameStatus(v string) *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.DomainCnameStatus = &v
	return s
}

func (s *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo) SetDomainName(v string) *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo) SetServerCertificate(v string) *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.ServerCertificate = &v
	return s
}

func (s *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo) SetServerCertificateStatus(v string) *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.ServerCertificateStatus = &v
	return s
}

func (s *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo) SetStatus(v string) *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.Status = &v
	return s
}

type DescribeVodDomainCertificateInfoResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodDomainCertificateInfoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodDomainCertificateInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainCertificateInfoResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainCertificateInfoResponse) SetHeaders(v map[string]*string) *DescribeVodDomainCertificateInfoResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodDomainCertificateInfoResponse) SetStatusCode(v int32) *DescribeVodDomainCertificateInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodDomainCertificateInfoResponse) SetBody(v *DescribeVodDomainCertificateInfoResponseBody) *DescribeVodDomainCertificateInfoResponse {
	s.Body = v
	return s
}

type DescribeVodDomainConfigsRequest struct {
	// The domain name for CDN.
	//
	// This parameter is required.
	//
	// example:
	//
	// www.example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The feature name. Separate multiple names with commas (,). For more information, see **Feature description**.
	//
	// This parameter is required.
	//
	// example:
	//
	// filetype_based_ttl_set,set_req_host_header
	FunctionNames *string `json:"FunctionNames,omitempty" xml:"FunctionNames,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeVodDomainConfigsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainConfigsRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainConfigsRequest) SetDomainName(v string) *DescribeVodDomainConfigsRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainConfigsRequest) SetFunctionNames(v string) *DescribeVodDomainConfigsRequest {
	s.FunctionNames = &v
	return s
}

func (s *DescribeVodDomainConfigsRequest) SetOwnerId(v int64) *DescribeVodDomainConfigsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodDomainConfigsRequest) SetSecurityToken(v string) *DescribeVodDomainConfigsRequest {
	s.SecurityToken = &v
	return s
}

type DescribeVodDomainConfigsResponseBody struct {
	// The configurations of the domain name.
	DomainConfigs *DescribeVodDomainConfigsResponseBodyDomainConfigs `json:"DomainConfigs,omitempty" xml:"DomainConfigs,omitempty" type:"Struct"`
	// The request ID.
	//
	// example:
	//
	// F8AA0364-0FDB-4AD5-****-D69FAB8924ED
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeVodDomainConfigsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainConfigsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainConfigsResponseBody) SetDomainConfigs(v *DescribeVodDomainConfigsResponseBodyDomainConfigs) *DescribeVodDomainConfigsResponseBody {
	s.DomainConfigs = v
	return s
}

func (s *DescribeVodDomainConfigsResponseBody) SetRequestId(v string) *DescribeVodDomainConfigsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeVodDomainConfigsResponseBodyDomainConfigs struct {
	DomainConfig []*DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig `json:"DomainConfig,omitempty" xml:"DomainConfig,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainConfigsResponseBodyDomainConfigs) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainConfigsResponseBodyDomainConfigs) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainConfigsResponseBodyDomainConfigs) SetDomainConfig(v []*DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig) *DescribeVodDomainConfigsResponseBodyDomainConfigs {
	s.DomainConfig = v
	return s
}

type DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig struct {
	// The configuration ID.
	//
	// example:
	//
	// 5003576
	ConfigId *string `json:"ConfigId,omitempty" xml:"ConfigId,omitempty"`
	// The feature parameters.
	FunctionArgs *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs `json:"FunctionArgs,omitempty" xml:"FunctionArgs,omitempty" type:"Struct"`
	// The feature name.
	//
	// example:
	//
	// set_req_host_header
	FunctionName *string `json:"FunctionName,omitempty" xml:"FunctionName,omitempty"`
	// The configuration status. Valid values:
	//
	// 	- **success**
	//
	// 	- **testing**
	//
	// 	- **failed**
	//
	// 	- **configuring**
	//
	// example:
	//
	// success
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig) SetConfigId(v string) *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig {
	s.ConfigId = &v
	return s
}

func (s *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig) SetFunctionArgs(v *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs) *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig {
	s.FunctionArgs = v
	return s
}

func (s *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig) SetFunctionName(v string) *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig {
	s.FunctionName = &v
	return s
}

func (s *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig) SetStatus(v string) *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig {
	s.Status = &v
	return s
}

type DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs struct {
	FunctionArg []*DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg `json:"FunctionArg,omitempty" xml:"FunctionArg,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs) SetFunctionArg(v []*DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg) *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs {
	s.FunctionArg = v
	return s
}

type DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg struct {
	// The parameter name.
	//
	// example:
	//
	// file_type
	ArgName *string `json:"ArgName,omitempty" xml:"ArgName,omitempty"`
	// The parameter value.
	//
	// example:
	//
	// txt
	ArgValue *string `json:"ArgValue,omitempty" xml:"ArgValue,omitempty"`
}

func (s DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg) SetArgName(v string) *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg {
	s.ArgName = &v
	return s
}

func (s *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg) SetArgValue(v string) *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg {
	s.ArgValue = &v
	return s
}

type DescribeVodDomainConfigsResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodDomainConfigsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodDomainConfigsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainConfigsResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainConfigsResponse) SetHeaders(v map[string]*string) *DescribeVodDomainConfigsResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodDomainConfigsResponse) SetStatusCode(v int32) *DescribeVodDomainConfigsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodDomainConfigsResponse) SetBody(v *DescribeVodDomainConfigsResponseBody) *DescribeVodDomainConfigsResponse {
	s.Body = v
	return s
}

type DescribeVodDomainDetailRequest struct {
	// The domain name for CDN.
	//
	// This parameter is required.
	//
	// example:
	//
	// example.com
	DomainName    *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeVodDomainDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainDetailRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainDetailRequest) SetDomainName(v string) *DescribeVodDomainDetailRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainDetailRequest) SetOwnerId(v int64) *DescribeVodDomainDetailRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodDomainDetailRequest) SetSecurityToken(v string) *DescribeVodDomainDetailRequest {
	s.SecurityToken = &v
	return s
}

type DescribeVodDomainDetailResponseBody struct {
	// The basic information about the domain name for CDN.
	DomainDetail *DescribeVodDomainDetailResponseBodyDomainDetail `json:"DomainDetail,omitempty" xml:"DomainDetail,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// 09ABE829-6CD3-4FE0-556113E2****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeVodDomainDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainDetailResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainDetailResponseBody) SetDomainDetail(v *DescribeVodDomainDetailResponseBodyDomainDetail) *DescribeVodDomainDetailResponseBody {
	s.DomainDetail = v
	return s
}

func (s *DescribeVodDomainDetailResponseBody) SetRequestId(v string) *DescribeVodDomainDetailResponseBody {
	s.RequestId = &v
	return s
}

type DescribeVodDomainDetailResponseBodyDomainDetail struct {
	// The name of the certificate. The value of this parameter is returned if HTTPS is enabled.
	//
	// example:
	//
	// testCertName
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The CNAME that is assigned to the domain name for CDN. You must add a CNAME record in the system of your Domain Name System (DNS) service provider to map the domain name for CDN to the CNAME.
	//
	// example:
	//
	// example.com.w.alikunlun.net
	Cname *string `json:"Cname,omitempty" xml:"Cname,omitempty"`
	// The description of the domain name for CDN.
	//
	// example:
	//
	// testDescription
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The domain name for CDN.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The status of the domain name for CDN. Value values:
	//
	// 	- **online**: indicates that the domain name is enabled.
	//
	// 	- **offline**: indicates that the domain name is disabled.
	//
	// 	- **configuring**: indicates that the domain name is being configured.
	//
	// 	- **configure_failed**: indicates that the domain name failed to be configured.
	//
	// 	- **checking**: indicates that the domain name is under review.
	//
	// 	- **check_failed**: indicates that the domain name failed the review.
	//
	// example:
	//
	// online
	DomainStatus *string `json:"DomainStatus,omitempty" xml:"DomainStatus,omitempty"`
	// The time when the domain name for CDN was added. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-11-27T06:51:26Z
	GmtCreated *string `json:"GmtCreated,omitempty" xml:"GmtCreated,omitempty"`
	// The last time when the domain name for CDN was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-11-27T06:55:26Z
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// Indicates whether the Secure Sockets Layer (SSL) certificate is enabled. Valid values:
	//
	// 	- **on**: indicates that the SSL certificate is enabled.
	//
	// 	- **off**: indicates that the SSL certificate is disabled.
	//
	// example:
	//
	// on
	SSLProtocol *string `json:"SSLProtocol,omitempty" xml:"SSLProtocol,omitempty"`
	// The public key of the certificate. The value of this parameter is returned if HTTPS is enabled.
	//
	// example:
	//
	// yourSSLPub
	SSLPub *string `json:"SSLPub,omitempty" xml:"SSLPub,omitempty"`
	// This parameter is applicable to users of level 3 or higher in mainland China and users outside mainland China. Valid values:
	//
	// 	- **domestic**: mainland China. This is the default value.
	//
	// 	- **overseas**: outside mainland China.
	//
	// 	- **global**: regions in and outside mainland China.
	//
	// example:
	//
	// domestic
	Scope *string `json:"Scope,omitempty" xml:"Scope,omitempty"`
	// The information about the origin server.
	Sources *DescribeVodDomainDetailResponseBodyDomainDetailSources `json:"Sources,omitempty" xml:"Sources,omitempty" type:"Struct"`
	// The weight of the origin server.
	//
	// example:
	//
	// 1
	Weight *string `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeVodDomainDetailResponseBodyDomainDetail) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainDetailResponseBodyDomainDetail) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetail) SetCertName(v string) *DescribeVodDomainDetailResponseBodyDomainDetail {
	s.CertName = &v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetail) SetCname(v string) *DescribeVodDomainDetailResponseBodyDomainDetail {
	s.Cname = &v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetail) SetDescription(v string) *DescribeVodDomainDetailResponseBodyDomainDetail {
	s.Description = &v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetail) SetDomainName(v string) *DescribeVodDomainDetailResponseBodyDomainDetail {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetail) SetDomainStatus(v string) *DescribeVodDomainDetailResponseBodyDomainDetail {
	s.DomainStatus = &v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetail) SetGmtCreated(v string) *DescribeVodDomainDetailResponseBodyDomainDetail {
	s.GmtCreated = &v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetail) SetGmtModified(v string) *DescribeVodDomainDetailResponseBodyDomainDetail {
	s.GmtModified = &v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetail) SetSSLProtocol(v string) *DescribeVodDomainDetailResponseBodyDomainDetail {
	s.SSLProtocol = &v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetail) SetSSLPub(v string) *DescribeVodDomainDetailResponseBodyDomainDetail {
	s.SSLPub = &v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetail) SetScope(v string) *DescribeVodDomainDetailResponseBodyDomainDetail {
	s.Scope = &v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetail) SetSources(v *DescribeVodDomainDetailResponseBodyDomainDetailSources) *DescribeVodDomainDetailResponseBodyDomainDetail {
	s.Sources = v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetail) SetWeight(v string) *DescribeVodDomainDetailResponseBodyDomainDetail {
	s.Weight = &v
	return s
}

type DescribeVodDomainDetailResponseBodyDomainDetailSources struct {
	Source []*DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource `json:"Source,omitempty" xml:"Source,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainDetailResponseBodyDomainDetailSources) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainDetailResponseBodyDomainDetailSources) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetailSources) SetSource(v []*DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource) *DescribeVodDomainDetailResponseBodyDomainDetailSources {
	s.Source = v
	return s
}

type DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource struct {
	// The address of the origin server.
	//
	// example:
	//
	// ****.oss-cn-hangzhou.aliyuncs.com
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The status of the origin server. Valid values:
	//
	// 	- **online**: indicates that the origin server is enabled.
	//
	// 	- **offline**: indicates that the origin server is disabled.
	//
	// example:
	//
	// online
	Enabled *string `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	// The port number. Valid values: 443 and 80.
	//
	// example:
	//
	// 80
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The priority of the origin server.
	//
	// example:
	//
	// 50
	Priority *string `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The type of the origin server. Valid values:
	//
	// 	- **ipaddr**: a server that you can access by using an IP address.
	//
	// 	- **domain**: a server that you can access by using a domain name.
	//
	// 	- **oss**: the URL of an Object Storage Service (OSS) bucket.
	//
	// example:
	//
	// oss
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The weight of the origin server if multiple origin servers have been specified.
	//
	// example:
	//
	// 10
	Weight *string `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource) SetContent(v string) *DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource {
	s.Content = &v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource) SetEnabled(v string) *DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource {
	s.Enabled = &v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource) SetPort(v int32) *DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource {
	s.Port = &v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource) SetPriority(v string) *DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource {
	s.Priority = &v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource) SetType(v string) *DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource {
	s.Type = &v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource) SetWeight(v string) *DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource {
	s.Weight = &v
	return s
}

type DescribeVodDomainDetailResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodDomainDetailResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodDomainDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainDetailResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainDetailResponse) SetHeaders(v map[string]*string) *DescribeVodDomainDetailResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodDomainDetailResponse) SetStatusCode(v int32) *DescribeVodDomainDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodDomainDetailResponse) SetBody(v *DescribeVodDomainDetailResponseBody) *DescribeVodDomainDetailResponse {
	s.Body = v
	return s
}

type DescribeVodDomainHitRateDataRequest struct {
	// The accelerated domain name.
	//
	// 	- If you leave this parameter empty, the merged data of all your accelerated domain names is returned.
	//
	// 	- You can specify multiple domain names and separate them with commas (,). You can specify a maximum of 500 domain names in each call.
	//
	// 	- To obtain the accelerated domain name, perform the following steps: Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Configuration Management > CDN Configuration > Domain Names**. On the Domain Names page, view the accelerated domain names. Alternatively, you can call the [DescribeVodUserDomains](~~DescribeVodUserDomains~~) operation to query the accelerated domain names.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// >  The end time must be later than the start time.
	//
	// example:
	//
	// 2024-01-20T14:59:58Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time granularity. Unit: seconds. Valid values: **300**, **3600**, and **86400**. If you leave this parameter empty or specify an invalid value, the default value is used. The supported time granularity varies based on the time range specified by `EndTime` and `StartTime`. The following content describes the supported time granularity.
	//
	// 	- Time range per query < 3 days: **300*	- (default), **3600**, and **86400**
	//
	// 	- 3 days ≤ Time range per query < 31 days: **3600*	- (default) and **86400**
	//
	// 	- 31 days ≤ Time range per query ≤ 90 days: **86400*	- (default)
	//
	// example:
	//
	// 300
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	OwnerId  *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// example:
	//
	// 2024-01-20T13:59:58Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainHitRateDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainHitRateDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainHitRateDataRequest) SetDomainName(v string) *DescribeVodDomainHitRateDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainHitRateDataRequest) SetEndTime(v string) *DescribeVodDomainHitRateDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainHitRateDataRequest) SetInterval(v string) *DescribeVodDomainHitRateDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeVodDomainHitRateDataRequest) SetOwnerId(v int64) *DescribeVodDomainHitRateDataRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodDomainHitRateDataRequest) SetStartTime(v string) *DescribeVodDomainHitRateDataRequest {
	s.StartTime = &v
	return s
}

type DescribeVodDomainHitRateDataResponseBody struct {
	// The time interval at which data is returned, which is the time granularity. Unit: seconds.
	//
	// example:
	//
	// 300
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range.
	//
	// example:
	//
	// 2024-01-20T14:59:58Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The byte hit rate data at each time interval.
	HitRateInterval *DescribeVodDomainHitRateDataResponseBodyHitRateInterval `json:"HitRateInterval,omitempty" xml:"HitRateInterval,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// D94E471F-1A27-442E-552D-D4D2000C****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range.
	//
	// example:
	//
	// 2024-01-20T13:59:58Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainHitRateDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainHitRateDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainHitRateDataResponseBody) SetDataInterval(v string) *DescribeVodDomainHitRateDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeVodDomainHitRateDataResponseBody) SetDomainName(v string) *DescribeVodDomainHitRateDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainHitRateDataResponseBody) SetEndTime(v string) *DescribeVodDomainHitRateDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainHitRateDataResponseBody) SetHitRateInterval(v *DescribeVodDomainHitRateDataResponseBodyHitRateInterval) *DescribeVodDomainHitRateDataResponseBody {
	s.HitRateInterval = v
	return s
}

func (s *DescribeVodDomainHitRateDataResponseBody) SetRequestId(v string) *DescribeVodDomainHitRateDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVodDomainHitRateDataResponseBody) SetStartTime(v string) *DescribeVodDomainHitRateDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeVodDomainHitRateDataResponseBodyHitRateInterval struct {
	DataModule []*DescribeVodDomainHitRateDataResponseBodyHitRateIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainHitRateDataResponseBodyHitRateInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainHitRateDataResponseBodyHitRateInterval) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainHitRateDataResponseBodyHitRateInterval) SetDataModule(v []*DescribeVodDomainHitRateDataResponseBodyHitRateIntervalDataModule) *DescribeVodDomainHitRateDataResponseBodyHitRateInterval {
	s.DataModule = v
	return s
}

type DescribeVodDomainHitRateDataResponseBodyHitRateIntervalDataModule struct {
	// The HTTPS byte hit rate.
	//
	// example:
	//
	// 50
	HttpsValue *string `json:"HttpsValue,omitempty" xml:"HttpsValue,omitempty"`
	// The timestamp of the data returned. The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.
	//
	// example:
	//
	// 2024-01-20T13:59:58Z
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The total byte hit rate.
	//
	// example:
	//
	// 100
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVodDomainHitRateDataResponseBodyHitRateIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainHitRateDataResponseBodyHitRateIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainHitRateDataResponseBodyHitRateIntervalDataModule) SetHttpsValue(v string) *DescribeVodDomainHitRateDataResponseBodyHitRateIntervalDataModule {
	s.HttpsValue = &v
	return s
}

func (s *DescribeVodDomainHitRateDataResponseBodyHitRateIntervalDataModule) SetTimeStamp(v string) *DescribeVodDomainHitRateDataResponseBodyHitRateIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeVodDomainHitRateDataResponseBodyHitRateIntervalDataModule) SetValue(v string) *DescribeVodDomainHitRateDataResponseBodyHitRateIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeVodDomainHitRateDataResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodDomainHitRateDataResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodDomainHitRateDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainHitRateDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainHitRateDataResponse) SetHeaders(v map[string]*string) *DescribeVodDomainHitRateDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodDomainHitRateDataResponse) SetStatusCode(v int32) *DescribeVodDomainHitRateDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodDomainHitRateDataResponse) SetBody(v *DescribeVodDomainHitRateDataResponseBody) *DescribeVodDomainHitRateDataResponse {
	s.Body = v
	return s
}

type DescribeVodDomainLogRequest struct {
	// The domain name for CDN.
	//
	// >  You can specify only one domain name in each query.
	//
	// This parameter is required.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. The end time must be later than the start time. The maximum time range that can be specified is one year. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time must be in UTC.
	//
	// example:
	//
	// 2016-10-20T05:00:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The page number. Default value: **1**.
	//
	// example:
	//
	// 1
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	//
	// 	- Default value: **300**.
	//
	// 	- Valid values: **1 to 1000**.
	//
	// example:
	//
	// 300
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time must be in UTC.
	//
	// example:
	//
	// 2016-10-20T04:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainLogRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainLogRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainLogRequest) SetDomainName(v string) *DescribeVodDomainLogRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainLogRequest) SetEndTime(v string) *DescribeVodDomainLogRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainLogRequest) SetOwnerId(v int64) *DescribeVodDomainLogRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodDomainLogRequest) SetPageNumber(v int64) *DescribeVodDomainLogRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeVodDomainLogRequest) SetPageSize(v int64) *DescribeVodDomainLogRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeVodDomainLogRequest) SetStartTime(v string) *DescribeVodDomainLogRequest {
	s.StartTime = &v
	return s
}

type DescribeVodDomainLogResponseBody struct {
	// The details of CDN logs.
	DomainLogDetails *DescribeVodDomainLogResponseBodyDomainLogDetails `json:"DomainLogDetails,omitempty" xml:"DomainLogDetails,omitempty" type:"Struct"`
	// The request ID.
	//
	// example:
	//
	// 077D0284-F041-4A41-4D3C-B48377FD****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeVodDomainLogResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainLogResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainLogResponseBody) SetDomainLogDetails(v *DescribeVodDomainLogResponseBodyDomainLogDetails) *DescribeVodDomainLogResponseBody {
	s.DomainLogDetails = v
	return s
}

func (s *DescribeVodDomainLogResponseBody) SetRequestId(v string) *DescribeVodDomainLogResponseBody {
	s.RequestId = &v
	return s
}

type DescribeVodDomainLogResponseBodyDomainLogDetails struct {
	DomainLogDetail []*DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail `json:"DomainLogDetail,omitempty" xml:"DomainLogDetail,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainLogResponseBodyDomainLogDetails) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainLogResponseBodyDomainLogDetails) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainLogResponseBodyDomainLogDetails) SetDomainLogDetail(v []*DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail) *DescribeVodDomainLogResponseBodyDomainLogDetails {
	s.DomainLogDetail = v
	return s
}

type DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail struct {
	// The domain name.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The total number of entries returned on the current page.
	//
	// example:
	//
	// 2
	LogCount *int64 `json:"LogCount,omitempty" xml:"LogCount,omitempty"`
	// The queried CDN logs.
	LogInfos *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos `json:"LogInfos,omitempty" xml:"LogInfos,omitempty" type:"Struct"`
	// The pagination information.
	PageInfos *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos `json:"PageInfos,omitempty" xml:"PageInfos,omitempty" type:"Struct"`
}

func (s DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail) SetDomainName(v string) *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail) SetLogCount(v int64) *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail {
	s.LogCount = &v
	return s
}

func (s *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail) SetLogInfos(v *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos) *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail {
	s.LogInfos = v
	return s
}

func (s *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail) SetPageInfos(v *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos) *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail {
	s.PageInfos = v
	return s
}

type DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos struct {
	LogInfoDetail []*DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail `json:"LogInfoDetail,omitempty" xml:"LogInfoDetail,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos) SetLogInfoDetail(v []*DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos {
	s.LogInfoDetail = v
	return s
}

type DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail struct {
	// The end of the time range during which data was queried. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.
	//
	// example:
	//
	// 2018-05-31T05:00:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The name of the log file.
	//
	// example:
	//
	// example.com_2018_03_25_180000_19****.gz
	LogName *string `json:"LogName,omitempty" xml:"LogName,omitempty"`
	// The path of the log file.
	//
	// example:
	//
	// example.com/2018_03_25/example.com_2018_03_25_180000_19****.gz?Expires=1522659931&OSSAccessKeyId=****&Signature=****
	LogPath *string `json:"LogPath,omitempty" xml:"LogPath,omitempty"`
	// The size of the log file.
	//
	// example:
	//
	// 2645401
	LogSize *int64 `json:"LogSize,omitempty" xml:"LogSize,omitempty"`
	// The beginning of the time range during which data was queried. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.
	//
	// example:
	//
	// 2018-05-31T04:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) SetEndTime(v string) *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) SetLogName(v string) *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail {
	s.LogName = &v
	return s
}

func (s *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) SetLogPath(v string) *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail {
	s.LogPath = &v
	return s
}

func (s *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) SetLogSize(v int64) *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail {
	s.LogSize = &v
	return s
}

func (s *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) SetStartTime(v string) *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail {
	s.StartTime = &v
	return s
}

type DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos struct {
	// The page number.
	//
	// example:
	//
	// 1
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	//
	// example:
	//
	// 300
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of entries returned.
	//
	// example:
	//
	// 2
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos) SetPageNumber(v int64) *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos {
	s.PageNumber = &v
	return s
}

func (s *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos) SetPageSize(v int64) *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos {
	s.PageSize = &v
	return s
}

func (s *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos) SetTotal(v int64) *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos {
	s.Total = &v
	return s
}

type DescribeVodDomainLogResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodDomainLogResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodDomainLogResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainLogResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainLogResponse) SetHeaders(v map[string]*string) *DescribeVodDomainLogResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodDomainLogResponse) SetStatusCode(v int32) *DescribeVodDomainLogResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodDomainLogResponse) SetBody(v *DescribeVodDomainLogResponseBody) *DescribeVodDomainLogResponse {
	s.Body = v
	return s
}

type DescribeVodDomainMax95BpsDataRequest struct {
	// The cycle to query the 95th percentile bandwidth data. Valid values:
	//
	// 	- day (default)
	//
	// 	- month
	//
	// example:
	//
	// month
	Cycle *string `json:"Cycle,omitempty" xml:"Cycle,omitempty"`
	// The domain name to be queried for acceleration. If the parameter is empty, the data merged from all accelerated domain names will be returned by default.
	//
	// > Batch domain name queries are not supported.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// End time point. The date format follows the ISO8601 representation and uses UTC time, in the format yyyy-MM-dd\\"T\\"HH:mm:ssZ.
	//
	// example:
	//
	// 2017-01-12T13:00:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// Start time point. The date format follows the ISO8601 representation and uses UTC time, in the format yyyy-MM-dd\\"T\\"HH:mm:ssZ.
	//
	// example:
	//
	// 2017-01-11T12:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The start time point for getting the data. The date format follows the ISO8601 representation and uses UTC time, in the format yyyy-MM-dd\\"T\\"HH:mm:ssZ.
	//
	// example:
	//
	// 2017-12-21T10:00:00Z
	TimePoint *string `json:"TimePoint,omitempty" xml:"TimePoint,omitempty"`
}

func (s DescribeVodDomainMax95BpsDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainMax95BpsDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainMax95BpsDataRequest) SetCycle(v string) *DescribeVodDomainMax95BpsDataRequest {
	s.Cycle = &v
	return s
}

func (s *DescribeVodDomainMax95BpsDataRequest) SetDomainName(v string) *DescribeVodDomainMax95BpsDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainMax95BpsDataRequest) SetEndTime(v string) *DescribeVodDomainMax95BpsDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainMax95BpsDataRequest) SetOwnerId(v int64) *DescribeVodDomainMax95BpsDataRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodDomainMax95BpsDataRequest) SetStartTime(v string) *DescribeVodDomainMax95BpsDataRequest {
	s.StartTime = &v
	return s
}

func (s *DescribeVodDomainMax95BpsDataRequest) SetTimePoint(v string) *DescribeVodDomainMax95BpsDataRequest {
	s.TimePoint = &v
	return s
}

type DescribeVodDomainMax95BpsDataResponseBody struct {
	// Details of the 95th percentile bandwidth.
	DetailData *DescribeVodDomainMax95BpsDataResponseBodyDetailData `json:"DetailData,omitempty" xml:"DetailData,omitempty" type:"Struct"`
	// The domain name for CDN.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The 95th percentile bandwidth in the Chinese mainland.
	//
	// example:
	//
	// 16777590.28
	DomesticMax95Bps *string `json:"DomesticMax95Bps,omitempty" xml:"DomesticMax95Bps,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// >  The end time must be later than the start time.
	//
	// example:
	//
	// 2017-01-11T13:00:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The 95th percentile bandwidth.
	//
	// example:
	//
	// 16777590.28
	Max95Bps *string `json:"Max95Bps,omitempty" xml:"Max95Bps,omitempty"`
	// The 95th percentile bandwidth outside the Chinese mainland.
	//
	// example:
	//
	// 0
	OverseasMax95Bps *string `json:"OverseasMax95Bps,omitempty" xml:"OverseasMax95Bps,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 25818875-5F78-4A*****F6-D7393642CA58
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// example:
	//
	// 2017-01-11T12:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainMax95BpsDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainMax95BpsDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainMax95BpsDataResponseBody) SetDetailData(v *DescribeVodDomainMax95BpsDataResponseBodyDetailData) *DescribeVodDomainMax95BpsDataResponseBody {
	s.DetailData = v
	return s
}

func (s *DescribeVodDomainMax95BpsDataResponseBody) SetDomainName(v string) *DescribeVodDomainMax95BpsDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainMax95BpsDataResponseBody) SetDomesticMax95Bps(v string) *DescribeVodDomainMax95BpsDataResponseBody {
	s.DomesticMax95Bps = &v
	return s
}

func (s *DescribeVodDomainMax95BpsDataResponseBody) SetEndTime(v string) *DescribeVodDomainMax95BpsDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainMax95BpsDataResponseBody) SetMax95Bps(v string) *DescribeVodDomainMax95BpsDataResponseBody {
	s.Max95Bps = &v
	return s
}

func (s *DescribeVodDomainMax95BpsDataResponseBody) SetOverseasMax95Bps(v string) *DescribeVodDomainMax95BpsDataResponseBody {
	s.OverseasMax95Bps = &v
	return s
}

func (s *DescribeVodDomainMax95BpsDataResponseBody) SetRequestId(v string) *DescribeVodDomainMax95BpsDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVodDomainMax95BpsDataResponseBody) SetStartTime(v string) *DescribeVodDomainMax95BpsDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeVodDomainMax95BpsDataResponseBodyDetailData struct {
	Max95Detail []*DescribeVodDomainMax95BpsDataResponseBodyDetailDataMax95Detail `json:"Max95Detail,omitempty" xml:"Max95Detail,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainMax95BpsDataResponseBodyDetailData) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainMax95BpsDataResponseBodyDetailData) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainMax95BpsDataResponseBodyDetailData) SetMax95Detail(v []*DescribeVodDomainMax95BpsDataResponseBodyDetailDataMax95Detail) *DescribeVodDomainMax95BpsDataResponseBodyDetailData {
	s.Max95Detail = v
	return s
}

type DescribeVodDomainMax95BpsDataResponseBodyDetailDataMax95Detail struct {
	// The billable region where the peak 95 data was collected.
	//
	// example:
	//
	// CN
	Area *string `json:"Area,omitempty" xml:"Area,omitempty"`
	// The 95th percentile bandwidth.
	//
	// example:
	//
	// 16777590.28
	Max95Bps *float32 `json:"Max95Bps,omitempty" xml:"Max95Bps,omitempty"`
	// The time corresponding to the 95th percentile bandwidth peak.
	//
	// example:
	//
	// 2015-12-11T21:05:00Z
	Max95BpsPeakTime *string `json:"Max95BpsPeakTime,omitempty" xml:"Max95BpsPeakTime,omitempty"`
	// The timestamp of the returned data.
	//
	// example:
	//
	// 2024-01-18 10:11:32
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeVodDomainMax95BpsDataResponseBodyDetailDataMax95Detail) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainMax95BpsDataResponseBodyDetailDataMax95Detail) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainMax95BpsDataResponseBodyDetailDataMax95Detail) SetArea(v string) *DescribeVodDomainMax95BpsDataResponseBodyDetailDataMax95Detail {
	s.Area = &v
	return s
}

func (s *DescribeVodDomainMax95BpsDataResponseBodyDetailDataMax95Detail) SetMax95Bps(v float32) *DescribeVodDomainMax95BpsDataResponseBodyDetailDataMax95Detail {
	s.Max95Bps = &v
	return s
}

func (s *DescribeVodDomainMax95BpsDataResponseBodyDetailDataMax95Detail) SetMax95BpsPeakTime(v string) *DescribeVodDomainMax95BpsDataResponseBodyDetailDataMax95Detail {
	s.Max95BpsPeakTime = &v
	return s
}

func (s *DescribeVodDomainMax95BpsDataResponseBodyDetailDataMax95Detail) SetTimeStamp(v string) *DescribeVodDomainMax95BpsDataResponseBodyDetailDataMax95Detail {
	s.TimeStamp = &v
	return s
}

type DescribeVodDomainMax95BpsDataResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodDomainMax95BpsDataResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodDomainMax95BpsDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainMax95BpsDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainMax95BpsDataResponse) SetHeaders(v map[string]*string) *DescribeVodDomainMax95BpsDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodDomainMax95BpsDataResponse) SetStatusCode(v int32) *DescribeVodDomainMax95BpsDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodDomainMax95BpsDataResponse) SetBody(v *DescribeVodDomainMax95BpsDataResponseBody) *DescribeVodDomainMax95BpsDataResponse {
	s.Body = v
	return s
}

type DescribeVodDomainQpsDataRequest struct {
	// You can specify multiple domain names and separate them with commas (,). You can specify a maximum of 500 domain names in each call.
	//
	// By default, this operation queries the number and proportions of HTTP status codes for all accelerated domain names that belong to your Alibaba Cloud account.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd**THH:mm:ssZ	- format. The time must be in UTC.
	//
	// example:
	//
	// 2024-05-02T15:59:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The interval at which to return data. Unit: seconds. Valid values: **300**, **3600**, and **86400**.
	//
	// example:
	//
	// 300
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The name of the Internet service provider (ISP). If you leave this parameter empty, data of all ISPs is queried.
	//
	// example:
	//
	// unicom
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region. If you leave this parameter empty, data in all regions is queried.
	//
	// example:
	//
	// beijing
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd**THH:mm:ssZ	- format. The time must be in UTC.
	//
	// example:
	//
	// 2024-05-02T15:50:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainQpsDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainQpsDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainQpsDataRequest) SetDomainName(v string) *DescribeVodDomainQpsDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainQpsDataRequest) SetEndTime(v string) *DescribeVodDomainQpsDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainQpsDataRequest) SetInterval(v string) *DescribeVodDomainQpsDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeVodDomainQpsDataRequest) SetIspNameEn(v string) *DescribeVodDomainQpsDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeVodDomainQpsDataRequest) SetLocationNameEn(v string) *DescribeVodDomainQpsDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeVodDomainQpsDataRequest) SetOwnerId(v int64) *DescribeVodDomainQpsDataRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodDomainQpsDataRequest) SetStartTime(v string) *DescribeVodDomainQpsDataRequest {
	s.StartTime = &v
	return s
}

type DescribeVodDomainQpsDataResponseBody struct {
	// The time interval between the data entries returned. Unit: seconds.
	//
	// example:
	//
	// 300
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried. The time follows the ISO 8601 standard in the *YYYY-MM-DD**Thh:mm:ss	- format. The time is displayed in UTC.
	//
	// example:
	//
	// 2024-05-02T15:59:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The list of QPS records at each interval.
	QpsDataInterval *DescribeVodDomainQpsDataResponseBodyQpsDataInterval `json:"QpsDataInterval,omitempty" xml:"QpsDataInterval,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4AF6-D7393642CA58*****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range during which data was queried. The time follows the ISO 8601 standard in the *YYYY-MM-DD**Thh:mm:ss	- format. The time is displayed in UTC.
	//
	// example:
	//
	// 2024-05-02T15:50:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainQpsDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainQpsDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainQpsDataResponseBody) SetDataInterval(v string) *DescribeVodDomainQpsDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeVodDomainQpsDataResponseBody) SetDomainName(v string) *DescribeVodDomainQpsDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainQpsDataResponseBody) SetEndTime(v string) *DescribeVodDomainQpsDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainQpsDataResponseBody) SetQpsDataInterval(v *DescribeVodDomainQpsDataResponseBodyQpsDataInterval) *DescribeVodDomainQpsDataResponseBody {
	s.QpsDataInterval = v
	return s
}

func (s *DescribeVodDomainQpsDataResponseBody) SetRequestId(v string) *DescribeVodDomainQpsDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVodDomainQpsDataResponseBody) SetStartTime(v string) *DescribeVodDomainQpsDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeVodDomainQpsDataResponseBodyQpsDataInterval struct {
	DataModule []*DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainQpsDataResponseBodyQpsDataInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainQpsDataResponseBodyQpsDataInterval) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainQpsDataResponseBodyQpsDataInterval) SetDataModule(v []*DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule) *DescribeVodDomainQpsDataResponseBodyQpsDataInterval {
	s.DataModule = v
	return s
}

type DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule struct {
	// The number of requests in the Chinese mainland.
	//
	// example:
	//
	// 0
	AccDomesticValue *string `json:"AccDomesticValue,omitempty" xml:"AccDomesticValue,omitempty"`
	// The number of requests outside the Chinese mainland.
	//
	// example:
	//
	// 0
	AccOverseasValue *string `json:"AccOverseasValue,omitempty" xml:"AccOverseasValue,omitempty"`
	// The total number of requests.
	//
	// example:
	//
	// 0
	AccValue *string `json:"AccValue,omitempty" xml:"AccValue,omitempty"`
	// The QPS data in the Chinese mainland.
	//
	// example:
	//
	// 0
	DomesticValue *string `json:"DomesticValue,omitempty" xml:"DomesticValue,omitempty"`
	// The QPS that is calculated based on the HTTPS requests sent to POPs in the Chinese mainland.
	//
	// example:
	//
	// 1
	HttpsAccDomesticValue *string `json:"HttpsAccDomesticValue,omitempty" xml:"HttpsAccDomesticValue,omitempty"`
	// The number of HTTPS requests sent to POPs outside the Chinese mainland.
	//
	// example:
	//
	// 1
	HttpsAccOverseasValue *string `json:"HttpsAccOverseasValue,omitempty" xml:"HttpsAccOverseasValue,omitempty"`
	// The number of HTTPS requests sent to POPs.
	//
	// example:
	//
	// 1
	HttpsAccValue *string `json:"HttpsAccValue,omitempty" xml:"HttpsAccValue,omitempty"`
	// The QPS that is calculated based on the HTTPS requests sent to POPs in the Chinese mainland.
	//
	// example:
	//
	// 1
	HttpsDomesticValue *string `json:"HttpsDomesticValue,omitempty" xml:"HttpsDomesticValue,omitempty"`
	// The QPS that is calculated based on the HTTPS requests sent to POPs outside the Chinese mainland.
	//
	// example:
	//
	// 1
	HttpsOverseasValue *string `json:"HttpsOverseasValue,omitempty" xml:"HttpsOverseasValue,omitempty"`
	// The QPS that is calculated based on the HTTPS requests sent to points of presence (POPs).
	//
	// example:
	//
	// 1
	HttpsValue *string `json:"HttpsValue,omitempty" xml:"HttpsValue,omitempty"`
	// The QPS data outside the Chinese mainland.
	//
	// example:
	//
	// 0
	OverseasValue *string `json:"OverseasValue,omitempty" xml:"OverseasValue,omitempty"`
	// The timestamp of the data returned. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.
	//
	// example:
	//
	// 2023-06-27 10:10:58
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The total QPS.
	//
	// example:
	//
	// 0
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule) SetAccDomesticValue(v string) *DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule {
	s.AccDomesticValue = &v
	return s
}

func (s *DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule) SetAccOverseasValue(v string) *DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule {
	s.AccOverseasValue = &v
	return s
}

func (s *DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule) SetAccValue(v string) *DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule {
	s.AccValue = &v
	return s
}

func (s *DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule) SetDomesticValue(v string) *DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule {
	s.DomesticValue = &v
	return s
}

func (s *DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule) SetHttpsAccDomesticValue(v string) *DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule {
	s.HttpsAccDomesticValue = &v
	return s
}

func (s *DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule) SetHttpsAccOverseasValue(v string) *DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule {
	s.HttpsAccOverseasValue = &v
	return s
}

func (s *DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule) SetHttpsAccValue(v string) *DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule {
	s.HttpsAccValue = &v
	return s
}

func (s *DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule) SetHttpsDomesticValue(v string) *DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule {
	s.HttpsDomesticValue = &v
	return s
}

func (s *DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule) SetHttpsOverseasValue(v string) *DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule {
	s.HttpsOverseasValue = &v
	return s
}

func (s *DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule) SetHttpsValue(v string) *DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule {
	s.HttpsValue = &v
	return s
}

func (s *DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule) SetOverseasValue(v string) *DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule {
	s.OverseasValue = &v
	return s
}

func (s *DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule) SetTimeStamp(v string) *DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule) SetValue(v string) *DescribeVodDomainQpsDataResponseBodyQpsDataIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeVodDomainQpsDataResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodDomainQpsDataResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodDomainQpsDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainQpsDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainQpsDataResponse) SetHeaders(v map[string]*string) *DescribeVodDomainQpsDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodDomainQpsDataResponse) SetStatusCode(v int32) *DescribeVodDomainQpsDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodDomainQpsDataResponse) SetBody(v *DescribeVodDomainQpsDataResponseBody) *DescribeVodDomainQpsDataResponse {
	s.Body = v
	return s
}

type DescribeVodDomainRealTimeBpsDataRequest struct {
	// You can specify multiple domain names and separate them with commas (,). You can specify a maximum of 500 domain names in each call.
	//
	// This parameter is required.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// >  The end time must be later than the start time.
	//
	// example:
	//
	// 2019-11-30T05:40:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The name of the ISP. If you do not set this parameter, all ISPs are queried.
	//
	// example:
	//
	// telecom
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region. If you do not set this parameter, data in all regions is queried.
	//
	// example:
	//
	// shanghai
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// example:
	//
	// 2019-11-30T05:33:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainRealTimeBpsDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeBpsDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeBpsDataRequest) SetDomainName(v string) *DescribeVodDomainRealTimeBpsDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainRealTimeBpsDataRequest) SetEndTime(v string) *DescribeVodDomainRealTimeBpsDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainRealTimeBpsDataRequest) SetIspNameEn(v string) *DescribeVodDomainRealTimeBpsDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeVodDomainRealTimeBpsDataRequest) SetLocationNameEn(v string) *DescribeVodDomainRealTimeBpsDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeVodDomainRealTimeBpsDataRequest) SetOwnerId(v int64) *DescribeVodDomainRealTimeBpsDataRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodDomainRealTimeBpsDataRequest) SetStartTime(v string) *DescribeVodDomainRealTimeBpsDataRequest {
	s.StartTime = &v
	return s
}

type DescribeVodDomainRealTimeBpsDataResponseBody struct {
	// The returned data.
	Data *DescribeVodDomainRealTimeBpsDataResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// B49E6DDA-F413-422B-B58E-2FA23F286726
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeVodDomainRealTimeBpsDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeBpsDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeBpsDataResponseBody) SetData(v *DescribeVodDomainRealTimeBpsDataResponseBodyData) *DescribeVodDomainRealTimeBpsDataResponseBody {
	s.Data = v
	return s
}

func (s *DescribeVodDomainRealTimeBpsDataResponseBody) SetRequestId(v string) *DescribeVodDomainRealTimeBpsDataResponseBody {
	s.RequestId = &v
	return s
}

type DescribeVodDomainRealTimeBpsDataResponseBodyData struct {
	BpsModel []*DescribeVodDomainRealTimeBpsDataResponseBodyDataBpsModel `json:"BpsModel,omitempty" xml:"BpsModel,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainRealTimeBpsDataResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeBpsDataResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeBpsDataResponseBodyData) SetBpsModel(v []*DescribeVodDomainRealTimeBpsDataResponseBodyDataBpsModel) *DescribeVodDomainRealTimeBpsDataResponseBodyData {
	s.BpsModel = v
	return s
}

type DescribeVodDomainRealTimeBpsDataResponseBodyDataBpsModel struct {
	// The bandwidth. Unit: bit/s.
	//
	// example:
	//
	// 16710625.733333332
	Bps *float32 `json:"Bps,omitempty" xml:"Bps,omitempty"`
	// The timestamp of the data returned. The time follows the ISO 8601 standard. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-11-30T05:41:00Z
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeVodDomainRealTimeBpsDataResponseBodyDataBpsModel) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeBpsDataResponseBodyDataBpsModel) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeBpsDataResponseBodyDataBpsModel) SetBps(v float32) *DescribeVodDomainRealTimeBpsDataResponseBodyDataBpsModel {
	s.Bps = &v
	return s
}

func (s *DescribeVodDomainRealTimeBpsDataResponseBodyDataBpsModel) SetTimeStamp(v string) *DescribeVodDomainRealTimeBpsDataResponseBodyDataBpsModel {
	s.TimeStamp = &v
	return s
}

type DescribeVodDomainRealTimeBpsDataResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodDomainRealTimeBpsDataResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodDomainRealTimeBpsDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeBpsDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeBpsDataResponse) SetHeaders(v map[string]*string) *DescribeVodDomainRealTimeBpsDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodDomainRealTimeBpsDataResponse) SetStatusCode(v int32) *DescribeVodDomainRealTimeBpsDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodDomainRealTimeBpsDataResponse) SetBody(v *DescribeVodDomainRealTimeBpsDataResponseBody) *DescribeVodDomainRealTimeBpsDataResponse {
	s.Body = v
	return s
}

type DescribeVodDomainRealTimeByteHitRateDataRequest struct {
	// You can specify multiple domain names and separate them with commas (,). You can specify at most 100 domain names in each call.
	//
	// This parameter is required.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// >  The end time must be later than the start time.
	//
	// example:
	//
	// 2020-05-15T09:15:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// example:
	//
	// 2020-05-15T09:13:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainRealTimeByteHitRateDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeByteHitRateDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeByteHitRateDataRequest) SetDomainName(v string) *DescribeVodDomainRealTimeByteHitRateDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainRealTimeByteHitRateDataRequest) SetEndTime(v string) *DescribeVodDomainRealTimeByteHitRateDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainRealTimeByteHitRateDataRequest) SetOwnerId(v int64) *DescribeVodDomainRealTimeByteHitRateDataRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodDomainRealTimeByteHitRateDataRequest) SetStartTime(v string) *DescribeVodDomainRealTimeByteHitRateDataRequest {
	s.StartTime = &v
	return s
}

type DescribeVodDomainRealTimeByteHitRateDataResponseBody struct {
	// The returned data.
	Data *DescribeVodDomainRealTimeByteHitRateDataResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// 70A26B11-3673-479C-AEA8-E03FC5D3496D
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeVodDomainRealTimeByteHitRateDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeByteHitRateDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeByteHitRateDataResponseBody) SetData(v *DescribeVodDomainRealTimeByteHitRateDataResponseBodyData) *DescribeVodDomainRealTimeByteHitRateDataResponseBody {
	s.Data = v
	return s
}

func (s *DescribeVodDomainRealTimeByteHitRateDataResponseBody) SetRequestId(v string) *DescribeVodDomainRealTimeByteHitRateDataResponseBody {
	s.RequestId = &v
	return s
}

type DescribeVodDomainRealTimeByteHitRateDataResponseBodyData struct {
	ByteHitRateDataModel []*DescribeVodDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel `json:"ByteHitRateDataModel,omitempty" xml:"ByteHitRateDataModel,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainRealTimeByteHitRateDataResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeByteHitRateDataResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeByteHitRateDataResponseBodyData) SetByteHitRateDataModel(v []*DescribeVodDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel) *DescribeVodDomainRealTimeByteHitRateDataResponseBodyData {
	s.ByteHitRateDataModel = v
	return s
}

type DescribeVodDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel struct {
	// The byte hit ratio in percentage.
	//
	// example:
	//
	// 0.8956940476262277
	ByteHitRate *float32 `json:"ByteHitRate,omitempty" xml:"ByteHitRate,omitempty"`
	// The timestamp of the data returned. The time follows the ISO 8601 standard. The time is displayed in UTC.
	//
	// example:
	//
	// 2020-05-15T09:13:00Z
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeVodDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel) SetByteHitRate(v float32) *DescribeVodDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel {
	s.ByteHitRate = &v
	return s
}

func (s *DescribeVodDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel) SetTimeStamp(v string) *DescribeVodDomainRealTimeByteHitRateDataResponseBodyDataByteHitRateDataModel {
	s.TimeStamp = &v
	return s
}

type DescribeVodDomainRealTimeByteHitRateDataResponse struct {
	Headers    map[string]*string                                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodDomainRealTimeByteHitRateDataResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodDomainRealTimeByteHitRateDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeByteHitRateDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeByteHitRateDataResponse) SetHeaders(v map[string]*string) *DescribeVodDomainRealTimeByteHitRateDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodDomainRealTimeByteHitRateDataResponse) SetStatusCode(v int32) *DescribeVodDomainRealTimeByteHitRateDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodDomainRealTimeByteHitRateDataResponse) SetBody(v *DescribeVodDomainRealTimeByteHitRateDataResponseBody) *DescribeVodDomainRealTimeByteHitRateDataResponse {
	s.Body = v
	return s
}

type DescribeVodDomainRealTimeDetailDataRequest struct {
	// The accelerated domain name. You can specify a maximum of 20 accelerated domain names in each call. Separate domain names with commas (,).
	//
	// This parameter is required.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. Example: 2019-11-30T05:40:00Z.
	//
	// This parameter is required.
	//
	// example:
	//
	// 2019-01-23T12:40:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The type of data that you want to query. You can specify multiple data types and separate them with commas (,). Valid values:
	//
	// qps: the number of queries per second bps: bandwidth data http_code: HTTP status codes
	//
	// This parameter is required.
	//
	// example:
	//
	// bps
	Field *string `json:"Field,omitempty" xml:"Field,omitempty"`
	// The name of the Internet service provider (ISP).
	//
	// example:
	//
	// unicom
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region. If you do not specify a region, data in all regions is queried.
	//
	// example:
	//
	// shanghai
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// Specifies whether to return a summary value. Valid values:
	//
	// true false (default)
	//
	// example:
	//
	// false
	Merge *string `json:"Merge,omitempty" xml:"Merge,omitempty"`
	// Specifies whether to return a summary value. Valid values:
	//
	// 	- **true**: groups the results by domain name and merges the results by region and ISP.
	//
	// 	- **false**: groups the results by domain name.
	//
	// Default value: **false**.
	//
	// example:
	//
	// true
	MergeLocIsp *string `json:"MergeLocIsp,omitempty" xml:"MergeLocIsp,omitempty"`
	OwnerId     *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. Example: 2019-11-30T05:33:00Z.
	//
	// This parameter is required.
	//
	// example:
	//
	// 2019-01-23T12:35:12Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainRealTimeDetailDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeDetailDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeDetailDataRequest) SetDomainName(v string) *DescribeVodDomainRealTimeDetailDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainRealTimeDetailDataRequest) SetEndTime(v string) *DescribeVodDomainRealTimeDetailDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainRealTimeDetailDataRequest) SetField(v string) *DescribeVodDomainRealTimeDetailDataRequest {
	s.Field = &v
	return s
}

func (s *DescribeVodDomainRealTimeDetailDataRequest) SetIspNameEn(v string) *DescribeVodDomainRealTimeDetailDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeVodDomainRealTimeDetailDataRequest) SetLocationNameEn(v string) *DescribeVodDomainRealTimeDetailDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeVodDomainRealTimeDetailDataRequest) SetMerge(v string) *DescribeVodDomainRealTimeDetailDataRequest {
	s.Merge = &v
	return s
}

func (s *DescribeVodDomainRealTimeDetailDataRequest) SetMergeLocIsp(v string) *DescribeVodDomainRealTimeDetailDataRequest {
	s.MergeLocIsp = &v
	return s
}

func (s *DescribeVodDomainRealTimeDetailDataRequest) SetOwnerId(v int64) *DescribeVodDomainRealTimeDetailDataRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodDomainRealTimeDetailDataRequest) SetStartTime(v string) *DescribeVodDomainRealTimeDetailDataRequest {
	s.StartTime = &v
	return s
}

type DescribeVodDomainRealTimeDetailDataResponseBody struct {
	// The returned results.
	//
	// example:
	//
	// [
	//
	//       {
	//
	//             "time_stp": "2018-06-05T20:00:00Z",
	//
	//             "domain_name": "example.com",
	//
	//             "location": "Guangdong",
	//
	//             "isp": "telecom",
	//
	//             "qps": 10
	//
	//       },
	//
	//       {
	//
	//             "time_stp": "2018-06-05T20:00:00Z",
	//
	//             "domain_name": "example.com",
	//
	//             "location": "Jiangsu",
	//
	//             "isp": "unicom",
	//
	//             "qps": 11.1
	//
	//       }
	//
	// ]
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// 1710298E-8AFA-5F6D-A3E9-47103C52177D
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeVodDomainRealTimeDetailDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeDetailDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeDetailDataResponseBody) SetData(v string) *DescribeVodDomainRealTimeDetailDataResponseBody {
	s.Data = &v
	return s
}

func (s *DescribeVodDomainRealTimeDetailDataResponseBody) SetRequestId(v string) *DescribeVodDomainRealTimeDetailDataResponseBody {
	s.RequestId = &v
	return s
}

type DescribeVodDomainRealTimeDetailDataResponse struct {
	Headers    map[string]*string                               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodDomainRealTimeDetailDataResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodDomainRealTimeDetailDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeDetailDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeDetailDataResponse) SetHeaders(v map[string]*string) *DescribeVodDomainRealTimeDetailDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodDomainRealTimeDetailDataResponse) SetStatusCode(v int32) *DescribeVodDomainRealTimeDetailDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodDomainRealTimeDetailDataResponse) SetBody(v *DescribeVodDomainRealTimeDetailDataResponseBody) *DescribeVodDomainRealTimeDetailDataResponse {
	s.Body = v
	return s
}

type DescribeVodDomainRealTimeHttpCodeDataRequest struct {
	// The accelerated domain name.
	//
	// 	- You can specify multiple domain names and separate them with commas (,). You can specify at most 100 domain names in each call.
	//
	// 	- If you specify multiple domain names, merged data is returned.
	//
	// 	- To obtain the accelerated domain name, perform the following steps: Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Configuration Management > CDN Configuration > Domain Names**. On the Domain Names page, view the accelerated domain names. Alternatively, you can call the [DescribeVodUserDomains](~~DescribeVodUserDomains~~) operation to query the accelerated domain names.
	//
	// This parameter is required.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// >  The end time must be later than the start time.
	//
	// example:
	//
	// 2019-11-30T05:40:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The name of the ISP. If you do not set this parameter, all ISPs are queried.
	//
	// example:
	//
	// unicom
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region. If you do not set this parameter, data in all regions is queried.
	//
	// example:
	//
	// shanghai
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// example:
	//
	// 2019-11-30T05:39:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainRealTimeHttpCodeDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeHttpCodeDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeHttpCodeDataRequest) SetDomainName(v string) *DescribeVodDomainRealTimeHttpCodeDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainRealTimeHttpCodeDataRequest) SetEndTime(v string) *DescribeVodDomainRealTimeHttpCodeDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainRealTimeHttpCodeDataRequest) SetIspNameEn(v string) *DescribeVodDomainRealTimeHttpCodeDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeVodDomainRealTimeHttpCodeDataRequest) SetLocationNameEn(v string) *DescribeVodDomainRealTimeHttpCodeDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeVodDomainRealTimeHttpCodeDataRequest) SetOwnerId(v int64) *DescribeVodDomainRealTimeHttpCodeDataRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodDomainRealTimeHttpCodeDataRequest) SetStartTime(v string) *DescribeVodDomainRealTimeHttpCodeDataRequest {
	s.StartTime = &v
	return s
}

type DescribeVodDomainRealTimeHttpCodeDataResponseBody struct {
	// The time interval at which data is returned. Unit: seconds.
	//
	// The returned value varies based on the time range per query. Valid values: 60 (1 minute), 300 (5 minutes), and 3600 (1 hour). For more information, see the **Time granularity*	- section in the **API documentation**.
	//
	// example:
	//
	// 60
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range.
	//
	// example:
	//
	// 2019-11-30T05:40:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The proportion of each HTTP status code in each time interval.
	RealTimeHttpCodeData *DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData `json:"RealTimeHttpCodeData,omitempty" xml:"RealTimeHttpCodeData,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// BC858082-736F-4A25-867B-E5B67C85ACF7
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range.
	//
	// example:
	//
	// 2019-11-30T05:39:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainRealTimeHttpCodeDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeHttpCodeDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeHttpCodeDataResponseBody) SetDataInterval(v string) *DescribeVodDomainRealTimeHttpCodeDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeVodDomainRealTimeHttpCodeDataResponseBody) SetDomainName(v string) *DescribeVodDomainRealTimeHttpCodeDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainRealTimeHttpCodeDataResponseBody) SetEndTime(v string) *DescribeVodDomainRealTimeHttpCodeDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainRealTimeHttpCodeDataResponseBody) SetRealTimeHttpCodeData(v *DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData) *DescribeVodDomainRealTimeHttpCodeDataResponseBody {
	s.RealTimeHttpCodeData = v
	return s
}

func (s *DescribeVodDomainRealTimeHttpCodeDataResponseBody) SetRequestId(v string) *DescribeVodDomainRealTimeHttpCodeDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVodDomainRealTimeHttpCodeDataResponseBody) SetStartTime(v string) *DescribeVodDomainRealTimeHttpCodeDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData struct {
	UsageData []*DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData `json:"UsageData,omitempty" xml:"UsageData,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData) SetUsageData(v []*DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData) *DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeData {
	s.UsageData = v
	return s
}

type DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData struct {
	// The timestamp of the data returned. The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-11-30T05:39:00Z
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The proportion of each HTTP status code is displayed in a data list.
	Value *DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue `json:"Value,omitempty" xml:"Value,omitempty" type:"Struct"`
}

func (s DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData) SetTimeStamp(v string) *DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData {
	s.TimeStamp = &v
	return s
}

func (s *DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData) SetValue(v *DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue) *DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageData {
	s.Value = v
	return s
}

type DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue struct {
	RealTimeCodeProportionData []*DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData `json:"RealTimeCodeProportionData,omitempty" xml:"RealTimeCodeProportionData,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue) SetRealTimeCodeProportionData(v []*DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData) *DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValue {
	s.RealTimeCodeProportionData = v
	return s
}

type DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData struct {
	// The HTTP status code.
	//
	// example:
	//
	// 500
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The number of the HTTP status codes.
	//
	// example:
	//
	// 100
	Count *string `json:"Count,omitempty" xml:"Count,omitempty"`
	// The proportion of the HTTP status code in percentage.
	//
	// example:
	//
	// 28.4496124031008
	Proportion *string `json:"Proportion,omitempty" xml:"Proportion,omitempty"`
}

func (s DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData) SetCode(v string) *DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData {
	s.Code = &v
	return s
}

func (s *DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData) SetCount(v string) *DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData {
	s.Count = &v
	return s
}

func (s *DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData) SetProportion(v string) *DescribeVodDomainRealTimeHttpCodeDataResponseBodyRealTimeHttpCodeDataUsageDataValueRealTimeCodeProportionData {
	s.Proportion = &v
	return s
}

type DescribeVodDomainRealTimeHttpCodeDataResponse struct {
	Headers    map[string]*string                                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodDomainRealTimeHttpCodeDataResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodDomainRealTimeHttpCodeDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeHttpCodeDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeHttpCodeDataResponse) SetHeaders(v map[string]*string) *DescribeVodDomainRealTimeHttpCodeDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodDomainRealTimeHttpCodeDataResponse) SetStatusCode(v int32) *DescribeVodDomainRealTimeHttpCodeDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodDomainRealTimeHttpCodeDataResponse) SetBody(v *DescribeVodDomainRealTimeHttpCodeDataResponseBody) *DescribeVodDomainRealTimeHttpCodeDataResponse {
	s.Body = v
	return s
}

type DescribeVodDomainRealTimeQpsDataRequest struct {
	// You can specify multiple domain names and separate them with commas (,). You can specify a maximum of 500 domain names in each call.
	//
	// This parameter is required.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// >  The end time must be later than the start time.
	//
	// example:
	//
	// 2019-12-02T11:26:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The name of the Internet service provider (ISP). If you do not set this parameter, all ISPs are queried.
	//
	// example:
	//
	// unicom
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region. If you do not set this parameter, data in all regions is queried.
	//
	// example:
	//
	// shanghai
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// example:
	//
	// 2019-12-02T11:25:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainRealTimeQpsDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeQpsDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeQpsDataRequest) SetDomainName(v string) *DescribeVodDomainRealTimeQpsDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainRealTimeQpsDataRequest) SetEndTime(v string) *DescribeVodDomainRealTimeQpsDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainRealTimeQpsDataRequest) SetIspNameEn(v string) *DescribeVodDomainRealTimeQpsDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeVodDomainRealTimeQpsDataRequest) SetLocationNameEn(v string) *DescribeVodDomainRealTimeQpsDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeVodDomainRealTimeQpsDataRequest) SetOwnerId(v int64) *DescribeVodDomainRealTimeQpsDataRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodDomainRealTimeQpsDataRequest) SetStartTime(v string) *DescribeVodDomainRealTimeQpsDataRequest {
	s.StartTime = &v
	return s
}

type DescribeVodDomainRealTimeQpsDataResponseBody struct {
	// The returned data.
	Data *DescribeVodDomainRealTimeQpsDataResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// 32DC9806-E9F9-4490-BBDC-B3A9E32FCC1D
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeVodDomainRealTimeQpsDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeQpsDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeQpsDataResponseBody) SetData(v *DescribeVodDomainRealTimeQpsDataResponseBodyData) *DescribeVodDomainRealTimeQpsDataResponseBody {
	s.Data = v
	return s
}

func (s *DescribeVodDomainRealTimeQpsDataResponseBody) SetRequestId(v string) *DescribeVodDomainRealTimeQpsDataResponseBody {
	s.RequestId = &v
	return s
}

type DescribeVodDomainRealTimeQpsDataResponseBodyData struct {
	QpsModel []*DescribeVodDomainRealTimeQpsDataResponseBodyDataQpsModel `json:"QpsModel,omitempty" xml:"QpsModel,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainRealTimeQpsDataResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeQpsDataResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeQpsDataResponseBodyData) SetQpsModel(v []*DescribeVodDomainRealTimeQpsDataResponseBodyDataQpsModel) *DescribeVodDomainRealTimeQpsDataResponseBodyData {
	s.QpsModel = v
	return s
}

type DescribeVodDomainRealTimeQpsDataResponseBodyDataQpsModel struct {
	// The number of queries per second.
	//
	// example:
	//
	// 1851.25
	Qps *float32 `json:"Qps,omitempty" xml:"Qps,omitempty"`
	// The timestamp of the returned data. The time follows the ISO 8601 standard. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-12-02T11:25:00Z
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeVodDomainRealTimeQpsDataResponseBodyDataQpsModel) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeQpsDataResponseBodyDataQpsModel) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeQpsDataResponseBodyDataQpsModel) SetQps(v float32) *DescribeVodDomainRealTimeQpsDataResponseBodyDataQpsModel {
	s.Qps = &v
	return s
}

func (s *DescribeVodDomainRealTimeQpsDataResponseBodyDataQpsModel) SetTimeStamp(v string) *DescribeVodDomainRealTimeQpsDataResponseBodyDataQpsModel {
	s.TimeStamp = &v
	return s
}

type DescribeVodDomainRealTimeQpsDataResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodDomainRealTimeQpsDataResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodDomainRealTimeQpsDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeQpsDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeQpsDataResponse) SetHeaders(v map[string]*string) *DescribeVodDomainRealTimeQpsDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodDomainRealTimeQpsDataResponse) SetStatusCode(v int32) *DescribeVodDomainRealTimeQpsDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodDomainRealTimeQpsDataResponse) SetBody(v *DescribeVodDomainRealTimeQpsDataResponseBody) *DescribeVodDomainRealTimeQpsDataResponse {
	s.Body = v
	return s
}

type DescribeVodDomainRealTimeReqHitRateDataRequest struct {
	// You can specify multiple domain names and separate them with commas (,). You can specify a maximum of 100 domain names in each call. If you specify multiple domain names, merged data is returned.
	//
	// This parameter is required.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// >  The end time must be later than the start time.
	//
	// example:
	//
	// 2024-01-02T11:26:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// example:
	//
	// 2024-01-02T11:23:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainRealTimeReqHitRateDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeReqHitRateDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeReqHitRateDataRequest) SetDomainName(v string) *DescribeVodDomainRealTimeReqHitRateDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainRealTimeReqHitRateDataRequest) SetEndTime(v string) *DescribeVodDomainRealTimeReqHitRateDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainRealTimeReqHitRateDataRequest) SetOwnerId(v int64) *DescribeVodDomainRealTimeReqHitRateDataRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodDomainRealTimeReqHitRateDataRequest) SetStartTime(v string) *DescribeVodDomainRealTimeReqHitRateDataRequest {
	s.StartTime = &v
	return s
}

type DescribeVodDomainRealTimeReqHitRateDataResponseBody struct {
	// The returned results.
	Data *DescribeVodDomainRealTimeReqHitRateDataResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// 70A26B11-3673-479C-AEA8-E03FC5D3496D
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeVodDomainRealTimeReqHitRateDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeReqHitRateDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeReqHitRateDataResponseBody) SetData(v *DescribeVodDomainRealTimeReqHitRateDataResponseBodyData) *DescribeVodDomainRealTimeReqHitRateDataResponseBody {
	s.Data = v
	return s
}

func (s *DescribeVodDomainRealTimeReqHitRateDataResponseBody) SetRequestId(v string) *DescribeVodDomainRealTimeReqHitRateDataResponseBody {
	s.RequestId = &v
	return s
}

type DescribeVodDomainRealTimeReqHitRateDataResponseBodyData struct {
	ReqHitRateDataModel []*DescribeVodDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel `json:"ReqHitRateDataModel,omitempty" xml:"ReqHitRateDataModel,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainRealTimeReqHitRateDataResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeReqHitRateDataResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeReqHitRateDataResponseBodyData) SetReqHitRateDataModel(v []*DescribeVodDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel) *DescribeVodDomainRealTimeReqHitRateDataResponseBodyData {
	s.ReqHitRateDataModel = v
	return s
}

type DescribeVodDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel struct {
	// The cache hit ratio that is calculated based on requests. The cache hit ratio is measured in percentage.
	//
	// example:
	//
	// 0.8956940476262277
	ReqHitRate *float32 `json:"ReqHitRate,omitempty" xml:"ReqHitRate,omitempty"`
	// The timestamp of the data returned. The time follows the ISO 8601 standard. The time is displayed in UTC.
	//
	// example:
	//
	// 2024-01-02T11:26:00Z
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeVodDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel) SetReqHitRate(v float32) *DescribeVodDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel {
	s.ReqHitRate = &v
	return s
}

func (s *DescribeVodDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel) SetTimeStamp(v string) *DescribeVodDomainRealTimeReqHitRateDataResponseBodyDataReqHitRateDataModel {
	s.TimeStamp = &v
	return s
}

type DescribeVodDomainRealTimeReqHitRateDataResponse struct {
	Headers    map[string]*string                                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodDomainRealTimeReqHitRateDataResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodDomainRealTimeReqHitRateDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeReqHitRateDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeReqHitRateDataResponse) SetHeaders(v map[string]*string) *DescribeVodDomainRealTimeReqHitRateDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodDomainRealTimeReqHitRateDataResponse) SetStatusCode(v int32) *DescribeVodDomainRealTimeReqHitRateDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodDomainRealTimeReqHitRateDataResponse) SetBody(v *DescribeVodDomainRealTimeReqHitRateDataResponseBody) *DescribeVodDomainRealTimeReqHitRateDataResponse {
	s.Body = v
	return s
}

type DescribeVodDomainRealTimeTrafficDataRequest struct {
	// You can specify multiple domain names and separate them with commas (,). You can specify a maximum of 500 domain names in each call.
	//
	// This parameter is required.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// >  The end time must be later than the start time.
	//
	// example:
	//
	// 2019-12-10T20:01:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The name of the ISP. If you do not set this parameter, all ISPs are queried.
	//
	// example:
	//
	// telecom
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region. If you do not set this parameter, data in all regions is queried.
	//
	// example:
	//
	// shanghai
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The beginning of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// example:
	//
	// 2019-12-10T20:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainRealTimeTrafficDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeTrafficDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeTrafficDataRequest) SetDomainName(v string) *DescribeVodDomainRealTimeTrafficDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainRealTimeTrafficDataRequest) SetEndTime(v string) *DescribeVodDomainRealTimeTrafficDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainRealTimeTrafficDataRequest) SetIspNameEn(v string) *DescribeVodDomainRealTimeTrafficDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeVodDomainRealTimeTrafficDataRequest) SetLocationNameEn(v string) *DescribeVodDomainRealTimeTrafficDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeVodDomainRealTimeTrafficDataRequest) SetOwnerId(v int64) *DescribeVodDomainRealTimeTrafficDataRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodDomainRealTimeTrafficDataRequest) SetStartTime(v string) *DescribeVodDomainRealTimeTrafficDataRequest {
	s.StartTime = &v
	return s
}

type DescribeVodDomainRealTimeTrafficDataResponseBody struct {
	// The time interval at which data is returned. Unit: seconds.
	//
	// The returned value varies based on the time range per query. Valid values: 60 (1 minute), 300 (5 minutes), and 3600 (1 hour). For more information, see the **Time granularity*	- section in the **API documentation**.
	//
	// example:
	//
	// 60
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range.
	//
	// example:
	//
	// 2019-12-10T20:01:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The details of traffic data in each time interval.
	RealTimeTrafficDataPerInterval *DescribeVodDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval `json:"RealTimeTrafficDataPerInterval,omitempty" xml:"RealTimeTrafficDataPerInterval,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// A666D44F-19D6-490E-97CF-1A64AB962C57
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range.
	//
	// example:
	//
	// 2019-12-10T20:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainRealTimeTrafficDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeTrafficDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeTrafficDataResponseBody) SetDataInterval(v string) *DescribeVodDomainRealTimeTrafficDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeVodDomainRealTimeTrafficDataResponseBody) SetDomainName(v string) *DescribeVodDomainRealTimeTrafficDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainRealTimeTrafficDataResponseBody) SetEndTime(v string) *DescribeVodDomainRealTimeTrafficDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainRealTimeTrafficDataResponseBody) SetRealTimeTrafficDataPerInterval(v *DescribeVodDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval) *DescribeVodDomainRealTimeTrafficDataResponseBody {
	s.RealTimeTrafficDataPerInterval = v
	return s
}

func (s *DescribeVodDomainRealTimeTrafficDataResponseBody) SetRequestId(v string) *DescribeVodDomainRealTimeTrafficDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVodDomainRealTimeTrafficDataResponseBody) SetStartTime(v string) *DescribeVodDomainRealTimeTrafficDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeVodDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval struct {
	DataModule []*DescribeVodDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval) SetDataModule(v []*DescribeVodDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule) *DescribeVodDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeVodDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule struct {
	// The timestamp of the data returned. The time follows the ISO 8601 standard. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-12-10T20:01:00Z
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The traffic data. Unit: bytes.
	//
	// example:
	//
	// 0
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVodDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeVodDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeVodDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule) SetValue(v string) *DescribeVodDomainRealTimeTrafficDataResponseBodyRealTimeTrafficDataPerIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeVodDomainRealTimeTrafficDataResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodDomainRealTimeTrafficDataResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodDomainRealTimeTrafficDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainRealTimeTrafficDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainRealTimeTrafficDataResponse) SetHeaders(v map[string]*string) *DescribeVodDomainRealTimeTrafficDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodDomainRealTimeTrafficDataResponse) SetStatusCode(v int32) *DescribeVodDomainRealTimeTrafficDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodDomainRealTimeTrafficDataResponse) SetBody(v *DescribeVodDomainRealTimeTrafficDataResponseBody) *DescribeVodDomainRealTimeTrafficDataResponse {
	s.Body = v
	return s
}

type DescribeVodDomainReqHitRateDataRequest struct {
	// The accelerated domain name.
	//
	// 	- If you leave this parameter empty, the merged data of all your accelerated domain names is returned.
	//
	// 	- You can specify a maximum of 500 accelerated domain names. Separate multiple domain names with commas (,).
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// >  The end time must be later than the start time.
	//
	// example:
	//
	// 2023-12-22T08:00:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time granularity. Unit: seconds. Valid values: **300**, **3600**, and **86400**. If you leave this parameter empty or specify an invalid value, the default value is used. The supported time granularity varies based on the time range specified by `EndTime` and `StartTime`. The following content describes the supported time granularity.
	//
	// 	- Time range per query < 3 days: **300*	- (default), **3600**, and **86400**
	//
	// 	- 3 days ≤ Time range per query < 31 days: **3600*	- (default) and **86400**
	//
	// 	- 31 days ≤ Time range per query ≤ 90 days: **86400*	- (default)
	//
	// example:
	//
	// 300
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// example:
	//
	// 2023-12-21T08:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainReqHitRateDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainReqHitRateDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainReqHitRateDataRequest) SetDomainName(v string) *DescribeVodDomainReqHitRateDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainReqHitRateDataRequest) SetEndTime(v string) *DescribeVodDomainReqHitRateDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainReqHitRateDataRequest) SetInterval(v string) *DescribeVodDomainReqHitRateDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeVodDomainReqHitRateDataRequest) SetStartTime(v string) *DescribeVodDomainReqHitRateDataRequest {
	s.StartTime = &v
	return s
}

type DescribeVodDomainReqHitRateDataResponseBody struct {
	// The request hit rate data at each time interval.
	Data *DescribeVodDomainReqHitRateDataResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The time interval at which data is returned, which is the time granularity. Unit: seconds.
	//
	// example:
	//
	// 300
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range.
	//
	// example:
	//
	// 2023-12-22T08:00:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// D94E471F-1A27-442E-552D-D4D2000C****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range.
	//
	// example:
	//
	// 2023-12-21T08:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainReqHitRateDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainReqHitRateDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainReqHitRateDataResponseBody) SetData(v *DescribeVodDomainReqHitRateDataResponseBodyData) *DescribeVodDomainReqHitRateDataResponseBody {
	s.Data = v
	return s
}

func (s *DescribeVodDomainReqHitRateDataResponseBody) SetDataInterval(v string) *DescribeVodDomainReqHitRateDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeVodDomainReqHitRateDataResponseBody) SetDomainName(v string) *DescribeVodDomainReqHitRateDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainReqHitRateDataResponseBody) SetEndTime(v string) *DescribeVodDomainReqHitRateDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainReqHitRateDataResponseBody) SetRequestId(v string) *DescribeVodDomainReqHitRateDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVodDomainReqHitRateDataResponseBody) SetStartTime(v string) *DescribeVodDomainReqHitRateDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeVodDomainReqHitRateDataResponseBodyData struct {
	DataModule []*DescribeVodDomainReqHitRateDataResponseBodyDataDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainReqHitRateDataResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainReqHitRateDataResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainReqHitRateDataResponseBodyData) SetDataModule(v []*DescribeVodDomainReqHitRateDataResponseBodyDataDataModule) *DescribeVodDomainReqHitRateDataResponseBodyData {
	s.DataModule = v
	return s
}

type DescribeVodDomainReqHitRateDataResponseBodyDataDataModule struct {
	// The HTTPS request hit rate.
	//
	// example:
	//
	// 50
	HttpsValue *string `json:"HttpsValue,omitempty" xml:"HttpsValue,omitempty"`
	// The timestamp of the data returned. The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.
	//
	// example:
	//
	// 2023-12-21T08:00:00Z
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The total request hit rate.
	//
	// example:
	//
	// 100
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVodDomainReqHitRateDataResponseBodyDataDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainReqHitRateDataResponseBodyDataDataModule) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainReqHitRateDataResponseBodyDataDataModule) SetHttpsValue(v string) *DescribeVodDomainReqHitRateDataResponseBodyDataDataModule {
	s.HttpsValue = &v
	return s
}

func (s *DescribeVodDomainReqHitRateDataResponseBodyDataDataModule) SetTimeStamp(v string) *DescribeVodDomainReqHitRateDataResponseBodyDataDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeVodDomainReqHitRateDataResponseBodyDataDataModule) SetValue(v string) *DescribeVodDomainReqHitRateDataResponseBodyDataDataModule {
	s.Value = &v
	return s
}

type DescribeVodDomainReqHitRateDataResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodDomainReqHitRateDataResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodDomainReqHitRateDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainReqHitRateDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainReqHitRateDataResponse) SetHeaders(v map[string]*string) *DescribeVodDomainReqHitRateDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodDomainReqHitRateDataResponse) SetStatusCode(v int32) *DescribeVodDomainReqHitRateDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodDomainReqHitRateDataResponse) SetBody(v *DescribeVodDomainReqHitRateDataResponseBody) *DescribeVodDomainReqHitRateDataResponse {
	s.Body = v
	return s
}

type DescribeVodDomainSrcBpsDataRequest struct {
	// The accelerated domain name.
	//
	// 	- If you leave this parameter empty, the merged data of all your accelerated domain names is returned.
	//
	// 	- You can specify a maximum of 500 accelerated domain names. Separate multiple domain names with commas (,).
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// >  The end time must be later than the start time.
	//
	// example:
	//
	// 2022-04-26T15:59:59Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time granularity. Unit: seconds. Valid values: **300**, **3600**, and **86400**. If you leave this parameter empty or specify an invalid value, the default value is used. The supported time granularity varies based on the time range specified by `EndTime` and `StartTime`. The following content describes the supported time granularity.
	//
	// 	- Time range per query < 3 days: **300*	- (default), **3600**, and **86400**
	//
	// 	- 3 days ≤ Time range per query < 31 days: **3600*	- (default) and **86400**
	//
	// 	- 31 days ≤ Time range per query ≤ 366 days: **86400*	- (default)
	//
	// example:
	//
	// 300
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	OwnerId  *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The start of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// example:
	//
	// 2022-04-25T16:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainSrcBpsDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainSrcBpsDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainSrcBpsDataRequest) SetDomainName(v string) *DescribeVodDomainSrcBpsDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainSrcBpsDataRequest) SetEndTime(v string) *DescribeVodDomainSrcBpsDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainSrcBpsDataRequest) SetInterval(v string) *DescribeVodDomainSrcBpsDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeVodDomainSrcBpsDataRequest) SetOwnerId(v int64) *DescribeVodDomainSrcBpsDataRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodDomainSrcBpsDataRequest) SetStartTime(v string) *DescribeVodDomainSrcBpsDataRequest {
	s.StartTime = &v
	return s
}

type DescribeVodDomainSrcBpsDataResponseBody struct {
	// The time interval at which data is returned, which is the time granularity. Unit: seconds.
	//
	// example:
	//
	// 300
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name whose ICP filing status you want to update.
	//
	// example:
	//
	// sample.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range.
	//
	// example:
	//
	// 2022-08-23T02:02:57Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A13-BEF6-****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The origin bandwidth data at each time interval.
	SrcBpsDataPerInterval *DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerInterval `json:"SrcBpsDataPerInterval,omitempty" xml:"SrcBpsDataPerInterval,omitempty" type:"Struct"`
	// The beginning of the time range.
	//
	// example:
	//
	// 2022-07-12T16:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainSrcBpsDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainSrcBpsDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainSrcBpsDataResponseBody) SetDataInterval(v string) *DescribeVodDomainSrcBpsDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeVodDomainSrcBpsDataResponseBody) SetDomainName(v string) *DescribeVodDomainSrcBpsDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainSrcBpsDataResponseBody) SetEndTime(v string) *DescribeVodDomainSrcBpsDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainSrcBpsDataResponseBody) SetRequestId(v string) *DescribeVodDomainSrcBpsDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVodDomainSrcBpsDataResponseBody) SetSrcBpsDataPerInterval(v *DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerInterval) *DescribeVodDomainSrcBpsDataResponseBody {
	s.SrcBpsDataPerInterval = v
	return s
}

func (s *DescribeVodDomainSrcBpsDataResponseBody) SetStartTime(v string) *DescribeVodDomainSrcBpsDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerInterval struct {
	DataModule []*DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerInterval) SetDataModule(v []*DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule) *DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule struct {
	// The bandwidth consumed for fetching resources from the origin over HTTPS.
	//
	// example:
	//
	// 0
	HttpsValue *string `json:"HttpsValue,omitempty" xml:"HttpsValue,omitempty"`
	// The timestamp of the data returned. The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.
	//
	// example:
	//
	// 2022-08-23T02:02:57Z
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The total origin bandwidth data. Unit: bit/s.
	//
	// example:
	//
	// 0
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule) SetHttpsValue(v string) *DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule {
	s.HttpsValue = &v
	return s
}

func (s *DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule) SetValue(v string) *DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeVodDomainSrcBpsDataResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodDomainSrcBpsDataResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodDomainSrcBpsDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainSrcBpsDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainSrcBpsDataResponse) SetHeaders(v map[string]*string) *DescribeVodDomainSrcBpsDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodDomainSrcBpsDataResponse) SetStatusCode(v int32) *DescribeVodDomainSrcBpsDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodDomainSrcBpsDataResponse) SetBody(v *DescribeVodDomainSrcBpsDataResponseBody) *DescribeVodDomainSrcBpsDataResponse {
	s.Body = v
	return s
}

type DescribeVodDomainSrcTrafficDataRequest struct {
	// The accelerated domain name. You can specify a maximum of 500 domain names in a request. Separate multiple domain names with commas (,). If you specify multiple domain names in a request, aggregation results are returned.
	//
	// If you leave this parameter empty, the origin traffic data for all accelerated domain names is queried by default.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. The end time must be later than the start time. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// example:
	//
	// 2022-09-24T15:59:59Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time interval between the data entries to return. Unit: seconds. Valid values:
	//
	// 	- **300**: 5 minutes
	//
	// 	- **3600**: 1 hour
	//
	// 	- **86400**: 1 day
	//
	// > The time granularity supported by the Interval parameter varies based on the time range per query specified by using `StartTime` and `EndTime`. For more information, see the **Time granularity*	- section of this topic.
	//
	// example:
	//
	// 300
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	OwnerId  *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The beginning of the time range to query. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// If you leave this parameter empty, the origin traffic data that is generated in the last 24 hours is queried by default.
	//
	// example:
	//
	// 2022-03-22T16:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainSrcTrafficDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainSrcTrafficDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainSrcTrafficDataRequest) SetDomainName(v string) *DescribeVodDomainSrcTrafficDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainSrcTrafficDataRequest) SetEndTime(v string) *DescribeVodDomainSrcTrafficDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainSrcTrafficDataRequest) SetInterval(v string) *DescribeVodDomainSrcTrafficDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeVodDomainSrcTrafficDataRequest) SetOwnerId(v int64) *DescribeVodDomainSrcTrafficDataRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodDomainSrcTrafficDataRequest) SetStartTime(v string) *DescribeVodDomainSrcTrafficDataRequest {
	s.StartTime = &v
	return s
}

type DescribeVodDomainSrcTrafficDataResponseBody struct {
	// The time interval between the entries returned. Unit: seconds.
	//
	// example:
	//
	// 300
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2022-09-23T15:59:59Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4AF6-D7393642CA58****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Details about the origin traffic returned at each time interval. Unit: bytes.
	SrcTrafficDataPerInterval *DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval `json:"SrcTrafficDataPerInterval,omitempty" xml:"SrcTrafficDataPerInterval,omitempty" type:"Struct"`
	// The start of the time range during which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2022-08-29T16:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The total traffic. Unit: bytes.
	//
	// example:
	//
	// 5906662826
	TotalTraffic *string `json:"TotalTraffic,omitempty" xml:"TotalTraffic,omitempty"`
}

func (s DescribeVodDomainSrcTrafficDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainSrcTrafficDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainSrcTrafficDataResponseBody) SetDataInterval(v string) *DescribeVodDomainSrcTrafficDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeVodDomainSrcTrafficDataResponseBody) SetDomainName(v string) *DescribeVodDomainSrcTrafficDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainSrcTrafficDataResponseBody) SetEndTime(v string) *DescribeVodDomainSrcTrafficDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainSrcTrafficDataResponseBody) SetRequestId(v string) *DescribeVodDomainSrcTrafficDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVodDomainSrcTrafficDataResponseBody) SetSrcTrafficDataPerInterval(v *DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval) *DescribeVodDomainSrcTrafficDataResponseBody {
	s.SrcTrafficDataPerInterval = v
	return s
}

func (s *DescribeVodDomainSrcTrafficDataResponseBody) SetStartTime(v string) *DescribeVodDomainSrcTrafficDataResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeVodDomainSrcTrafficDataResponseBody) SetTotalTraffic(v string) *DescribeVodDomainSrcTrafficDataResponseBody {
	s.TotalTraffic = &v
	return s
}

type DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval struct {
	DataModule []*DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval) SetDataModule(v []*DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule) *DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule struct {
	// The amount of traffic generated by origin HTTPS requests.
	//
	// example:
	//
	// 0
	HttpsValue *string `json:"HttpsValue,omitempty" xml:"HttpsValue,omitempty"`
	// The timestamp of the returned data. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2022-09-23T15:59:59Z
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The traffic value at each time interval.
	//
	// example:
	//
	// 0
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule) SetHttpsValue(v string) *DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule {
	s.HttpsValue = &v
	return s
}

func (s *DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule) SetValue(v string) *DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeVodDomainSrcTrafficDataResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodDomainSrcTrafficDataResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodDomainSrcTrafficDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainSrcTrafficDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainSrcTrafficDataResponse) SetHeaders(v map[string]*string) *DescribeVodDomainSrcTrafficDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodDomainSrcTrafficDataResponse) SetStatusCode(v int32) *DescribeVodDomainSrcTrafficDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodDomainSrcTrafficDataResponse) SetBody(v *DescribeVodDomainSrcTrafficDataResponseBody) *DescribeVodDomainSrcTrafficDataResponse {
	s.Body = v
	return s
}

type DescribeVodDomainTrafficDataRequest struct {
	// The accelerated domain name.
	//
	// 	- If you leave this parameter empty, the merged data of all your accelerated domain names is returned.
	//
	// 	- You can specify multiple domain names and separate them with commas (,). You can specify a maximum of 500 domain names in each call.
	//
	// 	- To obtain the accelerated domain name, perform the following steps: Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Configuration Management > CDN Configuration > Domain Names**. On the Domain Names page, view the accelerated domain names. Alternatively, you can call the [DescribeVodUserDomains](~~DescribeVodUserDomains~~) operation to query the accelerated domain names.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query.
	//
	// Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// >  The end time must be later than the start time.
	//
	// example:
	//
	// 2019-01-20T14:59:58Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time granularity of the query. Unit: seconds. Valid values: **300**, **3600**, and **86400**. If you leave this parameter empty or specify an invalid value, the default value is used. The supported time granularity varies based on the time range specified by `EndTime` and `StartTime`. The following content describes the supported time granularity.
	//
	// 	- Time range per query < 3 days: **300*	- (default), **3600**, and **86400**
	//
	// 	- 3 days ≤ Time range per query < 31 days: **3600*	- (default) and **86400**
	//
	// 	- 31 days ≤ Time range per query ≤ 366 days: **86400*	- (default)
	//
	// example:
	//
	// 300
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The name of the Internet service provider (ISP). If you leave this parameter empty, all ISPs are queried.
	//
	// example:
	//
	// Alibaba
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region. If you leave this parameter empty, all regions are queried. You can specify only the China (Shanghai) region.
	//
	// example:
	//
	// cn-shanghai
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The start of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	//
	// example:
	//
	// 2019-01-20T13:59:58Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainTrafficDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainTrafficDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainTrafficDataRequest) SetDomainName(v string) *DescribeVodDomainTrafficDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainTrafficDataRequest) SetEndTime(v string) *DescribeVodDomainTrafficDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainTrafficDataRequest) SetInterval(v string) *DescribeVodDomainTrafficDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeVodDomainTrafficDataRequest) SetIspNameEn(v string) *DescribeVodDomainTrafficDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeVodDomainTrafficDataRequest) SetLocationNameEn(v string) *DescribeVodDomainTrafficDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeVodDomainTrafficDataRequest) SetOwnerId(v int64) *DescribeVodDomainTrafficDataRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodDomainTrafficDataRequest) SetStartTime(v string) *DescribeVodDomainTrafficDataRequest {
	s.StartTime = &v
	return s
}

type DescribeVodDomainTrafficDataResponseBody struct {
	// The time interval at which data is returned, which is the time granularity. Unit: seconds.
	//
	// example:
	//
	// 3600
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range.
	//
	// example:
	//
	// 2019-01-20T14:59:58Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// D94E471F-1A27-442E-552D-D4D2000C****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range.
	//
	// example:
	//
	// 2019-01-20T13:59:58Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The total amount of network traffic.
	//
	// example:
	//
	// 5906662826
	TotalTraffic *string `json:"TotalTraffic,omitempty" xml:"TotalTraffic,omitempty"`
	// The amount of network traffic at each time interval.
	TrafficDataPerInterval *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerInterval `json:"TrafficDataPerInterval,omitempty" xml:"TrafficDataPerInterval,omitempty" type:"Struct"`
}

func (s DescribeVodDomainTrafficDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainTrafficDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainTrafficDataResponseBody) SetDataInterval(v string) *DescribeVodDomainTrafficDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeVodDomainTrafficDataResponseBody) SetDomainName(v string) *DescribeVodDomainTrafficDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainTrafficDataResponseBody) SetEndTime(v string) *DescribeVodDomainTrafficDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainTrafficDataResponseBody) SetRequestId(v string) *DescribeVodDomainTrafficDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVodDomainTrafficDataResponseBody) SetStartTime(v string) *DescribeVodDomainTrafficDataResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeVodDomainTrafficDataResponseBody) SetTotalTraffic(v string) *DescribeVodDomainTrafficDataResponseBody {
	s.TotalTraffic = &v
	return s
}

func (s *DescribeVodDomainTrafficDataResponseBody) SetTrafficDataPerInterval(v *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerInterval) *DescribeVodDomainTrafficDataResponseBody {
	s.TrafficDataPerInterval = v
	return s
}

type DescribeVodDomainTrafficDataResponseBodyTrafficDataPerInterval struct {
	DataModule []*DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainTrafficDataResponseBodyTrafficDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainTrafficDataResponseBodyTrafficDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerInterval) SetDataModule(v []*DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule struct {
	// The amount of network traffic in the Chinese mainland. Unit: bytes.
	//
	// example:
	//
	// 0
	DomesticValue *string `json:"DomesticValue,omitempty" xml:"DomesticValue,omitempty"`
	// The amount of HTTPS network traffic on points of presence (POPs) in the Chinese mainland. Unit: bytes.
	//
	// example:
	//
	// 0
	HttpsDomesticValue *string `json:"HttpsDomesticValue,omitempty" xml:"HttpsDomesticValue,omitempty"`
	// The amount of HTTPS network traffic on POPs outside the Chinese mainland. Unit: bytes.
	//
	// example:
	//
	// 0
	HttpsOverseasValue *string `json:"HttpsOverseasValue,omitempty" xml:"HttpsOverseasValue,omitempty"`
	// The total amount of HTTPS network traffic on POPs. Unit: bytes.
	//
	// example:
	//
	// 0
	HttpsValue *string `json:"HttpsValue,omitempty" xml:"HttpsValue,omitempty"`
	// The amount of network traffic outside the Chinese mainland. Unit: bytes.
	//
	// example:
	//
	// 0
	OverseasValue *string `json:"OverseasValue,omitempty" xml:"OverseasValue,omitempty"`
	// The timestamp of the data returned. The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mm:ssZ format. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-01-15T19:00:00Z
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The total traffic. Unit: bytes.
	//
	// example:
	//
	// 0
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetDomesticValue(v string) *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.DomesticValue = &v
	return s
}

func (s *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetHttpsDomesticValue(v string) *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.HttpsDomesticValue = &v
	return s
}

func (s *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetHttpsOverseasValue(v string) *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.HttpsOverseasValue = &v
	return s
}

func (s *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetHttpsValue(v string) *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.HttpsValue = &v
	return s
}

func (s *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetOverseasValue(v string) *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.OverseasValue = &v
	return s
}

func (s *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetValue(v string) *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeVodDomainTrafficDataResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodDomainTrafficDataResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodDomainTrafficDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainTrafficDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainTrafficDataResponse) SetHeaders(v map[string]*string) *DescribeVodDomainTrafficDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodDomainTrafficDataResponse) SetStatusCode(v int32) *DescribeVodDomainTrafficDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodDomainTrafficDataResponse) SetBody(v *DescribeVodDomainTrafficDataResponseBody) *DescribeVodDomainTrafficDataResponse {
	s.Body = v
	return s
}

type DescribeVodDomainUsageDataRequest struct {
	// The region in which you want to query data. Valid values:
	//
	// 	- **CN**: Chinese mainland
	//
	// 	- **OverSeas**: outside the Chinese mainland
	//
	// example:
	//
	// CN
	Area *string `json:"Area,omitempty" xml:"Area,omitempty"`
	// The accelerated domain name. If you leave this parameter empty, the merged data of all your accelerated domain names is returned. Separate multiple accelerated domain names with commas (,).
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// This parameter is required.
	//
	// example:
	//
	// 2015-12-10T12:20:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The type of the data to return. Valid values:
	//
	// 	- **bps**: bandwidth
	//
	// 	- **traf**: traffic
	//
	// This parameter is required.
	//
	// example:
	//
	// bps
	Field *string `json:"Field,omitempty" xml:"Field,omitempty"`
	// The time interval between the data entries to return. Unit: seconds. Valid values: **300*	- (5 minutes), **3600*	- (1 hour), and **86400*	- (1 day).
	//
	// 	- If **Interval*	- is set to **300**, you can query usage data in the last six months. The maximum time range per query that can be specified is three days.
	//
	// 	- If **Interval*	- is set to **3600*	- or **86400**, you can query usage data of the previous year.
	//
	// 	- If you do not set the **Interval*	- parameter, the maximum time range that you can query is one month. If you specify a time range of 1 to 3 days, the time interval between the entries that are returned is 1 hour. If you specify a time range of at least 4 days, the time interval between the entries that are returned is 1 day.
	//
	// example:
	//
	// 300
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	OwnerId  *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// This parameter is required.
	//
	// example:
	//
	// 2015-12-10T10:20:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The type of content that you want to query. Valid values:
	//
	// 	- **static**: static content
	//
	// 	- **dynamic**: dynamic requests
	//
	// 	- **all**: all content
	//
	// example:
	//
	// static
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeVodDomainUsageDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainUsageDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainUsageDataRequest) SetArea(v string) *DescribeVodDomainUsageDataRequest {
	s.Area = &v
	return s
}

func (s *DescribeVodDomainUsageDataRequest) SetDomainName(v string) *DescribeVodDomainUsageDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainUsageDataRequest) SetEndTime(v string) *DescribeVodDomainUsageDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainUsageDataRequest) SetField(v string) *DescribeVodDomainUsageDataRequest {
	s.Field = &v
	return s
}

func (s *DescribeVodDomainUsageDataRequest) SetInterval(v string) *DescribeVodDomainUsageDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeVodDomainUsageDataRequest) SetOwnerId(v int64) *DescribeVodDomainUsageDataRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodDomainUsageDataRequest) SetStartTime(v string) *DescribeVodDomainUsageDataRequest {
	s.StartTime = &v
	return s
}

func (s *DescribeVodDomainUsageDataRequest) SetType(v string) *DescribeVodDomainUsageDataRequest {
	s.Type = &v
	return s
}

type DescribeVodDomainUsageDataResponseBody struct {
	// The billable region where the data was collected.
	//
	// example:
	//
	// CN
	Area *string `json:"Area,omitempty" xml:"Area,omitempty"`
	// The time interval between the entries returned. Unit: seconds.
	//
	// example:
	//
	// 300
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2015-12-10T12:20:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// B955107D-E658-4E77-****-E0AC3D31693E
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2015-12-10T10:20:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The type of the data. Valid values:
	//
	// 	- **bps**: bandwidth
	//
	// 	- **traf**: traffic
	//
	// example:
	//
	// static
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The traffic or bandwidth data returned at each interval.
	UsageDataPerInterval *DescribeVodDomainUsageDataResponseBodyUsageDataPerInterval `json:"UsageDataPerInterval,omitempty" xml:"UsageDataPerInterval,omitempty" type:"Struct"`
}

func (s DescribeVodDomainUsageDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainUsageDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainUsageDataResponseBody) SetArea(v string) *DescribeVodDomainUsageDataResponseBody {
	s.Area = &v
	return s
}

func (s *DescribeVodDomainUsageDataResponseBody) SetDataInterval(v string) *DescribeVodDomainUsageDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeVodDomainUsageDataResponseBody) SetDomainName(v string) *DescribeVodDomainUsageDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainUsageDataResponseBody) SetEndTime(v string) *DescribeVodDomainUsageDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainUsageDataResponseBody) SetRequestId(v string) *DescribeVodDomainUsageDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVodDomainUsageDataResponseBody) SetStartTime(v string) *DescribeVodDomainUsageDataResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeVodDomainUsageDataResponseBody) SetType(v string) *DescribeVodDomainUsageDataResponseBody {
	s.Type = &v
	return s
}

func (s *DescribeVodDomainUsageDataResponseBody) SetUsageDataPerInterval(v *DescribeVodDomainUsageDataResponseBodyUsageDataPerInterval) *DescribeVodDomainUsageDataResponseBody {
	s.UsageDataPerInterval = v
	return s
}

type DescribeVodDomainUsageDataResponseBodyUsageDataPerInterval struct {
	DataModule []*DescribeVodDomainUsageDataResponseBodyUsageDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainUsageDataResponseBodyUsageDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainUsageDataResponseBodyUsageDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainUsageDataResponseBodyUsageDataPerInterval) SetDataModule(v []*DescribeVodDomainUsageDataResponseBodyUsageDataPerIntervalDataModule) *DescribeVodDomainUsageDataResponseBodyUsageDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeVodDomainUsageDataResponseBodyUsageDataPerIntervalDataModule struct {
	// The timestamp of the returned data. The time is in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2015-12-10T10:00:00Z
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The traffic or bandwidth data. Unit: bit/s.
	//
	// example:
	//
	// 2592.3920000000003
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVodDomainUsageDataResponseBodyUsageDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainUsageDataResponseBodyUsageDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainUsageDataResponseBodyUsageDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeVodDomainUsageDataResponseBodyUsageDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeVodDomainUsageDataResponseBodyUsageDataPerIntervalDataModule) SetValue(v string) *DescribeVodDomainUsageDataResponseBodyUsageDataPerIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeVodDomainUsageDataResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodDomainUsageDataResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodDomainUsageDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainUsageDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainUsageDataResponse) SetHeaders(v map[string]*string) *DescribeVodDomainUsageDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodDomainUsageDataResponse) SetStatusCode(v int32) *DescribeVodDomainUsageDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodDomainUsageDataResponse) SetBody(v *DescribeVodDomainUsageDataResponseBody) *DescribeVodDomainUsageDataResponse {
	s.Body = v
	return s
}

type DescribeVodEditingUsageDataRequest struct {
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// example:
	//
	// 2024-11-07T16:00:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// example:
	//
	// cn-beijing
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// example:
	//
	// H264.SD
	Specification *string `json:"Specification,omitempty" xml:"Specification,omitempty"`
	// example:
	//
	// 2024-11-06T16:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodEditingUsageDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodEditingUsageDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodEditingUsageDataRequest) SetAppId(v string) *DescribeVodEditingUsageDataRequest {
	s.AppId = &v
	return s
}

func (s *DescribeVodEditingUsageDataRequest) SetEndTime(v string) *DescribeVodEditingUsageDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodEditingUsageDataRequest) SetOwnerId(v int64) *DescribeVodEditingUsageDataRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodEditingUsageDataRequest) SetRegion(v string) *DescribeVodEditingUsageDataRequest {
	s.Region = &v
	return s
}

func (s *DescribeVodEditingUsageDataRequest) SetSpecification(v string) *DescribeVodEditingUsageDataRequest {
	s.Specification = &v
	return s
}

func (s *DescribeVodEditingUsageDataRequest) SetStartTime(v string) *DescribeVodEditingUsageDataRequest {
	s.StartTime = &v
	return s
}

type DescribeVodEditingUsageDataResponseBody struct {
	EditingData []*DescribeVodEditingUsageDataResponseBodyEditingData `json:"EditingData,omitempty" xml:"EditingData,omitempty" type:"Repeated"`
	// example:
	//
	// 2024-11-07T16:00:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// example:
	//
	// 6CB55B62-6E5F-54D1-80BF-DFA3DE9F0***
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// example:
	//
	// 2024-11-06T16:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodEditingUsageDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodEditingUsageDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodEditingUsageDataResponseBody) SetEditingData(v []*DescribeVodEditingUsageDataResponseBodyEditingData) *DescribeVodEditingUsageDataResponseBody {
	s.EditingData = v
	return s
}

func (s *DescribeVodEditingUsageDataResponseBody) SetEndTime(v string) *DescribeVodEditingUsageDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeVodEditingUsageDataResponseBody) SetRequestId(v string) *DescribeVodEditingUsageDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVodEditingUsageDataResponseBody) SetStartTime(v string) *DescribeVodEditingUsageDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeVodEditingUsageDataResponseBodyEditingData struct {
	// example:
	//
	// 123
	Duration *int64 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// example:
	//
	// cn-beijing
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// example:
	//
	// H264.SD
	Specification *string `json:"Specification,omitempty" xml:"Specification,omitempty"`
	// example:
	//
	// 2024-11-06T16:00:00Z
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeVodEditingUsageDataResponseBodyEditingData) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodEditingUsageDataResponseBodyEditingData) GoString() string {
	return s.String()
}

func (s *DescribeVodEditingUsageDataResponseBodyEditingData) SetDuration(v int64) *DescribeVodEditingUsageDataResponseBodyEditingData {
	s.Duration = &v
	return s
}

func (s *DescribeVodEditingUsageDataResponseBodyEditingData) SetRegion(v string) *DescribeVodEditingUsageDataResponseBodyEditingData {
	s.Region = &v
	return s
}

func (s *DescribeVodEditingUsageDataResponseBodyEditingData) SetSpecification(v string) *DescribeVodEditingUsageDataResponseBodyEditingData {
	s.Specification = &v
	return s
}

func (s *DescribeVodEditingUsageDataResponseBodyEditingData) SetTimeStamp(v string) *DescribeVodEditingUsageDataResponseBodyEditingData {
	s.TimeStamp = &v
	return s
}

type DescribeVodEditingUsageDataResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodEditingUsageDataResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodEditingUsageDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodEditingUsageDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodEditingUsageDataResponse) SetHeaders(v map[string]*string) *DescribeVodEditingUsageDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodEditingUsageDataResponse) SetStatusCode(v int32) *DescribeVodEditingUsageDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodEditingUsageDataResponse) SetBody(v *DescribeVodEditingUsageDataResponseBody) *DescribeVodEditingUsageDataResponse {
	s.Body = v
	return s
}

type DescribeVodMediaPlayDataRequest struct {
	// The ID of the media file (VideoId). You can specify this parameter to query all playback data of a media file. You can specify only one media ID. You can use one of the following methods to obtain the ID:
	//
	// 	- Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Media Files*	- > **Audio/Video**. On the page that appears, view the media ID.
	//
	// 	- Obtain the value of the VideoId parameter in the response to the [CreateUploadVideo](~~CreateUploadVideo~~) operation that you called to upload the audio or video file.
	//
	// 	- Obtain the value of VideoId by calling the [SearchMedia](~~SearchMedia~~) operation. This method is applicable to files that have been uploaded.
	//
	// example:
	//
	// 9ae2af636ca6c10412f44891fc****
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The name of the metric. This parameter must be specified together with the `OrderType` parameter. You can specify this parameter to sort the returned data in ascending or descending order based on specific metrics. Valid values:
	//
	// 	- **PlaySuccessVv**: the total number of views.
	//
	// 	- **PlayPerVv**: the average views per viewer.
	//
	// 	- **PlayDuration**: the total playback duration.
	//
	// 	- **PlayDurationPerUv**: the average playback duration per viewer.
	//
	// example:
	//
	// PlaySuccessVv
	OrderName *string `json:"OrderName,omitempty" xml:"OrderName,omitempty"`
	// The sort type. This parameter must be specified together with the `OrderName` parameter. You can specify this parameter to sort the returned data in ascending or descending order based on specific metrics. Valid values:
	//
	// 	- **ASC**: The returned data is sorted in ascending order.
	//
	// 	- **DESC**: The returned data is sorted in descending order.
	//
	// example:
	//
	// ASC
	OrderType *string `json:"OrderType,omitempty" xml:"OrderType,omitempty"`
	// The operating system of the player. You can specify this parameter to query all playback data generated on a specific operating system. Valid values:
	//
	// 	- **Android**
	//
	// 	- **iOS**
	//
	// 	- **Windows**
	//
	// 	- **macOS**
	//
	// 	- **Linux**
	//
	// example:
	//
	// Android
	Os *string `json:"Os,omitempty" xml:"Os,omitempty"`
	// The number of the page. You can specify a page number to return data from the specified page.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1
	PageNo *int64 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The number of entries per page. Maximum value: 100.
	//
	// This parameter is required.
	//
	// example:
	//
	// 20
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The playback time. Specify the value in the yyyyMMdd format.
	//
	// > 	- You can query data only by day.
	//
	// > 	- You can query only data within the last 30 days.
	//
	// example:
	//
	// 20240322
	PlayDate *string `json:"PlayDate,omitempty" xml:"PlayDate,omitempty"`
	// The region in which ApsaraVideo VOD is activated. You can specify this parameter to query all playback data generated only in a specific region. Valid values:
	//
	// 	- **cn-beijing**: China (Beijing)
	//
	// 	- **cn-shanghai**: China (Shanghai)
	//
	// 	- **cn-shenzhen**: China (Shenzhen)
	//
	// 	- **ap-northeast-1**: Japan (Tokyo)
	//
	// 	- **ap-southeast-1**: Singapore
	//
	// 	- **ap-southeast-5**: Indonesia (Jakarta)
	//
	// 	- **eu-central-1**: Germany (Frankfurt)
	//
	// example:
	//
	// cn-beijing
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The type of the player SDK. You can specify this parameter to query all playback data generated by using a specific type of player SDK. Valid values:
	//
	// 	- **Native**: ApsaraVideo Player SDK for Android or ApsaraVideo Player SDK for iOS
	//
	// 	- **Web**: ApsaraVideo Player SDK for Web
	//
	// example:
	//
	// Native
	TerminalType *string `json:"TerminalType,omitempty" xml:"TerminalType,omitempty"`
}

func (s DescribeVodMediaPlayDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodMediaPlayDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodMediaPlayDataRequest) SetMediaId(v string) *DescribeVodMediaPlayDataRequest {
	s.MediaId = &v
	return s
}

func (s *DescribeVodMediaPlayDataRequest) SetOrderName(v string) *DescribeVodMediaPlayDataRequest {
	s.OrderName = &v
	return s
}

func (s *DescribeVodMediaPlayDataRequest) SetOrderType(v string) *DescribeVodMediaPlayDataRequest {
	s.OrderType = &v
	return s
}

func (s *DescribeVodMediaPlayDataRequest) SetOs(v string) *DescribeVodMediaPlayDataRequest {
	s.Os = &v
	return s
}

func (s *DescribeVodMediaPlayDataRequest) SetPageNo(v int64) *DescribeVodMediaPlayDataRequest {
	s.PageNo = &v
	return s
}

func (s *DescribeVodMediaPlayDataRequest) SetPageSize(v int64) *DescribeVodMediaPlayDataRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeVodMediaPlayDataRequest) SetPlayDate(v string) *DescribeVodMediaPlayDataRequest {
	s.PlayDate = &v
	return s
}

func (s *DescribeVodMediaPlayDataRequest) SetRegion(v string) *DescribeVodMediaPlayDataRequest {
	s.Region = &v
	return s
}

func (s *DescribeVodMediaPlayDataRequest) SetTerminalType(v string) *DescribeVodMediaPlayDataRequest {
	s.TerminalType = &v
	return s
}

type DescribeVodMediaPlayDataResponseBody struct {
	// The page number.
	//
	// example:
	//
	// 1
	PageNo *int64 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The number of entries per page.
	//
	// example:
	//
	// 20
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The data returned.
	QoeInfoList []*DescribeVodMediaPlayDataResponseBodyQoeInfoList `json:"QoeInfoList,omitempty" xml:"QoeInfoList,omitempty" type:"Repeated"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4AF6-D7393642CA58****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	//
	// example:
	//
	// 1
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeVodMediaPlayDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodMediaPlayDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodMediaPlayDataResponseBody) SetPageNo(v int64) *DescribeVodMediaPlayDataResponseBody {
	s.PageNo = &v
	return s
}

func (s *DescribeVodMediaPlayDataResponseBody) SetPageSize(v int64) *DescribeVodMediaPlayDataResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeVodMediaPlayDataResponseBody) SetQoeInfoList(v []*DescribeVodMediaPlayDataResponseBodyQoeInfoList) *DescribeVodMediaPlayDataResponseBody {
	s.QoeInfoList = v
	return s
}

func (s *DescribeVodMediaPlayDataResponseBody) SetRequestId(v string) *DescribeVodMediaPlayDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVodMediaPlayDataResponseBody) SetTotalCount(v int64) *DescribeVodMediaPlayDataResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeVodMediaPlayDataResponseBodyQoeInfoList struct {
	// The number of visits to the audio or video per day.
	//
	// example:
	//
	// 5
	DAU *float32 `json:"DAU,omitempty" xml:"DAU,omitempty"`
	// The ID of the media file (VideoId).
	//
	// example:
	//
	// 9ae2af636ca6c10412f44891fc****
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The total playback duration of the audio or video. Unit: seconds.
	//
	// example:
	//
	// 2400
	PlayDuration *float32 `json:"PlayDuration,omitempty" xml:"PlayDuration,omitempty"`
	// The average playback duration of the audio or video per viewer. Unit: seconds.
	//
	// example:
	//
	// 120
	PlayDurationPerUv *float32 `json:"PlayDurationPerUv,omitempty" xml:"PlayDurationPerUv,omitempty"`
	// The average number of times that the audio or video was played per viewer.
	//
	// example:
	//
	// 4
	PlayPerVv *float32 `json:"PlayPerVv,omitempty" xml:"PlayPerVv,omitempty"`
	// The total number of times the audio or video has been played.
	//
	// example:
	//
	// 20
	PlaySuccessVv *float32 `json:"PlaySuccessVv,omitempty" xml:"PlaySuccessVv,omitempty"`
	// The duration of the audio or video file. Unit: seconds.
	//
	// example:
	//
	// 246
	VideoDuration *float32 `json:"VideoDuration,omitempty" xml:"VideoDuration,omitempty"`
	// The name of the audio or video file.
	//
	// example:
	//
	// title
	VideoTitle *string `json:"VideoTitle,omitempty" xml:"VideoTitle,omitempty"`
}

func (s DescribeVodMediaPlayDataResponseBodyQoeInfoList) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodMediaPlayDataResponseBodyQoeInfoList) GoString() string {
	return s.String()
}

func (s *DescribeVodMediaPlayDataResponseBodyQoeInfoList) SetDAU(v float32) *DescribeVodMediaPlayDataResponseBodyQoeInfoList {
	s.DAU = &v
	return s
}

func (s *DescribeVodMediaPlayDataResponseBodyQoeInfoList) SetMediaId(v string) *DescribeVodMediaPlayDataResponseBodyQoeInfoList {
	s.MediaId = &v
	return s
}

func (s *DescribeVodMediaPlayDataResponseBodyQoeInfoList) SetPlayDuration(v float32) *DescribeVodMediaPlayDataResponseBodyQoeInfoList {
	s.PlayDuration = &v
	return s
}

func (s *DescribeVodMediaPlayDataResponseBodyQoeInfoList) SetPlayDurationPerUv(v float32) *DescribeVodMediaPlayDataResponseBodyQoeInfoList {
	s.PlayDurationPerUv = &v
	return s
}

func (s *DescribeVodMediaPlayDataResponseBodyQoeInfoList) SetPlayPerVv(v float32) *DescribeVodMediaPlayDataResponseBodyQoeInfoList {
	s.PlayPerVv = &v
	return s
}

func (s *DescribeVodMediaPlayDataResponseBodyQoeInfoList) SetPlaySuccessVv(v float32) *DescribeVodMediaPlayDataResponseBodyQoeInfoList {
	s.PlaySuccessVv = &v
	return s
}

func (s *DescribeVodMediaPlayDataResponseBodyQoeInfoList) SetVideoDuration(v float32) *DescribeVodMediaPlayDataResponseBodyQoeInfoList {
	s.VideoDuration = &v
	return s
}

func (s *DescribeVodMediaPlayDataResponseBodyQoeInfoList) SetVideoTitle(v string) *DescribeVodMediaPlayDataResponseBodyQoeInfoList {
	s.VideoTitle = &v
	return s
}

type DescribeVodMediaPlayDataResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodMediaPlayDataResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodMediaPlayDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodMediaPlayDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodMediaPlayDataResponse) SetHeaders(v map[string]*string) *DescribeVodMediaPlayDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodMediaPlayDataResponse) SetStatusCode(v int32) *DescribeVodMediaPlayDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodMediaPlayDataResponse) SetBody(v *DescribeVodMediaPlayDataResponseBody) *DescribeVodMediaPlayDataResponse {
	s.Body = v
	return s
}

type DescribeVodRangeDataByLocateAndIspServiceRequest struct {
	// The accelerated domain name.
	//
	// This parameter is required.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// This parameter is required.
	//
	// example:
	//
	// 2023-05-29T03:55:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The name of the ISP. If you leave this parameter empty, all ISPs are queried.
	//
	// example:
	//
	// unicom
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region. If you leave this parameter empty, data in all regions is queried.
	//
	// example:
	//
	// beijing
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// This parameter is required.
	//
	// example:
	//
	// 2023-05-29T03:50:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodRangeDataByLocateAndIspServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodRangeDataByLocateAndIspServiceRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodRangeDataByLocateAndIspServiceRequest) SetDomainName(v string) *DescribeVodRangeDataByLocateAndIspServiceRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodRangeDataByLocateAndIspServiceRequest) SetEndTime(v string) *DescribeVodRangeDataByLocateAndIspServiceRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodRangeDataByLocateAndIspServiceRequest) SetIspNameEn(v string) *DescribeVodRangeDataByLocateAndIspServiceRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeVodRangeDataByLocateAndIspServiceRequest) SetLocationNameEn(v string) *DescribeVodRangeDataByLocateAndIspServiceRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeVodRangeDataByLocateAndIspServiceRequest) SetOwnerId(v int64) *DescribeVodRangeDataByLocateAndIspServiceRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodRangeDataByLocateAndIspServiceRequest) SetStartTime(v string) *DescribeVodRangeDataByLocateAndIspServiceRequest {
	s.StartTime = &v
	return s
}

type DescribeVodRangeDataByLocateAndIspServiceResponseBody struct {
	// The returned result. The value is in the JSON format. These parameters indicate the following information in sequence: UNIX time, region, ISP, distribution of HTTP status codes, response time, bandwidth (bit/s), average response rate, page views, cache hit ratio, and request hit ratio.
	//
	// example:
	//
	// {"1472659200":{"tianjin":{"unicom":{"http_codes":{"000":0,"200":6,"400":0},"rt":4183,"bandwidth":46639,"avg_speed":7773,"pv":6,"hit_rate":0.93,"request_hit_rate":0.66}}}}
	JsonResult *string `json:"JsonResult,omitempty" xml:"JsonResult,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// C74802AA-C277-5A80-BDF2-072B05F119C7
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeVodRangeDataByLocateAndIspServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodRangeDataByLocateAndIspServiceResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodRangeDataByLocateAndIspServiceResponseBody) SetJsonResult(v string) *DescribeVodRangeDataByLocateAndIspServiceResponseBody {
	s.JsonResult = &v
	return s
}

func (s *DescribeVodRangeDataByLocateAndIspServiceResponseBody) SetRequestId(v string) *DescribeVodRangeDataByLocateAndIspServiceResponseBody {
	s.RequestId = &v
	return s
}

type DescribeVodRangeDataByLocateAndIspServiceResponse struct {
	Headers    map[string]*string                                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodRangeDataByLocateAndIspServiceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodRangeDataByLocateAndIspServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodRangeDataByLocateAndIspServiceResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodRangeDataByLocateAndIspServiceResponse) SetHeaders(v map[string]*string) *DescribeVodRangeDataByLocateAndIspServiceResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodRangeDataByLocateAndIspServiceResponse) SetStatusCode(v int32) *DescribeVodRangeDataByLocateAndIspServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodRangeDataByLocateAndIspServiceResponse) SetBody(v *DescribeVodRangeDataByLocateAndIspServiceResponseBody) *DescribeVodRangeDataByLocateAndIspServiceResponse {
	s.Body = v
	return s
}

type DescribeVodRefreshQuotaRequest struct {
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeVodRefreshQuotaRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodRefreshQuotaRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodRefreshQuotaRequest) SetOwnerId(v int64) *DescribeVodRefreshQuotaRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodRefreshQuotaRequest) SetSecurityToken(v string) *DescribeVodRefreshQuotaRequest {
	s.SecurityToken = &v
	return s
}

type DescribeVodRefreshQuotaResponseBody struct {
	// The maximum number of Object Storage Service (OSS) buckets that can be refreshed each day.
	//
	// example:
	//
	// 500
	BlockQuota *string `json:"BlockQuota,omitempty" xml:"BlockQuota,omitempty"`
	// The maximum number of directories of files that can be refreshed each day.
	//
	// example:
	//
	// 100
	DirQuota *string `json:"DirQuota,omitempty" xml:"DirQuota,omitempty"`
	// The remaining number of directories of files that can be refreshed on the current day.
	//
	// example:
	//
	// 99
	DirRemain *string `json:"DirRemain,omitempty" xml:"DirRemain,omitempty"`
	// The maximum number of URLs of files that can be prefetched each day.
	//
	// example:
	//
	// 500
	PreloadQuota *string `json:"PreloadQuota,omitempty" xml:"PreloadQuota,omitempty"`
	// The remaining number of URLs of files that can be prefetched on the current day.
	//
	// example:
	//
	// 500
	PreloadRemain *string `json:"PreloadRemain,omitempty" xml:"PreloadRemain,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// 42E0554B-80F4-4921-****-ACFB22CAAAD0
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The maximum number of URLs of files that can be refreshed each day.
	//
	// example:
	//
	// 2000
	UrlQuota *string `json:"UrlQuota,omitempty" xml:"UrlQuota,omitempty"`
	// The remaining number of URLs of files that can be refreshed on the current day.
	//
	// example:
	//
	// 1996
	UrlRemain *string `json:"UrlRemain,omitempty" xml:"UrlRemain,omitempty"`
	// The remaining number of OSS buckets that can be refreshed on the current day.
	//
	// example:
	//
	// 500
	BlockRemain *string `json:"blockRemain,omitempty" xml:"blockRemain,omitempty"`
}

func (s DescribeVodRefreshQuotaResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodRefreshQuotaResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodRefreshQuotaResponseBody) SetBlockQuota(v string) *DescribeVodRefreshQuotaResponseBody {
	s.BlockQuota = &v
	return s
}

func (s *DescribeVodRefreshQuotaResponseBody) SetDirQuota(v string) *DescribeVodRefreshQuotaResponseBody {
	s.DirQuota = &v
	return s
}

func (s *DescribeVodRefreshQuotaResponseBody) SetDirRemain(v string) *DescribeVodRefreshQuotaResponseBody {
	s.DirRemain = &v
	return s
}

func (s *DescribeVodRefreshQuotaResponseBody) SetPreloadQuota(v string) *DescribeVodRefreshQuotaResponseBody {
	s.PreloadQuota = &v
	return s
}

func (s *DescribeVodRefreshQuotaResponseBody) SetPreloadRemain(v string) *DescribeVodRefreshQuotaResponseBody {
	s.PreloadRemain = &v
	return s
}

func (s *DescribeVodRefreshQuotaResponseBody) SetRequestId(v string) *DescribeVodRefreshQuotaResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVodRefreshQuotaResponseBody) SetUrlQuota(v string) *DescribeVodRefreshQuotaResponseBody {
	s.UrlQuota = &v
	return s
}

func (s *DescribeVodRefreshQuotaResponseBody) SetUrlRemain(v string) *DescribeVodRefreshQuotaResponseBody {
	s.UrlRemain = &v
	return s
}

func (s *DescribeVodRefreshQuotaResponseBody) SetBlockRemain(v string) *DescribeVodRefreshQuotaResponseBody {
	s.BlockRemain = &v
	return s
}

type DescribeVodRefreshQuotaResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodRefreshQuotaResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodRefreshQuotaResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodRefreshQuotaResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodRefreshQuotaResponse) SetHeaders(v map[string]*string) *DescribeVodRefreshQuotaResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodRefreshQuotaResponse) SetStatusCode(v int32) *DescribeVodRefreshQuotaResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodRefreshQuotaResponse) SetBody(v *DescribeVodRefreshQuotaResponseBody) *DescribeVodRefreshQuotaResponse {
	s.Body = v
	return s
}

type DescribeVodRefreshTasksRequest struct {
	// The domain name.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// example:
	//
	// 2017-01-01T12:30:20Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The path of the object. The path is used as a condition for exact matching.
	//
	// example:
	//
	// http://example.com/***.txt
	ObjectPath *string `json:"ObjectPath,omitempty" xml:"ObjectPath,omitempty"`
	// The type of the task. Valid values:
	//
	// 	- **file**: refreshes one or more files.
	//
	// 	- **directory**: refreshes files in the specified directories.
	//
	// 	- **preload**: prefetches one or more files.
	//
	// > If you specify the DomainName or Status parameter, you must also specify the ObjectType parameter.
	//
	// example:
	//
	// file
	ObjectType *string `json:"ObjectType,omitempty" xml:"ObjectType,omitempty"`
	OwnerId    *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The page number.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: **20**. Maximum value: **50**.
	//
	// example:
	//
	// 20
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// > You can query data that is collected in the last three days.
	//
	// example:
	//
	// 2017-01-01T12:12:20Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The status of the task. Valid values:
	//
	// 	- **Complete**: The task is complete.
	//
	// 	- **Refreshing**: The task is in progress.
	//
	// 	- **Failed**: The task failed.
	//
	// example:
	//
	// Complete
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the task that you want to query.
	//
	// example:
	//
	// 70422****
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s DescribeVodRefreshTasksRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodRefreshTasksRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodRefreshTasksRequest) SetDomainName(v string) *DescribeVodRefreshTasksRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodRefreshTasksRequest) SetEndTime(v string) *DescribeVodRefreshTasksRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodRefreshTasksRequest) SetObjectPath(v string) *DescribeVodRefreshTasksRequest {
	s.ObjectPath = &v
	return s
}

func (s *DescribeVodRefreshTasksRequest) SetObjectType(v string) *DescribeVodRefreshTasksRequest {
	s.ObjectType = &v
	return s
}

func (s *DescribeVodRefreshTasksRequest) SetOwnerId(v int64) *DescribeVodRefreshTasksRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodRefreshTasksRequest) SetPageNumber(v int32) *DescribeVodRefreshTasksRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeVodRefreshTasksRequest) SetPageSize(v int32) *DescribeVodRefreshTasksRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeVodRefreshTasksRequest) SetSecurityToken(v string) *DescribeVodRefreshTasksRequest {
	s.SecurityToken = &v
	return s
}

func (s *DescribeVodRefreshTasksRequest) SetStartTime(v string) *DescribeVodRefreshTasksRequest {
	s.StartTime = &v
	return s
}

func (s *DescribeVodRefreshTasksRequest) SetStatus(v string) *DescribeVodRefreshTasksRequest {
	s.Status = &v
	return s
}

func (s *DescribeVodRefreshTasksRequest) SetTaskId(v string) *DescribeVodRefreshTasksRequest {
	s.TaskId = &v
	return s
}

type DescribeVodRefreshTasksResponseBody struct {
	// The page number of the returned page.
	//
	// example:
	//
	// 1
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	//
	// example:
	//
	// 10
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// 174F6032-AA26-470D-****-36F0EB205BEE
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the returned tasks.
	Tasks *DescribeVodRefreshTasksResponseBodyTasks `json:"Tasks,omitempty" xml:"Tasks,omitempty" type:"Struct"`
	// The total number of entries returned.
	//
	// example:
	//
	// 2
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeVodRefreshTasksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodRefreshTasksResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodRefreshTasksResponseBody) SetPageNumber(v int64) *DescribeVodRefreshTasksResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeVodRefreshTasksResponseBody) SetPageSize(v int64) *DescribeVodRefreshTasksResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeVodRefreshTasksResponseBody) SetRequestId(v string) *DescribeVodRefreshTasksResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVodRefreshTasksResponseBody) SetTasks(v *DescribeVodRefreshTasksResponseBodyTasks) *DescribeVodRefreshTasksResponseBody {
	s.Tasks = v
	return s
}

func (s *DescribeVodRefreshTasksResponseBody) SetTotalCount(v int64) *DescribeVodRefreshTasksResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeVodRefreshTasksResponseBodyTasks struct {
	Task []*DescribeVodRefreshTasksResponseBodyTasksTask `json:"Task,omitempty" xml:"Task,omitempty" type:"Repeated"`
}

func (s DescribeVodRefreshTasksResponseBodyTasks) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodRefreshTasksResponseBodyTasks) GoString() string {
	return s.String()
}

func (s *DescribeVodRefreshTasksResponseBodyTasks) SetTask(v []*DescribeVodRefreshTasksResponseBodyTasksTask) *DescribeVodRefreshTasksResponseBodyTasks {
	s.Task = v
	return s
}

type DescribeVodRefreshTasksResponseBodyTasksTask struct {
	// The time when the task was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2014-11-27T08:23:22Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The type of error returned when the refresh or prefetch task failed. Valid values: Valid values:
	//
	// 	- **Internal Error**: An internal error occurred.
	//
	// 	- **Origin Timeout**: The response from the origin server timed out.
	//
	// 	- **Origin Return StatusCode 5XX**: The origin server returned an HTTP status code 5xx.
	//
	// example:
	//
	// Internal Error
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The URL of the object refreshed.
	//
	// example:
	//
	// http://example.com/****.txt
	ObjectPath *string `json:"ObjectPath,omitempty" xml:"ObjectPath,omitempty"`
	// The type of the task. Default value: file. Valid values:
	//
	// 	- **file**: refreshes one or more files.
	//
	// 	- **directory**: refreshes files in the specified directory.
	//
	// 	- **preload**: prefetches one or more files.
	//
	// example:
	//
	// file
	ObjectType *string `json:"ObjectType,omitempty" xml:"ObjectType,omitempty"`
	// The progress of the task in percentage.
	//
	// example:
	//
	// 100%
	Process *string `json:"Process,omitempty" xml:"Process,omitempty"`
	// The status of the task. Valid values:
	//
	// 	- **Complete**: The task is complete.
	//
	// 	- **Refreshing**: The task is in progress.
	//
	// 	- **Failed**: The task failed.
	//
	// 	- **Pending**: The task is pending.
	//
	// example:
	//
	// Complete
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the task.
	//
	// example:
	//
	// 704225667
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s DescribeVodRefreshTasksResponseBodyTasksTask) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodRefreshTasksResponseBodyTasksTask) GoString() string {
	return s.String()
}

func (s *DescribeVodRefreshTasksResponseBodyTasksTask) SetCreationTime(v string) *DescribeVodRefreshTasksResponseBodyTasksTask {
	s.CreationTime = &v
	return s
}

func (s *DescribeVodRefreshTasksResponseBodyTasksTask) SetDescription(v string) *DescribeVodRefreshTasksResponseBodyTasksTask {
	s.Description = &v
	return s
}

func (s *DescribeVodRefreshTasksResponseBodyTasksTask) SetObjectPath(v string) *DescribeVodRefreshTasksResponseBodyTasksTask {
	s.ObjectPath = &v
	return s
}

func (s *DescribeVodRefreshTasksResponseBodyTasksTask) SetObjectType(v string) *DescribeVodRefreshTasksResponseBodyTasksTask {
	s.ObjectType = &v
	return s
}

func (s *DescribeVodRefreshTasksResponseBodyTasksTask) SetProcess(v string) *DescribeVodRefreshTasksResponseBodyTasksTask {
	s.Process = &v
	return s
}

func (s *DescribeVodRefreshTasksResponseBodyTasksTask) SetStatus(v string) *DescribeVodRefreshTasksResponseBodyTasksTask {
	s.Status = &v
	return s
}

func (s *DescribeVodRefreshTasksResponseBodyTasksTask) SetTaskId(v string) *DescribeVodRefreshTasksResponseBodyTasksTask {
	s.TaskId = &v
	return s
}

type DescribeVodRefreshTasksResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodRefreshTasksResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodRefreshTasksResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodRefreshTasksResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodRefreshTasksResponse) SetHeaders(v map[string]*string) *DescribeVodRefreshTasksResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodRefreshTasksResponse) SetStatusCode(v int32) *DescribeVodRefreshTasksResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodRefreshTasksResponse) SetBody(v *DescribeVodRefreshTasksResponseBody) *DescribeVodRefreshTasksResponse {
	s.Body = v
	return s
}

type DescribeVodSSLCertificateListRequest struct {
	// The accelerated domain name.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId    *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The page number. Default value: 1.
	//
	// example:
	//
	// 1
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page. Valid values: integers from 1 to 1000.
	//
	// example:
	//
	// 10
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The keyword that is used to query certificates.
	//
	// example:
	//
	// certabc
	SearchKeyword *string `json:"SearchKeyword,omitempty" xml:"SearchKeyword,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeVodSSLCertificateListRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodSSLCertificateListRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodSSLCertificateListRequest) SetDomainName(v string) *DescribeVodSSLCertificateListRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodSSLCertificateListRequest) SetOwnerId(v int64) *DescribeVodSSLCertificateListRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodSSLCertificateListRequest) SetPageNumber(v int64) *DescribeVodSSLCertificateListRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeVodSSLCertificateListRequest) SetPageSize(v int64) *DescribeVodSSLCertificateListRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeVodSSLCertificateListRequest) SetSearchKeyword(v string) *DescribeVodSSLCertificateListRequest {
	s.SearchKeyword = &v
	return s
}

func (s *DescribeVodSSLCertificateListRequest) SetSecurityToken(v string) *DescribeVodSSLCertificateListRequest {
	s.SecurityToken = &v
	return s
}

type DescribeVodSSLCertificateListResponseBody struct {
	// The information about certificates.
	CertificateListModel *DescribeVodSSLCertificateListResponseBodyCertificateListModel `json:"CertificateListModel,omitempty" xml:"CertificateListModel,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4AF6-D7393642CA58****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeVodSSLCertificateListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodSSLCertificateListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodSSLCertificateListResponseBody) SetCertificateListModel(v *DescribeVodSSLCertificateListResponseBodyCertificateListModel) *DescribeVodSSLCertificateListResponseBody {
	s.CertificateListModel = v
	return s
}

func (s *DescribeVodSSLCertificateListResponseBody) SetRequestId(v string) *DescribeVodSSLCertificateListResponseBody {
	s.RequestId = &v
	return s
}

type DescribeVodSSLCertificateListResponseBodyCertificateListModel struct {
	// The list of certificates.
	CertList *DescribeVodSSLCertificateListResponseBodyCertificateListModelCertList `json:"CertList,omitempty" xml:"CertList,omitempty" type:"Struct"`
	// The number of certificates that are returned.
	//
	// example:
	//
	// 2
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The page number. Pages start from page 1. Default value: 1.
	//
	// example:
	//
	// 1
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page. Valid values: integers from 1 to 1000.
	//
	// example:
	//
	// 20
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribeVodSSLCertificateListResponseBodyCertificateListModel) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodSSLCertificateListResponseBodyCertificateListModel) GoString() string {
	return s.String()
}

func (s *DescribeVodSSLCertificateListResponseBodyCertificateListModel) SetCertList(v *DescribeVodSSLCertificateListResponseBodyCertificateListModelCertList) *DescribeVodSSLCertificateListResponseBodyCertificateListModel {
	s.CertList = v
	return s
}

func (s *DescribeVodSSLCertificateListResponseBodyCertificateListModel) SetCount(v int32) *DescribeVodSSLCertificateListResponseBodyCertificateListModel {
	s.Count = &v
	return s
}

func (s *DescribeVodSSLCertificateListResponseBodyCertificateListModel) SetPageNumber(v int64) *DescribeVodSSLCertificateListResponseBodyCertificateListModel {
	s.PageNumber = &v
	return s
}

func (s *DescribeVodSSLCertificateListResponseBodyCertificateListModel) SetPageSize(v int64) *DescribeVodSSLCertificateListResponseBodyCertificateListModel {
	s.PageSize = &v
	return s
}

type DescribeVodSSLCertificateListResponseBodyCertificateListModelCertList struct {
	Cert []*DescribeVodSSLCertificateListResponseBodyCertificateListModelCertListCert `json:"Cert,omitempty" xml:"Cert,omitempty" type:"Repeated"`
}

func (s DescribeVodSSLCertificateListResponseBodyCertificateListModelCertList) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodSSLCertificateListResponseBodyCertificateListModelCertList) GoString() string {
	return s.String()
}

func (s *DescribeVodSSLCertificateListResponseBodyCertificateListModelCertList) SetCert(v []*DescribeVodSSLCertificateListResponseBodyCertificateListModelCertListCert) *DescribeVodSSLCertificateListResponseBodyCertificateListModelCertList {
	s.Cert = v
	return s
}

type DescribeVodSSLCertificateListResponseBodyCertificateListModelCertListCert struct {
	// The ID of the certificate.
	//
	// example:
	//
	// 235437
	CertId *int64 `json:"CertId,omitempty" xml:"CertId,omitempty"`
	// The name of the certificate.
	//
	// example:
	//
	// video-ssl
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The region of the certificate. Valid values: **cn-hangzhou*	- and **ap-southeast-1**. Default value: **cn-hangzhou**.
	//
	// example:
	//
	// cn-hangzhou
	CertRegion *string `json:"CertRegion,omitempty" xml:"CertRegion,omitempty"`
	// The Common Name (CN) attribute of the certificate. In most cases, the CN is a domain name.
	//
	// example:
	//
	// test
	Common *string `json:"Common,omitempty" xml:"Common,omitempty"`
	// The fingerprint of the certificate.
	//
	// example:
	//
	// ****
	Fingerprint *string `json:"Fingerprint,omitempty" xml:"Fingerprint,omitempty"`
	// The certificate authority (CA) that issued the certificate.
	//
	// example:
	//
	// ****
	Issuer *string `json:"Issuer,omitempty" xml:"Issuer,omitempty"`
	// The time when the certificate was last modified. Unit: milliseconds.
	//
	// example:
	//
	// 1512388610
	LastTime *int64 `json:"LastTime,omitempty" xml:"LastTime,omitempty"`
}

func (s DescribeVodSSLCertificateListResponseBodyCertificateListModelCertListCert) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodSSLCertificateListResponseBodyCertificateListModelCertListCert) GoString() string {
	return s.String()
}

func (s *DescribeVodSSLCertificateListResponseBodyCertificateListModelCertListCert) SetCertId(v int64) *DescribeVodSSLCertificateListResponseBodyCertificateListModelCertListCert {
	s.CertId = &v
	return s
}

func (s *DescribeVodSSLCertificateListResponseBodyCertificateListModelCertListCert) SetCertName(v string) *DescribeVodSSLCertificateListResponseBodyCertificateListModelCertListCert {
	s.CertName = &v
	return s
}

func (s *DescribeVodSSLCertificateListResponseBodyCertificateListModelCertListCert) SetCertRegion(v string) *DescribeVodSSLCertificateListResponseBodyCertificateListModelCertListCert {
	s.CertRegion = &v
	return s
}

func (s *DescribeVodSSLCertificateListResponseBodyCertificateListModelCertListCert) SetCommon(v string) *DescribeVodSSLCertificateListResponseBodyCertificateListModelCertListCert {
	s.Common = &v
	return s
}

func (s *DescribeVodSSLCertificateListResponseBodyCertificateListModelCertListCert) SetFingerprint(v string) *DescribeVodSSLCertificateListResponseBodyCertificateListModelCertListCert {
	s.Fingerprint = &v
	return s
}

func (s *DescribeVodSSLCertificateListResponseBodyCertificateListModelCertListCert) SetIssuer(v string) *DescribeVodSSLCertificateListResponseBodyCertificateListModelCertListCert {
	s.Issuer = &v
	return s
}

func (s *DescribeVodSSLCertificateListResponseBodyCertificateListModelCertListCert) SetLastTime(v int64) *DescribeVodSSLCertificateListResponseBodyCertificateListModelCertListCert {
	s.LastTime = &v
	return s
}

type DescribeVodSSLCertificateListResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodSSLCertificateListResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodSSLCertificateListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodSSLCertificateListResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodSSLCertificateListResponse) SetHeaders(v map[string]*string) *DescribeVodSSLCertificateListResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodSSLCertificateListResponse) SetStatusCode(v int32) *DescribeVodSSLCertificateListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodSSLCertificateListResponse) SetBody(v *DescribeVodSSLCertificateListResponseBody) *DescribeVodSSLCertificateListResponse {
	s.Body = v
	return s
}

type DescribeVodStorageDataRequest struct {
	// The ID of the application.
	//
	// 	- Default value: **app-1000000**.
	//
	// example:
	//
	// app-1000000
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// This parameter is required.
	//
	// example:
	//
	// 2019-02-01T15:00:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region in which you want to query storage data. If you leave this parameter empty, data in all regions is returned. Separate multiple regions with commas (,). Valid values:
	//
	// 	- **cn-shanghai**: China (Shanghai)
	//
	// 	- **cn-beijing**: China (Beijing)
	//
	// 	- **eu-central-1**: Germany (Frankfurt)
	//
	// 	- **ap-southeast-1**: Singapore
	//
	// example:
	//
	// cn-shanghai
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// This parameter is required.
	//
	// example:
	//
	// 2019-02-01T14:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The name of the Object Storage Service (OSS) bucket. If you leave this parameter empty, data of all buckets is returned. Separate multiple transcoding specifications with commas (,).
	//
	// example:
	//
	// bucket
	Storage *string `json:"Storage,omitempty" xml:"Storage,omitempty"`
	// The storage class. Set the value to **OSS**.
	//
	// example:
	//
	// OSS
	StorageType *string `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
}

func (s DescribeVodStorageDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodStorageDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodStorageDataRequest) SetAppId(v string) *DescribeVodStorageDataRequest {
	s.AppId = &v
	return s
}

func (s *DescribeVodStorageDataRequest) SetEndTime(v string) *DescribeVodStorageDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodStorageDataRequest) SetOwnerId(v int64) *DescribeVodStorageDataRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodStorageDataRequest) SetRegion(v string) *DescribeVodStorageDataRequest {
	s.Region = &v
	return s
}

func (s *DescribeVodStorageDataRequest) SetStartTime(v string) *DescribeVodStorageDataRequest {
	s.StartTime = &v
	return s
}

func (s *DescribeVodStorageDataRequest) SetStorage(v string) *DescribeVodStorageDataRequest {
	s.Storage = &v
	return s
}

func (s *DescribeVodStorageDataRequest) SetStorageType(v string) *DescribeVodStorageDataRequest {
	s.StorageType = &v
	return s
}

type DescribeVodStorageDataResponseBody struct {
	// The time granularity at which the data was queried. Valid values:
	//
	// 	- **hour**
	//
	// 	- **day**
	//
	// example:
	//
	// day
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// C370DAF1-C838-4288-****-9A87633D248E
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The storage usage data returned.
	StorageData *DescribeVodStorageDataResponseBodyStorageData `json:"StorageData,omitempty" xml:"StorageData,omitempty" type:"Struct"`
}

func (s DescribeVodStorageDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodStorageDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodStorageDataResponseBody) SetDataInterval(v string) *DescribeVodStorageDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeVodStorageDataResponseBody) SetRequestId(v string) *DescribeVodStorageDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVodStorageDataResponseBody) SetStorageData(v *DescribeVodStorageDataResponseBodyStorageData) *DescribeVodStorageDataResponseBody {
	s.StorageData = v
	return s
}

type DescribeVodStorageDataResponseBodyStorageData struct {
	StorageDataItem []*DescribeVodStorageDataResponseBodyStorageDataStorageDataItem `json:"StorageDataItem,omitempty" xml:"StorageDataItem,omitempty" type:"Repeated"`
}

func (s DescribeVodStorageDataResponseBodyStorageData) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodStorageDataResponseBodyStorageData) GoString() string {
	return s.String()
}

func (s *DescribeVodStorageDataResponseBodyStorageData) SetStorageDataItem(v []*DescribeVodStorageDataResponseBodyStorageDataStorageDataItem) *DescribeVodStorageDataResponseBodyStorageData {
	s.StorageDataItem = v
	return s
}

type DescribeVodStorageDataResponseBodyStorageDataStorageDataItem struct {
	// The outbound traffic. Unit: bytes. The outbound traffic is generated when videos are directly downloaded or played from OSS buckets without Alibaba Cloud CDN acceleration.
	//
	// example:
	//
	// 111111
	NetworkOut *string `json:"NetworkOut,omitempty" xml:"NetworkOut,omitempty"`
	// The detailed usage data of storage-related resources. Unit: bytes.
	//
	// example:
	//
	// 111111
	StorageUtilization *string `json:"StorageUtilization,omitempty" xml:"StorageUtilization,omitempty"`
	// The timestamp of the returned data. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-02-01T15:00:00Z
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeVodStorageDataResponseBodyStorageDataStorageDataItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodStorageDataResponseBodyStorageDataStorageDataItem) GoString() string {
	return s.String()
}

func (s *DescribeVodStorageDataResponseBodyStorageDataStorageDataItem) SetNetworkOut(v string) *DescribeVodStorageDataResponseBodyStorageDataStorageDataItem {
	s.NetworkOut = &v
	return s
}

func (s *DescribeVodStorageDataResponseBodyStorageDataStorageDataItem) SetStorageUtilization(v string) *DescribeVodStorageDataResponseBodyStorageDataStorageDataItem {
	s.StorageUtilization = &v
	return s
}

func (s *DescribeVodStorageDataResponseBodyStorageDataStorageDataItem) SetTimeStamp(v string) *DescribeVodStorageDataResponseBodyStorageDataStorageDataItem {
	s.TimeStamp = &v
	return s
}

type DescribeVodStorageDataResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodStorageDataResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodStorageDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodStorageDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodStorageDataResponse) SetHeaders(v map[string]*string) *DescribeVodStorageDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodStorageDataResponse) SetStatusCode(v int32) *DescribeVodStorageDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodStorageDataResponse) SetBody(v *DescribeVodStorageDataResponseBody) *DescribeVodStorageDataResponse {
	s.Body = v
	return s
}

type DescribeVodTieringStorageDataRequest struct {
	// The end time at which data is obtained. The end time must be later than the start time. The difference cannot exceed 31 days. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// example:
	//
	// 2023-05-29T02:00:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region in which you want to query data. If you leave this parameter empty, data in all regions is returned. Separate multiple regions with commas (,).
	//
	// example:
	//
	// cn-beijing
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. If you leave this parameter empty, data in the last 24 hours is queried.
	//
	// example:
	//
	// 2023-05-29T01:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The storage type. By default, all storage types are returned. Valid values:
	//
	// 	- **IA**
	//
	// 	- **Archive**
	//
	// 	- **ColdArchive**
	//
	// example:
	//
	// IA
	StorageClass *string `json:"StorageClass,omitempty" xml:"StorageClass,omitempty"`
}

func (s DescribeVodTieringStorageDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodTieringStorageDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodTieringStorageDataRequest) SetEndTime(v string) *DescribeVodTieringStorageDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodTieringStorageDataRequest) SetOwnerId(v int64) *DescribeVodTieringStorageDataRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodTieringStorageDataRequest) SetRegion(v string) *DescribeVodTieringStorageDataRequest {
	s.Region = &v
	return s
}

func (s *DescribeVodTieringStorageDataRequest) SetStartTime(v string) *DescribeVodTieringStorageDataRequest {
	s.StartTime = &v
	return s
}

func (s *DescribeVodTieringStorageDataRequest) SetStorageClass(v string) *DescribeVodTieringStorageDataRequest {
	s.StorageClass = &v
	return s
}

type DescribeVodTieringStorageDataResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4AF6-D7393642CA58****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The storage usage data returned.
	StorageData []*DescribeVodTieringStorageDataResponseBodyStorageData `json:"StorageData,omitempty" xml:"StorageData,omitempty" type:"Repeated"`
}

func (s DescribeVodTieringStorageDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodTieringStorageDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodTieringStorageDataResponseBody) SetRequestId(v string) *DescribeVodTieringStorageDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVodTieringStorageDataResponseBody) SetStorageData(v []*DescribeVodTieringStorageDataResponseBodyStorageData) *DescribeVodTieringStorageDataResponseBody {
	s.StorageData = v
	return s
}

type DescribeVodTieringStorageDataResponseBodyStorageData struct {
	// The data that is stored less than a month. Unit: bytes.
	//
	// example:
	//
	// 123
	LessthanMonthDatasize *int64 `json:"LessthanMonthDatasize,omitempty" xml:"LessthanMonthDatasize,omitempty"`
	// The region in which data is queried.
	//
	// example:
	//
	// cn-beijing
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The storage type.
	//
	// example:
	//
	// IA
	StorageClass *string `json:"StorageClass,omitempty" xml:"StorageClass,omitempty"`
	// The storage usage. Unit: bytes.
	//
	// example:
	//
	// 1234
	StorageUtilization *int64 `json:"StorageUtilization,omitempty" xml:"StorageUtilization,omitempty"`
	// The timestamp of the data returned. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2023-05-29T01:00:00Z
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeVodTieringStorageDataResponseBodyStorageData) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodTieringStorageDataResponseBodyStorageData) GoString() string {
	return s.String()
}

func (s *DescribeVodTieringStorageDataResponseBodyStorageData) SetLessthanMonthDatasize(v int64) *DescribeVodTieringStorageDataResponseBodyStorageData {
	s.LessthanMonthDatasize = &v
	return s
}

func (s *DescribeVodTieringStorageDataResponseBodyStorageData) SetRegion(v string) *DescribeVodTieringStorageDataResponseBodyStorageData {
	s.Region = &v
	return s
}

func (s *DescribeVodTieringStorageDataResponseBodyStorageData) SetStorageClass(v string) *DescribeVodTieringStorageDataResponseBodyStorageData {
	s.StorageClass = &v
	return s
}

func (s *DescribeVodTieringStorageDataResponseBodyStorageData) SetStorageUtilization(v int64) *DescribeVodTieringStorageDataResponseBodyStorageData {
	s.StorageUtilization = &v
	return s
}

func (s *DescribeVodTieringStorageDataResponseBodyStorageData) SetTimeStamp(v string) *DescribeVodTieringStorageDataResponseBodyStorageData {
	s.TimeStamp = &v
	return s
}

type DescribeVodTieringStorageDataResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodTieringStorageDataResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodTieringStorageDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodTieringStorageDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodTieringStorageDataResponse) SetHeaders(v map[string]*string) *DescribeVodTieringStorageDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodTieringStorageDataResponse) SetStatusCode(v int32) *DescribeVodTieringStorageDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodTieringStorageDataResponse) SetBody(v *DescribeVodTieringStorageDataResponseBody) *DescribeVodTieringStorageDataResponse {
	s.Body = v
	return s
}

type DescribeVodTieringStorageRetrievalDataRequest struct {
	// The end of the time range to query. The end time must be later than the start time. The time range cannot exceed 31 days. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// example:
	//
	// 2023-06-02T11:20:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region in which you want to query data. If you leave this parameter empty, data in all regions is returned. Separate multiple regions with commas (,).
	//
	// example:
	//
	// cn-beijing
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. The minimum time range is 5 minutes. If you leave this parameter empty, data in the last 24 hours is queried.
	//
	// example:
	//
	// 2023-06-02T10:20:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The storage type. Valid values:
	//
	// 	- **IA**
	//
	// 	- **Archive**
	//
	// 	- **ColdArchive**
	//
	// example:
	//
	// IA
	StorageClass *string `json:"StorageClass,omitempty" xml:"StorageClass,omitempty"`
}

func (s DescribeVodTieringStorageRetrievalDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodTieringStorageRetrievalDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodTieringStorageRetrievalDataRequest) SetEndTime(v string) *DescribeVodTieringStorageRetrievalDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodTieringStorageRetrievalDataRequest) SetOwnerId(v int64) *DescribeVodTieringStorageRetrievalDataRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodTieringStorageRetrievalDataRequest) SetRegion(v string) *DescribeVodTieringStorageRetrievalDataRequest {
	s.Region = &v
	return s
}

func (s *DescribeVodTieringStorageRetrievalDataRequest) SetStartTime(v string) *DescribeVodTieringStorageRetrievalDataRequest {
	s.StartTime = &v
	return s
}

func (s *DescribeVodTieringStorageRetrievalDataRequest) SetStorageClass(v string) *DescribeVodTieringStorageRetrievalDataRequest {
	s.StorageClass = &v
	return s
}

type DescribeVodTieringStorageRetrievalDataResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A13-BEF6-D73936****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The data retrieval information.
	RetrievalData []*DescribeVodTieringStorageRetrievalDataResponseBodyRetrievalData `json:"RetrievalData,omitempty" xml:"RetrievalData,omitempty" type:"Repeated"`
}

func (s DescribeVodTieringStorageRetrievalDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodTieringStorageRetrievalDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodTieringStorageRetrievalDataResponseBody) SetRequestId(v string) *DescribeVodTieringStorageRetrievalDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVodTieringStorageRetrievalDataResponseBody) SetRetrievalData(v []*DescribeVodTieringStorageRetrievalDataResponseBodyRetrievalData) *DescribeVodTieringStorageRetrievalDataResponseBody {
	s.RetrievalData = v
	return s
}

type DescribeVodTieringStorageRetrievalDataResponseBodyRetrievalData struct {
	// The retrieved Cold Archive data in the bulk mode.
	//
	// example:
	//
	// 123
	CABulkRetrievalData *int64 `json:"CABulkRetrievalData,omitempty" xml:"CABulkRetrievalData,omitempty"`
	// The retrieved Cold Archive data in the expedited mode.
	//
	// example:
	//
	// 123
	CAHighPriorRetrievalData *int64 `json:"CAHighPriorRetrievalData,omitempty" xml:"CAHighPriorRetrievalData,omitempty"`
	// The retrieved Cold Archive data in the standard mode.
	//
	// example:
	//
	// 123
	CAStdRetrievalData *int64 `json:"CAStdRetrievalData,omitempty" xml:"CAStdRetrievalData,omitempty"`
	// The storage region.
	//
	// example:
	//
	// cn-beijing
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The data retrieval information.
	//
	// example:
	//
	// 1234
	RetrievalData *int64 `json:"RetrievalData,omitempty" xml:"RetrievalData,omitempty"`
	// The storage type.
	//
	// example:
	//
	// IA
	StorageClass *string `json:"StorageClass,omitempty" xml:"StorageClass,omitempty"`
	// The timestamp of the returned data. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2023-06-02T10:20:00Z
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeVodTieringStorageRetrievalDataResponseBodyRetrievalData) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodTieringStorageRetrievalDataResponseBodyRetrievalData) GoString() string {
	return s.String()
}

func (s *DescribeVodTieringStorageRetrievalDataResponseBodyRetrievalData) SetCABulkRetrievalData(v int64) *DescribeVodTieringStorageRetrievalDataResponseBodyRetrievalData {
	s.CABulkRetrievalData = &v
	return s
}

func (s *DescribeVodTieringStorageRetrievalDataResponseBodyRetrievalData) SetCAHighPriorRetrievalData(v int64) *DescribeVodTieringStorageRetrievalDataResponseBodyRetrievalData {
	s.CAHighPriorRetrievalData = &v
	return s
}

func (s *DescribeVodTieringStorageRetrievalDataResponseBodyRetrievalData) SetCAStdRetrievalData(v int64) *DescribeVodTieringStorageRetrievalDataResponseBodyRetrievalData {
	s.CAStdRetrievalData = &v
	return s
}

func (s *DescribeVodTieringStorageRetrievalDataResponseBodyRetrievalData) SetRegion(v string) *DescribeVodTieringStorageRetrievalDataResponseBodyRetrievalData {
	s.Region = &v
	return s
}

func (s *DescribeVodTieringStorageRetrievalDataResponseBodyRetrievalData) SetRetrievalData(v int64) *DescribeVodTieringStorageRetrievalDataResponseBodyRetrievalData {
	s.RetrievalData = &v
	return s
}

func (s *DescribeVodTieringStorageRetrievalDataResponseBodyRetrievalData) SetStorageClass(v string) *DescribeVodTieringStorageRetrievalDataResponseBodyRetrievalData {
	s.StorageClass = &v
	return s
}

func (s *DescribeVodTieringStorageRetrievalDataResponseBodyRetrievalData) SetTimeStamp(v string) *DescribeVodTieringStorageRetrievalDataResponseBodyRetrievalData {
	s.TimeStamp = &v
	return s
}

type DescribeVodTieringStorageRetrievalDataResponse struct {
	Headers    map[string]*string                                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodTieringStorageRetrievalDataResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodTieringStorageRetrievalDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodTieringStorageRetrievalDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodTieringStorageRetrievalDataResponse) SetHeaders(v map[string]*string) *DescribeVodTieringStorageRetrievalDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodTieringStorageRetrievalDataResponse) SetStatusCode(v int32) *DescribeVodTieringStorageRetrievalDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodTieringStorageRetrievalDataResponse) SetBody(v *DescribeVodTieringStorageRetrievalDataResponseBody) *DescribeVodTieringStorageRetrievalDataResponse {
	s.Body = v
	return s
}

type DescribeVodTranscodeDataRequest struct {
	// The ID of the application. You can specify this parameter to query the transcoding statistics of a specific application. By default, the transcoding statistics of all applications is returned. You can obtain the application ID from the `AppId` parameter in the response to the [CreateAppInfo](~~CreateAppInfo~~) operation.
	//
	// example:
	//
	// app-1000001
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// This parameter is required.
	//
	// example:
	//
	// 2019-02-01T15:59:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The interval at which you want to query data. Valid values:
	//
	// 	- **day**: days
	//
	// 	- **hour**: hours
	//
	// example:
	//
	// day
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	OwnerId  *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region in which you want to query data. If you leave this parameter empty, data in all regions is returned. Separate multiple regions with commas (,). Valid values:
	//
	// 	- **cn-shanghai**: China (Shanghai)
	//
	// 	- **cn-beijing**: China (Beijing)
	//
	// 	- **eu-central-1**: Germany (Frankfurt)
	//
	// 	- **ap-southeast-1**: Singapore
	//
	// example:
	//
	// cn-shanghai
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The transcoding specification. If you leave this parameter empty, data of all transcoding specifications is returned. Separate multiple transcoding specifications with commas (,). Valid values:
	//
	// 	- **Audio**: audio transcoding
	//
	// 	- **Segmentation**: container format conversion
	//
	// 	- **H264.LD**, **H264.SD**, **H264.HD**, **H264.2K**, **H264.4K**, and more
	//
	// example:
	//
	// Audio
	Specification *string `json:"Specification,omitempty" xml:"Specification,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// This parameter is required.
	//
	// example:
	//
	// 2019-02-01T15:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The name of the Object Storage Service (OSS) bucket. If you leave this parameter empty, data of all buckets is returned. Separate multiple bucket names with commas (,).
	//
	// example:
	//
	// bucket01
	Storage *string `json:"Storage,omitempty" xml:"Storage,omitempty"`
}

func (s DescribeVodTranscodeDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodTranscodeDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodTranscodeDataRequest) SetAppId(v string) *DescribeVodTranscodeDataRequest {
	s.AppId = &v
	return s
}

func (s *DescribeVodTranscodeDataRequest) SetEndTime(v string) *DescribeVodTranscodeDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodTranscodeDataRequest) SetInterval(v string) *DescribeVodTranscodeDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeVodTranscodeDataRequest) SetOwnerId(v int64) *DescribeVodTranscodeDataRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodTranscodeDataRequest) SetRegion(v string) *DescribeVodTranscodeDataRequest {
	s.Region = &v
	return s
}

func (s *DescribeVodTranscodeDataRequest) SetSpecification(v string) *DescribeVodTranscodeDataRequest {
	s.Specification = &v
	return s
}

func (s *DescribeVodTranscodeDataRequest) SetStartTime(v string) *DescribeVodTranscodeDataRequest {
	s.StartTime = &v
	return s
}

func (s *DescribeVodTranscodeDataRequest) SetStorage(v string) *DescribeVodTranscodeDataRequest {
	s.Storage = &v
	return s
}

type DescribeVodTranscodeDataResponseBody struct {
	// The interval at which the data was queried. Valid values:
	//
	// 	- **hour**
	//
	// 	- **day**
	//
	// example:
	//
	// day
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// C370DAF1-C838-4288-****-9A87633D248E
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The transcoding statistics returned.
	TranscodeData *DescribeVodTranscodeDataResponseBodyTranscodeData `json:"TranscodeData,omitempty" xml:"TranscodeData,omitempty" type:"Struct"`
}

func (s DescribeVodTranscodeDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodTranscodeDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodTranscodeDataResponseBody) SetDataInterval(v string) *DescribeVodTranscodeDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeVodTranscodeDataResponseBody) SetRequestId(v string) *DescribeVodTranscodeDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVodTranscodeDataResponseBody) SetTranscodeData(v *DescribeVodTranscodeDataResponseBodyTranscodeData) *DescribeVodTranscodeDataResponseBody {
	s.TranscodeData = v
	return s
}

type DescribeVodTranscodeDataResponseBodyTranscodeData struct {
	TranscodeDataItem []*DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItem `json:"TranscodeDataItem,omitempty" xml:"TranscodeDataItem,omitempty" type:"Repeated"`
}

func (s DescribeVodTranscodeDataResponseBodyTranscodeData) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodTranscodeDataResponseBodyTranscodeData) GoString() string {
	return s.String()
}

func (s *DescribeVodTranscodeDataResponseBodyTranscodeData) SetTranscodeDataItem(v []*DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItem) *DescribeVodTranscodeDataResponseBodyTranscodeData {
	s.TranscodeDataItem = v
	return s
}

type DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItem struct {
	// The statistics on transcoding of different specifications.
	Data *DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The timestamp of the returned data. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-02-01T16:00:00Z
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItem) GoString() string {
	return s.String()
}

func (s *DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItem) SetData(v *DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemData) *DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItem {
	s.Data = v
	return s
}

func (s *DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItem) SetTimeStamp(v string) *DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItem {
	s.TimeStamp = &v
	return s
}

type DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemData struct {
	DataItem []*DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemDataDataItem `json:"DataItem,omitempty" xml:"DataItem,omitempty" type:"Repeated"`
}

func (s DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemData) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemData) GoString() string {
	return s.String()
}

func (s *DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemData) SetDataItem(v []*DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemDataDataItem) *DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemData {
	s.DataItem = v
	return s
}

type DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemDataDataItem struct {
	// The transcoding specification. Valid values:
	//
	// 	- **Audio**: audio transcoding
	//
	// 	- **Segmentation**: container format conversion
	//
	// 	- **H264.LD, H264.SD, H264.HD, H264.2K, H264.4K, and more**
	//
	// example:
	//
	// H264.SD
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The transcoding duration. Unit: seconds.
	//
	// example:
	//
	// 111
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemDataDataItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemDataDataItem) GoString() string {
	return s.String()
}

func (s *DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemDataDataItem) SetName(v string) *DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemDataDataItem {
	s.Name = &v
	return s
}

func (s *DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemDataDataItem) SetValue(v string) *DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemDataDataItem {
	s.Value = &v
	return s
}

type DescribeVodTranscodeDataResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodTranscodeDataResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodTranscodeDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodTranscodeDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodTranscodeDataResponse) SetHeaders(v map[string]*string) *DescribeVodTranscodeDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodTranscodeDataResponse) SetStatusCode(v int32) *DescribeVodTranscodeDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodTranscodeDataResponse) SetBody(v *DescribeVodTranscodeDataResponseBody) *DescribeVodTranscodeDataResponse {
	s.Body = v
	return s
}

type DescribeVodUserDomainsRequest struct {
	// The domain name. The value of this parameter is used as a filter condition for a fuzzy match.
	//
	// example:
	//
	// example.aliyundoc.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The search method. Valid values:
	//
	// 	- **fuzzy_match*	- (default): fuzzy match.
	//
	// 	- **pre_match**: prefix match
	//
	// 	- **suf_match**: suffix match
	//
	// 	- **full_match**: exact match
	//
	// example:
	//
	// fuzzy_match
	DomainSearchType *string `json:"DomainSearchType,omitempty" xml:"DomainSearchType,omitempty"`
	// The status of the domain name. Value values:
	//
	// 	- **online**: indicates that the domain name is enabled.
	//
	// 	- **offline**: indicates that the domain name is disabled.
	//
	// 	- **configuring**: indicates that the domain name is being configured.
	//
	// 	- **configure_failed**: indicates that the domain name failed to be configured.
	//
	// 	- **checking**: indicates that the domain name is under review.
	//
	// 	- **check_failed**: indicates that the domain name failed the review.
	//
	// example:
	//
	// online
	DomainStatus *string `json:"DomainStatus,omitempty" xml:"DomainStatus,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The page number.
	//
	// example:
	//
	// 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page. Default value: **20**. Maximum value: **50**. Valid values: **1*	- to **50**.
	//
	// example:
	//
	// 20
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The tags.
	Tag []*DescribeVodUserDomainsRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeVodUserDomainsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodUserDomainsRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodUserDomainsRequest) SetDomainName(v string) *DescribeVodUserDomainsRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodUserDomainsRequest) SetDomainSearchType(v string) *DescribeVodUserDomainsRequest {
	s.DomainSearchType = &v
	return s
}

func (s *DescribeVodUserDomainsRequest) SetDomainStatus(v string) *DescribeVodUserDomainsRequest {
	s.DomainStatus = &v
	return s
}

func (s *DescribeVodUserDomainsRequest) SetOwnerId(v int64) *DescribeVodUserDomainsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodUserDomainsRequest) SetPageNumber(v int32) *DescribeVodUserDomainsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeVodUserDomainsRequest) SetPageSize(v int32) *DescribeVodUserDomainsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeVodUserDomainsRequest) SetSecurityToken(v string) *DescribeVodUserDomainsRequest {
	s.SecurityToken = &v
	return s
}

func (s *DescribeVodUserDomainsRequest) SetTag(v []*DescribeVodUserDomainsRequestTag) *DescribeVodUserDomainsRequest {
	s.Tag = v
	return s
}

type DescribeVodUserDomainsRequestTag struct {
	// The key of tag N. Valid values of N: **1*	- to **20**.
	//
	// By default, all tag keys are queried.
	//
	// example:
	//
	// key
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of tag N. Valid values of N: **1*	- to **20**.
	//
	// By default, all tag values are queried.
	//
	// example:
	//
	// value
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVodUserDomainsRequestTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodUserDomainsRequestTag) GoString() string {
	return s.String()
}

func (s *DescribeVodUserDomainsRequestTag) SetKey(v string) *DescribeVodUserDomainsRequestTag {
	s.Key = &v
	return s
}

func (s *DescribeVodUserDomainsRequestTag) SetValue(v string) *DescribeVodUserDomainsRequestTag {
	s.Value = &v
	return s
}

type DescribeVodUserDomainsResponseBody struct {
	// The detailed information about each domain name for CDN. The returned information is displayed in the format that is specified by the PageData parameter.
	Domains *DescribeVodUserDomainsResponseBodyDomains `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Struct"`
	// The page number.
	//
	// example:
	//
	// 1
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	//
	// example:
	//
	// 20
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// E4EBD2BF-5EB0-4476-****-9D94E1B15267
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries.
	//
	// example:
	//
	// 2
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeVodUserDomainsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodUserDomainsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodUserDomainsResponseBody) SetDomains(v *DescribeVodUserDomainsResponseBodyDomains) *DescribeVodUserDomainsResponseBody {
	s.Domains = v
	return s
}

func (s *DescribeVodUserDomainsResponseBody) SetPageNumber(v int64) *DescribeVodUserDomainsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeVodUserDomainsResponseBody) SetPageSize(v int64) *DescribeVodUserDomainsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeVodUserDomainsResponseBody) SetRequestId(v string) *DescribeVodUserDomainsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVodUserDomainsResponseBody) SetTotalCount(v int64) *DescribeVodUserDomainsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeVodUserDomainsResponseBodyDomains struct {
	PageData []*DescribeVodUserDomainsResponseBodyDomainsPageData `json:"PageData,omitempty" xml:"PageData,omitempty" type:"Repeated"`
}

func (s DescribeVodUserDomainsResponseBodyDomains) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodUserDomainsResponseBodyDomains) GoString() string {
	return s.String()
}

func (s *DescribeVodUserDomainsResponseBodyDomains) SetPageData(v []*DescribeVodUserDomainsResponseBodyDomainsPageData) *DescribeVodUserDomainsResponseBodyDomains {
	s.PageData = v
	return s
}

type DescribeVodUserDomainsResponseBodyDomainsPageData struct {
	// The CNAME that is assigned to the domain name for CDN.
	//
	// example:
	//
	// learn.developer.aliyundoc.com
	Cname *string `json:"Cname,omitempty" xml:"Cname,omitempty"`
	// The remarks.
	//
	// example:
	//
	// Zhejiang ICP Filing No. ****
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The domain name for CDN.
	//
	// example:
	//
	// example.aliyundoc.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The status of the domain name for CDN. Valid values:
	//
	// 	- **online**: indicates that the domain name is enabled.
	//
	// 	- **offline**: indicates that the domain name is disabled.
	//
	// 	- **configuring**: indicates that the domain name is being configured.
	//
	// 	- **configure_failed**: indicates that the domain name failed to be configured.
	//
	// 	- **checking**: indicates that the domain name is under review.
	//
	// 	- **check_failed**: indicates that the domain name failed the review.
	//
	// example:
	//
	// online
	DomainStatus *string `json:"DomainStatus,omitempty" xml:"DomainStatus,omitempty"`
	// The time when the domain name for CDN was added. The time is in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-08-29T08:40:53Z
	GmtCreated *string `json:"GmtCreated,omitempty" xml:"GmtCreated,omitempty"`
	// The last time when the domain name for CDN was modified. The time is in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-12-29T09:24:12Z
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// Indicates whether the accelerated domain name was in a sandbox.
	//
	// example:
	//
	// normal
	Sandbox *string `json:"Sandbox,omitempty" xml:"Sandbox,omitempty"`
	// The information about the origin server.
	Sources *DescribeVodUserDomainsResponseBodyDomainsPageDataSources `json:"Sources,omitempty" xml:"Sources,omitempty" type:"Struct"`
	// Indicates whether HTTPS is enabled.
	//
	// 	- **on**: HTTPS is enabled.
	//
	// 	- **off**: HTTPS is not eabled.
	//
	// example:
	//
	// on
	SslProtocol *string `json:"SslProtocol,omitempty" xml:"SslProtocol,omitempty"`
}

func (s DescribeVodUserDomainsResponseBodyDomainsPageData) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodUserDomainsResponseBodyDomainsPageData) GoString() string {
	return s.String()
}

func (s *DescribeVodUserDomainsResponseBodyDomainsPageData) SetCname(v string) *DescribeVodUserDomainsResponseBodyDomainsPageData {
	s.Cname = &v
	return s
}

func (s *DescribeVodUserDomainsResponseBodyDomainsPageData) SetDescription(v string) *DescribeVodUserDomainsResponseBodyDomainsPageData {
	s.Description = &v
	return s
}

func (s *DescribeVodUserDomainsResponseBodyDomainsPageData) SetDomainName(v string) *DescribeVodUserDomainsResponseBodyDomainsPageData {
	s.DomainName = &v
	return s
}

func (s *DescribeVodUserDomainsResponseBodyDomainsPageData) SetDomainStatus(v string) *DescribeVodUserDomainsResponseBodyDomainsPageData {
	s.DomainStatus = &v
	return s
}

func (s *DescribeVodUserDomainsResponseBodyDomainsPageData) SetGmtCreated(v string) *DescribeVodUserDomainsResponseBodyDomainsPageData {
	s.GmtCreated = &v
	return s
}

func (s *DescribeVodUserDomainsResponseBodyDomainsPageData) SetGmtModified(v string) *DescribeVodUserDomainsResponseBodyDomainsPageData {
	s.GmtModified = &v
	return s
}

func (s *DescribeVodUserDomainsResponseBodyDomainsPageData) SetSandbox(v string) *DescribeVodUserDomainsResponseBodyDomainsPageData {
	s.Sandbox = &v
	return s
}

func (s *DescribeVodUserDomainsResponseBodyDomainsPageData) SetSources(v *DescribeVodUserDomainsResponseBodyDomainsPageDataSources) *DescribeVodUserDomainsResponseBodyDomainsPageData {
	s.Sources = v
	return s
}

func (s *DescribeVodUserDomainsResponseBodyDomainsPageData) SetSslProtocol(v string) *DescribeVodUserDomainsResponseBodyDomainsPageData {
	s.SslProtocol = &v
	return s
}

type DescribeVodUserDomainsResponseBodyDomainsPageDataSources struct {
	Source []*DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource `json:"Source,omitempty" xml:"Source,omitempty" type:"Repeated"`
}

func (s DescribeVodUserDomainsResponseBodyDomainsPageDataSources) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodUserDomainsResponseBodyDomainsPageDataSources) GoString() string {
	return s.String()
}

func (s *DescribeVodUserDomainsResponseBodyDomainsPageDataSources) SetSource(v []*DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource) *DescribeVodUserDomainsResponseBodyDomainsPageDataSources {
	s.Source = v
	return s
}

type DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource struct {
	// The address of the origin server.
	//
	// example:
	//
	// 192.168.0.1
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The port number. Valid values: **443*	- and **80**.
	//
	// example:
	//
	// 80
	Port *int32 `json:"Port,omitempty" xml:"Port,omitempty"`
	// The priority of the origin server.
	//
	// example:
	//
	// 5
	Priority *string `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The type of the origin server. Valid values:
	//
	// 	- **ipaddr**: an IP address.
	//
	// 	- **domain**: an origin domain name
	//
	// 	- **oss**: the OSS domain of an Object Storage Service (OSS) bucket
	//
	// example:
	//
	// oss
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource) GoString() string {
	return s.String()
}

func (s *DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource) SetContent(v string) *DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource {
	s.Content = &v
	return s
}

func (s *DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource) SetPort(v int32) *DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource {
	s.Port = &v
	return s
}

func (s *DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource) SetPriority(v string) *DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource {
	s.Priority = &v
	return s
}

func (s *DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource) SetType(v string) *DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource {
	s.Type = &v
	return s
}

type DescribeVodUserDomainsResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodUserDomainsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodUserDomainsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodUserDomainsResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodUserDomainsResponse) SetHeaders(v map[string]*string) *DescribeVodUserDomainsResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodUserDomainsResponse) SetStatusCode(v int32) *DescribeVodUserDomainsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodUserDomainsResponse) SetBody(v *DescribeVodUserDomainsResponseBody) *DescribeVodUserDomainsResponse {
	s.Body = v
	return s
}

type DescribeVodVerifyContentRequest struct {
	// The domain name for which you want to verify the ownership. You can specify only one domain name in each call.
	//
	// This parameter is required.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId    *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
}

func (s DescribeVodVerifyContentRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodVerifyContentRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodVerifyContentRequest) SetDomainName(v string) *DescribeVodVerifyContentRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodVerifyContentRequest) SetOwnerId(v int64) *DescribeVodVerifyContentRequest {
	s.OwnerId = &v
	return s
}

type DescribeVodVerifyContentResponseBody struct {
	// The verification content.
	//
	// example:
	//
	// verify_dffeb661*****3a59c31cd91f
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// 34AB41F1-04A5-4688-634BDBE6****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeVodVerifyContentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodVerifyContentResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodVerifyContentResponseBody) SetContent(v string) *DescribeVodVerifyContentResponseBody {
	s.Content = &v
	return s
}

func (s *DescribeVodVerifyContentResponseBody) SetRequestId(v string) *DescribeVodVerifyContentResponseBody {
	s.RequestId = &v
	return s
}

type DescribeVodVerifyContentResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DescribeVodVerifyContentResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DescribeVodVerifyContentResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodVerifyContentResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodVerifyContentResponse) SetHeaders(v map[string]*string) *DescribeVodVerifyContentResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodVerifyContentResponse) SetStatusCode(v int32) *DescribeVodVerifyContentResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodVerifyContentResponse) SetBody(v *DescribeVodVerifyContentResponseBody) *DescribeVodVerifyContentResponse {
	s.Body = v
	return s
}

type DetachAppPolicyFromIdentityRequest struct {
	// The ID of the application. This parameter is optional if you set PolicyNames to VODAppAdministratorAccess. This parameter is required if you set PolicyNames to a value other than VODAppAdministratorAccess.
	//
	// 	- Default value: **app-1000000**.
	//
	// 	- For more information, see [Overview](https://help.aliyun.com/document_detail/113600.html).
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the RAM user or the name of the RAM role.
	//
	// 	- Specifies the ID of the RAM user for this parameter if you set IdentityType to RamUser.
	//
	// 	- Specifies the name of the RAM role for this parameter if you set IdentityType to RamRole.
	//
	// This parameter is required.
	//
	// example:
	//
	// test****name
	IdentityName *string `json:"IdentityName,omitempty" xml:"IdentityName,omitempty"`
	// The type of the identity. Valid values:
	//
	// 	- **RamUser**: RAM user
	//
	// 	- **RamRole**: RAM role
	//
	// This parameter is required.
	//
	// example:
	//
	// RamUser
	IdentityType *string `json:"IdentityType,omitempty" xml:"IdentityType,omitempty"`
	// The name of the policy. Separate multiple names with commas (,). Only system policies are supported.
	//
	// 	- **VODAppFullAccess**: permissions to manage all resources in an application
	//
	// 	- **VODAppReadOnlyAccess**: permissions to read all resources in an application
	//
	// 	- **VODAppAdministratorAccess**: permissions of the application administrator
	//
	// This parameter is required.
	//
	// example:
	//
	// VODAppFullAccess
	PolicyNames *string `json:"PolicyNames,omitempty" xml:"PolicyNames,omitempty"`
}

func (s DetachAppPolicyFromIdentityRequest) String() string {
	return tea.Prettify(s)
}

func (s DetachAppPolicyFromIdentityRequest) GoString() string {
	return s.String()
}

func (s *DetachAppPolicyFromIdentityRequest) SetAppId(v string) *DetachAppPolicyFromIdentityRequest {
	s.AppId = &v
	return s
}

func (s *DetachAppPolicyFromIdentityRequest) SetIdentityName(v string) *DetachAppPolicyFromIdentityRequest {
	s.IdentityName = &v
	return s
}

func (s *DetachAppPolicyFromIdentityRequest) SetIdentityType(v string) *DetachAppPolicyFromIdentityRequest {
	s.IdentityType = &v
	return s
}

func (s *DetachAppPolicyFromIdentityRequest) SetPolicyNames(v string) *DetachAppPolicyFromIdentityRequest {
	s.PolicyNames = &v
	return s
}

type DetachAppPolicyFromIdentityResponseBody struct {
	// The names of the policies that failed to be granted to the RAM user or RAM role.
	FailedPolicyNames []*string `json:"FailedPolicyNames,omitempty" xml:"FailedPolicyNames,omitempty" type:"Repeated"`
	// The name of the policy that was not found.
	NonExistPolicyNames []*string `json:"NonExistPolicyNames,omitempty" xml:"NonExistPolicyNames,omitempty" type:"Repeated"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A13-****-D7393642C
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DetachAppPolicyFromIdentityResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DetachAppPolicyFromIdentityResponseBody) GoString() string {
	return s.String()
}

func (s *DetachAppPolicyFromIdentityResponseBody) SetFailedPolicyNames(v []*string) *DetachAppPolicyFromIdentityResponseBody {
	s.FailedPolicyNames = v
	return s
}

func (s *DetachAppPolicyFromIdentityResponseBody) SetNonExistPolicyNames(v []*string) *DetachAppPolicyFromIdentityResponseBody {
	s.NonExistPolicyNames = v
	return s
}

func (s *DetachAppPolicyFromIdentityResponseBody) SetRequestId(v string) *DetachAppPolicyFromIdentityResponseBody {
	s.RequestId = &v
	return s
}

type DetachAppPolicyFromIdentityResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DetachAppPolicyFromIdentityResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DetachAppPolicyFromIdentityResponse) String() string {
	return tea.Prettify(s)
}

func (s DetachAppPolicyFromIdentityResponse) GoString() string {
	return s.String()
}

func (s *DetachAppPolicyFromIdentityResponse) SetHeaders(v map[string]*string) *DetachAppPolicyFromIdentityResponse {
	s.Headers = v
	return s
}

func (s *DetachAppPolicyFromIdentityResponse) SetStatusCode(v int32) *DetachAppPolicyFromIdentityResponse {
	s.StatusCode = &v
	return s
}

func (s *DetachAppPolicyFromIdentityResponse) SetBody(v *DetachAppPolicyFromIdentityResponseBody) *DetachAppPolicyFromIdentityResponse {
	s.Body = v
	return s
}

type GenerateDownloadSecretKeyRequest struct {
	// A custom string of 16 to 32 characters in length. The string must contain uppercase letters, lowercase letters, and digits.
	//
	// This parameter is required.
	//
	// example:
	//
	// AppDecryptKeyAndroid20230101
	AppDecryptKey *string `json:"AppDecryptKey,omitempty" xml:"AppDecryptKey,omitempty"`
	// The unique identifier of the app.
	//
	// 	- Android: the SHA-1 fingerprint of the keystore. The value is a string that contains a colon (:).
	//
	// 	- iOS: the bundle ID of the app.
	//
	// 	- Windows: the serial number in the digital signature certificate.
	//
	// For more information about how to obtain the unique identifier of an app, see [Obtain the unique app identifier](~~86107#section-wtj-9d7-lg2~~).
	//
	// This parameter is required.
	//
	// example:
	//
	// BB:0D:AC:74:D3:21:09:EF:9C:71:1A:5E:77:2C:8E:BF:03:FD:FA:5A
	AppIdentification    *string `json:"AppIdentification,omitempty" xml:"AppIdentification,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GenerateDownloadSecretKeyRequest) String() string {
	return tea.Prettify(s)
}

func (s GenerateDownloadSecretKeyRequest) GoString() string {
	return s.String()
}

func (s *GenerateDownloadSecretKeyRequest) SetAppDecryptKey(v string) *GenerateDownloadSecretKeyRequest {
	s.AppDecryptKey = &v
	return s
}

func (s *GenerateDownloadSecretKeyRequest) SetAppIdentification(v string) *GenerateDownloadSecretKeyRequest {
	s.AppIdentification = &v
	return s
}

func (s *GenerateDownloadSecretKeyRequest) SetOwnerId(v int64) *GenerateDownloadSecretKeyRequest {
	s.OwnerId = &v
	return s
}

func (s *GenerateDownloadSecretKeyRequest) SetResourceOwnerAccount(v string) *GenerateDownloadSecretKeyRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GenerateDownloadSecretKeyRequest) SetResourceOwnerId(v int64) *GenerateDownloadSecretKeyRequest {
	s.ResourceOwnerId = &v
	return s
}

type GenerateDownloadSecretKeyResponseBody struct {
	// The key file for secure download.
	//
	// example:
	//
	// ***
	AppEncryptKey *string `json:"AppEncryptKey,omitempty" xml:"AppEncryptKey,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// E99B9BAD-7F9D-552B-A689-B72E92EA040E
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GenerateDownloadSecretKeyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GenerateDownloadSecretKeyResponseBody) GoString() string {
	return s.String()
}

func (s *GenerateDownloadSecretKeyResponseBody) SetAppEncryptKey(v string) *GenerateDownloadSecretKeyResponseBody {
	s.AppEncryptKey = &v
	return s
}

func (s *GenerateDownloadSecretKeyResponseBody) SetRequestId(v string) *GenerateDownloadSecretKeyResponseBody {
	s.RequestId = &v
	return s
}

type GenerateDownloadSecretKeyResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GenerateDownloadSecretKeyResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GenerateDownloadSecretKeyResponse) String() string {
	return tea.Prettify(s)
}

func (s GenerateDownloadSecretKeyResponse) GoString() string {
	return s.String()
}

func (s *GenerateDownloadSecretKeyResponse) SetHeaders(v map[string]*string) *GenerateDownloadSecretKeyResponse {
	s.Headers = v
	return s
}

func (s *GenerateDownloadSecretKeyResponse) SetStatusCode(v int32) *GenerateDownloadSecretKeyResponse {
	s.StatusCode = &v
	return s
}

func (s *GenerateDownloadSecretKeyResponse) SetBody(v *GenerateDownloadSecretKeyResponseBody) *GenerateDownloadSecretKeyResponse {
	s.Body = v
	return s
}

type GenerateKMSDataKeyRequest struct {
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GenerateKMSDataKeyRequest) String() string {
	return tea.Prettify(s)
}

func (s GenerateKMSDataKeyRequest) GoString() string {
	return s.String()
}

func (s *GenerateKMSDataKeyRequest) SetOwnerAccount(v string) *GenerateKMSDataKeyRequest {
	s.OwnerAccount = &v
	return s
}

func (s *GenerateKMSDataKeyRequest) SetOwnerId(v string) *GenerateKMSDataKeyRequest {
	s.OwnerId = &v
	return s
}

func (s *GenerateKMSDataKeyRequest) SetResourceOwnerAccount(v string) *GenerateKMSDataKeyRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GenerateKMSDataKeyRequest) SetResourceOwnerId(v string) *GenerateKMSDataKeyRequest {
	s.ResourceOwnerId = &v
	return s
}

type GenerateKMSDataKeyResponseBody struct {
	// The ciphertext of the encrypted data key. This is used as CipherText when you create a transcoding job.
	//
	// example:
	//
	// ODZhOWVmZDktM2QxNi00ODk0LWJkNGYtMWZjNDNmM2YyYWJmS7FmDBBQ0BkKsQrtRnidtPwirmDcS0ZuJCU41xxAAWk4Z8qsADfbV0b+i6kQmlvj79dJdGOvtX69Uycs901qOjop4bTS****
	CiphertextBlob *string `json:"CiphertextBlob,omitempty" xml:"CiphertextBlob,omitempty"`
	// The ID of the customer master key (CMK). The ID must be globally unique.
	//
	// example:
	//
	// 7906979c-8e06-46a2-be2d-68e3ccbc****
	KeyId *string `json:"KeyId,omitempty" xml:"KeyId,omitempty"`
	// The Base64-encoded plaintext of the data key.
	//
	// example:
	//
	// QmFzZTY0IGVuY29kZWQgcGxhaW50****
	Plaintext *string `json:"Plaintext,omitempty" xml:"Plaintext,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A*****F6-D7393642CA58
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GenerateKMSDataKeyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GenerateKMSDataKeyResponseBody) GoString() string {
	return s.String()
}

func (s *GenerateKMSDataKeyResponseBody) SetCiphertextBlob(v string) *GenerateKMSDataKeyResponseBody {
	s.CiphertextBlob = &v
	return s
}

func (s *GenerateKMSDataKeyResponseBody) SetKeyId(v string) *GenerateKMSDataKeyResponseBody {
	s.KeyId = &v
	return s
}

func (s *GenerateKMSDataKeyResponseBody) SetPlaintext(v string) *GenerateKMSDataKeyResponseBody {
	s.Plaintext = &v
	return s
}

func (s *GenerateKMSDataKeyResponseBody) SetRequestId(v string) *GenerateKMSDataKeyResponseBody {
	s.RequestId = &v
	return s
}

type GenerateKMSDataKeyResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GenerateKMSDataKeyResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GenerateKMSDataKeyResponse) String() string {
	return tea.Prettify(s)
}

func (s GenerateKMSDataKeyResponse) GoString() string {
	return s.String()
}

func (s *GenerateKMSDataKeyResponse) SetHeaders(v map[string]*string) *GenerateKMSDataKeyResponse {
	s.Headers = v
	return s
}

func (s *GenerateKMSDataKeyResponse) SetStatusCode(v int32) *GenerateKMSDataKeyResponse {
	s.StatusCode = &v
	return s
}

func (s *GenerateKMSDataKeyResponse) SetBody(v *GenerateKMSDataKeyResponseBody) *GenerateKMSDataKeyResponse {
	s.Body = v
	return s
}

type GetAIImageJobsRequest struct {
	// The ID of the image AI processing job. You can obtain the value of JobId from the response to the [SubmitAIImageJob](~~SubmitAIImageJob~~) operation.
	//
	// 	- You can specify a maximum of 10 IDs.
	//
	// 	- Separate multiple IDs with commas (,).
	//
	// This parameter is required.
	//
	// example:
	//
	// cf08a2c6e11e*****de1711b738b9067
	JobIds               *string `json:"JobIds,omitempty" xml:"JobIds,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GetAIImageJobsRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAIImageJobsRequest) GoString() string {
	return s.String()
}

func (s *GetAIImageJobsRequest) SetJobIds(v string) *GetAIImageJobsRequest {
	s.JobIds = &v
	return s
}

func (s *GetAIImageJobsRequest) SetOwnerAccount(v string) *GetAIImageJobsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *GetAIImageJobsRequest) SetOwnerId(v string) *GetAIImageJobsRequest {
	s.OwnerId = &v
	return s
}

func (s *GetAIImageJobsRequest) SetResourceOwnerAccount(v string) *GetAIImageJobsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GetAIImageJobsRequest) SetResourceOwnerId(v string) *GetAIImageJobsRequest {
	s.ResourceOwnerId = &v
	return s
}

type GetAIImageJobsResponseBody struct {
	// The image AI processing jobs.
	AIImageJobList []*GetAIImageJobsResponseBodyAIImageJobList `json:"AIImageJobList,omitempty" xml:"AIImageJobList,omitempty" type:"Repeated"`
	// The ID of the request.
	//
	// example:
	//
	// 7721B494-1F78-4E*****E8-A7CEE7315BFA
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetAIImageJobsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAIImageJobsResponseBody) GoString() string {
	return s.String()
}

func (s *GetAIImageJobsResponseBody) SetAIImageJobList(v []*GetAIImageJobsResponseBodyAIImageJobList) *GetAIImageJobsResponseBody {
	s.AIImageJobList = v
	return s
}

func (s *GetAIImageJobsResponseBody) SetRequestId(v string) *GetAIImageJobsResponseBody {
	s.RequestId = &v
	return s
}

type GetAIImageJobsResponseBodyAIImageJobList struct {
	// The Object Storage Service (OSS) URL of the image file.
	//
	// > This parameter does not include the complete authentication information. To obtain the authentication information, you must generate a signed URL. Alternatively, you can call the [ListAIImageInfo](~~ListAIImageInfo~~) operation to obtain the image information.
	//
	// example:
	//
	// [{"Score":5.035636554444242,"Url":"http://outin-*****.oss-cn-shanghai.aliyuncs.com/357a8748c577*****789d2726e6436aa/image/ai/b0a7612554d*****5cbe3-00001.gif"}]
	AIImageResult *string `json:"AIImageResult,omitempty" xml:"AIImageResult,omitempty"`
	// The error code.
	//
	// example:
	//
	// Success
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The time when the image AI processing job was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2020-10-15T03:30:03Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The ID of the image AI processing job.
	//
	// example:
	//
	// cf08a2c6e11e*****de1711b738b9067
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The error message.
	//
	// example:
	//
	// success
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The status of the job. Valid values:
	//
	// 	- **success**
	//
	// 	- **fail**
	//
	// example:
	//
	// success
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The configurations of the AI template that was used to submit the job.
	//
	// example:
	//
	// {"Format":"gif","SetDefaultCover":"true"}
	TemplateConfig *string `json:"TemplateConfig,omitempty" xml:"TemplateConfig,omitempty"`
	// The ID of the AI template.
	//
	// example:
	//
	// 5a86a00f15194*****d7fe7de1b4a173
	TemplateId *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The user data.
	//
	// 	- The value must be a JSON string.
	//
	// 	- The MessageCallback or Extend parameter is returned.
	//
	// 	- The value contains a maximum of 512 bytes.
	//
	// For more information, see the "UserData: specifies the custom configurations for media upload" section of the [Request parameters](https://help.aliyun.com/document_detail/86952.html) topic.
	//
	// example:
	//
	// {"Extend":{"localId":"****","test":"www"}}
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
	// The ID of the video.
	//
	// example:
	//
	// 357a8748c577*****789d2726e6436aa
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s GetAIImageJobsResponseBodyAIImageJobList) String() string {
	return tea.Prettify(s)
}

func (s GetAIImageJobsResponseBodyAIImageJobList) GoString() string {
	return s.String()
}

func (s *GetAIImageJobsResponseBodyAIImageJobList) SetAIImageResult(v string) *GetAIImageJobsResponseBodyAIImageJobList {
	s.AIImageResult = &v
	return s
}

func (s *GetAIImageJobsResponseBodyAIImageJobList) SetCode(v string) *GetAIImageJobsResponseBodyAIImageJobList {
	s.Code = &v
	return s
}

func (s *GetAIImageJobsResponseBodyAIImageJobList) SetCreationTime(v string) *GetAIImageJobsResponseBodyAIImageJobList {
	s.CreationTime = &v
	return s
}

func (s *GetAIImageJobsResponseBodyAIImageJobList) SetJobId(v string) *GetAIImageJobsResponseBodyAIImageJobList {
	s.JobId = &v
	return s
}

func (s *GetAIImageJobsResponseBodyAIImageJobList) SetMessage(v string) *GetAIImageJobsResponseBodyAIImageJobList {
	s.Message = &v
	return s
}

func (s *GetAIImageJobsResponseBodyAIImageJobList) SetStatus(v string) *GetAIImageJobsResponseBodyAIImageJobList {
	s.Status = &v
	return s
}

func (s *GetAIImageJobsResponseBodyAIImageJobList) SetTemplateConfig(v string) *GetAIImageJobsResponseBodyAIImageJobList {
	s.TemplateConfig = &v
	return s
}

func (s *GetAIImageJobsResponseBodyAIImageJobList) SetTemplateId(v string) *GetAIImageJobsResponseBodyAIImageJobList {
	s.TemplateId = &v
	return s
}

func (s *GetAIImageJobsResponseBodyAIImageJobList) SetUserData(v string) *GetAIImageJobsResponseBodyAIImageJobList {
	s.UserData = &v
	return s
}

func (s *GetAIImageJobsResponseBodyAIImageJobList) SetVideoId(v string) *GetAIImageJobsResponseBodyAIImageJobList {
	s.VideoId = &v
	return s
}

type GetAIImageJobsResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetAIImageJobsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetAIImageJobsResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAIImageJobsResponse) GoString() string {
	return s.String()
}

func (s *GetAIImageJobsResponse) SetHeaders(v map[string]*string) *GetAIImageJobsResponse {
	s.Headers = v
	return s
}

func (s *GetAIImageJobsResponse) SetStatusCode(v int32) *GetAIImageJobsResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAIImageJobsResponse) SetBody(v *GetAIImageJobsResponseBody) *GetAIImageJobsResponse {
	s.Body = v
	return s
}

type GetAIMediaAuditJobRequest struct {
	// The ID of the intelligent review job.
	//
	// This parameter is required.
	//
	// example:
	//
	// bdbc266af6894*****943a70176d92e9
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
}

func (s GetAIMediaAuditJobRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobRequest) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobRequest) SetJobId(v string) *GetAIMediaAuditJobRequest {
	s.JobId = &v
	return s
}

type GetAIMediaAuditJobResponseBody struct {
	// The information about the intelligent review job.
	MediaAuditJob *GetAIMediaAuditJobResponseBodyMediaAuditJob `json:"MediaAuditJob,omitempty" xml:"MediaAuditJob,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// EAA3E96A-02E2-41*****85-08E1D568ED3A
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetAIMediaAuditJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBody) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBody) SetMediaAuditJob(v *GetAIMediaAuditJobResponseBodyMediaAuditJob) *GetAIMediaAuditJobResponseBody {
	s.MediaAuditJob = v
	return s
}

func (s *GetAIMediaAuditJobResponseBody) SetRequestId(v string) *GetAIMediaAuditJobResponseBody {
	s.RequestId = &v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJob struct {
	// The error code. This parameter is returned if the value of Status is fail.
	//
	// example:
	//
	// 0
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The time when the job is complete. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-01-11T13:00:00Z
	CompleteTime *string `json:"CompleteTime,omitempty" xml:"CompleteTime,omitempty"`
	// The time when the job started to run. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-01-11T12:00:00Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The job result.
	Data *GetAIMediaAuditJobResponseBodyMediaAuditJobData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the job.
	//
	// example:
	//
	// bdbc266af6894*****943a70176d92e9
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The ID of the video.
	//
	// example:
	//
	// fe028d09441d*****d1afffb138cd7e
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The error message. This parameter is returned if the value of Status is fail.
	//
	// example:
	//
	// OK
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The status of the job. Valid values:
	//
	// 	- **success**: The job is successful.
	//
	// 	- **fail**: The job failed.
	//
	// 	- **init**: The job is being initialized.
	//
	// 	- **Processing**: The job is in progress.
	//
	// example:
	//
	// success
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the job. The value is AIMediaAudit.
	//
	// example:
	//
	// AIMediaAudit
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJob) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJob) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJob) SetCode(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJob {
	s.Code = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJob) SetCompleteTime(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJob {
	s.CompleteTime = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJob) SetCreationTime(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJob {
	s.CreationTime = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJob) SetData(v *GetAIMediaAuditJobResponseBodyMediaAuditJobData) *GetAIMediaAuditJobResponseBodyMediaAuditJob {
	s.Data = v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJob) SetJobId(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJob {
	s.JobId = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJob) SetMediaId(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJob {
	s.MediaId = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJob) SetMessage(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJob {
	s.Message = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJob) SetStatus(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJob {
	s.Status = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJob) SetType(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJob {
	s.Type = &v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobData struct {
	// The content that violates the regulations. Separate multiple values with commas (,). Valid values:
	//
	// 	- **video**: the video.
	//
	// 	- **image-cover**: the cover.
	//
	// 	- **text-title**: the title.
	//
	// example:
	//
	// video
	AbnormalModules *string `json:"AbnormalModules,omitempty" xml:"AbnormalModules,omitempty"`
	// The results of audio review.
	AudioResult []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult `json:"AudioResult,omitempty" xml:"AudioResult,omitempty" type:"Repeated"`
	// The results of image review.
	ImageResult []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult `json:"ImageResult,omitempty" xml:"ImageResult,omitempty" type:"Repeated"`
	// The category of the review result. Multiple values are separated by commas (,). Valid values:
	//
	// 	- **porn**: pornographic content
	//
	// 	- **terrorism**: terrorist or politically sensitive content
	//
	// 	- **ad**: ad violation
	//
	// 	- **live**: undesirable scene
	//
	// 	- **logo**: logo
	//
	// 	- **audio**: audio anti-spam
	//
	// 	- **normal**: normal content
	//
	// example:
	//
	// normal
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The recommendation for review results. Valid values:
	//
	// 	- **block**: The content violates the regulations.
	//
	// 	- **review**: The content may violate the regulations.
	//
	// 	- **pass**: The content passes the review.
	//
	// example:
	//
	// pass
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The text moderation results.
	TextResult []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult `json:"TextResult,omitempty" xml:"TextResult,omitempty" type:"Repeated"`
	// The results of video review.
	VideoResult *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult `json:"VideoResult,omitempty" xml:"VideoResult,omitempty" type:"Struct"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobData) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobData) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobData) SetAbnormalModules(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobData {
	s.AbnormalModules = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobData) SetAudioResult(v []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult) *GetAIMediaAuditJobResponseBodyMediaAuditJobData {
	s.AudioResult = v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobData) SetImageResult(v []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult) *GetAIMediaAuditJobResponseBodyMediaAuditJobData {
	s.ImageResult = v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobData) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobData {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobData) SetSuggestion(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobData {
	s.Suggestion = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobData) SetTextResult(v []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult) *GetAIMediaAuditJobResponseBodyMediaAuditJobData {
	s.TextResult = v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobData) SetVideoResult(v *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult) *GetAIMediaAuditJobResponseBodyMediaAuditJobData {
	s.VideoResult = v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult struct {
	// The category of the review result.
	//
	// 	- **normal**: normal content
	//
	// 	- **spam**: spam
	//
	// 	- **ad**: ads
	//
	// 	- **politics**: political content
	//
	// 	- **terrorism**: terrorist content
	//
	// 	- **abuse**: abuse
	//
	// 	- **porn**: pornographic content.
	//
	// 	- **flood**: excessive junk content
	//
	// 	- **contraband**: prohibited content
	//
	// 	- **meaningless**: meaningless content
	//
	// example:
	//
	// normal
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The review scenario. The value is **antispam**.
	//
	// example:
	//
	// antispam
	Scene *string `json:"Scene,omitempty" xml:"Scene,omitempty"`
	// The score.
	//
	// example:
	//
	// 99.91
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The recommendation for review results. Valid values:
	//
	// 	- **block**
	//
	// 	- **review**
	//
	// 	- **pass**
	//
	// example:
	//
	// pass
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult) SetScene(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult {
	s.Scene = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult) SetScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult {
	s.Score = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult) SetSuggestion(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult {
	s.Suggestion = &v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult struct {
	// The categories of the image review results. Multiple values are separated by commas (,). Valid values:
	//
	// 	- **porn**: pornographic content
	//
	// 	- **terrorism**: terrorist or politically sensitive content
	//
	// 	- **ad**: ad violation
	//
	// 	- **live**: undesirable scene
	//
	// 	- **logo**: logo
	//
	// 	- **normal**: normal content
	//
	// example:
	//
	// normal
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// Details of image review results.
	Result []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// The recommendation for review results. Valid values:
	//
	// 	- **block**
	//
	// 	- **review**
	//
	// 	- **pass**
	//
	// example:
	//
	// pass
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The type of the image. Valid value: **cover**.
	//
	// example:
	//
	// cover
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The URL of the image.
	//
	// example:
	//
	// http://www.test.com/****.jpg
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult) SetResult(v []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult {
	s.Result = v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult) SetSuggestion(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult {
	s.Suggestion = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult) SetType(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult {
	s.Type = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult) SetUrl(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult {
	s.Url = &v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult struct {
	// The category of the review result.
	//
	// Valid values if scene is **porn**:
	//
	// 	- **porn**
	//
	// 	- **sexy**
	//
	// 	- **normal**
	//
	// Valid values if scene is **terrorism**:
	//
	// 	- **normal**
	//
	// 	- **bloody**
	//
	// 	- **explosion**
	//
	// 	- **outfit**
	//
	// 	- **logo**
	//
	// 	- **weapon**
	//
	// 	- **politics**
	//
	// 	- **violence**
	//
	// 	- **crowd**
	//
	// 	- **parade**
	//
	// 	- **carcrash**
	//
	// 	- **flag**
	//
	// 	- **location**
	//
	// 	- **others**
	//
	// Valid values if scene is **ad**:
	//
	// 	- **normal**: normal content
	//
	// 	- **ad**: ads
	//
	// 	- **politics**: political content
	//
	// 	- **porn**: pornographic content
	//
	// 	- **abuse**: verbal abuse
	//
	// 	- **terrorism**: terrorist content
	//
	// 	- **contraband**: prohibited content
	//
	// 	- **spam**: spam content
	//
	// 	- **npx**: illegal ad
	//
	// 	- **qrcode**: QR code
	//
	// 	- **programCode**: mini program code
	//
	// Valid values if scene is **live**:
	//
	// 	- **normal**: normal content
	//
	// 	- **meaningless**: meaningless content, such as a black or white screen.
	//
	// 	- **PIP**: picture-in-picture
	//
	// 	- **smoking**: smoking
	//
	// 	- **drivelive**: live broadcasting in a running vehicle
	//
	// Valid values if scene is **logo**:
	//
	// 	- **normal**: normal content
	//
	// 	- **TV**: controlled TV station logo
	//
	// 	- **trademark**: trademark
	//
	// example:
	//
	// porn
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The review scenario. Valid values:
	//
	// 	- **porn**: pornographic content
	//
	// 	- **terrorism**: terrorist or politically sensitive content
	//
	// 	- **ad**: ad violation
	//
	// 	- **live**: undesirable scene
	//
	// 	- **logo**: logo
	//
	// example:
	//
	// porn
	Scene *string `json:"Scene,omitempty" xml:"Scene,omitempty"`
	// The score of the image of the category that is indicated by Label. Valid values: `[0, 100]`. The score is representative of the confidence.
	//
	// example:
	//
	// 0
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The recommendation for review results. Valid values:
	//
	// 	- **block**
	//
	// 	- **review**
	//
	// 	- **pass**
	//
	// example:
	//
	// pass
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult) SetScene(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult {
	s.Scene = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult) SetScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult {
	s.Score = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult) SetSuggestion(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult {
	s.Suggestion = &v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult struct {
	// The text content.
	//
	// example:
	//
	// Test
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The category of the review result. Valid values:
	//
	// 	- **spam**: spam content
	//
	// 	- **ad**: ads
	//
	// 	- **abuse**: abuse
	//
	// 	- **flood**: excessive junk content
	//
	// 	- **contraband**: prohibited content
	//
	// 	- **meaningless**: meaningless content
	//
	// 	- **normal**: normal content
	//
	// example:
	//
	// ad
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The review scenario. The value is **antispam**.
	//
	// example:
	//
	// antispam
	Scene *string `json:"Scene,omitempty" xml:"Scene,omitempty"`
	// The score of the image of the category that is indicated by Label. Valid values: `[0, 100]`. The score is representative of the confidence.
	//
	// example:
	//
	// 100
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The recommendation for review results. Valid values:
	//
	// 	- **block**
	//
	// 	- **review**
	//
	// 	- **pass**
	//
	// example:
	//
	// pass
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The type of the text. The value is **title**.
	//
	// example:
	//
	// title
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult) SetContent(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult {
	s.Content = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult) SetScene(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult {
	s.Scene = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult) SetScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult {
	s.Score = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult) SetSuggestion(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult {
	s.Suggestion = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult) SetType(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult {
	s.Type = &v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult struct {
	// The results of ad review.
	AdResult *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult `json:"AdResult,omitempty" xml:"AdResult,omitempty" type:"Struct"`
	// The category of the review result. Valid values:
	//
	// 	- **porn**: pornographic content
	//
	// 	- **terrorism**: terrorist or politically sensitive content
	//
	// 	- **ad**: ad violation
	//
	// 	- **live**: undesirable scene
	//
	// 	- **logo**: logo
	//
	// 	- **normal**
	//
	// example:
	//
	// normal
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The results of undesired content review.
	LiveResult *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult `json:"LiveResult,omitempty" xml:"LiveResult,omitempty" type:"Struct"`
	// The results of logo review.
	LogoResult *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult `json:"LogoResult,omitempty" xml:"LogoResult,omitempty" type:"Struct"`
	// The results of pornographic content review.
	PornResult *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult `json:"PornResult,omitempty" xml:"PornResult,omitempty" type:"Struct"`
	// The recommendation for video review results. Valid values:
	//
	// 	- **block**
	//
	// 	- **review**
	//
	// 	- **pass**
	//
	// example:
	//
	// pass
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The results of terrorist content review.
	TerrorismResult *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult `json:"TerrorismResult,omitempty" xml:"TerrorismResult,omitempty" type:"Struct"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult) SetAdResult(v *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult {
	s.AdResult = v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult) SetLiveResult(v *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult {
	s.LiveResult = v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult) SetLogoResult(v *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult {
	s.LogoResult = v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult) SetPornResult(v *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult {
	s.PornResult = v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult) SetSuggestion(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult {
	s.Suggestion = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult) SetTerrorismResult(v *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult {
	s.TerrorismResult = v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult struct {
	// The average score of the review results.
	//
	// example:
	//
	// 100
	AverageScore *string `json:"AverageScore,omitempty" xml:"AverageScore,omitempty"`
	// The number of snapshots of each category in the review result.
	CounterList []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultCounterList `json:"CounterList,omitempty" xml:"CounterList,omitempty" type:"Repeated"`
	// The categories of the ad review results. Valid values:
	//
	// 	- **normal**: normal content
	//
	// 	- **ad**: other ads
	//
	// 	- **politics**: political content
	//
	// 	- **porn**: pornographic content
	//
	// 	- **abuse**: abuse
	//
	// 	- **terrorism**: terrorist content
	//
	// 	- **contraband**: prohibited content
	//
	// 	- **spam**: spam content
	//
	// 	- **npx**: illegal ad
	//
	// 	- **qrcode**: QR code
	//
	// 	- **programCode**: mini program code
	//
	// example:
	//
	// ad
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The highest review score.
	//
	// example:
	//
	// 100
	MaxScore *string `json:"MaxScore,omitempty" xml:"MaxScore,omitempty"`
	// The recommendation for review results. Valid values:
	//
	// 	- **block**: The content violates the regulations.
	//
	// 	- **review**: The content may violate the regulations.
	//
	// 	- **pass**: The content passes the review.
	//
	// example:
	//
	// block
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The information about the snapshot that has the highest score in the category.
	TopList []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList `json:"TopList,omitempty" xml:"TopList,omitempty" type:"Repeated"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult) SetAverageScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult {
	s.AverageScore = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult) SetCounterList(v []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultCounterList) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult {
	s.CounterList = v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult) SetMaxScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult {
	s.MaxScore = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult) SetSuggestion(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult {
	s.Suggestion = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult) SetTopList(v []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult {
	s.TopList = v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultCounterList struct {
	// The number of video snapshots.
	//
	// example:
	//
	// 10
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The categories of the ad review results. Valid values:
	//
	// 	- **normal**: normal content
	//
	// 	- **ad**: other ads
	//
	// 	- **politics**: political content
	//
	// 	- **porn**: pornographic content
	//
	// 	- **abuse**: abuse
	//
	// 	- **terrorism**: terrorist content
	//
	// 	- **contraband**: prohibited content
	//
	// 	- **spam**: spam content
	//
	// 	- **npx**: illegal ad
	//
	// 	- **qrcode**: QR code
	//
	// 	- **programCode**: mini program code
	//
	// example:
	//
	// ad
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultCounterList) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultCounterList) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultCounterList) SetCount(v int32) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultCounterList {
	s.Count = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultCounterList) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultCounterList {
	s.Label = &v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList struct {
	// The categories of the ad review results. Valid values:
	//
	// 	- **normal**: normal content
	//
	// 	- **ad**: other ads
	//
	// 	- **politics**: political content
	//
	// 	- **porn**: pornographic content
	//
	// 	- **abuse**: abuse
	//
	// 	- **terrorism**: terrorist content
	//
	// 	- **contraband**: prohibited content
	//
	// 	- **spam**: spam content
	//
	// 	- **npx**: illegal ad
	//
	// 	- **qrcode**: QR code
	//
	// 	- **programCode**: mini program code
	//
	// example:
	//
	// ad
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The score of the snapshot in the category that is indicated by Label.
	//
	// example:
	//
	// 100
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The timestamp of the snapshot in the video. Unit: milliseconds.
	//
	// example:
	//
	// 500
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	// The URL of the video snapshot.
	//
	// example:
	//
	// http://temp-****bucket.oss-cn-shanghai.aliyuncs.com/aivideocensor/****.jpg
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList) SetScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList {
	s.Score = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList) SetTimestamp(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList {
	s.Timestamp = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList) SetUrl(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList {
	s.Url = &v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult struct {
	// The average score of the review results.
	//
	// example:
	//
	// 100
	AverageScore *string `json:"AverageScore,omitempty" xml:"AverageScore,omitempty"`
	// The categories of the review results and the number of video snapshots in each category.
	CounterList []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultCounterList `json:"CounterList,omitempty" xml:"CounterList,omitempty" type:"Repeated"`
	// The category of the review result. Valid values:
	//
	// 	- **normal**: normal content
	//
	// 	- **meaningless**: meaningless content, such as a black or white screen.
	//
	// 	- **PIP**: picture-in-picture
	//
	// 	- **smoking**: smoking
	//
	// 	- **drivelive**: live broadcasting in a running vehicle
	//
	// example:
	//
	// live
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The highest review score.
	//
	// example:
	//
	// 100
	MaxScore *string `json:"MaxScore,omitempty" xml:"MaxScore,omitempty"`
	// The recommendation for review results. Valid values:
	//
	// 	- **block**: The content violates the regulations.
	//
	// 	- **review**: The content may violate the regulations.
	//
	// 	- **pass**: The content passes the review.
	//
	// example:
	//
	// block
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The information about the snapshot that has the highest score in the category.
	TopList []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList `json:"TopList,omitempty" xml:"TopList,omitempty" type:"Repeated"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult) SetAverageScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult {
	s.AverageScore = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult) SetCounterList(v []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultCounterList) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult {
	s.CounterList = v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult) SetMaxScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult {
	s.MaxScore = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult) SetSuggestion(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult {
	s.Suggestion = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult) SetTopList(v []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult {
	s.TopList = v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultCounterList struct {
	// The number of video snapshots.
	//
	// example:
	//
	// 0
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The category of the review result. Valid values:
	//
	// 	- **normal**: normal content
	//
	// 	- **meaningless**: meaningless content, such as a black or white screen.
	//
	// 	- **PIP**: picture-in-picture
	//
	// 	- **smoking**: smoking
	//
	// 	- **drivelive**: live broadcasting in a running vehicle
	//
	// example:
	//
	// live
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultCounterList) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultCounterList) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultCounterList) SetCount(v int32) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultCounterList {
	s.Count = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultCounterList) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultCounterList {
	s.Label = &v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList struct {
	// The category of the review result. Valid values:
	//
	// 	- **normal**: normal content
	//
	// 	- **meaningless**: meaningless content, such as a black or white screen.
	//
	// 	- **PIP**: picture-in-picture
	//
	// 	- **smoking**: smoking
	//
	// 	- **drivelive**: live broadcasting in a running vehicle
	//
	// example:
	//
	// live
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The score of the snapshot in the category that is indicated by Label.
	//
	// example:
	//
	// 100
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The timestamp of the snapshot in the video. Unit: milliseconds.
	//
	// example:
	//
	// 500
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	// The URL of the video snapshot.
	//
	// example:
	//
	// http://temp-****bucket.oss-cn-shanghai.aliyuncs.com/aivideocensor/****.jpg
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList) SetScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList {
	s.Score = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList) SetTimestamp(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList {
	s.Timestamp = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList) SetUrl(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList {
	s.Url = &v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult struct {
	// The average score of the snapshots in the category indicated by Label.
	//
	// example:
	//
	// 100
	AverageScore *string `json:"AverageScore,omitempty" xml:"AverageScore,omitempty"`
	// The categories of the review results and the number of video snapshots in each category.
	CounterList []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultCounterList `json:"CounterList,omitempty" xml:"CounterList,omitempty" type:"Repeated"`
	// The category of the review result. Valid values:
	//
	// 	- **normal**: normal content
	//
	// 	- **TV**: controlled TV station logo
	//
	// 	- **trademark**: trademark
	//
	// example:
	//
	// logo
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The highest score of the snapshot of the category that is indicated by Label.
	//
	// example:
	//
	// 100
	MaxScore *string `json:"MaxScore,omitempty" xml:"MaxScore,omitempty"`
	// The recommendation for review results. Valid values:
	//
	// 	- **block**: The content violates the regulations.
	//
	// 	- **review**: The content may violate the regulations.
	//
	// 	- **pass**: The content passes the review.
	//
	// example:
	//
	// block
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The information about the snapshot that has the highest score in the category.
	TopList []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList `json:"TopList,omitempty" xml:"TopList,omitempty" type:"Repeated"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult) SetAverageScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult {
	s.AverageScore = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult) SetCounterList(v []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultCounterList) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult {
	s.CounterList = v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult) SetMaxScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult {
	s.MaxScore = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult) SetSuggestion(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult {
	s.Suggestion = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult) SetTopList(v []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult {
	s.TopList = v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultCounterList struct {
	// The number of video snapshots.
	//
	// example:
	//
	// 2
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The category of the review result. Valid values:
	//
	// 	- **normal**: normal content
	//
	// 	- **TV**: controlled TV station logo
	//
	// 	- **trademark**: trademark
	//
	// example:
	//
	// logo
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultCounterList) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultCounterList) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultCounterList) SetCount(v int32) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultCounterList {
	s.Count = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultCounterList) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultCounterList {
	s.Label = &v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList struct {
	// The category of the review result. Valid values:
	//
	// 	- **normal**: normal content
	//
	// 	- **TV**: controlled TV station logo
	//
	// 	- **trademark**: trademark
	//
	// example:
	//
	// logo
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The score of the snapshot in the category that is indicated by Label.
	//
	// example:
	//
	// 100
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The timestamp of the snapshot in the video. Unit: milliseconds.
	//
	// example:
	//
	// 5000
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	// The URL of the video snapshot.
	//
	// example:
	//
	// http://temp-****bucket.oss-cn-shanghai.aliyuncs.com/aivideocensor/****.jpg
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList) SetScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList {
	s.Score = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList) SetTimestamp(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList {
	s.Timestamp = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList) SetUrl(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList {
	s.Url = &v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult struct {
	// The average score of the snapshots of the category that is indicated by Label. Valid values: `[0, 100]`. The value is accurate to 10 decimal places. The score is representative of the confidence.
	//
	// example:
	//
	// 100
	AverageScore *string `json:"AverageScore,omitempty" xml:"AverageScore,omitempty"`
	// The number of snapshots of each category in the review result.
	CounterList []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultCounterList `json:"CounterList,omitempty" xml:"CounterList,omitempty" type:"Repeated"`
	// The category of the review result. Valid values:
	//
	// 	- **porn**
	//
	// 	- **sexy**
	//
	// 	- **normal**
	//
	// example:
	//
	// porn
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The highest score of the snapshot of the category that is indicated by Label. Valid values: `[0, 100]`. The value is accurate to 10 decimal places. The score is representative of the confidence.
	//
	// example:
	//
	// 100
	MaxScore *string `json:"MaxScore,omitempty" xml:"MaxScore,omitempty"`
	// The recommendation for review results. Valid values:
	//
	// 	- **block**: The content violates the regulations.
	//
	// 	- **review**: The content may violate the regulations.
	//
	// 	- **pass**: The content passes the review.
	//
	// example:
	//
	// pass
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The information about the snapshot that has the highest score in the category.
	TopList []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList `json:"TopList,omitempty" xml:"TopList,omitempty" type:"Repeated"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult) SetAverageScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult {
	s.AverageScore = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult) SetCounterList(v []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultCounterList) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult {
	s.CounterList = v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult) SetMaxScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult {
	s.MaxScore = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult) SetSuggestion(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult {
	s.Suggestion = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult) SetTopList(v []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult {
	s.TopList = v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultCounterList struct {
	// The number of video snapshots.
	//
	// example:
	//
	// 0
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The results of pornographic content review. Valid values:
	//
	// 	- **porn**
	//
	// 	- **sexy**
	//
	// 	- **normal**
	//
	// example:
	//
	// porn
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultCounterList) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultCounterList) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultCounterList) SetCount(v int32) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultCounterList {
	s.Count = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultCounterList) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultCounterList {
	s.Label = &v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList struct {
	// The results of pornographic content review. Valid values:
	//
	// 	- **porn**
	//
	// 	- **sexy**
	//
	// 	- **normal**
	//
	// example:
	//
	// porn
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The score of the snapshot in the category that is indicated by Label. Valid values: `[0, 100]`. The value is accurate to 10 decimal places. The score is representative of the confidence.
	//
	// example:
	//
	// 100
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The timestamp of the snapshot in the video. Unit: milliseconds.
	//
	// example:
	//
	// 3005
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	// The URL of the video snapshot.
	//
	// example:
	//
	// http://temp-****bucket.oss-cn-shanghai.aliyuncs.com/aivideocensor/****.jpg
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList) SetScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList {
	s.Score = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList) SetTimestamp(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList {
	s.Timestamp = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList) SetUrl(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList {
	s.Url = &v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult struct {
	// The average score of the snapshots of the category that is indicated by Label. Valid values: `[0, 100]`. The value is accurate to 10 decimal places. The score is representative of the confidence.
	//
	// example:
	//
	// 100
	AverageScore *string `json:"AverageScore,omitempty" xml:"AverageScore,omitempty"`
	// The categories of terrorist content review results and the number of video snapshots in each category.
	CounterList []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultCounterList `json:"CounterList,omitempty" xml:"CounterList,omitempty" type:"Repeated"`
	// The category of the review result. Valid values:
	//
	// 	- **normal**
	//
	// 	- **bloody**
	//
	// 	- **explosion**
	//
	// 	- **outfit**
	//
	// 	- **logo**
	//
	// 	- **weapon**
	//
	// 	- **politics**
	//
	// 	- **violence**
	//
	// 	- **crowd**
	//
	// 	- **parade**
	//
	// 	- **carcrash**
	//
	// 	- **flag**
	//
	// 	- **location**
	//
	// 	- **others**
	//
	// example:
	//
	// normal
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The highest score of the snapshot of the category that is indicated by Label. Valid values: `[0, 100]`. The value is accurate to 10 decimal places. The score is representative of the confidence.
	//
	// example:
	//
	// 100
	MaxScore *string `json:"MaxScore,omitempty" xml:"MaxScore,omitempty"`
	// The recommendation for terrorist content review results. Valid values:
	//
	// 	- **block**
	//
	// 	- **review**
	//
	// 	- **pass**
	//
	// example:
	//
	// pass
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The information about the snapshot that has the highest score in the category.
	TopList []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList `json:"TopList,omitempty" xml:"TopList,omitempty" type:"Repeated"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult) SetAverageScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult {
	s.AverageScore = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult) SetCounterList(v []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultCounterList) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult {
	s.CounterList = v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult) SetMaxScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult {
	s.MaxScore = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult) SetSuggestion(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult {
	s.Suggestion = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult) SetTopList(v []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult {
	s.TopList = v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultCounterList struct {
	// The number of video snapshots.
	//
	// example:
	//
	// 0
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The results of terrorist content review. Valid values:
	//
	// 	- **normal**
	//
	// 	- **bloody**
	//
	// 	- **explosion**
	//
	// 	- **outfit**
	//
	// 	- **logo**
	//
	// 	- **weapon**
	//
	// 	- **politics**
	//
	// 	- **violence**
	//
	// 	- **crowd**
	//
	// 	- **parade**
	//
	// 	- **carcrash**
	//
	// 	- **flag**
	//
	// 	- **location**
	//
	// 	- **others**
	//
	// example:
	//
	// terrorism
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultCounterList) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultCounterList) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultCounterList) SetCount(v int32) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultCounterList {
	s.Count = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultCounterList) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultCounterList {
	s.Label = &v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList struct {
	// The results of terrorist content review. Valid values:
	//
	// 	- **normal**
	//
	// 	- **bloody**
	//
	// 	- **explosion**
	//
	// 	- **outfit**
	//
	// 	- **logo**
	//
	// 	- **weapon**
	//
	// 	- **politics**
	//
	// 	- **violence**
	//
	// 	- **crowd**
	//
	// 	- **parade**
	//
	// 	- **carcrash**
	//
	// 	- **flag**
	//
	// 	- **location**
	//
	// 	- **others**
	//
	// example:
	//
	// normal
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The score of the snapshot in the category that is indicated by Label. Valid values: `[0, 100]`. The value is accurate to 10 decimal places. The score is representative of the confidence.
	//
	// example:
	//
	// 100
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The timestamp of the snapshot in the video. Unit: milliseconds.
	//
	// example:
	//
	// 5
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	// The URL of the video snapshot.
	//
	// example:
	//
	// http://ali*****.com/aivideocensor/yytysursrutyrxuq/****.jpg
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList) SetScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList {
	s.Score = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList) SetTimestamp(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList {
	s.Timestamp = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList) SetUrl(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList {
	s.Url = &v
	return s
}

type GetAIMediaAuditJobResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetAIMediaAuditJobResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetAIMediaAuditJobResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponse) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponse) SetHeaders(v map[string]*string) *GetAIMediaAuditJobResponse {
	s.Headers = v
	return s
}

func (s *GetAIMediaAuditJobResponse) SetStatusCode(v int32) *GetAIMediaAuditJobResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAIMediaAuditJobResponse) SetBody(v *GetAIMediaAuditJobResponseBody) *GetAIMediaAuditJobResponse {
	s.Body = v
	return s
}

type GetAITemplateRequest struct {
	// The ID of the AI template. You can use one of the following methods to obtain the ID:
	//
	// 	- Call the [AddAITemplate](https://help.aliyun.com/document_detail/102930.html) operation to add an AI template if no AI template exists. The value of TemplateId in the response is the ID of the AI template.
	//
	// 	- Call the [ListAITemplate](https://help.aliyun.com/document_detail/102936.html) operation if the template already exists. The value of TemplateId in the response is the ID of the AI template.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1706a0063dd733f6a823ef32e0a5****
	TemplateId *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
}

func (s GetAITemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAITemplateRequest) GoString() string {
	return s.String()
}

func (s *GetAITemplateRequest) SetTemplateId(v string) *GetAITemplateRequest {
	s.TemplateId = &v
	return s
}

type GetAITemplateResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 080DA371-8AC0-4CD4-4476-33E64282****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the AI template.
	TemplateInfo *GetAITemplateResponseBodyTemplateInfo `json:"TemplateInfo,omitempty" xml:"TemplateInfo,omitempty" type:"Struct"`
}

func (s GetAITemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAITemplateResponseBody) GoString() string {
	return s.String()
}

func (s *GetAITemplateResponseBody) SetRequestId(v string) *GetAITemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetAITemplateResponseBody) SetTemplateInfo(v *GetAITemplateResponseBodyTemplateInfo) *GetAITemplateResponseBody {
	s.TemplateInfo = v
	return s
}

type GetAITemplateResponseBodyTemplateInfo struct {
	// The time when the AI template was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2020-07-08T06:50:45Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// Indicates whether the template is the default AI template. Valid values:
	//
	// 	- **Default**
	//
	// 	- **NotDefault**
	//
	// example:
	//
	// NotDefault
	IsDefault *string `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	// The time when the AI template was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2020-07-08T06:58:45Z
	ModifyTime *string `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	// The source of the AI template. Valid values:
	//
	// 	- **System**
	//
	// 	- **Custom**
	//
	// example:
	//
	// Custom
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The detailed configurations of the AI template. The value is a JSON string. For more information, see [AITemplateConfig](~~89863#title-vd3-499-o36~~).
	//
	// example:
	//
	// {"AuditRange":["text-title","video"],"AuditContent":["screen"],"AuditItem":["terrorism","porn"],"AuditAutoBlock":"yes"}
	TemplateConfig *string `json:"TemplateConfig,omitempty" xml:"TemplateConfig,omitempty"`
	// The ID of the AI template.
	//
	// example:
	//
	// 1706a0063dd733f6a823ef32e0a5****
	TemplateId *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The name of the AI template.
	//
	// example:
	//
	// DemoAITemplate
	TemplateName *string `json:"TemplateName,omitempty" xml:"TemplateName,omitempty"`
	// The type of the AI template. Valid values:
	//
	// 	- **AIMediaAudit**: automated review
	//
	// 	- **AIImage**: smart thumbnail
	//
	// example:
	//
	// AIMediaAudit
	TemplateType *string `json:"TemplateType,omitempty" xml:"TemplateType,omitempty"`
}

func (s GetAITemplateResponseBodyTemplateInfo) String() string {
	return tea.Prettify(s)
}

func (s GetAITemplateResponseBodyTemplateInfo) GoString() string {
	return s.String()
}

func (s *GetAITemplateResponseBodyTemplateInfo) SetCreationTime(v string) *GetAITemplateResponseBodyTemplateInfo {
	s.CreationTime = &v
	return s
}

func (s *GetAITemplateResponseBodyTemplateInfo) SetIsDefault(v string) *GetAITemplateResponseBodyTemplateInfo {
	s.IsDefault = &v
	return s
}

func (s *GetAITemplateResponseBodyTemplateInfo) SetModifyTime(v string) *GetAITemplateResponseBodyTemplateInfo {
	s.ModifyTime = &v
	return s
}

func (s *GetAITemplateResponseBodyTemplateInfo) SetSource(v string) *GetAITemplateResponseBodyTemplateInfo {
	s.Source = &v
	return s
}

func (s *GetAITemplateResponseBodyTemplateInfo) SetTemplateConfig(v string) *GetAITemplateResponseBodyTemplateInfo {
	s.TemplateConfig = &v
	return s
}

func (s *GetAITemplateResponseBodyTemplateInfo) SetTemplateId(v string) *GetAITemplateResponseBodyTemplateInfo {
	s.TemplateId = &v
	return s
}

func (s *GetAITemplateResponseBodyTemplateInfo) SetTemplateName(v string) *GetAITemplateResponseBodyTemplateInfo {
	s.TemplateName = &v
	return s
}

func (s *GetAITemplateResponseBodyTemplateInfo) SetTemplateType(v string) *GetAITemplateResponseBodyTemplateInfo {
	s.TemplateType = &v
	return s
}

type GetAITemplateResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetAITemplateResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetAITemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAITemplateResponse) GoString() string {
	return s.String()
}

func (s *GetAITemplateResponse) SetHeaders(v map[string]*string) *GetAITemplateResponse {
	s.Headers = v
	return s
}

func (s *GetAITemplateResponse) SetStatusCode(v int32) *GetAITemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAITemplateResponse) SetBody(v *GetAITemplateResponseBody) *GetAITemplateResponse {
	s.Body = v
	return s
}

type GetAIVideoTagResultRequest struct {
	// The ID of the media file. You can use one of the following methods to obtain the ID:
	//
	// 	- Log on to the [ApsaraVideo VOD](https://vod.console.aliyun.com) console. In the left-side navigation pane, choose **Media Files*	- > **Audio/Video**. On the Video and Audio page, view the ID of the audio or video file. This method is applicable to files that are uploaded by using the ApsaraVideo VOD console.
	//
	// 	- Obtain the value of VideoId from the response to the [CreateUploadVideo](https://help.aliyun.com/document_detail/55407.html) operation that you call to upload media files.
	//
	// 	- Obtain the value of VideoId from the response to the [SearchMedia](https://help.aliyun.com/document_detail/86044.html) operation after you upload media files.
	//
	// This parameter is required.
	//
	// example:
	//
	// 595d020bad37421f37433451720****
	MediaId              *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GetAIVideoTagResultRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAIVideoTagResultRequest) GoString() string {
	return s.String()
}

func (s *GetAIVideoTagResultRequest) SetMediaId(v string) *GetAIVideoTagResultRequest {
	s.MediaId = &v
	return s
}

func (s *GetAIVideoTagResultRequest) SetOwnerAccount(v string) *GetAIVideoTagResultRequest {
	s.OwnerAccount = &v
	return s
}

func (s *GetAIVideoTagResultRequest) SetOwnerId(v string) *GetAIVideoTagResultRequest {
	s.OwnerId = &v
	return s
}

func (s *GetAIVideoTagResultRequest) SetResourceOwnerAccount(v string) *GetAIVideoTagResultRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GetAIVideoTagResultRequest) SetResourceOwnerId(v string) *GetAIVideoTagResultRequest {
	s.ResourceOwnerId = &v
	return s
}

type GetAIVideoTagResultResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 8829B4DB-AFD9-4FF6-12965DBFFA14****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The returned result.
	VideoTagResult *GetAIVideoTagResultResponseBodyVideoTagResult `json:"VideoTagResult,omitempty" xml:"VideoTagResult,omitempty" type:"Struct"`
}

func (s GetAIVideoTagResultResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAIVideoTagResultResponseBody) GoString() string {
	return s.String()
}

func (s *GetAIVideoTagResultResponseBody) SetRequestId(v string) *GetAIVideoTagResultResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetAIVideoTagResultResponseBody) SetVideoTagResult(v *GetAIVideoTagResultResponseBodyVideoTagResult) *GetAIVideoTagResultResponseBody {
	s.VideoTagResult = v
	return s
}

type GetAIVideoTagResultResponseBodyVideoTagResult struct {
	// The video categories.
	Category []*GetAIVideoTagResultResponseBodyVideoTagResultCategory `json:"Category,omitempty" xml:"Category,omitempty" type:"Repeated"`
	// The keyword tags.
	Keyword []*GetAIVideoTagResultResponseBodyVideoTagResultKeyword `json:"Keyword,omitempty" xml:"Keyword,omitempty" type:"Repeated"`
	// The location tags.
	Location []*GetAIVideoTagResultResponseBodyVideoTagResultLocation `json:"Location,omitempty" xml:"Location,omitempty" type:"Repeated"`
	// The figure tags.
	Person []*GetAIVideoTagResultResponseBodyVideoTagResultPerson `json:"Person,omitempty" xml:"Person,omitempty" type:"Repeated"`
	// The time tags.
	Time []*GetAIVideoTagResultResponseBodyVideoTagResultTime `json:"Time,omitempty" xml:"Time,omitempty" type:"Repeated"`
}

func (s GetAIVideoTagResultResponseBodyVideoTagResult) String() string {
	return tea.Prettify(s)
}

func (s GetAIVideoTagResultResponseBodyVideoTagResult) GoString() string {
	return s.String()
}

func (s *GetAIVideoTagResultResponseBodyVideoTagResult) SetCategory(v []*GetAIVideoTagResultResponseBodyVideoTagResultCategory) *GetAIVideoTagResultResponseBodyVideoTagResult {
	s.Category = v
	return s
}

func (s *GetAIVideoTagResultResponseBodyVideoTagResult) SetKeyword(v []*GetAIVideoTagResultResponseBodyVideoTagResultKeyword) *GetAIVideoTagResultResponseBodyVideoTagResult {
	s.Keyword = v
	return s
}

func (s *GetAIVideoTagResultResponseBodyVideoTagResult) SetLocation(v []*GetAIVideoTagResultResponseBodyVideoTagResultLocation) *GetAIVideoTagResultResponseBodyVideoTagResult {
	s.Location = v
	return s
}

func (s *GetAIVideoTagResultResponseBodyVideoTagResult) SetPerson(v []*GetAIVideoTagResultResponseBodyVideoTagResultPerson) *GetAIVideoTagResultResponseBodyVideoTagResult {
	s.Person = v
	return s
}

func (s *GetAIVideoTagResultResponseBodyVideoTagResult) SetTime(v []*GetAIVideoTagResultResponseBodyVideoTagResultTime) *GetAIVideoTagResultResponseBodyVideoTagResult {
	s.Time = v
	return s
}

type GetAIVideoTagResultResponseBodyVideoTagResultCategory struct {
	// The tag string.
	//
	// example:
	//
	// Retouching
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
}

func (s GetAIVideoTagResultResponseBodyVideoTagResultCategory) String() string {
	return tea.Prettify(s)
}

func (s GetAIVideoTagResultResponseBodyVideoTagResultCategory) GoString() string {
	return s.String()
}

func (s *GetAIVideoTagResultResponseBodyVideoTagResultCategory) SetTag(v string) *GetAIVideoTagResultResponseBodyVideoTagResultCategory {
	s.Tag = &v
	return s
}

type GetAIVideoTagResultResponseBodyVideoTagResultKeyword struct {
	// The tag string.
	//
	// example:
	//
	// Cushion
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
	// The points in time when the tags are displayed. Unit: milliseconds.
	Times []*string `json:"Times,omitempty" xml:"Times,omitempty" type:"Repeated"`
}

func (s GetAIVideoTagResultResponseBodyVideoTagResultKeyword) String() string {
	return tea.Prettify(s)
}

func (s GetAIVideoTagResultResponseBodyVideoTagResultKeyword) GoString() string {
	return s.String()
}

func (s *GetAIVideoTagResultResponseBodyVideoTagResultKeyword) SetTag(v string) *GetAIVideoTagResultResponseBodyVideoTagResultKeyword {
	s.Tag = &v
	return s
}

func (s *GetAIVideoTagResultResponseBodyVideoTagResultKeyword) SetTimes(v []*string) *GetAIVideoTagResultResponseBodyVideoTagResultKeyword {
	s.Times = v
	return s
}

type GetAIVideoTagResultResponseBodyVideoTagResultLocation struct {
	// The tag string.
	//
	// example:
	//
	// Asia
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
	// The points in time when the tags are displayed. Unit: milliseconds.
	Times []*string `json:"Times,omitempty" xml:"Times,omitempty" type:"Repeated"`
}

func (s GetAIVideoTagResultResponseBodyVideoTagResultLocation) String() string {
	return tea.Prettify(s)
}

func (s GetAIVideoTagResultResponseBodyVideoTagResultLocation) GoString() string {
	return s.String()
}

func (s *GetAIVideoTagResultResponseBodyVideoTagResultLocation) SetTag(v string) *GetAIVideoTagResultResponseBodyVideoTagResultLocation {
	s.Tag = &v
	return s
}

func (s *GetAIVideoTagResultResponseBodyVideoTagResultLocation) SetTimes(v []*string) *GetAIVideoTagResultResponseBodyVideoTagResultLocation {
	s.Times = v
	return s
}

type GetAIVideoTagResultResponseBodyVideoTagResultPerson struct {
	// The URL of the profile photo.
	//
	// > This parameter is returned only when a figure tag was used.
	//
	// example:
	//
	// http://example.com/aivideotag/8829B4DB-AFD9-4F*****F6-12965DBFFA14/Index_****.jpg
	FaceUrl *string `json:"FaceUrl,omitempty" xml:"FaceUrl,omitempty"`
	// The tag string.
	//
	// example:
	//
	// John
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
	// The points in time when the tags are displayed. Unit: milliseconds.
	Times []*string `json:"Times,omitempty" xml:"Times,omitempty" type:"Repeated"`
}

func (s GetAIVideoTagResultResponseBodyVideoTagResultPerson) String() string {
	return tea.Prettify(s)
}

func (s GetAIVideoTagResultResponseBodyVideoTagResultPerson) GoString() string {
	return s.String()
}

func (s *GetAIVideoTagResultResponseBodyVideoTagResultPerson) SetFaceUrl(v string) *GetAIVideoTagResultResponseBodyVideoTagResultPerson {
	s.FaceUrl = &v
	return s
}

func (s *GetAIVideoTagResultResponseBodyVideoTagResultPerson) SetTag(v string) *GetAIVideoTagResultResponseBodyVideoTagResultPerson {
	s.Tag = &v
	return s
}

func (s *GetAIVideoTagResultResponseBodyVideoTagResultPerson) SetTimes(v []*string) *GetAIVideoTagResultResponseBodyVideoTagResultPerson {
	s.Times = v
	return s
}

type GetAIVideoTagResultResponseBodyVideoTagResultTime struct {
	// The tag string.
	//
	// example:
	//
	// Milliseconds
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
	// The points in time when the tags are displayed. Unit: milliseconds.
	Times []*string `json:"Times,omitempty" xml:"Times,omitempty" type:"Repeated"`
}

func (s GetAIVideoTagResultResponseBodyVideoTagResultTime) String() string {
	return tea.Prettify(s)
}

func (s GetAIVideoTagResultResponseBodyVideoTagResultTime) GoString() string {
	return s.String()
}

func (s *GetAIVideoTagResultResponseBodyVideoTagResultTime) SetTag(v string) *GetAIVideoTagResultResponseBodyVideoTagResultTime {
	s.Tag = &v
	return s
}

func (s *GetAIVideoTagResultResponseBodyVideoTagResultTime) SetTimes(v []*string) *GetAIVideoTagResultResponseBodyVideoTagResultTime {
	s.Times = v
	return s
}

type GetAIVideoTagResultResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetAIVideoTagResultResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetAIVideoTagResultResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAIVideoTagResultResponse) GoString() string {
	return s.String()
}

func (s *GetAIVideoTagResultResponse) SetHeaders(v map[string]*string) *GetAIVideoTagResultResponse {
	s.Headers = v
	return s
}

func (s *GetAIVideoTagResultResponse) SetStatusCode(v int32) *GetAIVideoTagResultResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAIVideoTagResultResponse) SetBody(v *GetAIVideoTagResultResponseBody) *GetAIVideoTagResultResponse {
	s.Body = v
	return s
}

type GetAppInfosRequest struct {
	// The IDs of applications. You can obtain application IDs from the response to the [CreateAppInfo](https://help.aliyun.com/document_detail/113266.html) or [ListAppInfo](https://help.aliyun.com/document_detail/114000.html) operation.
	//
	// 	- You can specify a maximum of 10 application IDs.
	//
	// 	- Separate application IDs with commas (,).
	//
	// This parameter is required.
	//
	// example:
	//
	// app-****
	AppIds *string `json:"AppIds,omitempty" xml:"AppIds,omitempty"`
}

func (s GetAppInfosRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAppInfosRequest) GoString() string {
	return s.String()
}

func (s *GetAppInfosRequest) SetAppIds(v string) *GetAppInfosRequest {
	s.AppIds = &v
	return s
}

type GetAppInfosResponseBody struct {
	// The details of applications.
	AppInfoList []*GetAppInfosResponseBodyAppInfoList `json:"AppInfoList,omitempty" xml:"AppInfoList,omitempty" type:"Repeated"`
	// The HTTP status code that is returned.
	//
	// example:
	//
	// 200
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The IDs of applications that do not exist.
	NonExistAppIds []*string `json:"NonExistAppIds,omitempty" xml:"NonExistAppIds,omitempty" type:"Repeated"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A13-4DC4-D7393642****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetAppInfosResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAppInfosResponseBody) GoString() string {
	return s.String()
}

func (s *GetAppInfosResponseBody) SetAppInfoList(v []*GetAppInfosResponseBodyAppInfoList) *GetAppInfosResponseBody {
	s.AppInfoList = v
	return s
}

func (s *GetAppInfosResponseBody) SetCode(v string) *GetAppInfosResponseBody {
	s.Code = &v
	return s
}

func (s *GetAppInfosResponseBody) SetNonExistAppIds(v []*string) *GetAppInfosResponseBody {
	s.NonExistAppIds = v
	return s
}

func (s *GetAppInfosResponseBody) SetRequestId(v string) *GetAppInfosResponseBody {
	s.RequestId = &v
	return s
}

type GetAppInfosResponseBodyAppInfoList struct {
	// The ID of the application.
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	//
	// example:
	//
	// test
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The time when the application was created. The time is in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-03-01T08:00:00Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the application.
	//
	// example:
	//
	// my first app.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The last time when the application was modified. The time is in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-03-01T09:00:00Z
	ModificationTime *string `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	// The resource group ID.
	//
	// example:
	//
	// rg-aekzko7fsuj****
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The status of the application. Valid values:
	//
	// 	- **Normal**
	//
	// 	- **Disable**
	//
	// example:
	//
	// Normal
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the application. Valid values:
	//
	// 	- **System**
	//
	// 	- **Custom**
	//
	// example:
	//
	// System
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetAppInfosResponseBodyAppInfoList) String() string {
	return tea.Prettify(s)
}

func (s GetAppInfosResponseBodyAppInfoList) GoString() string {
	return s.String()
}

func (s *GetAppInfosResponseBodyAppInfoList) SetAppId(v string) *GetAppInfosResponseBodyAppInfoList {
	s.AppId = &v
	return s
}

func (s *GetAppInfosResponseBodyAppInfoList) SetAppName(v string) *GetAppInfosResponseBodyAppInfoList {
	s.AppName = &v
	return s
}

func (s *GetAppInfosResponseBodyAppInfoList) SetCreationTime(v string) *GetAppInfosResponseBodyAppInfoList {
	s.CreationTime = &v
	return s
}

func (s *GetAppInfosResponseBodyAppInfoList) SetDescription(v string) *GetAppInfosResponseBodyAppInfoList {
	s.Description = &v
	return s
}

func (s *GetAppInfosResponseBodyAppInfoList) SetModificationTime(v string) *GetAppInfosResponseBodyAppInfoList {
	s.ModificationTime = &v
	return s
}

func (s *GetAppInfosResponseBodyAppInfoList) SetResourceGroupId(v string) *GetAppInfosResponseBodyAppInfoList {
	s.ResourceGroupId = &v
	return s
}

func (s *GetAppInfosResponseBodyAppInfoList) SetStatus(v string) *GetAppInfosResponseBodyAppInfoList {
	s.Status = &v
	return s
}

func (s *GetAppInfosResponseBodyAppInfoList) SetType(v string) *GetAppInfosResponseBodyAppInfoList {
	s.Type = &v
	return s
}

type GetAppInfosResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetAppInfosResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetAppInfosResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAppInfosResponse) GoString() string {
	return s.String()
}

func (s *GetAppInfosResponse) SetHeaders(v map[string]*string) *GetAppInfosResponse {
	s.Headers = v
	return s
}

func (s *GetAppInfosResponse) SetStatusCode(v int32) *GetAppInfosResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAppInfosResponse) SetBody(v *GetAppInfosResponseBody) *GetAppInfosResponse {
	s.Body = v
	return s
}

type GetAttachedMediaInfoRequest struct {
	// The validity period of the URL. Unit: seconds.
	//
	// 	- If you set the OutputType parameter to **cdn**:
	//
	//     	- The URL of the auxiliary media asset has a validity period only if URL signing is enabled. Otherwise, the URL of the auxiliary media asset is permanently valid.
	//
	//     	- Minimum value: **1**.
	//
	//     	- Maximum value: unlimited.
	//
	//     	- Default value: If you do not set this parameter, the default validity period that is specified in URL signing is used.
	//
	// 	- If you set the OutputType parameter to **oss**:
	//
	//     	- The URL of the auxiliary media asset has a validity period only if the permissions on the Object Storage Service (OSS) bucket are private. Otherwise, the URL of the auxiliary media asset is permanently valid.
	//
	//     	- Minimum value: **1**.
	//
	//     	- The maximum value for a media asset stored in the VOD bucket is **2592000*	- (30 days) and the maximum value for a media asset stored in an OSS bucket is **129600*	- (36 hours). The maximum value is limited to reduce security risks of the origin.
	//
	//     	- Default value: If you do not set this parameter, the default value **3600*	- is used.
	//
	// example:
	//
	// 3600
	AuthTimeout *int64 `json:"AuthTimeout,omitempty" xml:"AuthTimeout,omitempty"`
	// The ID of the auxiliary media asset.
	//
	// 	- Separate multiple IDs with commas (,). You can specify up to 20 IDs.
	//
	// 	- You can obtain the ID from the response to the [CreateUploadAttachedMedia](~~CreateUploadAttachedMedia~~) operation that you call to obtain the upload URL and credential.
	//
	// This parameter is required.
	//
	// example:
	//
	// eb1861d2c9a842340e989dd56****,0222e203cf80f9c22870a4d2c****
	MediaIds *string `json:"MediaIds,omitempty" xml:"MediaIds,omitempty"`
	// The type of the media asset URL. Valid values:
	//
	// 	- **oss**
	//
	// 	- **cdn*	- (default)
	//
	// example:
	//
	// oss
	OutputType *string `json:"OutputType,omitempty" xml:"OutputType,omitempty"`
}

func (s GetAttachedMediaInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAttachedMediaInfoRequest) GoString() string {
	return s.String()
}

func (s *GetAttachedMediaInfoRequest) SetAuthTimeout(v int64) *GetAttachedMediaInfoRequest {
	s.AuthTimeout = &v
	return s
}

func (s *GetAttachedMediaInfoRequest) SetMediaIds(v string) *GetAttachedMediaInfoRequest {
	s.MediaIds = &v
	return s
}

func (s *GetAttachedMediaInfoRequest) SetOutputType(v string) *GetAttachedMediaInfoRequest {
	s.OutputType = &v
	return s
}

type GetAttachedMediaInfoResponseBody struct {
	// The information about the media assets.
	AttachedMediaList []*GetAttachedMediaInfoResponseBodyAttachedMediaList `json:"AttachedMediaList,omitempty" xml:"AttachedMediaList,omitempty" type:"Repeated"`
	// The IDs of the auxiliary media assets that do not exist.
	NonExistMediaIds []*string `json:"NonExistMediaIds,omitempty" xml:"NonExistMediaIds,omitempty" type:"Repeated"`
	// The ID of the request.
	//
	// example:
	//
	// 221BCB57-B217-42BF-619BD13378F9****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetAttachedMediaInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAttachedMediaInfoResponseBody) GoString() string {
	return s.String()
}

func (s *GetAttachedMediaInfoResponseBody) SetAttachedMediaList(v []*GetAttachedMediaInfoResponseBodyAttachedMediaList) *GetAttachedMediaInfoResponseBody {
	s.AttachedMediaList = v
	return s
}

func (s *GetAttachedMediaInfoResponseBody) SetNonExistMediaIds(v []*string) *GetAttachedMediaInfoResponseBody {
	s.NonExistMediaIds = v
	return s
}

func (s *GetAttachedMediaInfoResponseBody) SetRequestId(v string) *GetAttachedMediaInfoResponseBody {
	s.RequestId = &v
	return s
}

type GetAttachedMediaInfoResponseBodyAttachedMediaList struct {
	// The ID of the application.
	//
	// example:
	//
	// app-*****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The categories.
	Categories []*GetAttachedMediaInfoResponseBodyAttachedMediaListCategories `json:"Categories,omitempty" xml:"Categories,omitempty" type:"Repeated"`
	// The time when the auxiliary media asset was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-01-01T10:00:00Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the auxiliary media asset.
	//
	// >  This parameter is returned only when a description is specified for the auxiliary media asset.
	//
	// example:
	//
	// description test
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the auxiliary media asset.
	//
	// example:
	//
	// 0222e203cf80f9c22870a4d2c****
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The time when the auxiliary media asset was last updated. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2020-05-31T11:42:20Z
	ModificationTime *string `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	// The status of the auxiliary media asset. Valid values:
	//
	// 	- **Uploading**
	//
	// 	- **Normal**
	//
	// 	- **UploadFail**
	//
	// example:
	//
	// Normal
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The storage address of the auxiliary media asset.
	//
	// example:
	//
	// outin-bfefbb9*****c7426.oss-cn-shanghai.aliyuncs.com
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	// The tags of the auxiliary media asset.
	//
	// >  This parameter is returned only when tags are specified for the auxiliary media asset.
	//
	// example:
	//
	// tag1,tag2
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The title of the auxiliary media asset.
	//
	// example:
	//
	// subtitle test
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The type of the auxiliary media asset.
	//
	// 	- **watermark**
	//
	// 	- **subtitle**
	//
	// 	- **material**
	//
	// example:
	//
	// subtitle
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The URL of the auxiliary media asset.
	//
	// >  If a CDN domain name is specified, a CDN URL is returned. Otherwise, an OSS URL is returned.
	//
	// example:
	//
	// https://al*****.cn/subtitle/9843C2*****4E186F19B6.vtt?auth_key=159099f60e0b7fd59****
	URL *string `json:"URL,omitempty" xml:"URL,omitempty"`
}

func (s GetAttachedMediaInfoResponseBodyAttachedMediaList) String() string {
	return tea.Prettify(s)
}

func (s GetAttachedMediaInfoResponseBodyAttachedMediaList) GoString() string {
	return s.String()
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaList) SetAppId(v string) *GetAttachedMediaInfoResponseBodyAttachedMediaList {
	s.AppId = &v
	return s
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaList) SetCategories(v []*GetAttachedMediaInfoResponseBodyAttachedMediaListCategories) *GetAttachedMediaInfoResponseBodyAttachedMediaList {
	s.Categories = v
	return s
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaList) SetCreationTime(v string) *GetAttachedMediaInfoResponseBodyAttachedMediaList {
	s.CreationTime = &v
	return s
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaList) SetDescription(v string) *GetAttachedMediaInfoResponseBodyAttachedMediaList {
	s.Description = &v
	return s
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaList) SetMediaId(v string) *GetAttachedMediaInfoResponseBodyAttachedMediaList {
	s.MediaId = &v
	return s
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaList) SetModificationTime(v string) *GetAttachedMediaInfoResponseBodyAttachedMediaList {
	s.ModificationTime = &v
	return s
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaList) SetStatus(v string) *GetAttachedMediaInfoResponseBodyAttachedMediaList {
	s.Status = &v
	return s
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaList) SetStorageLocation(v string) *GetAttachedMediaInfoResponseBodyAttachedMediaList {
	s.StorageLocation = &v
	return s
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaList) SetTags(v string) *GetAttachedMediaInfoResponseBodyAttachedMediaList {
	s.Tags = &v
	return s
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaList) SetTitle(v string) *GetAttachedMediaInfoResponseBodyAttachedMediaList {
	s.Title = &v
	return s
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaList) SetType(v string) *GetAttachedMediaInfoResponseBodyAttachedMediaList {
	s.Type = &v
	return s
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaList) SetURL(v string) *GetAttachedMediaInfoResponseBodyAttachedMediaList {
	s.URL = &v
	return s
}

type GetAttachedMediaInfoResponseBodyAttachedMediaListCategories struct {
	// The ID of the category.
	//
	// example:
	//
	// 1000224338
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The name of the category.
	//
	// example:
	//
	// category test
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	// The level of the category.
	//
	// example:
	//
	// 0
	Level *int64 `json:"Level,omitempty" xml:"Level,omitempty"`
	// The ID of the parent category.
	//
	// example:
	//
	// 1000224336
	ParentId *int64 `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
}

func (s GetAttachedMediaInfoResponseBodyAttachedMediaListCategories) String() string {
	return tea.Prettify(s)
}

func (s GetAttachedMediaInfoResponseBodyAttachedMediaListCategories) GoString() string {
	return s.String()
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaListCategories) SetCateId(v int64) *GetAttachedMediaInfoResponseBodyAttachedMediaListCategories {
	s.CateId = &v
	return s
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaListCategories) SetCateName(v string) *GetAttachedMediaInfoResponseBodyAttachedMediaListCategories {
	s.CateName = &v
	return s
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaListCategories) SetLevel(v int64) *GetAttachedMediaInfoResponseBodyAttachedMediaListCategories {
	s.Level = &v
	return s
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaListCategories) SetParentId(v int64) *GetAttachedMediaInfoResponseBodyAttachedMediaListCategories {
	s.ParentId = &v
	return s
}

type GetAttachedMediaInfoResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetAttachedMediaInfoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetAttachedMediaInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAttachedMediaInfoResponse) GoString() string {
	return s.String()
}

func (s *GetAttachedMediaInfoResponse) SetHeaders(v map[string]*string) *GetAttachedMediaInfoResponse {
	s.Headers = v
	return s
}

func (s *GetAttachedMediaInfoResponse) SetStatusCode(v int32) *GetAttachedMediaInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAttachedMediaInfoResponse) SetBody(v *GetAttachedMediaInfoResponseBody) *GetAttachedMediaInfoResponse {
	s.Body = v
	return s
}

type GetAuditHistoryRequest struct {
	// The number of the page to return. Default value: **1**.
	//
	// example:
	//
	// 1
	PageNo *int64 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The number of entries to return on each page. Default value: **10**. Maximum value: **100**.
	//
	// example:
	//
	// 10
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The sorting rule of the results. Valid values:
	//
	// 	- **CreationTime:Desc**: sorts the results based on the creation time in descending order. This is the default value.
	//
	// 	- **CreationTime:Asc**: sorts the results based on the creation time in ascending order.
	//
	// example:
	//
	// CreationTime:Desc
	SortBy *string `json:"SortBy,omitempty" xml:"SortBy,omitempty"`
	// The ID of the video.
	//
	// This parameter is required.
	//
	// example:
	//
	// 93ab850b4f6f44*****6e91d24d81d4
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s GetAuditHistoryRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAuditHistoryRequest) GoString() string {
	return s.String()
}

func (s *GetAuditHistoryRequest) SetPageNo(v int64) *GetAuditHistoryRequest {
	s.PageNo = &v
	return s
}

func (s *GetAuditHistoryRequest) SetPageSize(v int64) *GetAuditHistoryRequest {
	s.PageSize = &v
	return s
}

func (s *GetAuditHistoryRequest) SetSortBy(v string) *GetAuditHistoryRequest {
	s.SortBy = &v
	return s
}

func (s *GetAuditHistoryRequest) SetVideoId(v string) *GetAuditHistoryRequest {
	s.VideoId = &v
	return s
}

type GetAuditHistoryResponseBody struct {
	// The review records.
	Histories []*GetAuditHistoryResponseBodyHistories `json:"Histories,omitempty" xml:"Histories,omitempty" type:"Repeated"`
	// The ID of the request.
	//
	// example:
	//
	// 04F0F334-1335-43*****D7-6C044FE73368
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The manual review result. Valid values:
	//
	// - **Normal**: The video can be played.
	//
	// - **Blocked**: The video is blocked.
	//
	// example:
	//
	// Normal
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The total number of review records.
	//
	// example:
	//
	// 2
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s GetAuditHistoryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAuditHistoryResponseBody) GoString() string {
	return s.String()
}

func (s *GetAuditHistoryResponseBody) SetHistories(v []*GetAuditHistoryResponseBodyHistories) *GetAuditHistoryResponseBody {
	s.Histories = v
	return s
}

func (s *GetAuditHistoryResponseBody) SetRequestId(v string) *GetAuditHistoryResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetAuditHistoryResponseBody) SetStatus(v string) *GetAuditHistoryResponseBody {
	s.Status = &v
	return s
}

func (s *GetAuditHistoryResponseBody) SetTotal(v int64) *GetAuditHistoryResponseBody {
	s.Total = &v
	return s
}

type GetAuditHistoryResponseBodyHistories struct {
	// The reviewer.
	//
	// example:
	//
	// auditor
	Auditor *string `json:"Auditor,omitempty" xml:"Auditor,omitempty"`
	// The review comments, which are provided by the reviewer.
	//
	// example:
	//
	// Contains nudity
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The time when the review record was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-01-11T12:00:00Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The reason why the video failed the review. If the video failed the review, specify the reason.
	//
	// example:
	//
	// Pornographic video
	Reason *string `json:"Reason,omitempty" xml:"Reason,omitempty"`
	// The manual review result. Valid values:
	//
	// - **Normal**: The video can be played.
	//
	// - **Blocked**: The video is blocked.
	//
	// example:
	//
	// Blocked
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetAuditHistoryResponseBodyHistories) String() string {
	return tea.Prettify(s)
}

func (s GetAuditHistoryResponseBodyHistories) GoString() string {
	return s.String()
}

func (s *GetAuditHistoryResponseBodyHistories) SetAuditor(v string) *GetAuditHistoryResponseBodyHistories {
	s.Auditor = &v
	return s
}

func (s *GetAuditHistoryResponseBodyHistories) SetComment(v string) *GetAuditHistoryResponseBodyHistories {
	s.Comment = &v
	return s
}

func (s *GetAuditHistoryResponseBodyHistories) SetCreationTime(v string) *GetAuditHistoryResponseBodyHistories {
	s.CreationTime = &v
	return s
}

func (s *GetAuditHistoryResponseBodyHistories) SetReason(v string) *GetAuditHistoryResponseBodyHistories {
	s.Reason = &v
	return s
}

func (s *GetAuditHistoryResponseBodyHistories) SetStatus(v string) *GetAuditHistoryResponseBodyHistories {
	s.Status = &v
	return s
}

type GetAuditHistoryResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetAuditHistoryResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetAuditHistoryResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAuditHistoryResponse) GoString() string {
	return s.String()
}

func (s *GetAuditHistoryResponse) SetHeaders(v map[string]*string) *GetAuditHistoryResponse {
	s.Headers = v
	return s
}

func (s *GetAuditHistoryResponse) SetStatusCode(v int32) *GetAuditHistoryResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAuditHistoryResponse) SetBody(v *GetAuditHistoryResponseBody) *GetAuditHistoryResponse {
	s.Body = v
	return s
}

type GetCategoriesRequest struct {
	// The ID of the category. If you specify this parameter, the system queries the category based on the ID. You can specify only one category ID. You can use one of the following methods to obtain the ID:
	//
	// 	- Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). Choose **Configuration Management*	- > **Media Management*	- > **Categories**. On the Audio and Video / Image Category or Short Video Material Category tab, view the category ID.
	//
	// 	- Obtain the category ID from the response to the [AddCategory](~~AddCategory~~) operation.
	//
	// example:
	//
	// 49339****
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The number of the page where the subcategories to be returned are listed. Default value: **1**.
	//
	// example:
	//
	// 1
	PageNo *int64 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The number of entries to return on each page of the subcategory list. Default value: **10**. Maximum value: **100**.
	//
	// example:
	//
	// 10
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The sorting method of the results. Valid values:
	//
	// 	- **CreationTime:Desc*	- (default): The results are sorted in reverse chronological order based on the creation time.
	//
	// 	- **CreationTime:Asc**: The results are sorted in chronological order based on the creation time.
	//
	// example:
	//
	// CreationTime:Desc
	SortBy *string `json:"SortBy,omitempty" xml:"SortBy,omitempty"`
	// The type of the category. If you specify this parameter, the system queries the category based on the type. Valid values:
	//
	// 	- **default*	- (default): audio, video, and image files
	//
	// 	- **material**: short video materials
	//
	// example:
	//
	// default
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetCategoriesRequest) String() string {
	return tea.Prettify(s)
}

func (s GetCategoriesRequest) GoString() string {
	return s.String()
}

func (s *GetCategoriesRequest) SetCateId(v int64) *GetCategoriesRequest {
	s.CateId = &v
	return s
}

func (s *GetCategoriesRequest) SetPageNo(v int64) *GetCategoriesRequest {
	s.PageNo = &v
	return s
}

func (s *GetCategoriesRequest) SetPageSize(v int64) *GetCategoriesRequest {
	s.PageSize = &v
	return s
}

func (s *GetCategoriesRequest) SetSortBy(v string) *GetCategoriesRequest {
	s.SortBy = &v
	return s
}

func (s *GetCategoriesRequest) SetType(v string) *GetCategoriesRequest {
	s.Type = &v
	return s
}

type GetCategoriesResponseBody struct {
	// The information about the category.
	Category *GetCategoriesResponseBodyCategory `json:"Category,omitempty" xml:"Category,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4AF6-D7393642CA58****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The details of the subcategory.
	SubCategories *GetCategoriesResponseBodySubCategories `json:"SubCategories,omitempty" xml:"SubCategories,omitempty" type:"Struct"`
	// The total number of subcategories.
	//
	// example:
	//
	// 3795
	SubTotal *int64 `json:"SubTotal,omitempty" xml:"SubTotal,omitempty"`
}

func (s GetCategoriesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetCategoriesResponseBody) GoString() string {
	return s.String()
}

func (s *GetCategoriesResponseBody) SetCategory(v *GetCategoriesResponseBodyCategory) *GetCategoriesResponseBody {
	s.Category = v
	return s
}

func (s *GetCategoriesResponseBody) SetRequestId(v string) *GetCategoriesResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetCategoriesResponseBody) SetSubCategories(v *GetCategoriesResponseBodySubCategories) *GetCategoriesResponseBody {
	s.SubCategories = v
	return s
}

func (s *GetCategoriesResponseBody) SetSubTotal(v int64) *GetCategoriesResponseBody {
	s.SubTotal = &v
	return s
}

type GetCategoriesResponseBodyCategory struct {
	// The ID of the category.
	//
	// example:
	//
	// 100
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The name of the category.
	//
	// example:
	//
	// film
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	// The level of the category. Valid values:
	//
	// 	- **0**: level 1 category
	//
	// 	- **1**: level 2 category
	//
	// 	- **2**: level 3 category
	//
	// example:
	//
	// 0
	Level *int64 `json:"Level,omitempty" xml:"Level,omitempty"`
	// The ID of the parent category.
	//
	// example:
	//
	// 100012****
	ParentId *int64 `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
	// The type of the category. Valid values:
	//
	// 	- **default**: audio, video, and image files
	//
	// 	- **material**: short video materials
	//
	// example:
	//
	// default
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetCategoriesResponseBodyCategory) String() string {
	return tea.Prettify(s)
}

func (s GetCategoriesResponseBodyCategory) GoString() string {
	return s.String()
}

func (s *GetCategoriesResponseBodyCategory) SetCateId(v int64) *GetCategoriesResponseBodyCategory {
	s.CateId = &v
	return s
}

func (s *GetCategoriesResponseBodyCategory) SetCateName(v string) *GetCategoriesResponseBodyCategory {
	s.CateName = &v
	return s
}

func (s *GetCategoriesResponseBodyCategory) SetLevel(v int64) *GetCategoriesResponseBodyCategory {
	s.Level = &v
	return s
}

func (s *GetCategoriesResponseBodyCategory) SetParentId(v int64) *GetCategoriesResponseBodyCategory {
	s.ParentId = &v
	return s
}

func (s *GetCategoriesResponseBodyCategory) SetType(v string) *GetCategoriesResponseBodyCategory {
	s.Type = &v
	return s
}

type GetCategoriesResponseBodySubCategories struct {
	Category []*GetCategoriesResponseBodySubCategoriesCategory `json:"Category,omitempty" xml:"Category,omitempty" type:"Repeated"`
}

func (s GetCategoriesResponseBodySubCategories) String() string {
	return tea.Prettify(s)
}

func (s GetCategoriesResponseBodySubCategories) GoString() string {
	return s.String()
}

func (s *GetCategoriesResponseBodySubCategories) SetCategory(v []*GetCategoriesResponseBodySubCategoriesCategory) *GetCategoriesResponseBodySubCategories {
	s.Category = v
	return s
}

type GetCategoriesResponseBodySubCategoriesCategory struct {
	// The ID of the category.
	//
	// example:
	//
	// 100
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The name of the category.
	//
	// example:
	//
	// film
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	// The level of the category. Valid values:
	//
	// 	- **0**: level 1 category
	//
	// 	- **1**: level 2 category
	//
	// 	- **2**: level 3 category
	//
	// example:
	//
	// 1
	Level *int64 `json:"Level,omitempty" xml:"Level,omitempty"`
	// The ID of the parent category.
	//
	// example:
	//
	// 10020****
	ParentId *int64 `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
	// The total number of subcategories.
	//
	// example:
	//
	// 1
	SubTotal *int64 `json:"SubTotal,omitempty" xml:"SubTotal,omitempty"`
	// The type of the subcategory. Valid values:
	//
	// 	- **default**: audio, video, and image files
	//
	// 	- **material**: short video materials
	//
	// example:
	//
	// default
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetCategoriesResponseBodySubCategoriesCategory) String() string {
	return tea.Prettify(s)
}

func (s GetCategoriesResponseBodySubCategoriesCategory) GoString() string {
	return s.String()
}

func (s *GetCategoriesResponseBodySubCategoriesCategory) SetCateId(v int64) *GetCategoriesResponseBodySubCategoriesCategory {
	s.CateId = &v
	return s
}

func (s *GetCategoriesResponseBodySubCategoriesCategory) SetCateName(v string) *GetCategoriesResponseBodySubCategoriesCategory {
	s.CateName = &v
	return s
}

func (s *GetCategoriesResponseBodySubCategoriesCategory) SetLevel(v int64) *GetCategoriesResponseBodySubCategoriesCategory {
	s.Level = &v
	return s
}

func (s *GetCategoriesResponseBodySubCategoriesCategory) SetParentId(v int64) *GetCategoriesResponseBodySubCategoriesCategory {
	s.ParentId = &v
	return s
}

func (s *GetCategoriesResponseBodySubCategoriesCategory) SetSubTotal(v int64) *GetCategoriesResponseBodySubCategoriesCategory {
	s.SubTotal = &v
	return s
}

func (s *GetCategoriesResponseBodySubCategoriesCategory) SetType(v string) *GetCategoriesResponseBodySubCategoriesCategory {
	s.Type = &v
	return s
}

type GetCategoriesResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetCategoriesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetCategoriesResponse) String() string {
	return tea.Prettify(s)
}

func (s GetCategoriesResponse) GoString() string {
	return s.String()
}

func (s *GetCategoriesResponse) SetHeaders(v map[string]*string) *GetCategoriesResponse {
	s.Headers = v
	return s
}

func (s *GetCategoriesResponse) SetStatusCode(v int32) *GetCategoriesResponse {
	s.StatusCode = &v
	return s
}

func (s *GetCategoriesResponse) SetBody(v *GetCategoriesResponseBody) *GetCategoriesResponse {
	s.Body = v
	return s
}

type GetDefaultAITemplateRequest struct {
	// The type of the AI template. Set the value to **AIMediaAudit**, which specifies the automated review.
	//
	// This parameter is required.
	//
	// example:
	//
	// AIMediaAudit
	TemplateType *string `json:"TemplateType,omitempty" xml:"TemplateType,omitempty"`
}

func (s GetDefaultAITemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDefaultAITemplateRequest) GoString() string {
	return s.String()
}

func (s *GetDefaultAITemplateRequest) SetTemplateType(v string) *GetDefaultAITemplateRequest {
	s.TemplateType = &v
	return s
}

type GetDefaultAITemplateResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// A017F1DE-3DC3-4441-6755-37E81113****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the AI template.
	TemplateInfo *GetDefaultAITemplateResponseBodyTemplateInfo `json:"TemplateInfo,omitempty" xml:"TemplateInfo,omitempty" type:"Struct"`
}

func (s GetDefaultAITemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDefaultAITemplateResponseBody) GoString() string {
	return s.String()
}

func (s *GetDefaultAITemplateResponseBody) SetRequestId(v string) *GetDefaultAITemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDefaultAITemplateResponseBody) SetTemplateInfo(v *GetDefaultAITemplateResponseBodyTemplateInfo) *GetDefaultAITemplateResponseBody {
	s.TemplateInfo = v
	return s
}

type GetDefaultAITemplateResponseBodyTemplateInfo struct {
	// The time when the AI template was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2020-07-08T06:50:45Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// Indicates whether the template is the default AI template. Valid values:
	//
	// 	- **Default**
	//
	// 	- **NotDefault**
	//
	// example:
	//
	// Default
	IsDefault *string `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	// The time when the AI template was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2020-07-08T06:58:45Z
	ModifyTime *string `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	// The source of the AI template. Valid values:
	//
	// 	- **System**
	//
	// 	- **Custom**
	//
	// example:
	//
	// Custom
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The detailed configurations of the AI template. The value is a JSON string. For more information, see [AITemplateConfig](~~89863#title-vd3-499-o36~~).
	//
	// example:
	//
	// {"AuditRange":["text-title","video"],"AuditContent":["screen"],"AuditItem":["terrorism","porn"],"AuditAutoBlock":"yes"}
	TemplateConfig *string `json:"TemplateConfig,omitempty" xml:"TemplateConfig,omitempty"`
	// The ID of the AI template.
	//
	// example:
	//
	// 1706a0063dd733f6a823ef32e0a5****
	TemplateId *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The name of the AI template.
	//
	// example:
	//
	// DemoAITemplate
	TemplateName *string `json:"TemplateName,omitempty" xml:"TemplateName,omitempty"`
	// The type of the AI template. The value is **AIMediaAudit**, which indicates automated review.
	//
	// example:
	//
	// AIMediaAudit
	TemplateType *string `json:"TemplateType,omitempty" xml:"TemplateType,omitempty"`
}

func (s GetDefaultAITemplateResponseBodyTemplateInfo) String() string {
	return tea.Prettify(s)
}

func (s GetDefaultAITemplateResponseBodyTemplateInfo) GoString() string {
	return s.String()
}

func (s *GetDefaultAITemplateResponseBodyTemplateInfo) SetCreationTime(v string) *GetDefaultAITemplateResponseBodyTemplateInfo {
	s.CreationTime = &v
	return s
}

func (s *GetDefaultAITemplateResponseBodyTemplateInfo) SetIsDefault(v string) *GetDefaultAITemplateResponseBodyTemplateInfo {
	s.IsDefault = &v
	return s
}

func (s *GetDefaultAITemplateResponseBodyTemplateInfo) SetModifyTime(v string) *GetDefaultAITemplateResponseBodyTemplateInfo {
	s.ModifyTime = &v
	return s
}

func (s *GetDefaultAITemplateResponseBodyTemplateInfo) SetSource(v string) *GetDefaultAITemplateResponseBodyTemplateInfo {
	s.Source = &v
	return s
}

func (s *GetDefaultAITemplateResponseBodyTemplateInfo) SetTemplateConfig(v string) *GetDefaultAITemplateResponseBodyTemplateInfo {
	s.TemplateConfig = &v
	return s
}

func (s *GetDefaultAITemplateResponseBodyTemplateInfo) SetTemplateId(v string) *GetDefaultAITemplateResponseBodyTemplateInfo {
	s.TemplateId = &v
	return s
}

func (s *GetDefaultAITemplateResponseBodyTemplateInfo) SetTemplateName(v string) *GetDefaultAITemplateResponseBodyTemplateInfo {
	s.TemplateName = &v
	return s
}

func (s *GetDefaultAITemplateResponseBodyTemplateInfo) SetTemplateType(v string) *GetDefaultAITemplateResponseBodyTemplateInfo {
	s.TemplateType = &v
	return s
}

type GetDefaultAITemplateResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetDefaultAITemplateResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetDefaultAITemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDefaultAITemplateResponse) GoString() string {
	return s.String()
}

func (s *GetDefaultAITemplateResponse) SetHeaders(v map[string]*string) *GetDefaultAITemplateResponse {
	s.Headers = v
	return s
}

func (s *GetDefaultAITemplateResponse) SetStatusCode(v int32) *GetDefaultAITemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDefaultAITemplateResponse) SetBody(v *GetDefaultAITemplateResponseBody) *GetDefaultAITemplateResponse {
	s.Body = v
	return s
}

type GetDigitalWatermarkExtractResultRequest struct {
	// The type of the watermark. Valid values:
	//
	// 	- **TraceMark**: user-tracing watermark
	//
	// 	- **CopyrightMark**: copyright watermark
	//
	// This parameter is required.
	//
	// example:
	//
	// TraceMark
	ExtractType *string `json:"ExtractType,omitempty" xml:"ExtractType,omitempty"`
	// The ID of the watermark extraction job.
	//
	// 	- You can obtain the ID from the response to the [SubmitDigitalWatermarkExtractJob](~~SubmitDigitalWatermarkExtractJob~~) operation.
	//
	// 	- If you specify this parameter, the result of the specified watermark extraction job is returned. If you leave this parameter empty, the results of all watermark extraction jobs submitted for the video are returned.
	//
	// example:
	//
	// 2bf4390af9e5491c09cc720ad****
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The ID of the video from which you want to query the watermark content. You can specify only one ID. You can use one of the following methods to obtain the ID:
	//
	// 	- Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Media Files*	- > **Audio/Video*	- to view the video ID.
	//
	// 	- Obtain the VideoId from the response to the [SearchMedia](~~SearchMedia~~) operation.
	//
	// This parameter is required.
	//
	// example:
	//
	// 93ab850b4f6f54b6e91d24d81d4****
	MediaId              *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GetDigitalWatermarkExtractResultRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDigitalWatermarkExtractResultRequest) GoString() string {
	return s.String()
}

func (s *GetDigitalWatermarkExtractResultRequest) SetExtractType(v string) *GetDigitalWatermarkExtractResultRequest {
	s.ExtractType = &v
	return s
}

func (s *GetDigitalWatermarkExtractResultRequest) SetJobId(v string) *GetDigitalWatermarkExtractResultRequest {
	s.JobId = &v
	return s
}

func (s *GetDigitalWatermarkExtractResultRequest) SetMediaId(v string) *GetDigitalWatermarkExtractResultRequest {
	s.MediaId = &v
	return s
}

func (s *GetDigitalWatermarkExtractResultRequest) SetOwnerAccount(v string) *GetDigitalWatermarkExtractResultRequest {
	s.OwnerAccount = &v
	return s
}

func (s *GetDigitalWatermarkExtractResultRequest) SetOwnerId(v string) *GetDigitalWatermarkExtractResultRequest {
	s.OwnerId = &v
	return s
}

func (s *GetDigitalWatermarkExtractResultRequest) SetResourceOwnerAccount(v string) *GetDigitalWatermarkExtractResultRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GetDigitalWatermarkExtractResultRequest) SetResourceOwnerId(v string) *GetDigitalWatermarkExtractResultRequest {
	s.ResourceOwnerId = &v
	return s
}

type GetDigitalWatermarkExtractResultResponseBody struct {
	// The details of the watermark extraction job.
	AiExtractResultList []*GetDigitalWatermarkExtractResultResponseBodyAiExtractResultList `json:"AiExtractResultList,omitempty" xml:"AiExtractResultList,omitempty" type:"Repeated"`
	// The ID of the request.
	//
	// example:
	//
	// 42E0554B-80F4-4921-****-ACFB22CAAAD0
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetDigitalWatermarkExtractResultResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDigitalWatermarkExtractResultResponseBody) GoString() string {
	return s.String()
}

func (s *GetDigitalWatermarkExtractResultResponseBody) SetAiExtractResultList(v []*GetDigitalWatermarkExtractResultResponseBodyAiExtractResultList) *GetDigitalWatermarkExtractResultResponseBody {
	s.AiExtractResultList = v
	return s
}

func (s *GetDigitalWatermarkExtractResultResponseBody) SetRequestId(v string) *GetDigitalWatermarkExtractResultResponseBody {
	s.RequestId = &v
	return s
}

type GetDigitalWatermarkExtractResultResponseBodyAiExtractResultList struct {
	// The time when the watermark extraction job was created.
	//
	// example:
	//
	// 2023-09-16T02:49:04Z
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The error message.
	//
	// example:
	//
	// successful
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the watermark extraction job.
	//
	// example:
	//
	// 3af004763bcf459698860f4ede20****
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The time when the watermark extraction job was last updated.
	//
	// example:
	//
	// 2023-09-17T06:20:45Z
	ModifyTime *string `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	// The status of the watermark extraction job. Valid values:
	//
	// 	- **Success**
	//
	// 	- **Failed**
	//
	// 	- **Processing**
	//
	// example:
	//
	// Success
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The extracted watermark content.
	//
	// example:
	//
	// test mark
	WaterMarkText *string `json:"WaterMarkText,omitempty" xml:"WaterMarkText,omitempty"`
}

func (s GetDigitalWatermarkExtractResultResponseBodyAiExtractResultList) String() string {
	return tea.Prettify(s)
}

func (s GetDigitalWatermarkExtractResultResponseBodyAiExtractResultList) GoString() string {
	return s.String()
}

func (s *GetDigitalWatermarkExtractResultResponseBodyAiExtractResultList) SetCreateTime(v string) *GetDigitalWatermarkExtractResultResponseBodyAiExtractResultList {
	s.CreateTime = &v
	return s
}

func (s *GetDigitalWatermarkExtractResultResponseBodyAiExtractResultList) SetErrorMessage(v string) *GetDigitalWatermarkExtractResultResponseBodyAiExtractResultList {
	s.ErrorMessage = &v
	return s
}

func (s *GetDigitalWatermarkExtractResultResponseBodyAiExtractResultList) SetJobId(v string) *GetDigitalWatermarkExtractResultResponseBodyAiExtractResultList {
	s.JobId = &v
	return s
}

func (s *GetDigitalWatermarkExtractResultResponseBodyAiExtractResultList) SetModifyTime(v string) *GetDigitalWatermarkExtractResultResponseBodyAiExtractResultList {
	s.ModifyTime = &v
	return s
}

func (s *GetDigitalWatermarkExtractResultResponseBodyAiExtractResultList) SetStatus(v string) *GetDigitalWatermarkExtractResultResponseBodyAiExtractResultList {
	s.Status = &v
	return s
}

func (s *GetDigitalWatermarkExtractResultResponseBodyAiExtractResultList) SetWaterMarkText(v string) *GetDigitalWatermarkExtractResultResponseBodyAiExtractResultList {
	s.WaterMarkText = &v
	return s
}

type GetDigitalWatermarkExtractResultResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetDigitalWatermarkExtractResultResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetDigitalWatermarkExtractResultResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDigitalWatermarkExtractResultResponse) GoString() string {
	return s.String()
}

func (s *GetDigitalWatermarkExtractResultResponse) SetHeaders(v map[string]*string) *GetDigitalWatermarkExtractResultResponse {
	s.Headers = v
	return s
}

func (s *GetDigitalWatermarkExtractResultResponse) SetStatusCode(v int32) *GetDigitalWatermarkExtractResultResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDigitalWatermarkExtractResultResponse) SetBody(v *GetDigitalWatermarkExtractResultResponseBody) *GetDigitalWatermarkExtractResultResponse {
	s.Body = v
	return s
}

type GetEditingProjectRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the online editing project.
	//
	// This parameter is required.
	//
	// example:
	//
	// fb2101bf24b27*****54cb318787dc
	ProjectId            *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GetEditingProjectRequest) String() string {
	return tea.Prettify(s)
}

func (s GetEditingProjectRequest) GoString() string {
	return s.String()
}

func (s *GetEditingProjectRequest) SetOwnerAccount(v string) *GetEditingProjectRequest {
	s.OwnerAccount = &v
	return s
}

func (s *GetEditingProjectRequest) SetOwnerId(v string) *GetEditingProjectRequest {
	s.OwnerId = &v
	return s
}

func (s *GetEditingProjectRequest) SetProjectId(v string) *GetEditingProjectRequest {
	s.ProjectId = &v
	return s
}

func (s *GetEditingProjectRequest) SetResourceOwnerAccount(v string) *GetEditingProjectRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GetEditingProjectRequest) SetResourceOwnerId(v string) *GetEditingProjectRequest {
	s.ResourceOwnerId = &v
	return s
}

type GetEditingProjectResponseBody struct {
	// The information about the online editing project.
	Project *GetEditingProjectResponseBodyProject `json:"Project,omitempty" xml:"Project,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// 63E8B7C7-4812-46*****AD-0FA56029AC86
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetEditingProjectResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetEditingProjectResponseBody) GoString() string {
	return s.String()
}

func (s *GetEditingProjectResponseBody) SetProject(v *GetEditingProjectResponseBodyProject) *GetEditingProjectResponseBody {
	s.Project = v
	return s
}

func (s *GetEditingProjectResponseBody) SetRequestId(v string) *GetEditingProjectResponseBody {
	s.RequestId = &v
	return s
}

type GetEditingProjectResponseBodyProject struct {
	// The thumbnail URL of the online editing project.
	//
	// example:
	//
	// https://****.com/6AB4D0E1E1C74468883516C2349****.png
	CoverURL *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	// The time when the online editing project was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-10-23T13:33:40Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the online editing project.
	//
	// example:
	//
	// testdescription
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The last time when the online editing project was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-10-23T14:27:26Z
	ModifiedTime *string `json:"ModifiedTime,omitempty" xml:"ModifiedTime,omitempty"`
	// The ID of the online editing project.
	//
	// example:
	//
	// fb2101bf24b27*****54cb318787dc
	ProjectId *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The region where the online editing project was created.
	//
	// example:
	//
	// cn-shanghai
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The status of the online editing project. Separate multiple states with commas (,). By default, all online editing projects were queried. Valid values:
	//
	// 	- **Normal**: indicates that the online editing project is in draft.
	//
	// 	- **Producing**: indicates that the video is being produced.
	//
	// 	- **Produced**: indicates that the video was produced.
	//
	// 	- **ProduceFailed**: indicates that the video failed to be produced.
	//
	// example:
	//
	// Normal
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The path of the Object Storage Service (OSS) bucket where the online editing project is stored.
	//
	// > To view the path of the OSS bucket, log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com/?spm=a2c4g.11186623.2.15.6948257eaZ4m54#/vod/settings/censored), and choose **Configuration Management*	- > **Media Management*	- > **Storage**. On the Storage page, you can view the path of the OSS bucket.
	//
	// example:
	//
	// location_s
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	// The timeline of the online editing project.
	//
	// example:
	//
	// {\\"TimelineIn\\":0,\\"TimelineOut\\":9.42}
	Timeline *string `json:"Timeline,omitempty" xml:"Timeline,omitempty"`
	// The title of the online editing project.
	//
	// example:
	//
	// video_1508736815000
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
}

func (s GetEditingProjectResponseBodyProject) String() string {
	return tea.Prettify(s)
}

func (s GetEditingProjectResponseBodyProject) GoString() string {
	return s.String()
}

func (s *GetEditingProjectResponseBodyProject) SetCoverURL(v string) *GetEditingProjectResponseBodyProject {
	s.CoverURL = &v
	return s
}

func (s *GetEditingProjectResponseBodyProject) SetCreationTime(v string) *GetEditingProjectResponseBodyProject {
	s.CreationTime = &v
	return s
}

func (s *GetEditingProjectResponseBodyProject) SetDescription(v string) *GetEditingProjectResponseBodyProject {
	s.Description = &v
	return s
}

func (s *GetEditingProjectResponseBodyProject) SetModifiedTime(v string) *GetEditingProjectResponseBodyProject {
	s.ModifiedTime = &v
	return s
}

func (s *GetEditingProjectResponseBodyProject) SetProjectId(v string) *GetEditingProjectResponseBodyProject {
	s.ProjectId = &v
	return s
}

func (s *GetEditingProjectResponseBodyProject) SetRegionId(v string) *GetEditingProjectResponseBodyProject {
	s.RegionId = &v
	return s
}

func (s *GetEditingProjectResponseBodyProject) SetStatus(v string) *GetEditingProjectResponseBodyProject {
	s.Status = &v
	return s
}

func (s *GetEditingProjectResponseBodyProject) SetStorageLocation(v string) *GetEditingProjectResponseBodyProject {
	s.StorageLocation = &v
	return s
}

func (s *GetEditingProjectResponseBodyProject) SetTimeline(v string) *GetEditingProjectResponseBodyProject {
	s.Timeline = &v
	return s
}

func (s *GetEditingProjectResponseBodyProject) SetTitle(v string) *GetEditingProjectResponseBodyProject {
	s.Title = &v
	return s
}

type GetEditingProjectResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetEditingProjectResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetEditingProjectResponse) String() string {
	return tea.Prettify(s)
}

func (s GetEditingProjectResponse) GoString() string {
	return s.String()
}

func (s *GetEditingProjectResponse) SetHeaders(v map[string]*string) *GetEditingProjectResponse {
	s.Headers = v
	return s
}

func (s *GetEditingProjectResponse) SetStatusCode(v int32) *GetEditingProjectResponse {
	s.StatusCode = &v
	return s
}

func (s *GetEditingProjectResponse) SetBody(v *GetEditingProjectResponseBody) *GetEditingProjectResponse {
	s.Body = v
	return s
}

type GetEditingProjectMaterialsRequest struct {
	// The type of the material. Valid values:
	//
	// 	- **video**
	//
	// 	- **audio**
	//
	// 	- **image**
	//
	// example:
	//
	// video
	MaterialType *string `json:"MaterialType,omitempty" xml:"MaterialType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the online editing project. You can use one of the following methods to obtain the ID of the online editing project:
	//
	// 	- Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Production Center*	- > **Video Editing*	- to obtain the ID of the specified online editing project.
	//
	// 	- Call the **AddEditingProject*	- operation. The value of the response parameter ProjectId is the ID of the specified online editing project.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1982361011093374****
	ProjectId            *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the material. Valid values:
	//
	// 	- **video**
	//
	// 	- **audio**
	//
	// example:
	//
	// video
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetEditingProjectMaterialsRequest) String() string {
	return tea.Prettify(s)
}

func (s GetEditingProjectMaterialsRequest) GoString() string {
	return s.String()
}

func (s *GetEditingProjectMaterialsRequest) SetMaterialType(v string) *GetEditingProjectMaterialsRequest {
	s.MaterialType = &v
	return s
}

func (s *GetEditingProjectMaterialsRequest) SetOwnerAccount(v string) *GetEditingProjectMaterialsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *GetEditingProjectMaterialsRequest) SetOwnerId(v string) *GetEditingProjectMaterialsRequest {
	s.OwnerId = &v
	return s
}

func (s *GetEditingProjectMaterialsRequest) SetProjectId(v string) *GetEditingProjectMaterialsRequest {
	s.ProjectId = &v
	return s
}

func (s *GetEditingProjectMaterialsRequest) SetResourceOwnerAccount(v string) *GetEditingProjectMaterialsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GetEditingProjectMaterialsRequest) SetResourceOwnerId(v string) *GetEditingProjectMaterialsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *GetEditingProjectMaterialsRequest) SetType(v string) *GetEditingProjectMaterialsRequest {
	s.Type = &v
	return s
}

type GetEditingProjectMaterialsResponseBody struct {
	// The materials.
	MaterialList *GetEditingProjectMaterialsResponseBodyMaterialList `json:"MaterialList,omitempty" xml:"MaterialList,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// 746FFA07-8BBB-46B1-3E94E3B2915E****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetEditingProjectMaterialsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetEditingProjectMaterialsResponseBody) GoString() string {
	return s.String()
}

func (s *GetEditingProjectMaterialsResponseBody) SetMaterialList(v *GetEditingProjectMaterialsResponseBodyMaterialList) *GetEditingProjectMaterialsResponseBody {
	s.MaterialList = v
	return s
}

func (s *GetEditingProjectMaterialsResponseBody) SetRequestId(v string) *GetEditingProjectMaterialsResponseBody {
	s.RequestId = &v
	return s
}

type GetEditingProjectMaterialsResponseBodyMaterialList struct {
	Material []*GetEditingProjectMaterialsResponseBodyMaterialListMaterial `json:"Material,omitempty" xml:"Material,omitempty" type:"Repeated"`
}

func (s GetEditingProjectMaterialsResponseBodyMaterialList) String() string {
	return tea.Prettify(s)
}

func (s GetEditingProjectMaterialsResponseBodyMaterialList) GoString() string {
	return s.String()
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialList) SetMaterial(v []*GetEditingProjectMaterialsResponseBodyMaterialListMaterial) *GetEditingProjectMaterialsResponseBodyMaterialList {
	s.Material = v
	return s
}

type GetEditingProjectMaterialsResponseBodyMaterialListMaterial struct {
	// The category ID of the material.
	//
	// example:
	//
	// 100005****
	CateId *int32 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The category name of the material.
	//
	// example:
	//
	// test1
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	// The thumbnail URL of the material.
	CoverURL *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	// The time when the material was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-10-19 10:48:17
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the material.
	//
	// example:
	//
	// test2
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The duration of the material. The value is rounded to four decimal places. Unit: seconds.
	//
	// example:
	//
	// 15.16
	Duration *float32 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The ID of the material.
	//
	// example:
	//
	// 85befc4118b84c6723e53b80b1****
	MaterialId *string `json:"MaterialId,omitempty" xml:"MaterialId,omitempty"`
	// The type of the material. Valid values:
	//
	// 	- **video**
	//
	// 	- **audio**
	//
	// 	- **image**
	//
	// example:
	//
	// video
	MaterialType *string `json:"MaterialType,omitempty" xml:"MaterialType,omitempty"`
	// The time when the material was last updated. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-10-19 10:48:17
	ModifiedTime *string `json:"ModifiedTime,omitempty" xml:"ModifiedTime,omitempty"`
	// The size of the mezzanine file. Unit: byte.
	//
	// example:
	//
	// 1682694
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The URLs of material snapshots. The value is an array.
	Snapshots *GetEditingProjectMaterialsResponseBodyMaterialListMaterialSnapshots `json:"Snapshots,omitempty" xml:"Snapshots,omitempty" type:"Struct"`
	// The source of the sprite.
	//
	// example:
	//
	// xxx
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The configuration of the sprite.
	//
	// example:
	//
	// xxx
	SpriteConfig *string `json:"SpriteConfig,omitempty" xml:"SpriteConfig,omitempty"`
	// The URLs of material sprites. The value is an array.
	Sprites *GetEditingProjectMaterialsResponseBodyMaterialListMaterialSprites `json:"Sprites,omitempty" xml:"Sprites,omitempty" type:"Struct"`
	// The status of the material. Valid values:
	//
	// 	- **Normal**: The material is in draft.
	//
	// 	- **Producing**: The material is being produced.
	//
	// 	- **Produced**: The material was produced.
	//
	// 	- **ProduceFailed**: The material failed to be produced.
	//
	// example:
	//
	// Normal
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tag of the material. Multiple tags are separated by commas (,).
	//
	// example:
	//
	// editing test
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The title of the material.
	//
	// example:
	//
	// test
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
}

func (s GetEditingProjectMaterialsResponseBodyMaterialListMaterial) String() string {
	return tea.Prettify(s)
}

func (s GetEditingProjectMaterialsResponseBodyMaterialListMaterial) GoString() string {
	return s.String()
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetCateId(v int32) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.CateId = &v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetCateName(v string) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.CateName = &v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetCoverURL(v string) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.CoverURL = &v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetCreationTime(v string) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.CreationTime = &v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetDescription(v string) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.Description = &v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetDuration(v float32) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.Duration = &v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetMaterialId(v string) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.MaterialId = &v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetMaterialType(v string) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.MaterialType = &v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetModifiedTime(v string) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.ModifiedTime = &v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetSize(v int64) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.Size = &v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetSnapshots(v *GetEditingProjectMaterialsResponseBodyMaterialListMaterialSnapshots) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.Snapshots = v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetSource(v string) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.Source = &v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetSpriteConfig(v string) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.SpriteConfig = &v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetSprites(v *GetEditingProjectMaterialsResponseBodyMaterialListMaterialSprites) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.Sprites = v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetStatus(v string) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.Status = &v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetTags(v string) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.Tags = &v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetTitle(v string) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.Title = &v
	return s
}

type GetEditingProjectMaterialsResponseBodyMaterialListMaterialSnapshots struct {
	Snapshot []*string `json:"Snapshot,omitempty" xml:"Snapshot,omitempty" type:"Repeated"`
}

func (s GetEditingProjectMaterialsResponseBodyMaterialListMaterialSnapshots) String() string {
	return tea.Prettify(s)
}

func (s GetEditingProjectMaterialsResponseBodyMaterialListMaterialSnapshots) GoString() string {
	return s.String()
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterialSnapshots) SetSnapshot(v []*string) *GetEditingProjectMaterialsResponseBodyMaterialListMaterialSnapshots {
	s.Snapshot = v
	return s
}

type GetEditingProjectMaterialsResponseBodyMaterialListMaterialSprites struct {
	Sprite []*string `json:"Sprite,omitempty" xml:"Sprite,omitempty" type:"Repeated"`
}

func (s GetEditingProjectMaterialsResponseBodyMaterialListMaterialSprites) String() string {
	return tea.Prettify(s)
}

func (s GetEditingProjectMaterialsResponseBodyMaterialListMaterialSprites) GoString() string {
	return s.String()
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterialSprites) SetSprite(v []*string) *GetEditingProjectMaterialsResponseBodyMaterialListMaterialSprites {
	s.Sprite = v
	return s
}

type GetEditingProjectMaterialsResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetEditingProjectMaterialsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetEditingProjectMaterialsResponse) String() string {
	return tea.Prettify(s)
}

func (s GetEditingProjectMaterialsResponse) GoString() string {
	return s.String()
}

func (s *GetEditingProjectMaterialsResponse) SetHeaders(v map[string]*string) *GetEditingProjectMaterialsResponse {
	s.Headers = v
	return s
}

func (s *GetEditingProjectMaterialsResponse) SetStatusCode(v int32) *GetEditingProjectMaterialsResponse {
	s.StatusCode = &v
	return s
}

func (s *GetEditingProjectMaterialsResponse) SetBody(v *GetEditingProjectMaterialsResponseBody) *GetEditingProjectMaterialsResponse {
	s.Body = v
	return s
}

type GetImageInfoRequest struct {
	// The time when the image URL expires. Unit: seconds.
	//
	// 	- If you set OutputType to cdn:
	//
	//     	- This parameter takes effect only if URL authentication is enabled. Otherwise, the image URL does not expire.
	//
	//     	- Minimum value: 1.
	//
	//     	- Maximum value: unlimited.
	//
	//     	- Default value: If you leave this parameter empty, the default validity period that is specified in URL signing is used.
	//
	// 	- If you set OutputType to oss:
	//
	//     	- This parameter takes effect only when the ACL of the Object Storage Service (OSS) bucket is private. Otherwise, the image URL does not expire.
	//
	//     	- Minimum value: 1.
	//
	//     	- If you store the image in the VOD bucket, the maximum value of this parameter is **2592000*	- (30 days). If you store the image in an OSS bucket, the maximum value of this parameter is **129600*	- (36 hours). The maximum value is limited to reduce security risks of the origin.
	//
	//     	- Default value: 3600.
	//
	// example:
	//
	// 3600
	AuthTimeout *int64 `json:"AuthTimeout,omitempty" xml:"AuthTimeout,omitempty"`
	// The ID of the image. You can use one of the following methods to obtain the ID:
	//
	// 	- Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com/). In the left-side navigation pane, choose Media Files > Image. On the Image page, view the image ID.
	//
	// 	- Obtain the image ID from the response to the [CreateUploadImage](~~CreateUploadImage~~) operation that you call to obtain the upload URL and credential.
	//
	// 	- Obtain the image ID from the response to the [SearchMedia](~~SearchMedia~~) operation that you call to query the image.
	//
	// This parameter is required.
	//
	// example:
	//
	// 3e34733b40b9a96ccf5c1ff6f69****
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The type of the output image URL. Valid values:
	//
	// 	- oss: OSS URL
	//
	// 	- cdn: CDN URL
	//
	// example:
	//
	// cdn
	OutputType *string `json:"OutputType,omitempty" xml:"OutputType,omitempty"`
}

func (s GetImageInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s GetImageInfoRequest) GoString() string {
	return s.String()
}

func (s *GetImageInfoRequest) SetAuthTimeout(v int64) *GetImageInfoRequest {
	s.AuthTimeout = &v
	return s
}

func (s *GetImageInfoRequest) SetImageId(v string) *GetImageInfoRequest {
	s.ImageId = &v
	return s
}

func (s *GetImageInfoRequest) SetOutputType(v string) *GetImageInfoRequest {
	s.OutputType = &v
	return s
}

type GetImageInfoResponseBody struct {
	// The information about the image.
	ImageInfo *GetImageInfoResponseBodyImageInfo `json:"ImageInfo,omitempty" xml:"ImageInfo,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// AB99D4DF-FAFA-49DC-9C548C1E261E****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetImageInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetImageInfoResponseBody) GoString() string {
	return s.String()
}

func (s *GetImageInfoResponseBody) SetImageInfo(v *GetImageInfoResponseBodyImageInfo) *GetImageInfoResponseBody {
	s.ImageInfo = v
	return s
}

func (s *GetImageInfoResponseBody) SetRequestId(v string) *GetImageInfoResponseBody {
	s.RequestId = &v
	return s
}

type GetImageInfoResponseBodyImageInfo struct {
	// The ID of the application.
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the category.
	//
	// example:
	//
	// 254766071
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The name of the category.
	//
	// example:
	//
	// test name
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	// The time when the image was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2018-11-21T02:37:23Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the image.
	//
	// example:
	//
	// test description
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the image.
	//
	// example:
	//
	// bbc65bba53f9*****ed90de118a7849
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The type of the image. Valid values:
	//
	// 	- **CoverSnapshot**: thumbnail snapshot.
	//
	// 	- **NormalSnapshot**: normal snapshot.
	//
	// 	- **SpriteSnapshot**: sprite snapshot.
	//
	// 	- **SpriteOriginSnapshot**: sprite source snapshot.
	//
	// 	- **All**: images of all the preceding types. Multiple types other than All can return for this parameter. Multiple types are separated by commas (,).
	//
	// example:
	//
	// NormalSnapshot
	ImageType *string `json:"ImageType,omitempty" xml:"ImageType,omitempty"`
	// The source information about the image.
	Mezzanine *GetImageInfoResponseBodyImageInfoMezzanine `json:"Mezzanine,omitempty" xml:"Mezzanine,omitempty" type:"Struct"`
	// The status of the image. Valid values:
	//
	// 	- **Uploading**: The image is being uploaded. This is the initial status.
	//
	// 	- **Normal**: The image is uploaded.
	//
	// 	- **UploadFail**: The image fails to be uploaded.
	//
	// example:
	//
	// Uploading
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The bucket in which the image is stored.
	//
	// example:
	//
	// outin-****..oss-cn-shanghai.aliyuncs.com
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	// The tags of the image. Multiple tags are separated by commas (,).
	//
	// example:
	//
	// tag1,tag2,tag3
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The title of the image.
	//
	// example:
	//
	// this is a sample
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The image URL. If a domain name for CDN is specified, a CDN URL is returned. Otherwise, an OSS URL is returned.
	//
	// example:
	//
	// http://example.aliyundoc.com/image/default/****.gif?auth_key=****
	URL *string `json:"URL,omitempty" xml:"URL,omitempty"`
}

func (s GetImageInfoResponseBodyImageInfo) String() string {
	return tea.Prettify(s)
}

func (s GetImageInfoResponseBodyImageInfo) GoString() string {
	return s.String()
}

func (s *GetImageInfoResponseBodyImageInfo) SetAppId(v string) *GetImageInfoResponseBodyImageInfo {
	s.AppId = &v
	return s
}

func (s *GetImageInfoResponseBodyImageInfo) SetCateId(v int64) *GetImageInfoResponseBodyImageInfo {
	s.CateId = &v
	return s
}

func (s *GetImageInfoResponseBodyImageInfo) SetCateName(v string) *GetImageInfoResponseBodyImageInfo {
	s.CateName = &v
	return s
}

func (s *GetImageInfoResponseBodyImageInfo) SetCreationTime(v string) *GetImageInfoResponseBodyImageInfo {
	s.CreationTime = &v
	return s
}

func (s *GetImageInfoResponseBodyImageInfo) SetDescription(v string) *GetImageInfoResponseBodyImageInfo {
	s.Description = &v
	return s
}

func (s *GetImageInfoResponseBodyImageInfo) SetImageId(v string) *GetImageInfoResponseBodyImageInfo {
	s.ImageId = &v
	return s
}

func (s *GetImageInfoResponseBodyImageInfo) SetImageType(v string) *GetImageInfoResponseBodyImageInfo {
	s.ImageType = &v
	return s
}

func (s *GetImageInfoResponseBodyImageInfo) SetMezzanine(v *GetImageInfoResponseBodyImageInfoMezzanine) *GetImageInfoResponseBodyImageInfo {
	s.Mezzanine = v
	return s
}

func (s *GetImageInfoResponseBodyImageInfo) SetStatus(v string) *GetImageInfoResponseBodyImageInfo {
	s.Status = &v
	return s
}

func (s *GetImageInfoResponseBodyImageInfo) SetStorageLocation(v string) *GetImageInfoResponseBodyImageInfo {
	s.StorageLocation = &v
	return s
}

func (s *GetImageInfoResponseBodyImageInfo) SetTags(v string) *GetImageInfoResponseBodyImageInfo {
	s.Tags = &v
	return s
}

func (s *GetImageInfoResponseBodyImageInfo) SetTitle(v string) *GetImageInfoResponseBodyImageInfo {
	s.Title = &v
	return s
}

func (s *GetImageInfoResponseBodyImageInfo) SetURL(v string) *GetImageInfoResponseBodyImageInfo {
	s.URL = &v
	return s
}

type GetImageInfoResponseBodyImageInfoMezzanine struct {
	// The size of the image. Unit: bytes.
	//
	// example:
	//
	// 8932
	FileSize *string `json:"FileSize,omitempty" xml:"FileSize,omitempty"`
	// The OSS URL of the image file.
	//
	// example:
	//
	// https://outin-bfefbb*****163e1c7426.oss-cn-XXXXXXXX.aliyuncs.com/image/default/5E84CD536*****D4DAD.png?Expires=1590982353&OSSAccessKeyId=*****&Signature=ALPET74o*****c%3D
	FileURL *string `json:"FileURL,omitempty" xml:"FileURL,omitempty"`
	// The height of the image. Unit: pixels.
	//
	// example:
	//
	// 200
	Height *int32 `json:"Height,omitempty" xml:"Height,omitempty"`
	// The URL of the source file.
	//
	// example:
	//
	// ****.gif
	OriginalFileName *string `json:"OriginalFileName,omitempty" xml:"OriginalFileName,omitempty"`
	// The width of the image. Unit: pixels.
	//
	// example:
	//
	// 200
	Width *int32 `json:"Width,omitempty" xml:"Width,omitempty"`
}

func (s GetImageInfoResponseBodyImageInfoMezzanine) String() string {
	return tea.Prettify(s)
}

func (s GetImageInfoResponseBodyImageInfoMezzanine) GoString() string {
	return s.String()
}

func (s *GetImageInfoResponseBodyImageInfoMezzanine) SetFileSize(v string) *GetImageInfoResponseBodyImageInfoMezzanine {
	s.FileSize = &v
	return s
}

func (s *GetImageInfoResponseBodyImageInfoMezzanine) SetFileURL(v string) *GetImageInfoResponseBodyImageInfoMezzanine {
	s.FileURL = &v
	return s
}

func (s *GetImageInfoResponseBodyImageInfoMezzanine) SetHeight(v int32) *GetImageInfoResponseBodyImageInfoMezzanine {
	s.Height = &v
	return s
}

func (s *GetImageInfoResponseBodyImageInfoMezzanine) SetOriginalFileName(v string) *GetImageInfoResponseBodyImageInfoMezzanine {
	s.OriginalFileName = &v
	return s
}

func (s *GetImageInfoResponseBodyImageInfoMezzanine) SetWidth(v int32) *GetImageInfoResponseBodyImageInfoMezzanine {
	s.Width = &v
	return s
}

type GetImageInfoResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetImageInfoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetImageInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s GetImageInfoResponse) GoString() string {
	return s.String()
}

func (s *GetImageInfoResponse) SetHeaders(v map[string]*string) *GetImageInfoResponse {
	s.Headers = v
	return s
}

func (s *GetImageInfoResponse) SetStatusCode(v int32) *GetImageInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *GetImageInfoResponse) SetBody(v *GetImageInfoResponseBody) *GetImageInfoResponse {
	s.Body = v
	return s
}

type GetImageInfosRequest struct {
	// The time when the image URL expires. Unit: seconds.
	//
	// 	- If the OutputType parameter is set to cdn:
	//
	//     	- This parameter takes effect only if URL authentication is enabled. Otherwise, the image URL does not expire.
	//
	//     	- Minimum value: 1.
	//
	//     	- Maximum value: unlimited.
	//
	//     	- Default value: The default validity period that is specified in URL authentication is used.
	//
	// 	- If the OutputType parameter is set to oss:
	//
	//     	- This parameter takes effect only when the ACL of the Object Storage Service (OSS) bucket is private. Otherwise, the image URL does not expire.
	//
	//     	- Minimum value: 1.
	//
	//     	- If you store the image in the VOD bucket, the maximum value of this parameter is **2592000*	- (30 days). If you store the image in an OSS bucket, the maximum value of this parameter is **129600*	- (36 hours). The maximum value is limited to reduce security risks of the origin.
	//
	//     	- Default value: 3600.
	//
	// example:
	//
	// 3600
	AuthTimeout *int64 `json:"AuthTimeout,omitempty" xml:"AuthTimeout,omitempty"`
	// The image IDs. Separate multiple IDs with commas (,). You can specify up to 20 image IDs. You can use one of the following methods to obtain the ID:
	//
	// 	- Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com/) and choose **Media Files > Images*	- in the left-side navigation pane.
	//
	// 	- Obtain the value of ImageId from the response to the CreateUploadImage operation that you call to obtain the upload URL and credential.
	//
	// 	- Obtain the value of ImageId from the response to the [SearchMedia](~~SearchMedia~~) operation after you upload images.
	//
	// This parameter is required.
	//
	// example:
	//
	// bbc65bba53fed90de118a7849****,594228cdd14b4d069fc17a8c4a****
	ImageIds *string `json:"ImageIds,omitempty" xml:"ImageIds,omitempty"`
	// The type of the output image URL. Valid values:
	//
	// 	- oss: OSS URL
	//
	// 	- cdn: CDN URL
	//
	// example:
	//
	// cdn
	OutputType *string `json:"OutputType,omitempty" xml:"OutputType,omitempty"`
}

func (s GetImageInfosRequest) String() string {
	return tea.Prettify(s)
}

func (s GetImageInfosRequest) GoString() string {
	return s.String()
}

func (s *GetImageInfosRequest) SetAuthTimeout(v int64) *GetImageInfosRequest {
	s.AuthTimeout = &v
	return s
}

func (s *GetImageInfosRequest) SetImageIds(v string) *GetImageInfosRequest {
	s.ImageIds = &v
	return s
}

func (s *GetImageInfosRequest) SetOutputType(v string) *GetImageInfosRequest {
	s.OutputType = &v
	return s
}

type GetImageInfosResponseBody struct {
	// The image information.
	ImageInfo []*GetImageInfosResponseBodyImageInfo `json:"ImageInfo,omitempty" xml:"ImageInfo,omitempty" type:"Repeated"`
	// The IDs of the images that do not exist.
	NonExistImageIds []*string `json:"NonExistImageIds,omitempty" xml:"NonExistImageIds,omitempty" type:"Repeated"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4AF6-D7393642CA58*****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetImageInfosResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetImageInfosResponseBody) GoString() string {
	return s.String()
}

func (s *GetImageInfosResponseBody) SetImageInfo(v []*GetImageInfosResponseBodyImageInfo) *GetImageInfosResponseBody {
	s.ImageInfo = v
	return s
}

func (s *GetImageInfosResponseBody) SetNonExistImageIds(v []*string) *GetImageInfosResponseBody {
	s.NonExistImageIds = v
	return s
}

func (s *GetImageInfosResponseBody) SetRequestId(v string) *GetImageInfosResponseBody {
	s.RequestId = &v
	return s
}

type GetImageInfosResponseBodyImageInfo struct {
	// The ID of the application.
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the category.
	//
	// example:
	//
	// 254766071
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The name of the category.
	//
	// example:
	//
	// Test
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	// The time when the image was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2018-11-21T02:37:23Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the image.
	//
	// example:
	//
	// Test description
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the image.
	//
	// example:
	//
	// bbc65bba53f9*****ed90de118a7849
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The type of the image. Valid values:
	//
	// 	- **default**: regular images
	//
	// 	- **cover**: video thumbnail
	//
	// example:
	//
	// NormalSnapshot
	ImageType *string `json:"ImageType,omitempty" xml:"ImageType,omitempty"`
	// The source information about the image.
	Mezzanine *GetImageInfosResponseBodyImageInfoMezzanine `json:"Mezzanine,omitempty" xml:"Mezzanine,omitempty" type:"Struct"`
	// The status of the image file. Valid values:
	//
	// 	- **Uploading**: The image is being uploaded. This is the initial status.
	//
	// 	- **Normal**: The image is uploaded.
	//
	// 	- **UploadFail**: The image fails to be uploaded.
	//
	// example:
	//
	// Uploading
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The bucket in which the image is stored.
	//
	// example:
	//
	// outin-****..oss-cn-shanghai.aliyuncs.com
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	// The tags of the image. Multiple tags are separated by commas (,).
	//
	// example:
	//
	// tag1,tag2,tag3
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The title of the image.
	//
	// example:
	//
	// this is a sample
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The image URL. If a domain name for CDN is specified, a CDN URL is returned. Otherwise, an OSS URL is returned.
	//
	// example:
	//
	// http://example.aliyundoc.com/image/default/****.gif?auth_key=****
	URL *string `json:"URL,omitempty" xml:"URL,omitempty"`
}

func (s GetImageInfosResponseBodyImageInfo) String() string {
	return tea.Prettify(s)
}

func (s GetImageInfosResponseBodyImageInfo) GoString() string {
	return s.String()
}

func (s *GetImageInfosResponseBodyImageInfo) SetAppId(v string) *GetImageInfosResponseBodyImageInfo {
	s.AppId = &v
	return s
}

func (s *GetImageInfosResponseBodyImageInfo) SetCateId(v int64) *GetImageInfosResponseBodyImageInfo {
	s.CateId = &v
	return s
}

func (s *GetImageInfosResponseBodyImageInfo) SetCateName(v string) *GetImageInfosResponseBodyImageInfo {
	s.CateName = &v
	return s
}

func (s *GetImageInfosResponseBodyImageInfo) SetCreationTime(v string) *GetImageInfosResponseBodyImageInfo {
	s.CreationTime = &v
	return s
}

func (s *GetImageInfosResponseBodyImageInfo) SetDescription(v string) *GetImageInfosResponseBodyImageInfo {
	s.Description = &v
	return s
}

func (s *GetImageInfosResponseBodyImageInfo) SetImageId(v string) *GetImageInfosResponseBodyImageInfo {
	s.ImageId = &v
	return s
}

func (s *GetImageInfosResponseBodyImageInfo) SetImageType(v string) *GetImageInfosResponseBodyImageInfo {
	s.ImageType = &v
	return s
}

func (s *GetImageInfosResponseBodyImageInfo) SetMezzanine(v *GetImageInfosResponseBodyImageInfoMezzanine) *GetImageInfosResponseBodyImageInfo {
	s.Mezzanine = v
	return s
}

func (s *GetImageInfosResponseBodyImageInfo) SetStatus(v string) *GetImageInfosResponseBodyImageInfo {
	s.Status = &v
	return s
}

func (s *GetImageInfosResponseBodyImageInfo) SetStorageLocation(v string) *GetImageInfosResponseBodyImageInfo {
	s.StorageLocation = &v
	return s
}

func (s *GetImageInfosResponseBodyImageInfo) SetTags(v string) *GetImageInfosResponseBodyImageInfo {
	s.Tags = &v
	return s
}

func (s *GetImageInfosResponseBodyImageInfo) SetTitle(v string) *GetImageInfosResponseBodyImageInfo {
	s.Title = &v
	return s
}

func (s *GetImageInfosResponseBodyImageInfo) SetURL(v string) *GetImageInfosResponseBodyImageInfo {
	s.URL = &v
	return s
}

type GetImageInfosResponseBodyImageInfoMezzanine struct {
	// The size of the file to be uploaded. Unit: bytes.
	//
	// example:
	//
	// 8932
	FileSize *string `json:"FileSize,omitempty" xml:"FileSize,omitempty"`
	// The OSS URL of the image file.
	//
	// example:
	//
	// https://outin-bfefbb*****163e1c7426.oss-cn-XXXXXXXX.aliyuncs.com/image/default/5E84CD536*****D4DAD.png?Expires=1590982353&OSSAccessKeyId=*****&Signature=ALPET74o*****c%3D
	FileURL *string `json:"FileURL,omitempty" xml:"FileURL,omitempty"`
	// The height of the image. Unit: pixels.
	//
	// example:
	//
	// 200
	Height *int32 `json:"Height,omitempty" xml:"Height,omitempty"`
	// The URL of the source file.
	//
	// example:
	//
	// ****.gif
	OriginalFileName *string `json:"OriginalFileName,omitempty" xml:"OriginalFileName,omitempty"`
	// The width of the image. Unit: pixels.
	//
	// example:
	//
	// 200
	Width *int32 `json:"Width,omitempty" xml:"Width,omitempty"`
}

func (s GetImageInfosResponseBodyImageInfoMezzanine) String() string {
	return tea.Prettify(s)
}

func (s GetImageInfosResponseBodyImageInfoMezzanine) GoString() string {
	return s.String()
}

func (s *GetImageInfosResponseBodyImageInfoMezzanine) SetFileSize(v string) *GetImageInfosResponseBodyImageInfoMezzanine {
	s.FileSize = &v
	return s
}

func (s *GetImageInfosResponseBodyImageInfoMezzanine) SetFileURL(v string) *GetImageInfosResponseBodyImageInfoMezzanine {
	s.FileURL = &v
	return s
}

func (s *GetImageInfosResponseBodyImageInfoMezzanine) SetHeight(v int32) *GetImageInfosResponseBodyImageInfoMezzanine {
	s.Height = &v
	return s
}

func (s *GetImageInfosResponseBodyImageInfoMezzanine) SetOriginalFileName(v string) *GetImageInfosResponseBodyImageInfoMezzanine {
	s.OriginalFileName = &v
	return s
}

func (s *GetImageInfosResponseBodyImageInfoMezzanine) SetWidth(v int32) *GetImageInfosResponseBodyImageInfoMezzanine {
	s.Width = &v
	return s
}

type GetImageInfosResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetImageInfosResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetImageInfosResponse) String() string {
	return tea.Prettify(s)
}

func (s GetImageInfosResponse) GoString() string {
	return s.String()
}

func (s *GetImageInfosResponse) SetHeaders(v map[string]*string) *GetImageInfosResponse {
	s.Headers = v
	return s
}

func (s *GetImageInfosResponse) SetStatusCode(v int32) *GetImageInfosResponse {
	s.StatusCode = &v
	return s
}

func (s *GetImageInfosResponse) SetBody(v *GetImageInfosResponseBody) *GetImageInfosResponse {
	s.Body = v
	return s
}

type GetJobDetailRequest struct {
	// The ID of the task.
	//
	// This parameter is required.
	//
	// example:
	//
	// 5c9dff***************59d50a967f5
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The task type. Valid values:
	//
	// 	- transcode
	//
	// 	- snapshot
	//
	// 	- ai
	//
	// This parameter is required.
	//
	// example:
	//
	// transcode
	JobType *string `json:"JobType,omitempty" xml:"JobType,omitempty"`
}

func (s GetJobDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetJobDetailRequest) GoString() string {
	return s.String()
}

func (s *GetJobDetailRequest) SetJobId(v string) *GetJobDetailRequest {
	s.JobId = &v
	return s
}

func (s *GetJobDetailRequest) SetJobType(v string) *GetJobDetailRequest {
	s.JobType = &v
	return s
}

type GetJobDetailResponseBody struct {
	// The details of the AI task. This parameter takes effect only when the TaskType parameter is set to AI.
	AIJobDetail *GetJobDetailResponseBodyAIJobDetail `json:"AIJobDetail,omitempty" xml:"AIJobDetail,omitempty" type:"Struct"`
	// The type of the task. Valid values:
	//
	// example:
	//
	// transcode
	JobType *string `json:"JobType,omitempty" xml:"JobType,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 6708D849-F109-1A6C-AC91-************
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The details of the snapshot task. This parameter takes effect only when the jobType parameter is set to Snapshot.
	SnapshotJobDetail *GetJobDetailResponseBodySnapshotJobDetail `json:"SnapshotJobDetail,omitempty" xml:"SnapshotJobDetail,omitempty" type:"Struct"`
	// The details of the transcoding task. This parameter takes effect only when the jobType parameter is set to Transcode.
	TranscodeJobDetail *GetJobDetailResponseBodyTranscodeJobDetail `json:"TranscodeJobDetail,omitempty" xml:"TranscodeJobDetail,omitempty" type:"Struct"`
}

func (s GetJobDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetJobDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetJobDetailResponseBody) SetAIJobDetail(v *GetJobDetailResponseBodyAIJobDetail) *GetJobDetailResponseBody {
	s.AIJobDetail = v
	return s
}

func (s *GetJobDetailResponseBody) SetJobType(v string) *GetJobDetailResponseBody {
	s.JobType = &v
	return s
}

func (s *GetJobDetailResponseBody) SetRequestId(v string) *GetJobDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetJobDetailResponseBody) SetSnapshotJobDetail(v *GetJobDetailResponseBodySnapshotJobDetail) *GetJobDetailResponseBody {
	s.SnapshotJobDetail = v
	return s
}

func (s *GetJobDetailResponseBody) SetTranscodeJobDetail(v *GetJobDetailResponseBodyTranscodeJobDetail) *GetJobDetailResponseBody {
	s.TranscodeJobDetail = v
	return s
}

type GetJobDetailResponseBodyAIJobDetail struct {
	// The end time of the task.
	//
	// example:
	//
	// 2024-10-14T07:39:46Z
	CompleteTime *string `json:"CompleteTime,omitempty" xml:"CompleteTime,omitempty"`
	// The time when the task was created. The time follows the ISO 8601 standard in the YYYY-MM-DDTHH:mm:ssZ format. The time is displayed in UTC.
	//
	// example:
	//
	// 2024-10-14T07:39:25Z
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the task.
	//
	// example:
	//
	// 5c9dff751ba**********59d50a967f5
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The type of the AI task.
	//
	// example:
	//
	// AIVideoCensor
	JobType *string `json:"JobType,omitempty" xml:"JobType,omitempty"`
	// The ID of the media asset.
	//
	// example:
	//
	// 30e5d7**********bd900764de7c0102
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The status of the task. Valid values:
	//
	// 	- reserved
	//
	// 	- init
	//
	// 	- success
	//
	// 	- fail
	//
	// 	- processing
	//
	// 	- analysing
	//
	// example:
	//
	// success
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The template configuration.
	//
	// example:
	//
	// {"AuditRange":["video","image-cover","text-title"],"AuditContent":["screen"],"AuditItem":["terrorism","porn"],"AuditAutoBlock":"no"}
	TemplateConfig *string `json:"TemplateConfig,omitempty" xml:"TemplateConfig,omitempty"`
	// The trigger mode. Valid values:
	//
	// 	- Auto
	//
	// 	- Manual
	//
	// example:
	//
	// Auto
	Trigger *string `json:"Trigger,omitempty" xml:"Trigger,omitempty"`
	// The ID of the user who submitted the task.
	//
	// example:
	//
	// 139109*****84930
	UserId *int64 `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s GetJobDetailResponseBodyAIJobDetail) String() string {
	return tea.Prettify(s)
}

func (s GetJobDetailResponseBodyAIJobDetail) GoString() string {
	return s.String()
}

func (s *GetJobDetailResponseBodyAIJobDetail) SetCompleteTime(v string) *GetJobDetailResponseBodyAIJobDetail {
	s.CompleteTime = &v
	return s
}

func (s *GetJobDetailResponseBodyAIJobDetail) SetCreateTime(v string) *GetJobDetailResponseBodyAIJobDetail {
	s.CreateTime = &v
	return s
}

func (s *GetJobDetailResponseBodyAIJobDetail) SetJobId(v string) *GetJobDetailResponseBodyAIJobDetail {
	s.JobId = &v
	return s
}

func (s *GetJobDetailResponseBodyAIJobDetail) SetJobType(v string) *GetJobDetailResponseBodyAIJobDetail {
	s.JobType = &v
	return s
}

func (s *GetJobDetailResponseBodyAIJobDetail) SetMediaId(v string) *GetJobDetailResponseBodyAIJobDetail {
	s.MediaId = &v
	return s
}

func (s *GetJobDetailResponseBodyAIJobDetail) SetStatus(v string) *GetJobDetailResponseBodyAIJobDetail {
	s.Status = &v
	return s
}

func (s *GetJobDetailResponseBodyAIJobDetail) SetTemplateConfig(v string) *GetJobDetailResponseBodyAIJobDetail {
	s.TemplateConfig = &v
	return s
}

func (s *GetJobDetailResponseBodyAIJobDetail) SetTrigger(v string) *GetJobDetailResponseBodyAIJobDetail {
	s.Trigger = &v
	return s
}

func (s *GetJobDetailResponseBodyAIJobDetail) SetUserId(v int64) *GetJobDetailResponseBodyAIJobDetail {
	s.UserId = &v
	return s
}

type GetJobDetailResponseBodySnapshotJobDetail struct {
	// The time when the task was complete.
	//
	// example:
	//
	// 2024-10-14T07:39:45Z
	CompleteTime *string `json:"CompleteTime,omitempty" xml:"CompleteTime,omitempty"`
	// The time when the task was created. The time follows the ISO 8601 standard in the YYYY-MM-DDTHH:mm:ssZ format. The time is displayed in UTC.
	//
	// example:
	//
	// 2024-10-14T07:39:25Z
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the task.
	//
	// example:
	//
	// 63df12s0**********4hdq249t82kr91
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// Configuration of normal snapshots.
	//
	// example:
	//
	// {"inl":0,"num":32,"tm":5,"wd":"352","ft":"normal","hg":"640"}
	NormalConfig *string `json:"NormalConfig,omitempty" xml:"NormalConfig,omitempty"`
	// The sprite configuration.
	//
	// example:
	//
	// {"pad":"0","lines":"10","mgin":"0","cols":"10","ikcp":"false","hg":"68"}
	SpriteConfig *string `json:"SpriteConfig,omitempty" xml:"SpriteConfig,omitempty"`
	// The status of the task. Valid values:
	//
	// 	- Processing
	//
	// 	- Fail
	//
	// 	- Success
	//
	// example:
	//
	// Success
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The trigger mode. Valid values:
	//
	// 	- Auto
	//
	// 	- Manual
	//
	// example:
	//
	// Auto
	Trigger *string `json:"Trigger,omitempty" xml:"Trigger,omitempty"`
	// The ID of the user who submitted the task.
	//
	// example:
	//
	// 139109*****84930
	UserId *int64 `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The ID of the media asset.
	//
	// example:
	//
	// 30e5d7**********bd900764de7c0102
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s GetJobDetailResponseBodySnapshotJobDetail) String() string {
	return tea.Prettify(s)
}

func (s GetJobDetailResponseBodySnapshotJobDetail) GoString() string {
	return s.String()
}

func (s *GetJobDetailResponseBodySnapshotJobDetail) SetCompleteTime(v string) *GetJobDetailResponseBodySnapshotJobDetail {
	s.CompleteTime = &v
	return s
}

func (s *GetJobDetailResponseBodySnapshotJobDetail) SetCreateTime(v string) *GetJobDetailResponseBodySnapshotJobDetail {
	s.CreateTime = &v
	return s
}

func (s *GetJobDetailResponseBodySnapshotJobDetail) SetJobId(v string) *GetJobDetailResponseBodySnapshotJobDetail {
	s.JobId = &v
	return s
}

func (s *GetJobDetailResponseBodySnapshotJobDetail) SetNormalConfig(v string) *GetJobDetailResponseBodySnapshotJobDetail {
	s.NormalConfig = &v
	return s
}

func (s *GetJobDetailResponseBodySnapshotJobDetail) SetSpriteConfig(v string) *GetJobDetailResponseBodySnapshotJobDetail {
	s.SpriteConfig = &v
	return s
}

func (s *GetJobDetailResponseBodySnapshotJobDetail) SetStatus(v string) *GetJobDetailResponseBodySnapshotJobDetail {
	s.Status = &v
	return s
}

func (s *GetJobDetailResponseBodySnapshotJobDetail) SetTrigger(v string) *GetJobDetailResponseBodySnapshotJobDetail {
	s.Trigger = &v
	return s
}

func (s *GetJobDetailResponseBodySnapshotJobDetail) SetUserId(v int64) *GetJobDetailResponseBodySnapshotJobDetail {
	s.UserId = &v
	return s
}

func (s *GetJobDetailResponseBodySnapshotJobDetail) SetVideoId(v string) *GetJobDetailResponseBodySnapshotJobDetail {
	s.VideoId = &v
	return s
}

type GetJobDetailResponseBodyTranscodeJobDetail struct {
	// The time when the task was complete.
	//
	// example:
	//
	// 2024-10-14T07:39:34Z
	CompleteTime *string `json:"CompleteTime,omitempty" xml:"CompleteTime,omitempty"`
	// The time when the task was created. The time follows the ISO 8601 standard in the YYYY-MM-DDTHH:mm:ssZ format. The time is displayed in UTC.
	//
	// example:
	//
	// 2024-10-14T07:39:25Z
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The definition.
	//
	// example:
	//
	// HD
	Definition *string `json:"Definition,omitempty" xml:"Definition,omitempty"`
	// The ID of the task.
	//
	// example:
	//
	// 2dc1634e**********3f1d22d1a0174e
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The status of the task. Valid values:
	//
	// 	- Submitted
	//
	// 	- Transcoding
	//
	// 	- TranscodeSuccess
	//
	// 	- TranscodeFail
	//
	// 	- TranscodeCancelled
	//
	// example:
	//
	// TranscodeSuccess
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the template.
	//
	// example:
	//
	// dbfaaec9e**********bf0b81219244c
	TemplateId *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The ID of the user who submitted the task.
	//
	// example:
	//
	// 139109*****84930
	UserId *int64 `json:"UserId,omitempty" xml:"UserId,omitempty"`
	// The ID of the media asset.
	//
	// example:
	//
	// 30e5d7**********bd900764de7c0102
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s GetJobDetailResponseBodyTranscodeJobDetail) String() string {
	return tea.Prettify(s)
}

func (s GetJobDetailResponseBodyTranscodeJobDetail) GoString() string {
	return s.String()
}

func (s *GetJobDetailResponseBodyTranscodeJobDetail) SetCompleteTime(v string) *GetJobDetailResponseBodyTranscodeJobDetail {
	s.CompleteTime = &v
	return s
}

func (s *GetJobDetailResponseBodyTranscodeJobDetail) SetCreateTime(v string) *GetJobDetailResponseBodyTranscodeJobDetail {
	s.CreateTime = &v
	return s
}

func (s *GetJobDetailResponseBodyTranscodeJobDetail) SetDefinition(v string) *GetJobDetailResponseBodyTranscodeJobDetail {
	s.Definition = &v
	return s
}

func (s *GetJobDetailResponseBodyTranscodeJobDetail) SetJobId(v string) *GetJobDetailResponseBodyTranscodeJobDetail {
	s.JobId = &v
	return s
}

func (s *GetJobDetailResponseBodyTranscodeJobDetail) SetStatus(v string) *GetJobDetailResponseBodyTranscodeJobDetail {
	s.Status = &v
	return s
}

func (s *GetJobDetailResponseBodyTranscodeJobDetail) SetTemplateId(v string) *GetJobDetailResponseBodyTranscodeJobDetail {
	s.TemplateId = &v
	return s
}

func (s *GetJobDetailResponseBodyTranscodeJobDetail) SetUserId(v int64) *GetJobDetailResponseBodyTranscodeJobDetail {
	s.UserId = &v
	return s
}

func (s *GetJobDetailResponseBodyTranscodeJobDetail) SetVideoId(v string) *GetJobDetailResponseBodyTranscodeJobDetail {
	s.VideoId = &v
	return s
}

type GetJobDetailResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetJobDetailResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetJobDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetJobDetailResponse) GoString() string {
	return s.String()
}

func (s *GetJobDetailResponse) SetHeaders(v map[string]*string) *GetJobDetailResponse {
	s.Headers = v
	return s
}

func (s *GetJobDetailResponse) SetStatusCode(v int32) *GetJobDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetJobDetailResponse) SetBody(v *GetJobDetailResponseBody) *GetJobDetailResponse {
	s.Body = v
	return s
}

type GetMediaAuditAudioResultDetailRequest struct {
	// The ID of the video. You can query the video ID by using the ApsaraVideo VOD console or calling the [SearchMedia](https://help.aliyun.com/document_detail/86044.html) operation.
	//
	// This parameter is required.
	//
	// example:
	//
	// 93ab850b4f6f*****54b6e91d24d81d4
	MediaId      *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. This parameter is optional. If you do not specify this parameter, all results are returned without pagination.
	//
	// example:
	//
	// 1
	PageNo               *int32  `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GetMediaAuditAudioResultDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditAudioResultDetailRequest) GoString() string {
	return s.String()
}

func (s *GetMediaAuditAudioResultDetailRequest) SetMediaId(v string) *GetMediaAuditAudioResultDetailRequest {
	s.MediaId = &v
	return s
}

func (s *GetMediaAuditAudioResultDetailRequest) SetOwnerAccount(v string) *GetMediaAuditAudioResultDetailRequest {
	s.OwnerAccount = &v
	return s
}

func (s *GetMediaAuditAudioResultDetailRequest) SetOwnerId(v string) *GetMediaAuditAudioResultDetailRequest {
	s.OwnerId = &v
	return s
}

func (s *GetMediaAuditAudioResultDetailRequest) SetPageNo(v int32) *GetMediaAuditAudioResultDetailRequest {
	s.PageNo = &v
	return s
}

func (s *GetMediaAuditAudioResultDetailRequest) SetResourceOwnerAccount(v string) *GetMediaAuditAudioResultDetailRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GetMediaAuditAudioResultDetailRequest) SetResourceOwnerId(v string) *GetMediaAuditAudioResultDetailRequest {
	s.ResourceOwnerId = &v
	return s
}

type GetMediaAuditAudioResultDetailResponseBody struct {
	// Details of review results.
	MediaAuditAudioResultDetail *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetail `json:"MediaAuditAudioResultDetail,omitempty" xml:"MediaAuditAudioResultDetail,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// CB7D7232-1AB2-40FE-B8D3-****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetMediaAuditAudioResultDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditAudioResultDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetMediaAuditAudioResultDetailResponseBody) SetMediaAuditAudioResultDetail(v *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetail) *GetMediaAuditAudioResultDetailResponseBody {
	s.MediaAuditAudioResultDetail = v
	return s
}

func (s *GetMediaAuditAudioResultDetailResponseBody) SetRequestId(v string) *GetMediaAuditAudioResultDetailResponseBody {
	s.RequestId = &v
	return s
}

type GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetail struct {
	// The list of results.
	List []*GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList `json:"List,omitempty" xml:"List,omitempty" type:"Repeated"`
	// The page number of the returned page.
	//
	// example:
	//
	// 1
	PageTotal *int32 `json:"PageTotal,omitempty" xml:"PageTotal,omitempty"`
	// The total number of pages returned.
	//
	// example:
	//
	// 10
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetail) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetail) GoString() string {
	return s.String()
}

func (s *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetail) SetList(v []*GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList) *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetail {
	s.List = v
	return s
}

func (s *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetail) SetPageTotal(v int32) *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetail {
	s.PageTotal = &v
	return s
}

func (s *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetail) SetTotal(v int32) *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetail {
	s.Total = &v
	return s
}

type GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList struct {
	// The end time of the audio that failed the review. Unit: seconds.
	//
	// example:
	//
	// 10
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The review results. Valid values:
	//
	// 	- **spam**
	//
	// 	- **ad**
	//
	// 	- **abuse**
	//
	// 	- **flood**
	//
	// 	- **contraband**
	//
	// 	- **meaningless**
	//
	// 	- **normal**
	//
	// example:
	//
	// abuse
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The start time of the audio that failed the review. Unit: seconds.
	//
	// example:
	//
	// 8
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The text that corresponds to the audio.
	//
	// example:
	//
	// beauty
	Text *string `json:"Text,omitempty" xml:"Text,omitempty"`
}

func (s GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList) GoString() string {
	return s.String()
}

func (s *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList) SetEndTime(v int64) *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList {
	s.EndTime = &v
	return s
}

func (s *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList) SetLabel(v string) *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList {
	s.Label = &v
	return s
}

func (s *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList) SetStartTime(v int64) *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList {
	s.StartTime = &v
	return s
}

func (s *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList) SetText(v string) *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList {
	s.Text = &v
	return s
}

type GetMediaAuditAudioResultDetailResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetMediaAuditAudioResultDetailResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetMediaAuditAudioResultDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditAudioResultDetailResponse) GoString() string {
	return s.String()
}

func (s *GetMediaAuditAudioResultDetailResponse) SetHeaders(v map[string]*string) *GetMediaAuditAudioResultDetailResponse {
	s.Headers = v
	return s
}

func (s *GetMediaAuditAudioResultDetailResponse) SetStatusCode(v int32) *GetMediaAuditAudioResultDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMediaAuditAudioResultDetailResponse) SetBody(v *GetMediaAuditAudioResultDetailResponseBody) *GetMediaAuditAudioResultDetailResponse {
	s.Body = v
	return s
}

type GetMediaAuditResultRequest struct {
	// The ID of the video or image.
	//
	// This parameter is required.
	//
	// example:
	//
	// 93ab850b4f6f*****54b6e91d24d81d4
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
}

func (s GetMediaAuditResultRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultRequest) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultRequest) SetMediaId(v string) *GetMediaAuditResultRequest {
	s.MediaId = &v
	return s
}

type GetMediaAuditResultResponseBody struct {
	// The review results.
	MediaAuditResult *GetMediaAuditResultResponseBodyMediaAuditResult `json:"MediaAuditResult,omitempty" xml:"MediaAuditResult,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// CB7D7232-1AB2-40FE-B8D5-****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetMediaAuditResultResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBody) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBody) SetMediaAuditResult(v *GetMediaAuditResultResponseBodyMediaAuditResult) *GetMediaAuditResultResponseBody {
	s.MediaAuditResult = v
	return s
}

func (s *GetMediaAuditResultResponseBody) SetRequestId(v string) *GetMediaAuditResultResponseBody {
	s.RequestId = &v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResult struct {
	// The content that violates the regulations. Separate multiple values with commas (,). Valid values:
	//
	// 	- **video**
	//
	// 	- **image-cover**
	//
	// 	- **text-title**
	//
	// example:
	//
	// video
	AbnormalModules *string `json:"AbnormalModules,omitempty" xml:"AbnormalModules,omitempty"`
	// The results of audio review.
	AudioResult []*GetMediaAuditResultResponseBodyMediaAuditResultAudioResult `json:"AudioResult,omitempty" xml:"AudioResult,omitempty" type:"Repeated"`
	// The results of image review.
	ImageResult []*GetMediaAuditResultResponseBodyMediaAuditResultImageResult `json:"ImageResult,omitempty" xml:"ImageResult,omitempty" type:"Repeated"`
	// The category of the review result. Separate multiple values with commas (,). Valid values:
	//
	// 	- **porn**
	//
	// 	- **terrorism**
	//
	// 	- **normal**
	//
	// example:
	//
	// porn
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The recommendation for review results. Valid values:
	//
	// 	- **block**
	//
	// 	- **review**
	//
	// 	- **pass**
	//
	// example:
	//
	// pass
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The results of text review.
	TextResult []*GetMediaAuditResultResponseBodyMediaAuditResultTextResult `json:"TextResult,omitempty" xml:"TextResult,omitempty" type:"Repeated"`
	// The results of video review.
	VideoResult *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult `json:"VideoResult,omitempty" xml:"VideoResult,omitempty" type:"Struct"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResult) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResult) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResult) SetAbnormalModules(v string) *GetMediaAuditResultResponseBodyMediaAuditResult {
	s.AbnormalModules = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResult) SetAudioResult(v []*GetMediaAuditResultResponseBodyMediaAuditResultAudioResult) *GetMediaAuditResultResponseBodyMediaAuditResult {
	s.AudioResult = v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResult) SetImageResult(v []*GetMediaAuditResultResponseBodyMediaAuditResultImageResult) *GetMediaAuditResultResponseBodyMediaAuditResult {
	s.ImageResult = v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResult) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResult {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResult) SetSuggestion(v string) *GetMediaAuditResultResponseBodyMediaAuditResult {
	s.Suggestion = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResult) SetTextResult(v []*GetMediaAuditResultResponseBodyMediaAuditResultTextResult) *GetMediaAuditResultResponseBodyMediaAuditResult {
	s.TextResult = v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResult) SetVideoResult(v *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult) *GetMediaAuditResultResponseBodyMediaAuditResult {
	s.VideoResult = v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultAudioResult struct {
	// The category of the review result.
	//
	// 	- **normal**
	//
	// 	- **spam**
	//
	// 	- **ad**
	//
	// 	- **politics**
	//
	// 	- **terrorism**
	//
	// 	- **abuse**
	//
	// 	- **porn**
	//
	// 	- **flood**
	//
	// 	- **contraband**
	//
	// 	- **meaningless**
	//
	// example:
	//
	// normal
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The review scenario. The value is **antispam**.
	//
	// example:
	//
	// antispam
	Scene *string `json:"Scene,omitempty" xml:"Scene,omitempty"`
	// The score.
	//
	// example:
	//
	// 99.91
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The recommendation for review results. Valid values:
	//
	// 	- **block**
	//
	// 	- **review**
	//
	// 	- **pass**
	//
	// example:
	//
	// pass
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultAudioResult) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultAudioResult) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultAudioResult) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultAudioResult {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultAudioResult) SetScene(v string) *GetMediaAuditResultResponseBodyMediaAuditResultAudioResult {
	s.Scene = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultAudioResult) SetScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultAudioResult {
	s.Score = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultAudioResult) SetSuggestion(v string) *GetMediaAuditResultResponseBodyMediaAuditResultAudioResult {
	s.Suggestion = &v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultImageResult struct {
	// The category of the review result. Separate multiple values with commas (,). Valid values:
	//
	// 	- **porn**
	//
	// 	- **terrorism**
	//
	// 	- **normal**
	//
	// example:
	//
	// porn
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// Details of image review results.
	Result []*GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// The recommendation for review results. Valid values:
	//
	// 	- **block**
	//
	// 	- **review**
	//
	// 	- **pass**
	//
	// example:
	//
	// pass
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The type of the image. The value is **cover**.
	//
	// example:
	//
	// cover
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The URL of the image.
	//
	// example:
	//
	// http://www.test.com/****.jpg
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultImageResult) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultImageResult) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultImageResult) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultImageResult {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultImageResult) SetResult(v []*GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult) *GetMediaAuditResultResponseBodyMediaAuditResultImageResult {
	s.Result = v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultImageResult) SetSuggestion(v string) *GetMediaAuditResultResponseBodyMediaAuditResultImageResult {
	s.Suggestion = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultImageResult) SetType(v string) *GetMediaAuditResultResponseBodyMediaAuditResultImageResult {
	s.Type = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultImageResult) SetUrl(v string) *GetMediaAuditResultResponseBodyMediaAuditResultImageResult {
	s.Url = &v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult struct {
	// The category of the review result.
	//
	// Valid values if scene is **porn**:
	//
	// 	- **porn**
	//
	// 	- **sexy**
	//
	// 	- **normal**
	//
	// Valid values if scene is **terrorism**:
	//
	// 	- **normal**
	//
	// 	- **bloody**
	//
	// 	- **explosion**
	//
	// 	- **outfit**
	//
	// 	- **logo**
	//
	// 	- **weapon**
	//
	// 	- **politics**
	//
	// 	- **violence**
	//
	// 	- **crowd**
	//
	// 	- **parade**
	//
	// 	- **carcrash**
	//
	// 	- **flag**
	//
	// 	- **location**
	//
	// 	- **others**
	//
	// example:
	//
	// porn
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The review scenario. Valid values:
	//
	// 	- **terrorism**
	//
	// 	- **porn**
	//
	// example:
	//
	// porn
	Scene *string `json:"Scene,omitempty" xml:"Scene,omitempty"`
	// The score of the image of the category that is indicated by Label.
	//
	// example:
	//
	// 100.00000
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The recommendation for review results. Valid values:
	//
	// 	- **block**
	//
	// 	- **review**
	//
	// 	- **pass**
	//
	// example:
	//
	// pass
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult) SetScene(v string) *GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult {
	s.Scene = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult) SetScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult {
	s.Score = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult) SetSuggestion(v string) *GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult {
	s.Suggestion = &v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultTextResult struct {
	// The text content for review.
	//
	// example:
	//
	// hot line 123****
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The category of the review result. Valid values:
	//
	// - **spam**
	//
	// - **ad**
	//
	// - **abuse**
	//
	// - **flood**
	//
	// - **contraband**
	//
	// - **meaningless**
	//
	// - **normal**
	//
	// example:
	//
	// ad
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The review scenario. The value is **antispam**.
	//
	// example:
	//
	// antispam
	Scene *string `json:"Scene,omitempty" xml:"Scene,omitempty"`
	// The score of the image of the category that is indicated by Label.
	//
	// example:
	//
	// 100.00000
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The recommendation for review results. Valid values:
	//
	// - **block**
	//
	// - **review**
	//
	// - **pass**
	//
	// example:
	//
	// pass
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The type of the text. The value is **title**.
	//
	// example:
	//
	// title
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultTextResult) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultTextResult) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultTextResult) SetContent(v string) *GetMediaAuditResultResponseBodyMediaAuditResultTextResult {
	s.Content = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultTextResult) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultTextResult {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultTextResult) SetScene(v string) *GetMediaAuditResultResponseBodyMediaAuditResultTextResult {
	s.Scene = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultTextResult) SetScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultTextResult {
	s.Score = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultTextResult) SetSuggestion(v string) *GetMediaAuditResultResponseBodyMediaAuditResultTextResult {
	s.Suggestion = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultTextResult) SetType(v string) *GetMediaAuditResultResponseBodyMediaAuditResultTextResult {
	s.Type = &v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResult struct {
	// The results of ad review.
	AdResult *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult `json:"AdResult,omitempty" xml:"AdResult,omitempty" type:"Struct"`
	// The category of the review result. Separate multiple values with commas (,). Valid values:
	//
	// - **porn**
	//
	// - **terrorism**
	//
	// - **normal**
	//
	// example:
	//
	// porn
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The results of undesired content review.
	LiveResult *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult `json:"LiveResult,omitempty" xml:"LiveResult,omitempty" type:"Struct"`
	// The results of logo review.
	LogoResult *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult `json:"LogoResult,omitempty" xml:"LogoResult,omitempty" type:"Struct"`
	// The results of pornographic content review.
	PornResult *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult `json:"PornResult,omitempty" xml:"PornResult,omitempty" type:"Struct"`
	// The recommendation for review results. Valid values:
	//
	// - **block**
	//
	// - **review**
	//
	// - **pass**
	//
	// example:
	//
	// pass
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The results of terrorist content review.
	TerrorismResult *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult `json:"TerrorismResult,omitempty" xml:"TerrorismResult,omitempty" type:"Struct"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResult) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResult) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult) SetAdResult(v *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult {
	s.AdResult = v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult) SetLiveResult(v *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult {
	s.LiveResult = v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult) SetLogoResult(v *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult {
	s.LogoResult = v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult) SetPornResult(v *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult {
	s.PornResult = v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult) SetSuggestion(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult {
	s.Suggestion = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult) SetTerrorismResult(v *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult {
	s.TerrorismResult = v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult struct {
	// The average score of the review results.
	//
	// example:
	//
	// 100
	AverageScore *string `json:"AverageScore,omitempty" xml:"AverageScore,omitempty"`
	// The statistics about tag frames.
	CounterList []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultCounterList `json:"CounterList,omitempty" xml:"CounterList,omitempty" type:"Repeated"`
	// The category of the review result. Valid values:
	//
	// - **ad**
	//
	// - **normal**
	//
	// example:
	//
	// ad
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The highest review score.
	//
	// example:
	//
	// 100
	MaxScore *string `json:"MaxScore,omitempty" xml:"MaxScore,omitempty"`
	// The recommendation for review results. Valid values:
	//
	// - **block**
	//
	// - **review**
	//
	// - **pass**
	//
	// example:
	//
	// block
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The information about the image with the highest score of the category that is indicated by Label.
	TopList []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList `json:"TopList,omitempty" xml:"TopList,omitempty" type:"Repeated"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult) SetAverageScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult {
	s.AverageScore = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult) SetCounterList(v []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultCounterList) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult {
	s.CounterList = v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult) SetMaxScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult {
	s.MaxScore = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult) SetSuggestion(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult {
	s.Suggestion = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult) SetTopList(v []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult {
	s.TopList = v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultCounterList struct {
	// The number of frames.
	//
	// example:
	//
	// 12
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The category of the review result. Valid values:
	//
	// - **ad**
	//
	// - **normal**
	//
	// example:
	//
	// ad
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultCounterList) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultCounterList) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultCounterList) SetCount(v int32) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultCounterList {
	s.Count = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultCounterList) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultCounterList {
	s.Label = &v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList struct {
	// The category of the review result.
	//
	// - **ad**
	//
	// - **normal**
	//
	// example:
	//
	// ad
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The score of the image of the category that is indicated by Label.
	//
	// example:
	//
	// 100
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The position in the video. Unit: milliseconds.
	//
	// example:
	//
	// 10
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	// The URL of the image.
	//
	// example:
	//
	// http://temp-testbucket.oss-cn-shanghai.aliyuncs.com/aivideocensor/****.jpg
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList) SetScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList {
	s.Score = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList) SetTimestamp(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList {
	s.Timestamp = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList) SetUrl(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList {
	s.Url = &v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult struct {
	// The average score of the review results.
	//
	// example:
	//
	// 100
	AverageScore *string `json:"AverageScore,omitempty" xml:"AverageScore,omitempty"`
	// The statistics about tag frames.
	CounterList []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultCounterList `json:"CounterList,omitempty" xml:"CounterList,omitempty" type:"Repeated"`
	// The category of the review result. Valid values:
	//
	// - **live**: The content contains undesirable scenes.
	//
	// - **normal**: normal content.
	//
	// example:
	//
	// live
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The highest review score.
	//
	// example:
	//
	// 100
	MaxScore *string `json:"MaxScore,omitempty" xml:"MaxScore,omitempty"`
	// The recommendation for review results. Valid values:
	//
	// - **block**
	//
	// - **review**
	//
	// - **pass**
	//
	// example:
	//
	// block
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The information about the image with the highest score of the category that is indicated by Label.
	TopList []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList `json:"TopList,omitempty" xml:"TopList,omitempty" type:"Repeated"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult) SetAverageScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult {
	s.AverageScore = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult) SetCounterList(v []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultCounterList) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult {
	s.CounterList = v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult) SetMaxScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult {
	s.MaxScore = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult) SetSuggestion(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult {
	s.Suggestion = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult) SetTopList(v []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult {
	s.TopList = v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultCounterList struct {
	// The number of frames.
	//
	// example:
	//
	// 2
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The category of the review result. Valid values:
	//
	// - **live**: The content contains undesirable scenes.
	//
	// - **normal**: normal content.
	//
	// example:
	//
	// live
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultCounterList) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultCounterList) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultCounterList) SetCount(v int32) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultCounterList {
	s.Count = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultCounterList) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultCounterList {
	s.Label = &v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList struct {
	// The category of the review result. Valid values:
	//
	// - **live**: The content contains undesirable scenes.
	//
	// - **normal**: normal content.
	//
	// example:
	//
	// normal
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The score of the image of the category that is indicated by Label.
	//
	// example:
	//
	// 100
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The position in the video. Unit: milliseconds.
	//
	// example:
	//
	// 10
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	// The URL of the image.
	//
	// example:
	//
	// http://temp-testbucket.oss-cn-shanghai.aliyuncs.com/aivideocensor/****.jpg
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList) SetScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList {
	s.Score = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList) SetTimestamp(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList {
	s.Timestamp = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList) SetUrl(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList {
	s.Url = &v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult struct {
	// The average score of the review results.
	//
	// example:
	//
	// 100
	AverageScore *string `json:"AverageScore,omitempty" xml:"AverageScore,omitempty"`
	// The statistics about tag frames.
	CounterList []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultCounterList `json:"CounterList,omitempty" xml:"CounterList,omitempty" type:"Repeated"`
	// The category of the review result. Valid values:
	//
	// - **logo**
	//
	// - **normal**
	//
	// example:
	//
	// logo
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The highest review score.
	//
	// example:
	//
	// 100
	MaxScore *string `json:"MaxScore,omitempty" xml:"MaxScore,omitempty"`
	// The recommendation for review results. Valid values:
	//
	// - **block**
	//
	// - **review**
	//
	// - **pass**
	//
	// example:
	//
	// block
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The information about the image with the highest score of the category that is indicated by Label.
	TopList []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList `json:"TopList,omitempty" xml:"TopList,omitempty" type:"Repeated"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult) SetAverageScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult {
	s.AverageScore = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult) SetCounterList(v []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultCounterList) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult {
	s.CounterList = v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult) SetMaxScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult {
	s.MaxScore = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult) SetSuggestion(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult {
	s.Suggestion = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult) SetTopList(v []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult {
	s.TopList = v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultCounterList struct {
	// The number of frames.
	//
	// example:
	//
	// 1
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The category of the review result. Valid values:
	//
	// - **logo**
	//
	// - **normal**
	//
	// example:
	//
	// logo
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultCounterList) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultCounterList) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultCounterList) SetCount(v int32) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultCounterList {
	s.Count = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultCounterList) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultCounterList {
	s.Label = &v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList struct {
	// The category of the review result.
	//
	// - **logo**
	//
	// - **normal**
	//
	// example:
	//
	// logo
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The score of the image of the category that is indicated by Label.
	//
	// example:
	//
	// 100
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The position in the video. Unit: milliseconds.
	//
	// example:
	//
	// 16
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	// The URL of the image.
	//
	// example:
	//
	// http://temp-testbucket.oss-cn-shanghai.aliyuncs.com/aivideocensor/****.jpg
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList) SetScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList {
	s.Score = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList) SetTimestamp(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList {
	s.Timestamp = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList) SetUrl(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList {
	s.Url = &v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult struct {
	// The average score of the review results.
	//
	// example:
	//
	// 100
	AverageScore *string `json:"AverageScore,omitempty" xml:"AverageScore,omitempty"`
	// The statistics about tag frames.
	CounterList []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultCounterList `json:"CounterList,omitempty" xml:"CounterList,omitempty" type:"Repeated"`
	// The category of the review result. Valid values:
	//
	// - **porn**
	//
	// - **sexy**
	//
	// - **normal**
	//
	// example:
	//
	// porn
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The highest review score.
	//
	// example:
	//
	// 100
	MaxScore *string `json:"MaxScore,omitempty" xml:"MaxScore,omitempty"`
	// The recommendation for review results.
	//
	// example:
	//
	// pass
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The information about the image with the highest score of the category that is indicated by Label.
	TopList []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList `json:"TopList,omitempty" xml:"TopList,omitempty" type:"Repeated"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult) SetAverageScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult {
	s.AverageScore = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult) SetCounterList(v []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultCounterList) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult {
	s.CounterList = v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult) SetMaxScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult {
	s.MaxScore = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult) SetSuggestion(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult {
	s.Suggestion = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult) SetTopList(v []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult {
	s.TopList = v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultCounterList struct {
	// The number of frames.
	//
	// example:
	//
	// 1
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The category of the review result. Valid values:
	//
	// - **porn**
	//
	// - **sexy**
	//
	// - **normal**
	//
	// example:
	//
	// porn
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultCounterList) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultCounterList) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultCounterList) SetCount(v int32) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultCounterList {
	s.Count = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultCounterList) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultCounterList {
	s.Label = &v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList struct {
	// The category of the review result. Valid values:
	//
	// - **porn**
	//
	// - **sexy**
	//
	// - **normal**
	//
	// example:
	//
	// porn
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The score of the image of the category that is indicated by Label.
	//
	// example:
	//
	// 100.0000
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The position in the video. Unit: milliseconds.
	//
	// example:
	//
	// 3005
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	// The URL of the image.
	//
	// example:
	//
	// http://temp-testbucket.oss-cn-shanghai.aliyuncs.com/aivideocensor/****.jpg
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList) SetScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList {
	s.Score = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList) SetTimestamp(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList {
	s.Timestamp = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList) SetUrl(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList {
	s.Url = &v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult struct {
	// The average score of the review results.
	//
	// example:
	//
	// 100
	AverageScore *string `json:"AverageScore,omitempty" xml:"AverageScore,omitempty"`
	// The statistics about tag frames.
	CounterList []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultCounterList `json:"CounterList,omitempty" xml:"CounterList,omitempty" type:"Repeated"`
	// The category of the review result. Valid values:
	//
	// - **normal**
	//
	// - **bloody**
	//
	// - **explosion**
	//
	// - **outfit**
	//
	// - **logo**
	//
	// - **weapon**
	//
	// - **politics**
	//
	// - **violence**
	//
	// - **crowd**
	//
	// - **parade**
	//
	// - **carcrash**
	//
	// - **flag**
	//
	// - **location**
	//
	// - **others**
	//
	// example:
	//
	// normal
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The highest review score.
	//
	// example:
	//
	// 100
	MaxScore *string `json:"MaxScore,omitempty" xml:"MaxScore,omitempty"`
	// The recommendation for review results. Valid values:
	//
	// - **block**
	//
	// - **review**
	//
	// - **pass**
	//
	// example:
	//
	// pass
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The information about the image with the highest score of the category that is indicated by Label.
	TopList []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList `json:"TopList,omitempty" xml:"TopList,omitempty" type:"Repeated"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult) SetAverageScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult {
	s.AverageScore = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult) SetCounterList(v []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultCounterList) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult {
	s.CounterList = v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult) SetMaxScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult {
	s.MaxScore = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult) SetSuggestion(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult {
	s.Suggestion = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult) SetTopList(v []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult {
	s.TopList = v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultCounterList struct {
	// The number of frames.
	//
	// example:
	//
	// 1
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The category of the review result. Valid values:
	//
	// - **normal**
	//
	// - **bloody**
	//
	// - **explosion**
	//
	// - **outfit**
	//
	// - **logo**
	//
	// - **weapon**
	//
	// - **politics**
	//
	// - **violence**
	//
	// - **crowd**
	//
	// - **parade**
	//
	// - **carcrash**
	//
	// - **flag**
	//
	// - **location**
	//
	// - **others**
	//
	// example:
	//
	// outfit
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultCounterList) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultCounterList) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultCounterList) SetCount(v int32) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultCounterList {
	s.Count = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultCounterList) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultCounterList {
	s.Label = &v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList struct {
	// The category of the review result. Valid values:
	//
	// - **normal**
	//
	// - **bloody**
	//
	// - **explosion**
	//
	// - **outfit**
	//
	// - **logo**
	//
	// - **weapon**
	//
	// - **politics**
	//
	// - **violence**
	//
	// - **crowd**
	//
	// - **parade**
	//
	// - **carcrash**
	//
	// - **flag**
	//
	// - **location**
	//
	// - **others**
	//
	// example:
	//
	// normal
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The score of the image of the category that is indicated by Label.
	//
	// example:
	//
	// 100.000
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The position in the video. Unit: milliseconds.
	//
	// example:
	//
	// 3005
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	// The URL of the image.
	//
	// example:
	//
	// http://temp-testbucket.oss-cn-shanghai.aliyuncs.com/aivideocensor/****.jpg
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList) SetScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList {
	s.Score = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList) SetTimestamp(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList {
	s.Timestamp = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList) SetUrl(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList {
	s.Url = &v
	return s
}

type GetMediaAuditResultResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetMediaAuditResultResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetMediaAuditResultResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponse) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponse) SetHeaders(v map[string]*string) *GetMediaAuditResultResponse {
	s.Headers = v
	return s
}

func (s *GetMediaAuditResultResponse) SetStatusCode(v int32) *GetMediaAuditResultResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMediaAuditResultResponse) SetBody(v *GetMediaAuditResultResponseBody) *GetMediaAuditResultResponse {
	s.Body = v
	return s
}

type GetMediaAuditResultDetailRequest struct {
	// The ID of the video.
	//
	// This parameter is required.
	//
	// example:
	//
	// 93ab850b4f6f*****54b6e91d24d81d4
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The page number. The default value is **1**. A maximum of **20*	- records can be returned on each page.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1
	PageNo *int32 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
}

func (s GetMediaAuditResultDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultDetailRequest) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultDetailRequest) SetMediaId(v string) *GetMediaAuditResultDetailRequest {
	s.MediaId = &v
	return s
}

func (s *GetMediaAuditResultDetailRequest) SetPageNo(v int32) *GetMediaAuditResultDetailRequest {
	s.PageNo = &v
	return s
}

type GetMediaAuditResultDetailResponseBody struct {
	// Details about review results.
	MediaAuditResultDetail *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetail `json:"MediaAuditResultDetail,omitempty" xml:"MediaAuditResultDetail,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// 6438BD76-D523-46FC-956F-****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetMediaAuditResultDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultDetailResponseBody) SetMediaAuditResultDetail(v *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetail) *GetMediaAuditResultDetailResponseBody {
	s.MediaAuditResultDetail = v
	return s
}

func (s *GetMediaAuditResultDetailResponseBody) SetRequestId(v string) *GetMediaAuditResultDetailResponseBody {
	s.RequestId = &v
	return s
}

type GetMediaAuditResultDetailResponseBodyMediaAuditResultDetail struct {
	// The review results returned.
	List []*GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList `json:"List,omitempty" xml:"List,omitempty" type:"Repeated"`
	// The total number of snapshots returned.
	//
	// example:
	//
	// 2
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s GetMediaAuditResultDetailResponseBodyMediaAuditResultDetail) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultDetailResponseBodyMediaAuditResultDetail) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetail) SetList(v []*GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList) *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetail {
	s.List = v
	return s
}

func (s *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetail) SetTotal(v int32) *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetail {
	s.Total = &v
	return s
}

type GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList struct {
	// The category of the review result. Valid values:
	//
	// 	- **normal**: normal content.
	//
	// 	- **ad**: other ads.
	//
	// 	- **politics**: political content in text.
	//
	// 	- **porn**: pornographic content in text.
	//
	// 	- **abuse**: verbal abuse in text.
	//
	// 	- **terrorism**: terrorist content in text.
	//
	// 	- **contraband**: prohibited content in text.
	//
	// 	- **spam**: spam content in text.
	//
	// 	- **npx**: illegal ad
	//
	// 	- **qrcode**: QR code.
	//
	// 	- **programCode**: mini program code.
	//
	// example:
	//
	// normal
	AdLabel *string `json:"AdLabel,omitempty" xml:"AdLabel,omitempty"`
	// The score of the video snapshot in the ad review result. Valid values: `[0,100]`. The value is rounded down to 10 decimal places. The score is representative of the confidence.
	//
	// example:
	//
	// 100
	AdScore *string `json:"AdScore,omitempty" xml:"AdScore,omitempty"`
	// The category of the review result. Valid values:
	//
	// 	- **normal**: normal content.
	//
	// 	- **meaningless**: meaningless content, such as a black or white screen.
	//
	// 	- **PIP**: picture-in-picture.
	//
	// 	- **smoking**: smoking.
	//
	// 	- **drivelive**: live broadcasting in a running vehicle.
	//
	// example:
	//
	// normal
	LiveLabel *string `json:"LiveLabel,omitempty" xml:"LiveLabel,omitempty"`
	// The score of the video snapshot in the undesirable content review result. Valid values: `[0,100]`. The value is rounded down to 10 decimal places. The score is representative of the confidence.
	//
	// example:
	//
	// 100
	LiveScore *string `json:"LiveScore,omitempty" xml:"LiveScore,omitempty"`
	// The category of the review result. Valid values:
	//
	// 	- **normal**: normal content.
	//
	// 	- **TV**: controlled TV station logo.
	//
	// 	- **trademark**: trademark.
	//
	// example:
	//
	// normal
	LogoLabel *string `json:"LogoLabel,omitempty" xml:"LogoLabel,omitempty"`
	// The score of the video snapshot in the logo review result. Valid values: `[0,100]`. The value is rounded down to 10 decimal places. The score is representative of the confidence.
	//
	// example:
	//
	// 100
	LogoScore *string `json:"LogoScore,omitempty" xml:"LogoScore,omitempty"`
	// The category of the review result. Valid values:
	//
	// 	- **normal**
	//
	// 	- **porn**
	//
	// 	- **sexy**
	//
	// example:
	//
	// normal
	PornLabel *string `json:"PornLabel,omitempty" xml:"PornLabel,omitempty"`
	// The score of the video snapshot in the pornographic content review result. Valid values: `[0,100]`. The value is rounded down to 10 decimal places. The score is representative of the confidence.
	//
	// example:
	//
	// 100.00
	PornScore *string `json:"PornScore,omitempty" xml:"PornScore,omitempty"`
	// The category of the review result. Valid values:
	//
	// 	- **normal**
	//
	// 	- **bloody**
	//
	// 	- **explosion**
	//
	// 	- **outfit**
	//
	// 	- **logo**
	//
	// 	- **weapon**
	//
	// 	- **politics**
	//
	// 	- **violence**
	//
	// 	- **crowd**
	//
	// 	- **parade**
	//
	// 	- **carcrash**
	//
	// 	- **flag**
	//
	// 	- **location**
	//
	// 	- **others**
	//
	// example:
	//
	// normal
	TerrorismLabel *string `json:"TerrorismLabel,omitempty" xml:"TerrorismLabel,omitempty"`
	// The score of the video snapshot in the terrorist content review result. Valid values: `[0,100]`. The value is rounded down to 10 decimal places. The score is representative of the confidence.
	//
	// example:
	//
	// 100.00
	TerrorismScore *string `json:"TerrorismScore,omitempty" xml:"TerrorismScore,omitempty"`
	// The timestamp of the snapshot in the video. Unit: milliseconds.
	//
	// example:
	//
	// 3005
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	// The URL of the video snapshot.
	//
	// example:
	//
	// http://temp-testbucket.oss-cn-shanghai.aliyuncs.com/aivideocensor/****.jpg
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList) SetAdLabel(v string) *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList {
	s.AdLabel = &v
	return s
}

func (s *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList) SetAdScore(v string) *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList {
	s.AdScore = &v
	return s
}

func (s *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList) SetLiveLabel(v string) *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList {
	s.LiveLabel = &v
	return s
}

func (s *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList) SetLiveScore(v string) *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList {
	s.LiveScore = &v
	return s
}

func (s *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList) SetLogoLabel(v string) *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList {
	s.LogoLabel = &v
	return s
}

func (s *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList) SetLogoScore(v string) *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList {
	s.LogoScore = &v
	return s
}

func (s *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList) SetPornLabel(v string) *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList {
	s.PornLabel = &v
	return s
}

func (s *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList) SetPornScore(v string) *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList {
	s.PornScore = &v
	return s
}

func (s *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList) SetTerrorismLabel(v string) *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList {
	s.TerrorismLabel = &v
	return s
}

func (s *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList) SetTerrorismScore(v string) *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList {
	s.TerrorismScore = &v
	return s
}

func (s *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList) SetTimestamp(v string) *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList {
	s.Timestamp = &v
	return s
}

func (s *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList) SetUrl(v string) *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList {
	s.Url = &v
	return s
}

type GetMediaAuditResultDetailResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetMediaAuditResultDetailResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetMediaAuditResultDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultDetailResponse) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultDetailResponse) SetHeaders(v map[string]*string) *GetMediaAuditResultDetailResponse {
	s.Headers = v
	return s
}

func (s *GetMediaAuditResultDetailResponse) SetStatusCode(v int32) *GetMediaAuditResultDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMediaAuditResultDetailResponse) SetBody(v *GetMediaAuditResultDetailResponseBody) *GetMediaAuditResultDetailResponse {
	s.Body = v
	return s
}

type GetMediaAuditResultTimelineRequest struct {
	// The ID of the video.
	//
	// This parameter is required.
	//
	// example:
	//
	// 93ab850b4f6f*****54b6e91d24d81d4
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
}

func (s GetMediaAuditResultTimelineRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultTimelineRequest) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultTimelineRequest) SetMediaId(v string) *GetMediaAuditResultTimelineRequest {
	s.MediaId = &v
	return s
}

type GetMediaAuditResultTimelineResponseBody struct {
	// The collection of review result timelines.
	MediaAuditResultTimeline *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline `json:"MediaAuditResultTimeline,omitempty" xml:"MediaAuditResultTimeline,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// 6438BD76-D523-46FC-956F-****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetMediaAuditResultTimelineResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultTimelineResponseBody) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultTimelineResponseBody) SetMediaAuditResultTimeline(v *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline) *GetMediaAuditResultTimelineResponseBody {
	s.MediaAuditResultTimeline = v
	return s
}

func (s *GetMediaAuditResultTimelineResponseBody) SetRequestId(v string) *GetMediaAuditResultTimelineResponseBody {
	s.RequestId = &v
	return s
}

type GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline struct {
	// The collection of ad timelines.
	Ad []*GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineAd `json:"Ad,omitempty" xml:"Ad,omitempty" type:"Repeated"`
	// The collection of undesirable content timelines.
	Live []*GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLive `json:"Live,omitempty" xml:"Live,omitempty" type:"Repeated"`
	// The collection of logo timelines.
	Logo []*GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLogo `json:"Logo,omitempty" xml:"Logo,omitempty" type:"Repeated"`
	// The collection of pornographic content timelines.
	Porn []*GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelinePorn `json:"Porn,omitempty" xml:"Porn,omitempty" type:"Repeated"`
	// The collection of terrorist content timelines.
	Terrorism []*GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineTerrorism `json:"Terrorism,omitempty" xml:"Terrorism,omitempty" type:"Repeated"`
}

func (s GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline) SetAd(v []*GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineAd) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline {
	s.Ad = v
	return s
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline) SetLive(v []*GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLive) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline {
	s.Live = v
	return s
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline) SetLogo(v []*GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLogo) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline {
	s.Logo = v
	return s
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline) SetPorn(v []*GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelinePorn) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline {
	s.Porn = v
	return s
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline) SetTerrorism(v []*GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineTerrorism) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline {
	s.Terrorism = v
	return s
}

type GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineAd struct {
	// The category of the review result. Valid values:
	//
	// 	- **normal**: normal content.
	//
	// 	- **ad**: other ads.
	//
	// 	- **politics**: political content in text.
	//
	// 	- **porn**: pornographic content in text.
	//
	// 	- **abuse**: abuse in text.
	//
	// 	- **terrorism**: terrorist content in text.
	//
	// 	- **contraband**: prohibited content in text.
	//
	// 	- **spam**: spam content.
	//
	// 	- **npx**: illegal ad.
	//
	// 	- **qrcode**: QR code.
	//
	// 	- **programCode**: mini program code.
	//
	// example:
	//
	// ad
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The score of the video snapshot in the ad review result. Valid values: `[0,100]`. The value is rounded down to 10 decimal places. The score is representative of the confidence.
	//
	// example:
	//
	// 100
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The timestamp of the snapshot in the video. Unit: milliseconds.
	//
	// example:
	//
	// 10
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
}

func (s GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineAd) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineAd) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineAd) SetLabel(v string) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineAd {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineAd) SetScore(v string) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineAd {
	s.Score = &v
	return s
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineAd) SetTimestamp(v string) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineAd {
	s.Timestamp = &v
	return s
}

type GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLive struct {
	// The categories of undesired content review results. Valid values:
	//
	// 	- **normal**: normal content.
	//
	// 	- **meaningless**: meaningless content, such as a black or white screen.
	//
	// 	- **PIP**: picture-in-picture.
	//
	// 	- **smoking**: smoking.
	//
	// 	- **drivelive**: live broadcasting in a running vehicle.
	//
	// example:
	//
	// pip
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The score of the video snapshot in the undesirable content review result. Valid values: `[0,100]`. The value is rounded down to 10 decimal places. The score is representative of the confidence.
	//
	// example:
	//
	// 100
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The timestamp of the snapshot in the video. Unit: milliseconds.
	//
	// example:
	//
	// 12
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
}

func (s GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLive) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLive) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLive) SetLabel(v string) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLive {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLive) SetScore(v string) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLive {
	s.Score = &v
	return s
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLive) SetTimestamp(v string) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLive {
	s.Timestamp = &v
	return s
}

type GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLogo struct {
	// The category of the review result. Valid values:
	//
	// 	- **normal**: normal content.
	//
	// 	- **TV**: controlled TV station logo.
	//
	// 	- **trademark**: trademark.
	//
	// example:
	//
	// logo
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The score of the video snapshot in the logo review result. Valid values: `[0,100]`. The value is rounded down to 10 decimal places. The score is representative of the confidence.
	//
	// example:
	//
	// 100
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The timestamp of the snapshot in the video. Unit: milliseconds.
	//
	// example:
	//
	// 13
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
}

func (s GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLogo) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLogo) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLogo) SetLabel(v string) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLogo {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLogo) SetScore(v string) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLogo {
	s.Score = &v
	return s
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLogo) SetTimestamp(v string) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLogo {
	s.Timestamp = &v
	return s
}

type GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelinePorn struct {
	// The category of the review result. Valid values:
	//
	// 	- **porn**
	//
	// 	- **sexy**
	//
	// 	- **normal**
	//
	// example:
	//
	// porn
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The score of the video snapshot in the pornographic content review result. Valid values: `[0,100]`. The value is rounded down to 10 decimal places. The score is representative of the confidence.
	//
	// example:
	//
	// 100.00
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The timestamp of the snapshot in the video. Unit: milliseconds.
	//
	// example:
	//
	// 3005
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
}

func (s GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelinePorn) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelinePorn) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelinePorn) SetLabel(v string) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelinePorn {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelinePorn) SetScore(v string) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelinePorn {
	s.Score = &v
	return s
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelinePorn) SetTimestamp(v string) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelinePorn {
	s.Timestamp = &v
	return s
}

type GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineTerrorism struct {
	// The category of the review result. Valid values:
	//
	// 	- **normal**
	//
	// 	- **bloody**
	//
	// 	- **explosion**
	//
	// 	- **outfit**
	//
	// 	- **logo**
	//
	// 	- **weapon**
	//
	// 	- **politics**
	//
	// 	- **violence**
	//
	// 	- **crowd**
	//
	// 	- **parade**
	//
	// 	- **carcrash**
	//
	// 	- **flag**
	//
	// 	- **location**
	//
	// 	- **others**
	//
	// example:
	//
	// normal
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The score of the video snapshot in the terrorist content review result. Valid values: `[0,100]`. The value is rounded down to 10 decimal places. The score is representative of the confidence.
	//
	// example:
	//
	// 100.00
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The timestamp of the snapshot in the video. Unit: milliseconds.
	//
	// example:
	//
	// 3005
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
}

func (s GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineTerrorism) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineTerrorism) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineTerrorism) SetLabel(v string) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineTerrorism {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineTerrorism) SetScore(v string) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineTerrorism {
	s.Score = &v
	return s
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineTerrorism) SetTimestamp(v string) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineTerrorism {
	s.Timestamp = &v
	return s
}

type GetMediaAuditResultTimelineResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetMediaAuditResultTimelineResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetMediaAuditResultTimelineResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultTimelineResponse) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultTimelineResponse) SetHeaders(v map[string]*string) *GetMediaAuditResultTimelineResponse {
	s.Headers = v
	return s
}

func (s *GetMediaAuditResultTimelineResponse) SetStatusCode(v int32) *GetMediaAuditResultTimelineResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMediaAuditResultTimelineResponse) SetBody(v *GetMediaAuditResultTimelineResponseBody) *GetMediaAuditResultTimelineResponse {
	s.Body = v
	return s
}

type GetMediaDNAResultRequest struct {
	// The ID of the video.
	//
	// This parameter is required.
	//
	// example:
	//
	// 88c6ca184c0e*****a5b665e2a126797
	MediaId              *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GetMediaDNAResultRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMediaDNAResultRequest) GoString() string {
	return s.String()
}

func (s *GetMediaDNAResultRequest) SetMediaId(v string) *GetMediaDNAResultRequest {
	s.MediaId = &v
	return s
}

func (s *GetMediaDNAResultRequest) SetOwnerAccount(v string) *GetMediaDNAResultRequest {
	s.OwnerAccount = &v
	return s
}

func (s *GetMediaDNAResultRequest) SetOwnerId(v string) *GetMediaDNAResultRequest {
	s.OwnerId = &v
	return s
}

func (s *GetMediaDNAResultRequest) SetResourceOwnerAccount(v string) *GetMediaDNAResultRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GetMediaDNAResultRequest) SetResourceOwnerId(v string) *GetMediaDNAResultRequest {
	s.ResourceOwnerId = &v
	return s
}

type GetMediaDNAResultResponseBody struct {
	// The media fingerprinting results.
	DNAResult *GetMediaDNAResultResponseBodyDNAResult `json:"DNAResult,omitempty" xml:"DNAResult,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// 63FC4896-E956-4B*****7D-134FF1BC597A
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetMediaDNAResultResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMediaDNAResultResponseBody) GoString() string {
	return s.String()
}

func (s *GetMediaDNAResultResponseBody) SetDNAResult(v *GetMediaDNAResultResponseBodyDNAResult) *GetMediaDNAResultResponseBody {
	s.DNAResult = v
	return s
}

func (s *GetMediaDNAResultResponseBody) SetRequestId(v string) *GetMediaDNAResultResponseBody {
	s.RequestId = &v
	return s
}

type GetMediaDNAResultResponseBodyDNAResult struct {
	// The video fingerprint recognition result.
	VideoDNA []*GetMediaDNAResultResponseBodyDNAResultVideoDNA `json:"VideoDNA,omitempty" xml:"VideoDNA,omitempty" type:"Repeated"`
}

func (s GetMediaDNAResultResponseBodyDNAResult) String() string {
	return tea.Prettify(s)
}

func (s GetMediaDNAResultResponseBodyDNAResult) GoString() string {
	return s.String()
}

func (s *GetMediaDNAResultResponseBodyDNAResult) SetVideoDNA(v []*GetMediaDNAResultResponseBodyDNAResultVideoDNA) *GetMediaDNAResultResponseBodyDNAResult {
	s.VideoDNA = v
	return s
}

type GetMediaDNAResultResponseBodyDNAResultVideoDNA struct {
	// The details of the matched video. Information such as the location and duration of the video is returned.
	Detail []*GetMediaDNAResultResponseBodyDNAResultVideoDNADetail `json:"Detail,omitempty" xml:"Detail,omitempty" type:"Repeated"`
	// The ID of the video that has a similar fingerprint.
	//
	// example:
	//
	// 6ad8987da46f4b*****490ce2873745
	PrimaryKey *string `json:"PrimaryKey,omitempty" xml:"PrimaryKey,omitempty"`
	// The similarity between the fingerprints of the input video and the matched video. 1 indicates that the fingerprints of the two videos are the same.
	//
	// example:
	//
	// 0.98
	Similarity *string `json:"Similarity,omitempty" xml:"Similarity,omitempty"`
}

func (s GetMediaDNAResultResponseBodyDNAResultVideoDNA) String() string {
	return tea.Prettify(s)
}

func (s GetMediaDNAResultResponseBodyDNAResultVideoDNA) GoString() string {
	return s.String()
}

func (s *GetMediaDNAResultResponseBodyDNAResultVideoDNA) SetDetail(v []*GetMediaDNAResultResponseBodyDNAResultVideoDNADetail) *GetMediaDNAResultResponseBodyDNAResultVideoDNA {
	s.Detail = v
	return s
}

func (s *GetMediaDNAResultResponseBodyDNAResultVideoDNA) SetPrimaryKey(v string) *GetMediaDNAResultResponseBodyDNAResultVideoDNA {
	s.PrimaryKey = &v
	return s
}

func (s *GetMediaDNAResultResponseBodyDNAResultVideoDNA) SetSimilarity(v string) *GetMediaDNAResultResponseBodyDNAResultVideoDNA {
	s.Similarity = &v
	return s
}

type GetMediaDNAResultResponseBodyDNAResultVideoDNADetail struct {
	// The start time and duration of the matched video.
	Duplication *GetMediaDNAResultResponseBodyDNAResultVideoDNADetailDuplication `json:"Duplication,omitempty" xml:"Duplication,omitempty" type:"Struct"`
	// The start time and duration of the input video.
	Input *GetMediaDNAResultResponseBodyDNAResultVideoDNADetailInput `json:"Input,omitempty" xml:"Input,omitempty" type:"Struct"`
}

func (s GetMediaDNAResultResponseBodyDNAResultVideoDNADetail) String() string {
	return tea.Prettify(s)
}

func (s GetMediaDNAResultResponseBodyDNAResultVideoDNADetail) GoString() string {
	return s.String()
}

func (s *GetMediaDNAResultResponseBodyDNAResultVideoDNADetail) SetDuplication(v *GetMediaDNAResultResponseBodyDNAResultVideoDNADetailDuplication) *GetMediaDNAResultResponseBodyDNAResultVideoDNADetail {
	s.Duplication = v
	return s
}

func (s *GetMediaDNAResultResponseBodyDNAResultVideoDNADetail) SetInput(v *GetMediaDNAResultResponseBodyDNAResultVideoDNADetailInput) *GetMediaDNAResultResponseBodyDNAResultVideoDNADetail {
	s.Input = v
	return s
}

type GetMediaDNAResultResponseBodyDNAResultVideoDNADetailDuplication struct {
	// The duration of the video. Unit: seconds.
	//
	// example:
	//
	// 12.0
	Duration *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The start time of the video. Unit: seconds.
	//
	// example:
	//
	// 2.0
	Start *string `json:"Start,omitempty" xml:"Start,omitempty"`
}

func (s GetMediaDNAResultResponseBodyDNAResultVideoDNADetailDuplication) String() string {
	return tea.Prettify(s)
}

func (s GetMediaDNAResultResponseBodyDNAResultVideoDNADetailDuplication) GoString() string {
	return s.String()
}

func (s *GetMediaDNAResultResponseBodyDNAResultVideoDNADetailDuplication) SetDuration(v string) *GetMediaDNAResultResponseBodyDNAResultVideoDNADetailDuplication {
	s.Duration = &v
	return s
}

func (s *GetMediaDNAResultResponseBodyDNAResultVideoDNADetailDuplication) SetStart(v string) *GetMediaDNAResultResponseBodyDNAResultVideoDNADetailDuplication {
	s.Start = &v
	return s
}

type GetMediaDNAResultResponseBodyDNAResultVideoDNADetailInput struct {
	// The duration of the video. Unit: seconds.
	//
	// example:
	//
	// 12.0
	Duration *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The start time of the video. Unit: seconds.
	//
	// example:
	//
	// 2.0
	Start *string `json:"Start,omitempty" xml:"Start,omitempty"`
}

func (s GetMediaDNAResultResponseBodyDNAResultVideoDNADetailInput) String() string {
	return tea.Prettify(s)
}

func (s GetMediaDNAResultResponseBodyDNAResultVideoDNADetailInput) GoString() string {
	return s.String()
}

func (s *GetMediaDNAResultResponseBodyDNAResultVideoDNADetailInput) SetDuration(v string) *GetMediaDNAResultResponseBodyDNAResultVideoDNADetailInput {
	s.Duration = &v
	return s
}

func (s *GetMediaDNAResultResponseBodyDNAResultVideoDNADetailInput) SetStart(v string) *GetMediaDNAResultResponseBodyDNAResultVideoDNADetailInput {
	s.Start = &v
	return s
}

type GetMediaDNAResultResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetMediaDNAResultResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetMediaDNAResultResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMediaDNAResultResponse) GoString() string {
	return s.String()
}

func (s *GetMediaDNAResultResponse) SetHeaders(v map[string]*string) *GetMediaDNAResultResponse {
	s.Headers = v
	return s
}

func (s *GetMediaDNAResultResponse) SetStatusCode(v int32) *GetMediaDNAResultResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMediaDNAResultResponse) SetBody(v *GetMediaDNAResultResponseBody) *GetMediaDNAResultResponse {
	s.Body = v
	return s
}

type GetMediaRefreshJobsRequest struct {
	// The ID of the media file. It is the value of the `MediaIds` parameter that you specify when you call the [RefreshMediaPlayUrls](~~RefreshMediaPlayUrls~~) operation. You can specify only one media ID.
	//
	// If you leave this parameter empty, information about all media files in the refresh or prefetch job specified by `MediaRefreshJobId` is returned. If you set this parameter, only the information about the specified media file is returned.``
	//
	// example:
	//
	// ca3a8f6e4957b658067095869****
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The ID of the refresh or prefetch job. It is the value of the MediaRefreshJobId parameter that is returned from the call to the [RefreshMediaPlayUrls](~~RefreshMediaPlayUrls~~) operation.
	//
	// This parameter is required.
	//
	// example:
	//
	// 41d465e31957****
	MediaRefreshJobId *string `json:"MediaRefreshJobId,omitempty" xml:"MediaRefreshJobId,omitempty"`
}

func (s GetMediaRefreshJobsRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMediaRefreshJobsRequest) GoString() string {
	return s.String()
}

func (s *GetMediaRefreshJobsRequest) SetMediaId(v string) *GetMediaRefreshJobsRequest {
	s.MediaId = &v
	return s
}

func (s *GetMediaRefreshJobsRequest) SetMediaRefreshJobId(v string) *GetMediaRefreshJobsRequest {
	s.MediaRefreshJobId = &v
	return s
}

type GetMediaRefreshJobsResponseBody struct {
	// The media refresh or prefetch jobs.
	MediaRefreshJobs []*GetMediaRefreshJobsResponseBodyMediaRefreshJobs `json:"MediaRefreshJobs,omitempty" xml:"MediaRefreshJobs,omitempty" type:"Repeated"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4AF6-D7393642CA58****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetMediaRefreshJobsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMediaRefreshJobsResponseBody) GoString() string {
	return s.String()
}

func (s *GetMediaRefreshJobsResponseBody) SetMediaRefreshJobs(v []*GetMediaRefreshJobsResponseBodyMediaRefreshJobs) *GetMediaRefreshJobsResponseBody {
	s.MediaRefreshJobs = v
	return s
}

func (s *GetMediaRefreshJobsResponseBody) SetRequestId(v string) *GetMediaRefreshJobsResponseBody {
	s.RequestId = &v
	return s
}

type GetMediaRefreshJobsResponseBodyMediaRefreshJobs struct {
	// The error code. This parameter is returned if the refresh or prefetch task fails.
	//
	// example:
	//
	// PreloadQueueFull
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message. This parameter is returned if the refresh or prefetch task fails.
	//
	// example:
	//
	// Preload queue is full, please try again later!
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The filtering conditions for stream playback. The value is a JSON string. This parameter is used as a request parameter of the [RefreshMediaPlayUrls](~~RefreshMediaPlayUrls~~) operation.
	//
	// example:
	//
	// {"Formats":"mp4,m3u8", "Definitions":"HD,SD",  " StreamType":"video",  "ResultType":"Single",  " SliceFlag":false, "SliceCount": 3}
	FilterPolicy *string `json:"FilterPolicy,omitempty" xml:"FilterPolicy,omitempty"`
	// The time when the task was created.
	//
	// example:
	//
	// 2022-05-20T08:23:22Z
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The time when the task was modified.
	//
	// example:
	//
	// 2022-05-21T08:23:22Z
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the media file.
	//
	// example:
	//
	// ca3a8f6e4957b658067095869****
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The ID of the job.
	//
	// example:
	//
	// 41d465e31957****
	MediaRefreshJobId *string `json:"MediaRefreshJobId,omitempty" xml:"MediaRefreshJobId,omitempty"`
	// The status of the job. Valid values:
	//
	// 	- **success**
	//
	// 	- **fail**
	//
	// example:
	//
	// success
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The playback URLs that were refreshed or prefetched.
	//
	// example:
	//
	// https://shenzhen.****.aliyuncdn.com/74401a4f546007bf845cd8840****.m3u8,https://shenzhen.****.aliyuncdn.com/24041e7d13582d86604d8****.m3u8
	SuccessPlayUrls *string `json:"SuccessPlayUrls,omitempty" xml:"SuccessPlayUrls,omitempty"`
	// The IDs of the refresh or prefetch tasks for the playback URLs of media files. Only one URL can be refreshed or prefetched in a task. This value is used in the [DescribeVodRefreshTasks](~~DescribeVodRefreshTasks~~) operation, which queries the status of refresh or prefetch tasks for playback URLs of media files.
	//
	// example:
	//
	// 70422****,9524****
	TaskIds *string `json:"TaskIds,omitempty" xml:"TaskIds,omitempty"`
	// The type of the job. Valid values:
	//
	// 	- **Refresh**
	//
	// 	- **Preload**
	//
	// example:
	//
	// Preload
	TaskType *string `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
	// The user data that you passed when you submit a refresh or prefetch task.
	//
	// example:
	//
	// {"MessageCallback":{"CallbackURL":"http://example.aliyundoc.com"}, "Extend":{"localId":"xxx","test":"www"}}
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
}

func (s GetMediaRefreshJobsResponseBodyMediaRefreshJobs) String() string {
	return tea.Prettify(s)
}

func (s GetMediaRefreshJobsResponseBodyMediaRefreshJobs) GoString() string {
	return s.String()
}

func (s *GetMediaRefreshJobsResponseBodyMediaRefreshJobs) SetErrorCode(v string) *GetMediaRefreshJobsResponseBodyMediaRefreshJobs {
	s.ErrorCode = &v
	return s
}

func (s *GetMediaRefreshJobsResponseBodyMediaRefreshJobs) SetErrorMessage(v string) *GetMediaRefreshJobsResponseBodyMediaRefreshJobs {
	s.ErrorMessage = &v
	return s
}

func (s *GetMediaRefreshJobsResponseBodyMediaRefreshJobs) SetFilterPolicy(v string) *GetMediaRefreshJobsResponseBodyMediaRefreshJobs {
	s.FilterPolicy = &v
	return s
}

func (s *GetMediaRefreshJobsResponseBodyMediaRefreshJobs) SetGmtCreate(v string) *GetMediaRefreshJobsResponseBodyMediaRefreshJobs {
	s.GmtCreate = &v
	return s
}

func (s *GetMediaRefreshJobsResponseBodyMediaRefreshJobs) SetGmtModified(v string) *GetMediaRefreshJobsResponseBodyMediaRefreshJobs {
	s.GmtModified = &v
	return s
}

func (s *GetMediaRefreshJobsResponseBodyMediaRefreshJobs) SetMediaId(v string) *GetMediaRefreshJobsResponseBodyMediaRefreshJobs {
	s.MediaId = &v
	return s
}

func (s *GetMediaRefreshJobsResponseBodyMediaRefreshJobs) SetMediaRefreshJobId(v string) *GetMediaRefreshJobsResponseBodyMediaRefreshJobs {
	s.MediaRefreshJobId = &v
	return s
}

func (s *GetMediaRefreshJobsResponseBodyMediaRefreshJobs) SetStatus(v string) *GetMediaRefreshJobsResponseBodyMediaRefreshJobs {
	s.Status = &v
	return s
}

func (s *GetMediaRefreshJobsResponseBodyMediaRefreshJobs) SetSuccessPlayUrls(v string) *GetMediaRefreshJobsResponseBodyMediaRefreshJobs {
	s.SuccessPlayUrls = &v
	return s
}

func (s *GetMediaRefreshJobsResponseBodyMediaRefreshJobs) SetTaskIds(v string) *GetMediaRefreshJobsResponseBodyMediaRefreshJobs {
	s.TaskIds = &v
	return s
}

func (s *GetMediaRefreshJobsResponseBodyMediaRefreshJobs) SetTaskType(v string) *GetMediaRefreshJobsResponseBodyMediaRefreshJobs {
	s.TaskType = &v
	return s
}

func (s *GetMediaRefreshJobsResponseBodyMediaRefreshJobs) SetUserData(v string) *GetMediaRefreshJobsResponseBodyMediaRefreshJobs {
	s.UserData = &v
	return s
}

type GetMediaRefreshJobsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetMediaRefreshJobsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetMediaRefreshJobsResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMediaRefreshJobsResponse) GoString() string {
	return s.String()
}

func (s *GetMediaRefreshJobsResponse) SetHeaders(v map[string]*string) *GetMediaRefreshJobsResponse {
	s.Headers = v
	return s
}

func (s *GetMediaRefreshJobsResponse) SetStatusCode(v int32) *GetMediaRefreshJobsResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMediaRefreshJobsResponse) SetBody(v *GetMediaRefreshJobsResponseBody) *GetMediaRefreshJobsResponse {
	s.Body = v
	return s
}

type GetMessageCallbackRequest struct {
	// The ID of the application. If you do not set this parameter, the default value **app-1000000*	- is used.
	//
	// example:
	//
	// app-1000000
	AppId        *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
}

func (s GetMessageCallbackRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMessageCallbackRequest) GoString() string {
	return s.String()
}

func (s *GetMessageCallbackRequest) SetAppId(v string) *GetMessageCallbackRequest {
	s.AppId = &v
	return s
}

func (s *GetMessageCallbackRequest) SetOwnerAccount(v string) *GetMessageCallbackRequest {
	s.OwnerAccount = &v
	return s
}

type GetMessageCallbackResponseBody struct {
	// The configuration of the event notification.
	MessageCallback *GetMessageCallbackResponseBodyMessageCallback `json:"MessageCallback,omitempty" xml:"MessageCallback,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// 272A222A-F7F7-4A3E-****-F531574F1234
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetMessageCallbackResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMessageCallbackResponseBody) GoString() string {
	return s.String()
}

func (s *GetMessageCallbackResponseBody) SetMessageCallback(v *GetMessageCallbackResponseBodyMessageCallback) *GetMessageCallbackResponseBody {
	s.MessageCallback = v
	return s
}

func (s *GetMessageCallbackResponseBody) SetRequestId(v string) *GetMessageCallbackResponseBody {
	s.RequestId = &v
	return s
}

type GetMessageCallbackResponseBodyMessageCallback struct {
	// The ID of the application.
	//
	// example:
	//
	// app-1000000
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The cryptographic key. This parameter is returned only for HTTP callbacks.
	//
	// example:
	//
	// 12345678abc
	AuthKey *string `json:"AuthKey,omitempty" xml:"AuthKey,omitempty"`
	// Indicates whether callback authentication is enabled. This parameter is returned only for HTTP callbacks. Valid values:
	//
	// 	- **on**
	//
	// 	- **off**
	//
	// example:
	//
	// on
	AuthSwitch *string `json:"AuthSwitch,omitempty" xml:"AuthSwitch,omitempty"`
	// The callback method. Valid values:
	//
	// 	- **HTTP**
	//
	// 	- **MNS**
	//
	// example:
	//
	// HTTP
	CallbackType *string `json:"CallbackType,omitempty" xml:"CallbackType,omitempty"`
	// The callback URL. This parameter is returned only for HTTP callbacks.
	//
	// example:
	//
	// http://test.com/test
	CallbackURL *string `json:"CallbackURL,omitempty" xml:"CallbackURL,omitempty"`
	// The type of the callback event.
	//
	// example:
	//
	// FileUploadComplete,StreamTranscodeComplete,TranscodeComplete,SnapshotComplete,AIComplete,AddLiveRecordVideoComplete,CreateAuditComplete,UploadByURLComplete,ProduceMediaComplete,LiveRecordVideoComposeStart,ImageUploadComplete,VideoAnalysisComplete
	EventTypeList *string `json:"EventTypeList,omitempty" xml:"EventTypeList,omitempty"`
	// The public endpoint of MNS. This parameter is returned only for MNS callbacks.
	//
	// example:
	//
	// http://1234567.mns.cn-shanghai-internal.aliyuncs.com/
	MnsEndpoint *string `json:"MnsEndpoint,omitempty" xml:"MnsEndpoint,omitempty"`
	// The name of the Message Service (MNS) queue. This parameter is returned only for MNS callbacks.
	//
	// example:
	//
	// vodcallback
	MnsQueueName *string `json:"MnsQueueName,omitempty" xml:"MnsQueueName,omitempty"`
}

func (s GetMessageCallbackResponseBodyMessageCallback) String() string {
	return tea.Prettify(s)
}

func (s GetMessageCallbackResponseBodyMessageCallback) GoString() string {
	return s.String()
}

func (s *GetMessageCallbackResponseBodyMessageCallback) SetAppId(v string) *GetMessageCallbackResponseBodyMessageCallback {
	s.AppId = &v
	return s
}

func (s *GetMessageCallbackResponseBodyMessageCallback) SetAuthKey(v string) *GetMessageCallbackResponseBodyMessageCallback {
	s.AuthKey = &v
	return s
}

func (s *GetMessageCallbackResponseBodyMessageCallback) SetAuthSwitch(v string) *GetMessageCallbackResponseBodyMessageCallback {
	s.AuthSwitch = &v
	return s
}

func (s *GetMessageCallbackResponseBodyMessageCallback) SetCallbackType(v string) *GetMessageCallbackResponseBodyMessageCallback {
	s.CallbackType = &v
	return s
}

func (s *GetMessageCallbackResponseBodyMessageCallback) SetCallbackURL(v string) *GetMessageCallbackResponseBodyMessageCallback {
	s.CallbackURL = &v
	return s
}

func (s *GetMessageCallbackResponseBodyMessageCallback) SetEventTypeList(v string) *GetMessageCallbackResponseBodyMessageCallback {
	s.EventTypeList = &v
	return s
}

func (s *GetMessageCallbackResponseBodyMessageCallback) SetMnsEndpoint(v string) *GetMessageCallbackResponseBodyMessageCallback {
	s.MnsEndpoint = &v
	return s
}

func (s *GetMessageCallbackResponseBodyMessageCallback) SetMnsQueueName(v string) *GetMessageCallbackResponseBodyMessageCallback {
	s.MnsQueueName = &v
	return s
}

type GetMessageCallbackResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetMessageCallbackResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetMessageCallbackResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMessageCallbackResponse) GoString() string {
	return s.String()
}

func (s *GetMessageCallbackResponse) SetHeaders(v map[string]*string) *GetMessageCallbackResponse {
	s.Headers = v
	return s
}

func (s *GetMessageCallbackResponse) SetStatusCode(v int32) *GetMessageCallbackResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMessageCallbackResponse) SetBody(v *GetMessageCallbackResponseBody) *GetMessageCallbackResponse {
	s.Body = v
	return s
}

type GetMezzanineInfoRequest struct {
	// The type of additional information. Separate multiple values with commas (,). By default, only the basic information is returned. Valid values:
	//
	// 	- **video**: video stream information
	//
	// 	- **audio**: audio stream information
	//
	// example:
	//
	// video
	AdditionType *string `json:"AdditionType,omitempty" xml:"AdditionType,omitempty"`
	// The validity period of the mezzanine file URL. Unit: seconds. Default value: **1800**. Minimum value: **1**.
	//
	// 	- If the OutputType parameter is set to **cdn**:
	//
	//     	- The mezzanine file URL has a validity period only if URL signing is enabled. Otherwise, the mezzanine file URL is permanently valid.
	//
	//     	- Minimum value: **1**.
	//
	//     	- Maximum Value: unlimited.
	//
	//     	- Default value: If you do not set this parameter, the default validity period that is specified in URL signing is used.
	//
	// <!---->
	//
	// 	- If the OutputType parameter is set to **oss**:
	//
	//     	- The mezzanine file URL has a validity period only if the permissions on the Object Storage Service (OSS) bucket are private. Otherwise, the mezzanine file URL is permanently valid.
	//
	//     	- Minimum value: **1**.
	//
	//     	- Maximum value: **2592000*	- (30 days). The maximum value is limited to reduce security risks of the origin.
	//
	//     	- Default value: If you do not set this parameter, the default value is **3600**.
	//
	// example:
	//
	// 3600
	AuthTimeout *int64 `json:"AuthTimeout,omitempty" xml:"AuthTimeout,omitempty"`
	// The type of the mezzanine file URL. Valid values:
	//
	// - **oss**: OSS URL
	//
	// - **cdn*	- (default): Content Delivery Network (CDN) URL
	//
	// > If the mezzanine file is stored in a bucket of the in type, only an OSS URL is returned.
	//
	// example:
	//
	// oss
	OutputType *string `json:"OutputType,omitempty" xml:"OutputType,omitempty"`
	// The ID of the video.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1f1a6fc03ca04814031b8a6559e****
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s GetMezzanineInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMezzanineInfoRequest) GoString() string {
	return s.String()
}

func (s *GetMezzanineInfoRequest) SetAdditionType(v string) *GetMezzanineInfoRequest {
	s.AdditionType = &v
	return s
}

func (s *GetMezzanineInfoRequest) SetAuthTimeout(v int64) *GetMezzanineInfoRequest {
	s.AuthTimeout = &v
	return s
}

func (s *GetMezzanineInfoRequest) SetOutputType(v string) *GetMezzanineInfoRequest {
	s.OutputType = &v
	return s
}

func (s *GetMezzanineInfoRequest) SetVideoId(v string) *GetMezzanineInfoRequest {
	s.VideoId = &v
	return s
}

type GetMezzanineInfoResponseBody struct {
	// The information about the source file.
	Mezzanine *GetMezzanineInfoResponseBodyMezzanine `json:"Mezzanine,omitempty" xml:"Mezzanine,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4AF6-D7393642CA58****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetMezzanineInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMezzanineInfoResponseBody) GoString() string {
	return s.String()
}

func (s *GetMezzanineInfoResponseBody) SetMezzanine(v *GetMezzanineInfoResponseBodyMezzanine) *GetMezzanineInfoResponseBody {
	s.Mezzanine = v
	return s
}

func (s *GetMezzanineInfoResponseBody) SetRequestId(v string) *GetMezzanineInfoResponseBody {
	s.RequestId = &v
	return s
}

type GetMezzanineInfoResponseBodyMezzanine struct {
	// The codec time base.
	AudioStreamList []*GetMezzanineInfoResponseBodyMezzanineAudioStreamList `json:"AudioStreamList,omitempty" xml:"AudioStreamList,omitempty" type:"Repeated"`
	// The bitrate of the file. Unit: Kbit/s.
	//
	// example:
	//
	// 771.2280
	Bitrate *string `json:"Bitrate,omitempty" xml:"Bitrate,omitempty"`
	// The time when the file was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-11-14T09:15:50Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The duration of the file. Unit: seconds.
	//
	// example:
	//
	// 42.4930
	Duration *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The name of the file.
	//
	// example:
	//
	// 27ffc438-164h67f57ef-0005-6884-51a-1****.mp4
	FileName *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	// The URL of the file.
	//
	// example:
	//
	// http://example-bucket-****.oss-cn-shanghai.aliyuncs.com/27ffc438-164h67f57ef-0005-6884-51a-1****.mp4
	FileURL *string `json:"FileURL,omitempty" xml:"FileURL,omitempty"`
	// The frame rate of the file. Unit: frames per second.
	//
	// example:
	//
	// 25.0000
	Fps *string `json:"Fps,omitempty" xml:"Fps,omitempty"`
	// The height of the file. Unit: pixel.
	//
	// example:
	//
	// 540
	Height *int64 `json:"Height,omitempty" xml:"Height,omitempty"`
	// The type of the mezzanine file URL. Valid values:
	//
	// - **oss**: OSS URL
	//
	// - **cdn*	- (default): CDN URL
	//
	// > If you specify an OSS URL for the video stream, the video stream must be in the MP4 format.
	//
	// example:
	//
	// oss
	OutputType *string `json:"OutputType,omitempty" xml:"OutputType,omitempty"`
	// The preprocess status od the media.
	//
	// example:
	//
	// UnPreprocess
	PreprocessStatus *string `json:"PreprocessStatus,omitempty" xml:"PreprocessStatus,omitempty"`
	// The period of time in which the object remains in the restored state.
	//
	// example:
	//
	// 2023-03-30T10:14:14Z
	RestoreExpiration *string `json:"RestoreExpiration,omitempty" xml:"RestoreExpiration,omitempty"`
	// The restoration status of the audio or video file. Valid values:
	//
	// 	- **Processing**
	//
	// 	- **Success**
	//
	// 	- **Failed**
	//
	// example:
	//
	// Success
	RestoreStatus *string `json:"RestoreStatus,omitempty" xml:"RestoreStatus,omitempty"`
	// The size of the file. Unit: byte.
	//
	// example:
	//
	// 4096477
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The status of the file. Valid values:
	//
	// 	- **Uploading**: The file is being uploaded. This is the initial status.
	//
	// 	- **Normal**: The file is uploaded.
	//
	// 	- **UploadFail**: The file fails to be uploaded.
	//
	// 	- **Deleted**: The file is deleted.
	//
	// example:
	//
	// Normal
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The storage class of the audio file. Valid values:
	//
	// 	- **Standard**: All media resources are stored as Standard objects.
	//
	// 	- **IA**: All media resources are stored as IA objects.
	//
	// 	- **Archive**: All media resources are stored as Archive objects.
	//
	// 	- **ColdArchive**: All media resources are stored as Cold Archive objects.
	//
	// 	- **SourceIA**: Only the source files are IA objects.
	//
	// 	- **SourceArchive**: Only the source files are Archive objects.
	//
	// 	- **SourceColdArchive**: Only the source files are Cold Archive objects.
	//
	// 	- **Changing**: The storage class of the audio file is being changed.
	//
	// 	- **SourceChanging**: The storage class of the source file is being changed.
	//
	// example:
	//
	// Standard
	StorageClass *string `json:"StorageClass,omitempty" xml:"StorageClass,omitempty"`
	// The ID of the video.
	//
	// example:
	//
	// 1f1a6fc03ca04814031b8a6559e****
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
	// The HDR type of the video stream.
	VideoStreamList []*GetMezzanineInfoResponseBodyMezzanineVideoStreamList `json:"VideoStreamList,omitempty" xml:"VideoStreamList,omitempty" type:"Repeated"`
	// The width of the file. Unit: pixel.
	//
	// example:
	//
	// 960
	Width *int64 `json:"Width,omitempty" xml:"Width,omitempty"`
}

func (s GetMezzanineInfoResponseBodyMezzanine) String() string {
	return tea.Prettify(s)
}

func (s GetMezzanineInfoResponseBodyMezzanine) GoString() string {
	return s.String()
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetAudioStreamList(v []*GetMezzanineInfoResponseBodyMezzanineAudioStreamList) *GetMezzanineInfoResponseBodyMezzanine {
	s.AudioStreamList = v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetBitrate(v string) *GetMezzanineInfoResponseBodyMezzanine {
	s.Bitrate = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetCreationTime(v string) *GetMezzanineInfoResponseBodyMezzanine {
	s.CreationTime = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetDuration(v string) *GetMezzanineInfoResponseBodyMezzanine {
	s.Duration = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetFileName(v string) *GetMezzanineInfoResponseBodyMezzanine {
	s.FileName = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetFileURL(v string) *GetMezzanineInfoResponseBodyMezzanine {
	s.FileURL = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetFps(v string) *GetMezzanineInfoResponseBodyMezzanine {
	s.Fps = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetHeight(v int64) *GetMezzanineInfoResponseBodyMezzanine {
	s.Height = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetOutputType(v string) *GetMezzanineInfoResponseBodyMezzanine {
	s.OutputType = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetPreprocessStatus(v string) *GetMezzanineInfoResponseBodyMezzanine {
	s.PreprocessStatus = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetRestoreExpiration(v string) *GetMezzanineInfoResponseBodyMezzanine {
	s.RestoreExpiration = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetRestoreStatus(v string) *GetMezzanineInfoResponseBodyMezzanine {
	s.RestoreStatus = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetSize(v int64) *GetMezzanineInfoResponseBodyMezzanine {
	s.Size = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetStatus(v string) *GetMezzanineInfoResponseBodyMezzanine {
	s.Status = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetStorageClass(v string) *GetMezzanineInfoResponseBodyMezzanine {
	s.StorageClass = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetVideoId(v string) *GetMezzanineInfoResponseBodyMezzanine {
	s.VideoId = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetVideoStreamList(v []*GetMezzanineInfoResponseBodyMezzanineVideoStreamList) *GetMezzanineInfoResponseBodyMezzanine {
	s.VideoStreamList = v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetWidth(v int64) *GetMezzanineInfoResponseBodyMezzanine {
	s.Width = &v
	return s
}

type GetMezzanineInfoResponseBodyMezzanineAudioStreamList struct {
	// The bitrate.
	//
	// example:
	//
	// 62.885
	Bitrate *string `json:"Bitrate,omitempty" xml:"Bitrate,omitempty"`
	// The output layout of the sound channels. Valid values:
	//
	// 	- **mono**
	//
	// 	- **stereo**
	//
	// example:
	//
	// mono
	ChannelLayout *string `json:"ChannelLayout,omitempty" xml:"ChannelLayout,omitempty"`
	// The number of sound channels.
	//
	// example:
	//
	// 1
	Channels *string `json:"Channels,omitempty" xml:"Channels,omitempty"`
	// The full name of the encoding format.
	//
	// example:
	//
	// AAC (Advanced Audio Coding)
	CodecLongName *string `json:"CodecLongName,omitempty" xml:"CodecLongName,omitempty"`
	// The short name of the encoding format.
	//
	// example:
	//
	// aac
	CodecName *string `json:"CodecName,omitempty" xml:"CodecName,omitempty"`
	// The tag of the encoding format.
	//
	// example:
	//
	// 0x6134706d
	CodecTag *string `json:"CodecTag,omitempty" xml:"CodecTag,omitempty"`
	// The tag string of the encoding format.
	//
	// example:
	//
	// mp4a
	CodecTagString *string `json:"CodecTagString,omitempty" xml:"CodecTagString,omitempty"`
	// The codec time base.
	//
	// example:
	//
	// 1/44100
	CodecTimeBase *string `json:"CodecTimeBase,omitempty" xml:"CodecTimeBase,omitempty"`
	// The duration of the audio file.
	//
	// example:
	//
	// 3.227574
	Duration *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The sequence number of the audio stream. The value indicates the position of the audio stream in all audio streams.
	//
	// example:
	//
	// 0
	Index *string `json:"Index,omitempty" xml:"Index,omitempty"`
	// The language.
	//
	// example:
	//
	// und
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The total number of frames.
	//
	// example:
	//
	// 1
	NumFrames *string `json:"NumFrames,omitempty" xml:"NumFrames,omitempty"`
	// The sampling format.
	//
	// example:
	//
	// fltp
	SampleFmt *string `json:"SampleFmt,omitempty" xml:"SampleFmt,omitempty"`
	// The sampling rate of the audio stream.
	//
	// example:
	//
	// 44100
	SampleRate *string `json:"SampleRate,omitempty" xml:"SampleRate,omitempty"`
	// The beginning of the time range during which the data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-01-11T12:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The time base of the audio stream.
	//
	// example:
	//
	// 0.000000
	Timebase *string `json:"Timebase,omitempty" xml:"Timebase,omitempty"`
}

func (s GetMezzanineInfoResponseBodyMezzanineAudioStreamList) String() string {
	return tea.Prettify(s)
}

func (s GetMezzanineInfoResponseBodyMezzanineAudioStreamList) GoString() string {
	return s.String()
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetBitrate(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.Bitrate = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetChannelLayout(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.ChannelLayout = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetChannels(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.Channels = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetCodecLongName(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.CodecLongName = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetCodecName(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.CodecName = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetCodecTag(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.CodecTag = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetCodecTagString(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.CodecTagString = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetCodecTimeBase(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.CodecTimeBase = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetDuration(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.Duration = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetIndex(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.Index = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetLang(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.Lang = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetNumFrames(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.NumFrames = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetSampleFmt(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.SampleFmt = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetSampleRate(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.SampleRate = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetStartTime(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.StartTime = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetTimebase(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.Timebase = &v
	return s
}

type GetMezzanineInfoResponseBodyMezzanineVideoStreamList struct {
	// The average frame rate.
	//
	// example:
	//
	// 30.0
	AvgFPS *string `json:"AvgFPS,omitempty" xml:"AvgFPS,omitempty"`
	// The bitrate. Unit: Kbit/s.
	//
	// example:
	//
	// 500
	Bitrate *string `json:"Bitrate,omitempty" xml:"Bitrate,omitempty"`
	// The full name of the encoding format.
	//
	// example:
	//
	// H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10
	CodecLongName *string `json:"CodecLongName,omitempty" xml:"CodecLongName,omitempty"`
	// The short name of the encoding format.
	//
	// example:
	//
	// h264
	CodecName *string `json:"CodecName,omitempty" xml:"CodecName,omitempty"`
	// The tag of the encoding format.
	//
	// example:
	//
	// 0x31637661
	CodecTag *string `json:"CodecTag,omitempty" xml:"CodecTag,omitempty"`
	// The tag string of the encoding format.
	//
	// example:
	//
	// avc1
	CodecTagString *string `json:"CodecTagString,omitempty" xml:"CodecTagString,omitempty"`
	// The codec time base.
	//
	// example:
	//
	// 1/60
	CodecTimeBase *string `json:"CodecTimeBase,omitempty" xml:"CodecTimeBase,omitempty"`
	// The display aspect ratio (DAR) of the video stream.
	//
	// example:
	//
	// 0:1
	Dar *string `json:"Dar,omitempty" xml:"Dar,omitempty"`
	// The duration of the audio file.
	//
	// example:
	//
	// 3.166667
	Duration *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The frame rate of the output file.
	//
	// example:
	//
	// 30.0
	Fps *string `json:"Fps,omitempty" xml:"Fps,omitempty"`
	// The HDR type of the video stream.
	//
	// example:
	//
	// HDR
	HDRType *string `json:"HDRType,omitempty" xml:"HDRType,omitempty"`
	// Indicates whether the video stream contains B-frames.
	//
	// example:
	//
	// 0
	HasBFrames *string `json:"HasBFrames,omitempty" xml:"HasBFrames,omitempty"`
	// The height of the video stream.
	//
	// example:
	//
	// 320
	Height *string `json:"Height,omitempty" xml:"Height,omitempty"`
	// The sequence number of the video stream. The value indicates the position of the video stream in all video streams.
	//
	// example:
	//
	// 1
	Index *string `json:"Index,omitempty" xml:"Index,omitempty"`
	// The language.
	//
	// example:
	//
	// und
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The codec level.
	//
	// example:
	//
	// 30
	Level *string `json:"Level,omitempty" xml:"Level,omitempty"`
	// The total number of frames.
	//
	// example:
	//
	// 0
	NumFrames *string `json:"NumFrames,omitempty" xml:"NumFrames,omitempty"`
	// The pixel format.
	//
	// example:
	//
	// yuv420p
	PixFmt *string `json:"PixFmt,omitempty" xml:"PixFmt,omitempty"`
	// The codec profile.
	//
	// example:
	//
	// Main
	Profile *string `json:"Profile,omitempty" xml:"Profile,omitempty"`
	// The rotation angle of the video. Valid values: **[0,360)**.
	//
	// example:
	//
	// 90
	Rotate *string `json:"Rotate,omitempty" xml:"Rotate,omitempty"`
	// The sample aspect ratio (SAR) of the video stream.
	//
	// example:
	//
	// 0:1
	Sar *string `json:"Sar,omitempty" xml:"Sar,omitempty"`
	// The beginning of the time range during which the data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-01-11T12:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The time base of the audio stream.
	//
	// example:
	//
	// 0.000000
	Timebase *string `json:"Timebase,omitempty" xml:"Timebase,omitempty"`
	// The width of the video in pixels.
	//
	// example:
	//
	// 568
	Width *string `json:"Width,omitempty" xml:"Width,omitempty"`
}

func (s GetMezzanineInfoResponseBodyMezzanineVideoStreamList) String() string {
	return tea.Prettify(s)
}

func (s GetMezzanineInfoResponseBodyMezzanineVideoStreamList) GoString() string {
	return s.String()
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetAvgFPS(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.AvgFPS = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetBitrate(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.Bitrate = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetCodecLongName(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.CodecLongName = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetCodecName(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.CodecName = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetCodecTag(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.CodecTag = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetCodecTagString(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.CodecTagString = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetCodecTimeBase(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.CodecTimeBase = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetDar(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.Dar = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetDuration(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.Duration = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetFps(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.Fps = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetHDRType(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.HDRType = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetHasBFrames(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.HasBFrames = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetHeight(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.Height = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetIndex(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.Index = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetLang(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.Lang = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetLevel(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.Level = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetNumFrames(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.NumFrames = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetPixFmt(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.PixFmt = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetProfile(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.Profile = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetRotate(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.Rotate = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetSar(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.Sar = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetStartTime(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.StartTime = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetTimebase(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.Timebase = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetWidth(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.Width = &v
	return s
}

type GetMezzanineInfoResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetMezzanineInfoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetMezzanineInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMezzanineInfoResponse) GoString() string {
	return s.String()
}

func (s *GetMezzanineInfoResponse) SetHeaders(v map[string]*string) *GetMezzanineInfoResponse {
	s.Headers = v
	return s
}

func (s *GetMezzanineInfoResponse) SetStatusCode(v int32) *GetMezzanineInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMezzanineInfoResponse) SetBody(v *GetMezzanineInfoResponseBody) *GetMezzanineInfoResponse {
	s.Body = v
	return s
}

type GetPlayInfoRequest struct {
	// The URL of the masked live comment data. Value: **danmu**.
	//
	// >  This parameter takes effect only when the `outputType` parameter is set to `cdn`.
	//
	// example:
	//
	// danmu
	AdditionType *string `json:"AdditionType,omitempty" xml:"AdditionType,omitempty"`
	// The validity period of the playback URL. Unit: seconds.
	//
	// 	- If you set OutputType to **cdn**:
	//
	//     	- The playback URL has a validity period only if URL signing is enabled. Otherwise, the playback URL is permanently valid. For more information about how to enable and configure URL signing, see [URL signing](https://help.aliyun.com/document_detail/86090.html).
	//
	//     	- Minimum value: **1**.
	//
	//     	- Maximum value: unlimited.
	//
	//     	- Default value: The default validity period that is specified in URL signing is used.
	//
	// 	- If you set OutputType to **oss**:
	//
	//     	- This parameter takes effect only when the ACL of the Object Storage Service (OSS) bucket is private. Otherwise, the playback URL does not expire.
	//
	//     	- Minimum value: **1**.
	//
	//     	- Maximum value: If the media file is stored in the VOD bucket, the maximum validity period is **2592000*	- (30 days). If the media file is stored in an OSS bucket, the maximum validity period is **129600*	- (36 hours). This limit is imposed to reduce security risks of the origin server. If you require a longer validity period, set OutputType to **cdn*	- and configure URL signing to specify a longer validity period.
	//
	//     	- Default value: **3600**.
	//
	// example:
	//
	// 1800
	AuthTimeout *int64 `json:"AuthTimeout,omitempty" xml:"AuthTimeout,omitempty"`
	// The quality of the video stream. Separate multiple qualities with commas (,). Valid values:
	//
	// 	- **FD**: low definition
	//
	// 	- **LD**: standard definition
	//
	// 	- **SD**: high definition
	//
	// 	- **HD**: ultra-high definition
	//
	// 	- **OD**: original definition
	//
	// 	- **2K**
	//
	// 	- **4K**
	//
	// 	- **SQ**: standard sound quality
	//
	// 	- **HQ**: high sound quality
	//
	// 	- **AUTO**: adaptive bitrate
	//
	// > 	- By default, ApsaraVideo VOD returns video streams in all the preceding qualities.
	//
	// > 	- However, video streams for adaptive bitrate streaming are returned only if the PackageSetting parameter is specified in the transcoding template. For more information, see the [PackageSetting parameter in the TranscodeTemplate table](~~52839#title-4fk-cg8-gzx~~).
	//
	// example:
	//
	// LD
	Definition *string `json:"Definition,omitempty" xml:"Definition,omitempty"`
	// The type of the digital watermark. Valid values:
	//
	// 	- TraceMark: tracing watermark
	//
	// 	- CopyrightMark: copyright watermark
	//
	// example:
	//
	// TraceMark
	DigitalWatermarkType *string `json:"DigitalWatermarkType,omitempty" xml:"DigitalWatermarkType,omitempty"`
	// The format of the media stream. Separate multiple formats with commas (,). Valid values:
	//
	// 	- **mp4**
	//
	// 	- **m3u8**
	//
	// 	- **mp3**
	//
	// 	- **flv**
	//
	// 	- **mpd**
	//
	// > 	- By default, ApsaraVideo VOD returns video streams in all the preceding formats.
	//
	// >	- However, video streams in the MPD format are returned only if the `dash` container format is specified in the transcoding template. For more information, see the [Container parameter in the TranscodeTemplate table](~~52839#title-7rr-3hj-gy5~~).
	//
	// example:
	//
	// mp4,m3u8
	Formats *string `json:"Formats,omitempty" xml:"Formats,omitempty"`
	// The type of the output URL. Default value: oss. Valid values:
	//
	// 	- **oss**
	//
	// 	- **cdn**
	//
	// example:
	//
	// cdn
	OutputType *string `json:"OutputType,omitempty" xml:"OutputType,omitempty"`
	// The custom playback configuration. The value must be a JSON string. You can specify a domain name for playback. For more information, see [PlayConfig](~~86952#section-9g7-s9b-v7z~~).
	//
	// > 	- If you do not set the PlayConfig parameter or the `PlayDomain` parameter that is nested under the PlayConfig parameter, the default domain name specified in ApsaraVideo VOD is used in this operation. If no default domain name is specified, the domain names are queried in reverse chronological order based on the time when the domain names were last modified. To prevent domain name issues, we recommend that you perform the following steps to specify the default playback domain name: Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Configuration Management*	- > **Media Management*	- > **Storage**. Find the domain name that you want to configure and click **Manage*	- in the Actions column. On the page that appears, set the default playback domain name in the **Origin Domain Name*	- section.
	//
	// > 	- If you set the `EncryptType` parameter nested under the PlayConfig parameter to `AliyunVoDEncryption`, the playback URLs of videos encrypted by using Alibaba Cloud proprietary cryptography are not automatically returned to ensure video security. To return playback URLs of videos encrypted by using Alibaba Cloud proprietary cryptography, you must set the `ResultType` parameter to `Multiple`.
	//
	// example:
	//
	// {"PlayDomain":"vod.test_domain","XForwardedFor":"yqCD7Fp1uqChoVj/sl/p5Q==","PreviewTime":"20","MtsHlsUriToken":"yqCD7Fp1uqChoVjslp5Q"}
	PlayConfig *string `json:"PlayConfig,omitempty" xml:"PlayConfig,omitempty"`
	// The CDN reauthentication configuration. The value must be a JSON string. If CDN reauthentication is enabled, you can use this parameter to specify the `UID` and `rand` fields for URL authentication. For more information, see [URL authentication](https://help.aliyun.com/document_detail/2249352.html).
	//
	// example:
	//
	// {"uid":"12345","rand":"abckljd"}
	ReAuthInfo *string `json:"ReAuthInfo,omitempty" xml:"ReAuthInfo,omitempty"`
	// The type of the data to return. Default value: Single. Valid values:
	//
	// 	- **Single**: Only one latest transcoded stream is returned for each quality and format.
	//
	// 	- **Multiple**: All transcoded streams are returned for each quality and format.
	//
	// example:
	//
	// Single
	ResultType *string `json:"ResultType,omitempty" xml:"ResultType,omitempty"`
	// The type of the media stream. Separate multiple types with commas (,). Valid values:
	//
	// 	- **video**
	//
	// 	- **audio**
	//
	// By default, video and audio streams are returned.
	//
	// example:
	//
	// video
	StreamType *string `json:"StreamType,omitempty" xml:"StreamType,omitempty"`
	// The custom digital watermark.
	//
	// 	- If you set `DigitalWatermarkType` to `TraceMark`, specify this parameter to configure the video tracing watermark and return the video stream that contains the watermark. The value can be up to 1,024 characters in length and can contain letters and digits.
	//
	// 	- If you set `DigitalWatermarkType` to `CopyrightMark`, specify the **watermark text*	- that you created for the watermark template for this parameter.`` You can specify this parameter to query and return the video stream that contains the specified watermark text.
	//
	// example:
	//
	// test mark
	Trace *string `json:"Trace,omitempty" xml:"Trace,omitempty"`
	// The ID of the media file. You can specify only one ID. You can use one of the following methods to obtain the ID:
	//
	// 	- Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Media Files*	- > **Audio/Video**. On the page that appears, view the media ID.
	//
	// 	- Obtain the value of the VideoId parameter in the response to the [CreateUploadVideo](https://help.aliyun.com/document_detail/55407.html) operation that you called to upload the audio or video file.
	//
	// 	- Obtain the value of VideoId by calling the [SearchMedia](https://help.aliyun.com/document_detail/86044.html) operation. This method is applicable to files that have been uploaded.
	//
	// This parameter is required.
	//
	// example:
	//
	// 93ab850b4f654b6e91d24d81d44****
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s GetPlayInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s GetPlayInfoRequest) GoString() string {
	return s.String()
}

func (s *GetPlayInfoRequest) SetAdditionType(v string) *GetPlayInfoRequest {
	s.AdditionType = &v
	return s
}

func (s *GetPlayInfoRequest) SetAuthTimeout(v int64) *GetPlayInfoRequest {
	s.AuthTimeout = &v
	return s
}

func (s *GetPlayInfoRequest) SetDefinition(v string) *GetPlayInfoRequest {
	s.Definition = &v
	return s
}

func (s *GetPlayInfoRequest) SetDigitalWatermarkType(v string) *GetPlayInfoRequest {
	s.DigitalWatermarkType = &v
	return s
}

func (s *GetPlayInfoRequest) SetFormats(v string) *GetPlayInfoRequest {
	s.Formats = &v
	return s
}

func (s *GetPlayInfoRequest) SetOutputType(v string) *GetPlayInfoRequest {
	s.OutputType = &v
	return s
}

func (s *GetPlayInfoRequest) SetPlayConfig(v string) *GetPlayInfoRequest {
	s.PlayConfig = &v
	return s
}

func (s *GetPlayInfoRequest) SetReAuthInfo(v string) *GetPlayInfoRequest {
	s.ReAuthInfo = &v
	return s
}

func (s *GetPlayInfoRequest) SetResultType(v string) *GetPlayInfoRequest {
	s.ResultType = &v
	return s
}

func (s *GetPlayInfoRequest) SetStreamType(v string) *GetPlayInfoRequest {
	s.StreamType = &v
	return s
}

func (s *GetPlayInfoRequest) SetTrace(v string) *GetPlayInfoRequest {
	s.Trace = &v
	return s
}

func (s *GetPlayInfoRequest) SetVideoId(v string) *GetPlayInfoRequest {
	s.VideoId = &v
	return s
}

type GetPlayInfoResponseBody struct {
	// The information about the audio or video stream.
	PlayInfoList *GetPlayInfoResponseBodyPlayInfoList `json:"PlayInfoList,omitempty" xml:"PlayInfoList,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// F552E596-967D-5500-842F-17E6364****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The basic information about the audio or video file.
	VideoBase *GetPlayInfoResponseBodyVideoBase `json:"VideoBase,omitempty" xml:"VideoBase,omitempty" type:"Struct"`
}

func (s GetPlayInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetPlayInfoResponseBody) GoString() string {
	return s.String()
}

func (s *GetPlayInfoResponseBody) SetPlayInfoList(v *GetPlayInfoResponseBodyPlayInfoList) *GetPlayInfoResponseBody {
	s.PlayInfoList = v
	return s
}

func (s *GetPlayInfoResponseBody) SetRequestId(v string) *GetPlayInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetPlayInfoResponseBody) SetVideoBase(v *GetPlayInfoResponseBodyVideoBase) *GetPlayInfoResponseBody {
	s.VideoBase = v
	return s
}

type GetPlayInfoResponseBodyPlayInfoList struct {
	PlayInfo []*GetPlayInfoResponseBodyPlayInfoListPlayInfo `json:"PlayInfo,omitempty" xml:"PlayInfo,omitempty" type:"Repeated"`
}

func (s GetPlayInfoResponseBodyPlayInfoList) String() string {
	return tea.Prettify(s)
}

func (s GetPlayInfoResponseBodyPlayInfoList) GoString() string {
	return s.String()
}

func (s *GetPlayInfoResponseBodyPlayInfoList) SetPlayInfo(v []*GetPlayInfoResponseBodyPlayInfoListPlayInfo) *GetPlayInfoResponseBodyPlayInfoList {
	s.PlayInfo = v
	return s
}

type GetPlayInfoResponseBodyPlayInfoListPlayInfo struct {
	// The color depth. This value is an integer.
	//
	// example:
	//
	// 8
	BitDepth *int32 `json:"BitDepth,omitempty" xml:"BitDepth,omitempty"`
	// The bitrate of the media stream. Unit: Kbit/s.
	//
	// example:
	//
	// 450.878
	Bitrate *string `json:"Bitrate,omitempty" xml:"Bitrate,omitempty"`
	// The encoding type. The possible values are:
	//
	// - H264
	//
	// - H265
	//
	// example:
	//
	// H264
	CodecName *string `json:"CodecName,omitempty" xml:"CodecName,omitempty"`
	// The time when the audio or video stream was created. The time is in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2022-04-18T07:37:15Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The quality of the video stream. Valid values:
	//
	// 	- **FD**: low definition
	//
	// 	- **LD**: standard definition
	//
	// 	- **SD**: high definition
	//
	// 	- **HD**: ultra-high definition
	//
	// 	- **OD**: original definition
	//
	// 	- **2K**
	//
	// 	- **4K**
	//
	// 	- **SQ**: standard sound quality
	//
	// 	- **HQ**: high sound quality
	//
	// 	- **AUTO**: adaptive bitrate
	//
	// example:
	//
	// LD
	Definition *string `json:"Definition,omitempty" xml:"Definition,omitempty"`
	// The duration of the media stream. Unit: seconds.
	//
	// example:
	//
	// 9.0464
	Duration *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// Indicates whether the media stream is encrypted. Valid values:
	//
	// 	- **0**: The media stream is not encrypted.
	//
	// 	- **1**: The media stream is encrypted.
	//
	// example:
	//
	// 1
	Encrypt *int64 `json:"Encrypt,omitempty" xml:"Encrypt,omitempty"`
	// The encryption type of the media stream. Valid values:
	//
	// 	- **License**: decryption on local devices
	//
	// >  If the encryption type is **License**, only ApsaraVideo Player SDK can be used to play videos.
	//
	// example:
	//
	// License
	EncryptMode *string `json:"EncryptMode,omitempty" xml:"EncryptMode,omitempty"`
	// The encryption type of the media stream. Valid values:
	//
	// 	- **AliyunVoDEncryption**: Alibaba Cloud proprietary cryptography
	//
	// 	- **HLSEncryption**: HTTP-Live-Streaming (HLS) encryption
	//
	// >  If the encryption type is AliyunVoDEncryption, only ApsaraVideo Player SDK can be used to play videos.
	//
	// example:
	//
	// AliyunVoDEncryption
	EncryptType *string `json:"EncryptType,omitempty" xml:"EncryptType,omitempty"`
	// The format of the media stream.
	//
	// 	- If the media file is a video file, the valid values are **mp4*	- and **m3u8**.
	//
	// 	- If the media asset is an audio-only file, the value is **mp3**.
	//
	// example:
	//
	// m3u8
	Format *string `json:"Format,omitempty" xml:"Format,omitempty"`
	// The frame rate of the media stream. Unit: frames per second.
	//
	// example:
	//
	// 25
	Fps *string `json:"Fps,omitempty" xml:"Fps,omitempty"`
	// The HDR type of the media stream. Valid values:
	//
	// 	- HDR
	//
	// 	- HDR10
	//
	// 	- HLG
	//
	// 	- DolbyVision
	//
	// 	- HDRVivid
	//
	// 	- SDR+
	//
	// example:
	//
	// HLG
	HDRType *string `json:"HDRType,omitempty" xml:"HDRType,omitempty"`
	// The height of the media stream. Unit: pixels.
	//
	// example:
	//
	// 640
	Height *int64 `json:"Height,omitempty" xml:"Height,omitempty"`
	// The custom watermark information of the copyright watermark. This parameter is returned if you set `JobType` to `2`.
	//
	// example:
	//
	// CopyrightMarkTest
	JobExt *string `json:"JobExt,omitempty" xml:"JobExt,omitempty"`
	// The job ID for transcoding the media stream. This ID uniquely identifies a media stream.
	//
	// example:
	//
	// 80e9c6580e754a798c3c19c59b16****
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The type of the digital watermark. Valid values:
	//
	// 	- **1**: user-tracing watermark
	//
	// 	- **2**: copyright watermark
	//
	// example:
	//
	// 2
	JobType *int32 `json:"JobType,omitempty" xml:"JobType,omitempty"`
	// The time when the audio or video file was last updated. The time is in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2022-04-20T06:32:19Z
	ModificationTime *string `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	// The transcoding type. Valid values:
	//
	// 	- **0**: regular transcoding
	//
	// 	- **1.0**: Narrowband HD™ 1.0 transcoding
	//
	// 	- **2.0**: Narrowband HD™ 2.0 transcoding
	//
	// example:
	//
	// 0
	NarrowBandType *string `json:"NarrowBandType,omitempty" xml:"NarrowBandType,omitempty"`
	// The playback URL of the video stream.
	PlayURL *string `json:"PlayURL,omitempty" xml:"PlayURL,omitempty"`
	// The size of the media stream. Unit: bytes.
	//
	// example:
	//
	// 418112
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The specifications of transcoded audio and video streams. For more information about the valid values, see [Output specifications](~~124671#section-6bv-l0g-opq~~).
	//
	// example:
	//
	// H264.LD
	Specification *string `json:"Specification,omitempty" xml:"Specification,omitempty"`
	// The status of the audio or video stream. Valid values:
	//
	// 	- **Normal**: The latest transcoded stream in each quality and format is in the Normal status.
	//
	// 	- **Invisible**: If multiple streams are transcoded in the same quality and format, the latest transcoded stream is in the Normal status and other streams are in the Invisible status.
	//
	// example:
	//
	// Normal
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the media stream. If the media stream is a video stream, the value is **video**. If the media stream is an audio-only stream, the value is **audio**.
	//
	// example:
	//
	// video
	StreamType *string `json:"StreamType,omitempty" xml:"StreamType,omitempty"`
	// The ID of the watermark that is associated with the media stream.
	//
	// example:
	//
	// dgfn26457856****
	WatermarkId *string `json:"WatermarkId,omitempty" xml:"WatermarkId,omitempty"`
	// The width of the media stream. Unit: pixels.
	//
	// example:
	//
	// 360
	Width *int64 `json:"Width,omitempty" xml:"Width,omitempty"`
}

func (s GetPlayInfoResponseBodyPlayInfoListPlayInfo) String() string {
	return tea.Prettify(s)
}

func (s GetPlayInfoResponseBodyPlayInfoListPlayInfo) GoString() string {
	return s.String()
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetBitDepth(v int32) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.BitDepth = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetBitrate(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.Bitrate = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetCodecName(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.CodecName = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetCreationTime(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.CreationTime = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetDefinition(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.Definition = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetDuration(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.Duration = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetEncrypt(v int64) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.Encrypt = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetEncryptMode(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.EncryptMode = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetEncryptType(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.EncryptType = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetFormat(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.Format = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetFps(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.Fps = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetHDRType(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.HDRType = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetHeight(v int64) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.Height = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetJobExt(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.JobExt = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetJobId(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.JobId = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetJobType(v int32) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.JobType = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetModificationTime(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.ModificationTime = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetNarrowBandType(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.NarrowBandType = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetPlayURL(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.PlayURL = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetSize(v int64) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.Size = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetSpecification(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.Specification = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetStatus(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.Status = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetStreamType(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.StreamType = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetWatermarkId(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.WatermarkId = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetWidth(v int64) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.Width = &v
	return s
}

type GetPlayInfoResponseBodyVideoBase struct {
	// The thumbnail URL of the audio or video file.
	//
	// example:
	//
	// http://example.aliyundoc.com/sample.jpg?auth_key=2333232-atb****
	CoverURL *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	// The time when the audio or video file was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-06-26T06:38:48Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The URL of the masked live comment data.
	//
	// example:
	//
	// http://example.aliyundoc.com/****?auth_key=abdf2123-6783232****
	DanMuURL *string `json:"DanMuURL,omitempty" xml:"DanMuURL,omitempty"`
	// The duration of the audio or video file. Unit: seconds.
	//
	// example:
	//
	// 3.1667
	Duration *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The type of the media file. Valid values:
	//
	// 	- **video**
	//
	// 	- **audio**
	//
	// example:
	//
	// video
	MediaType *string `json:"MediaType,omitempty" xml:"MediaType,omitempty"`
	// The status of the media file. For more information about the value range and description, see the [Status](~~52839#title-vqg-8cz-7p8~~) table.
	//
	// example:
	//
	// Normal
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The storage class of the audio file. Valid values:
	//
	// 	- **Standard**: All media resources are stored as Standard objects.
	//
	// 	- **IA**: All media resources are stored as IA objects.
	//
	// 	- **Archive**: All media resources are stored as Archive objects.
	//
	// 	- **ColdArchive**: All media resources are stored as Cold Archive objects.
	//
	// 	- **SourceIA**: Only the source files are IA objects.
	//
	// 	- **SourceArchive**: Only the source files are Archive objects.
	//
	// 	- **SourceColdArchive**: Only the source file is stored as a Cold Archive object.
	//
	// 	- **Changing**: The storage class of the video file is being changed.
	//
	// 	- **SourceChanging**: The storage class of the source file is being changed.
	//
	// example:
	//
	// Standard
	StorageClass *string `json:"StorageClass,omitempty" xml:"StorageClass,omitempty"`
	// The title of the audio or video file.
	//
	// example:
	//
	// ApsaraVideo VOD
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The ID of the media file.
	//
	// example:
	//
	// 93ab850b4f654b6e91d24d81d44****
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s GetPlayInfoResponseBodyVideoBase) String() string {
	return tea.Prettify(s)
}

func (s GetPlayInfoResponseBodyVideoBase) GoString() string {
	return s.String()
}

func (s *GetPlayInfoResponseBodyVideoBase) SetCoverURL(v string) *GetPlayInfoResponseBodyVideoBase {
	s.CoverURL = &v
	return s
}

func (s *GetPlayInfoResponseBodyVideoBase) SetCreationTime(v string) *GetPlayInfoResponseBodyVideoBase {
	s.CreationTime = &v
	return s
}

func (s *GetPlayInfoResponseBodyVideoBase) SetDanMuURL(v string) *GetPlayInfoResponseBodyVideoBase {
	s.DanMuURL = &v
	return s
}

func (s *GetPlayInfoResponseBodyVideoBase) SetDuration(v string) *GetPlayInfoResponseBodyVideoBase {
	s.Duration = &v
	return s
}

func (s *GetPlayInfoResponseBodyVideoBase) SetMediaType(v string) *GetPlayInfoResponseBodyVideoBase {
	s.MediaType = &v
	return s
}

func (s *GetPlayInfoResponseBodyVideoBase) SetStatus(v string) *GetPlayInfoResponseBodyVideoBase {
	s.Status = &v
	return s
}

func (s *GetPlayInfoResponseBodyVideoBase) SetStorageClass(v string) *GetPlayInfoResponseBodyVideoBase {
	s.StorageClass = &v
	return s
}

func (s *GetPlayInfoResponseBodyVideoBase) SetTitle(v string) *GetPlayInfoResponseBodyVideoBase {
	s.Title = &v
	return s
}

func (s *GetPlayInfoResponseBodyVideoBase) SetVideoId(v string) *GetPlayInfoResponseBodyVideoBase {
	s.VideoId = &v
	return s
}

type GetPlayInfoResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetPlayInfoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetPlayInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s GetPlayInfoResponse) GoString() string {
	return s.String()
}

func (s *GetPlayInfoResponse) SetHeaders(v map[string]*string) *GetPlayInfoResponse {
	s.Headers = v
	return s
}

func (s *GetPlayInfoResponse) SetStatusCode(v int32) *GetPlayInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *GetPlayInfoResponse) SetBody(v *GetPlayInfoResponseBody) *GetPlayInfoResponse {
	s.Body = v
	return s
}

type GetTranscodeSummaryRequest struct {
	// The ID of the audio or video file. You can specify up to 10 IDs. Separate the IDs with commas (,). You can use one of the following methods to obtain the ID:
	//
	// 	- After you upload a video in the [ApsaraVideo VOD console](https://vod.console.aliyun.com), you can log on to the ApsaraVideo VOD console and choose **Media Files*	- > **Audio/Video*	- to view the ID of the video.
	//
	// 	- Obtain the value of VideoId from the response to the [CreateUploadVideo](https://help.aliyun.com/document_detail/55407.html) operation that you call to obtain the upload URL and credential.
	//
	// 	- Obtain the value of VideoId by calling the [SearchMedia](https://help.aliyun.com/document_detail/86044.html) operation. This method is applicable to files that have been uploaded.
	//
	// This parameter is required.
	//
	// example:
	//
	// "d4860fcc6ae9fed52e8938244****,e1db68cc586644b83e562bcd94****,hhhhhhh"
	VideoIds *string `json:"VideoIds,omitempty" xml:"VideoIds,omitempty"`
}

func (s GetTranscodeSummaryRequest) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeSummaryRequest) GoString() string {
	return s.String()
}

func (s *GetTranscodeSummaryRequest) SetVideoIds(v string) *GetTranscodeSummaryRequest {
	s.VideoIds = &v
	return s
}

type GetTranscodeSummaryResponseBody struct {
	// The IDs of the audio or video files that do not exist.
	NonExistVideoIds []*string `json:"NonExistVideoIds,omitempty" xml:"NonExistVideoIds,omitempty" type:"Repeated"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A*****F6-D7393642CA58
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The transcoding summary of the file.
	TranscodeSummaryList []*GetTranscodeSummaryResponseBodyTranscodeSummaryList `json:"TranscodeSummaryList,omitempty" xml:"TranscodeSummaryList,omitempty" type:"Repeated"`
}

func (s GetTranscodeSummaryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeSummaryResponseBody) GoString() string {
	return s.String()
}

func (s *GetTranscodeSummaryResponseBody) SetNonExistVideoIds(v []*string) *GetTranscodeSummaryResponseBody {
	s.NonExistVideoIds = v
	return s
}

func (s *GetTranscodeSummaryResponseBody) SetRequestId(v string) *GetTranscodeSummaryResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetTranscodeSummaryResponseBody) SetTranscodeSummaryList(v []*GetTranscodeSummaryResponseBodyTranscodeSummaryList) *GetTranscodeSummaryResponseBody {
	s.TranscodeSummaryList = v
	return s
}

type GetTranscodeSummaryResponseBodyTranscodeSummaryList struct {
	// The time when the transcoding task was complete. The time is in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-01-23T12:40:12Z
	CompleteTime *string `json:"CompleteTime,omitempty" xml:"CompleteTime,omitempty"`
	// The time when the transcoding task was created. The time is in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-01-23T12:35:12Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The summaries of transcoding jobs.
	TranscodeJobInfoSummaryList []*GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList `json:"TranscodeJobInfoSummaryList,omitempty" xml:"TranscodeJobInfoSummaryList,omitempty" type:"Repeated"`
	// The status of the transcoding task. Valid values:
	//
	// 	- **Processing**: Transcoding is in process.
	//
	// 	- **Partial**: Some transcoding jobs were complete.
	//
	// 	- **CompleteAllSucc**: All transcoding jobs were successful.
	//
	// 	- **CompleteAllFail**: All transcoding jobs failed. If an exception occurs in the source file, no transcoding job is initiated and the transcoding task fails.
	//
	// 	- **CompletePartialSucc**: All transcoding jobs were complete but only some were successful.
	//
	// example:
	//
	// Processing
	TranscodeStatus *string `json:"TranscodeStatus,omitempty" xml:"TranscodeStatus,omitempty"`
	// The ID of the transcoding template group.
	//
	// example:
	//
	// 44f9e406bbb*****736a9abe876ecc0
	TranscodeTemplateGroupId *string `json:"TranscodeTemplateGroupId,omitempty" xml:"TranscodeTemplateGroupId,omitempty"`
	// The ID of the audio or video file.
	//
	// example:
	//
	// e1db68cc586644b83e562bcd94****
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s GetTranscodeSummaryResponseBodyTranscodeSummaryList) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeSummaryResponseBodyTranscodeSummaryList) GoString() string {
	return s.String()
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryList) SetCompleteTime(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryList {
	s.CompleteTime = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryList) SetCreationTime(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryList {
	s.CreationTime = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryList) SetTranscodeJobInfoSummaryList(v []*GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) *GetTranscodeSummaryResponseBodyTranscodeSummaryList {
	s.TranscodeJobInfoSummaryList = v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryList) SetTranscodeStatus(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryList {
	s.TranscodeStatus = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryList) SetTranscodeTemplateGroupId(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryList {
	s.TranscodeTemplateGroupId = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryList) SetVideoId(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryList {
	s.VideoId = &v
	return s
}

type GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList struct {
	// The average bitrate of the output video. Unit: Kbit/s.
	//
	// example:
	//
	// 749
	Bitrate *string `json:"Bitrate,omitempty" xml:"Bitrate,omitempty"`
	// The time when the transcoding job was complete. The time is in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-02-27T03:40:51Z
	CompleteTime *string `json:"CompleteTime,omitempty" xml:"CompleteTime,omitempty"`
	// The time when the transcoding job was created. The time is in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-02-27T03:34:46Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The duration of the output video. Unit: seconds.
	//
	// example:
	//
	// 12
	Duration *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The error code returned when the transcoding job failed.
	//
	// example:
	//
	// 200
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned when the transcoding job failed.
	//
	// example:
	//
	// ErrorMessage
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The size of the output video. Unit: bytes.
	//
	// example:
	//
	// 1144259
	Filesize *int64 `json:"Filesize,omitempty" xml:"Filesize,omitempty"`
	// The container format of the output video.
	//
	// example:
	//
	// mp4
	Format *string `json:"Format,omitempty" xml:"Format,omitempty"`
	// The frame rate of the output video. Unit: frames per second.
	//
	// example:
	//
	// 30
	Fps *string `json:"Fps,omitempty" xml:"Fps,omitempty"`
	// The height of the output video. Unit: pixels.
	//
	// example:
	//
	// 960
	Height *string `json:"Height,omitempty" xml:"Height,omitempty"`
	// The status of the transcoding job. Valid values:
	//
	// 	- **Transcoding**: Transcoding is in process.
	//
	// 	- **TranscodeSuccess**: The job was successful.
	//
	// 	- **TranscodeFail**: The job failed.
	//
	// example:
	//
	// Transcoding
	TranscodeJobStatus *string `json:"TranscodeJobStatus,omitempty" xml:"TranscodeJobStatus,omitempty"`
	// The transcoding progress. Valid values: `[0,100]`.
	//
	// example:
	//
	// 100
	TranscodeProgress *int64 `json:"TranscodeProgress,omitempty" xml:"TranscodeProgress,omitempty"`
	// The ID of the transcoding template.
	//
	// example:
	//
	// 57496724ae2*****0968d6e08acc8f6
	TranscodeTemplateId *string `json:"TranscodeTemplateId,omitempty" xml:"TranscodeTemplateId,omitempty"`
	// The IDs of the watermarks that are applied to the output video.
	WatermarkIdList []*string `json:"WatermarkIdList,omitempty" xml:"WatermarkIdList,omitempty" type:"Repeated"`
	// The width of the output video. Unit: pixels.
	//
	// example:
	//
	// 544
	Width *string `json:"Width,omitempty" xml:"Width,omitempty"`
}

func (s GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) GoString() string {
	return s.String()
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) SetBitrate(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList {
	s.Bitrate = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) SetCompleteTime(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList {
	s.CompleteTime = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) SetCreationTime(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList {
	s.CreationTime = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) SetDuration(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList {
	s.Duration = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) SetErrorCode(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList {
	s.ErrorCode = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) SetErrorMessage(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList {
	s.ErrorMessage = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) SetFilesize(v int64) *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList {
	s.Filesize = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) SetFormat(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList {
	s.Format = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) SetFps(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList {
	s.Fps = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) SetHeight(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList {
	s.Height = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) SetTranscodeJobStatus(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList {
	s.TranscodeJobStatus = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) SetTranscodeProgress(v int64) *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList {
	s.TranscodeProgress = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) SetTranscodeTemplateId(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList {
	s.TranscodeTemplateId = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) SetWatermarkIdList(v []*string) *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList {
	s.WatermarkIdList = v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) SetWidth(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList {
	s.Width = &v
	return s
}

type GetTranscodeSummaryResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetTranscodeSummaryResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetTranscodeSummaryResponse) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeSummaryResponse) GoString() string {
	return s.String()
}

func (s *GetTranscodeSummaryResponse) SetHeaders(v map[string]*string) *GetTranscodeSummaryResponse {
	s.Headers = v
	return s
}

func (s *GetTranscodeSummaryResponse) SetStatusCode(v int32) *GetTranscodeSummaryResponse {
	s.StatusCode = &v
	return s
}

func (s *GetTranscodeSummaryResponse) SetBody(v *GetTranscodeSummaryResponseBody) *GetTranscodeSummaryResponse {
	s.Body = v
	return s
}

type GetTranscodeTaskRequest struct {
	// Transcoding job ID. Supports up to 10 IDs, and multiple IDs should be separated by a comma (,). You can obtain this value in the following ways:
	//
	// When initiating a transcoding task through the [SubmitTranscodeJobs](https://help.aliyun.com/document_detail/454920.html) interface, it is the value of the returned parameter JobId.
	//
	// example:
	//
	// 86c1925fba0****,7afb201e7fa****,2cc4997378****
	JobIds *string `json:"JobIds,omitempty" xml:"JobIds,omitempty"`
	// The ID of the transcoding task. You can use one of the following methods to obtain the ID:
	//
	// 	- Obtain the value of TranscodeTaskId from the response to the [SubmitTranscodeJobs](https://help.aliyun.com/document_detail/68570.html) operation.
	//
	// 	- Obtain the value of TranscodeTaskId from the response to the [ListTranscodeTask](https://help.aliyun.com/document_detail/109120.html) operation.
	//
	// example:
	//
	// b1b65ab107e14*****3dbb900f6c1fe0
	TranscodeTaskId *string `json:"TranscodeTaskId,omitempty" xml:"TranscodeTaskId,omitempty"`
}

func (s GetTranscodeTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeTaskRequest) GoString() string {
	return s.String()
}

func (s *GetTranscodeTaskRequest) SetJobIds(v string) *GetTranscodeTaskRequest {
	s.JobIds = &v
	return s
}

func (s *GetTranscodeTaskRequest) SetTranscodeTaskId(v string) *GetTranscodeTaskRequest {
	s.TranscodeTaskId = &v
	return s
}

type GetTranscodeTaskResponseBody struct {
	// The nonexistent job ID.
	NonExistJobIds []*string `json:"NonExistJobIds,omitempty" xml:"NonExistJobIds,omitempty" type:"Repeated"`
	// The ID of the request.
	//
	// example:
	//
	// F4C6D5BE-BF13-45*****6C-516EA8906DCD
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// List of transcode job information.
	TranscodeJobInfoList []*GetTranscodeTaskResponseBodyTranscodeJobInfoList `json:"TranscodeJobInfoList,omitempty" xml:"TranscodeJobInfoList,omitempty" type:"Repeated"`
	// Details about transcoding tasks.
	TranscodeTask *GetTranscodeTaskResponseBodyTranscodeTask `json:"TranscodeTask,omitempty" xml:"TranscodeTask,omitempty" type:"Struct"`
}

func (s GetTranscodeTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeTaskResponseBody) GoString() string {
	return s.String()
}

func (s *GetTranscodeTaskResponseBody) SetNonExistJobIds(v []*string) *GetTranscodeTaskResponseBody {
	s.NonExistJobIds = v
	return s
}

func (s *GetTranscodeTaskResponseBody) SetRequestId(v string) *GetTranscodeTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetTranscodeTaskResponseBody) SetTranscodeJobInfoList(v []*GetTranscodeTaskResponseBodyTranscodeJobInfoList) *GetTranscodeTaskResponseBody {
	s.TranscodeJobInfoList = v
	return s
}

func (s *GetTranscodeTaskResponseBody) SetTranscodeTask(v *GetTranscodeTaskResponseBodyTranscodeTask) *GetTranscodeTaskResponseBody {
	s.TranscodeTask = v
	return s
}

type GetTranscodeTaskResponseBodyTranscodeJobInfoList struct {
	// The complete time of the transcoding job. The format is yyyy-MM-dd\\"T\\"HH:mm:ssZ (UTC time).
	//
	// example:
	//
	// 2019-02-26T08:30:16Z
	CompleteTime *string `json:"CompleteTime,omitempty" xml:"CompleteTime,omitempty"`
	// The creation time of the transcoding job. The format is yyyy-MM-dd\\"T\\"HH:mm:ssZ (UTC time).
	//
	// example:
	//
	// 2019-02-26T08:27:16Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The clarity and audio quality types are defined as follows:
	//
	// - SD: Standard Definition.
	//
	// - HD: High Definition.
	//
	// - FHD: Full High Definition.
	//
	// - OD: Original Definition.
	//
	// - 2K: 2K.
	//
	// - 4K: 4K.
	//
	// - SQ: Standard Audio Quality.
	//
	// - HQ: High Audio Quality.
	//
	// - AUTO: Adaptive Bitrate.  This is only available when the transcoding template is configured with packaging settings. Please refer to [the Transcoding Template Configuration - Package Setting](https://api.aliyun-inc.com/~~52839~~?spm=openapi-amp.newDocPublishment.0.0.65b0281fNUFIXC) for more details.
	//
	// > This value represents the clarity label configured in the transcoding template and does not indicate the actual resolution range of the transcoded output file.
	//
	// example:
	//
	// LD
	Definition *string `json:"Definition,omitempty" xml:"Definition,omitempty"`
	// The error code.
	//
	// example:
	//
	// 200
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	//
	// example:
	//
	// ErrorMessage
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The OSS address of the source file for transcoding.
	//
	// example:
	//
	// http://outin-40564*****e1403e7.oss-cn-shanghai.aliyuncs.com/customerTrans/5b95e568f8e*****47f38e/31f1184c-*****b2a2-f94-c213f.wmv
	InputFileUrl *string `json:"InputFileUrl,omitempty" xml:"InputFileUrl,omitempty"`
	// Information about the transcoded output files.
	OutputFile *GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile `json:"OutputFile,omitempty" xml:"OutputFile,omitempty" type:"Struct"`
	// The priority of the transcoding task.
	//
	// example:
	//
	// 6
	Priority *string `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The ID of the transcode job.
	//
	// example:
	//
	// 38f0e513c88*****85515f9d50be188
	TranscodeJobId *string `json:"TranscodeJobId,omitempty" xml:"TranscodeJobId,omitempty"`
	// The status of the transcoding job:
	//
	// Transcoding: Transcoding in progress.
	//
	// TranscodeSuccess: Transcoding successful.
	//
	// TranscodeFail: Transcoding failed.
	//
	// example:
	//
	// Transcoding
	TranscodeJobStatus *string `json:"TranscodeJobStatus,omitempty" xml:"TranscodeJobStatus,omitempty"`
	// The processing progress of the transcoding job. The value range is [0, 100].
	//
	// example:
	//
	// 80
	TranscodeProgress *int64 `json:"TranscodeProgress,omitempty" xml:"TranscodeProgress,omitempty"`
	// The ID of the template used for the transcode job.
	//
	// example:
	//
	// 174b0534fea3*****b51c8f0ad1374
	TranscodeTemplateId *string `json:"TranscodeTemplateId,omitempty" xml:"TranscodeTemplateId,omitempty"`
}

func (s GetTranscodeTaskResponseBodyTranscodeJobInfoList) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeTaskResponseBodyTranscodeJobInfoList) GoString() string {
	return s.String()
}

func (s *GetTranscodeTaskResponseBodyTranscodeJobInfoList) SetCompleteTime(v string) *GetTranscodeTaskResponseBodyTranscodeJobInfoList {
	s.CompleteTime = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeJobInfoList) SetCreationTime(v string) *GetTranscodeTaskResponseBodyTranscodeJobInfoList {
	s.CreationTime = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeJobInfoList) SetDefinition(v string) *GetTranscodeTaskResponseBodyTranscodeJobInfoList {
	s.Definition = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeJobInfoList) SetErrorCode(v string) *GetTranscodeTaskResponseBodyTranscodeJobInfoList {
	s.ErrorCode = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeJobInfoList) SetErrorMessage(v string) *GetTranscodeTaskResponseBodyTranscodeJobInfoList {
	s.ErrorMessage = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeJobInfoList) SetInputFileUrl(v string) *GetTranscodeTaskResponseBodyTranscodeJobInfoList {
	s.InputFileUrl = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeJobInfoList) SetOutputFile(v *GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile) *GetTranscodeTaskResponseBodyTranscodeJobInfoList {
	s.OutputFile = v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeJobInfoList) SetPriority(v string) *GetTranscodeTaskResponseBodyTranscodeJobInfoList {
	s.Priority = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeJobInfoList) SetTranscodeJobId(v string) *GetTranscodeTaskResponseBodyTranscodeJobInfoList {
	s.TranscodeJobId = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeJobInfoList) SetTranscodeJobStatus(v string) *GetTranscodeTaskResponseBodyTranscodeJobInfoList {
	s.TranscodeJobStatus = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeJobInfoList) SetTranscodeProgress(v int64) *GetTranscodeTaskResponseBodyTranscodeJobInfoList {
	s.TranscodeProgress = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeJobInfoList) SetTranscodeTemplateId(v string) *GetTranscodeTaskResponseBodyTranscodeJobInfoList {
	s.TranscodeTemplateId = &v
	return s
}

type GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile struct {
	// List of audio streams.
	//
	// example:
	//
	// "AudioStreamList": "[{\\"Bitrate\\":\\"64.533\\",\\"ChannelLayout\\":\\"stereo\\",\\"Channels\\":\\"2\\",\\"CodecLongName\\":\\"AAC (Advanced Audio Coding)\\",\\"CodecName\\":\\"aac\\",\\"CodecTag\\":\\"0x6134706d\\",\\"CodecTagString\\":\\"mp4a\\",\\"CodecTimeBase\\":\\"1/44100\\",\\"Duration\\":\\"12.615533\\",\\"Index\\":\\"1\\",\\"Lang\\":\\"und\\",\\"SampleFmt\\":\\"fltp\\",\\"Samplerate\\":\\"44100\\",\\"StartTime\\":\\"-0.046440\\",\\"Timebase\\":\\"1/44100\\"}]
	AudioStreamList *string `json:"AudioStreamList,omitempty" xml:"AudioStreamList,omitempty"`
	// Average bitrate of the transcoded output file. Unit: Kbps.
	//
	// example:
	//
	// 964
	Bitrate *string `json:"Bitrate,omitempty" xml:"Bitrate,omitempty"`
	// Duration of the transcoded output file. Unit: seconds (s).
	//
	// example:
	//
	// 12
	Duration *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// Encryption configuration used for the transcoded output file. Values:
	//
	// - AliyunVoDEncryption: Alibaba Cloud Video Encryption (private encryption).
	//
	// - HLSEncryption: HLS standard encryption.
	//
	// example:
	//
	// {\\"EncryptType\\":\\"AliyunVoDEncryption\\"}
	Encryption *string `json:"Encryption,omitempty" xml:"Encryption,omitempty"`
	// Size of the transcoded output file. Unit: bytes (B).
	//
	// example:
	//
	// 851076
	Filesize *int64 `json:"Filesize,omitempty" xml:"Filesize,omitempty"`
	// Container format of the transcoded output file.
	//
	// example:
	//
	// m3u8
	Format *string `json:"Format,omitempty" xml:"Format,omitempty"`
	// Frame rate of the transcoded output file. Unit: frames per second (fps).
	//
	// example:
	//
	// 25
	Fps *string `json:"Fps,omitempty" xml:"Fps,omitempty"`
	// Height of the video frame in the transcoded output file. Unit: pixels (px).
	//
	// example:
	//
	// 360
	Height *string `json:"Height,omitempty" xml:"Height,omitempty"`
	// OSS address of the transcoded output file.
	//
	// example:
	//
	// http://outin-40564*****e1403e7.oss-cn-shanghai.aliyuncs.com/883f5d*****f20aaa352f/c3be4f073*****7d5193ec8-{DestMd5}-od-S00000001-200000.mp4
	OutputFileUrl *string `json:"OutputFileUrl,omitempty" xml:"OutputFileUrl,omitempty"`
	// List of subtitle streams.
	//
	// example:
	//
	// []
	SubtitleStreamList *string `json:"SubtitleStreamList,omitempty" xml:"SubtitleStreamList,omitempty"`
	// List of video streams.
	//
	// example:
	//
	// [{\\"AvgFPS\\":\\"30.0\\",\\"Bitrate\\":\\"933.814\\",\\"CodecLongName\\":\\"H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10\\",\\"CodecName\\":\\"h264\\",\\"CodecTag\\":\\"0x31637661\\",\\"CodecTagString\\":\\"avc1\\",\\"CodecTimeBase\\":\\"1/60\\",\\"Dar\\":\\"9:16\\",\\"Duration\\":\\"12.033333\\",\\"Fps\\":\\"30.0\\",\\"HasBFrames\\":\\"2\\",\\"Height\\":\\"360\\",\\"Index\\":\\"0\\",\\"Lang\\":\\"und\\",\\"Level\\":\\"30\\",\\"PixFmt\\":\\"yuv420p\\",\\"Profile\\":\\"High\\",\\"Sar\\":\\"81:256\\",\\"StartTime\\":\\"0.000000\\",\\"Timebase\\":\\"1/15360\\",\\"Width\\":\\"640\\"}]
	VideoStreamList *string `json:"VideoStreamList,omitempty" xml:"VideoStreamList,omitempty"`
	// List of watermarks used for transcoding.
	WatermarkIdList []*string `json:"WatermarkIdList,omitempty" xml:"WatermarkIdList,omitempty" type:"Repeated"`
	// Width of the video frame in the transcoded output file. Unit: pixels (px).
	//
	// example:
	//
	// 640
	Width *string `json:"Width,omitempty" xml:"Width,omitempty"`
}

func (s GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile) GoString() string {
	return s.String()
}

func (s *GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile) SetAudioStreamList(v string) *GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile {
	s.AudioStreamList = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile) SetBitrate(v string) *GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile {
	s.Bitrate = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile) SetDuration(v string) *GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile {
	s.Duration = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile) SetEncryption(v string) *GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile {
	s.Encryption = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile) SetFilesize(v int64) *GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile {
	s.Filesize = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile) SetFormat(v string) *GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile {
	s.Format = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile) SetFps(v string) *GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile {
	s.Fps = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile) SetHeight(v string) *GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile {
	s.Height = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile) SetOutputFileUrl(v string) *GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile {
	s.OutputFileUrl = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile) SetSubtitleStreamList(v string) *GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile {
	s.SubtitleStreamList = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile) SetVideoStreamList(v string) *GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile {
	s.VideoStreamList = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile) SetWatermarkIdList(v []*string) *GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile {
	s.WatermarkIdList = v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile) SetWidth(v string) *GetTranscodeTaskResponseBodyTranscodeJobInfoListOutputFile {
	s.Width = &v
	return s
}

type GetTranscodeTaskResponseBodyTranscodeTask struct {
	// The time when the transcoding task was complete. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-01-23T12:40:12Z
	CompleteTime *string `json:"CompleteTime,omitempty" xml:"CompleteTime,omitempty"`
	// The time when the transcoding task was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-01-23T12:35:12Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The status of the transcoding task. Valid values:
	//
	// 	- **Processing**: In progress.
	//
	// 	- **Partial**: Some transcoding jobs were complete.
	//
	// 	- **CompleteAllSucc**: All transcoding jobs were successful.
	//
	// 	- **CompleteAllFail**: All transcoding jobs failed. If an exception occurs in the source file, no transcoding job is initiated and the transcoding task fails.
	//
	// 	- **CompletePartialSucc**: All transcoding jobs were complete but only some were successful.
	//
	// example:
	//
	// Processing
	TaskStatus *string `json:"TaskStatus,omitempty" xml:"TaskStatus,omitempty"`
	// Details about transcoding jobs.
	TranscodeJobInfoList []*GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList `json:"TranscodeJobInfoList,omitempty" xml:"TranscodeJobInfoList,omitempty" type:"Repeated"`
	// The ID of the transcoding task.
	//
	// example:
	//
	// b1b65ab107e14*****3dbb900f6c1fe0
	TranscodeTaskId *string `json:"TranscodeTaskId,omitempty" xml:"TranscodeTaskId,omitempty"`
	// The ID of the transcoding template group.
	//
	// example:
	//
	// b500c7094bd241*****3e9900752d7c3
	TranscodeTemplateGroupId *string `json:"TranscodeTemplateGroupId,omitempty" xml:"TranscodeTemplateGroupId,omitempty"`
	// The mode in which the transcoding task is triggered. Valid values:
	//
	// 	- **Auto**: The transcoding task is automatically triggered when the video is uploaded.
	//
	// 	- **Manual**: The transcoding task is triggered by calling the SubmitTranscodeJobs operation.
	//
	// example:
	//
	// Auto
	Trigger *string `json:"Trigger,omitempty" xml:"Trigger,omitempty"`
	// The ID of the audio or video file.
	//
	// example:
	//
	// 883f5d98107*****b7f20aaa352f
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s GetTranscodeTaskResponseBodyTranscodeTask) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeTaskResponseBodyTranscodeTask) GoString() string {
	return s.String()
}

func (s *GetTranscodeTaskResponseBodyTranscodeTask) SetCompleteTime(v string) *GetTranscodeTaskResponseBodyTranscodeTask {
	s.CompleteTime = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTask) SetCreationTime(v string) *GetTranscodeTaskResponseBodyTranscodeTask {
	s.CreationTime = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTask) SetTaskStatus(v string) *GetTranscodeTaskResponseBodyTranscodeTask {
	s.TaskStatus = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTask) SetTranscodeJobInfoList(v []*GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList) *GetTranscodeTaskResponseBodyTranscodeTask {
	s.TranscodeJobInfoList = v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTask) SetTranscodeTaskId(v string) *GetTranscodeTaskResponseBodyTranscodeTask {
	s.TranscodeTaskId = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTask) SetTranscodeTemplateGroupId(v string) *GetTranscodeTaskResponseBodyTranscodeTask {
	s.TranscodeTemplateGroupId = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTask) SetTrigger(v string) *GetTranscodeTaskResponseBodyTranscodeTask {
	s.Trigger = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTask) SetVideoId(v string) *GetTranscodeTaskResponseBodyTranscodeTask {
	s.VideoId = &v
	return s
}

type GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList struct {
	// The time when the transcoding job was complete. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-02-26T08:30:16Z
	CompleteTime *string `json:"CompleteTime,omitempty" xml:"CompleteTime,omitempty"`
	// The time when the transcoding job was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-02-26T08:27:16Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The video resolution. Valid values:
	//
	// 	- **LD**: low definition
	//
	// 	- **SD**: standard definition
	//
	// 	- **HD**: high definition
	//
	// 	- **FHD**: ultra high definition
	//
	// 	- **OD**: original definition
	//
	// 	- **2K**: 2K
	//
	// 	- **4K**: 4K
	//
	// 	- **SQ**: standard sound quality
	//
	// 	- **HQ**: high sound quality
	//
	// 	- **AUTO**: adaptive bitrate Adaptive bitrate streams are returned only if PackageSetting is set in the transcoding template. For more information, see [Basic structures](https://help.aliyun.com/document_detail/52839.html).
	//
	// > This parameter indicates the definition that is configured in the transcoding template and does not indicate the actual resolution of the output video.
	//
	// example:
	//
	// LD
	Definition *string `json:"Definition,omitempty" xml:"Definition,omitempty"`
	// The error code returned when the transcoding job failed.
	//
	// example:
	//
	// 200
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned when the transcoding job failed.
	//
	// example:
	//
	// ErrorMessage
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The Object Storage Service (OSS) URL of the input file.
	//
	// example:
	//
	// http://outin-40564*****e1403e7.oss-cn-shanghai.aliyuncs.com/customerTrans/5b95e568f8e*****47f38e/31f1184c-*****b2a2-f94-c213f.wmv
	InputFileUrl *string `json:"InputFileUrl,omitempty" xml:"InputFileUrl,omitempty"`
	// The information about the output file.
	OutputFile *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile `json:"OutputFile,omitempty" xml:"OutputFile,omitempty" type:"Struct"`
	// The priority of the transcoding job.
	//
	// example:
	//
	// 6
	Priority *string `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The ID of the transcoding job.
	//
	// example:
	//
	// 38f0e513c88*****85515f9d50be188
	TranscodeJobId *string `json:"TranscodeJobId,omitempty" xml:"TranscodeJobId,omitempty"`
	// The status of the transcoding job.
	//
	// 	- **Transcoding**
	//
	// 	- **TranscodeSuccess**
	//
	// 	- **TranscodeFail**
	//
	// example:
	//
	// Transcoding
	TranscodeJobStatus *string `json:"TranscodeJobStatus,omitempty" xml:"TranscodeJobStatus,omitempty"`
	// The progress of the transcoding job. Valid values: `[0,100]`.
	//
	// example:
	//
	// 100
	TranscodeProgress *int64 `json:"TranscodeProgress,omitempty" xml:"TranscodeProgress,omitempty"`
	// The ID of the transcoding template.
	//
	// example:
	//
	// 174b0534fea3*****b51c8f0ad1374
	TranscodeTemplateId *string `json:"TranscodeTemplateId,omitempty" xml:"TranscodeTemplateId,omitempty"`
}

func (s GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList) GoString() string {
	return s.String()
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList) SetCompleteTime(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList {
	s.CompleteTime = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList) SetCreationTime(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList {
	s.CreationTime = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList) SetDefinition(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList {
	s.Definition = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList) SetErrorCode(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList {
	s.ErrorCode = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList) SetErrorMessage(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList {
	s.ErrorMessage = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList) SetInputFileUrl(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList {
	s.InputFileUrl = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList) SetOutputFile(v *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList {
	s.OutputFile = v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList) SetPriority(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList {
	s.Priority = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList) SetTranscodeJobId(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList {
	s.TranscodeJobId = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList) SetTranscodeJobStatus(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList {
	s.TranscodeJobStatus = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList) SetTranscodeProgress(v int64) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList {
	s.TranscodeProgress = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList) SetTranscodeTemplateId(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList {
	s.TranscodeTemplateId = &v
	return s
}

type GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile struct {
	// The audio streams.
	//
	// example:
	//
	// "AudioStreamList": "[{\\"Bitrate\\":\\"64.533\\",\\"ChannelLayout\\":\\"stereo\\",\\"Channels\\":\\"2\\",\\"CodecLongName\\":\\"AAC (Advanced Audio Coding)\\",\\"CodecName\\":\\"aac\\",\\"CodecTag\\":\\"0x6134706d\\",\\"CodecTagString\\":\\"mp4a\\",\\"CodecTimeBase\\":\\"1/44100\\",\\"Duration\\":\\"12.615533\\",\\"Index\\":\\"1\\",\\"Lang\\":\\"und\\",\\"SampleFmt\\":\\"fltp\\",\\"Samplerate\\":\\"44100\\",\\"StartTime\\":\\"-0.046440\\",\\"Timebase\\":\\"1/44100\\"}]
	AudioStreamList *string `json:"AudioStreamList,omitempty" xml:"AudioStreamList,omitempty"`
	// The average bitrate of the output file. Unit: Kbit/s.
	//
	// example:
	//
	// 964
	Bitrate *string `json:"Bitrate,omitempty" xml:"Bitrate,omitempty"`
	// The length of the output file. Unit: seconds.
	//
	// example:
	//
	// 12
	Duration *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The encryption method of the output file. Valid values:
	//
	// 	- **AliyunVoDEncryption**: Alibaba Cloud proprietary cryptography
	//
	// 	- **HLSEncryption**: HTTP Live Streaming (HLS) encryption
	//
	// example:
	//
	// {\\"EncryptType\\":\\"AliyunVoDEncryption\\"}
	Encryption *string `json:"Encryption,omitempty" xml:"Encryption,omitempty"`
	// The size of the output file. Unit: byte.
	//
	// example:
	//
	// 851076
	Filesize *int64 `json:"Filesize,omitempty" xml:"Filesize,omitempty"`
	// The container format of the output file.
	//
	// example:
	//
	// m3u8
	Format *string `json:"Format,omitempty" xml:"Format,omitempty"`
	// The frame rate of the output file. Unit: frames per second.
	//
	// example:
	//
	// 25
	Fps *string `json:"Fps,omitempty" xml:"Fps,omitempty"`
	// The height of the output video. Unit: pixels.
	//
	// example:
	//
	// 360
	Height *string `json:"Height,omitempty" xml:"Height,omitempty"`
	// The OSS URL of the output file.
	//
	// example:
	//
	// http://outin-40564*****e1403e7.oss-cn-shanghai.aliyuncs.com/883f5d*****f20aaa352f/c3be4f073*****7d5193ec8-{DestMd5}-od-S00000001-200000.mp4
	OutputFileUrl *string `json:"OutputFileUrl,omitempty" xml:"OutputFileUrl,omitempty"`
	// The subtitle streams.
	//
	// example:
	//
	// []
	SubtitleStreamList *string `json:"SubtitleStreamList,omitempty" xml:"SubtitleStreamList,omitempty"`
	// The video streams.
	//
	// example:
	//
	// [{\\"AvgFPS\\":\\"30.0\\",\\"Bitrate\\":\\"933.814\\",\\"CodecLongName\\":\\"H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10\\",\\"CodecName\\":\\"h264\\",\\"CodecTag\\":\\"0x31637661\\",\\"CodecTagString\\":\\"avc1\\",\\"CodecTimeBase\\":\\"1/60\\",\\"Dar\\":\\"9:16\\",\\"Duration\\":\\"12.033333\\",\\"Fps\\":\\"30.0\\",\\"HasBFrames\\":\\"2\\",\\"Height\\":\\"360\\",\\"Index\\":\\"0\\",\\"Lang\\":\\"und\\",\\"Level\\":\\"30\\",\\"PixFmt\\":\\"yuv420p\\",\\"Profile\\":\\"High\\",\\"Sar\\":\\"81:256\\",\\"StartTime\\":\\"0.000000\\",\\"Timebase\\":\\"1/15360\\",\\"Width\\":\\"640\\"}]
	VideoStreamList *string `json:"VideoStreamList,omitempty" xml:"VideoStreamList,omitempty"`
	// The IDs of the watermarks used by the output file.
	WatermarkIdList []*string `json:"WatermarkIdList,omitempty" xml:"WatermarkIdList,omitempty" type:"Repeated"`
	// The width of the output video. Unit: pixels.
	//
	// example:
	//
	// 640
	Width *string `json:"Width,omitempty" xml:"Width,omitempty"`
}

func (s GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) GoString() string {
	return s.String()
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) SetAudioStreamList(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile {
	s.AudioStreamList = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) SetBitrate(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile {
	s.Bitrate = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) SetDuration(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile {
	s.Duration = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) SetEncryption(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile {
	s.Encryption = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) SetFilesize(v int64) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile {
	s.Filesize = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) SetFormat(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile {
	s.Format = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) SetFps(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile {
	s.Fps = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) SetHeight(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile {
	s.Height = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) SetOutputFileUrl(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile {
	s.OutputFileUrl = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) SetSubtitleStreamList(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile {
	s.SubtitleStreamList = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) SetVideoStreamList(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile {
	s.VideoStreamList = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) SetWatermarkIdList(v []*string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile {
	s.WatermarkIdList = v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) SetWidth(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile {
	s.Width = &v
	return s
}

type GetTranscodeTaskResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetTranscodeTaskResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetTranscodeTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeTaskResponse) GoString() string {
	return s.String()
}

func (s *GetTranscodeTaskResponse) SetHeaders(v map[string]*string) *GetTranscodeTaskResponse {
	s.Headers = v
	return s
}

func (s *GetTranscodeTaskResponse) SetStatusCode(v int32) *GetTranscodeTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *GetTranscodeTaskResponse) SetBody(v *GetTranscodeTaskResponseBody) *GetTranscodeTaskResponse {
	s.Body = v
	return s
}

type GetTranscodeTemplateGroupRequest struct {
	// The ID of the transcoding template group.
	//
	// This parameter is required.
	//
	// example:
	//
	// a591f697c7167*****6ae1502142d0
	TranscodeTemplateGroupId *string `json:"TranscodeTemplateGroupId,omitempty" xml:"TranscodeTemplateGroupId,omitempty"`
}

func (s GetTranscodeTemplateGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeTemplateGroupRequest) GoString() string {
	return s.String()
}

func (s *GetTranscodeTemplateGroupRequest) SetTranscodeTemplateGroupId(v string) *GetTranscodeTemplateGroupRequest {
	s.TranscodeTemplateGroupId = &v
	return s
}

type GetTranscodeTemplateGroupResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 6730AC93-7B12-4B*****7F-49EE1FE8BC49
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the transcoding template group.
	TranscodeTemplateGroup *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup `json:"TranscodeTemplateGroup,omitempty" xml:"TranscodeTemplateGroup,omitempty" type:"Struct"`
}

func (s GetTranscodeTemplateGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeTemplateGroupResponseBody) GoString() string {
	return s.String()
}

func (s *GetTranscodeTemplateGroupResponseBody) SetRequestId(v string) *GetTranscodeTemplateGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBody) SetTranscodeTemplateGroup(v *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup) *GetTranscodeTemplateGroupResponseBody {
	s.TranscodeTemplateGroup = v
	return s
}

type GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup struct {
	// The ID of the application.
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The time when the transcoding template group was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*hh:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2018-12-12T10:20:51Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// Indicates whether the template group is the default one. Valid values:
	//
	// 	- **Default**
	//
	// 	- **NotDefault**
	//
	// example:
	//
	// NotDefault
	IsDefault *string `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	// Indicates whether the transcoding template group is locked. Valid values:
	//
	// 	- **Disabled**: The template group is not locked.
	//
	// 	- **Enabled**: The template group is locked.
	//
	// example:
	//
	// Enabled
	Locked *string `json:"Locked,omitempty" xml:"Locked,omitempty"`
	// The time when the transcoding template group was last modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*hh:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2018-12-12T11:20:51Z
	ModifyTime *string `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	// The name of the transcoding template group.
	//
	// example:
	//
	// test
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the transcoding template group.
	//
	// example:
	//
	// a59b11f697c716*****6ae1502142d0
	TranscodeTemplateGroupId *string `json:"TranscodeTemplateGroupId,omitempty" xml:"TranscodeTemplateGroupId,omitempty"`
	// The information about the transcoding templates.
	TranscodeTemplateList []*GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList `json:"TranscodeTemplateList,omitempty" xml:"TranscodeTemplateList,omitempty" type:"Repeated"`
}

func (s GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup) GoString() string {
	return s.String()
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup) SetAppId(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup {
	s.AppId = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup) SetCreationTime(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup {
	s.CreationTime = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup) SetIsDefault(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup {
	s.IsDefault = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup) SetLocked(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup {
	s.Locked = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup) SetModifyTime(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup {
	s.ModifyTime = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup) SetName(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup {
	s.Name = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup) SetTranscodeTemplateGroupId(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup {
	s.TranscodeTemplateGroupId = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup) SetTranscodeTemplateList(v []*GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup {
	s.TranscodeTemplateList = v
	return s
}

type GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList struct {
	// The transcoding configurations of the audio stream. The value is a JSON string.
	//
	// example:
	//
	// {\\"Codec\\":\\"AAC\\",\\"Remove\\":\\"false\\",\\"Bitrate\\":\\"44\\",\\"Samplerate\\":\\"32000\\",\\"Channels\\":\\"2\\",\\"Profile\\":\\"aac_low\\"}
	Audio *string `json:"Audio,omitempty" xml:"Audio,omitempty"`
	// The clipping configurations of the video. The value is a JSON string. For example, this parameter is returned if you extract 5 seconds of content from a video to generate a new video.
	//
	// example:
	//
	// {\\"TimeSpan\\":{\\"Seek\\":\\"1\\",\\"Duration\\":\\"5\\"}
	Clip *string `json:"Clip,omitempty" xml:"Clip,omitempty"`
	// The format of the container used to encapsulate audio and video streams. The value is a JSON string.
	//
	// example:
	//
	// "Format":"m3u8"
	Container *string `json:"Container,omitempty" xml:"Container,omitempty"`
	// The content of the copyright watermark.
	//
	// example:
	//
	// {
	//
	// 	"Content": "test"
	//
	// }
	CopyrightMark *string `json:"CopyrightMark,omitempty" xml:"CopyrightMark,omitempty"`
	// Valid values for the definition of a common transcoding template:
	//
	// 	- **LD**: low definition.
	//
	// 	- **SD**: standard definition.
	//
	// 	- **HD**: high definition.
	//
	// 	- **FHD**: ultra high definition.
	//
	// 	- **OD**: original quality.
	//
	// 	- **2K**
	//
	// 	- **4K**
	//
	// 	- **SQ**: standard sound quality.
	//
	// 	- **HQ**: high sound quality.
	//
	// Valid values for the definition of a Narrowband HD™ 1.0 transcoding template:
	//
	// 	- **LD-NBV1**: low definition.
	//
	// 	- **SD-NBV1**: standard definition.
	//
	// 	- **HD-NBV1**: high definition.
	//
	// 	- **FHD-NBV1**: ultra high definition.
	//
	// 	- **2K-NBV1**
	//
	// 	- **4K-NBV1**
	//
	// > 	- You cannot change the definition of a transcoding template.
	//
	// >	- You cannot modify the system parameters, such as the video resolution, audio resolution, and bitrate, of Narrowband HD™ 1.0 transcoding templates.
	//
	// >	- You can create only Narrowband HD™ 1.0 transcoding templates that support the FLV, M3U8 (HLS), and MP4 output formats.
	//
	// example:
	//
	// SD
	Definition *string `json:"Definition,omitempty" xml:"Definition,omitempty"`
	// The encryption configuration for transcoding.
	//
	// example:
	//
	// "EncryptType":"Private"
	EncryptSetting *string `json:"EncryptSetting,omitempty" xml:"EncryptSetting,omitempty"`
	// The transcoding segment configurations. This parameter must be returned if HTTP-Live-Streaming (HLS) encryption is used. The value is a JSON string.
	//
	// example:
	//
	// "Segment": { "Duration":"6" }
	MuxConfig *string `json:"MuxConfig,omitempty" xml:"MuxConfig,omitempty"`
	// The packaging configuration. Only HLS packaging and DASH packaging are supported. The value is a JSON string.
	//
	// example:
	//
	// "PackageType":"HLSPackage","PackageConfig":{   "BandWidth":"900000"  }
	PackageSetting *string `json:"PackageSetting,omitempty" xml:"PackageSetting,omitempty"`
	// The video rotation identifier. It is used to control the image rotation angle. For example, if you set this parameter to 180, the video image is turned upside down. Valid values: `[0,360]`.
	//
	// example:
	//
	// 90
	Rotate *string `json:"Rotate,omitempty" xml:"Rotate,omitempty"`
	// The subtitle configurations. The value is a JSON string.
	//
	// example:
	//
	// [{"SubtitleUrl":"http://outin-test.oss-cn-shanghai.aliyuncs.com/subtitles/c737fece-14f1-4364-b107-d5f7f8edde0e.ass","CharEncode":"utf-8"}]
	SubtitleList *string `json:"SubtitleList,omitempty" xml:"SubtitleList,omitempty"`
	// The name of the transcoding template.
	//
	// example:
	//
	// test
	TemplateName *string `json:"TemplateName,omitempty" xml:"TemplateName,omitempty"`
	// The content of the tracing watermark.
	//
	// example:
	//
	// {
	//
	// 	"Enable": true
	//
	// }
	TraceMark *string `json:"TraceMark,omitempty" xml:"TraceMark,omitempty"`
	// The conditional transcoding configurations. This parameter can be used if you want to determine the basic logic based on the bitrate and resolution of the source file before the video is transcoded. The value is a JSON-formatted string.
	//
	// example:
	//
	// {"IsCheckReso":"true","IsCheckResoFail":"false","IsCheckVideoBitrate":"false","IsCheckVideoBitrateFail":"false","IsCheckAudioBitrate":"false","IsCheckAudioBitrateFail":"false"}
	TransConfig *string `json:"TransConfig,omitempty" xml:"TransConfig,omitempty"`
	// The custom path used to store the output files.
	//
	// example:
	//
	// {MediaId}/transcoce_1
	TranscodeFileRegular *string `json:"TranscodeFileRegular,omitempty" xml:"TranscodeFileRegular,omitempty"`
	// The transcoding template ID.
	//
	// example:
	//
	// 696d29a11erc057*****a3acc398d02f4
	TranscodeTemplateId *string `json:"TranscodeTemplateId,omitempty" xml:"TranscodeTemplateId,omitempty"`
	// The type of the transcoding template. Valid values:
	//
	// 	- **Normal*	- (default): a common transcoding template. The PackageSetting parameter cannot be set for this type of template.
	//
	// 	- **VideoPackage**: a video stream package template. If this type of template is used, ApsaraVideo VOD transcodes a video into video streams in different bitrates and packages these video streams with a file. The PackageSetting parameter must be set for this type of template.
	//
	// 	- **SubtitlePackage**: a subtitle package template. If this type of template is used, ApsaraVideo VOD adds the subtitle information to the output file generated by packaging the multi-bitrate video streams of the corresponding video without transcoding. You must set the PackageSetting parameter for a subtitle package template and associate the subtitle package template with a video stream package template. A template group can contain only one subtitle package template.
	//
	// example:
	//
	// Normal
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The transcoding configurations of the video stream. The value is a JSON string.
	//
	// example:
	//
	// {"Codec":"H.264","Bitrate":"900","Width":"960","Remove":"false","Fps":"30"}
	Video *string `json:"Video,omitempty" xml:"Video,omitempty"`
	// The IDs of the associated watermarks.
	WatermarkIds []*string `json:"WatermarkIds,omitempty" xml:"WatermarkIds,omitempty" type:"Repeated"`
}

func (s GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) GoString() string {
	return s.String()
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetAudio(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.Audio = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetClip(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.Clip = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetContainer(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.Container = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetCopyrightMark(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.CopyrightMark = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetDefinition(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.Definition = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetEncryptSetting(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.EncryptSetting = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetMuxConfig(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.MuxConfig = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetPackageSetting(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.PackageSetting = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetRotate(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.Rotate = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetSubtitleList(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.SubtitleList = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetTemplateName(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.TemplateName = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetTraceMark(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.TraceMark = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetTransConfig(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.TransConfig = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetTranscodeFileRegular(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.TranscodeFileRegular = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetTranscodeTemplateId(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.TranscodeTemplateId = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetType(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.Type = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetVideo(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.Video = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetWatermarkIds(v []*string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.WatermarkIds = v
	return s
}

type GetTranscodeTemplateGroupResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetTranscodeTemplateGroupResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetTranscodeTemplateGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeTemplateGroupResponse) GoString() string {
	return s.String()
}

func (s *GetTranscodeTemplateGroupResponse) SetHeaders(v map[string]*string) *GetTranscodeTemplateGroupResponse {
	s.Headers = v
	return s
}

func (s *GetTranscodeTemplateGroupResponse) SetStatusCode(v int32) *GetTranscodeTemplateGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponse) SetBody(v *GetTranscodeTemplateGroupResponseBody) *GetTranscodeTemplateGroupResponse {
	s.Body = v
	return s
}

type GetURLUploadInfosRequest struct {
	// The one or more IDs of upload jobs. You can obtain the job IDs in the response parameter JobId of the [UploadMediaByURL](https://help.aliyun.com/document_detail/86311.html) operation.
	//
	// - You can specify a maximum of 10 IDs.
	//
	// - Separate multiple IDs with commas (,).
	//
	// > You must set one of the JobIds and the UploadURLs parameters. If you set both the JobIds and UploadURLs parameters, only the value of the JobIds parameter takes effect.
	//
	// example:
	//
	// 86c1925fba0****,7afb201e7fa****,2cc4997378****
	JobIds *string `json:"JobIds,omitempty" xml:"JobIds,omitempty"`
	// The one or more upload URLs of the source files. Separate multiple URLs with commas (,). You can specify a maximum of 10 URLs.
	//
	// > 	- You must encode the URLs before you use the URLs.
	//
	// > 	- If a media file is uploaded multiple times, pass the URL of the media file to this parameter only once.
	//
	// > 	- You must set one of the JobIds and the UploadURLs parameters. If you set both the JobIds and UploadURLs parameters, only the value of the JobIds parameter takes effect.
	//
	// example:
	//
	// http://****.mp4
	UploadURLs *string `json:"UploadURLs,omitempty" xml:"UploadURLs,omitempty"`
}

func (s GetURLUploadInfosRequest) String() string {
	return tea.Prettify(s)
}

func (s GetURLUploadInfosRequest) GoString() string {
	return s.String()
}

func (s *GetURLUploadInfosRequest) SetJobIds(v string) *GetURLUploadInfosRequest {
	s.JobIds = &v
	return s
}

func (s *GetURLUploadInfosRequest) SetUploadURLs(v string) *GetURLUploadInfosRequest {
	s.UploadURLs = &v
	return s
}

type GetURLUploadInfosResponseBody struct {
	// The job IDs or upload URLs that do not exist.
	NonExists []*string `json:"NonExists,omitempty" xml:"NonExists,omitempty" type:"Repeated"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4AF6-D7393642CA58****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about URL-based upload jobs. For more information, see the "URLUploadInfo: the information about a URL-based upload job" section of the [Basic structures](https://help.aliyun.com/document_detail/52839.html) topic.
	URLUploadInfoList []*GetURLUploadInfosResponseBodyURLUploadInfoList `json:"URLUploadInfoList,omitempty" xml:"URLUploadInfoList,omitempty" type:"Repeated"`
}

func (s GetURLUploadInfosResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetURLUploadInfosResponseBody) GoString() string {
	return s.String()
}

func (s *GetURLUploadInfosResponseBody) SetNonExists(v []*string) *GetURLUploadInfosResponseBody {
	s.NonExists = v
	return s
}

func (s *GetURLUploadInfosResponseBody) SetRequestId(v string) *GetURLUploadInfosResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetURLUploadInfosResponseBody) SetURLUploadInfoList(v []*GetURLUploadInfosResponseBodyURLUploadInfoList) *GetURLUploadInfosResponseBody {
	s.URLUploadInfoList = v
	return s
}

type GetURLUploadInfosResponseBodyURLUploadInfoList struct {
	// The time when the upload job was complete. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-01-01T01:11:01Z
	CompleteTime *string `json:"CompleteTime,omitempty" xml:"CompleteTime,omitempty"`
	// The time when the upload job was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-01-01T01:01:01Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The error code returned.
	//
	// example:
	//
	// 200
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	//
	// example:
	//
	// error_message
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The size of the uploaded media file. Unit: byte.
	//
	// example:
	//
	// 24
	FileSize *string `json:"FileSize,omitempty" xml:"FileSize,omitempty"`
	// The ID of the upload job.
	//
	// example:
	//
	// 86c1925fba0****
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The ID of the uploaded media file.
	//
	// example:
	//
	// 93ab850b4f6f54b6e91d24d81d4****
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The status of the URL-based upload job. For more information about the valid values and value description of the parameter, see the "Status: the status of a video" section of the [Basic structures](https://help.aliyun.com/document_detail/52839.html) topic.
	//
	// example:
	//
	// SUCCESS
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The upload URL of the source file.
	//
	// > A maximum of 100 URLs can be returned.
	//
	// example:
	//
	// http://****.mp4
	UploadURL *string `json:"UploadURL,omitempty" xml:"UploadURL,omitempty"`
	// The custom configurations. The value is a JSON string. For more information, see the "UserData: specifies the custom configurations for media upload" section of the [Request parameters](https://help.aliyun.com/document_detail/86952.html) topic.
	//
	// example:
	//
	// {"MessageCallback":"{"CallbackURL":"http://example.aliyundoc.com"}", "Extend":"{"localId":"***", "test":"www"}"}
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
}

func (s GetURLUploadInfosResponseBodyURLUploadInfoList) String() string {
	return tea.Prettify(s)
}

func (s GetURLUploadInfosResponseBodyURLUploadInfoList) GoString() string {
	return s.String()
}

func (s *GetURLUploadInfosResponseBodyURLUploadInfoList) SetCompleteTime(v string) *GetURLUploadInfosResponseBodyURLUploadInfoList {
	s.CompleteTime = &v
	return s
}

func (s *GetURLUploadInfosResponseBodyURLUploadInfoList) SetCreationTime(v string) *GetURLUploadInfosResponseBodyURLUploadInfoList {
	s.CreationTime = &v
	return s
}

func (s *GetURLUploadInfosResponseBodyURLUploadInfoList) SetErrorCode(v string) *GetURLUploadInfosResponseBodyURLUploadInfoList {
	s.ErrorCode = &v
	return s
}

func (s *GetURLUploadInfosResponseBodyURLUploadInfoList) SetErrorMessage(v string) *GetURLUploadInfosResponseBodyURLUploadInfoList {
	s.ErrorMessage = &v
	return s
}

func (s *GetURLUploadInfosResponseBodyURLUploadInfoList) SetFileSize(v string) *GetURLUploadInfosResponseBodyURLUploadInfoList {
	s.FileSize = &v
	return s
}

func (s *GetURLUploadInfosResponseBodyURLUploadInfoList) SetJobId(v string) *GetURLUploadInfosResponseBodyURLUploadInfoList {
	s.JobId = &v
	return s
}

func (s *GetURLUploadInfosResponseBodyURLUploadInfoList) SetMediaId(v string) *GetURLUploadInfosResponseBodyURLUploadInfoList {
	s.MediaId = &v
	return s
}

func (s *GetURLUploadInfosResponseBodyURLUploadInfoList) SetStatus(v string) *GetURLUploadInfosResponseBodyURLUploadInfoList {
	s.Status = &v
	return s
}

func (s *GetURLUploadInfosResponseBodyURLUploadInfoList) SetUploadURL(v string) *GetURLUploadInfosResponseBodyURLUploadInfoList {
	s.UploadURL = &v
	return s
}

func (s *GetURLUploadInfosResponseBodyURLUploadInfoList) SetUserData(v string) *GetURLUploadInfosResponseBodyURLUploadInfoList {
	s.UserData = &v
	return s
}

type GetURLUploadInfosResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetURLUploadInfosResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetURLUploadInfosResponse) String() string {
	return tea.Prettify(s)
}

func (s GetURLUploadInfosResponse) GoString() string {
	return s.String()
}

func (s *GetURLUploadInfosResponse) SetHeaders(v map[string]*string) *GetURLUploadInfosResponse {
	s.Headers = v
	return s
}

func (s *GetURLUploadInfosResponse) SetStatusCode(v int32) *GetURLUploadInfosResponse {
	s.StatusCode = &v
	return s
}

func (s *GetURLUploadInfosResponse) SetBody(v *GetURLUploadInfosResponseBody) *GetURLUploadInfosResponse {
	s.Body = v
	return s
}

type GetUploadDetailsRequest struct {
	// The ID of the media file, namely, the audio or video ID. You can specify a maximum of 20 IDs. Separate multiple IDs with commas (,). You can use one of the following methods to obtain the audio or video ID:
	//
	// 	- Log on to the [ApsaraVideo VOD](https://vod.console.aliyun.com) console. In the left-side navigation pane, choose **Media Files*	- > **Audio/Video**. On the Video and Audio page, you can view the audio or video ID. Use this method if the audio or video file is uploaded by using the ApsaraVideo VOD console.
	//
	// 	- View the value of the VideoId parameter returned by the [CreateUploadVideo](https://help.aliyun.com/document_detail/55407.html) operation that you called to obtain an upload URL and credential.
	//
	// 	- View the value of the VideoId parameter returned by the [SearchMedia](https://help.aliyun.com/document_detail/86044.html) operation that you called to query media information after the audio or video file is uploaded.
	//
	// This parameter is required.
	//
	// example:
	//
	// 61ccbdb06fa83012be4d8083f6****,7d2fbc380b0e08e55f****
	MediaIds *string `json:"MediaIds,omitempty" xml:"MediaIds,omitempty"`
	// The type of the media file. Set the value to **video**, which indicates audio and video files.
	//
	// example:
	//
	// video
	MediaType *string `json:"MediaType,omitempty" xml:"MediaType,omitempty"`
}

func (s GetUploadDetailsRequest) String() string {
	return tea.Prettify(s)
}

func (s GetUploadDetailsRequest) GoString() string {
	return s.String()
}

func (s *GetUploadDetailsRequest) SetMediaIds(v string) *GetUploadDetailsRequest {
	s.MediaIds = &v
	return s
}

func (s *GetUploadDetailsRequest) SetMediaType(v string) *GetUploadDetailsRequest {
	s.MediaType = &v
	return s
}

type GetUploadDetailsResponseBody struct {
	// The IDs of the media files that cannot be accessed.
	ForbiddenMediaIds []*string `json:"ForbiddenMediaIds,omitempty" xml:"ForbiddenMediaIds,omitempty" type:"Repeated"`
	// The IDs of the media files that do not exist.
	NonExistMediaIds []*string `json:"NonExistMediaIds,omitempty" xml:"NonExistMediaIds,omitempty" type:"Repeated"`
	// The ID of the request.
	//
	// example:
	//
	// 9E290613-04F4-47F4-795D30732077****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The upload details.
	UploadDetails []*GetUploadDetailsResponseBodyUploadDetails `json:"UploadDetails,omitempty" xml:"UploadDetails,omitempty" type:"Repeated"`
}

func (s GetUploadDetailsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetUploadDetailsResponseBody) GoString() string {
	return s.String()
}

func (s *GetUploadDetailsResponseBody) SetForbiddenMediaIds(v []*string) *GetUploadDetailsResponseBody {
	s.ForbiddenMediaIds = v
	return s
}

func (s *GetUploadDetailsResponseBody) SetNonExistMediaIds(v []*string) *GetUploadDetailsResponseBody {
	s.NonExistMediaIds = v
	return s
}

func (s *GetUploadDetailsResponseBody) SetRequestId(v string) *GetUploadDetailsResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetUploadDetailsResponseBody) SetUploadDetails(v []*GetUploadDetailsResponseBodyUploadDetails) *GetUploadDetailsResponseBody {
	s.UploadDetails = v
	return s
}

type GetUploadDetailsResponseBodyUploadDetails struct {
	// The time when the upload job was complete. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-04-28T09:45:07Z
	CompletionTime *string `json:"CompletionTime,omitempty" xml:"CompletionTime,omitempty"`
	// The time when the upload job was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-04-28T09:42:07Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The device model.
	//
	// example:
	//
	// Chrome
	DeviceModel *string `json:"DeviceModel,omitempty" xml:"DeviceModel,omitempty"`
	// The size of the uploaded file. Unit: byte.
	//
	// example:
	//
	// 46
	FileSize *int64 `json:"FileSize,omitempty" xml:"FileSize,omitempty"`
	// The ID of the uploaded audio or video.
	//
	// example:
	//
	// 61ccbdb06fa83012be4d8083f6****
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The time when the information about the media file was updated. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-04-28T09:43:12Z
	ModificationTime *string `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	// The status of the video. For more information about the valid values and value description of the parameter, see the "Status: the status of a video" section of the [Basic structures](https://help.aliyun.com/document_detail/52839.html) topic.
	//
	// example:
	//
	// Uploading
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The title of the media file.
	//
	// example:
	//
	// Test details
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The IP address of the server that uploads the media file.
	//
	// example:
	//
	// 192.168.0.1
	UploadIP *string `json:"UploadIP,omitempty" xml:"UploadIP,omitempty"`
	// The upload ratio.
	//
	// example:
	//
	// 0.038
	UploadRatio *float32 `json:"UploadRatio,omitempty" xml:"UploadRatio,omitempty"`
	// The upload size. Unit: byte.
	//
	// example:
	//
	// 346
	UploadSize *int64 `json:"UploadSize,omitempty" xml:"UploadSize,omitempty"`
	// The method that is used to upload the media file.
	//
	// example:
	//
	// WebSDK
	UploadSource *string `json:"UploadSource,omitempty" xml:"UploadSource,omitempty"`
	// The status of the upload job. For more information about the valid values and value description of the parameter, see the "Status: the status of a URL-based upload job" section of the [Basic structures](https://help.aliyun.com/document_detail/52839.html) topic.
	//
	// example:
	//
	// Uploading
	UploadStatus *string `json:"UploadStatus,omitempty" xml:"UploadStatus,omitempty"`
}

func (s GetUploadDetailsResponseBodyUploadDetails) String() string {
	return tea.Prettify(s)
}

func (s GetUploadDetailsResponseBodyUploadDetails) GoString() string {
	return s.String()
}

func (s *GetUploadDetailsResponseBodyUploadDetails) SetCompletionTime(v string) *GetUploadDetailsResponseBodyUploadDetails {
	s.CompletionTime = &v
	return s
}

func (s *GetUploadDetailsResponseBodyUploadDetails) SetCreationTime(v string) *GetUploadDetailsResponseBodyUploadDetails {
	s.CreationTime = &v
	return s
}

func (s *GetUploadDetailsResponseBodyUploadDetails) SetDeviceModel(v string) *GetUploadDetailsResponseBodyUploadDetails {
	s.DeviceModel = &v
	return s
}

func (s *GetUploadDetailsResponseBodyUploadDetails) SetFileSize(v int64) *GetUploadDetailsResponseBodyUploadDetails {
	s.FileSize = &v
	return s
}

func (s *GetUploadDetailsResponseBodyUploadDetails) SetMediaId(v string) *GetUploadDetailsResponseBodyUploadDetails {
	s.MediaId = &v
	return s
}

func (s *GetUploadDetailsResponseBodyUploadDetails) SetModificationTime(v string) *GetUploadDetailsResponseBodyUploadDetails {
	s.ModificationTime = &v
	return s
}

func (s *GetUploadDetailsResponseBodyUploadDetails) SetStatus(v string) *GetUploadDetailsResponseBodyUploadDetails {
	s.Status = &v
	return s
}

func (s *GetUploadDetailsResponseBodyUploadDetails) SetTitle(v string) *GetUploadDetailsResponseBodyUploadDetails {
	s.Title = &v
	return s
}

func (s *GetUploadDetailsResponseBodyUploadDetails) SetUploadIP(v string) *GetUploadDetailsResponseBodyUploadDetails {
	s.UploadIP = &v
	return s
}

func (s *GetUploadDetailsResponseBodyUploadDetails) SetUploadRatio(v float32) *GetUploadDetailsResponseBodyUploadDetails {
	s.UploadRatio = &v
	return s
}

func (s *GetUploadDetailsResponseBodyUploadDetails) SetUploadSize(v int64) *GetUploadDetailsResponseBodyUploadDetails {
	s.UploadSize = &v
	return s
}

func (s *GetUploadDetailsResponseBodyUploadDetails) SetUploadSource(v string) *GetUploadDetailsResponseBodyUploadDetails {
	s.UploadSource = &v
	return s
}

func (s *GetUploadDetailsResponseBodyUploadDetails) SetUploadStatus(v string) *GetUploadDetailsResponseBodyUploadDetails {
	s.UploadStatus = &v
	return s
}

type GetUploadDetailsResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetUploadDetailsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetUploadDetailsResponse) String() string {
	return tea.Prettify(s)
}

func (s GetUploadDetailsResponse) GoString() string {
	return s.String()
}

func (s *GetUploadDetailsResponse) SetHeaders(v map[string]*string) *GetUploadDetailsResponse {
	s.Headers = v
	return s
}

func (s *GetUploadDetailsResponse) SetStatusCode(v int32) *GetUploadDetailsResponse {
	s.StatusCode = &v
	return s
}

func (s *GetUploadDetailsResponse) SetBody(v *GetUploadDetailsResponseBody) *GetUploadDetailsResponse {
	s.Body = v
	return s
}

type GetVideoInfoRequest struct {
	// The ID of the audio or video file. You can specify only one ID in each call. You can use one of the following methods to obtain the ID:
	//
	// 	- Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Media Files*	- > **Audio/Video**. On the Video and Audio page, view the ID of the audio or video file. This method is applicable to files that are uploaded by using the ApsaraVideo VOD console.
	//
	// 	- Obtain the value of VideoId from the response to the [CreateUploadVideo](https://help.aliyun.com/document_detail/55407.html) operation that you called to obtain the upload URL and credential.
	//
	// 	- Obtain the value of VideoId from the response to the [SearchMedia](https://help.aliyun.com/document_detail/86044.html) operation that you called to query the media ID after the media file is uploaded.
	//
	// This parameter is required.
	//
	// example:
	//
	// 9b73864d75f1d231e9001cd5f8****
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s GetVideoInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s GetVideoInfoRequest) GoString() string {
	return s.String()
}

func (s *GetVideoInfoRequest) SetVideoId(v string) *GetVideoInfoRequest {
	s.VideoId = &v
	return s
}

type GetVideoInfoResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4AF6-D7393642CA58****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the audio or video file.
	Video *GetVideoInfoResponseBodyVideo `json:"Video,omitempty" xml:"Video,omitempty" type:"Struct"`
}

func (s GetVideoInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetVideoInfoResponseBody) GoString() string {
	return s.String()
}

func (s *GetVideoInfoResponseBody) SetRequestId(v string) *GetVideoInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetVideoInfoResponseBody) SetVideo(v *GetVideoInfoResponseBodyVideo) *GetVideoInfoResponseBody {
	s.Video = v
	return s
}

type GetVideoInfoResponseBodyVideo struct {
	// The ID of the application.
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The final review result of the audio or video file. Valid values:
	//
	// 	- **Normal**: pass
	//
	// 	- **Blocked**: blocked
	//
	// example:
	//
	// Normal
	AuditStatus *string `json:"AuditStatus,omitempty" xml:"AuditStatus,omitempty"`
	// The category ID of the media file.
	//
	// example:
	//
	// 781111****
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The name of the category.
	//
	// example:
	//
	// Category name
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	// The thumbnail URL of the media file.
	//
	// example:
	//
	// https://example.aliyundoc.com/****.jpg
	CoverURL *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	// The time when the media file was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-11-14T09:15:50Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The custom information about the media file.\\n\\n> This parameter has been deprecated. This parameter is no longer returned after you call the operation.
	//
	// example:
	//
	// {"aaa":"test"}
	CustomMediaInfo *string `json:"CustomMediaInfo,omitempty" xml:"CustomMediaInfo,omitempty"`
	// The description of the media file.
	//
	// example:
	//
	// Video description in ApsaraVideo VOD
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether the offline download feature is enabled. If you enable the offline download feature, users can download and play videos by using the ApsaraVideo Player on a local PC. For more information, see [Configure download settings](https://help.aliyun.com/document_detail/86107.html). Valid values:
	//
	// 	- **on**: the offline download feature is enabled.
	//
	// 	- **off**: the offline download feature is not enabled.
	//
	// example:
	//
	// on
	DownloadSwitch *string `json:"DownloadSwitch,omitempty" xml:"DownloadSwitch,omitempty"`
	// The duration of the media file. Unit: seconds.
	//
	// example:
	//
	// 135.6
	Duration *float32 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The time when the audio or video file was last updated. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-11-14T10:15:50Z
	ModificationTime *string `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	// The region where the media file is stored.
	//
	// example:
	//
	// cn-shanghai
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The period of time in which the object remains in the restored state.
	//
	// example:
	//
	// 2023-03-30T10:14:14Z
	RestoreExpiration *string `json:"RestoreExpiration,omitempty" xml:"RestoreExpiration,omitempty"`
	// The restoration status of the audio or video file. Valid values:
	//
	// 	- **Processing**
	//
	// 	- **Success**
	//
	// 	- **Failed**
	//
	// example:
	//
	// Success
	RestoreStatus *string `json:"RestoreStatus,omitempty" xml:"RestoreStatus,omitempty"`
	// The size of the source file. Unit: bytes.
	//
	// example:
	//
	// 10897890
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The video snapshot URLs.
	Snapshots *GetVideoInfoResponseBodyVideoSnapshots `json:"Snapshots,omitempty" xml:"Snapshots,omitempty" type:"Struct"`
	// The status of the media file. For more information about the operations that you can perform on files in different statuses and usage limits, see [Status: the status of a video](~~52839#title-vqg-8cz-7p8~~). Valid values:
	//
	// 	- **Uploading**
	//
	// 	- **UploadFail**
	//
	// 	- **UploadSucc**
	//
	// 	- **Transcoding**
	//
	// 	- **TranscodeFail**
	//
	// 	- **Blocked**
	//
	// 	- **Normal**
	//
	// example:
	//
	// Normal
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The storage class of the audio or video file. Valid values:
	//
	// 	- **Standard**: All media resources are stored as Standard objects.
	//
	// 	- **IA**: All media resources are stored as IA objects.
	//
	// 	- **Archive**: All media resources are stored as Archive objects.
	//
	// 	- **ColdArchive**: All media resources are stored as Cold Archive objects.
	//
	// 	- **SourceIA**: Only the source files are IA objects.
	//
	// 	- **SourceArchive**: Only the source files are Archive objects.
	//
	// 	- **SourceColdArchive**: Only the source files are Cold Archive objects.
	//
	// 	- **Changing**: The storage class of the audio or video file is being changed.
	//
	// 	- **SourceChanging**: The storage class of the source file is being changed.
	//
	// example:
	//
	// Standard
	StorageClass *string `json:"StorageClass,omitempty" xml:"StorageClass,omitempty"`
	// The storage address of the media file.
	//
	// example:
	//
	// out-201703232251****.oss-cn-shanghai.aliyuncs.com
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	// The tags of the audio or video file. Multiple tags are separated by commas (,).
	//
	// example:
	//
	// Tag 1,Tag 2
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The ID of the transcoding template group.
	//
	// example:
	//
	// 9ae2af636ca64835b0c10412f448****
	TemplateGroupId *string `json:"TemplateGroupId,omitempty" xml:"TemplateGroupId,omitempty"`
	// The title of the media file.
	//
	// example:
	//
	// Video title in ApsaraVideo VOD
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// Custom settings. This is a JSON string that supports settings such as message callbacks and upload acceleration. For more information, please refer to [UserData](https://help.aliyun.com/document_detail/86952.html).
	//
	// example:
	//
	// {"MessageCallback":{"CallbackURL":"http://example.aliyundoc.com"},"Extend":{"localId":"*****","test":"www"}}
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
	// The ID of the media file.
	//
	// example:
	//
	// 9b73864d75f1d231e9001cd5f8****
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s GetVideoInfoResponseBodyVideo) String() string {
	return tea.Prettify(s)
}

func (s GetVideoInfoResponseBodyVideo) GoString() string {
	return s.String()
}

func (s *GetVideoInfoResponseBodyVideo) SetAppId(v string) *GetVideoInfoResponseBodyVideo {
	s.AppId = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetAuditStatus(v string) *GetVideoInfoResponseBodyVideo {
	s.AuditStatus = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetCateId(v int64) *GetVideoInfoResponseBodyVideo {
	s.CateId = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetCateName(v string) *GetVideoInfoResponseBodyVideo {
	s.CateName = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetCoverURL(v string) *GetVideoInfoResponseBodyVideo {
	s.CoverURL = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetCreationTime(v string) *GetVideoInfoResponseBodyVideo {
	s.CreationTime = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetCustomMediaInfo(v string) *GetVideoInfoResponseBodyVideo {
	s.CustomMediaInfo = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetDescription(v string) *GetVideoInfoResponseBodyVideo {
	s.Description = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetDownloadSwitch(v string) *GetVideoInfoResponseBodyVideo {
	s.DownloadSwitch = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetDuration(v float32) *GetVideoInfoResponseBodyVideo {
	s.Duration = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetModificationTime(v string) *GetVideoInfoResponseBodyVideo {
	s.ModificationTime = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetRegionId(v string) *GetVideoInfoResponseBodyVideo {
	s.RegionId = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetRestoreExpiration(v string) *GetVideoInfoResponseBodyVideo {
	s.RestoreExpiration = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetRestoreStatus(v string) *GetVideoInfoResponseBodyVideo {
	s.RestoreStatus = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetSize(v int64) *GetVideoInfoResponseBodyVideo {
	s.Size = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetSnapshots(v *GetVideoInfoResponseBodyVideoSnapshots) *GetVideoInfoResponseBodyVideo {
	s.Snapshots = v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetStatus(v string) *GetVideoInfoResponseBodyVideo {
	s.Status = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetStorageClass(v string) *GetVideoInfoResponseBodyVideo {
	s.StorageClass = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetStorageLocation(v string) *GetVideoInfoResponseBodyVideo {
	s.StorageLocation = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetTags(v string) *GetVideoInfoResponseBodyVideo {
	s.Tags = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetTemplateGroupId(v string) *GetVideoInfoResponseBodyVideo {
	s.TemplateGroupId = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetTitle(v string) *GetVideoInfoResponseBodyVideo {
	s.Title = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetUserData(v string) *GetVideoInfoResponseBodyVideo {
	s.UserData = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetVideoId(v string) *GetVideoInfoResponseBodyVideo {
	s.VideoId = &v
	return s
}

type GetVideoInfoResponseBodyVideoSnapshots struct {
	Snapshot []*string `json:"Snapshot,omitempty" xml:"Snapshot,omitempty" type:"Repeated"`
}

func (s GetVideoInfoResponseBodyVideoSnapshots) String() string {
	return tea.Prettify(s)
}

func (s GetVideoInfoResponseBodyVideoSnapshots) GoString() string {
	return s.String()
}

func (s *GetVideoInfoResponseBodyVideoSnapshots) SetSnapshot(v []*string) *GetVideoInfoResponseBodyVideoSnapshots {
	s.Snapshot = v
	return s
}

type GetVideoInfoResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetVideoInfoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetVideoInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s GetVideoInfoResponse) GoString() string {
	return s.String()
}

func (s *GetVideoInfoResponse) SetHeaders(v map[string]*string) *GetVideoInfoResponse {
	s.Headers = v
	return s
}

func (s *GetVideoInfoResponse) SetStatusCode(v int32) *GetVideoInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *GetVideoInfoResponse) SetBody(v *GetVideoInfoResponseBody) *GetVideoInfoResponse {
	s.Body = v
	return s
}

type GetVideoInfosRequest struct {
	// The list of video IDs. Separate multiple IDs with commas (,). A maximum of 20 IDs can be specified.
	//
	// This parameter is required.
	//
	// example:
	//
	// 7753d144efd8e649c6c45fe0579****,7753d144efd74d6c45fe0570****
	VideoIds *string `json:"VideoIds,omitempty" xml:"VideoIds,omitempty"`
}

func (s GetVideoInfosRequest) String() string {
	return tea.Prettify(s)
}

func (s GetVideoInfosRequest) GoString() string {
	return s.String()
}

func (s *GetVideoInfosRequest) SetVideoIds(v string) *GetVideoInfosRequest {
	s.VideoIds = &v
	return s
}

type GetVideoInfosResponseBody struct {
	// The IDs of the videos that do not exist.
	NonExistVideoIds []*string `json:"NonExistVideoIds,omitempty" xml:"NonExistVideoIds,omitempty" type:"Repeated"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4AF6-D7393642CA58****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the audio or video files.
	VideoList []*GetVideoInfosResponseBodyVideoList `json:"VideoList,omitempty" xml:"VideoList,omitempty" type:"Repeated"`
}

func (s GetVideoInfosResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetVideoInfosResponseBody) GoString() string {
	return s.String()
}

func (s *GetVideoInfosResponseBody) SetNonExistVideoIds(v []*string) *GetVideoInfosResponseBody {
	s.NonExistVideoIds = v
	return s
}

func (s *GetVideoInfosResponseBody) SetRequestId(v string) *GetVideoInfosResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetVideoInfosResponseBody) SetVideoList(v []*GetVideoInfosResponseBodyVideoList) *GetVideoInfosResponseBody {
	s.VideoList = v
	return s
}

type GetVideoInfosResponseBodyVideoList struct {
	// The ID of the application.
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the category.
	//
	// example:
	//
	// 781111****
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The name of the category.
	//
	// example:
	//
	// This is a category name.
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	// The thumbnail URL of the audio or video file.
	//
	// example:
	//
	// https://example.aliyundoc.com/****.jpg
	CoverURL *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	// The time when the media file was created. The time is in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-06-26T05:38:48Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the audio or video file.
	//
	// example:
	//
	// This is a category description.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether the offline download feature is enabled. If you enable the offline download feature, users can download and play videos by using the ApsaraVideo Player on a local PC. For more information, see [Configure download settings](https://help.aliyun.com/document_detail/86107.html). Valid values:
	//
	// 	- **on**: the offline download feature is enabled.
	//
	// 	- **off**: the offline download feature is not enabled.
	//
	// example:
	//
	// on
	DownloadSwitch *string `json:"DownloadSwitch,omitempty" xml:"DownloadSwitch,omitempty"`
	// The duration of the audio or video file. Unit: seconds.
	//
	// example:
	//
	// 120
	Duration *float32 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The time when the audio or video file was last updated. The time is in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-06-26T06:38:48Z
	ModificationTime *string `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	// The period of time in which the audio file remains in the restored state.
	//
	// example:
	//
	// 2023-03-30T10:14:14Z
	RestoreExpiration *string `json:"RestoreExpiration,omitempty" xml:"RestoreExpiration,omitempty"`
	// The restoration status of the audio file. Valid values:
	//
	// 	- **Processing**
	//
	// 	- **Success**
	//
	// 	- **Failed**
	//
	// example:
	//
	// Success
	RestoreStatus *string `json:"RestoreStatus,omitempty" xml:"RestoreStatus,omitempty"`
	// The size of the source file. Unit: bytes.
	//
	// example:
	//
	// 453
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The video snapshot URLs.
	Snapshots []*string `json:"Snapshots,omitempty" xml:"Snapshots,omitempty" type:"Repeated"`
	// The status of the video. Valid values:
	//
	// 	- **Uploading**
	//
	// 	- **UploadFail**
	//
	// 	- **UploadSucc**
	//
	// 	- **Transcoding**
	//
	// 	- **TranscodeFail**
	//
	// 	- **Blocked**
	//
	// 	- **Normal**
	//
	// example:
	//
	// Normal
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The storage class of the audio file. Valid values:
	//
	// 	- **Standard**: All media resources are stored as Standard objects.
	//
	// 	- **IA**: All media resources are stored as IA objects.
	//
	// 	- **Archive**: All media resources are stored as Archive objects.
	//
	// 	- **ColdArchive**: All media resources are stored as Cold Archive objects.
	//
	// 	- **SourceIA**: Only the source files are IA objects.
	//
	// 	- **SourceArchive**: Only the source files are Archive objects.
	//
	// 	- **SourceColdArchive**: Only the source file is stored as a Cold Archive object.
	//
	// 	- **Changing**: The storage class of the video file is being changed.
	//
	// 	- **SourceChanging**: The storage class of the source file is being changed.
	//
	// example:
	//
	// Standard
	StorageClass *string `json:"StorageClass,omitempty" xml:"StorageClass,omitempty"`
	// The storage address of the audio or video file.
	//
	// example:
	//
	// out-****.oss-cn-shanghai.aliyuncs.com
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	// The tags of the audio or video file. Multiple tags are separated by commas (,).
	//
	// example:
	//
	// tag1, tag2
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The ID of the transcoding template group.
	//
	// example:
	//
	// b4039216985f4312a5382a4ed****
	TemplateGroupId *string `json:"TemplateGroupId,omitempty" xml:"TemplateGroupId,omitempty"`
	// The title of the audio or video file.
	//
	// example:
	//
	// Video tiltle
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// Custom settings. This is a JSON string that supports settings such as message callbacks and upload acceleration. For more information, please refer to [UserData](https://help.aliyun.com/document_detail/86952.html).
	//
	// example:
	//
	// {"MessageCallback":{"CallbackURL":"http://example.aliyundoc.com"},"Extend":{"localId":"*****","test":"www"}}
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
	// The ID of the audio or video file.
	//
	// example:
	//
	// 7753d144efd74d6c45fe0570****
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s GetVideoInfosResponseBodyVideoList) String() string {
	return tea.Prettify(s)
}

func (s GetVideoInfosResponseBodyVideoList) GoString() string {
	return s.String()
}

func (s *GetVideoInfosResponseBodyVideoList) SetAppId(v string) *GetVideoInfosResponseBodyVideoList {
	s.AppId = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetCateId(v int64) *GetVideoInfosResponseBodyVideoList {
	s.CateId = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetCateName(v string) *GetVideoInfosResponseBodyVideoList {
	s.CateName = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetCoverURL(v string) *GetVideoInfosResponseBodyVideoList {
	s.CoverURL = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetCreationTime(v string) *GetVideoInfosResponseBodyVideoList {
	s.CreationTime = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetDescription(v string) *GetVideoInfosResponseBodyVideoList {
	s.Description = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetDownloadSwitch(v string) *GetVideoInfosResponseBodyVideoList {
	s.DownloadSwitch = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetDuration(v float32) *GetVideoInfosResponseBodyVideoList {
	s.Duration = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetModificationTime(v string) *GetVideoInfosResponseBodyVideoList {
	s.ModificationTime = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetRestoreExpiration(v string) *GetVideoInfosResponseBodyVideoList {
	s.RestoreExpiration = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetRestoreStatus(v string) *GetVideoInfosResponseBodyVideoList {
	s.RestoreStatus = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetSize(v int64) *GetVideoInfosResponseBodyVideoList {
	s.Size = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetSnapshots(v []*string) *GetVideoInfosResponseBodyVideoList {
	s.Snapshots = v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetStatus(v string) *GetVideoInfosResponseBodyVideoList {
	s.Status = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetStorageClass(v string) *GetVideoInfosResponseBodyVideoList {
	s.StorageClass = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetStorageLocation(v string) *GetVideoInfosResponseBodyVideoList {
	s.StorageLocation = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetTags(v string) *GetVideoInfosResponseBodyVideoList {
	s.Tags = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetTemplateGroupId(v string) *GetVideoInfosResponseBodyVideoList {
	s.TemplateGroupId = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetTitle(v string) *GetVideoInfosResponseBodyVideoList {
	s.Title = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetUserData(v string) *GetVideoInfosResponseBodyVideoList {
	s.UserData = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetVideoId(v string) *GetVideoInfosResponseBodyVideoList {
	s.VideoId = &v
	return s
}

type GetVideoInfosResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetVideoInfosResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetVideoInfosResponse) String() string {
	return tea.Prettify(s)
}

func (s GetVideoInfosResponse) GoString() string {
	return s.String()
}

func (s *GetVideoInfosResponse) SetHeaders(v map[string]*string) *GetVideoInfosResponse {
	s.Headers = v
	return s
}

func (s *GetVideoInfosResponse) SetStatusCode(v int32) *GetVideoInfosResponse {
	s.StatusCode = &v
	return s
}

func (s *GetVideoInfosResponse) SetBody(v *GetVideoInfosResponseBody) *GetVideoInfosResponse {
	s.Body = v
	return s
}

type GetVideoListRequest struct {
	// The ID of the category. You can use one of the following methods to obtain the category ID:
	//
	// 	- Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Configuration Management*	- > **Media Management*	- > **Categories*	- to view the category ID.
	//
	// 	- Obtain the value of CateId from the response to the [AddCategory](https://help.aliyun.com/document_detail/56401.html) operation.
	//
	// 	- Obtain the value of CateId from the response to the [GetCategories](https://help.aliyun.com/document_detail/56406.html) operation.
	//
	// example:
	//
	// 781111
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// example:
	//
	// 2017-01-11T12:59:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The number of the page to return. Default value: **1**.
	//
	// example:
	//
	// 1
	PageNo *int32 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The number of entries to return on each page. Default value: **10**. Maximum value: **100**.
	//
	// example:
	//
	// 10
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The sorting method of the results. Valid values:
	//
	// 	- **CreationTime:Desc*	- (default): The results are sorted in reverse chronological order based on the creation time.
	//
	// 	- **CreationTime:Asc**: The results are sorted in chronological order based on the creation time.
	//
	// example:
	//
	// CreationTime:Asc
	SortBy *string `json:"SortBy,omitempty" xml:"SortBy,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// example:
	//
	// 2017-01-11T12:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The status of the video. You can specify multiple video statuses and separate them with commas (,). Valid values:
	//
	// 	- **Uploading**: The video is being uploaded.
	//
	// 	- **UploadFail**: The video failed to be uploaded.
	//
	// 	- **UploadSucc**: The video has been uploaded.
	//
	// 	- **Transcoding**: The video is being transcoded.
	//
	// 	- **TranscodeFail**: The video failed to be transcoded.
	//
	// 	- **checking**: The video is being reviewed.
	//
	// 	- **Blocked**: The video is blocked.
	//
	// 	- **Normal**: The video is normal.
	//
	// 	- **ProduceFail**: The video failed to be produced.
	//
	// For more information about each video status, see the "Status: the status of a video" section of the [Basic data types](~~52839#section-p7c-jgy-070~~) topic.
	//
	// example:
	//
	// Uploading,Normal
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The storage address of the media file.
	//
	// example:
	//
	// out-****.oss-cn-shanghai.aliyuncs.com
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
}

func (s GetVideoListRequest) String() string {
	return tea.Prettify(s)
}

func (s GetVideoListRequest) GoString() string {
	return s.String()
}

func (s *GetVideoListRequest) SetCateId(v int64) *GetVideoListRequest {
	s.CateId = &v
	return s
}

func (s *GetVideoListRequest) SetEndTime(v string) *GetVideoListRequest {
	s.EndTime = &v
	return s
}

func (s *GetVideoListRequest) SetPageNo(v int32) *GetVideoListRequest {
	s.PageNo = &v
	return s
}

func (s *GetVideoListRequest) SetPageSize(v int32) *GetVideoListRequest {
	s.PageSize = &v
	return s
}

func (s *GetVideoListRequest) SetSortBy(v string) *GetVideoListRequest {
	s.SortBy = &v
	return s
}

func (s *GetVideoListRequest) SetStartTime(v string) *GetVideoListRequest {
	s.StartTime = &v
	return s
}

func (s *GetVideoListRequest) SetStatus(v string) *GetVideoListRequest {
	s.Status = &v
	return s
}

func (s *GetVideoListRequest) SetStorageLocation(v string) *GetVideoListRequest {
	s.StorageLocation = &v
	return s
}

type GetVideoListResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4AF6-D7393642CA58****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of media files returned.
	//
	// example:
	//
	// 100
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
	// The information about the audio or video files. Information about a maximum of 5,000 audio or video files can be returned.
	VideoList *GetVideoListResponseBodyVideoList `json:"VideoList,omitempty" xml:"VideoList,omitempty" type:"Struct"`
}

func (s GetVideoListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetVideoListResponseBody) GoString() string {
	return s.String()
}

func (s *GetVideoListResponseBody) SetRequestId(v string) *GetVideoListResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetVideoListResponseBody) SetTotal(v int32) *GetVideoListResponseBody {
	s.Total = &v
	return s
}

func (s *GetVideoListResponseBody) SetVideoList(v *GetVideoListResponseBodyVideoList) *GetVideoListResponseBody {
	s.VideoList = v
	return s
}

type GetVideoListResponseBodyVideoList struct {
	Video []*GetVideoListResponseBodyVideoListVideo `json:"Video,omitempty" xml:"Video,omitempty" type:"Repeated"`
}

func (s GetVideoListResponseBodyVideoList) String() string {
	return tea.Prettify(s)
}

func (s GetVideoListResponseBodyVideoList) GoString() string {
	return s.String()
}

func (s *GetVideoListResponseBodyVideoList) SetVideo(v []*GetVideoListResponseBodyVideoListVideo) *GetVideoListResponseBodyVideoList {
	s.Video = v
	return s
}

type GetVideoListResponseBodyVideoListVideo struct {
	// The ID of the application. Default value: **app-1000000**.
	//
	// example:
	//
	// app-1000000
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The category ID of the audio or video file.
	//
	// example:
	//
	// 781111
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The name of the category.
	//
	// example:
	//
	// Category name
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	// The thumbnail URL of the audio or video file.
	//
	// example:
	//
	// https://example.aliyundoc.com/****.jpg
	CoverURL *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	// The time when the audio or video file was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*hh:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-11-14T09:15:50Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the audio or video file.
	//
	// example:
	//
	// Video description in ApsaraVideo VOD
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The duration of the audio or video file. Unit: seconds. 86,400 seconds is equivalent to 24 hours.
	//
	// example:
	//
	// 135.6
	Duration *float32 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The time when the video was updated. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*hh:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-11-14T09:16:50Z
	ModificationTime *string `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	// The period of time in which the audio or video file remains in the restored state.
	//
	// example:
	//
	// 2023-03-30T10:14:14Z
	RestoreExpiration *string `json:"RestoreExpiration,omitempty" xml:"RestoreExpiration,omitempty"`
	// The restoration status of the audio or video file. Valid values:
	//
	// 	- **Processing**
	//
	// 	- **Success**
	//
	// 	- **Failed**
	//
	// example:
	//
	// Success
	RestoreStatus *string `json:"RestoreStatus,omitempty" xml:"RestoreStatus,omitempty"`
	// The size of the source file. Unit: bytes.
	//
	// example:
	//
	// 10897890
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The URL array of video snapshots.
	Snapshots *GetVideoListResponseBodyVideoListVideoSnapshots `json:"Snapshots,omitempty" xml:"Snapshots,omitempty" type:"Struct"`
	// The status of the audio or video file. Valid values:
	//
	// 	- **Uploading**: The video is being uploaded.
	//
	// 	- **UploadFail**: The video failed to be uploaded.
	//
	// 	- **UploadSucc**: The video is uploaded.
	//
	// 	- **Transcoding**: The video is being transcoded.
	//
	// 	- **TranscodeFail**: The video failed to be transcoded.
	//
	// 	- **checking**: The video is being reviewed.
	//
	// 	- **Blocked**: The video is blocked.
	//
	// 	- **Normal**: The video is normal.
	//
	// 	- **ProduceFail**: The video failed to be produced.
	//
	// For more information about each video status, see the "Status: the status of a video" section of the [Basic data types](~~52839#section-p7c-jgy-070~~) topic.
	//
	// example:
	//
	// Normal
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The storage class of the audio or video file. Valid values:
	//
	// 	- **Standard**: All media resources are stored as Standard objects.
	//
	// 	- **IA**: All media resources are stored as IA objects.
	//
	// 	- **Archive**: All media resources are stored as Archive objects.
	//
	// 	- **ColdArchive**: All media resources are stored as Cold Archive objects.
	//
	// 	- **SourceIA**: Only the source files are IA objects.
	//
	// 	- **SourceArchive**: Only the source files are Archive objects.
	//
	// 	- **SourceColdArchive**: Only the source files are Cold Archive objects.
	//
	// 	- **Changing**: The storage class of the audio or video file is being changed.
	//
	// 	- **SourceChanging**: The storage class of the source file is being changed.
	//
	// example:
	//
	// Standard
	StorageClass *string `json:"StorageClass,omitempty" xml:"StorageClass,omitempty"`
	// The storage address of the audio or video file.
	//
	// example:
	//
	// out-****.oss-cn-shanghai.aliyuncs.com
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	// The tags of the audio or video file. Multiple tags are separated by commas (,).
	//
	// example:
	//
	// Tag 1,Tag 2
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The title of the audio or video file.
	//
	// example:
	//
	// Video title in ApsaraVideo VOD
	Title    *string `json:"Title,omitempty" xml:"Title,omitempty"`
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
	// The ID of the audio or video file.
	//
	// example:
	//
	// 9ae2af636ca6c10412f44891fc****
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s GetVideoListResponseBodyVideoListVideo) String() string {
	return tea.Prettify(s)
}

func (s GetVideoListResponseBodyVideoListVideo) GoString() string {
	return s.String()
}

func (s *GetVideoListResponseBodyVideoListVideo) SetAppId(v string) *GetVideoListResponseBodyVideoListVideo {
	s.AppId = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetCateId(v int64) *GetVideoListResponseBodyVideoListVideo {
	s.CateId = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetCateName(v string) *GetVideoListResponseBodyVideoListVideo {
	s.CateName = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetCoverURL(v string) *GetVideoListResponseBodyVideoListVideo {
	s.CoverURL = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetCreationTime(v string) *GetVideoListResponseBodyVideoListVideo {
	s.CreationTime = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetDescription(v string) *GetVideoListResponseBodyVideoListVideo {
	s.Description = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetDuration(v float32) *GetVideoListResponseBodyVideoListVideo {
	s.Duration = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetModificationTime(v string) *GetVideoListResponseBodyVideoListVideo {
	s.ModificationTime = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetRestoreExpiration(v string) *GetVideoListResponseBodyVideoListVideo {
	s.RestoreExpiration = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetRestoreStatus(v string) *GetVideoListResponseBodyVideoListVideo {
	s.RestoreStatus = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetSize(v int64) *GetVideoListResponseBodyVideoListVideo {
	s.Size = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetSnapshots(v *GetVideoListResponseBodyVideoListVideoSnapshots) *GetVideoListResponseBodyVideoListVideo {
	s.Snapshots = v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetStatus(v string) *GetVideoListResponseBodyVideoListVideo {
	s.Status = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetStorageClass(v string) *GetVideoListResponseBodyVideoListVideo {
	s.StorageClass = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetStorageLocation(v string) *GetVideoListResponseBodyVideoListVideo {
	s.StorageLocation = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetTags(v string) *GetVideoListResponseBodyVideoListVideo {
	s.Tags = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetTitle(v string) *GetVideoListResponseBodyVideoListVideo {
	s.Title = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetUserData(v string) *GetVideoListResponseBodyVideoListVideo {
	s.UserData = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetVideoId(v string) *GetVideoListResponseBodyVideoListVideo {
	s.VideoId = &v
	return s
}

type GetVideoListResponseBodyVideoListVideoSnapshots struct {
	Snapshot []*string `json:"Snapshot,omitempty" xml:"Snapshot,omitempty" type:"Repeated"`
}

func (s GetVideoListResponseBodyVideoListVideoSnapshots) String() string {
	return tea.Prettify(s)
}

func (s GetVideoListResponseBodyVideoListVideoSnapshots) GoString() string {
	return s.String()
}

func (s *GetVideoListResponseBodyVideoListVideoSnapshots) SetSnapshot(v []*string) *GetVideoListResponseBodyVideoListVideoSnapshots {
	s.Snapshot = v
	return s
}

type GetVideoListResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetVideoListResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetVideoListResponse) String() string {
	return tea.Prettify(s)
}

func (s GetVideoListResponse) GoString() string {
	return s.String()
}

func (s *GetVideoListResponse) SetHeaders(v map[string]*string) *GetVideoListResponse {
	s.Headers = v
	return s
}

func (s *GetVideoListResponse) SetStatusCode(v int32) *GetVideoListResponse {
	s.StatusCode = &v
	return s
}

func (s *GetVideoListResponse) SetBody(v *GetVideoListResponseBody) *GetVideoListResponse {
	s.Body = v
	return s
}

type GetVideoPlayAuthRequest struct {
	// The API version. Set the value to **1.0.0**.
	//
	// example:
	//
	// 1.0.0
	ApiVersion *string `json:"ApiVersion,omitempty" xml:"ApiVersion,omitempty"`
	// The validity period of the playback credential. Unit: **seconds**. You cannot obtain the playback URL of a video by using a credential that has expired. A new credential is required.
	//
	// 	- Default value: **100**.
	//
	// 	- Valid values: `[100,3000]`.
	//
	// example:
	//
	// 100
	AuthInfoTimeout *int64 `json:"AuthInfoTimeout,omitempty" xml:"AuthInfoTimeout,omitempty"`
	// The ID of the media file. You can specify only one ID. You can use one of the following methods to obtain the ID of the file:
	//
	// 	- Log on to the [ApsaraVideo VOD](https://vod.console.aliyun.com) console. In the left-side navigation pane, choose **Media Files*	- > **Audio/Video**. On the Video and Audio page, view the ID of the media file. This method is applicable to files that are uploaded by using the ApsaraVideo VOD console.
	//
	// 	- Obtain the value of the VideoId parameter from the response to the [CreateUploadVideo](https://help.aliyun.com/document_detail/55407.html) operation.
	//
	// 	- Obtain the value of the VideoId parameter from the response to the [SearchMedia](https://help.aliyun.com/document_detail/86044.html) operation. This method is applicable to files that have been uploaded.
	//
	// This parameter is required.
	//
	// example:
	//
	// dfde02284a5c46622a097adaf44a****
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s GetVideoPlayAuthRequest) String() string {
	return tea.Prettify(s)
}

func (s GetVideoPlayAuthRequest) GoString() string {
	return s.String()
}

func (s *GetVideoPlayAuthRequest) SetApiVersion(v string) *GetVideoPlayAuthRequest {
	s.ApiVersion = &v
	return s
}

func (s *GetVideoPlayAuthRequest) SetAuthInfoTimeout(v int64) *GetVideoPlayAuthRequest {
	s.AuthInfoTimeout = &v
	return s
}

func (s *GetVideoPlayAuthRequest) SetVideoId(v string) *GetVideoPlayAuthRequest {
	s.VideoId = &v
	return s
}

type GetVideoPlayAuthResponseBody struct {
	// The credential for media playback.
	//
	// example:
	//
	// sstyYuew6789000000xtt7TYUh****
	PlayAuth *string `json:"PlayAuth,omitempty" xml:"PlayAuth,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// E4EBD2BF-5EB0-4476-8829-9D94E1B1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The metadata of the audio or video file.
	VideoMeta *GetVideoPlayAuthResponseBodyVideoMeta `json:"VideoMeta,omitempty" xml:"VideoMeta,omitempty" type:"Struct"`
}

func (s GetVideoPlayAuthResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetVideoPlayAuthResponseBody) GoString() string {
	return s.String()
}

func (s *GetVideoPlayAuthResponseBody) SetPlayAuth(v string) *GetVideoPlayAuthResponseBody {
	s.PlayAuth = &v
	return s
}

func (s *GetVideoPlayAuthResponseBody) SetRequestId(v string) *GetVideoPlayAuthResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetVideoPlayAuthResponseBody) SetVideoMeta(v *GetVideoPlayAuthResponseBodyVideoMeta) *GetVideoPlayAuthResponseBody {
	s.VideoMeta = v
	return s
}

type GetVideoPlayAuthResponseBodyVideoMeta struct {
	// The thumbnail URL of the media file.
	//
	// example:
	//
	// https://example.aliyundoc.com/****.jpg
	CoverURL *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	// The duration of the media file. Unit: seconds.
	//
	// example:
	//
	// 120.0
	Duration *float32 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The status of the media file. For more information about the value range and description, see [Status: the status of a video](~~52839#title-vqg-8cz-7p8~~).
	//
	// example:
	//
	// Normal
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The title of the media file.
	//
	// example:
	//
	// VOD
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The ID of the media file.
	//
	// example:
	//
	// dfde02284a5c46622a097adaf44a****
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s GetVideoPlayAuthResponseBodyVideoMeta) String() string {
	return tea.Prettify(s)
}

func (s GetVideoPlayAuthResponseBodyVideoMeta) GoString() string {
	return s.String()
}

func (s *GetVideoPlayAuthResponseBodyVideoMeta) SetCoverURL(v string) *GetVideoPlayAuthResponseBodyVideoMeta {
	s.CoverURL = &v
	return s
}

func (s *GetVideoPlayAuthResponseBodyVideoMeta) SetDuration(v float32) *GetVideoPlayAuthResponseBodyVideoMeta {
	s.Duration = &v
	return s
}

func (s *GetVideoPlayAuthResponseBodyVideoMeta) SetStatus(v string) *GetVideoPlayAuthResponseBodyVideoMeta {
	s.Status = &v
	return s
}

func (s *GetVideoPlayAuthResponseBodyVideoMeta) SetTitle(v string) *GetVideoPlayAuthResponseBodyVideoMeta {
	s.Title = &v
	return s
}

func (s *GetVideoPlayAuthResponseBodyVideoMeta) SetVideoId(v string) *GetVideoPlayAuthResponseBodyVideoMeta {
	s.VideoId = &v
	return s
}

type GetVideoPlayAuthResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetVideoPlayAuthResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetVideoPlayAuthResponse) String() string {
	return tea.Prettify(s)
}

func (s GetVideoPlayAuthResponse) GoString() string {
	return s.String()
}

func (s *GetVideoPlayAuthResponse) SetHeaders(v map[string]*string) *GetVideoPlayAuthResponse {
	s.Headers = v
	return s
}

func (s *GetVideoPlayAuthResponse) SetStatusCode(v int32) *GetVideoPlayAuthResponse {
	s.StatusCode = &v
	return s
}

func (s *GetVideoPlayAuthResponse) SetBody(v *GetVideoPlayAuthResponseBody) *GetVideoPlayAuthResponse {
	s.Body = v
	return s
}

type GetVodTemplateRequest struct {
	// The ID of the snapshot template.
	//
	// This parameter is required.
	//
	// example:
	//
	// 7c49f2f4c0969*****fcd446690
	VodTemplateId *string `json:"VodTemplateId,omitempty" xml:"VodTemplateId,omitempty"`
}

func (s GetVodTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s GetVodTemplateRequest) GoString() string {
	return s.String()
}

func (s *GetVodTemplateRequest) SetVodTemplateId(v string) *GetVodTemplateRequest {
	s.VodTemplateId = &v
	return s
}

type GetVodTemplateResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// DE7A1F49-41C1-47*****DF-4CD0C02087DB
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the snapshot template.
	VodTemplateInfo *GetVodTemplateResponseBodyVodTemplateInfo `json:"VodTemplateInfo,omitempty" xml:"VodTemplateInfo,omitempty" type:"Struct"`
}

func (s GetVodTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetVodTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *GetVodTemplateResponseBody) SetRequestId(v string) *GetVodTemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetVodTemplateResponseBody) SetVodTemplateInfo(v *GetVodTemplateResponseBodyVodTemplateInfo) *GetVodTemplateResponseBody {
	s.VodTemplateInfo = v
	return s
}

type GetVodTemplateResponseBodyVodTemplateInfo struct {
	// The time when the template was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2018-11-30T08:05:59:57Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// Indicates whether the template is the default one. Valid values:
	//
	// 	- **Default**: The template is the default one.
	//
	// 	- **NotDefault**: The template is not the default one.
	//
	// example:
	//
	// NotDefault
	IsDefault *string `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	// The time when the template was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2018-11-30T09:05:59:57Z
	ModifyTime *string `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	// The name of the template.
	//
	// example:
	//
	// test
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The detailed configurations of the template. The value is a JSON-formatted string. For more information about the data structure, see the "SnapshotTemplateConfig" section of the [Media processing parameters](https://help.aliyun.com/document_detail/98618.html) topic.
	//
	// example:
	//
	// {\\"SnapshotConfig\\":{\\"Count\\":10,\\"SpecifiedOffsetTime\\":0,\\"Interval\\":1},\\"SnapshotType\\":\\"NormalSnapshot\\"}
	TemplateConfig *string `json:"TemplateConfig,omitempty" xml:"TemplateConfig,omitempty"`
	// The type of the template. Valid values:
	//
	// 	- **Snapshot**
	//
	// 	- **DynamicImage**
	//
	// example:
	//
	// Snapshot
	TemplateType *string `json:"TemplateType,omitempty" xml:"TemplateType,omitempty"`
	// The ID of the template.
	//
	// example:
	//
	// 7c49f2f4c09*****69fcd446690
	VodTemplateId *string `json:"VodTemplateId,omitempty" xml:"VodTemplateId,omitempty"`
}

func (s GetVodTemplateResponseBodyVodTemplateInfo) String() string {
	return tea.Prettify(s)
}

func (s GetVodTemplateResponseBodyVodTemplateInfo) GoString() string {
	return s.String()
}

func (s *GetVodTemplateResponseBodyVodTemplateInfo) SetCreationTime(v string) *GetVodTemplateResponseBodyVodTemplateInfo {
	s.CreationTime = &v
	return s
}

func (s *GetVodTemplateResponseBodyVodTemplateInfo) SetIsDefault(v string) *GetVodTemplateResponseBodyVodTemplateInfo {
	s.IsDefault = &v
	return s
}

func (s *GetVodTemplateResponseBodyVodTemplateInfo) SetModifyTime(v string) *GetVodTemplateResponseBodyVodTemplateInfo {
	s.ModifyTime = &v
	return s
}

func (s *GetVodTemplateResponseBodyVodTemplateInfo) SetName(v string) *GetVodTemplateResponseBodyVodTemplateInfo {
	s.Name = &v
	return s
}

func (s *GetVodTemplateResponseBodyVodTemplateInfo) SetTemplateConfig(v string) *GetVodTemplateResponseBodyVodTemplateInfo {
	s.TemplateConfig = &v
	return s
}

func (s *GetVodTemplateResponseBodyVodTemplateInfo) SetTemplateType(v string) *GetVodTemplateResponseBodyVodTemplateInfo {
	s.TemplateType = &v
	return s
}

func (s *GetVodTemplateResponseBodyVodTemplateInfo) SetVodTemplateId(v string) *GetVodTemplateResponseBodyVodTemplateInfo {
	s.VodTemplateId = &v
	return s
}

type GetVodTemplateResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetVodTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetVodTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s GetVodTemplateResponse) GoString() string {
	return s.String()
}

func (s *GetVodTemplateResponse) SetHeaders(v map[string]*string) *GetVodTemplateResponse {
	s.Headers = v
	return s
}

func (s *GetVodTemplateResponse) SetStatusCode(v int32) *GetVodTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *GetVodTemplateResponse) SetBody(v *GetVodTemplateResponseBody) *GetVodTemplateResponse {
	s.Body = v
	return s
}

type GetWatermarkRequest struct {
	// The ID of the watermark template. You can specify only one watermark template ID. You can obtain the ID by using one of the following methods:
	//
	// 	- Obtain the watermark template ID from the response to the [AddWatermark](~~AddWatermark~~) operation that you call to create a watermark template.
	//
	// 	- Obtain the watermark template ID from the response to the [ListWatermark](~~ListWatermark~~) operation that you call to query all watermarks within your account.
	//
	// This parameter is required.
	//
	// example:
	//
	// 9bcc8bfadb843f*****09a2671d0df97
	WatermarkId *string `json:"WatermarkId,omitempty" xml:"WatermarkId,omitempty"`
}

func (s GetWatermarkRequest) String() string {
	return tea.Prettify(s)
}

func (s GetWatermarkRequest) GoString() string {
	return s.String()
}

func (s *GetWatermarkRequest) SetWatermarkId(v string) *GetWatermarkRequest {
	s.WatermarkId = &v
	return s
}

type GetWatermarkResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A*****F6-D7393642CA58
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the watermark template.
	WatermarkInfo *GetWatermarkResponseBodyWatermarkInfo `json:"WatermarkInfo,omitempty" xml:"WatermarkInfo,omitempty" type:"Struct"`
}

func (s GetWatermarkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetWatermarkResponseBody) GoString() string {
	return s.String()
}

func (s *GetWatermarkResponseBody) SetRequestId(v string) *GetWatermarkResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetWatermarkResponseBody) SetWatermarkInfo(v *GetWatermarkResponseBodyWatermarkInfo) *GetWatermarkResponseBody {
	s.WatermarkInfo = v
	return s
}

type GetWatermarkResponseBodyWatermarkInfo struct {
	// The ID of the application.
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The time when the watermark template was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2018-11-06T08:03:17Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The URL of the watermark file. The URL is an Object Storage Service (OSS) URL or an Alibaba Cloud CDN URL.
	//
	// >  This parameter is returned only for image watermark templates.
	//
	// example:
	//
	// https://outin-32*****f4b3e7.oss-cn-shanghai.aliyuncs.com/image/cover/F85529C8B715E6F8A72EC6B-6-2.png?Expires=1541600583&OSSAccessKeyId=****&Signature=gmf1eYMoDVg%2BHQCb4UGozBW****
	FileUrl *string `json:"FileUrl,omitempty" xml:"FileUrl,omitempty"`
	// Indicates whether the watermark template is the default one. Valid values:
	//
	// 	- **Default**
	//
	// 	- **NotDefault**
	//
	// example:
	//
	// NotDefault
	IsDefault *string `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	// The name of the watermark template.
	//
	// example:
	//
	// image watermark test
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of the watermark template. Valid values:
	//
	// 	- **Image**: image watermark template
	//
	// 	- **Text**: text watermark template
	//
	// example:
	//
	// Text
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The configuration information of the watermark such as the display position and special effects. The value is a JSON string. The configuration parameters for image and text watermarks are different. For more information about the parameter structure, see [WatermarkConfig](~~98618#section-h01-44s-2lr~~).
	//
	// example:
	//
	// {"ReferPos": "BottomRight","Height": "55","Width": "55","Dx": "8","Dy": "8" }
	WatermarkConfig *string `json:"WatermarkConfig,omitempty" xml:"WatermarkConfig,omitempty"`
	// The ID of the watermark template.
	//
	// example:
	//
	// 505e2e287ea*****ecfddd386d384
	WatermarkId *string `json:"WatermarkId,omitempty" xml:"WatermarkId,omitempty"`
}

func (s GetWatermarkResponseBodyWatermarkInfo) String() string {
	return tea.Prettify(s)
}

func (s GetWatermarkResponseBodyWatermarkInfo) GoString() string {
	return s.String()
}

func (s *GetWatermarkResponseBodyWatermarkInfo) SetAppId(v string) *GetWatermarkResponseBodyWatermarkInfo {
	s.AppId = &v
	return s
}

func (s *GetWatermarkResponseBodyWatermarkInfo) SetCreationTime(v string) *GetWatermarkResponseBodyWatermarkInfo {
	s.CreationTime = &v
	return s
}

func (s *GetWatermarkResponseBodyWatermarkInfo) SetFileUrl(v string) *GetWatermarkResponseBodyWatermarkInfo {
	s.FileUrl = &v
	return s
}

func (s *GetWatermarkResponseBodyWatermarkInfo) SetIsDefault(v string) *GetWatermarkResponseBodyWatermarkInfo {
	s.IsDefault = &v
	return s
}

func (s *GetWatermarkResponseBodyWatermarkInfo) SetName(v string) *GetWatermarkResponseBodyWatermarkInfo {
	s.Name = &v
	return s
}

func (s *GetWatermarkResponseBodyWatermarkInfo) SetType(v string) *GetWatermarkResponseBodyWatermarkInfo {
	s.Type = &v
	return s
}

func (s *GetWatermarkResponseBodyWatermarkInfo) SetWatermarkConfig(v string) *GetWatermarkResponseBodyWatermarkInfo {
	s.WatermarkConfig = &v
	return s
}

func (s *GetWatermarkResponseBodyWatermarkInfo) SetWatermarkId(v string) *GetWatermarkResponseBodyWatermarkInfo {
	s.WatermarkId = &v
	return s
}

type GetWatermarkResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetWatermarkResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetWatermarkResponse) String() string {
	return tea.Prettify(s)
}

func (s GetWatermarkResponse) GoString() string {
	return s.String()
}

func (s *GetWatermarkResponse) SetHeaders(v map[string]*string) *GetWatermarkResponse {
	s.Headers = v
	return s
}

func (s *GetWatermarkResponse) SetStatusCode(v int32) *GetWatermarkResponse {
	s.StatusCode = &v
	return s
}

func (s *GetWatermarkResponse) SetBody(v *GetWatermarkResponseBody) *GetWatermarkResponse {
	s.Body = v
	return s
}

type ListAIImageInfoRequest struct {
	// The ID of the video. You can use one of the following methods to obtain the ID:
	//
	// 	- Log on to the [ApsaraVideo VOD](https://vod.console.aliyun.com) console. In the left-side navigation pane, choose **Media Files*	- > **Audio/Video**. On the Video and Audio page, view the ID of the audio or video file. This method is applicable to files that are uploaded by using the ApsaraVideo VOD console.
	//
	// 	- Obtain the value of VideoId from the response to the [CreateUploadVideo](https://help.aliyun.com/document_detail/55407.html) operation that you call to upload media files.
	//
	// 	- Obtain the value of VideoId from the response to the [SearchMedia](https://help.aliyun.com/document_detail/86044.html) operation after you upload media files.
	//
	// This parameter is required.
	//
	// example:
	//
	// 357a8748c5789d2726e6436aa****
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s ListAIImageInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAIImageInfoRequest) GoString() string {
	return s.String()
}

func (s *ListAIImageInfoRequest) SetVideoId(v string) *ListAIImageInfoRequest {
	s.VideoId = &v
	return s
}

type ListAIImageInfoResponseBody struct {
	// The image files that are uploaded for AI processing.
	AIImageInfoList []*ListAIImageInfoResponseBodyAIImageInfoList `json:"AIImageInfoList,omitempty" xml:"AIImageInfoList,omitempty" type:"Repeated"`
	// The ID of the request.
	//
	// example:
	//
	// D73420CD-D221-9122-5B8FA995A511****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListAIImageInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAIImageInfoResponseBody) GoString() string {
	return s.String()
}

func (s *ListAIImageInfoResponseBody) SetAIImageInfoList(v []*ListAIImageInfoResponseBodyAIImageInfoList) *ListAIImageInfoResponseBody {
	s.AIImageInfoList = v
	return s
}

func (s *ListAIImageInfoResponseBody) SetRequestId(v string) *ListAIImageInfoResponseBody {
	s.RequestId = &v
	return s
}

type ListAIImageInfoResponseBodyAIImageInfoList struct {
	// The ID of the image information.
	//
	// example:
	//
	// b89a6aabf1b6197ebd6fe6cf29****
	AIImageInfoId *string `json:"AIImageInfoId,omitempty" xml:"AIImageInfoId,omitempty"`
	// The time when the file was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2020-10-15T03:30:03Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The URL of the image file.
	FileURL *string `json:"FileURL,omitempty" xml:"FileURL,omitempty"`
	// The format of the image. Valid values: **gif*	- and **png**.
	//
	// example:
	//
	// gif
	Format *string `json:"Format,omitempty" xml:"Format,omitempty"`
	// The ID of the image AI processing job.
	//
	// example:
	//
	// cf08a2c6e11ee1711b738b9067****
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The score of the image.
	//
	// example:
	//
	// 5.035636554444242
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The data version ID.
	//
	// example:
	//
	// b547f3f0e199c3b457369f3cf****
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
	// The ID of the video.
	//
	// example:
	//
	// 357a8748c5789d2726e6436aa****
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s ListAIImageInfoResponseBodyAIImageInfoList) String() string {
	return tea.Prettify(s)
}

func (s ListAIImageInfoResponseBodyAIImageInfoList) GoString() string {
	return s.String()
}

func (s *ListAIImageInfoResponseBodyAIImageInfoList) SetAIImageInfoId(v string) *ListAIImageInfoResponseBodyAIImageInfoList {
	s.AIImageInfoId = &v
	return s
}

func (s *ListAIImageInfoResponseBodyAIImageInfoList) SetCreationTime(v string) *ListAIImageInfoResponseBodyAIImageInfoList {
	s.CreationTime = &v
	return s
}

func (s *ListAIImageInfoResponseBodyAIImageInfoList) SetFileURL(v string) *ListAIImageInfoResponseBodyAIImageInfoList {
	s.FileURL = &v
	return s
}

func (s *ListAIImageInfoResponseBodyAIImageInfoList) SetFormat(v string) *ListAIImageInfoResponseBodyAIImageInfoList {
	s.Format = &v
	return s
}

func (s *ListAIImageInfoResponseBodyAIImageInfoList) SetJobId(v string) *ListAIImageInfoResponseBodyAIImageInfoList {
	s.JobId = &v
	return s
}

func (s *ListAIImageInfoResponseBodyAIImageInfoList) SetScore(v string) *ListAIImageInfoResponseBodyAIImageInfoList {
	s.Score = &v
	return s
}

func (s *ListAIImageInfoResponseBodyAIImageInfoList) SetVersion(v string) *ListAIImageInfoResponseBodyAIImageInfoList {
	s.Version = &v
	return s
}

func (s *ListAIImageInfoResponseBodyAIImageInfoList) SetVideoId(v string) *ListAIImageInfoResponseBodyAIImageInfoList {
	s.VideoId = &v
	return s
}

type ListAIImageInfoResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListAIImageInfoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListAIImageInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAIImageInfoResponse) GoString() string {
	return s.String()
}

func (s *ListAIImageInfoResponse) SetHeaders(v map[string]*string) *ListAIImageInfoResponse {
	s.Headers = v
	return s
}

func (s *ListAIImageInfoResponse) SetStatusCode(v int32) *ListAIImageInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAIImageInfoResponse) SetBody(v *ListAIImageInfoResponseBody) *ListAIImageInfoResponse {
	s.Body = v
	return s
}

type ListAIJobRequest struct {
	// The list of job IDs. You can obtain the job ID from the PlayInfo parameter in the response to the [GetPlayInfo](https://help.aliyun.com/document_detail/56124.html) operation.
	//
	// >  You can specify a maximum of 10 job IDs in a request. Separate multiple IDs with commas (,).
	//
	// This parameter is required.
	//
	// example:
	//
	// a718a3a1e8bb42ee3bc88921e94****,aasdcsfg782740asd3****,k2l3ibaskod98wrns9d****
	JobIds               *string `json:"JobIds,omitempty" xml:"JobIds,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ListAIJobRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAIJobRequest) GoString() string {
	return s.String()
}

func (s *ListAIJobRequest) SetJobIds(v string) *ListAIJobRequest {
	s.JobIds = &v
	return s
}

func (s *ListAIJobRequest) SetOwnerAccount(v string) *ListAIJobRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListAIJobRequest) SetOwnerId(v string) *ListAIJobRequest {
	s.OwnerId = &v
	return s
}

func (s *ListAIJobRequest) SetResourceOwnerAccount(v string) *ListAIJobRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListAIJobRequest) SetResourceOwnerId(v string) *ListAIJobRequest {
	s.ResourceOwnerId = &v
	return s
}

type ListAIJobResponseBody struct {
	// The list of jobs.
	AIJobList *ListAIJobResponseBodyAIJobList `json:"AIJobList,omitempty" xml:"AIJobList,omitempty" type:"Struct"`
	// The IDs of the jobs that do not exist.
	NonExistAIJobIds *ListAIJobResponseBodyNonExistAIJobIds `json:"NonExistAIJobIds,omitempty" xml:"NonExistAIJobIds,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// 8233A0E4-E112-44*****58-2BCED1B88173
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListAIJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAIJobResponseBody) GoString() string {
	return s.String()
}

func (s *ListAIJobResponseBody) SetAIJobList(v *ListAIJobResponseBodyAIJobList) *ListAIJobResponseBody {
	s.AIJobList = v
	return s
}

func (s *ListAIJobResponseBody) SetNonExistAIJobIds(v *ListAIJobResponseBodyNonExistAIJobIds) *ListAIJobResponseBody {
	s.NonExistAIJobIds = v
	return s
}

func (s *ListAIJobResponseBody) SetRequestId(v string) *ListAIJobResponseBody {
	s.RequestId = &v
	return s
}

type ListAIJobResponseBodyAIJobList struct {
	AIJob []*ListAIJobResponseBodyAIJobListAIJob `json:"AIJob,omitempty" xml:"AIJob,omitempty" type:"Repeated"`
}

func (s ListAIJobResponseBodyAIJobList) String() string {
	return tea.Prettify(s)
}

func (s ListAIJobResponseBodyAIJobList) GoString() string {
	return s.String()
}

func (s *ListAIJobResponseBodyAIJobList) SetAIJob(v []*ListAIJobResponseBodyAIJobListAIJob) *ListAIJobResponseBodyAIJobList {
	s.AIJob = v
	return s
}

type ListAIJobResponseBodyAIJobListAIJob struct {
	// The error code. This parameter is returned if the value of Status is fail.
	//
	// example:
	//
	// 0
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The time when the job was complete. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2020-06-28T02:04:47Z
	CompleteTime *string `json:"CompleteTime,omitempty" xml:"CompleteTime,omitempty"`
	// The time when the job was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2020-06-28T02:04:32Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The returned data. The value is a JSON string. For more information, see [AITemplateConfig](https://help.aliyun.com/document_detail/89863.html).
	//
	// example:
	//
	// {"OrigASRData":{"AsrTextList":[{"EndTime":700,"StartTime":0,"Text":"Yes.","ChannelId":0,"SpeechRate":85},{"EndTime":3750,"StartTime":1630,"Text":"No.","ChannelId":0,"SpeechRate":28},{"EndTime":5910,"StartTime":4020,"Text":"Of course.","ChannelId":0,"SpeechRate":95},{"EndTime":12750,"StartTime":10090,"Text":"Message.","ChannelId":0,"SpeechRate":45},{"EndTime":25230,"StartTime":13590,"Text":"Hello, good afternoon.","ChannelId":0,"SpeechRate":20},{"EndTime":30000,"StartTime":28220,"Text":"Yes.","ChannelId":0,"SpeechRate":33}],"Duration":"30016"}}
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The job ID.
	//
	// example:
	//
	// a718a3a1e8bb42ee3bc88921e94****
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The ID of the video file.
	//
	// example:
	//
	// 3D3D12340d9401fab46a0b847****
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The error message. This parameter is returned if the value of Status is fail.
	//
	// example:
	//
	// OK
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The status of the job. Valid values:
	//
	// 	- **success**: The job is successful.
	//
	// 	- **fail**: The job failed.
	//
	// 	- **init**: The job is being initialized.
	//
	// 	- **Processing**: The job is in progress.
	//
	// example:
	//
	// success
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the job. Valid values:
	//
	// 	- **AIMediaDNA**: video fingerprinting
	//
	// 	- **AIVideoTag**: smart tagging
	//
	// example:
	//
	// AIVideoTag
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListAIJobResponseBodyAIJobListAIJob) String() string {
	return tea.Prettify(s)
}

func (s ListAIJobResponseBodyAIJobListAIJob) GoString() string {
	return s.String()
}

func (s *ListAIJobResponseBodyAIJobListAIJob) SetCode(v string) *ListAIJobResponseBodyAIJobListAIJob {
	s.Code = &v
	return s
}

func (s *ListAIJobResponseBodyAIJobListAIJob) SetCompleteTime(v string) *ListAIJobResponseBodyAIJobListAIJob {
	s.CompleteTime = &v
	return s
}

func (s *ListAIJobResponseBodyAIJobListAIJob) SetCreationTime(v string) *ListAIJobResponseBodyAIJobListAIJob {
	s.CreationTime = &v
	return s
}

func (s *ListAIJobResponseBodyAIJobListAIJob) SetData(v string) *ListAIJobResponseBodyAIJobListAIJob {
	s.Data = &v
	return s
}

func (s *ListAIJobResponseBodyAIJobListAIJob) SetJobId(v string) *ListAIJobResponseBodyAIJobListAIJob {
	s.JobId = &v
	return s
}

func (s *ListAIJobResponseBodyAIJobListAIJob) SetMediaId(v string) *ListAIJobResponseBodyAIJobListAIJob {
	s.MediaId = &v
	return s
}

func (s *ListAIJobResponseBodyAIJobListAIJob) SetMessage(v string) *ListAIJobResponseBodyAIJobListAIJob {
	s.Message = &v
	return s
}

func (s *ListAIJobResponseBodyAIJobListAIJob) SetStatus(v string) *ListAIJobResponseBodyAIJobListAIJob {
	s.Status = &v
	return s
}

func (s *ListAIJobResponseBodyAIJobListAIJob) SetType(v string) *ListAIJobResponseBodyAIJobListAIJob {
	s.Type = &v
	return s
}

type ListAIJobResponseBodyNonExistAIJobIds struct {
	String_ []*string `json:"String,omitempty" xml:"String,omitempty" type:"Repeated"`
}

func (s ListAIJobResponseBodyNonExistAIJobIds) String() string {
	return tea.Prettify(s)
}

func (s ListAIJobResponseBodyNonExistAIJobIds) GoString() string {
	return s.String()
}

func (s *ListAIJobResponseBodyNonExistAIJobIds) SetString_(v []*string) *ListAIJobResponseBodyNonExistAIJobIds {
	s.String_ = v
	return s
}

type ListAIJobResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListAIJobResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListAIJobResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAIJobResponse) GoString() string {
	return s.String()
}

func (s *ListAIJobResponse) SetHeaders(v map[string]*string) *ListAIJobResponse {
	s.Headers = v
	return s
}

func (s *ListAIJobResponse) SetStatusCode(v int32) *ListAIJobResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAIJobResponse) SetBody(v *ListAIJobResponseBody) *ListAIJobResponse {
	s.Body = v
	return s
}

type ListAITemplateRequest struct {
	// The type of the AI template. Valid values:
	//
	// 	- **AIMediaAudit**: automated review
	//
	// 	- **AIImage**: smart thumbnail
	//
	// This parameter is required.
	//
	// example:
	//
	// AIMediaAudit
	TemplateType *string `json:"TemplateType,omitempty" xml:"TemplateType,omitempty"`
}

func (s ListAITemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAITemplateRequest) GoString() string {
	return s.String()
}

func (s *ListAITemplateRequest) SetTemplateType(v string) *ListAITemplateRequest {
	s.TemplateType = &v
	return s
}

type ListAITemplateResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 75B7BC67-FB8C-4653-4788-F4B01ED2****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the AI templates.
	TemplateInfoList []*ListAITemplateResponseBodyTemplateInfoList `json:"TemplateInfoList,omitempty" xml:"TemplateInfoList,omitempty" type:"Repeated"`
}

func (s ListAITemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAITemplateResponseBody) GoString() string {
	return s.String()
}

func (s *ListAITemplateResponseBody) SetRequestId(v string) *ListAITemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListAITemplateResponseBody) SetTemplateInfoList(v []*ListAITemplateResponseBodyTemplateInfoList) *ListAITemplateResponseBody {
	s.TemplateInfoList = v
	return s
}

type ListAITemplateResponseBodyTemplateInfoList struct {
	// The time when the AI template was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2020-07-08T06:50:45Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// Indicates whether the template is the default AI template. Valid values:
	//
	// 	- **Default**
	//
	// 	- **NotDefault**
	//
	// example:
	//
	// NoDefault
	IsDefault *string `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	// The time when the AI template was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2020-07-08T06:58:45Z
	ModifyTime *string `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	// The source of the AI template. Valid values:
	//
	// 	- **System**
	//
	// 	- **Custom**
	//
	// example:
	//
	// Custom
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The detailed configurations of the AI template. The value is a JSON string. For more information, see [AITemplateConfig](~~89863#title-vd3-499-o36~~).
	//
	// example:
	//
	// {"AuditRange":["text-title","video"],"AuditContent":["screen"],"AuditItem":["terrorism","porn"],"AuditAutoBlock":"yes"}
	TemplateConfig *string `json:"TemplateConfig,omitempty" xml:"TemplateConfig,omitempty"`
	// The ID of the AI template.
	//
	// example:
	//
	// 1706a0063dd733f6a823ef32e0a5****
	TemplateId *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The name of the AI template.
	//
	// example:
	//
	// DemoAITemplate
	TemplateName *string `json:"TemplateName,omitempty" xml:"TemplateName,omitempty"`
	// The type of the AI template. Valid values:
	//
	// 	- **AIMediaAudit**: automated review
	//
	// 	- **AIImage**: smart thumbnail
	//
	// example:
	//
	// AIMediaAudit
	TemplateType *string `json:"TemplateType,omitempty" xml:"TemplateType,omitempty"`
}

func (s ListAITemplateResponseBodyTemplateInfoList) String() string {
	return tea.Prettify(s)
}

func (s ListAITemplateResponseBodyTemplateInfoList) GoString() string {
	return s.String()
}

func (s *ListAITemplateResponseBodyTemplateInfoList) SetCreationTime(v string) *ListAITemplateResponseBodyTemplateInfoList {
	s.CreationTime = &v
	return s
}

func (s *ListAITemplateResponseBodyTemplateInfoList) SetIsDefault(v string) *ListAITemplateResponseBodyTemplateInfoList {
	s.IsDefault = &v
	return s
}

func (s *ListAITemplateResponseBodyTemplateInfoList) SetModifyTime(v string) *ListAITemplateResponseBodyTemplateInfoList {
	s.ModifyTime = &v
	return s
}

func (s *ListAITemplateResponseBodyTemplateInfoList) SetSource(v string) *ListAITemplateResponseBodyTemplateInfoList {
	s.Source = &v
	return s
}

func (s *ListAITemplateResponseBodyTemplateInfoList) SetTemplateConfig(v string) *ListAITemplateResponseBodyTemplateInfoList {
	s.TemplateConfig = &v
	return s
}

func (s *ListAITemplateResponseBodyTemplateInfoList) SetTemplateId(v string) *ListAITemplateResponseBodyTemplateInfoList {
	s.TemplateId = &v
	return s
}

func (s *ListAITemplateResponseBodyTemplateInfoList) SetTemplateName(v string) *ListAITemplateResponseBodyTemplateInfoList {
	s.TemplateName = &v
	return s
}

func (s *ListAITemplateResponseBodyTemplateInfoList) SetTemplateType(v string) *ListAITemplateResponseBodyTemplateInfoList {
	s.TemplateType = &v
	return s
}

type ListAITemplateResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListAITemplateResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListAITemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAITemplateResponse) GoString() string {
	return s.String()
}

func (s *ListAITemplateResponse) SetHeaders(v map[string]*string) *ListAITemplateResponse {
	s.Headers = v
	return s
}

func (s *ListAITemplateResponse) SetStatusCode(v int32) *ListAITemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAITemplateResponse) SetBody(v *ListAITemplateResponseBody) *ListAITemplateResponse {
	s.Body = v
	return s
}

type ListAppInfoRequest struct {
	// The page number. Default value: **1**.
	//
	// example:
	//
	// 1
	PageNo *int32 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The number of entries per page. Default value: **10**. Maximum value: **100**.
	//
	// example:
	//
	// 10
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The resource group ID to which the instance belongs.
	//
	// example:
	//
	// rg-aekzko7fsuj****
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The status of the application. You can specify the status of the applications that you want to query. After an application is created, it enters the **Normal*	- state. Valid values:
	//
	// 	- **Normal**
	//
	// 	- **Disable**
	//
	// example:
	//
	// Normal
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListAppInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAppInfoRequest) GoString() string {
	return s.String()
}

func (s *ListAppInfoRequest) SetPageNo(v int32) *ListAppInfoRequest {
	s.PageNo = &v
	return s
}

func (s *ListAppInfoRequest) SetPageSize(v int32) *ListAppInfoRequest {
	s.PageSize = &v
	return s
}

func (s *ListAppInfoRequest) SetResourceGroupId(v string) *ListAppInfoRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ListAppInfoRequest) SetStatus(v string) *ListAppInfoRequest {
	s.Status = &v
	return s
}

type ListAppInfoResponseBody struct {
	// The details of applications.
	AppInfoList []*ListAppInfoResponseBodyAppInfoList `json:"AppInfoList,omitempty" xml:"AppInfoList,omitempty" type:"Repeated"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A13-4D5C-D7393642****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	//
	// example:
	//
	// 10
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListAppInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAppInfoResponseBody) GoString() string {
	return s.String()
}

func (s *ListAppInfoResponseBody) SetAppInfoList(v []*ListAppInfoResponseBodyAppInfoList) *ListAppInfoResponseBody {
	s.AppInfoList = v
	return s
}

func (s *ListAppInfoResponseBody) SetRequestId(v string) *ListAppInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListAppInfoResponseBody) SetTotal(v int32) *ListAppInfoResponseBody {
	s.Total = &v
	return s
}

type ListAppInfoResponseBodyAppInfoList struct {
	// The ID of the application.
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	//
	// example:
	//
	// test
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The time when the application was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-03-01T08:00:00Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the application.
	//
	// example:
	//
	// my first app.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The last time when the application was modified. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-03-01T09:00:00Z
	ModificationTime *string `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	// The region.
	//
	// example:
	//
	// cn-shanghai
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource group.
	//
	// example:
	//
	// rg-aekzko7fsuj****
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The status of the application. Valid values:
	//
	// 	- **Normal**
	//
	// 	- **Disable**
	//
	// example:
	//
	// Normal
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the application. Valid values:
	//
	// 	- **System**
	//
	// 	- **Custom**
	//
	// example:
	//
	// System
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListAppInfoResponseBodyAppInfoList) String() string {
	return tea.Prettify(s)
}

func (s ListAppInfoResponseBodyAppInfoList) GoString() string {
	return s.String()
}

func (s *ListAppInfoResponseBodyAppInfoList) SetAppId(v string) *ListAppInfoResponseBodyAppInfoList {
	s.AppId = &v
	return s
}

func (s *ListAppInfoResponseBodyAppInfoList) SetAppName(v string) *ListAppInfoResponseBodyAppInfoList {
	s.AppName = &v
	return s
}

func (s *ListAppInfoResponseBodyAppInfoList) SetCreationTime(v string) *ListAppInfoResponseBodyAppInfoList {
	s.CreationTime = &v
	return s
}

func (s *ListAppInfoResponseBodyAppInfoList) SetDescription(v string) *ListAppInfoResponseBodyAppInfoList {
	s.Description = &v
	return s
}

func (s *ListAppInfoResponseBodyAppInfoList) SetModificationTime(v string) *ListAppInfoResponseBodyAppInfoList {
	s.ModificationTime = &v
	return s
}

func (s *ListAppInfoResponseBodyAppInfoList) SetRegionId(v string) *ListAppInfoResponseBodyAppInfoList {
	s.RegionId = &v
	return s
}

func (s *ListAppInfoResponseBodyAppInfoList) SetResourceGroupId(v string) *ListAppInfoResponseBodyAppInfoList {
	s.ResourceGroupId = &v
	return s
}

func (s *ListAppInfoResponseBodyAppInfoList) SetStatus(v string) *ListAppInfoResponseBodyAppInfoList {
	s.Status = &v
	return s
}

func (s *ListAppInfoResponseBodyAppInfoList) SetType(v string) *ListAppInfoResponseBodyAppInfoList {
	s.Type = &v
	return s
}

type ListAppInfoResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListAppInfoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListAppInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAppInfoResponse) GoString() string {
	return s.String()
}

func (s *ListAppInfoResponse) SetHeaders(v map[string]*string) *ListAppInfoResponse {
	s.Headers = v
	return s
}

func (s *ListAppInfoResponse) SetStatusCode(v int32) *ListAppInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAppInfoResponse) SetBody(v *ListAppInfoResponseBody) *ListAppInfoResponse {
	s.Body = v
	return s
}

type ListAppPoliciesForIdentityRequest struct {
	// The ID of the application. Default value: **app-1000000**. For more information, see [Overview](https://help.aliyun.com/document_detail/113600.html).
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the identity.
	//
	// 	- Specifies the ID of the RAM user when the IdentityType parameter is set to RamUser.
	//
	// 	- Specifies the name of the RAM role when the IdentityType parameter is set to RamRole.
	//
	// example:
	//
	// test****name
	IdentityName *string `json:"IdentityName,omitempty" xml:"IdentityName,omitempty"`
	// The type of the identity. Valid values:
	//
	// 	- **RamUser**: a RAM user.
	//
	// 	- **RamRole**: a RAM role.
	//
	// example:
	//
	// RamUser
	IdentityType *string `json:"IdentityType,omitempty" xml:"IdentityType,omitempty"`
}

func (s ListAppPoliciesForIdentityRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAppPoliciesForIdentityRequest) GoString() string {
	return s.String()
}

func (s *ListAppPoliciesForIdentityRequest) SetAppId(v string) *ListAppPoliciesForIdentityRequest {
	s.AppId = &v
	return s
}

func (s *ListAppPoliciesForIdentityRequest) SetIdentityName(v string) *ListAppPoliciesForIdentityRequest {
	s.IdentityName = &v
	return s
}

func (s *ListAppPoliciesForIdentityRequest) SetIdentityType(v string) *ListAppPoliciesForIdentityRequest {
	s.IdentityType = &v
	return s
}

type ListAppPoliciesForIdentityResponseBody struct {
	// The details of each policy.
	//
	// > A maximum of 100 entries can be returned.
	AppPolicyList []*ListAppPoliciesForIdentityResponseBodyAppPolicyList `json:"AppPolicyList,omitempty" xml:"AppPolicyList,omitempty" type:"Repeated"`
	// The ID of the request.
	//
	// example:
	//
	// C9F3E715-B3B8-4D*****27-3A70346F0E04
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListAppPoliciesForIdentityResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAppPoliciesForIdentityResponseBody) GoString() string {
	return s.String()
}

func (s *ListAppPoliciesForIdentityResponseBody) SetAppPolicyList(v []*ListAppPoliciesForIdentityResponseBodyAppPolicyList) *ListAppPoliciesForIdentityResponseBody {
	s.AppPolicyList = v
	return s
}

func (s *ListAppPoliciesForIdentityResponseBody) SetRequestId(v string) *ListAppPoliciesForIdentityResponseBody {
	s.RequestId = &v
	return s
}

type ListAppPoliciesForIdentityResponseBodyAppPolicyList struct {
	// The ID of the application.
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The time when the application policy was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-01-01T01:01:01Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the policy.
	//
	// example:
	//
	// App full access permission
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The last time when the application policy was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-01-01T01:08:01Z
	ModificationTime *string `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	// The name of the policy.
	//
	// example:
	//
	// VODAppFullAccess
	PolicyName *string `json:"PolicyName,omitempty" xml:"PolicyName,omitempty"`
	// The type of the policy. Valid values:
	//
	// 	- **System**
	//
	// 	- **Custom**
	//
	// example:
	//
	// System
	PolicyType *string `json:"PolicyType,omitempty" xml:"PolicyType,omitempty"`
	// The content of the policy.
	//
	// example:
	//
	// ****
	PolicyValue *string `json:"PolicyValue,omitempty" xml:"PolicyValue,omitempty"`
}

func (s ListAppPoliciesForIdentityResponseBodyAppPolicyList) String() string {
	return tea.Prettify(s)
}

func (s ListAppPoliciesForIdentityResponseBodyAppPolicyList) GoString() string {
	return s.String()
}

func (s *ListAppPoliciesForIdentityResponseBodyAppPolicyList) SetAppId(v string) *ListAppPoliciesForIdentityResponseBodyAppPolicyList {
	s.AppId = &v
	return s
}

func (s *ListAppPoliciesForIdentityResponseBodyAppPolicyList) SetCreationTime(v string) *ListAppPoliciesForIdentityResponseBodyAppPolicyList {
	s.CreationTime = &v
	return s
}

func (s *ListAppPoliciesForIdentityResponseBodyAppPolicyList) SetDescription(v string) *ListAppPoliciesForIdentityResponseBodyAppPolicyList {
	s.Description = &v
	return s
}

func (s *ListAppPoliciesForIdentityResponseBodyAppPolicyList) SetModificationTime(v string) *ListAppPoliciesForIdentityResponseBodyAppPolicyList {
	s.ModificationTime = &v
	return s
}

func (s *ListAppPoliciesForIdentityResponseBodyAppPolicyList) SetPolicyName(v string) *ListAppPoliciesForIdentityResponseBodyAppPolicyList {
	s.PolicyName = &v
	return s
}

func (s *ListAppPoliciesForIdentityResponseBodyAppPolicyList) SetPolicyType(v string) *ListAppPoliciesForIdentityResponseBodyAppPolicyList {
	s.PolicyType = &v
	return s
}

func (s *ListAppPoliciesForIdentityResponseBodyAppPolicyList) SetPolicyValue(v string) *ListAppPoliciesForIdentityResponseBodyAppPolicyList {
	s.PolicyValue = &v
	return s
}

type ListAppPoliciesForIdentityResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListAppPoliciesForIdentityResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListAppPoliciesForIdentityResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAppPoliciesForIdentityResponse) GoString() string {
	return s.String()
}

func (s *ListAppPoliciesForIdentityResponse) SetHeaders(v map[string]*string) *ListAppPoliciesForIdentityResponse {
	s.Headers = v
	return s
}

func (s *ListAppPoliciesForIdentityResponse) SetStatusCode(v int32) *ListAppPoliciesForIdentityResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAppPoliciesForIdentityResponse) SetBody(v *ListAppPoliciesForIdentityResponseBody) *ListAppPoliciesForIdentityResponse {
	s.Body = v
	return s
}

type ListAuditSecurityIpRequest struct {
	// The name of the review security group in which you want to query IP addresses. If you do not specify this parameter, IP addresses in all review security groups are queried.
	//
	// example:
	//
	// Default
	SecurityGroupName *string `json:"SecurityGroupName,omitempty" xml:"SecurityGroupName,omitempty"`
}

func (s ListAuditSecurityIpRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAuditSecurityIpRequest) GoString() string {
	return s.String()
}

func (s *ListAuditSecurityIpRequest) SetSecurityGroupName(v string) *ListAuditSecurityIpRequest {
	s.SecurityGroupName = &v
	return s
}

type ListAuditSecurityIpResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 664BBD08-C7DB-4E*****73-9D0958D9A899
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The details of the review security group.
	SecurityIpList []*ListAuditSecurityIpResponseBodySecurityIpList `json:"SecurityIpList,omitempty" xml:"SecurityIpList,omitempty" type:"Repeated"`
}

func (s ListAuditSecurityIpResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAuditSecurityIpResponseBody) GoString() string {
	return s.String()
}

func (s *ListAuditSecurityIpResponseBody) SetRequestId(v string) *ListAuditSecurityIpResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListAuditSecurityIpResponseBody) SetSecurityIpList(v []*ListAuditSecurityIpResponseBodySecurityIpList) *ListAuditSecurityIpResponseBody {
	s.SecurityIpList = v
	return s
}

type ListAuditSecurityIpResponseBodySecurityIpList struct {
	// The time when the review security group was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2018-05-22T06:54:23Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The IP addresses in the review security group.
	//
	// example:
	//
	// 30.27.14.0/24,30.39.127.245
	Ips *string `json:"Ips,omitempty" xml:"Ips,omitempty"`
	// The time when the review security group was last modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2018-05-22T06:55:14Z
	ModificationTime *string `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	// The name of the review security group.
	//
	// example:
	//
	// Default
	SecurityGroupName *string `json:"SecurityGroupName,omitempty" xml:"SecurityGroupName,omitempty"`
}

func (s ListAuditSecurityIpResponseBodySecurityIpList) String() string {
	return tea.Prettify(s)
}

func (s ListAuditSecurityIpResponseBodySecurityIpList) GoString() string {
	return s.String()
}

func (s *ListAuditSecurityIpResponseBodySecurityIpList) SetCreationTime(v string) *ListAuditSecurityIpResponseBodySecurityIpList {
	s.CreationTime = &v
	return s
}

func (s *ListAuditSecurityIpResponseBodySecurityIpList) SetIps(v string) *ListAuditSecurityIpResponseBodySecurityIpList {
	s.Ips = &v
	return s
}

func (s *ListAuditSecurityIpResponseBodySecurityIpList) SetModificationTime(v string) *ListAuditSecurityIpResponseBodySecurityIpList {
	s.ModificationTime = &v
	return s
}

func (s *ListAuditSecurityIpResponseBodySecurityIpList) SetSecurityGroupName(v string) *ListAuditSecurityIpResponseBodySecurityIpList {
	s.SecurityGroupName = &v
	return s
}

type ListAuditSecurityIpResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListAuditSecurityIpResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListAuditSecurityIpResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAuditSecurityIpResponse) GoString() string {
	return s.String()
}

func (s *ListAuditSecurityIpResponse) SetHeaders(v map[string]*string) *ListAuditSecurityIpResponse {
	s.Headers = v
	return s
}

func (s *ListAuditSecurityIpResponse) SetStatusCode(v int32) *ListAuditSecurityIpResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAuditSecurityIpResponse) SetBody(v *ListAuditSecurityIpResponseBody) *ListAuditSecurityIpResponse {
	s.Body = v
	return s
}

type ListDynamicImageRequest struct {
	// The ID of the video.
	//
	// This parameter is required.
	//
	// example:
	//
	// 2e114f1100590c3193918fd449a****
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s ListDynamicImageRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDynamicImageRequest) GoString() string {
	return s.String()
}

func (s *ListDynamicImageRequest) SetVideoId(v string) *ListDynamicImageRequest {
	s.VideoId = &v
	return s
}

type ListDynamicImageResponseBody struct {
	// The list of animated stickers.
	DynamicImageList []*ListDynamicImageResponseBodyDynamicImageList `json:"DynamicImageList,omitempty" xml:"DynamicImageList,omitempty" type:"Repeated"`
	// The ID of the request.
	//
	// example:
	//
	// 570189B6-572E-4953-13B4278EE0D8****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListDynamicImageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDynamicImageResponseBody) GoString() string {
	return s.String()
}

func (s *ListDynamicImageResponseBody) SetDynamicImageList(v []*ListDynamicImageResponseBodyDynamicImageList) *ListDynamicImageResponseBody {
	s.DynamicImageList = v
	return s
}

func (s *ListDynamicImageResponseBody) SetRequestId(v string) *ListDynamicImageResponseBody {
	s.RequestId = &v
	return s
}

type ListDynamicImageResponseBodyDynamicImageList struct {
	// The time when the animated sticker was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2020-07-28T02:01:06Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The duration of the animated sticker. Unit: seconds.
	//
	// example:
	//
	// 2
	Duration *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The ID of the animated sticker.
	//
	// example:
	//
	// 2b4e51df60323ef43d6e336ecf****
	DynamicImageId *string `json:"DynamicImageId,omitempty" xml:"DynamicImageId,omitempty"`
	// The size of the animated sticker file. Unit: byte.
	//
	// example:
	//
	// 119866
	FileSize *string `json:"FileSize,omitempty" xml:"FileSize,omitempty"`
	// The URL of the animated sticker file.
	//
	// example:
	//
	// https://example.aliyundoc.com/2e114f110059*****0c3193918fd449a/image/dynamic/2b4e51df60*****323ef43d6e336ecf.webp?auth_key=1597296785-0-0-4a48e85*****bd2bb358e0b3cade
	FileURL *string `json:"FileURL,omitempty" xml:"FileURL,omitempty"`
	// The format of the animated sticker. Valid values: gif and webp.
	//
	// example:
	//
	// webp
	Format *string `json:"Format,omitempty" xml:"Format,omitempty"`
	// The frame rate of the animated sticker. Unit: frames per second.
	//
	// example:
	//
	// 10
	Fps *string `json:"Fps,omitempty" xml:"Fps,omitempty"`
	// The height of the animated sticker. Unit: pixel.
	//
	// example:
	//
	// 360
	Height *string `json:"Height,omitempty" xml:"Height,omitempty"`
	// The job ID for creating the animated sticker.
	//
	// example:
	//
	// 2bf4390af9e5491c09cc720ad****
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The ID of the video.
	//
	// example:
	//
	// 2e114f1100590c3193918fd449a****
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
	// The width of the animated sticker. Unit: pixel.
	//
	// example:
	//
	// 640
	Width *string `json:"Width,omitempty" xml:"Width,omitempty"`
}

func (s ListDynamicImageResponseBodyDynamicImageList) String() string {
	return tea.Prettify(s)
}

func (s ListDynamicImageResponseBodyDynamicImageList) GoString() string {
	return s.String()
}

func (s *ListDynamicImageResponseBodyDynamicImageList) SetCreationTime(v string) *ListDynamicImageResponseBodyDynamicImageList {
	s.CreationTime = &v
	return s
}

func (s *ListDynamicImageResponseBodyDynamicImageList) SetDuration(v string) *ListDynamicImageResponseBodyDynamicImageList {
	s.Duration = &v
	return s
}

func (s *ListDynamicImageResponseBodyDynamicImageList) SetDynamicImageId(v string) *ListDynamicImageResponseBodyDynamicImageList {
	s.DynamicImageId = &v
	return s
}

func (s *ListDynamicImageResponseBodyDynamicImageList) SetFileSize(v string) *ListDynamicImageResponseBodyDynamicImageList {
	s.FileSize = &v
	return s
}

func (s *ListDynamicImageResponseBodyDynamicImageList) SetFileURL(v string) *ListDynamicImageResponseBodyDynamicImageList {
	s.FileURL = &v
	return s
}

func (s *ListDynamicImageResponseBodyDynamicImageList) SetFormat(v string) *ListDynamicImageResponseBodyDynamicImageList {
	s.Format = &v
	return s
}

func (s *ListDynamicImageResponseBodyDynamicImageList) SetFps(v string) *ListDynamicImageResponseBodyDynamicImageList {
	s.Fps = &v
	return s
}

func (s *ListDynamicImageResponseBodyDynamicImageList) SetHeight(v string) *ListDynamicImageResponseBodyDynamicImageList {
	s.Height = &v
	return s
}

func (s *ListDynamicImageResponseBodyDynamicImageList) SetJobId(v string) *ListDynamicImageResponseBodyDynamicImageList {
	s.JobId = &v
	return s
}

func (s *ListDynamicImageResponseBodyDynamicImageList) SetVideoId(v string) *ListDynamicImageResponseBodyDynamicImageList {
	s.VideoId = &v
	return s
}

func (s *ListDynamicImageResponseBodyDynamicImageList) SetWidth(v string) *ListDynamicImageResponseBodyDynamicImageList {
	s.Width = &v
	return s
}

type ListDynamicImageResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListDynamicImageResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListDynamicImageResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDynamicImageResponse) GoString() string {
	return s.String()
}

func (s *ListDynamicImageResponse) SetHeaders(v map[string]*string) *ListDynamicImageResponse {
	s.Headers = v
	return s
}

func (s *ListDynamicImageResponse) SetStatusCode(v int32) *ListDynamicImageResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDynamicImageResponse) SetBody(v *ListDynamicImageResponseBody) *ListDynamicImageResponse {
	s.Body = v
	return s
}

type ListJobInfoRequest struct {
	// The type of the task. Valid values:
	//
	// 	- transcode
	//
	// 	- snapshot
	//
	// 	- ai
	//
	// This parameter is required.
	//
	// example:
	//
	// transcode
	JobType *string `json:"JobType,omitempty" xml:"JobType,omitempty"`
	// The ID of the media asset.
	//
	// This parameter is required.
	//
	// example:
	//
	// 30e5d7**********bd900764de7c0102
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
}

func (s ListJobInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s ListJobInfoRequest) GoString() string {
	return s.String()
}

func (s *ListJobInfoRequest) SetJobType(v string) *ListJobInfoRequest {
	s.JobType = &v
	return s
}

func (s *ListJobInfoRequest) SetMediaId(v string) *ListJobInfoRequest {
	s.MediaId = &v
	return s
}

type ListJobInfoResponseBody struct {
	// The historical tasks of the last 6 months.
	JobInfoList []*ListJobInfoResponseBodyJobInfoList `json:"JobInfoList,omitempty" xml:"JobInfoList,omitempty" type:"Repeated"`
	// The type of the task. Valid values:
	//
	// 	- transcode
	//
	// 	- snapshot
	//
	// 	- ai
	//
	// example:
	//
	// transcode
	JobType *string `json:"JobType,omitempty" xml:"JobType,omitempty"`
	// The ID of the media asset.
	//
	// example:
	//
	// 30e5d7**********bd900764de7c0102
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The request ID.
	//
	// example:
	//
	// 6708D849-F109-1A6C-AC91-************
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListJobInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListJobInfoResponseBody) GoString() string {
	return s.String()
}

func (s *ListJobInfoResponseBody) SetJobInfoList(v []*ListJobInfoResponseBodyJobInfoList) *ListJobInfoResponseBody {
	s.JobInfoList = v
	return s
}

func (s *ListJobInfoResponseBody) SetJobType(v string) *ListJobInfoResponseBody {
	s.JobType = &v
	return s
}

func (s *ListJobInfoResponseBody) SetMediaId(v string) *ListJobInfoResponseBody {
	s.MediaId = &v
	return s
}

func (s *ListJobInfoResponseBody) SetRequestId(v string) *ListJobInfoResponseBody {
	s.RequestId = &v
	return s
}

type ListJobInfoResponseBodyJobInfoList struct {
	// The time when the task was complete.
	//
	// example:
	//
	// 2024-10-14T07:39:34Z
	CompleteTime *string `json:"CompleteTime,omitempty" xml:"CompleteTime,omitempty"`
	// The time when the task was created. The time follows the ISO 8601 standard in the YYYY-MM-DDTHH:mm:ssZ format. The time is displayed in UTC.
	//
	// example:
	//
	// 2024-10-14T07:39:25Z
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the task.
	//
	// example:
	//
	// 5c9dff751ba**********59d50a967f5
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The status of the task.
	//
	// example:
	//
	// TranscodeSuccess
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the user who submitted the task.
	//
	// example:
	//
	// 139109*****84930
	UserId *int64 `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s ListJobInfoResponseBodyJobInfoList) String() string {
	return tea.Prettify(s)
}

func (s ListJobInfoResponseBodyJobInfoList) GoString() string {
	return s.String()
}

func (s *ListJobInfoResponseBodyJobInfoList) SetCompleteTime(v string) *ListJobInfoResponseBodyJobInfoList {
	s.CompleteTime = &v
	return s
}

func (s *ListJobInfoResponseBodyJobInfoList) SetCreateTime(v string) *ListJobInfoResponseBodyJobInfoList {
	s.CreateTime = &v
	return s
}

func (s *ListJobInfoResponseBodyJobInfoList) SetJobId(v string) *ListJobInfoResponseBodyJobInfoList {
	s.JobId = &v
	return s
}

func (s *ListJobInfoResponseBodyJobInfoList) SetStatus(v string) *ListJobInfoResponseBodyJobInfoList {
	s.Status = &v
	return s
}

func (s *ListJobInfoResponseBodyJobInfoList) SetUserId(v int64) *ListJobInfoResponseBodyJobInfoList {
	s.UserId = &v
	return s
}

type ListJobInfoResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListJobInfoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListJobInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s ListJobInfoResponse) GoString() string {
	return s.String()
}

func (s *ListJobInfoResponse) SetHeaders(v map[string]*string) *ListJobInfoResponse {
	s.Headers = v
	return s
}

func (s *ListJobInfoResponse) SetStatusCode(v int32) *ListJobInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *ListJobInfoResponse) SetBody(v *ListJobInfoResponseBody) *ListJobInfoResponse {
	s.Body = v
	return s
}

type ListLiveRecordVideoRequest struct {
	// The name of the application that was used to record the live stream.
	//
	// example:
	//
	// testApp
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The domain name of the recorded live stream.
	//
	// example:
	//
	// example.aliyundoc.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. The query is performed based on the time range during which the required live streams were recorded. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// example:
	//
	// 2017-01-11T13:00:00Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The number of the page to return. Default value: **1**.
	//
	// example:
	//
	// 1
	PageNo *int32 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The number of entries to return on each page. Maximum value: **100**. Default value: **10**.
	//
	// example:
	//
	// 10
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The sorting rule of the results. Valid values:
	//
	// 	- **CreationTime:Desc**: The results are sorted in reverse chronological order based on the creation time.
	//
	// 	- **CreationTime:Asc**: The results are sorted in chronological order based on the creation time.
	//
	// example:
	//
	// CreationTime:Desc
	SortBy *string `json:"SortBy,omitempty" xml:"SortBy,omitempty"`
	// The beginning of the time range to query. The query is performed based on the time range during which the required live streams were recorded. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// example:
	//
	// 2017-01-11T12:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The name of the recorded live stream.
	//
	// example:
	//
	// live-test
	StreamName *string `json:"StreamName,omitempty" xml:"StreamName,omitempty"`
}

func (s ListLiveRecordVideoRequest) String() string {
	return tea.Prettify(s)
}

func (s ListLiveRecordVideoRequest) GoString() string {
	return s.String()
}

func (s *ListLiveRecordVideoRequest) SetAppName(v string) *ListLiveRecordVideoRequest {
	s.AppName = &v
	return s
}

func (s *ListLiveRecordVideoRequest) SetDomainName(v string) *ListLiveRecordVideoRequest {
	s.DomainName = &v
	return s
}

func (s *ListLiveRecordVideoRequest) SetEndTime(v string) *ListLiveRecordVideoRequest {
	s.EndTime = &v
	return s
}

func (s *ListLiveRecordVideoRequest) SetPageNo(v int32) *ListLiveRecordVideoRequest {
	s.PageNo = &v
	return s
}

func (s *ListLiveRecordVideoRequest) SetPageSize(v int32) *ListLiveRecordVideoRequest {
	s.PageSize = &v
	return s
}

func (s *ListLiveRecordVideoRequest) SetSortBy(v string) *ListLiveRecordVideoRequest {
	s.SortBy = &v
	return s
}

func (s *ListLiveRecordVideoRequest) SetStartTime(v string) *ListLiveRecordVideoRequest {
	s.StartTime = &v
	return s
}

func (s *ListLiveRecordVideoRequest) SetStreamName(v string) *ListLiveRecordVideoRequest {
	s.StreamName = &v
	return s
}

type ListLiveRecordVideoResponseBody struct {
	// The list of videos.
	LiveRecordVideoList *ListLiveRecordVideoResponseBodyLiveRecordVideoList `json:"LiveRecordVideoList,omitempty" xml:"LiveRecordVideoList,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A13-****-D7393642CA58
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of videos.
	//
	// example:
	//
	// 123
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListLiveRecordVideoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListLiveRecordVideoResponseBody) GoString() string {
	return s.String()
}

func (s *ListLiveRecordVideoResponseBody) SetLiveRecordVideoList(v *ListLiveRecordVideoResponseBodyLiveRecordVideoList) *ListLiveRecordVideoResponseBody {
	s.LiveRecordVideoList = v
	return s
}

func (s *ListLiveRecordVideoResponseBody) SetRequestId(v string) *ListLiveRecordVideoResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListLiveRecordVideoResponseBody) SetTotal(v int32) *ListLiveRecordVideoResponseBody {
	s.Total = &v
	return s
}

type ListLiveRecordVideoResponseBodyLiveRecordVideoList struct {
	LiveRecordVideo []*ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo `json:"LiveRecordVideo,omitempty" xml:"LiveRecordVideo,omitempty" type:"Repeated"`
}

func (s ListLiveRecordVideoResponseBodyLiveRecordVideoList) String() string {
	return tea.Prettify(s)
}

func (s ListLiveRecordVideoResponseBodyLiveRecordVideoList) GoString() string {
	return s.String()
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoList) SetLiveRecordVideo(v []*ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo) *ListLiveRecordVideoResponseBodyLiveRecordVideoList {
	s.LiveRecordVideo = v
	return s
}

type ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo struct {
	// The name of the app.
	//
	// example:
	//
	// testApp
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The domain name.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The ID of the playlist.
	//
	// example:
	//
	// ****
	PlaylistId *string `json:"PlaylistId,omitempty" xml:"PlaylistId,omitempty"`
	// The recording end time. The time is in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-12-08T08:44:56Z
	RecordEndTime *string `json:"RecordEndTime,omitempty" xml:"RecordEndTime,omitempty"`
	// The recording start time. The time is in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-12-08T07:40:56Z
	RecordStartTime *string `json:"RecordStartTime,omitempty" xml:"RecordStartTime,omitempty"`
	// The name of the live-to-VOD file.
	//
	// example:
	//
	// live-test
	StreamName *string `json:"StreamName,omitempty" xml:"StreamName,omitempty"`
	// The information about the live-to-VOD file.
	Video *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo `json:"Video,omitempty" xml:"Video,omitempty" type:"Struct"`
}

func (s ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo) String() string {
	return tea.Prettify(s)
}

func (s ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo) GoString() string {
	return s.String()
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo) SetAppName(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo {
	s.AppName = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo) SetDomainName(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo {
	s.DomainName = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo) SetPlaylistId(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo {
	s.PlaylistId = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo) SetRecordEndTime(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo {
	s.RecordEndTime = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo) SetRecordStartTime(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo {
	s.RecordStartTime = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo) SetStreamName(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo {
	s.StreamName = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo) SetVideo(v *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo {
	s.Video = v
	return s
}

type ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo struct {
	// The ID of the video category.
	//
	// example:
	//
	// 78
	CateId *int32 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The category of the video.
	//
	// example:
	//
	// Category name
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	// The URL of the video thumbnail.
	//
	// example:
	//
	// https://example.aliyundoc.com/coversample.jpg
	CoverURL *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	// The time when the audio or video file was created. The time is in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-12-08T07:40:56Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the video file.
	//
	// example:
	//
	// Description of the ApsaraVideo VOD video
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The duration of the video file. Unit: seconds.
	//
	// example:
	//
	// 135.6
	Duration *float32 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The time when the video was updated. The time is in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-12-08T09:40:56Z
	ModifyTime *string `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	// The size of the source video file. Unit: bytes.
	//
	// example:
	//
	// 10897890
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The array of video snapshot URLs.
	Snapshots *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideoSnapshots `json:"Snapshots,omitempty" xml:"Snapshots,omitempty" type:"Struct"`
	// The status of the video. Valid values:
	//
	// 	- **Uploading**
	//
	// 	- **UploadFail**
	//
	// 	- **UploadSuccess**
	//
	// 	- **Transcoding**
	//
	// 	- **TranscodeFail**
	//
	// 	- **Blocked**
	//
	// 	- **Normal**: The video is normal.
	//
	// example:
	//
	// Normal
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tags of the video. Multiple tags are separated with commas (,).
	//
	// example:
	//
	// tag1, tag2
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The ID of the transcoding template group.
	//
	// example:
	//
	// 1
	TemplateGroupId *string `json:"TemplateGroupId,omitempty" xml:"TemplateGroupId,omitempty"`
	// The title of the video.
	//
	// example:
	//
	// Title of the ApsaraVideo VOD video
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The ID of the video.
	//
	// example:
	//
	// 93ab850b4f6f*****54b6e91d24d81d4
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) String() string {
	return tea.Prettify(s)
}

func (s ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) GoString() string {
	return s.String()
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) SetCateId(v int32) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo {
	s.CateId = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) SetCateName(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo {
	s.CateName = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) SetCoverURL(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo {
	s.CoverURL = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) SetCreationTime(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo {
	s.CreationTime = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) SetDescription(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo {
	s.Description = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) SetDuration(v float32) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo {
	s.Duration = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) SetModifyTime(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo {
	s.ModifyTime = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) SetSize(v int64) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo {
	s.Size = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) SetSnapshots(v *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideoSnapshots) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo {
	s.Snapshots = v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) SetStatus(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo {
	s.Status = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) SetTags(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo {
	s.Tags = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) SetTemplateGroupId(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo {
	s.TemplateGroupId = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) SetTitle(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo {
	s.Title = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) SetVideoId(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo {
	s.VideoId = &v
	return s
}

type ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideoSnapshots struct {
	Snapshot []*string `json:"Snapshot,omitempty" xml:"Snapshot,omitempty" type:"Repeated"`
}

func (s ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideoSnapshots) String() string {
	return tea.Prettify(s)
}

func (s ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideoSnapshots) GoString() string {
	return s.String()
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideoSnapshots) SetSnapshot(v []*string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideoSnapshots {
	s.Snapshot = v
	return s
}

type ListLiveRecordVideoResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListLiveRecordVideoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListLiveRecordVideoResponse) String() string {
	return tea.Prettify(s)
}

func (s ListLiveRecordVideoResponse) GoString() string {
	return s.String()
}

func (s *ListLiveRecordVideoResponse) SetHeaders(v map[string]*string) *ListLiveRecordVideoResponse {
	s.Headers = v
	return s
}

func (s *ListLiveRecordVideoResponse) SetStatusCode(v int32) *ListLiveRecordVideoResponse {
	s.StatusCode = &v
	return s
}

func (s *ListLiveRecordVideoResponse) SetBody(v *ListLiveRecordVideoResponseBody) *ListLiveRecordVideoResponse {
	s.Body = v
	return s
}

type ListSnapshotsRequest struct {
	// The validity period of the snapshot URL. Default value: **3600**. Minimum value: **3600**. Unit: seconds.
	//
	// 	- This parameter takes effect only when you enable URL signing. For more information, see [Configure URL signing](https://help.aliyun.com/document_detail/57007.html).
	//
	// 	- If you specify a value smaller than **3,600 seconds**, **3600*	- is used by default.
	//
	// 	- If the snapshot URL is an Object Storage Service (OSS) URL, the maximum value for this parameter is **2592000*	- (30 days). This reduces risks on the origin.
	//
	// example:
	//
	// 3600
	AuthTimeout *string `json:"AuthTimeout,omitempty" xml:"AuthTimeout,omitempty"`
	// The page number. Default value: **1**.
	//
	// example:
	//
	// 1
	PageNo *string `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The number of entries per page. Default value: **20**. Maximum value: **100**.
	//
	// example:
	//
	// 20
	PageSize *string `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The type of snapshots to return. Valid values:
	//
	// 	- **CoverSnapshot**: thumbnail snapshot
	//
	// 	- **NormalSnapshot**: regular snapshot
	//
	// 	- **SpriteSnapshot**: sprite snapshot
	//
	// 	- **SpriteOriginSnapshot**: sprite source snapshot
	//
	// 	- **WebVttSnapshot**: WebVTT snapshot
	//
	// example:
	//
	// CoverSnapshot
	SnapshotType *string `json:"SnapshotType,omitempty" xml:"SnapshotType,omitempty"`
	// The ID of the video. You can use one of the following methods to obtain the ID:
	//
	// 	- Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Media Files*	- > **Audio/Video*	- to view the video ID.
	//
	// 	- Obtain the video ID from the response to the [CreateUploadVideo](~~CreateUploadVideo~~) operation that you call to obtain the upload URL and credential.
	//
	// 	- Obtain the video ID from the response to the [SearchMedia](~~SearchMedia~~) operation that you call to query videos.
	//
	// This parameter is required.
	//
	// example:
	//
	// d3e680e618708fbf2cae7cc931****
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s ListSnapshotsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListSnapshotsRequest) GoString() string {
	return s.String()
}

func (s *ListSnapshotsRequest) SetAuthTimeout(v string) *ListSnapshotsRequest {
	s.AuthTimeout = &v
	return s
}

func (s *ListSnapshotsRequest) SetPageNo(v string) *ListSnapshotsRequest {
	s.PageNo = &v
	return s
}

func (s *ListSnapshotsRequest) SetPageSize(v string) *ListSnapshotsRequest {
	s.PageSize = &v
	return s
}

func (s *ListSnapshotsRequest) SetSnapshotType(v string) *ListSnapshotsRequest {
	s.SnapshotType = &v
	return s
}

func (s *ListSnapshotsRequest) SetVideoId(v string) *ListSnapshotsRequest {
	s.VideoId = &v
	return s
}

type ListSnapshotsResponseBody struct {
	// The information about the snapshot.
	MediaSnapshot *ListSnapshotsResponseBodyMediaSnapshot `json:"MediaSnapshot,omitempty" xml:"MediaSnapshot,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4AF6-D7393642CA58****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListSnapshotsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListSnapshotsResponseBody) GoString() string {
	return s.String()
}

func (s *ListSnapshotsResponseBody) SetMediaSnapshot(v *ListSnapshotsResponseBodyMediaSnapshot) *ListSnapshotsResponseBody {
	s.MediaSnapshot = v
	return s
}

func (s *ListSnapshotsResponseBody) SetRequestId(v string) *ListSnapshotsResponseBody {
	s.RequestId = &v
	return s
}

type ListSnapshotsResponseBodyMediaSnapshot struct {
	// The time when the snapshot job was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-12-20T12:23:45Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The ID of the snapshot job.
	//
	// example:
	//
	// ad90a501b1b9472374ad005046****
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The rule used to generate snapshot URLs.
	//
	// example:
	//
	// http://example.aliyundoc.com/snapshot/sample{SnapshotCount}.jpg
	Regular *string `json:"Regular,omitempty" xml:"Regular,omitempty"`
	// The details of the snapshot.
	Snapshots *ListSnapshotsResponseBodyMediaSnapshotSnapshots `json:"Snapshots,omitempty" xml:"Snapshots,omitempty" type:"Struct"`
	// The total number of snapshots.
	//
	// example:
	//
	// 100
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListSnapshotsResponseBodyMediaSnapshot) String() string {
	return tea.Prettify(s)
}

func (s ListSnapshotsResponseBodyMediaSnapshot) GoString() string {
	return s.String()
}

func (s *ListSnapshotsResponseBodyMediaSnapshot) SetCreationTime(v string) *ListSnapshotsResponseBodyMediaSnapshot {
	s.CreationTime = &v
	return s
}

func (s *ListSnapshotsResponseBodyMediaSnapshot) SetJobId(v string) *ListSnapshotsResponseBodyMediaSnapshot {
	s.JobId = &v
	return s
}

func (s *ListSnapshotsResponseBodyMediaSnapshot) SetRegular(v string) *ListSnapshotsResponseBodyMediaSnapshot {
	s.Regular = &v
	return s
}

func (s *ListSnapshotsResponseBodyMediaSnapshot) SetSnapshots(v *ListSnapshotsResponseBodyMediaSnapshotSnapshots) *ListSnapshotsResponseBodyMediaSnapshot {
	s.Snapshots = v
	return s
}

func (s *ListSnapshotsResponseBodyMediaSnapshot) SetTotal(v int64) *ListSnapshotsResponseBodyMediaSnapshot {
	s.Total = &v
	return s
}

type ListSnapshotsResponseBodyMediaSnapshotSnapshots struct {
	Snapshot []*ListSnapshotsResponseBodyMediaSnapshotSnapshotsSnapshot `json:"Snapshot,omitempty" xml:"Snapshot,omitempty" type:"Repeated"`
}

func (s ListSnapshotsResponseBodyMediaSnapshotSnapshots) String() string {
	return tea.Prettify(s)
}

func (s ListSnapshotsResponseBodyMediaSnapshotSnapshots) GoString() string {
	return s.String()
}

func (s *ListSnapshotsResponseBodyMediaSnapshotSnapshots) SetSnapshot(v []*ListSnapshotsResponseBodyMediaSnapshotSnapshotsSnapshot) *ListSnapshotsResponseBodyMediaSnapshotSnapshots {
	s.Snapshot = v
	return s
}

type ListSnapshotsResponseBodyMediaSnapshotSnapshotsSnapshot struct {
	// The index of the snapshot.
	//
	// example:
	//
	// 1
	Index *int64 `json:"Index,omitempty" xml:"Index,omitempty"`
	// The URL of the snapshot.
	//
	// example:
	//
	// http://example.aliyundoc.com/snapshot/sample00001****.jpg
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s ListSnapshotsResponseBodyMediaSnapshotSnapshotsSnapshot) String() string {
	return tea.Prettify(s)
}

func (s ListSnapshotsResponseBodyMediaSnapshotSnapshotsSnapshot) GoString() string {
	return s.String()
}

func (s *ListSnapshotsResponseBodyMediaSnapshotSnapshotsSnapshot) SetIndex(v int64) *ListSnapshotsResponseBodyMediaSnapshotSnapshotsSnapshot {
	s.Index = &v
	return s
}

func (s *ListSnapshotsResponseBodyMediaSnapshotSnapshotsSnapshot) SetUrl(v string) *ListSnapshotsResponseBodyMediaSnapshotSnapshotsSnapshot {
	s.Url = &v
	return s
}

type ListSnapshotsResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListSnapshotsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListSnapshotsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListSnapshotsResponse) GoString() string {
	return s.String()
}

func (s *ListSnapshotsResponse) SetHeaders(v map[string]*string) *ListSnapshotsResponse {
	s.Headers = v
	return s
}

func (s *ListSnapshotsResponse) SetStatusCode(v int32) *ListSnapshotsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListSnapshotsResponse) SetBody(v *ListSnapshotsResponseBody) *ListSnapshotsResponse {
	s.Body = v
	return s
}

type ListTranscodeTaskRequest struct {
	// The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// example:
	//
	// 2019-01-23T12:40:12Z
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The number of the page to return. You can specify a page number to return data from the specified page. Default value: **1**.
	//
	// example:
	//
	// 1
	PageNo *int32 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	//
	// example:
	//
	// 10
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// example:
	//
	// 2019-01-23T12:35:12Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The ID of the audio or video file. You can use one of the following methods to obtain the ID of the file:
	//
	// 	- Log on to the [ApsaraVideo VOD](https://vod.console.aliyun.com) console. In the left-side navigation pane, choose **Media Files*	- > **Audio/Video**. On the Video and Audio page, view the ID of the audio or video file. This method is applicable to files that are uploaded by using the ApsaraVideo VOD console.
	//
	// 	- Obtain the value of VideoId from the response to the [CreateUploadVideo](https://help.aliyun.com/document_detail/55407.html) operation that you call to obtain the upload URL and credential.
	//
	// 	- Obtain the value of VideoId by calling the [SearchMedia](https://help.aliyun.com/document_detail/86044.html) operation. This method is applicable to files that have been uploaded.
	//
	// This parameter is required.
	//
	// example:
	//
	// d4860fcc6a5*****bce9fed52e893824
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s ListTranscodeTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTranscodeTaskRequest) GoString() string {
	return s.String()
}

func (s *ListTranscodeTaskRequest) SetEndTime(v string) *ListTranscodeTaskRequest {
	s.EndTime = &v
	return s
}

func (s *ListTranscodeTaskRequest) SetPageNo(v int32) *ListTranscodeTaskRequest {
	s.PageNo = &v
	return s
}

func (s *ListTranscodeTaskRequest) SetPageSize(v int32) *ListTranscodeTaskRequest {
	s.PageSize = &v
	return s
}

func (s *ListTranscodeTaskRequest) SetStartTime(v string) *ListTranscodeTaskRequest {
	s.StartTime = &v
	return s
}

func (s *ListTranscodeTaskRequest) SetVideoId(v string) *ListTranscodeTaskRequest {
	s.VideoId = &v
	return s
}

type ListTranscodeTaskResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A*****F6-D7393642CA58
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Details about transcoding tasks.
	TranscodeTaskList []*ListTranscodeTaskResponseBodyTranscodeTaskList `json:"TranscodeTaskList,omitempty" xml:"TranscodeTaskList,omitempty" type:"Repeated"`
}

func (s ListTranscodeTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTranscodeTaskResponseBody) GoString() string {
	return s.String()
}

func (s *ListTranscodeTaskResponseBody) SetRequestId(v string) *ListTranscodeTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTranscodeTaskResponseBody) SetTranscodeTaskList(v []*ListTranscodeTaskResponseBodyTranscodeTaskList) *ListTranscodeTaskResponseBody {
	s.TranscodeTaskList = v
	return s
}

type ListTranscodeTaskResponseBodyTranscodeTaskList struct {
	// The time when the transcoding task was complete. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-01-23T12:40:12Z
	CompleteTime *string `json:"CompleteTime,omitempty" xml:"CompleteTime,omitempty"`
	// The time when the transcoding task was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2019-01-23T12:35:12Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The status of the transcoding task. Valid values:
	//
	// 	- **Processing**: In progress.
	//
	// 	- **Partial**: Some transcoding jobs were complete.
	//
	// 	- **CompleteAllSucc**: All transcoding jobs were successful.
	//
	// 	- **CompleteAllFail**: All transcoding jobs failed. If an exception occurs in the source file, no transcoding job is initiated and the transcoding task fails.
	//
	// 	- **CompletePartialSucc**: All transcoding jobs were complete but only some were successful.
	//
	// example:
	//
	// Processing
	TaskStatus *string `json:"TaskStatus,omitempty" xml:"TaskStatus,omitempty"`
	// The ID of the transcoding task.
	//
	// example:
	//
	// b1b65ab107*****ba3dbb900f6c1fe0
	TranscodeTaskId *string `json:"TranscodeTaskId,omitempty" xml:"TranscodeTaskId,omitempty"`
	// The ID of the transcoding template group.
	//
	// example:
	//
	// b500c7094bd24*****f3e9900752d7c3
	TranscodeTemplateGroupId *string `json:"TranscodeTemplateGroupId,omitempty" xml:"TranscodeTemplateGroupId,omitempty"`
	// The mode in which the transcoding task is triggered. Valid values:
	//
	// 	- **Auto**: The transcoding task is automatically triggered when the video is uploaded.
	//
	// 	- **Manual**: The transcoding task is triggered by calling the SubmitTranscodeJobs operation.
	//
	// example:
	//
	// Auto
	Trigger *string `json:"Trigger,omitempty" xml:"Trigger,omitempty"`
	// The ID of the audio or video file.
	//
	// example:
	//
	// d4860fcc6a5*****bce9fed52e893824
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s ListTranscodeTaskResponseBodyTranscodeTaskList) String() string {
	return tea.Prettify(s)
}

func (s ListTranscodeTaskResponseBodyTranscodeTaskList) GoString() string {
	return s.String()
}

func (s *ListTranscodeTaskResponseBodyTranscodeTaskList) SetCompleteTime(v string) *ListTranscodeTaskResponseBodyTranscodeTaskList {
	s.CompleteTime = &v
	return s
}

func (s *ListTranscodeTaskResponseBodyTranscodeTaskList) SetCreationTime(v string) *ListTranscodeTaskResponseBodyTranscodeTaskList {
	s.CreationTime = &v
	return s
}

func (s *ListTranscodeTaskResponseBodyTranscodeTaskList) SetTaskStatus(v string) *ListTranscodeTaskResponseBodyTranscodeTaskList {
	s.TaskStatus = &v
	return s
}

func (s *ListTranscodeTaskResponseBodyTranscodeTaskList) SetTranscodeTaskId(v string) *ListTranscodeTaskResponseBodyTranscodeTaskList {
	s.TranscodeTaskId = &v
	return s
}

func (s *ListTranscodeTaskResponseBodyTranscodeTaskList) SetTranscodeTemplateGroupId(v string) *ListTranscodeTaskResponseBodyTranscodeTaskList {
	s.TranscodeTemplateGroupId = &v
	return s
}

func (s *ListTranscodeTaskResponseBodyTranscodeTaskList) SetTrigger(v string) *ListTranscodeTaskResponseBodyTranscodeTaskList {
	s.Trigger = &v
	return s
}

func (s *ListTranscodeTaskResponseBodyTranscodeTaskList) SetVideoId(v string) *ListTranscodeTaskResponseBodyTranscodeTaskList {
	s.VideoId = &v
	return s
}

type ListTranscodeTaskResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListTranscodeTaskResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListTranscodeTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTranscodeTaskResponse) GoString() string {
	return s.String()
}

func (s *ListTranscodeTaskResponse) SetHeaders(v map[string]*string) *ListTranscodeTaskResponse {
	s.Headers = v
	return s
}

func (s *ListTranscodeTaskResponse) SetStatusCode(v int32) *ListTranscodeTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTranscodeTaskResponse) SetBody(v *ListTranscodeTaskResponseBody) *ListTranscodeTaskResponse {
	s.Body = v
	return s
}

type ListTranscodeTemplateGroupRequest struct {
	// The ID of the application. Default value: **app-1000000**. For more information, see [Overview](https://help.aliyun.com/document_detail/113600.html).
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
}

func (s ListTranscodeTemplateGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTranscodeTemplateGroupRequest) GoString() string {
	return s.String()
}

func (s *ListTranscodeTemplateGroupRequest) SetAppId(v string) *ListTranscodeTemplateGroupRequest {
	s.AppId = &v
	return s
}

type ListTranscodeTemplateGroupResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A*****F6-D7393642CA58
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The transcoding template groups.
	TranscodeTemplateGroupList []*ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList `json:"TranscodeTemplateGroupList,omitempty" xml:"TranscodeTemplateGroupList,omitempty" type:"Repeated"`
}

func (s ListTranscodeTemplateGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTranscodeTemplateGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ListTranscodeTemplateGroupResponseBody) SetRequestId(v string) *ListTranscodeTemplateGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTranscodeTemplateGroupResponseBody) SetTranscodeTemplateGroupList(v []*ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList) *ListTranscodeTemplateGroupResponseBody {
	s.TranscodeTemplateGroupList = v
	return s
}

type ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList struct {
	// The ID of the application.
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The time when the template group was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2018-12-05T10:20:09Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// Indicates whether the template group is the default one. Valid values:
	//
	// 	- **Default**: The template group is the default one.
	//
	// 	- **NotDefault**: The template group is not the default one.
	//
	// example:
	//
	// Default
	IsDefault *string `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	// The lock status of the transcoding template group. Valid values:
	//
	// 	- **Disabled**: The template group is not locked.
	//
	// 	- **Enabled**: The template group is locked.
	//
	// example:
	//
	// Disabled
	Locked *string `json:"Locked,omitempty" xml:"Locked,omitempty"`
	// The time when the template group was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2018-12-05T10:22:09Z
	ModifyTime *string `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	// The name of the template group.
	//
	// example:
	//
	// test
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the transcoding template group.
	//
	// example:
	//
	// 17a9889fc66852*****d791c886700932
	TranscodeTemplateGroupId *string `json:"TranscodeTemplateGroupId,omitempty" xml:"TranscodeTemplateGroupId,omitempty"`
}

func (s ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList) String() string {
	return tea.Prettify(s)
}

func (s ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList) GoString() string {
	return s.String()
}

func (s *ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList) SetAppId(v string) *ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList {
	s.AppId = &v
	return s
}

func (s *ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList) SetCreationTime(v string) *ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList {
	s.CreationTime = &v
	return s
}

func (s *ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList) SetIsDefault(v string) *ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList {
	s.IsDefault = &v
	return s
}

func (s *ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList) SetLocked(v string) *ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList {
	s.Locked = &v
	return s
}

func (s *ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList) SetModifyTime(v string) *ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList {
	s.ModifyTime = &v
	return s
}

func (s *ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList) SetName(v string) *ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList {
	s.Name = &v
	return s
}

func (s *ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList) SetTranscodeTemplateGroupId(v string) *ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList {
	s.TranscodeTemplateGroupId = &v
	return s
}

type ListTranscodeTemplateGroupResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListTranscodeTemplateGroupResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListTranscodeTemplateGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTranscodeTemplateGroupResponse) GoString() string {
	return s.String()
}

func (s *ListTranscodeTemplateGroupResponse) SetHeaders(v map[string]*string) *ListTranscodeTemplateGroupResponse {
	s.Headers = v
	return s
}

func (s *ListTranscodeTemplateGroupResponse) SetStatusCode(v int32) *ListTranscodeTemplateGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTranscodeTemplateGroupResponse) SetBody(v *ListTranscodeTemplateGroupResponseBody) *ListTranscodeTemplateGroupResponse {
	s.Body = v
	return s
}

type ListVodTemplateRequest struct {
	// The ID of the application. Set the value to **app-1000000**. For more information, see [Overview](https://help.aliyun.com/document_detail/113600.html).
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The type of the template. Set the value to **Snapshot**.
	//
	// This parameter is required.
	//
	// example:
	//
	// Snapshot
	TemplateType *string `json:"TemplateType,omitempty" xml:"TemplateType,omitempty"`
}

func (s ListVodTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s ListVodTemplateRequest) GoString() string {
	return s.String()
}

func (s *ListVodTemplateRequest) SetAppId(v string) *ListVodTemplateRequest {
	s.AppId = &v
	return s
}

func (s *ListVodTemplateRequest) SetTemplateType(v string) *ListVodTemplateRequest {
	s.TemplateType = &v
	return s
}

type ListVodTemplateResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 2A56B75B-B7E6-48*****27-A9BEAA3E50A8
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The snapshot templates.
	VodTemplateInfoList []*ListVodTemplateResponseBodyVodTemplateInfoList `json:"VodTemplateInfoList,omitempty" xml:"VodTemplateInfoList,omitempty" type:"Repeated"`
}

func (s ListVodTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListVodTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *ListVodTemplateResponseBody) SetRequestId(v string) *ListVodTemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListVodTemplateResponseBody) SetVodTemplateInfoList(v []*ListVodTemplateResponseBodyVodTemplateInfoList) *ListVodTemplateResponseBody {
	s.VodTemplateInfoList = v
	return s
}

type ListVodTemplateResponseBodyVodTemplateInfoList struct {
	// The ID of the application.
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The time when the template was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2018-11-30T08:05:59:57Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// Indicates whether the template is the default one. Valid values:
	//
	// 	- **Default**: The template is the default one.
	//
	// 	- **NotDefault**: The template is not the default one.
	//
	// example:
	//
	// NotDefault
	IsDefault *string `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	// The time when the template was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2018-11-30T09:05:59:97Z
	ModifyTime *string `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	// The name of the template.
	//
	// example:
	//
	// test
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The detailed configurations of the template. The value is a JSON-formatted string. For more information about the data structure, see the "SnapshotTemplateConfig" section of the [Media processing parameters](https://help.aliyun.com/document_detail/98618.html) topic.
	//
	// example:
	//
	// {\\"SnapshotConfig\\":{\\"Count\\":10,\\"SpecifiedOffsetTime\\":0,\\"Interval\\":1},\\"SnapshotType\\":\\"NormalSnapshot\\"}
	TemplateConfig *string `json:"TemplateConfig,omitempty" xml:"TemplateConfig,omitempty"`
	// The type of the template. Valid values:
	//
	// 	- **Snapshot**
	//
	// 	- **DynamicImage**
	//
	// example:
	//
	// Snapshot
	TemplateType *string `json:"TemplateType,omitempty" xml:"TemplateType,omitempty"`
	// The ID of the template.
	//
	// example:
	//
	// 7c49f2f42b1c*****0969fcd446690
	VodTemplateId *string `json:"VodTemplateId,omitempty" xml:"VodTemplateId,omitempty"`
}

func (s ListVodTemplateResponseBodyVodTemplateInfoList) String() string {
	return tea.Prettify(s)
}

func (s ListVodTemplateResponseBodyVodTemplateInfoList) GoString() string {
	return s.String()
}

func (s *ListVodTemplateResponseBodyVodTemplateInfoList) SetAppId(v string) *ListVodTemplateResponseBodyVodTemplateInfoList {
	s.AppId = &v
	return s
}

func (s *ListVodTemplateResponseBodyVodTemplateInfoList) SetCreationTime(v string) *ListVodTemplateResponseBodyVodTemplateInfoList {
	s.CreationTime = &v
	return s
}

func (s *ListVodTemplateResponseBodyVodTemplateInfoList) SetIsDefault(v string) *ListVodTemplateResponseBodyVodTemplateInfoList {
	s.IsDefault = &v
	return s
}

func (s *ListVodTemplateResponseBodyVodTemplateInfoList) SetModifyTime(v string) *ListVodTemplateResponseBodyVodTemplateInfoList {
	s.ModifyTime = &v
	return s
}

func (s *ListVodTemplateResponseBodyVodTemplateInfoList) SetName(v string) *ListVodTemplateResponseBodyVodTemplateInfoList {
	s.Name = &v
	return s
}

func (s *ListVodTemplateResponseBodyVodTemplateInfoList) SetTemplateConfig(v string) *ListVodTemplateResponseBodyVodTemplateInfoList {
	s.TemplateConfig = &v
	return s
}

func (s *ListVodTemplateResponseBodyVodTemplateInfoList) SetTemplateType(v string) *ListVodTemplateResponseBodyVodTemplateInfoList {
	s.TemplateType = &v
	return s
}

func (s *ListVodTemplateResponseBodyVodTemplateInfoList) SetVodTemplateId(v string) *ListVodTemplateResponseBodyVodTemplateInfoList {
	s.VodTemplateId = &v
	return s
}

type ListVodTemplateResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListVodTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListVodTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s ListVodTemplateResponse) GoString() string {
	return s.String()
}

func (s *ListVodTemplateResponse) SetHeaders(v map[string]*string) *ListVodTemplateResponse {
	s.Headers = v
	return s
}

func (s *ListVodTemplateResponse) SetStatusCode(v int32) *ListVodTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *ListVodTemplateResponse) SetBody(v *ListVodTemplateResponseBody) *ListVodTemplateResponse {
	s.Body = v
	return s
}

type ListWatermarkRequest struct {
	// The ID of the application. Default value: **app-1000000**.
	//
	// If you have activated the multi-application service, specify the ID of the application to query all image and text watermark templates in the specified application. If you leave this parameter empty, image and text watermark templates in all applications are queried. For more information, see [Overview](https://help.aliyun.com/document_detail/113600.html).
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
}

func (s ListWatermarkRequest) String() string {
	return tea.Prettify(s)
}

func (s ListWatermarkRequest) GoString() string {
	return s.String()
}

func (s *ListWatermarkRequest) SetAppId(v string) *ListWatermarkRequest {
	s.AppId = &v
	return s
}

type ListWatermarkResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 25818875-5F78-4A*****F6-D7393642CA58
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the watermark template.
	WatermarkInfos []*ListWatermarkResponseBodyWatermarkInfos `json:"WatermarkInfos,omitempty" xml:"WatermarkInfos,omitempty" type:"Repeated"`
}

func (s ListWatermarkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListWatermarkResponseBody) GoString() string {
	return s.String()
}

func (s *ListWatermarkResponseBody) SetRequestId(v string) *ListWatermarkResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListWatermarkResponseBody) SetWatermarkInfos(v []*ListWatermarkResponseBodyWatermarkInfos) *ListWatermarkResponseBody {
	s.WatermarkInfos = v
	return s
}

type ListWatermarkResponseBodyWatermarkInfos struct {
	// The ID of the application.
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The time when the watermark template was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2018-11-07T09:05:52Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The URL of the watermark file. The URL is an Object Storage Service (OSS) URL or an Alibaba Cloud CDN URL.
	//
	// >  This parameter is returned only for image watermark templates.
	//
	// example:
	//
	// https://outin-3262681cd*****89f4b3e7.oss-cn-shanghai.aliyuncs.com/image/cover/8CC8B715E6F8A72EC6B-6-2.png?Expires=1541600583&OSSAccessKeyId=****&Signature=gmf1eYMoDVg%2BHQCb4UGozB****
	FileUrl *string `json:"FileUrl,omitempty" xml:"FileUrl,omitempty"`
	// Indicates whether the watermark template is the default one. Valid values:
	//
	// 	- **Default**
	//
	// 	- **NotDefault**
	//
	// example:
	//
	// NotDefault
	IsDefault *string `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	// The name of the watermark template.
	//
	// example:
	//
	// testName
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of the watermark template.
	//
	// 	- **Image**: image watermark template
	//
	// 	- **Text**: text watermark template
	//
	// example:
	//
	// Text
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The configuration information of the watermark such as the display position and special effects. The value is a JSON string. The configuration parameters for image and text watermarks are different. For more information about the parameter structure, see [WatermarkConfig](~~98618#section-h01-44s-2lr~~).
	//
	// example:
	//
	// {"FontColor": "Blue","FontSize": 80,"Content": "test watermark"}
	WatermarkConfig *string `json:"WatermarkConfig,omitempty" xml:"WatermarkConfig,omitempty"`
	// The ID of the watermark template.
	//
	// example:
	//
	// 9bcc8bfadb843*****109a2671d0df97
	WatermarkId *string `json:"WatermarkId,omitempty" xml:"WatermarkId,omitempty"`
}

func (s ListWatermarkResponseBodyWatermarkInfos) String() string {
	return tea.Prettify(s)
}

func (s ListWatermarkResponseBodyWatermarkInfos) GoString() string {
	return s.String()
}

func (s *ListWatermarkResponseBodyWatermarkInfos) SetAppId(v string) *ListWatermarkResponseBodyWatermarkInfos {
	s.AppId = &v
	return s
}

func (s *ListWatermarkResponseBodyWatermarkInfos) SetCreationTime(v string) *ListWatermarkResponseBodyWatermarkInfos {
	s.CreationTime = &v
	return s
}

func (s *ListWatermarkResponseBodyWatermarkInfos) SetFileUrl(v string) *ListWatermarkResponseBodyWatermarkInfos {
	s.FileUrl = &v
	return s
}

func (s *ListWatermarkResponseBodyWatermarkInfos) SetIsDefault(v string) *ListWatermarkResponseBodyWatermarkInfos {
	s.IsDefault = &v
	return s
}

func (s *ListWatermarkResponseBodyWatermarkInfos) SetName(v string) *ListWatermarkResponseBodyWatermarkInfos {
	s.Name = &v
	return s
}

func (s *ListWatermarkResponseBodyWatermarkInfos) SetType(v string) *ListWatermarkResponseBodyWatermarkInfos {
	s.Type = &v
	return s
}

func (s *ListWatermarkResponseBodyWatermarkInfos) SetWatermarkConfig(v string) *ListWatermarkResponseBodyWatermarkInfos {
	s.WatermarkConfig = &v
	return s
}

func (s *ListWatermarkResponseBodyWatermarkInfos) SetWatermarkId(v string) *ListWatermarkResponseBodyWatermarkInfos {
	s.WatermarkId = &v
	return s
}

type ListWatermarkResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListWatermarkResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListWatermarkResponse) String() string {
	return tea.Prettify(s)
}

func (s ListWatermarkResponse) GoString() string {
	return s.String()
}

func (s *ListWatermarkResponse) SetHeaders(v map[string]*string) *ListWatermarkResponse {
	s.Headers = v
	return s
}

func (s *ListWatermarkResponse) SetStatusCode(v int32) *ListWatermarkResponse {
	s.StatusCode = &v
	return s
}

func (s *ListWatermarkResponse) SetBody(v *ListWatermarkResponseBody) *ListWatermarkResponse {
	s.Body = v
	return s
}

type MoveAppResourceRequest struct {
	// The resource ID. You can specify a maximum of 20 IDs at a time. Separate multiple IDs with commas (,).
	//
	// This parameter is required.
	//
	// example:
	//
	// 9afb4****06de180880e,f7bba****caa546cfe2ba
	ResourceIds *string `json:"ResourceIds,omitempty" xml:"ResourceIds,omitempty"`
	// The resource type. Valid values:
	//
	// 	- **video**: video files.
	//
	// 	- **image**: image files.
	//
	// 	- **attached**: auxiliary media assets.
	//
	// This parameter is required.
	//
	// example:
	//
	// video
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The ID of the application to which resources are migrated. Default value: **app-1000000**. For more information, see [Use the multi-application service](https://help.aliyun.com/document_detail/113600.html).
	//
	// This parameter is required.
	//
	// example:
	//
	// app-****
	TargetAppId *string `json:"TargetAppId,omitempty" xml:"TargetAppId,omitempty"`
}

func (s MoveAppResourceRequest) String() string {
	return tea.Prettify(s)
}

func (s MoveAppResourceRequest) GoString() string {
	return s.String()
}

func (s *MoveAppResourceRequest) SetResourceIds(v string) *MoveAppResourceRequest {
	s.ResourceIds = &v
	return s
}

func (s *MoveAppResourceRequest) SetResourceType(v string) *MoveAppResourceRequest {
	s.ResourceType = &v
	return s
}

func (s *MoveAppResourceRequest) SetTargetAppId(v string) *MoveAppResourceRequest {
	s.TargetAppId = &v
	return s
}

type MoveAppResourceResponseBody struct {
	// The IDs of the resources that failed to be migrated.
	FailedResourceIds []*string `json:"FailedResourceIds,omitempty" xml:"FailedResourceIds,omitempty" type:"Repeated"`
	// The IDs of the resources that were not found.
	NonExistResourceIds []*string `json:"NonExistResourceIds,omitempty" xml:"NonExistResourceIds,omitempty" type:"Repeated"`
	// The request ID.
	//
	// example:
	//
	// 25818875-5F78-4A13-BEF6-****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s MoveAppResourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s MoveAppResourceResponseBody) GoString() string {
	return s.String()
}

func (s *MoveAppResourceResponseBody) SetFailedResourceIds(v []*string) *MoveAppResourceResponseBody {
	s.FailedResourceIds = v
	return s
}

func (s *MoveAppResourceResponseBody) SetNonExistResourceIds(v []*string) *MoveAppResourceResponseBody {
	s.NonExistResourceIds = v
	return s
}

func (s *MoveAppResourceResponseBody) SetRequestId(v string) *MoveAppResourceResponseBody {
	s.RequestId = &v
	return s
}

type MoveAppResourceResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *MoveAppResourceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s MoveAppResourceResponse) String() string {
	return tea.Prettify(s)
}

func (s MoveAppResourceResponse) GoString() string {
	return s.String()
}

func (s *MoveAppResourceResponse) SetHeaders(v map[string]*string) *MoveAppResourceResponse {
	s.Headers = v
	return s
}

func (s *MoveAppResourceResponse) SetStatusCode(v int32) *MoveAppResourceResponse {
	s.StatusCode = &v
	return s
}

func (s *MoveAppResourceResponse) SetBody(v *MoveAppResourceResponseBody) *MoveAppResourceResponse {
	s.Body = v
	return s
}

type PreloadVodObjectCachesRequest struct {
	// The acceleration region in which you want to prefetch content. If you do not specify a region, the value overseas is used.
	//
	// 	- **domestic**: Chinese mainland
	//
	// 	- **overseas**: outside the Chinese mainland
	//
	// example:
	//
	// domestic
	Area *string `json:"Area,omitempty" xml:"Area,omitempty"`
	// Specifies whether to prefetch content to POPs. Valid values:
	//
	// 	- **true**: prefetches content to nodes that include L2 DCDN nodes.
	//
	// 	- **false**: prefetches content to L2 POPs or L3 POPs.
	//
	// example:
	//
	// true
	L2Preload *bool `json:"L2Preload,omitempty" xml:"L2Preload,omitempty"`
	// The URL of the file to be prefetched. Separate multiple URLs with line breaks (\\n or \\r\\n).
	//
	// This parameter is required.
	//
	// example:
	//
	// vod.test.com/test.txt
	ObjectPath    *string `json:"ObjectPath,omitempty" xml:"ObjectPath,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The custom header for prefetch in the JSON format.
	//
	// example:
	//
	// {
	//
	//       "Accept-Encoding": [
	//
	//             "gzip, deflate, br"
	//
	//       ]
	//
	// }
	WithHeader *string `json:"WithHeader,omitempty" xml:"WithHeader,omitempty"`
}

func (s PreloadVodObjectCachesRequest) String() string {
	return tea.Prettify(s)
}

func (s PreloadVodObjectCachesRequest) GoString() string {
	return s.String()
}

func (s *PreloadVodObjectCachesRequest) SetArea(v string) *PreloadVodObjectCachesRequest {
	s.Area = &v
	return s
}

func (s *PreloadVodObjectCachesRequest) SetL2Preload(v bool) *PreloadVodObjectCachesRequest {
	s.L2Preload = &v
	return s
}

func (s *PreloadVodObjectCachesRequest) SetObjectPath(v string) *PreloadVodObjectCachesRequest {
	s.ObjectPath = &v
	return s
}

func (s *PreloadVodObjectCachesRequest) SetOwnerId(v int64) *PreloadVodObjectCachesRequest {
	s.OwnerId = &v
	return s
}

func (s *PreloadVodObjectCachesRequest) SetSecurityToken(v string) *PreloadVodObjectCachesRequest {
	s.SecurityToken = &v
	return s
}

func (s *PreloadVodObjectCachesRequest) SetWithHeader(v string) *PreloadVodObjectCachesRequest {
	s.WithHeader = &v
	return s
}

type PreloadVodObjectCachesResponseBody struct {
	// The ID of the prefetch task. Separate multiple task IDs with commas (,).
	//
	// example:
	//
	// 9524****
	PreloadTaskId *string `json:"PreloadTaskId,omitempty" xml:"PreloadTaskId,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// E5BD4B50-7A02-493A-*****-97B9024B4135
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s PreloadVodObjectCachesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PreloadVodObjectCachesResponseBody) GoString() string {
	return s.String()
}

func (s *PreloadVodObjectCachesResponseBody) SetPreloadTaskId(v string) *PreloadVodObjectCachesResponseBody {
	s.PreloadTaskId = &v
	return s
}

func (s *PreloadVodObjectCachesResponseBody) SetRequestId(v string) *PreloadVodObjectCachesResponseBody {
	s.RequestId = &v
	return s
}

type PreloadVodObjectCachesResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *PreloadVodObjectCachesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s PreloadVodObjectCachesResponse) String() string {
	return tea.Prettify(s)
}

func (s PreloadVodObjectCachesResponse) GoString() string {
	return s.String()
}

func (s *PreloadVodObjectCachesResponse) SetHeaders(v map[string]*string) *PreloadVodObjectCachesResponse {
	s.Headers = v
	return s
}

func (s *PreloadVodObjectCachesResponse) SetStatusCode(v int32) *PreloadVodObjectCachesResponse {
	s.StatusCode = &v
	return s
}

func (s *PreloadVodObjectCachesResponse) SetBody(v *PreloadVodObjectCachesResponseBody) *PreloadVodObjectCachesResponse {
	s.Body = v
	return s
}

type ProduceEditingProjectVideoRequest struct {
	// The ID of the application. Default value: **app-1000000**. For more information, see [Multi-application service](https://help.aliyun.com/document_detail/113600.html).
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The thumbnail URL of the online editing project.
	//
	// example:
	//
	// https://example.aliyundoc.com/6AB4D0E1E1C7446888351****.png
	CoverURL *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	// The description of the online editing project.
	//
	// example:
	//
	// description test
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The video metadata. The value must be in JSON format. For more information about the parameter structure, see [MediaMetadata](~~52839#title_rtf_ry5_gjp~~).
	//
	// example:
	//
	// {"Description":"video description","Title":"userData test"}
	MediaMetadata *string `json:"MediaMetadata,omitempty" xml:"MediaMetadata,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The configuration of video production. The value must be in the JSON format. For more information about the parameter structure, see [ProduceConfig](~~52839#title-ybl-7cs-y7d~~).
	//
	// >  StorageLocation is required if you produce videos in a region other than China (Shanghai).
	//
	// example:
	//
	// {"TemplateGroupId":"6d11e25ea30a4c465435c74****"}
	ProduceConfig *string `json:"ProduceConfig,omitempty" xml:"ProduceConfig,omitempty"`
	// The ID of the online editing project. You can use one of the following methods to obtain the ID of the online editing project:
	//
	// 	- Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Production Center*	- > **Video Editing*	- to view the ID of the online editing project.
	//
	// 	- Obtain the value of ProjectId from the response to the [AddEditingProject](https://help.aliyun.com/document_detail/69048.html) operation.
	//
	// example:
	//
	// fb2101bf24b4cb318787dc****
	ProjectId            *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The timeline of the online editing project. The value must be in JSON format. For more information about the parameter structure, see [Timeline](~~52839#07bc7fe0f2xuh~~).
	//
	// example:
	//
	// {"VideoTracks":[{"VideoTrackClips":[{"MediaId":"cc3308ac59615a54328bc3443****"},{"MediaId":"da87a9cff645cd88bc6d8326e4****"}]}]}
	Timeline *string `json:"Timeline,omitempty" xml:"Timeline,omitempty"`
	// The title of the online editing project.
	//
	// example:
	//
	// editing project test
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The custom configurations, such as the callback configuration. The value must be a JSON string. For more information about the parameter structure, see [UserData](~~86952#title_vz7_xzs_0c5~~).
	//
	// > The callback configurations take effect only after you specify an HTTP URL for receiving callback notifications and select the event types in the ApsaraVideo VOD console.
	//
	// example:
	//
	// {"Extend":{"width":1280,"id":"028a8e56b1ebf6bb7afc74****","height":720},"MessageCallback":{"CallbackURL":"https://example.aliyundoc.com/2016-08-15/proxy/httpcallback/testcallback/","CallbackType":"http"}}
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
}

func (s ProduceEditingProjectVideoRequest) String() string {
	return tea.Prettify(s)
}

func (s ProduceEditingProjectVideoRequest) GoString() string {
	return s.String()
}

func (s *ProduceEditingProjectVideoRequest) SetAppId(v string) *ProduceEditingProjectVideoRequest {
	s.AppId = &v
	return s
}

func (s *ProduceEditingProjectVideoRequest) SetCoverURL(v string) *ProduceEditingProjectVideoRequest {
	s.CoverURL = &v
	return s
}

func (s *ProduceEditingProjectVideoRequest) SetDescription(v string) *ProduceEditingProjectVideoRequest {
	s.Description = &v
	return s
}

func (s *ProduceEditingProjectVideoRequest) SetMediaMetadata(v string) *ProduceEditingProjectVideoRequest {
	s.MediaMetadata = &v
	return s
}

func (s *ProduceEditingProjectVideoRequest) SetOwnerId(v int64) *ProduceEditingProjectVideoRequest {
	s.OwnerId = &v
	return s
}

func (s *ProduceEditingProjectVideoRequest) SetProduceConfig(v string) *ProduceEditingProjectVideoRequest {
	s.ProduceConfig = &v
	return s
}

func (s *ProduceEditingProjectVideoRequest) SetProjectId(v string) *ProduceEditingProjectVideoRequest {
	s.ProjectId = &v
	return s
}

func (s *ProduceEditingProjectVideoRequest) SetResourceOwnerAccount(v string) *ProduceEditingProjectVideoRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ProduceEditingProjectVideoRequest) SetResourceOwnerId(v int64) *ProduceEditingProjectVideoRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ProduceEditingProjectVideoRequest) SetTimeline(v string) *ProduceEditingProjectVideoRequest {
	s.Timeline = &v
	return s
}

func (s *ProduceEditingProjectVideoRequest) SetTitle(v string) *ProduceEditingProjectVideoRequest {
	s.Title = &v
	return s
}

func (s *ProduceEditingProjectVideoRequest) SetUserData(v string) *ProduceEditingProjectVideoRequest {
	s.UserData = &v
	return s
}

type ProduceEditingProjectVideoResponseBody struct {
	// The ID of the produced video.
	//
	// > 	- This parameter is returned for each request.
	//
	// > 	- If a value is returned for this parameter, the video production task is being asynchronously processed.
	//
	// example:
	//
	// 006204a11bb386bb25491f95f****
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The ID of the online editing project.
	//
	// example:
	//
	// fb2101bf24b4cb318787dc****
	ProjectId *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4AF6-D7393642CA58****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ProduceEditingProjectVideoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ProduceEditingProjectVideoResponseBody) GoString() string {
	return s.String()
}

func (s *ProduceEditingProjectVideoResponseBody) SetMediaId(v string) *ProduceEditingProjectVideoResponseBody {
	s.MediaId = &v
	return s
}

func (s *ProduceEditingProjectVideoResponseBody) SetProjectId(v string) *ProduceEditingProjectVideoResponseBody {
	s.ProjectId = &v
	return s
}

func (s *ProduceEditingProjectVideoResponseBody) SetRequestId(v string) *ProduceEditingProjectVideoResponseBody {
	s.RequestId = &v
	return s
}

type ProduceEditingProjectVideoResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ProduceEditingProjectVideoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ProduceEditingProjectVideoResponse) String() string {
	return tea.Prettify(s)
}

func (s ProduceEditingProjectVideoResponse) GoString() string {
	return s.String()
}

func (s *ProduceEditingProjectVideoResponse) SetHeaders(v map[string]*string) *ProduceEditingProjectVideoResponse {
	s.Headers = v
	return s
}

func (s *ProduceEditingProjectVideoResponse) SetStatusCode(v int32) *ProduceEditingProjectVideoResponse {
	s.StatusCode = &v
	return s
}

func (s *ProduceEditingProjectVideoResponse) SetBody(v *ProduceEditingProjectVideoResponseBody) *ProduceEditingProjectVideoResponse {
	s.Body = v
	return s
}

type RefreshMediaPlayUrlsRequest struct {
	// Specifies the resolutions of the media streams you want to refresh or prefetch. You can specify multiple resolutions. Separate multiple resolutions with commas (,). If you leave this parameter empty, media streams in all resolutions are refreshed or prefetched by default.
	//
	// >  The value must be supported in the **Definition*	- section in [Parameters for media assets](https://help.aliyun.com/document_detail/124671.html).
	//
	// example:
	//
	// HD, SD
	Definitions *string `json:"Definitions,omitempty" xml:"Definitions,omitempty"`
	// The formats of the media streams you want to refresh or prefetch. You can specify multiple formats. Separate multiple formats with commas (,). If you leave this parameter empty, media streams in all formats are refreshed or prefetched by default. Valid values:
	//
	// 	- **mp4**
	//
	// 	- **m3u8**
	//
	// 	- **mp3**
	//
	// 	- **flv**
	//
	// 	- **webm**
	//
	// 	- **ts**
	//
	// example:
	//
	// mp4,m3u8
	Formats *string `json:"Formats,omitempty" xml:"Formats,omitempty"`
	// The IDs of the media files that you want to refresh or prefetch. You can specify a maximum of 20 IDs. Separate multiple IDs with commas (,). You can use one of the following methods to obtain the ID:
	//
	// 	- Log on to the [ApsaraVideo VOD](https://vod.console.aliyun.com) console. In the left-side navigation pane, choose **Media Files*	- > **Audio/Video**. On the Video and Audio page, view the ID of the audio or video file. This method is applicable to files that are uploaded by using the ApsaraVideo VOD console.
	//
	// 	- Obtain the value of VideoId from the response to the [CreateUploadVideo](https://help.aliyun.com/document_detail/55407.html) operation that you call to upload media files.
	//
	// 	- Obtain the value of VideoId from the response to the [SearchMedia](https://help.aliyun.com/document_detail/86044.html) operation that you call to query the media ID after the media file is uploaded.
	//
	// This parameter is required.
	//
	// example:
	//
	// ca3a8f6e4957b658067095869****, a6e49sfgd23p5g9ja7095863****
	MediaIds *string `json:"MediaIds,omitempty" xml:"MediaIds,omitempty"`
	// Specifies the type of the refresh or prefetch operation. Default value: Single. Valid values:
	//
	// 	- **Single**: Only one latest transcoded stream is refreshed or prefetched for each resolution and format.
	//
	// 	- **Multiple**: All transcoded streams are refreshed or prefetched for each resolution and format.
	//
	// example:
	//
	// Single
	ResultType *string `json:"ResultType,omitempty" xml:"ResultType,omitempty"`
	// Specifies the number of the playback URLs of the TS files for the M3U8 media stream you want to refresh or prefetch. After you set this parameter, only the playback URLs of the first N TS files will be refreshed or prefetched. Valid values: 1 to 20. Default value: 5.
	//
	// example:
	//
	// 5
	SliceCount *int32 `json:"SliceCount,omitempty" xml:"SliceCount,omitempty"`
	// Specifies whether to refresh or prefetch the playback URLs of the TS files of the M3U8 media stream. Default value: false. Valid values:
	//
	// 	- **false**
	//
	// 	- **true**
	//
	// example:
	//
	// false
	SliceFlag *bool `json:"SliceFlag,omitempty" xml:"SliceFlag,omitempty"`
	// Specifies the types of media streams you want to refresh or prefetch. You can specify multiple types. Separate multiple types with commas (,). If you leave this parameter empty, media streams in all types are refreshed or prefetched by default. Valid values:
	//
	// 	- **video**
	//
	// 	- **audio**
	//
	// example:
	//
	// video
	StreamType *string `json:"StreamType,omitempty" xml:"StreamType,omitempty"`
	// The type of the task that you want to create. Valid values:
	//
	// 	- **Refresh**
	//
	// 	- **Preload**
	//
	// This parameter is required.
	//
	// example:
	//
	// Preload
	TaskType *string `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
	// The custom configurations such as callback configurations and upload acceleration configurations. The value must be a JSON string. For more information, see the "UserData: specifies the custom configurations for media upload" section in the [Request parameter](https://help.aliyun.com/document_detail/86952.html) topic.
	//
	// >	- The callback configurations take effect only after you specify the HTTP callback URL and select specific callback events in the ApsaraVideo VOD console. For more information about how to configure HTTP callback settings in the ApsaraVideo VOD console, see [Configure callback settings](https://help.aliyun.com/document_detail/86071.html).
	//
	// >	- To enable the upload acceleration feature, submit a ticket. For more information, see [Overview](https://help.aliyun.com/document_detail/55396.html). For more information about how to submit a ticket, see [Contact us](https://help.aliyun.com/document_detail/464625.html).
	//
	// example:
	//
	// {"MessageCallback":{"CallbackURL":"http://example.aliyundoc.com"}, "Extend":{"localId":"xxx","test":"www"}}
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
}

func (s RefreshMediaPlayUrlsRequest) String() string {
	return tea.Prettify(s)
}

func (s RefreshMediaPlayUrlsRequest) GoString() string {
	return s.String()
}

func (s *RefreshMediaPlayUrlsRequest) SetDefinitions(v string) *RefreshMediaPlayUrlsRequest {
	s.Definitions = &v
	return s
}

func (s *RefreshMediaPlayUrlsRequest) SetFormats(v string) *RefreshMediaPlayUrlsRequest {
	s.Formats = &v
	return s
}

func (s *RefreshMediaPlayUrlsRequest) SetMediaIds(v string) *RefreshMediaPlayUrlsRequest {
	s.MediaIds = &v
	return s
}

func (s *RefreshMediaPlayUrlsRequest) SetResultType(v string) *RefreshMediaPlayUrlsRequest {
	s.ResultType = &v
	return s
}

func (s *RefreshMediaPlayUrlsRequest) SetSliceCount(v int32) *RefreshMediaPlayUrlsRequest {
	s.SliceCount = &v
	return s
}

func (s *RefreshMediaPlayUrlsRequest) SetSliceFlag(v bool) *RefreshMediaPlayUrlsRequest {
	s.SliceFlag = &v
	return s
}

func (s *RefreshMediaPlayUrlsRequest) SetStreamType(v string) *RefreshMediaPlayUrlsRequest {
	s.StreamType = &v
	return s
}

func (s *RefreshMediaPlayUrlsRequest) SetTaskType(v string) *RefreshMediaPlayUrlsRequest {
	s.TaskType = &v
	return s
}

func (s *RefreshMediaPlayUrlsRequest) SetUserData(v string) *RefreshMediaPlayUrlsRequest {
	s.UserData = &v
	return s
}

type RefreshMediaPlayUrlsResponseBody struct {
	// The IDs of the media files that cannot be operated on. In most cases, media files cannot be operated on because you are not authorized to perform the operations. For more information, see [Overview](https://help.aliyun.com/document_detail/113600.html).
	//
	// example:
	//
	// a6e49sfgd23p5g9ja7095863****
	ForbiddenMediaIds *string `json:"ForbiddenMediaIds,omitempty" xml:"ForbiddenMediaIds,omitempty"`
	// The ID of the refresh or prefetch task.
	//
	// example:
	//
	// 41d465e31957****
	MediaRefreshJobId *string `json:"MediaRefreshJobId,omitempty" xml:"MediaRefreshJobId,omitempty"`
	// The IDs of the media files that do not exist.
	//
	// example:
	//
	// ca3a8f6e4957b658067095869****
	NonExistMediaIds *string `json:"NonExistMediaIds,omitempty" xml:"NonExistMediaIds,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4AF6-04D5-D7393642****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RefreshMediaPlayUrlsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RefreshMediaPlayUrlsResponseBody) GoString() string {
	return s.String()
}

func (s *RefreshMediaPlayUrlsResponseBody) SetForbiddenMediaIds(v string) *RefreshMediaPlayUrlsResponseBody {
	s.ForbiddenMediaIds = &v
	return s
}

func (s *RefreshMediaPlayUrlsResponseBody) SetMediaRefreshJobId(v string) *RefreshMediaPlayUrlsResponseBody {
	s.MediaRefreshJobId = &v
	return s
}

func (s *RefreshMediaPlayUrlsResponseBody) SetNonExistMediaIds(v string) *RefreshMediaPlayUrlsResponseBody {
	s.NonExistMediaIds = &v
	return s
}

func (s *RefreshMediaPlayUrlsResponseBody) SetRequestId(v string) *RefreshMediaPlayUrlsResponseBody {
	s.RequestId = &v
	return s
}

type RefreshMediaPlayUrlsResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RefreshMediaPlayUrlsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RefreshMediaPlayUrlsResponse) String() string {
	return tea.Prettify(s)
}

func (s RefreshMediaPlayUrlsResponse) GoString() string {
	return s.String()
}

func (s *RefreshMediaPlayUrlsResponse) SetHeaders(v map[string]*string) *RefreshMediaPlayUrlsResponse {
	s.Headers = v
	return s
}

func (s *RefreshMediaPlayUrlsResponse) SetStatusCode(v int32) *RefreshMediaPlayUrlsResponse {
	s.StatusCode = &v
	return s
}

func (s *RefreshMediaPlayUrlsResponse) SetBody(v *RefreshMediaPlayUrlsResponseBody) *RefreshMediaPlayUrlsResponse {
	s.Body = v
	return s
}

type RefreshUploadVideoRequest struct {
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the audio or video file. You can use one of the following methods to obtain the ID:
	//
	// 	- Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com) and choose **Media Files*	- > **Audio/Video*	- in the left-side navigation pane to view the ID.
	//
	// 	- View the value of the VideoId parameter returned by the [CreateUploadVideo](https://help.aliyun.com/document_detail/55407.html) operation that you called to upload the audio or video file.
	//
	// 	- After an audio or video file is uploaded, obtain the value of VideoId from the response to the [SearchMedia](https://help.aliyun.com/document_detail/86044.html) operation that you call to query the audio or video ID.
	//
	// This parameter is required.
	//
	// example:
	//
	// c6a23a870c8c4ffcd40cbd381333****
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s RefreshUploadVideoRequest) String() string {
	return tea.Prettify(s)
}

func (s RefreshUploadVideoRequest) GoString() string {
	return s.String()
}

func (s *RefreshUploadVideoRequest) SetOwnerId(v int64) *RefreshUploadVideoRequest {
	s.OwnerId = &v
	return s
}

func (s *RefreshUploadVideoRequest) SetResourceOwnerAccount(v string) *RefreshUploadVideoRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RefreshUploadVideoRequest) SetResourceOwnerId(v int64) *RefreshUploadVideoRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *RefreshUploadVideoRequest) SetVideoId(v string) *RefreshUploadVideoRequest {
	s.VideoId = &v
	return s
}

type RefreshUploadVideoResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A43-7DF6-D7393642****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The upload URL.
	//
	// >  The returned upload URL is a Base64-encoded URL. You must decode the Base64-encoded upload URL before you use an SDK or call an API operation to upload media files. You need to parse UploadAddress only if you use the OSS SDK or call an OSS API operation to upload media files.
	//
	// example:
	//
	// eyJTZWN1cml0eVRiQ0FJU3p3TjFxNkZ0NUIyeW****
	UploadAddress *string `json:"UploadAddress,omitempty" xml:"UploadAddress,omitempty"`
	// The upload credential.
	//
	// >  The returned upload credential is a Base64-encoded value. You must decode the Base64-encoded upload URL before you use an SDK or call an API operation to upload media files. You need to parse UploadAuth only if you use the OSS SDK or call an OSS API operation to upload media files.
	//
	// example:
	//
	// FJU3p3TZ0NUIyeW****
	UploadAuth *string `json:"UploadAuth,omitempty" xml:"UploadAuth,omitempty"`
	// The ID of the audio or video file.
	//
	// example:
	//
	// c6a23a870c8c4ffcd40cbd381333****
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s RefreshUploadVideoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RefreshUploadVideoResponseBody) GoString() string {
	return s.String()
}

func (s *RefreshUploadVideoResponseBody) SetRequestId(v string) *RefreshUploadVideoResponseBody {
	s.RequestId = &v
	return s
}

func (s *RefreshUploadVideoResponseBody) SetUploadAddress(v string) *RefreshUploadVideoResponseBody {
	s.UploadAddress = &v
	return s
}

func (s *RefreshUploadVideoResponseBody) SetUploadAuth(v string) *RefreshUploadVideoResponseBody {
	s.UploadAuth = &v
	return s
}

func (s *RefreshUploadVideoResponseBody) SetVideoId(v string) *RefreshUploadVideoResponseBody {
	s.VideoId = &v
	return s
}

type RefreshUploadVideoResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RefreshUploadVideoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RefreshUploadVideoResponse) String() string {
	return tea.Prettify(s)
}

func (s RefreshUploadVideoResponse) GoString() string {
	return s.String()
}

func (s *RefreshUploadVideoResponse) SetHeaders(v map[string]*string) *RefreshUploadVideoResponse {
	s.Headers = v
	return s
}

func (s *RefreshUploadVideoResponse) SetStatusCode(v int32) *RefreshUploadVideoResponse {
	s.StatusCode = &v
	return s
}

func (s *RefreshUploadVideoResponse) SetBody(v *RefreshUploadVideoResponseBody) *RefreshUploadVideoResponse {
	s.Body = v
	return s
}

type RefreshVodObjectCachesRequest struct {
	// Specifies whether to purge resources in a directory if the resources requested are different from the resources on the origin server.
	//
	// 	- **true**: refreshes all resources in the directory. If you set this parameter to true, when the requested content matches the resource in the directory, the POP retrieves the resource from the origin server, returns the resource to the client, and caches the resource.
	//
	// 	- **false*	- (default): refreshes the changed resources in the directory. If you set this parameter to false, when the requested content matches the resource in the directory, the POP obtains the Last-Modified parameter of the resource from the origin server. If the value of the obtained Last-Modified parameter is the same as that of the cached resource, the cached resource is returned. Otherwise, the POP retrieves the resource from the origin server, returns the resource to the client, and caches the resource.
	//
	// example:
	//
	// false
	Force *bool `json:"Force,omitempty" xml:"Force,omitempty"`
	// The URL of the file to be prefetched. Separate multiple URLs with line breaks (\\n or \\r\\n).
	//
	// This parameter is required.
	//
	// example:
	//
	// abc.com/image/1.png
	ObjectPath *string `json:"ObjectPath,omitempty" xml:"ObjectPath,omitempty"`
	// The type of the object that you want to refresh. Valid values:
	//
	// 	- **File*	- (default): refreshes one or more files.
	//
	// 	- **Directory**: refreshes the files in specified directories.
	//
	// 	- **Regex**: refreshes content based on regular expressions.
	//
	// 	- **IgnoreParams**: removes the question mark (?) and parameters after the question mark (?) in a request URL and refreshes content. After you call this operation with the request URL submitted, the system compares the submitted URL with the URL of the cached resource without specific parameters. If the URLs match, the POPs refresh the cached resource.
	//
	// example:
	//
	// File
	ObjectType    *string `json:"ObjectType,omitempty" xml:"ObjectType,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s RefreshVodObjectCachesRequest) String() string {
	return tea.Prettify(s)
}

func (s RefreshVodObjectCachesRequest) GoString() string {
	return s.String()
}

func (s *RefreshVodObjectCachesRequest) SetForce(v bool) *RefreshVodObjectCachesRequest {
	s.Force = &v
	return s
}

func (s *RefreshVodObjectCachesRequest) SetObjectPath(v string) *RefreshVodObjectCachesRequest {
	s.ObjectPath = &v
	return s
}

func (s *RefreshVodObjectCachesRequest) SetObjectType(v string) *RefreshVodObjectCachesRequest {
	s.ObjectType = &v
	return s
}

func (s *RefreshVodObjectCachesRequest) SetOwnerId(v int64) *RefreshVodObjectCachesRequest {
	s.OwnerId = &v
	return s
}

func (s *RefreshVodObjectCachesRequest) SetSecurityToken(v string) *RefreshVodObjectCachesRequest {
	s.SecurityToken = &v
	return s
}

type RefreshVodObjectCachesResponseBody struct {
	// The ID of the refresh task. Multiple IDs are separated by commas (,). Refresh tasks are merged based on the following rules:
	//
	// If the tasks are set for the same accelerated domain name, submitted within the same second, and refresh content based on URLs instead of directories, the tasks IDs are merged into the same task ID (RefreshTaskId). If the number of these tasks exceeds 2,000, every 2,000 tasks IDs are merged into the same task ID (RefreshTaskId).
	//
	// example:
	//
	// 70422*****2904
	RefreshTaskId *string `json:"RefreshTaskId,omitempty" xml:"RefreshTaskId,omitempty"`
	// The request ID.
	//
	// example:
	//
	// D61E4801-EAFF-4A63-****-FBF6CE1CFD1C
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RefreshVodObjectCachesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RefreshVodObjectCachesResponseBody) GoString() string {
	return s.String()
}

func (s *RefreshVodObjectCachesResponseBody) SetRefreshTaskId(v string) *RefreshVodObjectCachesResponseBody {
	s.RefreshTaskId = &v
	return s
}

func (s *RefreshVodObjectCachesResponseBody) SetRequestId(v string) *RefreshVodObjectCachesResponseBody {
	s.RequestId = &v
	return s
}

type RefreshVodObjectCachesResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RefreshVodObjectCachesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RefreshVodObjectCachesResponse) String() string {
	return tea.Prettify(s)
}

func (s RefreshVodObjectCachesResponse) GoString() string {
	return s.String()
}

func (s *RefreshVodObjectCachesResponse) SetHeaders(v map[string]*string) *RefreshVodObjectCachesResponse {
	s.Headers = v
	return s
}

func (s *RefreshVodObjectCachesResponse) SetStatusCode(v int32) *RefreshVodObjectCachesResponse {
	s.StatusCode = &v
	return s
}

func (s *RefreshVodObjectCachesResponse) SetBody(v *RefreshVodObjectCachesResponseBody) *RefreshVodObjectCachesResponse {
	s.Body = v
	return s
}

type RegisterMediaRequest struct {
	// The metadata of the media files. The value must be a JSON string. You can specify the metadata for up to 10 media files at a time. For more information about the metadata of media files, see the **RegisterMetadata*	- section of this topic.
	//
	// This parameter is required.
	//
	// example:
	//
	// [{"FileURL":"https://****.oss-cn-shanghai.aliyuncs.com/video/test/video123.m3u8","Title":"VideoName"}]
	RegisterMetadatas *string `json:"RegisterMetadatas,omitempty" xml:"RegisterMetadatas,omitempty"`
	// The ID of the transcoding template group. You can use one of the following methods to obtain the ID:
	//
	// 	- Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Configuration Management*	- > **Media Processing*	- > **Transcoding Template Groups**. On the Transcoding Template Groups page, you can view the ID of the transcoding template group.
	//
	// 	- Obtain the value of the TranscodeTemplateGroupId parameter from the response to the [AddTranscodeTemplateGroup](https://help.aliyun.com/document_detail/102665.html) operation that you called to create a transcoding template group.
	//
	// 	- Obtain the value of the TranscodeTemplateGroupId parameter from the response to the [ListTranscodeTemplateGroup](https://help.aliyun.com/document_detail/102669.html) operation that you called to query transcoding template groups.
	//
	// >
	//
	// 	- If you do not need to transcode media files, set the TemplateGroupId parameter to VOD_NO_TRANSCODE. If you do not specify this configuration, errors occur on your files. If you need to transcode media files, specify the ID of the transcoding template group.
	//
	// 	- If you specify both WorkflowId and TemplateGroupId, the value of the WorkflowId parameter takes effect. For more information, see [Workflows](https://help.aliyun.com/document_detail/115347.html).
	//
	// example:
	//
	// ca3a8f6e49c87b65806709586****
	TemplateGroupId *string `json:"TemplateGroupId,omitempty" xml:"TemplateGroupId,omitempty"`
	// The custom settings. The value must be a JSON string. You can configure settings such as message callbacks. For more information, see [UserData](~~86952#section_6fg_qll_v3w~~).
	//
	// >  You cannot configure callbacks for this operation. No callback message is returned after the media files are registered even if you configure callback settings for this parameter. If you configure callback settings for the UserData parameter when you create media processing jobs such as transcoding and snapshot capture jobs for the media file, the callback URL that you specified is used. If you do not configure callback settings when you create media processing jobs, the callback URL that you specified for the UserData parameter when you register the media file is used.
	//
	// example:
	//
	// {"Extend":{"localId":"****","test":"www"}}
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
	// The ID of the workflow. To view the workflow ID, perform the following steps: Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Configuration Management*	- > **Media Processing*	- > **Workflows**.
	//
	// >  If you specify both WorkflowId and TemplateGroupId, the value of WorkflowId parameter takes effect. For more information, see [Workflows](https://help.aliyun.com/document_detail/115347.html).
	//
	// example:
	//
	// 637adc2b7ba51a83d841606f8****
	WorkflowId *string `json:"WorkflowId,omitempty" xml:"WorkflowId,omitempty"`
}

func (s RegisterMediaRequest) String() string {
	return tea.Prettify(s)
}

func (s RegisterMediaRequest) GoString() string {
	return s.String()
}

func (s *RegisterMediaRequest) SetRegisterMetadatas(v string) *RegisterMediaRequest {
	s.RegisterMetadatas = &v
	return s
}

func (s *RegisterMediaRequest) SetTemplateGroupId(v string) *RegisterMediaRequest {
	s.TemplateGroupId = &v
	return s
}

func (s *RegisterMediaRequest) SetUserData(v string) *RegisterMediaRequest {
	s.UserData = &v
	return s
}

func (s *RegisterMediaRequest) SetWorkflowId(v string) *RegisterMediaRequest {
	s.WorkflowId = &v
	return s
}

type RegisterMediaResponseBody struct {
	// The URLs of the media files that failed to be registered.
	FailedFileURLs []*string `json:"FailedFileURLs,omitempty" xml:"FailedFileURLs,omitempty" type:"Repeated"`
	// The media files that are registered, including newly registered and repeatedly registered media files.
	RegisteredMediaList []*RegisterMediaResponseBodyRegisteredMediaList `json:"RegisteredMediaList,omitempty" xml:"RegisteredMediaList,omitempty" type:"Repeated"`
	// The ID of the request.
	//
	// example:
	//
	// 14F43C5C-8033-448B-AD04F64E5098****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RegisterMediaResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RegisterMediaResponseBody) GoString() string {
	return s.String()
}

func (s *RegisterMediaResponseBody) SetFailedFileURLs(v []*string) *RegisterMediaResponseBody {
	s.FailedFileURLs = v
	return s
}

func (s *RegisterMediaResponseBody) SetRegisteredMediaList(v []*RegisterMediaResponseBodyRegisteredMediaList) *RegisterMediaResponseBody {
	s.RegisteredMediaList = v
	return s
}

func (s *RegisterMediaResponseBody) SetRequestId(v string) *RegisterMediaResponseBody {
	s.RequestId = &v
	return s
}

type RegisterMediaResponseBodyRegisteredMediaList struct {
	// The URL of the media file.
	//
	// example:
	//
	// http://****.oss-cn-shanghai.aliyuncs.com/vod_sample_01.mp4
	FileURL *string `json:"FileURL,omitempty" xml:"FileURL,omitempty"`
	// The ID of the media file that is registered with ApsaraVideo VOD. If the registered media file is an audio or video file, the value of this parameter is the same as that of the VideoId parameter.
	//
	// example:
	//
	// d97af32828084d1896683b1aa38****
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// Indicates whether the media file is newly registered or repeatedly registered. Valid values:
	//
	// 	- **true**: The media file is newly registered.
	//
	// 	- **false**: The media file is repeatedly registered.
	//
	// example:
	//
	// false
	NewRegister *bool `json:"NewRegister,omitempty" xml:"NewRegister,omitempty"`
}

func (s RegisterMediaResponseBodyRegisteredMediaList) String() string {
	return tea.Prettify(s)
}

func (s RegisterMediaResponseBodyRegisteredMediaList) GoString() string {
	return s.String()
}

func (s *RegisterMediaResponseBodyRegisteredMediaList) SetFileURL(v string) *RegisterMediaResponseBodyRegisteredMediaList {
	s.FileURL = &v
	return s
}

func (s *RegisterMediaResponseBodyRegisteredMediaList) SetMediaId(v string) *RegisterMediaResponseBodyRegisteredMediaList {
	s.MediaId = &v
	return s
}

func (s *RegisterMediaResponseBodyRegisteredMediaList) SetNewRegister(v bool) *RegisterMediaResponseBodyRegisteredMediaList {
	s.NewRegister = &v
	return s
}

type RegisterMediaResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RegisterMediaResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RegisterMediaResponse) String() string {
	return tea.Prettify(s)
}

func (s RegisterMediaResponse) GoString() string {
	return s.String()
}

func (s *RegisterMediaResponse) SetHeaders(v map[string]*string) *RegisterMediaResponse {
	s.Headers = v
	return s
}

func (s *RegisterMediaResponse) SetStatusCode(v int32) *RegisterMediaResponse {
	s.StatusCode = &v
	return s
}

func (s *RegisterMediaResponse) SetBody(v *RegisterMediaResponseBody) *RegisterMediaResponse {
	s.Body = v
	return s
}

type RestoreMediaRequest struct {
	// The ID of the media asset (VideoId). Separate multiple IDs with commas (,). You can specify a maximum of 20 IDs. You can use one of the following methods to obtain the ID of the media asset:
	//
	// 	- Log on to the ApsaraVideo VOD console. In the left-side navigation pane, choose Media Files > Audio/Video. On the Video and Audio page, view the ID of the media asset. This method is applicable to files that are uploaded by using the ApsaraVideo VOD console.
	//
	// 	- Obtain the value of VideoId from the response to the CreateUploadVideo operation that you call to upload media assets.
	//
	// 	- Obtain the value of VideoId from the response to the SearchMedia operation that you call to query the media ID after the media asset is uploaded.
	//
	// This parameter is required.
	//
	// example:
	//
	// 8bc8e94fe4e55abde85718****,eb186180e989dd56****
	MediaIds *string `json:"MediaIds,omitempty" xml:"MediaIds,omitempty"`
	// The number of days during which media assets remain in the restored state. Default value: 1. The maximum validity period of a restored Archive media asset is 7 days and the maximum validity period of a restored Cold Archive media asset is 365 days.
	//
	// example:
	//
	// 2
	RestoreDays *string `json:"RestoreDays,omitempty" xml:"RestoreDays,omitempty"`
	// The restoration priority. This parameter is required only when you restore a Cold Archive media file. Valid values:
	//
	// 	- **Expedited**: The file is restored within 1 hour.
	//
	// 	- **Standard**: The file is restored within 2 to 5 hours.
	//
	// 	- **Bulk**: The file is restored within 5 to 12 hours.
	//
	// example:
	//
	// Standard
	RestoreTier *string `json:"RestoreTier,omitempty" xml:"RestoreTier,omitempty"`
	// The modification range. Valid values:
	//
	// 	- **All**: restores all resources, including the source files and transcoded streams.
	//
	// 	- **SourceFile**: restores only the source files.
	//
	// example:
	//
	// All
	Scope *string `json:"Scope,omitempty" xml:"Scope,omitempty"`
}

func (s RestoreMediaRequest) String() string {
	return tea.Prettify(s)
}

func (s RestoreMediaRequest) GoString() string {
	return s.String()
}

func (s *RestoreMediaRequest) SetMediaIds(v string) *RestoreMediaRequest {
	s.MediaIds = &v
	return s
}

func (s *RestoreMediaRequest) SetRestoreDays(v string) *RestoreMediaRequest {
	s.RestoreDays = &v
	return s
}

func (s *RestoreMediaRequest) SetRestoreTier(v string) *RestoreMediaRequest {
	s.RestoreTier = &v
	return s
}

func (s *RestoreMediaRequest) SetScope(v string) *RestoreMediaRequest {
	s.Scope = &v
	return s
}

type RestoreMediaResponseBody struct {
	// The IDs of the media asset that failed to be processed.
	ForbiddenList *RestoreMediaResponseBodyForbiddenList `json:"ForbiddenList,omitempty" xml:"ForbiddenList,omitempty" type:"Struct"`
	// The IDs of the media assets that failed to be obtained.
	IgnoredList *RestoreMediaResponseBodyIgnoredList `json:"IgnoredList,omitempty" xml:"IgnoredList,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// 8E70E3F8-E2EE-47BC-4677-379D6F28****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	//
	// example:
	//
	// true
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RestoreMediaResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RestoreMediaResponseBody) GoString() string {
	return s.String()
}

func (s *RestoreMediaResponseBody) SetForbiddenList(v *RestoreMediaResponseBodyForbiddenList) *RestoreMediaResponseBody {
	s.ForbiddenList = v
	return s
}

func (s *RestoreMediaResponseBody) SetIgnoredList(v *RestoreMediaResponseBodyIgnoredList) *RestoreMediaResponseBody {
	s.IgnoredList = v
	return s
}

func (s *RestoreMediaResponseBody) SetRequestId(v string) *RestoreMediaResponseBody {
	s.RequestId = &v
	return s
}

func (s *RestoreMediaResponseBody) SetSuccess(v bool) *RestoreMediaResponseBody {
	s.Success = &v
	return s
}

type RestoreMediaResponseBodyForbiddenList struct {
	MediaForbiddenReasonDTO []*RestoreMediaResponseBodyForbiddenListMediaForbiddenReasonDTO `json:"MediaForbiddenReasonDTO,omitempty" xml:"MediaForbiddenReasonDTO,omitempty" type:"Repeated"`
}

func (s RestoreMediaResponseBodyForbiddenList) String() string {
	return tea.Prettify(s)
}

func (s RestoreMediaResponseBodyForbiddenList) GoString() string {
	return s.String()
}

func (s *RestoreMediaResponseBodyForbiddenList) SetMediaForbiddenReasonDTO(v []*RestoreMediaResponseBodyForbiddenListMediaForbiddenReasonDTO) *RestoreMediaResponseBodyForbiddenList {
	s.MediaForbiddenReasonDTO = v
	return s
}

type RestoreMediaResponseBodyForbiddenListMediaForbiddenReasonDTO struct {
	// The ID of the media asset.
	//
	// example:
	//
	// fa10ee70898671edb99f6eb3690d****
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The reason for the failure.
	//
	// example:
	//
	// Forbidden.RestoreMedia
	Reason *string `json:"Reason,omitempty" xml:"Reason,omitempty"`
}

func (s RestoreMediaResponseBodyForbiddenListMediaForbiddenReasonDTO) String() string {
	return tea.Prettify(s)
}

func (s RestoreMediaResponseBodyForbiddenListMediaForbiddenReasonDTO) GoString() string {
	return s.String()
}

func (s *RestoreMediaResponseBodyForbiddenListMediaForbiddenReasonDTO) SetMediaId(v string) *RestoreMediaResponseBodyForbiddenListMediaForbiddenReasonDTO {
	s.MediaId = &v
	return s
}

func (s *RestoreMediaResponseBodyForbiddenListMediaForbiddenReasonDTO) SetReason(v string) *RestoreMediaResponseBodyForbiddenListMediaForbiddenReasonDTO {
	s.Reason = &v
	return s
}

type RestoreMediaResponseBodyIgnoredList struct {
	MediaId []*string `json:"MediaId,omitempty" xml:"MediaId,omitempty" type:"Repeated"`
}

func (s RestoreMediaResponseBodyIgnoredList) String() string {
	return tea.Prettify(s)
}

func (s RestoreMediaResponseBodyIgnoredList) GoString() string {
	return s.String()
}

func (s *RestoreMediaResponseBodyIgnoredList) SetMediaId(v []*string) *RestoreMediaResponseBodyIgnoredList {
	s.MediaId = v
	return s
}

type RestoreMediaResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RestoreMediaResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RestoreMediaResponse) String() string {
	return tea.Prettify(s)
}

func (s RestoreMediaResponse) GoString() string {
	return s.String()
}

func (s *RestoreMediaResponse) SetHeaders(v map[string]*string) *RestoreMediaResponse {
	s.Headers = v
	return s
}

func (s *RestoreMediaResponse) SetStatusCode(v int32) *RestoreMediaResponse {
	s.StatusCode = &v
	return s
}

func (s *RestoreMediaResponse) SetBody(v *RestoreMediaResponseBody) *RestoreMediaResponse {
	s.Body = v
	return s
}

type SearchEditingProjectRequest struct {
	// The end of the time range to query. The query is performed based on the time range during which the required online editing projects were created. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// example:
	//
	// 2017-01-11T13:00:00Z
	EndTime      *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	//
	// example:
	//
	// 1
	PageNo *int32 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The number of entries to return on each page. Default value: **10**. Maximum value: **100**.
	//
	// example:
	//
	// 10
	PageSize             *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The sorting rule of results. Valid values:
	//
	// 	- **CreationTime:Desc**: sorts the results based on the creation time in descending order. This is the default value.
	//
	// 	- **CreationTime:Asc**: sorts the results based on the creation time in ascending order.
	//
	// example:
	//
	// CreationTime:Desc
	SortBy *string `json:"SortBy,omitempty" xml:"SortBy,omitempty"`
	// The beginning of the time range to query. The query is performed based on the time range during which the required online editing projects were created. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// example:
	//
	// 2017-01-11T12:00:00Z
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The status of the online editing project. Separate multiple states with commas (,). By default, all online editing projects are queried. Valid values:
	//
	// 	- **Normal**: indicates that the online editing project is in draft.
	//
	// 	- **Producing**: indicates that the video is being produced.
	//
	// 	- **Produced**: indicates that the video was produced.
	//
	// 	- **ProduceFailed**: indicates that the video failed to be produced.
	//
	// example:
	//
	// Normal
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The title of the online editing project.
	//
	// example:
	//
	// test
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
}

func (s SearchEditingProjectRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchEditingProjectRequest) GoString() string {
	return s.String()
}

func (s *SearchEditingProjectRequest) SetEndTime(v string) *SearchEditingProjectRequest {
	s.EndTime = &v
	return s
}

func (s *SearchEditingProjectRequest) SetOwnerAccount(v string) *SearchEditingProjectRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SearchEditingProjectRequest) SetOwnerId(v string) *SearchEditingProjectRequest {
	s.OwnerId = &v
	return s
}

func (s *SearchEditingProjectRequest) SetPageNo(v int32) *SearchEditingProjectRequest {
	s.PageNo = &v
	return s
}

func (s *SearchEditingProjectRequest) SetPageSize(v int32) *SearchEditingProjectRequest {
	s.PageSize = &v
	return s
}

func (s *SearchEditingProjectRequest) SetResourceOwnerAccount(v string) *SearchEditingProjectRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SearchEditingProjectRequest) SetResourceOwnerId(v string) *SearchEditingProjectRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *SearchEditingProjectRequest) SetSortBy(v string) *SearchEditingProjectRequest {
	s.SortBy = &v
	return s
}

func (s *SearchEditingProjectRequest) SetStartTime(v string) *SearchEditingProjectRequest {
	s.StartTime = &v
	return s
}

func (s *SearchEditingProjectRequest) SetStatus(v string) *SearchEditingProjectRequest {
	s.Status = &v
	return s
}

func (s *SearchEditingProjectRequest) SetTitle(v string) *SearchEditingProjectRequest {
	s.Title = &v
	return s
}

type SearchEditingProjectResponseBody struct {
	// The list of online editing projects.
	ProjectList *SearchEditingProjectResponseBodyProjectList `json:"ProjectList,omitempty" xml:"ProjectList,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// 9262E3DA-07FA-48*****62-FCBB6BC61D08
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of online editing projects returned.
	//
	// example:
	//
	// 2
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s SearchEditingProjectResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SearchEditingProjectResponseBody) GoString() string {
	return s.String()
}

func (s *SearchEditingProjectResponseBody) SetProjectList(v *SearchEditingProjectResponseBodyProjectList) *SearchEditingProjectResponseBody {
	s.ProjectList = v
	return s
}

func (s *SearchEditingProjectResponseBody) SetRequestId(v string) *SearchEditingProjectResponseBody {
	s.RequestId = &v
	return s
}

func (s *SearchEditingProjectResponseBody) SetTotal(v int32) *SearchEditingProjectResponseBody {
	s.Total = &v
	return s
}

type SearchEditingProjectResponseBodyProjectList struct {
	Project []*SearchEditingProjectResponseBodyProjectListProject `json:"Project,omitempty" xml:"Project,omitempty" type:"Repeated"`
}

func (s SearchEditingProjectResponseBodyProjectList) String() string {
	return tea.Prettify(s)
}

func (s SearchEditingProjectResponseBodyProjectList) GoString() string {
	return s.String()
}

func (s *SearchEditingProjectResponseBodyProjectList) SetProject(v []*SearchEditingProjectResponseBodyProjectListProject) *SearchEditingProjectResponseBodyProjectList {
	s.Project = v
	return s
}

type SearchEditingProjectResponseBodyProjectListProject struct {
	// The thumbnail URL of the online editing project.
	//
	// example:
	//
	// cover_url
	CoverURL *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	// The time when the online editing project was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-01-11T12:00:00Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the online editing project.
	//
	// example:
	//
	// test project 001
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The duration of the online editing project, which must be consistent with the duration of the timeline.
	//
	// > The Timeline parameter is not included in response parameters.
	//
	// example:
	//
	// 22.65
	Duration *float32 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The last time when the online editing project was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2017-01-11T13:00:00Z
	ModifiedTime *string `json:"ModifiedTime,omitempty" xml:"ModifiedTime,omitempty"`
	// The ID of the online editing project.
	//
	// example:
	//
	// 25cfc178d2de4*****e77aebed6afcd
	ProjectId *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The region where the online editing project was created.
	//
	// example:
	//
	// cn-shanghai
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The status of the online editing project. Separate multiple states with commas (,). By default, all online editing projects were queried. Valid values:
	//
	// 	- **Normal**: indicates that the online editing project is in draft.
	//
	// 	- **Producing**: indicates that the video is being produced.
	//
	// 	- **Produced**: indicates that the video was produced.
	//
	// 	- **ProduceFailed**: indicates that the video failed to be produced.
	//
	// example:
	//
	// Normal
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The path of the Object Storage Service (OSS) bucket where the produced video is stored.
	//
	// > To view the path of the OSS bucket, log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com/?spm=a2c4g.11186623.2.15.6948257eaZ4m54#/vod/settings/censored), and choose **Configuration Management*	- > **Media Management*	- > **Storage**. On the Storage page, you can view the path of the OSS bucket.
	//
	// example:
	//
	// location_s
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	// The title of the online editing project.
	//
	// example:
	//
	// video_150873681****
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
}

func (s SearchEditingProjectResponseBodyProjectListProject) String() string {
	return tea.Prettify(s)
}

func (s SearchEditingProjectResponseBodyProjectListProject) GoString() string {
	return s.String()
}

func (s *SearchEditingProjectResponseBodyProjectListProject) SetCoverURL(v string) *SearchEditingProjectResponseBodyProjectListProject {
	s.CoverURL = &v
	return s
}

func (s *SearchEditingProjectResponseBodyProjectListProject) SetCreationTime(v string) *SearchEditingProjectResponseBodyProjectListProject {
	s.CreationTime = &v
	return s
}

func (s *SearchEditingProjectResponseBodyProjectListProject) SetDescription(v string) *SearchEditingProjectResponseBodyProjectListProject {
	s.Description = &v
	return s
}

func (s *SearchEditingProjectResponseBodyProjectListProject) SetDuration(v float32) *SearchEditingProjectResponseBodyProjectListProject {
	s.Duration = &v
	return s
}

func (s *SearchEditingProjectResponseBodyProjectListProject) SetModifiedTime(v string) *SearchEditingProjectResponseBodyProjectListProject {
	s.ModifiedTime = &v
	return s
}

func (s *SearchEditingProjectResponseBodyProjectListProject) SetProjectId(v string) *SearchEditingProjectResponseBodyProjectListProject {
	s.ProjectId = &v
	return s
}

func (s *SearchEditingProjectResponseBodyProjectListProject) SetRegionId(v string) *SearchEditingProjectResponseBodyProjectListProject {
	s.RegionId = &v
	return s
}

func (s *SearchEditingProjectResponseBodyProjectListProject) SetStatus(v string) *SearchEditingProjectResponseBodyProjectListProject {
	s.Status = &v
	return s
}

func (s *SearchEditingProjectResponseBodyProjectListProject) SetStorageLocation(v string) *SearchEditingProjectResponseBodyProjectListProject {
	s.StorageLocation = &v
	return s
}

func (s *SearchEditingProjectResponseBodyProjectListProject) SetTitle(v string) *SearchEditingProjectResponseBodyProjectListProject {
	s.Title = &v
	return s
}

type SearchEditingProjectResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SearchEditingProjectResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SearchEditingProjectResponse) String() string {
	return tea.Prettify(s)
}

func (s SearchEditingProjectResponse) GoString() string {
	return s.String()
}

func (s *SearchEditingProjectResponse) SetHeaders(v map[string]*string) *SearchEditingProjectResponse {
	s.Headers = v
	return s
}

func (s *SearchEditingProjectResponse) SetStatusCode(v int32) *SearchEditingProjectResponse {
	s.StatusCode = &v
	return s
}

func (s *SearchEditingProjectResponse) SetBody(v *SearchEditingProjectResponseBody) *SearchEditingProjectResponse {
	s.Body = v
	return s
}

type SearchMediaRequest struct {
	// The media asset fields to return in the query results.
	//
	// By default, only the basic media asset fields are returned. You can specify additional media asset fields that need to be returned in the request. For more information, see the "API examples" section of the [Search for media asset information](https://help.aliyun.com/document_detail/99179.html) topic.
	//
	// example:
	//
	// Title,CoverURL
	Fields *string `json:"Fields,omitempty" xml:"Fields,omitempty"`
	// The filter condition. For more information about the syntax, see [Protocol for media asset search](https://help.aliyun.com/document_detail/86991.html).
	//
	// example:
	//
	// field = value
	Match *string `json:"Match,omitempty" xml:"Match,omitempty"`
	// The number of the page to return. Default value: **1**.
	//
	// > If the value of this parameter exceeds **200**, we recommend that you set the ScrollToken parameter as well.
	//
	// example:
	//
	// 1
	PageNo *int32 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The number of entries to return on each page. Default value: **10**. Maximum value: **100**.
	//
	// example:
	//
	// 10
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The pagination identifier. The password must be 32 characters in length The first time you call this operation for each new search, you do not need to specify this parameter. The value of this parameter is returned each time data records that meet the specified filter condition are found. The value is used to record the current position of queried data. Record the returned parameter value and set this parameter according to the following requirements during the next search:
	//
	// 	- If SearchType is set to **video*	- or **audio*	- and you need to traverse all data that meets the filter criteria, you must set the ScrollToken parameter.
	//
	// 	- If the value of the PageNo parameter exceeds **200**, we recommend that you set this parameter to optimize search performance.
	//
	// example:
	//
	// 24e0fba7188fae707e146esa54****
	ScrollToken *string `json:"ScrollToken,omitempty" xml:"ScrollToken,omitempty"`
	// The type of the media asset that you want to query. Default value: video. Valid values:
	//
	// 	- **video**
	//
	// 	- **audio**
	//
	// 	- **image**
	//
	// 	- **attached**
	//
	// > If this parameter is set to **video*	- or **audio*	- and you want to traverse all data that meets the filter criteria, you must set the ScrollToken parameter.
	//
	// example:
	//
	// video
	SearchType *string `json:"SearchType,omitempty" xml:"SearchType,omitempty"`
	// The sort field and order. Separate multiple values with commas (,). Default value: CreationTime:Desc. Valid values:
	//
	// 	- **CreationTime:Desc**: The results are sorted in reverse chronological order based on the creation time.
	//
	// 	- **CreationTime:Asc**: The results are sorted in chronological order based on the creation time.
	//
	// > 	- For more information about the sort field, see "Sort field" in the [Search for media asset information](https://help.aliyun.com/document_detail/99179.html) topic.
	//
	// > 	- To obtain the first 5,000 data records that meet the specified filter criteria, you can specify a maximum of three sort fields.
	//
	// > 	- To obtain all the data records that meet the specified filter criteria, you can specify only one sort field.
	//
	// example:
	//
	// CreationTime:Desc
	SortBy *string `json:"SortBy,omitempty" xml:"SortBy,omitempty"`
}

func (s SearchMediaRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchMediaRequest) GoString() string {
	return s.String()
}

func (s *SearchMediaRequest) SetFields(v string) *SearchMediaRequest {
	s.Fields = &v
	return s
}

func (s *SearchMediaRequest) SetMatch(v string) *SearchMediaRequest {
	s.Match = &v
	return s
}

func (s *SearchMediaRequest) SetPageNo(v int32) *SearchMediaRequest {
	s.PageNo = &v
	return s
}

func (s *SearchMediaRequest) SetPageSize(v int32) *SearchMediaRequest {
	s.PageSize = &v
	return s
}

func (s *SearchMediaRequest) SetScrollToken(v string) *SearchMediaRequest {
	s.ScrollToken = &v
	return s
}

func (s *SearchMediaRequest) SetSearchType(v string) *SearchMediaRequest {
	s.SearchType = &v
	return s
}

func (s *SearchMediaRequest) SetSortBy(v string) *SearchMediaRequest {
	s.SortBy = &v
	return s
}

type SearchMediaResponseBody struct {
	// The information about the media assets.
	MediaList []*SearchMediaResponseBodyMediaList `json:"MediaList,omitempty" xml:"MediaList,omitempty" type:"Repeated"`
	// The ID of the request.
	//
	// example:
	//
	// 3E0CEF83-FB09-4E34-BA1451814B03****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The pagination identifier.
	//
	// example:
	//
	// 24e0fba7188fae707e146esa54****
	ScrollToken *string `json:"ScrollToken,omitempty" xml:"ScrollToken,omitempty"`
	// The total number of data records that meet the specified filter criteria.
	//
	// example:
	//
	// 10
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s SearchMediaResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SearchMediaResponseBody) GoString() string {
	return s.String()
}

func (s *SearchMediaResponseBody) SetMediaList(v []*SearchMediaResponseBodyMediaList) *SearchMediaResponseBody {
	s.MediaList = v
	return s
}

func (s *SearchMediaResponseBody) SetRequestId(v string) *SearchMediaResponseBody {
	s.RequestId = &v
	return s
}

func (s *SearchMediaResponseBody) SetScrollToken(v string) *SearchMediaResponseBody {
	s.ScrollToken = &v
	return s
}

func (s *SearchMediaResponseBody) SetTotal(v int64) *SearchMediaResponseBody {
	s.Total = &v
	return s
}

type SearchMediaResponseBodyMediaList struct {
	// Details about AI data.
	AiData *SearchMediaResponseBodyMediaListAiData `json:"AiData,omitempty" xml:"AiData,omitempty" type:"Struct"`
	// The basic information about AI data.
	AiRoughData *SearchMediaResponseBodyMediaListAiRoughData `json:"AiRoughData,omitempty" xml:"AiRoughData,omitempty" type:"Struct"`
	// [The information about the auxiliary media asset](https://help.aliyun.com/document_detail/86991.html).
	AttachedMedia *SearchMediaResponseBodyMediaListAttachedMedia `json:"AttachedMedia,omitempty" xml:"AttachedMedia,omitempty" type:"Struct"`
	// [The information about the audio](https://help.aliyun.com/document_detail/86991.html).
	Audio *SearchMediaResponseBodyMediaListAudio `json:"Audio,omitempty" xml:"Audio,omitempty" type:"Struct"`
	// The time when the media asset was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*hh:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2018-07-19T03:45:25Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// [The information about the image](https://help.aliyun.com/document_detail/86991.html).
	Image *SearchMediaResponseBodyMediaListImage `json:"Image,omitempty" xml:"Image,omitempty" type:"Struct"`
	// The ID of the file.
	//
	// example:
	//
	// a82a2cd7d4e147bbed6c1ee372****
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The type of the media asset. Valid values:
	//
	// 	- **video**
	//
	// 	- **audio**
	//
	// 	- **image**
	//
	// 	- **attached**
	//
	// example:
	//
	// video
	MediaType *string `json:"MediaType,omitempty" xml:"MediaType,omitempty"`
	// [The information about the video](https://help.aliyun.com/document_detail/86991.html).
	Video *SearchMediaResponseBodyMediaListVideo `json:"Video,omitempty" xml:"Video,omitempty" type:"Struct"`
}

func (s SearchMediaResponseBodyMediaList) String() string {
	return tea.Prettify(s)
}

func (s SearchMediaResponseBodyMediaList) GoString() string {
	return s.String()
}

func (s *SearchMediaResponseBodyMediaList) SetAiData(v *SearchMediaResponseBodyMediaListAiData) *SearchMediaResponseBodyMediaList {
	s.AiData = v
	return s
}

func (s *SearchMediaResponseBodyMediaList) SetAiRoughData(v *SearchMediaResponseBodyMediaListAiRoughData) *SearchMediaResponseBodyMediaList {
	s.AiRoughData = v
	return s
}

func (s *SearchMediaResponseBodyMediaList) SetAttachedMedia(v *SearchMediaResponseBodyMediaListAttachedMedia) *SearchMediaResponseBodyMediaList {
	s.AttachedMedia = v
	return s
}

func (s *SearchMediaResponseBodyMediaList) SetAudio(v *SearchMediaResponseBodyMediaListAudio) *SearchMediaResponseBodyMediaList {
	s.Audio = v
	return s
}

func (s *SearchMediaResponseBodyMediaList) SetCreationTime(v string) *SearchMediaResponseBodyMediaList {
	s.CreationTime = &v
	return s
}

func (s *SearchMediaResponseBodyMediaList) SetImage(v *SearchMediaResponseBodyMediaListImage) *SearchMediaResponseBodyMediaList {
	s.Image = v
	return s
}

func (s *SearchMediaResponseBodyMediaList) SetMediaId(v string) *SearchMediaResponseBodyMediaList {
	s.MediaId = &v
	return s
}

func (s *SearchMediaResponseBodyMediaList) SetMediaType(v string) *SearchMediaResponseBodyMediaList {
	s.MediaType = &v
	return s
}

func (s *SearchMediaResponseBodyMediaList) SetVideo(v *SearchMediaResponseBodyMediaListVideo) *SearchMediaResponseBodyMediaList {
	s.Video = v
	return s
}

type SearchMediaResponseBodyMediaListAiData struct {
	// The AI tags.
	AiLabelInfo []*SearchMediaResponseBodyMediaListAiDataAiLabelInfo `json:"AiLabelInfo,omitempty" xml:"AiLabelInfo,omitempty" type:"Repeated"`
	// The information about subtitles.
	OcrInfo []*SearchMediaResponseBodyMediaListAiDataOcrInfo `json:"OcrInfo,omitempty" xml:"OcrInfo,omitempty" type:"Repeated"`
}

func (s SearchMediaResponseBodyMediaListAiData) String() string {
	return tea.Prettify(s)
}

func (s SearchMediaResponseBodyMediaListAiData) GoString() string {
	return s.String()
}

func (s *SearchMediaResponseBodyMediaListAiData) SetAiLabelInfo(v []*SearchMediaResponseBodyMediaListAiDataAiLabelInfo) *SearchMediaResponseBodyMediaListAiData {
	s.AiLabelInfo = v
	return s
}

func (s *SearchMediaResponseBodyMediaListAiData) SetOcrInfo(v []*SearchMediaResponseBodyMediaListAiDataOcrInfo) *SearchMediaResponseBodyMediaListAiData {
	s.OcrInfo = v
	return s
}

type SearchMediaResponseBodyMediaListAiDataAiLabelInfo struct {
	// The category.
	//
	// example:
	//
	// Transportation
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// The ID of the tag.
	//
	// example:
	//
	// 10310250338
	LabelId *string `json:"LabelId,omitempty" xml:"LabelId,omitempty"`
	// The name of the tag.
	//
	// example:
	//
	// Vehicles
	LabelName *string `json:"LabelName,omitempty" xml:"LabelName,omitempty"`
	// The clips.
	Occurrences []*SearchMediaResponseBodyMediaListAiDataAiLabelInfoOccurrences `json:"Occurrences,omitempty" xml:"Occurrences,omitempty" type:"Repeated"`
}

func (s SearchMediaResponseBodyMediaListAiDataAiLabelInfo) String() string {
	return tea.Prettify(s)
}

func (s SearchMediaResponseBodyMediaListAiDataAiLabelInfo) GoString() string {
	return s.String()
}

func (s *SearchMediaResponseBodyMediaListAiDataAiLabelInfo) SetCategory(v string) *SearchMediaResponseBodyMediaListAiDataAiLabelInfo {
	s.Category = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAiDataAiLabelInfo) SetLabelId(v string) *SearchMediaResponseBodyMediaListAiDataAiLabelInfo {
	s.LabelId = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAiDataAiLabelInfo) SetLabelName(v string) *SearchMediaResponseBodyMediaListAiDataAiLabelInfo {
	s.LabelName = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAiDataAiLabelInfo) SetOccurrences(v []*SearchMediaResponseBodyMediaListAiDataAiLabelInfoOccurrences) *SearchMediaResponseBodyMediaListAiDataAiLabelInfo {
	s.Occurrences = v
	return s
}

type SearchMediaResponseBodyMediaListAiDataAiLabelInfoOccurrences struct {
	// The start time of the clip.
	//
	// example:
	//
	// 1.4
	From *float64 `json:"From,omitempty" xml:"From,omitempty"`
	// The score.
	//
	// example:
	//
	// 0.75287705
	Score *float64 `json:"Score,omitempty" xml:"Score,omitempty"`
	// The end time of the clip.
	//
	// example:
	//
	// 2.5
	To *float64 `json:"To,omitempty" xml:"To,omitempty"`
}

func (s SearchMediaResponseBodyMediaListAiDataAiLabelInfoOccurrences) String() string {
	return tea.Prettify(s)
}

func (s SearchMediaResponseBodyMediaListAiDataAiLabelInfoOccurrences) GoString() string {
	return s.String()
}

func (s *SearchMediaResponseBodyMediaListAiDataAiLabelInfoOccurrences) SetFrom(v float64) *SearchMediaResponseBodyMediaListAiDataAiLabelInfoOccurrences {
	s.From = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAiDataAiLabelInfoOccurrences) SetScore(v float64) *SearchMediaResponseBodyMediaListAiDataAiLabelInfoOccurrences {
	s.Score = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAiDataAiLabelInfoOccurrences) SetTo(v float64) *SearchMediaResponseBodyMediaListAiDataAiLabelInfoOccurrences {
	s.To = &v
	return s
}

type SearchMediaResponseBodyMediaListAiDataOcrInfo struct {
	// The text content.
	//
	// example:
	//
	// I\\"m Jane.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The start time of the subtitle.
	//
	// example:
	//
	// 1.4
	From *float64 `json:"From,omitempty" xml:"From,omitempty"`
	// The end time of the subtitle.
	//
	// example:
	//
	// 2.5
	To *float64 `json:"To,omitempty" xml:"To,omitempty"`
}

func (s SearchMediaResponseBodyMediaListAiDataOcrInfo) String() string {
	return tea.Prettify(s)
}

func (s SearchMediaResponseBodyMediaListAiDataOcrInfo) GoString() string {
	return s.String()
}

func (s *SearchMediaResponseBodyMediaListAiDataOcrInfo) SetContent(v string) *SearchMediaResponseBodyMediaListAiDataOcrInfo {
	s.Content = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAiDataOcrInfo) SetFrom(v float64) *SearchMediaResponseBodyMediaListAiDataOcrInfo {
	s.From = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAiDataOcrInfo) SetTo(v float64) *SearchMediaResponseBodyMediaListAiDataOcrInfo {
	s.To = &v
	return s
}

type SearchMediaResponseBodyMediaListAiRoughData struct {
	// The AI category.
	//
	// example:
	//
	// TV series
	AiCategory *string `json:"AiCategory,omitempty" xml:"AiCategory,omitempty"`
	// The ID of the AI task.
	//
	// example:
	//
	// cd35b0b0025f71edbfcb472190a9xxxx
	AiJobId *string `json:"AiJobId,omitempty" xml:"AiJobId,omitempty"`
	// The save type.
	//
	// example:
	//
	// TEXT
	SaveType *string `json:"SaveType,omitempty" xml:"SaveType,omitempty"`
	// The data status.
	//
	// example:
	//
	// SaveSuccess
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s SearchMediaResponseBodyMediaListAiRoughData) String() string {
	return tea.Prettify(s)
}

func (s SearchMediaResponseBodyMediaListAiRoughData) GoString() string {
	return s.String()
}

func (s *SearchMediaResponseBodyMediaListAiRoughData) SetAiCategory(v string) *SearchMediaResponseBodyMediaListAiRoughData {
	s.AiCategory = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAiRoughData) SetAiJobId(v string) *SearchMediaResponseBodyMediaListAiRoughData {
	s.AiJobId = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAiRoughData) SetSaveType(v string) *SearchMediaResponseBodyMediaListAiRoughData {
	s.SaveType = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAiRoughData) SetStatus(v string) *SearchMediaResponseBodyMediaListAiRoughData {
	s.Status = &v
	return s
}

type SearchMediaResponseBodyMediaListAttachedMedia struct {
	// The ID of the application.
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The type of the auxiliary media asset. Valid values:
	//
	// 	- **watermark**
	//
	// 	- **subtitle**
	//
	// 	- **material**
	//
	// example:
	//
	// watermark
	BusinessType *string `json:"BusinessType,omitempty" xml:"BusinessType,omitempty"`
	// The list of category IDs.
	Categories []*SearchMediaResponseBodyMediaListAttachedMediaCategories `json:"Categories,omitempty" xml:"Categories,omitempty" type:"Repeated"`
	// The time when the auxiliary media asset was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*hh:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2018-07-19T03:45:25Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the auxiliary media asset.
	//
	// example:
	//
	// test3
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the auxiliary media asset.
	//
	// example:
	//
	// a82a2cd7d4e147ba0ed6c1ee372****
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The time when the auxiliary media asset was updated. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*hh:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2018-07-19T03:48:25Z
	ModificationTime *string `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	// The status of the auxiliary media asset. Valid values:
	//
	// 	- **Uploading**
	//
	// 	- **Normal**
	//
	// 	- **UploadFail**
	//
	// example:
	//
	// Normal
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The region in which the auxiliary media asset is stored.
	//
	// example:
	//
	// outin-bfefbb90a47c11*****7426.oss-cn-shanghai.aliyuncs.com
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	// The tags of the auxiliary media asset.
	//
	// example:
	//
	// test2
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The title of the auxiliary media asset.
	//
	// example:
	//
	// test
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The URL of the auxiliary media asset.
	//
	// example:
	//
	// https://example.com/****.png
	URL *string `json:"URL,omitempty" xml:"URL,omitempty"`
}

func (s SearchMediaResponseBodyMediaListAttachedMedia) String() string {
	return tea.Prettify(s)
}

func (s SearchMediaResponseBodyMediaListAttachedMedia) GoString() string {
	return s.String()
}

func (s *SearchMediaResponseBodyMediaListAttachedMedia) SetAppId(v string) *SearchMediaResponseBodyMediaListAttachedMedia {
	s.AppId = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAttachedMedia) SetBusinessType(v string) *SearchMediaResponseBodyMediaListAttachedMedia {
	s.BusinessType = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAttachedMedia) SetCategories(v []*SearchMediaResponseBodyMediaListAttachedMediaCategories) *SearchMediaResponseBodyMediaListAttachedMedia {
	s.Categories = v
	return s
}

func (s *SearchMediaResponseBodyMediaListAttachedMedia) SetCreationTime(v string) *SearchMediaResponseBodyMediaListAttachedMedia {
	s.CreationTime = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAttachedMedia) SetDescription(v string) *SearchMediaResponseBodyMediaListAttachedMedia {
	s.Description = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAttachedMedia) SetMediaId(v string) *SearchMediaResponseBodyMediaListAttachedMedia {
	s.MediaId = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAttachedMedia) SetModificationTime(v string) *SearchMediaResponseBodyMediaListAttachedMedia {
	s.ModificationTime = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAttachedMedia) SetStatus(v string) *SearchMediaResponseBodyMediaListAttachedMedia {
	s.Status = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAttachedMedia) SetStorageLocation(v string) *SearchMediaResponseBodyMediaListAttachedMedia {
	s.StorageLocation = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAttachedMedia) SetTags(v string) *SearchMediaResponseBodyMediaListAttachedMedia {
	s.Tags = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAttachedMedia) SetTitle(v string) *SearchMediaResponseBodyMediaListAttachedMedia {
	s.Title = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAttachedMedia) SetURL(v string) *SearchMediaResponseBodyMediaListAttachedMedia {
	s.URL = &v
	return s
}

type SearchMediaResponseBodyMediaListAttachedMediaCategories struct {
	// The category ID of the auxiliary media asset.
	//
	// example:
	//
	// 10027394
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The name of the category.
	//
	// example:
	//
	// test1
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	// The level of the category.
	//
	// example:
	//
	// 1
	Level *int64 `json:"Level,omitempty" xml:"Level,omitempty"`
	// The ID of the parent node.
	//
	// example:
	//
	// -1
	ParentId *int64 `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
}

func (s SearchMediaResponseBodyMediaListAttachedMediaCategories) String() string {
	return tea.Prettify(s)
}

func (s SearchMediaResponseBodyMediaListAttachedMediaCategories) GoString() string {
	return s.String()
}

func (s *SearchMediaResponseBodyMediaListAttachedMediaCategories) SetCateId(v int64) *SearchMediaResponseBodyMediaListAttachedMediaCategories {
	s.CateId = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAttachedMediaCategories) SetCateName(v string) *SearchMediaResponseBodyMediaListAttachedMediaCategories {
	s.CateName = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAttachedMediaCategories) SetLevel(v int64) *SearchMediaResponseBodyMediaListAttachedMediaCategories {
	s.Level = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAttachedMediaCategories) SetParentId(v int64) *SearchMediaResponseBodyMediaListAttachedMediaCategories {
	s.ParentId = &v
	return s
}

type SearchMediaResponseBodyMediaListAudio struct {
	// The ID of the application.
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the audio file.
	//
	// example:
	//
	// a82a2cd7d4e147bbed6c1ee372****
	AudioId *string `json:"AudioId,omitempty" xml:"AudioId,omitempty"`
	// The ID of the category.
	//
	// example:
	//
	// 10000123
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The name of the category.
	//
	// example:
	//
	// ceshi
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	// The URL of the thumbnail.
	//
	// example:
	//
	// http://example.com/image04.jpg
	CoverURL *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	// The time when the audio stream was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*hh:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2018-07-19T03:45:25Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the audio file.
	//
	// example:
	//
	// audio description
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The download switch. The audio file can be downloaded offline only when the download switch is turned on. Valid values:
	//
	// 	- **on**
	//
	// 	- **off**
	//
	// example:
	//
	// on
	DownloadSwitch *string `json:"DownloadSwitch,omitempty" xml:"DownloadSwitch,omitempty"`
	// The duration of the audio file.
	//
	// example:
	//
	// 123
	Duration *float32 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The source of the audio file. Valid values:
	//
	// 	- **general**: The audio file is uploaded by using ApsaraVideo VOD.
	//
	// 	- **short_video**: The audio file is uploaded to ApsaraVideo VOD by using the short video SDK. For more information, see [Introduction](https://help.aliyun.com/document_detail/53407.html).
	//
	// 	- **editing**: The audio file is uploaded to ApsaraVideo VOD after online editing and production. For more information, see [ProduceEditingProjectVideo](https://help.aliyun.com/document_detail/68536.html).
	//
	// 	- **live**: The audio file is recorded and uploaded as a file to ApsaraVideo VOD.
	//
	// example:
	//
	// general
	MediaSource *string `json:"MediaSource,omitempty" xml:"MediaSource,omitempty"`
	// The time when the audio file was updated. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*hh:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2018-07-19T03:48:25Z
	ModificationTime *string `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	// The preprocessing status. Only preprocessed videos can be used for live streaming in the production studio. Valid values:
	//
	// 	- **UnPreprocess**
	//
	// 	- **Preprocessing**
	//
	// 	- **PreprocessSucceed**
	//
	// 	- **PreprocessFailed**
	//
	// example:
	//
	// UnPreprocess
	PreprocessStatus *string `json:"PreprocessStatus,omitempty" xml:"PreprocessStatus,omitempty"`
	// The period of time in which the audio file remains in the restored state.
	//
	// example:
	//
	// 2023-03-30T10:14:14Z
	RestoreExpiration *string `json:"RestoreExpiration,omitempty" xml:"RestoreExpiration,omitempty"`
	// The restoration status of the audio file. Valid values:
	//
	// 	- **Processing**
	//
	// 	- **Success**
	//
	// 	- **Failed**
	//
	// example:
	//
	// Success
	RestoreStatus *string `json:"RestoreStatus,omitempty" xml:"RestoreStatus,omitempty"`
	// The size of the audio file.
	//
	// example:
	//
	// 123
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The automatic snapshots.
	Snapshots []*string `json:"Snapshots,omitempty" xml:"Snapshots,omitempty" type:"Repeated"`
	// The sprite snapshots.
	SpriteSnapshots []*string `json:"SpriteSnapshots,omitempty" xml:"SpriteSnapshots,omitempty" type:"Repeated"`
	// The status of the audio file. Valid values:
	//
	// 	- **Uploading**
	//
	// 	- **Normal**
	//
	// 	- **UploadFail**
	//
	// 	- **Deleted**
	//
	// example:
	//
	// Normal
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The storage class of the audio file. Valid values:
	//
	// 	- **Standard**: All media resources are stored as Standard objects.
	//
	// 	- **IA**: All media resources are stored as IA objects.
	//
	// 	- **Archive**: All media resources are stored as Archive objects.
	//
	// 	- **ColdArchive**: All media resources are stored as Cold Archive objects.
	//
	// 	- **SourceIA**: Only the source file is stored as an IA object.
	//
	// 	- **SourceArchive**: Only the source file is stored as an Archive object.
	//
	// 	- **SourceColdArchive**: Only the source file is stored as a Cold Archive object.
	//
	// 	- **Changing**: The storage class is being modified.
	//
	// example:
	//
	// Standard
	StorageClass *string `json:"StorageClass,omitempty" xml:"StorageClass,omitempty"`
	// The region in which the audio is stored.
	//
	// example:
	//
	// outin-aaa*****aa.oss-cn-shanghai.aliyuncs.com
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	// The tags of the audio file.
	//
	// example:
	//
	// tag1,tag2
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The title of the audio file
	//
	// example:
	//
	// audio
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The transcoding mode. Valid values:
	//
	// 	- **FastTranscode**: The audio file is immediately transcoded after it is uploaded. You cannot play the file before it is transcoded.
	//
	// 	- **NoTranscode**: The audio file can be played without being transcoded. You can immediately play the file after it is uploaded.
	//
	// 	- **AsyncTranscode**: The audio file can be immediately played and asynchronously transcoded after it is uploaded.
	//
	// example:
	//
	// FastTranscode
	TranscodeMode *string `json:"TranscodeMode,omitempty" xml:"TranscodeMode,omitempty"`
}

func (s SearchMediaResponseBodyMediaListAudio) String() string {
	return tea.Prettify(s)
}

func (s SearchMediaResponseBodyMediaListAudio) GoString() string {
	return s.String()
}

func (s *SearchMediaResponseBodyMediaListAudio) SetAppId(v string) *SearchMediaResponseBodyMediaListAudio {
	s.AppId = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetAudioId(v string) *SearchMediaResponseBodyMediaListAudio {
	s.AudioId = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetCateId(v int64) *SearchMediaResponseBodyMediaListAudio {
	s.CateId = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetCateName(v string) *SearchMediaResponseBodyMediaListAudio {
	s.CateName = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetCoverURL(v string) *SearchMediaResponseBodyMediaListAudio {
	s.CoverURL = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetCreationTime(v string) *SearchMediaResponseBodyMediaListAudio {
	s.CreationTime = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetDescription(v string) *SearchMediaResponseBodyMediaListAudio {
	s.Description = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetDownloadSwitch(v string) *SearchMediaResponseBodyMediaListAudio {
	s.DownloadSwitch = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetDuration(v float32) *SearchMediaResponseBodyMediaListAudio {
	s.Duration = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetMediaSource(v string) *SearchMediaResponseBodyMediaListAudio {
	s.MediaSource = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetModificationTime(v string) *SearchMediaResponseBodyMediaListAudio {
	s.ModificationTime = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetPreprocessStatus(v string) *SearchMediaResponseBodyMediaListAudio {
	s.PreprocessStatus = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetRestoreExpiration(v string) *SearchMediaResponseBodyMediaListAudio {
	s.RestoreExpiration = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetRestoreStatus(v string) *SearchMediaResponseBodyMediaListAudio {
	s.RestoreStatus = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetSize(v int64) *SearchMediaResponseBodyMediaListAudio {
	s.Size = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetSnapshots(v []*string) *SearchMediaResponseBodyMediaListAudio {
	s.Snapshots = v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetSpriteSnapshots(v []*string) *SearchMediaResponseBodyMediaListAudio {
	s.SpriteSnapshots = v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetStatus(v string) *SearchMediaResponseBodyMediaListAudio {
	s.Status = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetStorageClass(v string) *SearchMediaResponseBodyMediaListAudio {
	s.StorageClass = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetStorageLocation(v string) *SearchMediaResponseBodyMediaListAudio {
	s.StorageLocation = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetTags(v string) *SearchMediaResponseBodyMediaListAudio {
	s.Tags = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetTitle(v string) *SearchMediaResponseBodyMediaListAudio {
	s.Title = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetTranscodeMode(v string) *SearchMediaResponseBodyMediaListAudio {
	s.TranscodeMode = &v
	return s
}

type SearchMediaResponseBodyMediaListImage struct {
	// The ID of the application.
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the category.
	//
	// example:
	//
	// 1000123
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The name of the category.
	//
	// example:
	//
	// beauty
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	// The time when the image was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*hh:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2018-07-19T03:45:25Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the image file.
	//
	// example:
	//
	// image test
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the image file.
	//
	// example:
	//
	// 11130843741se99wqmoes****
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The time when the image file was updated. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*hh:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2018-07-19T03:48:25Z
	ModificationTime *string `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	// The status of the image file.
	//
	// 	- **Uploading**
	//
	// 	- **Normal**
	//
	// 	- **UploadFail**
	//
	// example:
	//
	// Uploading
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The region in which the image is stored.
	//
	// example:
	//
	// outin-bfefbb90a47c******163e1c7426.oss-cn-shanghai.aliyuncs.com
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	// The tags of the image file.
	//
	// example:
	//
	// tag1
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The title of the image file.
	//
	// example:
	//
	// image1
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The URL of the image file.
	//
	// example:
	//
	// https://example.com/****.png
	URL *string `json:"URL,omitempty" xml:"URL,omitempty"`
}

func (s SearchMediaResponseBodyMediaListImage) String() string {
	return tea.Prettify(s)
}

func (s SearchMediaResponseBodyMediaListImage) GoString() string {
	return s.String()
}

func (s *SearchMediaResponseBodyMediaListImage) SetAppId(v string) *SearchMediaResponseBodyMediaListImage {
	s.AppId = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListImage) SetCateId(v int64) *SearchMediaResponseBodyMediaListImage {
	s.CateId = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListImage) SetCateName(v string) *SearchMediaResponseBodyMediaListImage {
	s.CateName = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListImage) SetCreationTime(v string) *SearchMediaResponseBodyMediaListImage {
	s.CreationTime = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListImage) SetDescription(v string) *SearchMediaResponseBodyMediaListImage {
	s.Description = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListImage) SetImageId(v string) *SearchMediaResponseBodyMediaListImage {
	s.ImageId = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListImage) SetModificationTime(v string) *SearchMediaResponseBodyMediaListImage {
	s.ModificationTime = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListImage) SetStatus(v string) *SearchMediaResponseBodyMediaListImage {
	s.Status = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListImage) SetStorageLocation(v string) *SearchMediaResponseBodyMediaListImage {
	s.StorageLocation = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListImage) SetTags(v string) *SearchMediaResponseBodyMediaListImage {
	s.Tags = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListImage) SetTitle(v string) *SearchMediaResponseBodyMediaListImage {
	s.Title = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListImage) SetURL(v string) *SearchMediaResponseBodyMediaListImage {
	s.URL = &v
	return s
}

type SearchMediaResponseBodyMediaListVideo struct {
	// The ID of the application.
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the category.
	//
	// example:
	//
	// 10000123
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The name of the category.
	//
	// example:
	//
	// video1
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	// The URL of the thumbnail.
	//
	// example:
	//
	// https://example.aliyundoc.com/image01.png
	CoverURL *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	// The time when the video file was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*hh:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2018-07-19T03:45:25Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the video file.
	//
	// example:
	//
	// Video test
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The download switch. The video file can be downloaded offline only when the download switch is turned on. Valid values:
	//
	// 	- **on**
	//
	// 	- **off**
	//
	// example:
	//
	// on
	DownloadSwitch *string `json:"DownloadSwitch,omitempty" xml:"DownloadSwitch,omitempty"`
	// The duration of the video file. Unit: seconds.
	//
	// example:
	//
	// 123
	Duration *float32 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The source of the video file. Valid values:
	//
	// 	- **general**: The video file is uploaded by using ApsaraVideo VOD.
	//
	// 	- **short_video**: The video file is uploaded by using the short video SDK.
	//
	// 	- **editing**: The video file is produced after online editing.
	//
	// 	- **live**: The video stream is recorded and uploaded as a file.
	//
	// example:
	//
	// general
	MediaSource *string `json:"MediaSource,omitempty" xml:"MediaSource,omitempty"`
	// The time when the video file was updated. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*hh:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2018-07-19T03:48:25Z
	ModificationTime *string `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	// The preprocessing status. Valid values:
	//
	// 	- **UnPreprocess**
	//
	// 	- **Preprocessing**
	//
	// 	- **PreprocessSucceed**
	//
	// 	- **PreprocessFailed**
	//
	// example:
	//
	// Preprocessing
	PreprocessStatus *string `json:"PreprocessStatus,omitempty" xml:"PreprocessStatus,omitempty"`
	// The period of time in which the video file remains in the restored state.
	//
	// example:
	//
	// 2023-03-30T10:14:14Z
	RestoreExpiration *string `json:"RestoreExpiration,omitempty" xml:"RestoreExpiration,omitempty"`
	// The restoration status of the video file. Valid values:
	//
	// 	- **Processing**
	//
	// 	- **Success**
	//
	// 	- **Failed**
	//
	// example:
	//
	// Success
	RestoreStatus *string `json:"RestoreStatus,omitempty" xml:"RestoreStatus,omitempty"`
	// The size of the video file.
	//
	// example:
	//
	// 123
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The automatic snapshots.
	Snapshots []*string `json:"Snapshots,omitempty" xml:"Snapshots,omitempty" type:"Repeated"`
	// The sprite snapshots.
	SpriteSnapshots []*string `json:"SpriteSnapshots,omitempty" xml:"SpriteSnapshots,omitempty" type:"Repeated"`
	// The status of the file. Valid values:
	//
	// 	- **Uploading**
	//
	// 	- **UploadFail**
	//
	// 	- **UploadSucc**
	//
	// 	- **Transcoding**
	//
	// 	- **TranscodeFail**
	//
	// 	- **Blocked**
	//
	// 	- **Normal**
	//
	// example:
	//
	// UploadSucc
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The storage class of the video file. Valid values:
	//
	// 	- **Standard**: All media resources are stored as Standard objects.
	//
	// 	- **IA**: All media resources are stored as IA objects.
	//
	// 	- **Archive**: All media resources are stored as Archive objects.
	//
	// 	- **ColdArchive**: All media resources are stored as Cold Archive objects.
	//
	// 	- **SourceIA**: Only the source file is stored as an IA object.
	//
	// 	- **SourceArchive**: Only the source file is stored as an Archive object.
	//
	// 	- **SourceColdArchive**: Only the source file is stored as a Cold Archive object.
	//
	// 	- **Changing**: The storage class of the video file is being changed.
	//
	// 	- **SourceChanging**: The storage class of the source file is being changed.
	//
	// example:
	//
	// Standard
	StorageClass *string `json:"StorageClass,omitempty" xml:"StorageClass,omitempty"`
	// The region in which the video is stored.
	//
	// example:
	//
	// outin-bfefbb90a47c******163e1c7426.oss-cn-shanghai.aliyuncs.com
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	// The tags of the video file.
	//
	// example:
	//
	// tag1
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The title of the video.
	//
	// example:
	//
	// ceshi
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The transcoding mode. Valid values:
	//
	// 	- **FastTranscode**: The video file is immediately transcoded after it is uploaded. You cannot play the file before it is transcoded.
	//
	// 	- **NoTranscode**: The video file can be played without being transcoded. You can immediately play the file after it is uploaded.
	//
	// 	- **AsyncTranscode**: The video file can be immediately played and asynchronously transcoded after it is uploaded.
	//
	// example:
	//
	// FastTranscode
	TranscodeMode *string `json:"TranscodeMode,omitempty" xml:"TranscodeMode,omitempty"`
	// The ID of the video file.
	//
	// example:
	//
	// a82a2asdasqadaf3faa0ed6c1ee372****
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s SearchMediaResponseBodyMediaListVideo) String() string {
	return tea.Prettify(s)
}

func (s SearchMediaResponseBodyMediaListVideo) GoString() string {
	return s.String()
}

func (s *SearchMediaResponseBodyMediaListVideo) SetAppId(v string) *SearchMediaResponseBodyMediaListVideo {
	s.AppId = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetCateId(v int64) *SearchMediaResponseBodyMediaListVideo {
	s.CateId = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetCateName(v string) *SearchMediaResponseBodyMediaListVideo {
	s.CateName = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetCoverURL(v string) *SearchMediaResponseBodyMediaListVideo {
	s.CoverURL = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetCreationTime(v string) *SearchMediaResponseBodyMediaListVideo {
	s.CreationTime = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetDescription(v string) *SearchMediaResponseBodyMediaListVideo {
	s.Description = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetDownloadSwitch(v string) *SearchMediaResponseBodyMediaListVideo {
	s.DownloadSwitch = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetDuration(v float32) *SearchMediaResponseBodyMediaListVideo {
	s.Duration = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetMediaSource(v string) *SearchMediaResponseBodyMediaListVideo {
	s.MediaSource = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetModificationTime(v string) *SearchMediaResponseBodyMediaListVideo {
	s.ModificationTime = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetPreprocessStatus(v string) *SearchMediaResponseBodyMediaListVideo {
	s.PreprocessStatus = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetRestoreExpiration(v string) *SearchMediaResponseBodyMediaListVideo {
	s.RestoreExpiration = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetRestoreStatus(v string) *SearchMediaResponseBodyMediaListVideo {
	s.RestoreStatus = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetSize(v int64) *SearchMediaResponseBodyMediaListVideo {
	s.Size = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetSnapshots(v []*string) *SearchMediaResponseBodyMediaListVideo {
	s.Snapshots = v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetSpriteSnapshots(v []*string) *SearchMediaResponseBodyMediaListVideo {
	s.SpriteSnapshots = v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetStatus(v string) *SearchMediaResponseBodyMediaListVideo {
	s.Status = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetStorageClass(v string) *SearchMediaResponseBodyMediaListVideo {
	s.StorageClass = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetStorageLocation(v string) *SearchMediaResponseBodyMediaListVideo {
	s.StorageLocation = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetTags(v string) *SearchMediaResponseBodyMediaListVideo {
	s.Tags = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetTitle(v string) *SearchMediaResponseBodyMediaListVideo {
	s.Title = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetTranscodeMode(v string) *SearchMediaResponseBodyMediaListVideo {
	s.TranscodeMode = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetVideoId(v string) *SearchMediaResponseBodyMediaListVideo {
	s.VideoId = &v
	return s
}

type SearchMediaResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SearchMediaResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SearchMediaResponse) String() string {
	return tea.Prettify(s)
}

func (s SearchMediaResponse) GoString() string {
	return s.String()
}

func (s *SearchMediaResponse) SetHeaders(v map[string]*string) *SearchMediaResponse {
	s.Headers = v
	return s
}

func (s *SearchMediaResponse) SetStatusCode(v int32) *SearchMediaResponse {
	s.StatusCode = &v
	return s
}

func (s *SearchMediaResponse) SetBody(v *SearchMediaResponseBody) *SearchMediaResponse {
	s.Body = v
	return s
}

type SetAuditSecurityIpRequest struct {
	// The IP addresses that you want to add to the review security group. You can add a maximum of 100 IP addresses to a review security group. Separate multiple IP addresses with commas (,). You can add IP addresses in the following formats to review security groups:
	//
	// 	- IP address: 192.168.0.1
	//
	// 	- CIDR block: 192.168.0.1/24. /24 indicates that the prefix of the CIDR block is 24 bits in length. You can replace 24 with a value that ranges `from 1 to 32`.
	//
	// This parameter is required.
	//
	// example:
	//
	// 192.168.0.1
	Ips *string `json:"Ips,omitempty" xml:"Ips,omitempty"`
	// The operation type. Valid values:
	//
	// 	- **Append*	- (default): adds the IP addresses to the original whitelist.
	//
	// 	- **Cover**: overwrites the original whitelist.
	//
	// 	- **Delete**: removes the IP addresses from the original whitelist.
	//
	// >  If the value that you specify is invalid, the default value is used.
	//
	// example:
	//
	// Cover
	OperateMode *string `json:"OperateMode,omitempty" xml:"OperateMode,omitempty"`
	// The name of the review security group. Default value: **Default**. You can specify a maximum of 10 review security groups.
	//
	// example:
	//
	// Default
	SecurityGroupName *string `json:"SecurityGroupName,omitempty" xml:"SecurityGroupName,omitempty"`
}

func (s SetAuditSecurityIpRequest) String() string {
	return tea.Prettify(s)
}

func (s SetAuditSecurityIpRequest) GoString() string {
	return s.String()
}

func (s *SetAuditSecurityIpRequest) SetIps(v string) *SetAuditSecurityIpRequest {
	s.Ips = &v
	return s
}

func (s *SetAuditSecurityIpRequest) SetOperateMode(v string) *SetAuditSecurityIpRequest {
	s.OperateMode = &v
	return s
}

func (s *SetAuditSecurityIpRequest) SetSecurityGroupName(v string) *SetAuditSecurityIpRequest {
	s.SecurityGroupName = &v
	return s
}

type SetAuditSecurityIpResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4AF6-D7393642CA58****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetAuditSecurityIpResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetAuditSecurityIpResponseBody) GoString() string {
	return s.String()
}

func (s *SetAuditSecurityIpResponseBody) SetRequestId(v string) *SetAuditSecurityIpResponseBody {
	s.RequestId = &v
	return s
}

type SetAuditSecurityIpResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SetAuditSecurityIpResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SetAuditSecurityIpResponse) String() string {
	return tea.Prettify(s)
}

func (s SetAuditSecurityIpResponse) GoString() string {
	return s.String()
}

func (s *SetAuditSecurityIpResponse) SetHeaders(v map[string]*string) *SetAuditSecurityIpResponse {
	s.Headers = v
	return s
}

func (s *SetAuditSecurityIpResponse) SetStatusCode(v int32) *SetAuditSecurityIpResponse {
	s.StatusCode = &v
	return s
}

func (s *SetAuditSecurityIpResponse) SetBody(v *SetAuditSecurityIpResponseBody) *SetAuditSecurityIpResponse {
	s.Body = v
	return s
}

type SetCrossdomainContentRequest struct {
	// The content of the cross-domain policy file. The file must be in the XML format and can contain up to 2,048 characters.
	//
	// This parameter is required.
	//
	// example:
	//
	// &lt;cross-domain-policy&gt;&lt;allow-access-from domain="*"/&gt;&lt;allow-http-request-headers-from domain="*" headers="*" secure="false"/&gt;&lt;/cross-domain-policy&gt;
	Content              *string `json:"Content,omitempty" xml:"Content,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the resource owner.
	//
	// example:
	//
	// 3461111
	ResourceRealOwnerId *string `json:"ResourceRealOwnerId,omitempty" xml:"ResourceRealOwnerId,omitempty"`
	// The URL of the Object Storage Service (OSS) bucket.
	//
	// This parameter is required.
	//
	// example:
	//
	// outin-67870fd5b****1e98a3900163e1c35d5.oss-cn-shanghai.aliyuncs.com
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
}

func (s SetCrossdomainContentRequest) String() string {
	return tea.Prettify(s)
}

func (s SetCrossdomainContentRequest) GoString() string {
	return s.String()
}

func (s *SetCrossdomainContentRequest) SetContent(v string) *SetCrossdomainContentRequest {
	s.Content = &v
	return s
}

func (s *SetCrossdomainContentRequest) SetOwnerAccount(v string) *SetCrossdomainContentRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SetCrossdomainContentRequest) SetOwnerId(v string) *SetCrossdomainContentRequest {
	s.OwnerId = &v
	return s
}

func (s *SetCrossdomainContentRequest) SetResourceOwnerAccount(v string) *SetCrossdomainContentRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SetCrossdomainContentRequest) SetResourceOwnerId(v string) *SetCrossdomainContentRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *SetCrossdomainContentRequest) SetResourceRealOwnerId(v string) *SetCrossdomainContentRequest {
	s.ResourceRealOwnerId = &v
	return s
}

func (s *SetCrossdomainContentRequest) SetStorageLocation(v string) *SetCrossdomainContentRequest {
	s.StorageLocation = &v
	return s
}

type SetCrossdomainContentResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A13-****-D7393642CA58
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetCrossdomainContentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetCrossdomainContentResponseBody) GoString() string {
	return s.String()
}

func (s *SetCrossdomainContentResponseBody) SetRequestId(v string) *SetCrossdomainContentResponseBody {
	s.RequestId = &v
	return s
}

type SetCrossdomainContentResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SetCrossdomainContentResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SetCrossdomainContentResponse) String() string {
	return tea.Prettify(s)
}

func (s SetCrossdomainContentResponse) GoString() string {
	return s.String()
}

func (s *SetCrossdomainContentResponse) SetHeaders(v map[string]*string) *SetCrossdomainContentResponse {
	s.Headers = v
	return s
}

func (s *SetCrossdomainContentResponse) SetStatusCode(v int32) *SetCrossdomainContentResponse {
	s.StatusCode = &v
	return s
}

func (s *SetCrossdomainContentResponse) SetBody(v *SetCrossdomainContentResponseBody) *SetCrossdomainContentResponse {
	s.Body = v
	return s
}

type SetDefaultAITemplateRequest struct {
	// The ID of the AI template.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1706a0063dd733f6a823ef32e0a5****
	TemplateId *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
}

func (s SetDefaultAITemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s SetDefaultAITemplateRequest) GoString() string {
	return s.String()
}

func (s *SetDefaultAITemplateRequest) SetTemplateId(v string) *SetDefaultAITemplateRequest {
	s.TemplateId = &v
	return s
}

type SetDefaultAITemplateResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 8E70E3F8-E2EE-47BC-4677-379D6F28****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the AI template.
	//
	// example:
	//
	// 1706a0063dd733f6a823ef32e0a5****
	TemplateId *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
}

func (s SetDefaultAITemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetDefaultAITemplateResponseBody) GoString() string {
	return s.String()
}

func (s *SetDefaultAITemplateResponseBody) SetRequestId(v string) *SetDefaultAITemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *SetDefaultAITemplateResponseBody) SetTemplateId(v string) *SetDefaultAITemplateResponseBody {
	s.TemplateId = &v
	return s
}

type SetDefaultAITemplateResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SetDefaultAITemplateResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SetDefaultAITemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s SetDefaultAITemplateResponse) GoString() string {
	return s.String()
}

func (s *SetDefaultAITemplateResponse) SetHeaders(v map[string]*string) *SetDefaultAITemplateResponse {
	s.Headers = v
	return s
}

func (s *SetDefaultAITemplateResponse) SetStatusCode(v int32) *SetDefaultAITemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *SetDefaultAITemplateResponse) SetBody(v *SetDefaultAITemplateResponseBody) *SetDefaultAITemplateResponse {
	s.Body = v
	return s
}

type SetDefaultTranscodeTemplateGroupRequest struct {
	// The ID of the transcoding template group.
	//
	// This parameter is required.
	//
	// example:
	//
	// d58079958be8d*****b699ab7ab6e1bf
	TranscodeTemplateGroupId *string `json:"TranscodeTemplateGroupId,omitempty" xml:"TranscodeTemplateGroupId,omitempty"`
}

func (s SetDefaultTranscodeTemplateGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s SetDefaultTranscodeTemplateGroupRequest) GoString() string {
	return s.String()
}

func (s *SetDefaultTranscodeTemplateGroupRequest) SetTranscodeTemplateGroupId(v string) *SetDefaultTranscodeTemplateGroupRequest {
	s.TranscodeTemplateGroupId = &v
	return s
}

type SetDefaultTranscodeTemplateGroupResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A*****F6-D7393642CA58
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetDefaultTranscodeTemplateGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetDefaultTranscodeTemplateGroupResponseBody) GoString() string {
	return s.String()
}

func (s *SetDefaultTranscodeTemplateGroupResponseBody) SetRequestId(v string) *SetDefaultTranscodeTemplateGroupResponseBody {
	s.RequestId = &v
	return s
}

type SetDefaultTranscodeTemplateGroupResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SetDefaultTranscodeTemplateGroupResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SetDefaultTranscodeTemplateGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s SetDefaultTranscodeTemplateGroupResponse) GoString() string {
	return s.String()
}

func (s *SetDefaultTranscodeTemplateGroupResponse) SetHeaders(v map[string]*string) *SetDefaultTranscodeTemplateGroupResponse {
	s.Headers = v
	return s
}

func (s *SetDefaultTranscodeTemplateGroupResponse) SetStatusCode(v int32) *SetDefaultTranscodeTemplateGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *SetDefaultTranscodeTemplateGroupResponse) SetBody(v *SetDefaultTranscodeTemplateGroupResponseBody) *SetDefaultTranscodeTemplateGroupResponse {
	s.Body = v
	return s
}

type SetDefaultWatermarkRequest struct {
	// The ID of the watermark template. You can specify only one watermark template ID. You can obtain the ID by using one of the following methods:
	//
	// 	- Obtain the watermark template ID from the response to the [AddWatermark](~~AddWatermark~~) operation that you call to create a watermark template.
	//
	// 	- Obtain the watermark template ID from the response to the [ListWatermark](~~ListWatermark~~) operation that you call to query all watermark templates within your account.
	//
	// This parameter is required.
	//
	// example:
	//
	// 9bcc8bfadb843f*****09a2671d0df97
	WatermarkId *string `json:"WatermarkId,omitempty" xml:"WatermarkId,omitempty"`
}

func (s SetDefaultWatermarkRequest) String() string {
	return tea.Prettify(s)
}

func (s SetDefaultWatermarkRequest) GoString() string {
	return s.String()
}

func (s *SetDefaultWatermarkRequest) SetWatermarkId(v string) *SetDefaultWatermarkRequest {
	s.WatermarkId = &v
	return s
}

type SetDefaultWatermarkResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A*****F6-D7393642CA58
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetDefaultWatermarkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetDefaultWatermarkResponseBody) GoString() string {
	return s.String()
}

func (s *SetDefaultWatermarkResponseBody) SetRequestId(v string) *SetDefaultWatermarkResponseBody {
	s.RequestId = &v
	return s
}

type SetDefaultWatermarkResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SetDefaultWatermarkResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SetDefaultWatermarkResponse) String() string {
	return tea.Prettify(s)
}

func (s SetDefaultWatermarkResponse) GoString() string {
	return s.String()
}

func (s *SetDefaultWatermarkResponse) SetHeaders(v map[string]*string) *SetDefaultWatermarkResponse {
	s.Headers = v
	return s
}

func (s *SetDefaultWatermarkResponse) SetStatusCode(v int32) *SetDefaultWatermarkResponse {
	s.StatusCode = &v
	return s
}

func (s *SetDefaultWatermarkResponse) SetBody(v *SetDefaultWatermarkResponseBody) *SetDefaultWatermarkResponse {
	s.Body = v
	return s
}

type SetEditingProjectMaterialsRequest struct {
	// The ID of the media asset. You can specify IDs of media assets such as videos, images, or auxiliary media assets. Separate multiple IDs with commas (,).
	//
	// This parameter is required.
	//
	// example:
	//
	// 9e3101bf24bf41c*****123318788ca
	MaterialIds  *string `json:"MaterialIds,omitempty" xml:"MaterialIds,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the online editing project.
	//
	// This parameter is required.
	//
	// example:
	//
	// fb2101bf24bf4*****754cb318787dc
	ProjectId            *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s SetEditingProjectMaterialsRequest) String() string {
	return tea.Prettify(s)
}

func (s SetEditingProjectMaterialsRequest) GoString() string {
	return s.String()
}

func (s *SetEditingProjectMaterialsRequest) SetMaterialIds(v string) *SetEditingProjectMaterialsRequest {
	s.MaterialIds = &v
	return s
}

func (s *SetEditingProjectMaterialsRequest) SetOwnerAccount(v string) *SetEditingProjectMaterialsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SetEditingProjectMaterialsRequest) SetOwnerId(v string) *SetEditingProjectMaterialsRequest {
	s.OwnerId = &v
	return s
}

func (s *SetEditingProjectMaterialsRequest) SetProjectId(v string) *SetEditingProjectMaterialsRequest {
	s.ProjectId = &v
	return s
}

func (s *SetEditingProjectMaterialsRequest) SetResourceOwnerAccount(v string) *SetEditingProjectMaterialsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SetEditingProjectMaterialsRequest) SetResourceOwnerId(v string) *SetEditingProjectMaterialsRequest {
	s.ResourceOwnerId = &v
	return s
}

type SetEditingProjectMaterialsResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 746FFA07-8BBB-46*****B1-3E94E3B2915E
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetEditingProjectMaterialsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetEditingProjectMaterialsResponseBody) GoString() string {
	return s.String()
}

func (s *SetEditingProjectMaterialsResponseBody) SetRequestId(v string) *SetEditingProjectMaterialsResponseBody {
	s.RequestId = &v
	return s
}

type SetEditingProjectMaterialsResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SetEditingProjectMaterialsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SetEditingProjectMaterialsResponse) String() string {
	return tea.Prettify(s)
}

func (s SetEditingProjectMaterialsResponse) GoString() string {
	return s.String()
}

func (s *SetEditingProjectMaterialsResponse) SetHeaders(v map[string]*string) *SetEditingProjectMaterialsResponse {
	s.Headers = v
	return s
}

func (s *SetEditingProjectMaterialsResponse) SetStatusCode(v int32) *SetEditingProjectMaterialsResponse {
	s.StatusCode = &v
	return s
}

func (s *SetEditingProjectMaterialsResponse) SetBody(v *SetEditingProjectMaterialsResponseBody) *SetEditingProjectMaterialsResponse {
	s.Body = v
	return s
}

type SetMessageCallbackRequest struct {
	// The ID of the application. If you leave this parameter empty, the default value **app-1000000*	- is used.
	//
	// example:
	//
	// app-1000000
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The authentication key. The key can be up to 32 characters in length and must contain uppercase letters, lowercase letters, and digits. This parameter takes effect only when you set CallbackType to **HTTP**.
	//
	// example:
	//
	// Dsf346dvet
	AuthKey *string `json:"AuthKey,omitempty" xml:"AuthKey,omitempty"`
	// Specifies whether to enable callback authentication. This parameter takes effect only when you set CallbackType to **HTTP**. Valid values:
	//
	// 	- **on**
	//
	// 	- **off**
	//
	// example:
	//
	// on
	AuthSwitch *string `json:"AuthSwitch,omitempty" xml:"AuthSwitch,omitempty"`
	// The callback method. Valid values:
	//
	// 	- **HTTP**
	//
	// 	- **Simple Message Queue(formerly MNS)**
	//
	// example:
	//
	// HTTP
	CallbackType *string `json:"CallbackType,omitempty" xml:"CallbackType,omitempty"`
	// The callback URL. This parameter is required if you set CallbackType to **HTTP**. The callback URL cannot exceed 256 bytes in length. You can specify only one callback URL.
	//
	// example:
	//
	// http://developer.aliyundoc.com
	CallbackURL *string `json:"CallbackURL,omitempty" xml:"CallbackURL,omitempty"`
	// The type of the callback event. If you do not set this parameter, notifications for all types of events are disabled. If you set this parameter to **ALL**, notifications for all types of events are enabled. You can specify the event types for which notifications are enabled. Separate multiple event types with commas (,). For more information about the valid values of this parameter, see [Overview](https://help.aliyun.com/document_detail/55627.html).
	//
	// example:
	//
	// FileUploadComplete
	EventTypeList *string `json:"EventTypeList,omitempty" xml:"EventTypeList,omitempty"`
	// The public endpoint of Message Service (MNS). This parameter only takes effect when the CallbackType parameter is set to **Simple Message Queue(formerly MNS)**. To obtain the public endpoint, log on to the [Simple Message Queue(formerly MNS) console](https://account.aliyun.com/login/login.html) and click **Get Endpoint*	- in the upper-right corner of the Topics page. For more information, see [Endpoint](https://help.aliyun.com/document_detail/27480.html).
	//
	// example:
	//
	// http://****.mns.cn-shanghai.aliyuncs.com/
	MnsEndpoint *string `json:"MnsEndpoint,omitempty" xml:"MnsEndpoint,omitempty"`
	// The name of the Simple Message Queue(formerly MNS). You can obtain the name of the Simple Message Queue(formerly MNS) on the **Queues*	- page in the [Simple Message Queue(formerly MNS) console](https://account.aliyun.com/login/login.html). This parameter is required when you set CallbackType to **Simple Message Queue(formerly MNS)**.
	//
	// example:
	//
	// quene_name
	MnsQueueName *string `json:"MnsQueueName,omitempty" xml:"MnsQueueName,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
}

func (s SetMessageCallbackRequest) String() string {
	return tea.Prettify(s)
}

func (s SetMessageCallbackRequest) GoString() string {
	return s.String()
}

func (s *SetMessageCallbackRequest) SetAppId(v string) *SetMessageCallbackRequest {
	s.AppId = &v
	return s
}

func (s *SetMessageCallbackRequest) SetAuthKey(v string) *SetMessageCallbackRequest {
	s.AuthKey = &v
	return s
}

func (s *SetMessageCallbackRequest) SetAuthSwitch(v string) *SetMessageCallbackRequest {
	s.AuthSwitch = &v
	return s
}

func (s *SetMessageCallbackRequest) SetCallbackType(v string) *SetMessageCallbackRequest {
	s.CallbackType = &v
	return s
}

func (s *SetMessageCallbackRequest) SetCallbackURL(v string) *SetMessageCallbackRequest {
	s.CallbackURL = &v
	return s
}

func (s *SetMessageCallbackRequest) SetEventTypeList(v string) *SetMessageCallbackRequest {
	s.EventTypeList = &v
	return s
}

func (s *SetMessageCallbackRequest) SetMnsEndpoint(v string) *SetMessageCallbackRequest {
	s.MnsEndpoint = &v
	return s
}

func (s *SetMessageCallbackRequest) SetMnsQueueName(v string) *SetMessageCallbackRequest {
	s.MnsQueueName = &v
	return s
}

func (s *SetMessageCallbackRequest) SetOwnerAccount(v string) *SetMessageCallbackRequest {
	s.OwnerAccount = &v
	return s
}

type SetMessageCallbackResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4AF6-D7393642CA58****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetMessageCallbackResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetMessageCallbackResponseBody) GoString() string {
	return s.String()
}

func (s *SetMessageCallbackResponseBody) SetRequestId(v string) *SetMessageCallbackResponseBody {
	s.RequestId = &v
	return s
}

type SetMessageCallbackResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SetMessageCallbackResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SetMessageCallbackResponse) String() string {
	return tea.Prettify(s)
}

func (s SetMessageCallbackResponse) GoString() string {
	return s.String()
}

func (s *SetMessageCallbackResponse) SetHeaders(v map[string]*string) *SetMessageCallbackResponse {
	s.Headers = v
	return s
}

func (s *SetMessageCallbackResponse) SetStatusCode(v int32) *SetMessageCallbackResponse {
	s.StatusCode = &v
	return s
}

func (s *SetMessageCallbackResponse) SetBody(v *SetMessageCallbackResponseBody) *SetMessageCallbackResponse {
	s.Body = v
	return s
}

type SetVodDomainCertificateRequest struct {
	// The name of the certificate.
	//
	// example:
	//
	// cert_name
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The domain name that is secured by the certificate. The domain name must use HTTPS acceleration.
	//
	// This parameter is required.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId    *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The private key. This parameter is required only if you enable the SSL certificate.
	//
	// example:
	//
	// ****
	SSLPri *string `json:"SSLPri,omitempty" xml:"SSLPri,omitempty"`
	// Specifies whether to enable the SSL certificate. Default value: off. Valid values:
	//
	// 	- **on**
	//
	// 	- **off**
	//
	// This parameter is required.
	//
	// example:
	//
	// off
	SSLProtocol *string `json:"SSLProtocol,omitempty" xml:"SSLProtocol,omitempty"`
	// The content of the certificate. This parameter is required only if you enable the SSL certificate.
	//
	// example:
	//
	// ****
	SSLPub        *string `json:"SSLPub,omitempty" xml:"SSLPub,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s SetVodDomainCertificateRequest) String() string {
	return tea.Prettify(s)
}

func (s SetVodDomainCertificateRequest) GoString() string {
	return s.String()
}

func (s *SetVodDomainCertificateRequest) SetCertName(v string) *SetVodDomainCertificateRequest {
	s.CertName = &v
	return s
}

func (s *SetVodDomainCertificateRequest) SetDomainName(v string) *SetVodDomainCertificateRequest {
	s.DomainName = &v
	return s
}

func (s *SetVodDomainCertificateRequest) SetOwnerId(v int64) *SetVodDomainCertificateRequest {
	s.OwnerId = &v
	return s
}

func (s *SetVodDomainCertificateRequest) SetSSLPri(v string) *SetVodDomainCertificateRequest {
	s.SSLPri = &v
	return s
}

func (s *SetVodDomainCertificateRequest) SetSSLProtocol(v string) *SetVodDomainCertificateRequest {
	s.SSLProtocol = &v
	return s
}

func (s *SetVodDomainCertificateRequest) SetSSLPub(v string) *SetVodDomainCertificateRequest {
	s.SSLPub = &v
	return s
}

func (s *SetVodDomainCertificateRequest) SetSecurityToken(v string) *SetVodDomainCertificateRequest {
	s.SecurityToken = &v
	return s
}

type SetVodDomainCertificateResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 04F0F334-1335-436C-****-6C044FE73368
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetVodDomainCertificateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetVodDomainCertificateResponseBody) GoString() string {
	return s.String()
}

func (s *SetVodDomainCertificateResponseBody) SetRequestId(v string) *SetVodDomainCertificateResponseBody {
	s.RequestId = &v
	return s
}

type SetVodDomainCertificateResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SetVodDomainCertificateResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SetVodDomainCertificateResponse) String() string {
	return tea.Prettify(s)
}

func (s SetVodDomainCertificateResponse) GoString() string {
	return s.String()
}

func (s *SetVodDomainCertificateResponse) SetHeaders(v map[string]*string) *SetVodDomainCertificateResponse {
	s.Headers = v
	return s
}

func (s *SetVodDomainCertificateResponse) SetStatusCode(v int32) *SetVodDomainCertificateResponse {
	s.StatusCode = &v
	return s
}

func (s *SetVodDomainCertificateResponse) SetBody(v *SetVodDomainCertificateResponseBody) *SetVodDomainCertificateResponse {
	s.Body = v
	return s
}

type SetVodDomainSSLCertificateRequest struct {
	// The ID of the certificate.
	//
	// example:
	//
	// 12342707
	CertId *int64 `json:"CertId,omitempty" xml:"CertId,omitempty"`
	// The name of the certificate.
	//
	// example:
	//
	// cert_name
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The region of the certificate. Valid values:
	//
	// 	- **ap-southeast-1**: Singapore
	//
	// 	- **cn-hangzhou**: China (Hangzhou)
	//
	// Default value: **cn-hangzhou**
	//
	// example:
	//
	// cn-hangzhou
	CertRegion *string `json:"CertRegion,omitempty" xml:"CertRegion,omitempty"`
	// The type of the certificate.
	//
	// 	- **upload**: a user-uploaded SSL certificate.
	//
	// 	- **cas**: a certificate that is acquired through Certificate Management Service.
	//
	// example:
	//
	// cas
	CertType *string `json:"CertType,omitempty" xml:"CertType,omitempty"`
	// VOD acceleration domain.
	//
	// This parameter is required.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// Specifies whether the certificate is issued in canary releases. If you set this parameter to **staging**, the certificate is issued in canary releases. If you do not specify this parameter or set this parameter to other values, the certificate is officially issued.
	//
	// example:
	//
	// staging
	Env     *string `json:"Env,omitempty" xml:"Env,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The private key. This parameter is required only if you enable the certificate.
	//
	// example:
	//
	// ****
	SSLPri *string `json:"SSLPri,omitempty" xml:"SSLPri,omitempty"`
	// Specifies whether to enable the SSL certificate. Default value: off. Valid values:
	//
	// 	- **on**
	//
	// 	- **off**
	//
	// This parameter is required.
	//
	// example:
	//
	// off
	SSLProtocol *string `json:"SSLProtocol,omitempty" xml:"SSLProtocol,omitempty"`
	// The content of the certificate. This parameter is required only if you enable the SSL certificate.
	//
	// example:
	//
	// ****
	SSLPub        *string `json:"SSLPub,omitempty" xml:"SSLPub,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s SetVodDomainSSLCertificateRequest) String() string {
	return tea.Prettify(s)
}

func (s SetVodDomainSSLCertificateRequest) GoString() string {
	return s.String()
}

func (s *SetVodDomainSSLCertificateRequest) SetCertId(v int64) *SetVodDomainSSLCertificateRequest {
	s.CertId = &v
	return s
}

func (s *SetVodDomainSSLCertificateRequest) SetCertName(v string) *SetVodDomainSSLCertificateRequest {
	s.CertName = &v
	return s
}

func (s *SetVodDomainSSLCertificateRequest) SetCertRegion(v string) *SetVodDomainSSLCertificateRequest {
	s.CertRegion = &v
	return s
}

func (s *SetVodDomainSSLCertificateRequest) SetCertType(v string) *SetVodDomainSSLCertificateRequest {
	s.CertType = &v
	return s
}

func (s *SetVodDomainSSLCertificateRequest) SetDomainName(v string) *SetVodDomainSSLCertificateRequest {
	s.DomainName = &v
	return s
}

func (s *SetVodDomainSSLCertificateRequest) SetEnv(v string) *SetVodDomainSSLCertificateRequest {
	s.Env = &v
	return s
}

func (s *SetVodDomainSSLCertificateRequest) SetOwnerId(v int64) *SetVodDomainSSLCertificateRequest {
	s.OwnerId = &v
	return s
}

func (s *SetVodDomainSSLCertificateRequest) SetSSLPri(v string) *SetVodDomainSSLCertificateRequest {
	s.SSLPri = &v
	return s
}

func (s *SetVodDomainSSLCertificateRequest) SetSSLProtocol(v string) *SetVodDomainSSLCertificateRequest {
	s.SSLProtocol = &v
	return s
}

func (s *SetVodDomainSSLCertificateRequest) SetSSLPub(v string) *SetVodDomainSSLCertificateRequest {
	s.SSLPub = &v
	return s
}

func (s *SetVodDomainSSLCertificateRequest) SetSecurityToken(v string) *SetVodDomainSSLCertificateRequest {
	s.SecurityToken = &v
	return s
}

type SetVodDomainSSLCertificateResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// F4C6D5BE-BF13-45*****6C-516EA8906DCD
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetVodDomainSSLCertificateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetVodDomainSSLCertificateResponseBody) GoString() string {
	return s.String()
}

func (s *SetVodDomainSSLCertificateResponseBody) SetRequestId(v string) *SetVodDomainSSLCertificateResponseBody {
	s.RequestId = &v
	return s
}

type SetVodDomainSSLCertificateResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SetVodDomainSSLCertificateResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SetVodDomainSSLCertificateResponse) String() string {
	return tea.Prettify(s)
}

func (s SetVodDomainSSLCertificateResponse) GoString() string {
	return s.String()
}

func (s *SetVodDomainSSLCertificateResponse) SetHeaders(v map[string]*string) *SetVodDomainSSLCertificateResponse {
	s.Headers = v
	return s
}

func (s *SetVodDomainSSLCertificateResponse) SetStatusCode(v int32) *SetVodDomainSSLCertificateResponse {
	s.StatusCode = &v
	return s
}

func (s *SetVodDomainSSLCertificateResponse) SetBody(v *SetVodDomainSSLCertificateResponseBody) *SetVodDomainSSLCertificateResponse {
	s.Body = v
	return s
}

type SubmitAIImageAuditJobRequest struct {
	// The configuration information about the review job.
	//
	// 	- Other configuration items of the review job. Only the ResourceType field is supported. This field is used to specify the type of media files. You can adjust review standards and rules based on the type of media files.
	//
	// 	- The value of ResourceType can contain only letters, digits, and underscores (_).
	//
	// > 	- You can specify a value for the ResourceType field based on the preceding limits. After you specify a value for the ResourceType field, you must [submit a ticket](https://yida.alibaba-inc.com/o/ticketapply). The value takes effect after Alibaba Cloud processes your ticket.
	//
	// >	- If you want to change moderation policies and rules based on ResourceType, [submit a ticket](https://yida.alibaba-inc.com/o/ticketapply) to contact technical support.
	//
	// example:
	//
	// {"ResourceType":"****_short_video"}
	MediaAuditConfiguration *string `json:"MediaAuditConfiguration,omitempty" xml:"MediaAuditConfiguration,omitempty"`
	// The ID of the image.
	//
	// The unique ID of the image is returned after the image is uploaded to ApsaraVideo VOD.
	//
	// This parameter is required.
	//
	// example:
	//
	// f1aa3024aee64*****6dc8ca20dbc320
	MediaId              *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the AI template. You can use one of the following methods to obtain the ID:
	//
	// 	- Obtain the value of TemplateId from the response to the [AddAITemplate](https://help.aliyun.com/document_detail/102930.html) operation that you call to create an AI template.
	//
	// 	- Obtain the value of TemplateId from the response to the [ListAITemplate](https://help.aliyun.com/document_detail/102936.html) operation that you call to create an AI template.
	//
	// This parameter is required.
	//
	// example:
	//
	// VOD-0003-00****
	TemplateId *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
}

func (s SubmitAIImageAuditJobRequest) String() string {
	return tea.Prettify(s)
}

func (s SubmitAIImageAuditJobRequest) GoString() string {
	return s.String()
}

func (s *SubmitAIImageAuditJobRequest) SetMediaAuditConfiguration(v string) *SubmitAIImageAuditJobRequest {
	s.MediaAuditConfiguration = &v
	return s
}

func (s *SubmitAIImageAuditJobRequest) SetMediaId(v string) *SubmitAIImageAuditJobRequest {
	s.MediaId = &v
	return s
}

func (s *SubmitAIImageAuditJobRequest) SetOwnerAccount(v string) *SubmitAIImageAuditJobRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SubmitAIImageAuditJobRequest) SetOwnerId(v string) *SubmitAIImageAuditJobRequest {
	s.OwnerId = &v
	return s
}

func (s *SubmitAIImageAuditJobRequest) SetResourceOwnerAccount(v string) *SubmitAIImageAuditJobRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SubmitAIImageAuditJobRequest) SetResourceOwnerId(v string) *SubmitAIImageAuditJobRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *SubmitAIImageAuditJobRequest) SetTemplateId(v string) *SubmitAIImageAuditJobRequest {
	s.TemplateId = &v
	return s
}

type SubmitAIImageAuditJobResponseBody struct {
	// The ID of the image review job.
	//
	// example:
	//
	// b1aa3024aee64*****6dc8ca20dbc328
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// 6F42D500-1956-4B*****30-C09E755F4F4B
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SubmitAIImageAuditJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SubmitAIImageAuditJobResponseBody) GoString() string {
	return s.String()
}

func (s *SubmitAIImageAuditJobResponseBody) SetJobId(v string) *SubmitAIImageAuditJobResponseBody {
	s.JobId = &v
	return s
}

func (s *SubmitAIImageAuditJobResponseBody) SetRequestId(v string) *SubmitAIImageAuditJobResponseBody {
	s.RequestId = &v
	return s
}

type SubmitAIImageAuditJobResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SubmitAIImageAuditJobResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SubmitAIImageAuditJobResponse) String() string {
	return tea.Prettify(s)
}

func (s SubmitAIImageAuditJobResponse) GoString() string {
	return s.String()
}

func (s *SubmitAIImageAuditJobResponse) SetHeaders(v map[string]*string) *SubmitAIImageAuditJobResponse {
	s.Headers = v
	return s
}

func (s *SubmitAIImageAuditJobResponse) SetStatusCode(v int32) *SubmitAIImageAuditJobResponse {
	s.StatusCode = &v
	return s
}

func (s *SubmitAIImageAuditJobResponse) SetBody(v *SubmitAIImageAuditJobResponseBody) *SubmitAIImageAuditJobResponse {
	s.Body = v
	return s
}

type SubmitAIImageJobRequest struct {
	// The ID of the pipeline that is used for the AI processing job.
	//
	// >  This parameter is optional if you specify a default pipeline ID. If you want to use a separate pipeline to submit multiple AI processing jobs., submit a ticket or contact Alibaba Cloud after-sales engineers. For more information about how to submit a ticket, see [Contact us](https://help.aliyun.com/document_detail/464625.html).
	//
	// example:
	//
	// 6492025b8f*****6ba5bb755a33438
	AIPipelineId *string `json:"AIPipelineId,omitempty" xml:"AIPipelineId,omitempty"`
	// The ID of the AI template. You can use one of the following methods to obtain the ID:
	//
	// 	- Obtain the value of TemplateId from the response to the [AddAITemplate](https://help.aliyun.com/document_detail/102930.html) that you call to create the template.
	//
	// 	- Obtain the value of TemplateId from the response to the [ListAITemplate](https://help.aliyun.com/document_detail/102936.html) operation after you create the template.
	//
	// This parameter is required.
	//
	// example:
	//
	// ef1a8842cb9f*****cea80cad902e416
	AITemplateId         *string `json:"AITemplateId,omitempty" xml:"AITemplateId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The user data.
	//
	// 	- The value must be a JSON string.
	//
	// 	- You must specify the MessageCallback or Extend parameter.
	//
	// 	- The value can contain a maximum of 512 bytes.
	//
	// For more information, see the "UserData: specifies the custom configurations for media upload" section of the [Request parameters](https://help.aliyun.com/document_detail/86952.html) topic.
	//
	// example:
	//
	// {"Extend":{"localId":"****","test":"www"}}
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
	// The ID of the video. You can use one of the following methods to obtain the ID:
	//
	// 	- Log on to the [ApsaraVideo VOD](https://vod.console.aliyun.com) console. In the left-side navigation pane, choose **Media Files*	- > **Audio/Video**. On the Video and Audio page, view the ID of the video file. This method is applicable to files that are uploaded by using the ApsaraVideo VOD console.
	//
	// 	- Obtain the value of VideoId from the response to the [CreateUploadVideo](https://help.aliyun.com/document_detail/55407.html) operation that you call to upload the video.
	//
	// 	- Obtain the value of VideoId from the response to the [SearchMedia](https://help.aliyun.com/document_detail/86044.html) operation after you upload the video.
	//
	// This parameter is required.
	//
	// example:
	//
	// 357a8748c5774*****89d2726e6436aa
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s SubmitAIImageJobRequest) String() string {
	return tea.Prettify(s)
}

func (s SubmitAIImageJobRequest) GoString() string {
	return s.String()
}

func (s *SubmitAIImageJobRequest) SetAIPipelineId(v string) *SubmitAIImageJobRequest {
	s.AIPipelineId = &v
	return s
}

func (s *SubmitAIImageJobRequest) SetAITemplateId(v string) *SubmitAIImageJobRequest {
	s.AITemplateId = &v
	return s
}

func (s *SubmitAIImageJobRequest) SetOwnerAccount(v string) *SubmitAIImageJobRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SubmitAIImageJobRequest) SetOwnerId(v string) *SubmitAIImageJobRequest {
	s.OwnerId = &v
	return s
}

func (s *SubmitAIImageJobRequest) SetResourceOwnerAccount(v string) *SubmitAIImageJobRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SubmitAIImageJobRequest) SetResourceOwnerId(v string) *SubmitAIImageJobRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *SubmitAIImageJobRequest) SetUserData(v string) *SubmitAIImageJobRequest {
	s.UserData = &v
	return s
}

func (s *SubmitAIImageJobRequest) SetVideoId(v string) *SubmitAIImageJobRequest {
	s.VideoId = &v
	return s
}

type SubmitAIImageJobResponseBody struct {
	// The ID of the image AI processing job.
	//
	// example:
	//
	// cf08a2c6e11e*****de1711b738b9067
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// 218A6807-A21E-43*****54-C0512880B0B0
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SubmitAIImageJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SubmitAIImageJobResponseBody) GoString() string {
	return s.String()
}

func (s *SubmitAIImageJobResponseBody) SetJobId(v string) *SubmitAIImageJobResponseBody {
	s.JobId = &v
	return s
}

func (s *SubmitAIImageJobResponseBody) SetRequestId(v string) *SubmitAIImageJobResponseBody {
	s.RequestId = &v
	return s
}

type SubmitAIImageJobResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SubmitAIImageJobResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SubmitAIImageJobResponse) String() string {
	return tea.Prettify(s)
}

func (s SubmitAIImageJobResponse) GoString() string {
	return s.String()
}

func (s *SubmitAIImageJobResponse) SetHeaders(v map[string]*string) *SubmitAIImageJobResponse {
	s.Headers = v
	return s
}

func (s *SubmitAIImageJobResponse) SetStatusCode(v int32) *SubmitAIImageJobResponse {
	s.StatusCode = &v
	return s
}

func (s *SubmitAIImageJobResponse) SetBody(v *SubmitAIImageJobResponseBody) *SubmitAIImageJobResponse {
	s.Body = v
	return s
}

type SubmitAIJobRequest struct {
	// The configurations of the AI job. The value is a JSON string.
	//
	// 	- If you set `Types` to `AIVideoTag`, you can specify `AnalyseTypes` for `Config` to set the analysis algorithm of a smart tagging job. Valid values:
	//
	//     	- ASR: automatic speech recognition (ASR)
	//
	//     	- OCR: image optical character recognition (OCR)
	//
	// 	- If you set `Types` to `AIMediaDNA`, you can specify `DNADBId` for `Config` to set the ID of the media fingerprint library for video fingerprinting jobs.
	//
	// example:
	//
	// {"AIVideoTag": {"AnalyseTypes": "Face,ASR"} }
	Config *string `json:"Config,omitempty" xml:"Config,omitempty"`
	// The ID of the video. You can use one of the following methods to obtain the ID:
	//
	// 	- Log on to the [ApsaraVideo VOD](https://vod.console.aliyun.com) console. In the left-side navigation pane, choose **Media Files*	- > **Audio/Video**. On the Video and Audio page, view the ID of the audio or video file. This method is applicable to files that are uploaded by using the ApsaraVideo VOD console.
	//
	// 	- Obtain the value of VideoId from the response to the [CreateUploadVideo](https://help.aliyun.com/document_detail/55407.html) operation that you call to upload media files.
	//
	// 	- Obtain the value of VideoId from the response to the [SearchMedia](https://help.aliyun.com/document_detail/86044.html) operation after you upload media files.
	//
	// example:
	//
	// 3D3D12340d9401fab46a0b847****
	MediaId              *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the AI job. Separate multiple types with commas (,). Valid values:
	//
	// 	- **AIMediaDNA**: The media fingerprinting job.
	//
	// 	- **AIVideoTag**: The smart tagging job.
	//
	// example:
	//
	// AIVideoTag
	Types *string `json:"Types,omitempty" xml:"Types,omitempty"`
	// The custom settings. The value is a JSON string. For more information, see [Request parameters](~~86952#h2--userdata-div-id-userdata-div-3~~).
	//
	// example:
	//
	// {"Extend":{"localId":"***","test":"www"}}
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
}

func (s SubmitAIJobRequest) String() string {
	return tea.Prettify(s)
}

func (s SubmitAIJobRequest) GoString() string {
	return s.String()
}

func (s *SubmitAIJobRequest) SetConfig(v string) *SubmitAIJobRequest {
	s.Config = &v
	return s
}

func (s *SubmitAIJobRequest) SetMediaId(v string) *SubmitAIJobRequest {
	s.MediaId = &v
	return s
}

func (s *SubmitAIJobRequest) SetOwnerAccount(v string) *SubmitAIJobRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SubmitAIJobRequest) SetOwnerId(v string) *SubmitAIJobRequest {
	s.OwnerId = &v
	return s
}

func (s *SubmitAIJobRequest) SetResourceOwnerAccount(v string) *SubmitAIJobRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SubmitAIJobRequest) SetResourceOwnerId(v string) *SubmitAIJobRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *SubmitAIJobRequest) SetTypes(v string) *SubmitAIJobRequest {
	s.Types = &v
	return s
}

func (s *SubmitAIJobRequest) SetUserData(v string) *SubmitAIJobRequest {
	s.UserData = &v
	return s
}

type SubmitAIJobResponseBody struct {
	// The information about the AI jobs.
	AIJobList *SubmitAIJobResponseBodyAIJobList `json:"AIJobList,omitempty" xml:"AIJobList,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A13-BEF6-D73936****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SubmitAIJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SubmitAIJobResponseBody) GoString() string {
	return s.String()
}

func (s *SubmitAIJobResponseBody) SetAIJobList(v *SubmitAIJobResponseBodyAIJobList) *SubmitAIJobResponseBody {
	s.AIJobList = v
	return s
}

func (s *SubmitAIJobResponseBody) SetRequestId(v string) *SubmitAIJobResponseBody {
	s.RequestId = &v
	return s
}

type SubmitAIJobResponseBodyAIJobList struct {
	AIJob []*SubmitAIJobResponseBodyAIJobListAIJob `json:"AIJob,omitempty" xml:"AIJob,omitempty" type:"Repeated"`
}

func (s SubmitAIJobResponseBodyAIJobList) String() string {
	return tea.Prettify(s)
}

func (s SubmitAIJobResponseBodyAIJobList) GoString() string {
	return s.String()
}

func (s *SubmitAIJobResponseBodyAIJobList) SetAIJob(v []*SubmitAIJobResponseBodyAIJobListAIJob) *SubmitAIJobResponseBodyAIJobList {
	s.AIJob = v
	return s
}

type SubmitAIJobResponseBodyAIJobListAIJob struct {
	// The ID of the AI job.
	//
	// example:
	//
	// 9e82640c85114bf5af23edfaf****
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The ID of the video.
	//
	// example:
	//
	// 3D3D12340d92c641401fab46a0b847****
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The type of the AI job. Valid values:
	//
	// 	- **AIMediaDNA**: The media fingerprinting job.
	//
	// 	- **AIVideoTag**: The smart tagging job.
	//
	// example:
	//
	// AIVideoTag
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s SubmitAIJobResponseBodyAIJobListAIJob) String() string {
	return tea.Prettify(s)
}

func (s SubmitAIJobResponseBodyAIJobListAIJob) GoString() string {
	return s.String()
}

func (s *SubmitAIJobResponseBodyAIJobListAIJob) SetJobId(v string) *SubmitAIJobResponseBodyAIJobListAIJob {
	s.JobId = &v
	return s
}

func (s *SubmitAIJobResponseBodyAIJobListAIJob) SetMediaId(v string) *SubmitAIJobResponseBodyAIJobListAIJob {
	s.MediaId = &v
	return s
}

func (s *SubmitAIJobResponseBodyAIJobListAIJob) SetType(v string) *SubmitAIJobResponseBodyAIJobListAIJob {
	s.Type = &v
	return s
}

type SubmitAIJobResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SubmitAIJobResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SubmitAIJobResponse) String() string {
	return tea.Prettify(s)
}

func (s SubmitAIJobResponse) GoString() string {
	return s.String()
}

func (s *SubmitAIJobResponse) SetHeaders(v map[string]*string) *SubmitAIJobResponse {
	s.Headers = v
	return s
}

func (s *SubmitAIJobResponse) SetStatusCode(v int32) *SubmitAIJobResponse {
	s.StatusCode = &v
	return s
}

func (s *SubmitAIJobResponse) SetBody(v *SubmitAIJobResponseBody) *SubmitAIJobResponse {
	s.Body = v
	return s
}

type SubmitAIMediaAuditJobRequest struct {
	// The configuration information about the review job.
	//
	// 	- Other configuration items of the review job. Only the ResourceType field is supported. This field is used to specify the type of media files. You can adjust review standards and rules based on the type of media files.
	//
	// 	- If you want to modify the review standard and rules based on ResourceType, submit a ticket. For more information, see [Contact us](https://help.aliyun.com/document_detail/464625.html).
	//
	// 	- The value of ResourceType can contain only letters, digits, and underscores (_).
	//
	// example:
	//
	// {"ResourceType":"****_movie"}
	MediaAuditConfiguration *string `json:"MediaAuditConfiguration,omitempty" xml:"MediaAuditConfiguration,omitempty"`
	// The ID of the video file. To obtain the file ID, log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com) and choose **Review Management*	- > **Content Moderation*	- in the left-side navigation pane.
	//
	// This parameter is required.
	//
	// example:
	//
	// fe028d09441afffb138cd7ee****
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The type of the media file. Only **video*	- is supported.
	//
	// example:
	//
	// video
	MediaType *string `json:"MediaType,omitempty" xml:"MediaType,omitempty"`
	// The ID of the AI template. You can use one of the following methods to obtain the ID of the AI template:
	//
	// 	- Obtain the value of TemplateId from the response to the [AddAITemplate](https://help.aliyun.com/document_detail/102930.html) operation that you call to create an AI template.
	//
	// 	- Obtain the value of TemplateId from the response to the [ListAITemplate](https://help.aliyun.com/document_detail/102936.html) operation that you call to create an AI template.
	//
	// >  If you do not specify an ID, the ID of the default AI template is used.
	//
	// example:
	//
	// a07a7f7d7d10eb9fd999e56ecc****
	TemplateId *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The custom settings. The value must be a JSON string. You can configure settings such as message callbacks. For more information, see [UserData](https://help.aliyun.com/document_detail/86952.html).
	//
	// >  To use the callback configurations specified by this parameter, you must configure an HTTP callback URL and specify the types of the callback events in the ApsaraVideo VOD console. Otherwise, the callback configurations do not take effect. For more information about how to configure HTTP callback settings in the ApsaraVideo VOD console, see [Configure callback settings](https://help.aliyun.com/document_detail/86071.html).
	//
	// example:
	//
	// {"MessageCallback":{"CallbackURL":"http://test.test.com"},"Extend":{"localId":"xxx","test":"www"}}
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
}

func (s SubmitAIMediaAuditJobRequest) String() string {
	return tea.Prettify(s)
}

func (s SubmitAIMediaAuditJobRequest) GoString() string {
	return s.String()
}

func (s *SubmitAIMediaAuditJobRequest) SetMediaAuditConfiguration(v string) *SubmitAIMediaAuditJobRequest {
	s.MediaAuditConfiguration = &v
	return s
}

func (s *SubmitAIMediaAuditJobRequest) SetMediaId(v string) *SubmitAIMediaAuditJobRequest {
	s.MediaId = &v
	return s
}

func (s *SubmitAIMediaAuditJobRequest) SetMediaType(v string) *SubmitAIMediaAuditJobRequest {
	s.MediaType = &v
	return s
}

func (s *SubmitAIMediaAuditJobRequest) SetTemplateId(v string) *SubmitAIMediaAuditJobRequest {
	s.TemplateId = &v
	return s
}

func (s *SubmitAIMediaAuditJobRequest) SetUserData(v string) *SubmitAIMediaAuditJobRequest {
	s.UserData = &v
	return s
}

type SubmitAIMediaAuditJobResponseBody struct {
	// The ID of the job.
	//
	// example:
	//
	// bdbc266af6893943a70176d92e99****
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The ID of the media file.
	//
	// example:
	//
	// fe028d09441afffb138cd7ee****
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// F4631053-8D9F-42B2-4A67281DB88E****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SubmitAIMediaAuditJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SubmitAIMediaAuditJobResponseBody) GoString() string {
	return s.String()
}

func (s *SubmitAIMediaAuditJobResponseBody) SetJobId(v string) *SubmitAIMediaAuditJobResponseBody {
	s.JobId = &v
	return s
}

func (s *SubmitAIMediaAuditJobResponseBody) SetMediaId(v string) *SubmitAIMediaAuditJobResponseBody {
	s.MediaId = &v
	return s
}

func (s *SubmitAIMediaAuditJobResponseBody) SetRequestId(v string) *SubmitAIMediaAuditJobResponseBody {
	s.RequestId = &v
	return s
}

type SubmitAIMediaAuditJobResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SubmitAIMediaAuditJobResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SubmitAIMediaAuditJobResponse) String() string {
	return tea.Prettify(s)
}

func (s SubmitAIMediaAuditJobResponse) GoString() string {
	return s.String()
}

func (s *SubmitAIMediaAuditJobResponse) SetHeaders(v map[string]*string) *SubmitAIMediaAuditJobResponse {
	s.Headers = v
	return s
}

func (s *SubmitAIMediaAuditJobResponse) SetStatusCode(v int32) *SubmitAIMediaAuditJobResponse {
	s.StatusCode = &v
	return s
}

func (s *SubmitAIMediaAuditJobResponse) SetBody(v *SubmitAIMediaAuditJobResponseBody) *SubmitAIMediaAuditJobResponse {
	s.Body = v
	return s
}

type SubmitDigitalWatermarkExtractJobRequest struct {
	// The type of the watermark that you want to extract. Valid values:
	//
	// 	- **TraceMark**: user-tracing watermark
	//
	// 	- **CopyrightMark**: copyright watermark
	//
	// This parameter is required.
	//
	// example:
	//
	// TraceMark
	ExtractType *string `json:"ExtractType,omitempty" xml:"ExtractType,omitempty"`
	// The ID of the video from which you want to extract the watermark. You can specify only one ID. You can use one of the following methods to obtain the ID:
	//
	// 	- Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Media Files*	- > **Audio/Video*	- to view the video ID.
	//
	// 	- Obtain the VideoId from the response to the [SearchMedia](~~SearchMedia~~) operation.
	//
	// This parameter is required.
	//
	// example:
	//
	// 0222e203cf80f9c22870a4d2c****
	MediaId              *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s SubmitDigitalWatermarkExtractJobRequest) String() string {
	return tea.Prettify(s)
}

func (s SubmitDigitalWatermarkExtractJobRequest) GoString() string {
	return s.String()
}

func (s *SubmitDigitalWatermarkExtractJobRequest) SetExtractType(v string) *SubmitDigitalWatermarkExtractJobRequest {
	s.ExtractType = &v
	return s
}

func (s *SubmitDigitalWatermarkExtractJobRequest) SetMediaId(v string) *SubmitDigitalWatermarkExtractJobRequest {
	s.MediaId = &v
	return s
}

func (s *SubmitDigitalWatermarkExtractJobRequest) SetOwnerAccount(v string) *SubmitDigitalWatermarkExtractJobRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SubmitDigitalWatermarkExtractJobRequest) SetOwnerId(v string) *SubmitDigitalWatermarkExtractJobRequest {
	s.OwnerId = &v
	return s
}

func (s *SubmitDigitalWatermarkExtractJobRequest) SetResourceOwnerAccount(v string) *SubmitDigitalWatermarkExtractJobRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SubmitDigitalWatermarkExtractJobRequest) SetResourceOwnerId(v string) *SubmitDigitalWatermarkExtractJobRequest {
	s.ResourceOwnerId = &v
	return s
}

type SubmitDigitalWatermarkExtractJobResponseBody struct {
	// The ID of the watermark extraction job.
	//
	// example:
	//
	// ad90a501b1b9472374ad005046****
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// 04F0F334-1335-436C-****-6C044FE73368
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SubmitDigitalWatermarkExtractJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SubmitDigitalWatermarkExtractJobResponseBody) GoString() string {
	return s.String()
}

func (s *SubmitDigitalWatermarkExtractJobResponseBody) SetJobId(v string) *SubmitDigitalWatermarkExtractJobResponseBody {
	s.JobId = &v
	return s
}

func (s *SubmitDigitalWatermarkExtractJobResponseBody) SetRequestId(v string) *SubmitDigitalWatermarkExtractJobResponseBody {
	s.RequestId = &v
	return s
}

type SubmitDigitalWatermarkExtractJobResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SubmitDigitalWatermarkExtractJobResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SubmitDigitalWatermarkExtractJobResponse) String() string {
	return tea.Prettify(s)
}

func (s SubmitDigitalWatermarkExtractJobResponse) GoString() string {
	return s.String()
}

func (s *SubmitDigitalWatermarkExtractJobResponse) SetHeaders(v map[string]*string) *SubmitDigitalWatermarkExtractJobResponse {
	s.Headers = v
	return s
}

func (s *SubmitDigitalWatermarkExtractJobResponse) SetStatusCode(v int32) *SubmitDigitalWatermarkExtractJobResponse {
	s.StatusCode = &v
	return s
}

func (s *SubmitDigitalWatermarkExtractJobResponse) SetBody(v *SubmitDigitalWatermarkExtractJobResponseBody) *SubmitDigitalWatermarkExtractJobResponse {
	s.Body = v
	return s
}

type SubmitDynamicImageJobRequest struct {
	// The ID of the frame animation template.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1a443dc52ef10abc4794d700*****
	DynamicImageTemplateId *string `json:"DynamicImageTemplateId,omitempty" xml:"DynamicImageTemplateId,omitempty"`
	// The override parameter. Specify the value in the JSON format. For more information, see [Parameters for media processing](https://help.aliyun.com/document_detail/98618.html). You can use this parameter to override configurations in the animated image template. For more information, see the "DynamicImageTemplateConfig: the configurations of an animated sticker template" section of the [Basic data types](https://help.aliyun.com/document_detail/52839.html) topic.
	//
	// example:
	//
	// {"Watermarks":[{"Content":"UserID: 666**","WatermarkId":"8ca03c884944bd05efccc312367****"}]}
	OverrideParams *string `json:"OverrideParams,omitempty" xml:"OverrideParams,omitempty"`
	// The ID of the video. You can use one of the following methods to obtain the ID:
	//
	// 	- Log on to the [ApsaraVideo VOD](https://vod.console.aliyun.com) console. In the left-side navigation pane, choose **Media Files*	- > **Audio/Video**. On the Video and Audio page, view the ID of the media file. This method is applicable to files that are uploaded by using the ApsaraVideo VOD console.
	//
	// 	- Obtain the value of VideoId from the response to the [CreateUploadVideo](https://help.aliyun.com/document_detail/55407.html) operation that you call to upload media files.
	//
	// 	- Obtain the value of VideoId from the response to the [SearchMedia](https://help.aliyun.com/document_detail/86044.html) operation after you upload media files.
	//
	// This parameter is required.
	//
	// example:
	//
	// 7d2fbc3e273441bdb0e08e55f8****
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s SubmitDynamicImageJobRequest) String() string {
	return tea.Prettify(s)
}

func (s SubmitDynamicImageJobRequest) GoString() string {
	return s.String()
}

func (s *SubmitDynamicImageJobRequest) SetDynamicImageTemplateId(v string) *SubmitDynamicImageJobRequest {
	s.DynamicImageTemplateId = &v
	return s
}

func (s *SubmitDynamicImageJobRequest) SetOverrideParams(v string) *SubmitDynamicImageJobRequest {
	s.OverrideParams = &v
	return s
}

func (s *SubmitDynamicImageJobRequest) SetVideoId(v string) *SubmitDynamicImageJobRequest {
	s.VideoId = &v
	return s
}

type SubmitDynamicImageJobResponseBody struct {
	// The information about the animated image job.
	DynamicImageJob *SubmitDynamicImageJobResponseBodyDynamicImageJob `json:"DynamicImageJob,omitempty" xml:"DynamicImageJob,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-74A6-BEF6-D7393642****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SubmitDynamicImageJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SubmitDynamicImageJobResponseBody) GoString() string {
	return s.String()
}

func (s *SubmitDynamicImageJobResponseBody) SetDynamicImageJob(v *SubmitDynamicImageJobResponseBodyDynamicImageJob) *SubmitDynamicImageJobResponseBody {
	s.DynamicImageJob = v
	return s
}

func (s *SubmitDynamicImageJobResponseBody) SetRequestId(v string) *SubmitDynamicImageJobResponseBody {
	s.RequestId = &v
	return s
}

type SubmitDynamicImageJobResponseBodyDynamicImageJob struct {
	// The ID of the animated image job.
	//
	// example:
	//
	// ad90a501b1bfb72374ad0050746****
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
}

func (s SubmitDynamicImageJobResponseBodyDynamicImageJob) String() string {
	return tea.Prettify(s)
}

func (s SubmitDynamicImageJobResponseBodyDynamicImageJob) GoString() string {
	return s.String()
}

func (s *SubmitDynamicImageJobResponseBodyDynamicImageJob) SetJobId(v string) *SubmitDynamicImageJobResponseBodyDynamicImageJob {
	s.JobId = &v
	return s
}

type SubmitDynamicImageJobResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SubmitDynamicImageJobResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SubmitDynamicImageJobResponse) String() string {
	return tea.Prettify(s)
}

func (s SubmitDynamicImageJobResponse) GoString() string {
	return s.String()
}

func (s *SubmitDynamicImageJobResponse) SetHeaders(v map[string]*string) *SubmitDynamicImageJobResponse {
	s.Headers = v
	return s
}

func (s *SubmitDynamicImageJobResponse) SetStatusCode(v int32) *SubmitDynamicImageJobResponse {
	s.StatusCode = &v
	return s
}

func (s *SubmitDynamicImageJobResponse) SetBody(v *SubmitDynamicImageJobResponseBody) *SubmitDynamicImageJobResponse {
	s.Body = v
	return s
}

type SubmitMediaDNADeleteJobRequest struct {
	// The ID of the video.
	//
	// This parameter is required.
	//
	// example:
	//
	// 656eaaa8c43a4597******1f09a36
	MediaId              *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s SubmitMediaDNADeleteJobRequest) String() string {
	return tea.Prettify(s)
}

func (s SubmitMediaDNADeleteJobRequest) GoString() string {
	return s.String()
}

func (s *SubmitMediaDNADeleteJobRequest) SetMediaId(v string) *SubmitMediaDNADeleteJobRequest {
	s.MediaId = &v
	return s
}

func (s *SubmitMediaDNADeleteJobRequest) SetOwnerAccount(v string) *SubmitMediaDNADeleteJobRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SubmitMediaDNADeleteJobRequest) SetOwnerId(v string) *SubmitMediaDNADeleteJobRequest {
	s.OwnerId = &v
	return s
}

func (s *SubmitMediaDNADeleteJobRequest) SetResourceOwnerAccount(v string) *SubmitMediaDNADeleteJobRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SubmitMediaDNADeleteJobRequest) SetResourceOwnerId(v string) *SubmitMediaDNADeleteJobRequest {
	s.ResourceOwnerId = &v
	return s
}

type SubmitMediaDNADeleteJobResponseBody struct {
	// The ID of the job.
	//
	// example:
	//
	// 6805B2EC-CE87-****-8FF6-9C0E97719A26
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// e5b1a2e7bee******b632c2710b9423f
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SubmitMediaDNADeleteJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SubmitMediaDNADeleteJobResponseBody) GoString() string {
	return s.String()
}

func (s *SubmitMediaDNADeleteJobResponseBody) SetJobId(v string) *SubmitMediaDNADeleteJobResponseBody {
	s.JobId = &v
	return s
}

func (s *SubmitMediaDNADeleteJobResponseBody) SetRequestId(v string) *SubmitMediaDNADeleteJobResponseBody {
	s.RequestId = &v
	return s
}

type SubmitMediaDNADeleteJobResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SubmitMediaDNADeleteJobResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SubmitMediaDNADeleteJobResponse) String() string {
	return tea.Prettify(s)
}

func (s SubmitMediaDNADeleteJobResponse) GoString() string {
	return s.String()
}

func (s *SubmitMediaDNADeleteJobResponse) SetHeaders(v map[string]*string) *SubmitMediaDNADeleteJobResponse {
	s.Headers = v
	return s
}

func (s *SubmitMediaDNADeleteJobResponse) SetStatusCode(v int32) *SubmitMediaDNADeleteJobResponse {
	s.StatusCode = &v
	return s
}

func (s *SubmitMediaDNADeleteJobResponse) SetBody(v *SubmitMediaDNADeleteJobResponseBody) *SubmitMediaDNADeleteJobResponse {
	s.Body = v
	return s
}

type SubmitPreprocessJobsRequest struct {
	// The preprocessing type. Set the value to **LivePreprocess**. LivePreprocess specifies that the video is preprocessed in the production studio.
	//
	// This parameter is required.
	//
	// example:
	//
	// LivePreprocess
	PreprocessType *string `json:"PreprocessType,omitempty" xml:"PreprocessType,omitempty"`
	// The ID of the video. You can use one of the following methods to obtain the ID:
	//
	// 	- After you upload a video in the ApsaraVideo VOD console, you can log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com) and choose **Media Files*	- > **Audio/Video*	- to view the ID of the video.
	//
	// 	- Obtain the VideoId from the response to the [CreateUploadVideo](https://help.aliyun.com/document_detail/55407.html) operation that you call to upload videos.
	//
	// 	- Obtain the VideoId from the response to the [SearchMedia](https://help.aliyun.com/document_detail/86044.html) operation that you call to query videos.
	//
	// This parameter is required.
	//
	// example:
	//
	// d3e680e618708efbf2cae7cc9312****
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s SubmitPreprocessJobsRequest) String() string {
	return tea.Prettify(s)
}

func (s SubmitPreprocessJobsRequest) GoString() string {
	return s.String()
}

func (s *SubmitPreprocessJobsRequest) SetPreprocessType(v string) *SubmitPreprocessJobsRequest {
	s.PreprocessType = &v
	return s
}

func (s *SubmitPreprocessJobsRequest) SetVideoId(v string) *SubmitPreprocessJobsRequest {
	s.VideoId = &v
	return s
}

type SubmitPreprocessJobsResponseBody struct {
	// The information about the job.
	PreprocessJobs *SubmitPreprocessJobsResponseBodyPreprocessJobs `json:"PreprocessJobs,omitempty" xml:"PreprocessJobs,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// E4EBD2BF-5EB0-4476-8829-9D94E1B1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SubmitPreprocessJobsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SubmitPreprocessJobsResponseBody) GoString() string {
	return s.String()
}

func (s *SubmitPreprocessJobsResponseBody) SetPreprocessJobs(v *SubmitPreprocessJobsResponseBodyPreprocessJobs) *SubmitPreprocessJobsResponseBody {
	s.PreprocessJobs = v
	return s
}

func (s *SubmitPreprocessJobsResponseBody) SetRequestId(v string) *SubmitPreprocessJobsResponseBody {
	s.RequestId = &v
	return s
}

type SubmitPreprocessJobsResponseBodyPreprocessJobs struct {
	PreprocessJob []*SubmitPreprocessJobsResponseBodyPreprocessJobsPreprocessJob `json:"PreprocessJob,omitempty" xml:"PreprocessJob,omitempty" type:"Repeated"`
}

func (s SubmitPreprocessJobsResponseBodyPreprocessJobs) String() string {
	return tea.Prettify(s)
}

func (s SubmitPreprocessJobsResponseBodyPreprocessJobs) GoString() string {
	return s.String()
}

func (s *SubmitPreprocessJobsResponseBodyPreprocessJobs) SetPreprocessJob(v []*SubmitPreprocessJobsResponseBodyPreprocessJobsPreprocessJob) *SubmitPreprocessJobsResponseBodyPreprocessJobs {
	s.PreprocessJob = v
	return s
}

type SubmitPreprocessJobsResponseBodyPreprocessJobsPreprocessJob struct {
	// The ID of the job.
	//
	// example:
	//
	// bb396607fd11fee9effbb99c4****
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
}

func (s SubmitPreprocessJobsResponseBodyPreprocessJobsPreprocessJob) String() string {
	return tea.Prettify(s)
}

func (s SubmitPreprocessJobsResponseBodyPreprocessJobsPreprocessJob) GoString() string {
	return s.String()
}

func (s *SubmitPreprocessJobsResponseBodyPreprocessJobsPreprocessJob) SetJobId(v string) *SubmitPreprocessJobsResponseBodyPreprocessJobsPreprocessJob {
	s.JobId = &v
	return s
}

type SubmitPreprocessJobsResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SubmitPreprocessJobsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SubmitPreprocessJobsResponse) String() string {
	return tea.Prettify(s)
}

func (s SubmitPreprocessJobsResponse) GoString() string {
	return s.String()
}

func (s *SubmitPreprocessJobsResponse) SetHeaders(v map[string]*string) *SubmitPreprocessJobsResponse {
	s.Headers = v
	return s
}

func (s *SubmitPreprocessJobsResponse) SetStatusCode(v int32) *SubmitPreprocessJobsResponse {
	s.StatusCode = &v
	return s
}

func (s *SubmitPreprocessJobsResponse) SetBody(v *SubmitPreprocessJobsResponseBody) *SubmitPreprocessJobsResponse {
	s.Body = v
	return s
}

type SubmitSnapshotJobRequest struct {
	// The maximum number of snapshots. Default value: **1**.
	//
	// example:
	//
	// 1
	Count *int64 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The height of each snapshot. Valid values: `[8,4096]`. By default, the height of the video source is used. Unit: pixels.
	//
	// example:
	//
	// 720
	Height *string `json:"Height,omitempty" xml:"Height,omitempty"`
	// The snapshot interval. The value must be **greater than or equal to 0**.
	//
	// 	- Unit: seconds.
	//
	// 	- Default value: **1**.
	//
	// 	- If you set this parameter to **0**, snapshots are captured at even intervals based on the video duration divided by the value of the Count parameter.
	//
	// example:
	//
	// 1
	Interval *int64 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The ID of the snapshot template.
	//
	// 	- We recommend that you create a snapshot template before you specify the template ID. For more information about how to create a snapshot template, see [AddVodTemplate](https://help.aliyun.com/document_detail/99406.html).
	//
	// 	- If you set the SnapshotTemplateId parameter, all the other request parameters except the Action and VideoId parameters are ignored.
	//
	// example:
	//
	// f5b228fe693bf55bd87b789****
	SnapshotTemplateId *string `json:"SnapshotTemplateId,omitempty" xml:"SnapshotTemplateId,omitempty"`
	// The point in time when the first snapshot is captured.
	//
	// 	- Unit: milliseconds.
	//
	// 	- Default value: **0**.
	//
	// example:
	//
	// 0
	SpecifiedOffsetTime *int64 `json:"SpecifiedOffsetTime,omitempty" xml:"SpecifiedOffsetTime,omitempty"`
	// The playback positions at which you want to capture snapshots. Unit: milliseconds. You can specify up to 30 playback positions in a request.
	SpecifiedOffsetTimes []*int64 `json:"SpecifiedOffsetTimes,omitempty" xml:"SpecifiedOffsetTimes,omitempty" type:"Repeated"`
	// The sprite snapshot configuration. If you set this parameter, sprite snapshots are generated. For more information, see [SpriteSnapshotConfig](https://help.aliyun.com/document_detail/86952.html).
	//
	// example:
	//
	// {\\"CellWidth\\": 120, \\"CellHeight\\": 68, \\"Columns\\": 3,\\"Lines\\": 10, \\"Padding\\": 20, \\"Margin\\": 50}
	SpriteSnapshotConfig *string `json:"SpriteSnapshotConfig,omitempty" xml:"SpriteSnapshotConfig,omitempty"`
	// The custom configurations including the configuration of transparent data transmission and callback configurations. The value must be a JSON string. For more information, see [UserData](https://help.aliyun.com/document_detail/86952.html).
	//
	// >  To use the message callback feature, you must specify an HTTP callback URL and the callback events in the ApsaraVideo VOD console. Otherwise, the callback settings do not take effect.
	//
	// example:
	//
	// {"MessageCallback":{"CallbackURL":"http://.example.aliyundoc.com"},"Extend":{"localId":"xxx","example":"www"}}
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
	// The ID of the video. You can use one of the following methods to obtain the ID:
	//
	// 	- After you upload a video in the ApsaraVideo VOD console, you can log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com) and choose **Media Files*	- > **Audio/Video*	- to view the ID of the video.
	//
	// 	- Obtain the video ID from the response to the [CreateUploadVideo](https://help.aliyun.com/document_detail/55407.html) operation that you called to obtain the upload URL and credential.
	//
	// 	- Obtain the video ID from the response to the [SearchMedia](https://help.aliyun.com/document_detail/86044.html) operation that you called to query media information after the audio or video file is uploaded.
	//
	// example:
	//
	// d3e680e618708efbf2cae7cc9312****
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
	// The width of each snapshot. Valid values: `[8,4096]`. By default, the width of the video source is used. Unit: pixels.
	//
	// example:
	//
	// 1280
	Width *string `json:"Width,omitempty" xml:"Width,omitempty"`
}

func (s SubmitSnapshotJobRequest) String() string {
	return tea.Prettify(s)
}

func (s SubmitSnapshotJobRequest) GoString() string {
	return s.String()
}

func (s *SubmitSnapshotJobRequest) SetCount(v int64) *SubmitSnapshotJobRequest {
	s.Count = &v
	return s
}

func (s *SubmitSnapshotJobRequest) SetHeight(v string) *SubmitSnapshotJobRequest {
	s.Height = &v
	return s
}

func (s *SubmitSnapshotJobRequest) SetInterval(v int64) *SubmitSnapshotJobRequest {
	s.Interval = &v
	return s
}

func (s *SubmitSnapshotJobRequest) SetSnapshotTemplateId(v string) *SubmitSnapshotJobRequest {
	s.SnapshotTemplateId = &v
	return s
}

func (s *SubmitSnapshotJobRequest) SetSpecifiedOffsetTime(v int64) *SubmitSnapshotJobRequest {
	s.SpecifiedOffsetTime = &v
	return s
}

func (s *SubmitSnapshotJobRequest) SetSpecifiedOffsetTimes(v []*int64) *SubmitSnapshotJobRequest {
	s.SpecifiedOffsetTimes = v
	return s
}

func (s *SubmitSnapshotJobRequest) SetSpriteSnapshotConfig(v string) *SubmitSnapshotJobRequest {
	s.SpriteSnapshotConfig = &v
	return s
}

func (s *SubmitSnapshotJobRequest) SetUserData(v string) *SubmitSnapshotJobRequest {
	s.UserData = &v
	return s
}

func (s *SubmitSnapshotJobRequest) SetVideoId(v string) *SubmitSnapshotJobRequest {
	s.VideoId = &v
	return s
}

func (s *SubmitSnapshotJobRequest) SetWidth(v string) *SubmitSnapshotJobRequest {
	s.Width = &v
	return s
}

type SubmitSnapshotJobShrinkRequest struct {
	// The maximum number of snapshots. Default value: **1**.
	//
	// example:
	//
	// 1
	Count *int64 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The height of each snapshot. Valid values: `[8,4096]`. By default, the height of the video source is used. Unit: pixels.
	//
	// example:
	//
	// 720
	Height *string `json:"Height,omitempty" xml:"Height,omitempty"`
	// The snapshot interval. The value must be **greater than or equal to 0**.
	//
	// 	- Unit: seconds.
	//
	// 	- Default value: **1**.
	//
	// 	- If you set this parameter to **0**, snapshots are captured at even intervals based on the video duration divided by the value of the Count parameter.
	//
	// example:
	//
	// 1
	Interval *int64 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The ID of the snapshot template.
	//
	// 	- We recommend that you create a snapshot template before you specify the template ID. For more information about how to create a snapshot template, see [AddVodTemplate](https://help.aliyun.com/document_detail/99406.html).
	//
	// 	- If you set the SnapshotTemplateId parameter, all the other request parameters except the Action and VideoId parameters are ignored.
	//
	// example:
	//
	// f5b228fe693bf55bd87b789****
	SnapshotTemplateId *string `json:"SnapshotTemplateId,omitempty" xml:"SnapshotTemplateId,omitempty"`
	// The point in time when the first snapshot is captured.
	//
	// 	- Unit: milliseconds.
	//
	// 	- Default value: **0**.
	//
	// example:
	//
	// 0
	SpecifiedOffsetTime *int64 `json:"SpecifiedOffsetTime,omitempty" xml:"SpecifiedOffsetTime,omitempty"`
	// The playback positions at which you want to capture snapshots. Unit: milliseconds. You can specify up to 30 playback positions in a request.
	SpecifiedOffsetTimesShrink *string `json:"SpecifiedOffsetTimes,omitempty" xml:"SpecifiedOffsetTimes,omitempty"`
	// The sprite snapshot configuration. If you set this parameter, sprite snapshots are generated. For more information, see [SpriteSnapshotConfig](https://help.aliyun.com/document_detail/86952.html).
	//
	// example:
	//
	// {\\"CellWidth\\": 120, \\"CellHeight\\": 68, \\"Columns\\": 3,\\"Lines\\": 10, \\"Padding\\": 20, \\"Margin\\": 50}
	SpriteSnapshotConfig *string `json:"SpriteSnapshotConfig,omitempty" xml:"SpriteSnapshotConfig,omitempty"`
	// The custom configurations including the configuration of transparent data transmission and callback configurations. The value must be a JSON string. For more information, see [UserData](https://help.aliyun.com/document_detail/86952.html).
	//
	// >  To use the message callback feature, you must specify an HTTP callback URL and the callback events in the ApsaraVideo VOD console. Otherwise, the callback settings do not take effect.
	//
	// example:
	//
	// {"MessageCallback":{"CallbackURL":"http://.example.aliyundoc.com"},"Extend":{"localId":"xxx","example":"www"}}
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
	// The ID of the video. You can use one of the following methods to obtain the ID:
	//
	// 	- After you upload a video in the ApsaraVideo VOD console, you can log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com) and choose **Media Files*	- > **Audio/Video*	- to view the ID of the video.
	//
	// 	- Obtain the video ID from the response to the [CreateUploadVideo](https://help.aliyun.com/document_detail/55407.html) operation that you called to obtain the upload URL and credential.
	//
	// 	- Obtain the video ID from the response to the [SearchMedia](https://help.aliyun.com/document_detail/86044.html) operation that you called to query media information after the audio or video file is uploaded.
	//
	// example:
	//
	// d3e680e618708efbf2cae7cc9312****
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
	// The width of each snapshot. Valid values: `[8,4096]`. By default, the width of the video source is used. Unit: pixels.
	//
	// example:
	//
	// 1280
	Width *string `json:"Width,omitempty" xml:"Width,omitempty"`
}

func (s SubmitSnapshotJobShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s SubmitSnapshotJobShrinkRequest) GoString() string {
	return s.String()
}

func (s *SubmitSnapshotJobShrinkRequest) SetCount(v int64) *SubmitSnapshotJobShrinkRequest {
	s.Count = &v
	return s
}

func (s *SubmitSnapshotJobShrinkRequest) SetHeight(v string) *SubmitSnapshotJobShrinkRequest {
	s.Height = &v
	return s
}

func (s *SubmitSnapshotJobShrinkRequest) SetInterval(v int64) *SubmitSnapshotJobShrinkRequest {
	s.Interval = &v
	return s
}

func (s *SubmitSnapshotJobShrinkRequest) SetSnapshotTemplateId(v string) *SubmitSnapshotJobShrinkRequest {
	s.SnapshotTemplateId = &v
	return s
}

func (s *SubmitSnapshotJobShrinkRequest) SetSpecifiedOffsetTime(v int64) *SubmitSnapshotJobShrinkRequest {
	s.SpecifiedOffsetTime = &v
	return s
}

func (s *SubmitSnapshotJobShrinkRequest) SetSpecifiedOffsetTimesShrink(v string) *SubmitSnapshotJobShrinkRequest {
	s.SpecifiedOffsetTimesShrink = &v
	return s
}

func (s *SubmitSnapshotJobShrinkRequest) SetSpriteSnapshotConfig(v string) *SubmitSnapshotJobShrinkRequest {
	s.SpriteSnapshotConfig = &v
	return s
}

func (s *SubmitSnapshotJobShrinkRequest) SetUserData(v string) *SubmitSnapshotJobShrinkRequest {
	s.UserData = &v
	return s
}

func (s *SubmitSnapshotJobShrinkRequest) SetVideoId(v string) *SubmitSnapshotJobShrinkRequest {
	s.VideoId = &v
	return s
}

func (s *SubmitSnapshotJobShrinkRequest) SetWidth(v string) *SubmitSnapshotJobShrinkRequest {
	s.Width = &v
	return s
}

type SubmitSnapshotJobResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-5EB0-4AF6-D7393642****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the snapshot job.
	SnapshotJob *SubmitSnapshotJobResponseBodySnapshotJob `json:"SnapshotJob,omitempty" xml:"SnapshotJob,omitempty" type:"Struct"`
}

func (s SubmitSnapshotJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SubmitSnapshotJobResponseBody) GoString() string {
	return s.String()
}

func (s *SubmitSnapshotJobResponseBody) SetRequestId(v string) *SubmitSnapshotJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *SubmitSnapshotJobResponseBody) SetSnapshotJob(v *SubmitSnapshotJobResponseBodySnapshotJob) *SubmitSnapshotJobResponseBody {
	s.SnapshotJob = v
	return s
}

type SubmitSnapshotJobResponseBodySnapshotJob struct {
	// The ID of the snapshot job.
	//
	// example:
	//
	// ad90a501b1b94b72374ad0050464****
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
}

func (s SubmitSnapshotJobResponseBodySnapshotJob) String() string {
	return tea.Prettify(s)
}

func (s SubmitSnapshotJobResponseBodySnapshotJob) GoString() string {
	return s.String()
}

func (s *SubmitSnapshotJobResponseBodySnapshotJob) SetJobId(v string) *SubmitSnapshotJobResponseBodySnapshotJob {
	s.JobId = &v
	return s
}

type SubmitSnapshotJobResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SubmitSnapshotJobResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SubmitSnapshotJobResponse) String() string {
	return tea.Prettify(s)
}

func (s SubmitSnapshotJobResponse) GoString() string {
	return s.String()
}

func (s *SubmitSnapshotJobResponse) SetHeaders(v map[string]*string) *SubmitSnapshotJobResponse {
	s.Headers = v
	return s
}

func (s *SubmitSnapshotJobResponse) SetStatusCode(v int32) *SubmitSnapshotJobResponse {
	s.StatusCode = &v
	return s
}

func (s *SubmitSnapshotJobResponse) SetBody(v *SubmitSnapshotJobResponseBody) *SubmitSnapshotJobResponse {
	s.Body = v
	return s
}

type SubmitTranscodeJobsRequest struct {
	// The encryption configurations. The value must be a JSON string. This parameter is required only when you use HLS encryption.
	//
	// >
	//
	// 	- You must set **CipherText*	- in [EncrptConfig](https://help.aliyun.com/document_detail/86952.html) to the AES_128 cipher text that is obtained from the response to the [GenerateKMSDataKey](https://help.aliyun.com/document_detail/455051.html) operation. Otherwise, the HLS encryption fails. For more information about how to use HLS encryption, see [HLS encryption](https://help.aliyun.com/document_detail/68612.html).
	//
	// 	- You must select HLS encryption for the template specified by **TemplateGroupId*	- no matter you use HLS encryption or Alibaba Cloud proprietary cryptography. Otherwise, the transcoded file is not encrypted.
	//
	// example:
	//
	// {"CipherText":"ZjJmZGViNzUtZWY1Mi00Y2RlLTk3****", "DecryptKeyUri":"http://demo.aliyundoc.com?CipherText=ZjJmZGViNzUtZWY1Mi00Y2RlLTk3****","KeyServiceType":"KMS"}
	EncryptConfig *string `json:"EncryptConfig,omitempty" xml:"EncryptConfig,omitempty"`
	// The override parameter. The value must be a JSON string. You can use this parameter to override the image watermark, text watermark, or subtitle file specified in the transcoding template, or override the encoding format of the subtitle file. For more information about the data structure, see [OverrideParams](https://help.aliyun.com/document_detail/98618.html).
	//
	// example:
	//
	// {"Watermarks":[{"WatermarkId":"af2afe4761992c47dae973374****","FileUrl":"http://developer.aliyundoc.com/image/image.png"},{"WatermarkId":"e8e5b8038d7ada85b376c2707****","Content":"watermark test"}]}
	OverrideParams *string `json:"OverrideParams,omitempty" xml:"OverrideParams,omitempty"`
	// The ID of the queue that you want to use to run the job.
	//
	// example:
	//
	// d3e680e618708erf45fbf2cae7c****
	PipelineId *string `json:"PipelineId,omitempty" xml:"PipelineId,omitempty"`
	// The priority of the transcoding job in all queued jobs.
	//
	// 	- Valid values: **1*	- to **10**.
	//
	// 	- A value of **10*	- indicates the highest priority.
	//
	// 	- Default value: **6**.
	//
	// >  This parameter takes effect only on the queued transcoding jobs. The priorities of the in-progress transcoding jobs are not affected.
	//
	// example:
	//
	// 6
	Priority *string `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The custom identifier for deduplication. If you send a request, an error is returned if a request with the same identifier was sent in the last 7 days. A custom identifier can be up to 50 characters in length and can contain letters, digits, hyphens (-), and underscores (_). If you do not specify this parameter or leave this parameter empty, duplicate requests are not filtered.
	//
	// example:
	//
	// 5c62d40299034bbaa4c195da330****
	SessionId *string `json:"SessionId,omitempty" xml:"SessionId,omitempty"`
	// The ID of the transcoding template group that you want to use. To view the template group ID, perform the following operations: Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Configuration Management*	- > **Media Processing*	- > **Transcoding Template Groups**.
	//
	// This parameter is required.
	//
	// example:
	//
	// 0e408c803baf658ee637790c5d9f****
	TemplateGroupId *string `json:"TemplateGroupId,omitempty" xml:"TemplateGroupId,omitempty"`
	// The custom settings. The value must be a JSON string. You can configure settings such as message callbacks. For more information, see [UserData](https://help.aliyun.com/document_detail/86952.html).
	//
	// >  To use the callback configurations specified by this parameter, you must configure an HTTP callback URL and specify the types of the callback events in the ApsaraVideo VOD console. Otherwise, the callback configurations do not take effect.
	//
	// example:
	//
	// {"Extend":{"localId":"****","test":"***"}}
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
	// The ID of the video file. You can use one of the following methods to obtain the video ID:
	//
	// 	- Log on to the [ApsaraVideo VOD](https://vod.console.aliyun.com) console. In the left-side navigation pane, choose **Media Files*	- > **Audio/Video**. On the Video and Audio page, view the ID of the video file. This method is applicable to files that are uploaded by using the ApsaraVideo VOD console.
	//
	// 	- Obtain the value of VideoId from the response to the [CreateUploadVideo](https://help.aliyun.com/document_detail/55407.html) operation that you call to upload the video.
	//
	// 	- Obtain the value of VideoId from the response to the [SearchMedia](https://help.aliyun.com/document_detail/86044.html) operation after you upload the video.
	//
	// example:
	//
	// 142710f878bd42508932f660d7b1****
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s SubmitTranscodeJobsRequest) String() string {
	return tea.Prettify(s)
}

func (s SubmitTranscodeJobsRequest) GoString() string {
	return s.String()
}

func (s *SubmitTranscodeJobsRequest) SetEncryptConfig(v string) *SubmitTranscodeJobsRequest {
	s.EncryptConfig = &v
	return s
}

func (s *SubmitTranscodeJobsRequest) SetOverrideParams(v string) *SubmitTranscodeJobsRequest {
	s.OverrideParams = &v
	return s
}

func (s *SubmitTranscodeJobsRequest) SetPipelineId(v string) *SubmitTranscodeJobsRequest {
	s.PipelineId = &v
	return s
}

func (s *SubmitTranscodeJobsRequest) SetPriority(v string) *SubmitTranscodeJobsRequest {
	s.Priority = &v
	return s
}

func (s *SubmitTranscodeJobsRequest) SetSessionId(v string) *SubmitTranscodeJobsRequest {
	s.SessionId = &v
	return s
}

func (s *SubmitTranscodeJobsRequest) SetTemplateGroupId(v string) *SubmitTranscodeJobsRequest {
	s.TemplateGroupId = &v
	return s
}

func (s *SubmitTranscodeJobsRequest) SetUserData(v string) *SubmitTranscodeJobsRequest {
	s.UserData = &v
	return s
}

func (s *SubmitTranscodeJobsRequest) SetVideoId(v string) *SubmitTranscodeJobsRequest {
	s.VideoId = &v
	return s
}

type SubmitTranscodeJobsResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// E4EBD2BF-5EB0-4476-8829-9D94E1B1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the transcoding job.
	//
	// >  This parameter is not returned for HLS packaging tasks. You must asynchronously receive the transcoding result.
	TranscodeJobs *SubmitTranscodeJobsResponseBodyTranscodeJobs `json:"TranscodeJobs,omitempty" xml:"TranscodeJobs,omitempty" type:"Struct"`
	// The ID of the transcoding task that was submitted.
	//
	// example:
	//
	// 9f4a0df7da2c8a81c8c0408c84****
	TranscodeTaskId *string `json:"TranscodeTaskId,omitempty" xml:"TranscodeTaskId,omitempty"`
}

func (s SubmitTranscodeJobsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SubmitTranscodeJobsResponseBody) GoString() string {
	return s.String()
}

func (s *SubmitTranscodeJobsResponseBody) SetRequestId(v string) *SubmitTranscodeJobsResponseBody {
	s.RequestId = &v
	return s
}

func (s *SubmitTranscodeJobsResponseBody) SetTranscodeJobs(v *SubmitTranscodeJobsResponseBodyTranscodeJobs) *SubmitTranscodeJobsResponseBody {
	s.TranscodeJobs = v
	return s
}

func (s *SubmitTranscodeJobsResponseBody) SetTranscodeTaskId(v string) *SubmitTranscodeJobsResponseBody {
	s.TranscodeTaskId = &v
	return s
}

type SubmitTranscodeJobsResponseBodyTranscodeJobs struct {
	TranscodeJob []*SubmitTranscodeJobsResponseBodyTranscodeJobsTranscodeJob `json:"TranscodeJob,omitempty" xml:"TranscodeJob,omitempty" type:"Repeated"`
}

func (s SubmitTranscodeJobsResponseBodyTranscodeJobs) String() string {
	return tea.Prettify(s)
}

func (s SubmitTranscodeJobsResponseBodyTranscodeJobs) GoString() string {
	return s.String()
}

func (s *SubmitTranscodeJobsResponseBodyTranscodeJobs) SetTranscodeJob(v []*SubmitTranscodeJobsResponseBodyTranscodeJobsTranscodeJob) *SubmitTranscodeJobsResponseBodyTranscodeJobs {
	s.TranscodeJob = v
	return s
}

type SubmitTranscodeJobsResponseBodyTranscodeJobsTranscodeJob struct {
	// The ID of the transcoding job.
	//
	// >  This parameter is not returned for HLS packaging tasks. You must asynchronously receive the transcoding result.
	//
	// example:
	//
	// d8921ce8505716cfe86fb112c4****
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
}

func (s SubmitTranscodeJobsResponseBodyTranscodeJobsTranscodeJob) String() string {
	return tea.Prettify(s)
}

func (s SubmitTranscodeJobsResponseBodyTranscodeJobsTranscodeJob) GoString() string {
	return s.String()
}

func (s *SubmitTranscodeJobsResponseBodyTranscodeJobsTranscodeJob) SetJobId(v string) *SubmitTranscodeJobsResponseBodyTranscodeJobsTranscodeJob {
	s.JobId = &v
	return s
}

type SubmitTranscodeJobsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SubmitTranscodeJobsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SubmitTranscodeJobsResponse) String() string {
	return tea.Prettify(s)
}

func (s SubmitTranscodeJobsResponse) GoString() string {
	return s.String()
}

func (s *SubmitTranscodeJobsResponse) SetHeaders(v map[string]*string) *SubmitTranscodeJobsResponse {
	s.Headers = v
	return s
}

func (s *SubmitTranscodeJobsResponse) SetStatusCode(v int32) *SubmitTranscodeJobsResponse {
	s.StatusCode = &v
	return s
}

func (s *SubmitTranscodeJobsResponse) SetBody(v *SubmitTranscodeJobsResponseBody) *SubmitTranscodeJobsResponse {
	s.Body = v
	return s
}

type SubmitWorkflowJobRequest struct {
	// The ID of the media file. You can use one of the following methods to obtain the ID:
	//
	// 	- Log on to the [ApsaraVideo VOD](https://vod.console.aliyun.com) console. In the left-side navigation pane, choose **Media Files*	- > **Audio/Video**. On the Video and Audio page, view the ID of the audio or video file. This method is applicable to files that are uploaded by using the ApsaraVideo VOD console.
	//
	// 	- Obtain the value of the VideoId parameter when you call the [CreateUploadVideo](https://help.aliyun.com/document_detail/55407.html) operation to upload media files.
	//
	// 	- Obtain the value of the VideoId parameter when you call the [SearchMedia](https://help.aliyun.com/document_detail/86044.html) operation after you upload media files.
	//
	// example:
	//
	// 058b39e75269da42b08f00459****
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The ID of the workflow. To view the ID of the workflow, log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Configuration Management*	- > **Media Processing*	- > **Workflows**.
	//
	// This parameter is required.
	//
	// example:
	//
	// 34d577eade633860bdf1237****
	WorkflowId *string `json:"WorkflowId,omitempty" xml:"WorkflowId,omitempty"`
}

func (s SubmitWorkflowJobRequest) String() string {
	return tea.Prettify(s)
}

func (s SubmitWorkflowJobRequest) GoString() string {
	return s.String()
}

func (s *SubmitWorkflowJobRequest) SetMediaId(v string) *SubmitWorkflowJobRequest {
	s.MediaId = &v
	return s
}

func (s *SubmitWorkflowJobRequest) SetWorkflowId(v string) *SubmitWorkflowJobRequest {
	s.WorkflowId = &v
	return s
}

type SubmitWorkflowJobResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// A01C8FF4-C106-4431-418F973DADB7****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SubmitWorkflowJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SubmitWorkflowJobResponseBody) GoString() string {
	return s.String()
}

func (s *SubmitWorkflowJobResponseBody) SetRequestId(v string) *SubmitWorkflowJobResponseBody {
	s.RequestId = &v
	return s
}

type SubmitWorkflowJobResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SubmitWorkflowJobResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SubmitWorkflowJobResponse) String() string {
	return tea.Prettify(s)
}

func (s SubmitWorkflowJobResponse) GoString() string {
	return s.String()
}

func (s *SubmitWorkflowJobResponse) SetHeaders(v map[string]*string) *SubmitWorkflowJobResponse {
	s.Headers = v
	return s
}

func (s *SubmitWorkflowJobResponse) SetStatusCode(v int32) *SubmitWorkflowJobResponse {
	s.StatusCode = &v
	return s
}

func (s *SubmitWorkflowJobResponse) SetBody(v *SubmitWorkflowJobResponseBody) *SubmitWorkflowJobResponse {
	s.Body = v
	return s
}

type UpdateAITemplateRequest struct {
	// The detailed configurations of the AI template. The value is a JSON string. For more information, see [AITemplateConfig](~~89863#title-vd3-499-o36~~).
	//
	// This parameter is required.
	//
	// example:
	//
	// {"AuditItem":["terrorism","porn"],"AuditRange":["text-title","video"],"AuditContent":["screen"],"AuditAutoBlock":"yes"}
	TemplateConfig *string `json:"TemplateConfig,omitempty" xml:"TemplateConfig,omitempty"`
	// The ID of the AI template. You can use one of the following methods to obtain the ID:
	//
	// 	- Call the [AddAITemplate](https://help.aliyun.com/document_detail/102930.html) operation to add an AI template if no AI template exists. The value of TemplateId in the response is the ID of the AI template.
	//
	// 	- Call the [ListAITemplate](https://help.aliyun.com/document_detail/102936.html) operation if the template already exists. The value of TemplateId in the response is the ID of the AI template.
	//
	// This parameter is required.
	//
	// example:
	//
	// 1706a0063dd733f6a823ef32e0a5****
	TemplateId *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The name of the AI template. The name can be up to 128 bytes in length.
	//
	// This parameter is required.
	//
	// example:
	//
	// DemoAITemplate
	TemplateName *string `json:"TemplateName,omitempty" xml:"TemplateName,omitempty"`
}

func (s UpdateAITemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAITemplateRequest) GoString() string {
	return s.String()
}

func (s *UpdateAITemplateRequest) SetTemplateConfig(v string) *UpdateAITemplateRequest {
	s.TemplateConfig = &v
	return s
}

func (s *UpdateAITemplateRequest) SetTemplateId(v string) *UpdateAITemplateRequest {
	s.TemplateId = &v
	return s
}

func (s *UpdateAITemplateRequest) SetTemplateName(v string) *UpdateAITemplateRequest {
	s.TemplateName = &v
	return s
}

type UpdateAITemplateResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A13-BEF6-****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the template.
	//
	// example:
	//
	// 1706a0063dd733f6a823ef32e0a5****
	TemplateId *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
}

func (s UpdateAITemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateAITemplateResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateAITemplateResponseBody) SetRequestId(v string) *UpdateAITemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateAITemplateResponseBody) SetTemplateId(v string) *UpdateAITemplateResponseBody {
	s.TemplateId = &v
	return s
}

type UpdateAITemplateResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateAITemplateResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateAITemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAITemplateResponse) GoString() string {
	return s.String()
}

func (s *UpdateAITemplateResponse) SetHeaders(v map[string]*string) *UpdateAITemplateResponse {
	s.Headers = v
	return s
}

func (s *UpdateAITemplateResponse) SetStatusCode(v int32) *UpdateAITemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateAITemplateResponse) SetBody(v *UpdateAITemplateResponseBody) *UpdateAITemplateResponse {
	s.Body = v
	return s
}

type UpdateAppInfoRequest struct {
	// The ID of the application.
	//
	// 	- Default value: **app-1000000**.
	//
	// 	- For more information, see [Overview](https://help.aliyun.com/document_detail/113600.html).
	//
	// This parameter is required.
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the application.
	//
	// 	- The name can contain up to 128 characters in length, including Chinese letters, digits, and periods (.), dash (-), and at character (@).
	//
	// 	- The name can contain only UTF-8 characters.
	//
	// example:
	//
	// test
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The description of the application.
	//
	// 	- The description can contain up to 512 characters in length.
	//
	// 	- The description can contain only UTF-8 characters.
	//
	// example:
	//
	// my first app.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The status of the application. Valid values:
	//
	// 	- **Normal**
	//
	// 	- **Disable**
	//
	// example:
	//
	// Disable
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s UpdateAppInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAppInfoRequest) GoString() string {
	return s.String()
}

func (s *UpdateAppInfoRequest) SetAppId(v string) *UpdateAppInfoRequest {
	s.AppId = &v
	return s
}

func (s *UpdateAppInfoRequest) SetAppName(v string) *UpdateAppInfoRequest {
	s.AppName = &v
	return s
}

func (s *UpdateAppInfoRequest) SetDescription(v string) *UpdateAppInfoRequest {
	s.Description = &v
	return s
}

func (s *UpdateAppInfoRequest) SetStatus(v string) *UpdateAppInfoRequest {
	s.Status = &v
	return s
}

type UpdateAppInfoResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A13-DF45-D7393642****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateAppInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateAppInfoResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateAppInfoResponseBody) SetRequestId(v string) *UpdateAppInfoResponseBody {
	s.RequestId = &v
	return s
}

type UpdateAppInfoResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateAppInfoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateAppInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAppInfoResponse) GoString() string {
	return s.String()
}

func (s *UpdateAppInfoResponse) SetHeaders(v map[string]*string) *UpdateAppInfoResponse {
	s.Headers = v
	return s
}

func (s *UpdateAppInfoResponse) SetStatusCode(v int32) *UpdateAppInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateAppInfoResponse) SetBody(v *UpdateAppInfoResponseBody) *UpdateAppInfoResponse {
	s.Body = v
	return s
}

type UpdateAttachedMediaInfosRequest struct {
	// The new information about the one or more images. You can modify the information about up to 20 auxiliary media assets at a time. For more information, see the **UpdateContent*	- section of this topic.
	//
	// > 	- You cannot specify emojis for `Title`, `Description`, or `Tags`.
	//
	// > 	- The specific parameter of a video is updated only when a new value is passed in the parameter.
	//
	// This parameter is required.
	//
	// example:
	//
	// [{"MediaId ":"bbc65bba53f6ed90de118a7849****","Title":" test title1","Description":"test description1","Tags":"tag1,tag2"},{"MediaId ":"f45cf4eba5cb90233389558c39****","Title2":"test title2","Description2":"test description2","Tags":"tag3,tag4"}]
	UpdateContent *string `json:"UpdateContent,omitempty" xml:"UpdateContent,omitempty"`
}

func (s UpdateAttachedMediaInfosRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAttachedMediaInfosRequest) GoString() string {
	return s.String()
}

func (s *UpdateAttachedMediaInfosRequest) SetUpdateContent(v string) *UpdateAttachedMediaInfosRequest {
	s.UpdateContent = &v
	return s
}

type UpdateAttachedMediaInfosResponseBody struct {
	// The IDs of the auxiliary media assets that do not exist.
	NonExistMediaIds []*string `json:"NonExistMediaIds,omitempty" xml:"NonExistMediaIds,omitempty" type:"Repeated"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4DF6-D7393642CA58****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateAttachedMediaInfosResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateAttachedMediaInfosResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateAttachedMediaInfosResponseBody) SetNonExistMediaIds(v []*string) *UpdateAttachedMediaInfosResponseBody {
	s.NonExistMediaIds = v
	return s
}

func (s *UpdateAttachedMediaInfosResponseBody) SetRequestId(v string) *UpdateAttachedMediaInfosResponseBody {
	s.RequestId = &v
	return s
}

type UpdateAttachedMediaInfosResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateAttachedMediaInfosResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateAttachedMediaInfosResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAttachedMediaInfosResponse) GoString() string {
	return s.String()
}

func (s *UpdateAttachedMediaInfosResponse) SetHeaders(v map[string]*string) *UpdateAttachedMediaInfosResponse {
	s.Headers = v
	return s
}

func (s *UpdateAttachedMediaInfosResponse) SetStatusCode(v int32) *UpdateAttachedMediaInfosResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateAttachedMediaInfosResponse) SetBody(v *UpdateAttachedMediaInfosResponseBody) *UpdateAttachedMediaInfosResponse {
	s.Body = v
	return s
}

type UpdateCategoryRequest struct {
	// The ID of the category. You can specify only one ID. You can use one of the following methods to obtain the ID:
	//
	// 	- Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). Choose **Configuration Management*	- > **Media Management*	- > **Categories**. On the **Audio and Video / Image Category*	- or **Short Video Material Category*	- tab, view the category ID.
	//
	// 	- Obtain the category ID from the response to the [AddCategory](~~AddCategory~~) operation.
	//
	// This parameter is required.
	//
	// example:
	//
	// 10020****
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The name of the category.
	//
	// 	- The value can be up to 64 bytes in length.
	//
	// 	- The value must be encoded in UTF-8.
	//
	// This parameter is required.
	//
	// example:
	//
	// beauty
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
}

func (s UpdateCategoryRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateCategoryRequest) GoString() string {
	return s.String()
}

func (s *UpdateCategoryRequest) SetCateId(v int64) *UpdateCategoryRequest {
	s.CateId = &v
	return s
}

func (s *UpdateCategoryRequest) SetCateName(v string) *UpdateCategoryRequest {
	s.CateName = &v
	return s
}

type UpdateCategoryResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4AF6-D7393642CA58****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateCategoryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateCategoryResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateCategoryResponseBody) SetRequestId(v string) *UpdateCategoryResponseBody {
	s.RequestId = &v
	return s
}

type UpdateCategoryResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateCategoryResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateCategoryResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateCategoryResponse) GoString() string {
	return s.String()
}

func (s *UpdateCategoryResponse) SetHeaders(v map[string]*string) *UpdateCategoryResponse {
	s.Headers = v
	return s
}

func (s *UpdateCategoryResponse) SetStatusCode(v int32) *UpdateCategoryResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateCategoryResponse) SetBody(v *UpdateCategoryResponseBody) *UpdateCategoryResponse {
	s.Body = v
	return s
}

type UpdateEditingProjectRequest struct {
	// The thumbnail URL of the online editing project.
	//
	// example:
	//
	// https://****.com/6AB4D0E1E1C7446888****.png
	CoverURL *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	// The description of the online editing project.
	//
	// example:
	//
	// testtimeline001desciption
	Description  *string `json:"Description,omitempty" xml:"Description,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the online editing project.
	//
	// This parameter is required.
	//
	// example:
	//
	// 4ee4b97e27*****b525142a6b2
	ProjectId            *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The timeline of the online editing project. For more information about the structure, see [Timeline](https://help.aliyun.com/document_detail/52839.html).
	//
	// example:
	//
	// {"VideoTracks":[{"VideoTrackClips":[{"MediaId":"cc3308ac500c*****a54328bc3443"},{"MediaId":"da87a9cff64*****d88bc6d8326e4"}]}]}
	Timeline *string `json:"Timeline,omitempty" xml:"Timeline,omitempty"`
	// The title of the online editing project.
	//
	// example:
	//
	// testtimeline
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
}

func (s UpdateEditingProjectRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateEditingProjectRequest) GoString() string {
	return s.String()
}

func (s *UpdateEditingProjectRequest) SetCoverURL(v string) *UpdateEditingProjectRequest {
	s.CoverURL = &v
	return s
}

func (s *UpdateEditingProjectRequest) SetDescription(v string) *UpdateEditingProjectRequest {
	s.Description = &v
	return s
}

func (s *UpdateEditingProjectRequest) SetOwnerAccount(v string) *UpdateEditingProjectRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UpdateEditingProjectRequest) SetOwnerId(v string) *UpdateEditingProjectRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdateEditingProjectRequest) SetProjectId(v string) *UpdateEditingProjectRequest {
	s.ProjectId = &v
	return s
}

func (s *UpdateEditingProjectRequest) SetResourceOwnerAccount(v string) *UpdateEditingProjectRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UpdateEditingProjectRequest) SetResourceOwnerId(v string) *UpdateEditingProjectRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UpdateEditingProjectRequest) SetTimeline(v string) *UpdateEditingProjectRequest {
	s.Timeline = &v
	return s
}

func (s *UpdateEditingProjectRequest) SetTitle(v string) *UpdateEditingProjectRequest {
	s.Title = &v
	return s
}

type UpdateEditingProjectResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A*****F6-D7393642CA58
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateEditingProjectResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateEditingProjectResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateEditingProjectResponseBody) SetRequestId(v string) *UpdateEditingProjectResponseBody {
	s.RequestId = &v
	return s
}

type UpdateEditingProjectResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateEditingProjectResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateEditingProjectResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateEditingProjectResponse) GoString() string {
	return s.String()
}

func (s *UpdateEditingProjectResponse) SetHeaders(v map[string]*string) *UpdateEditingProjectResponse {
	s.Headers = v
	return s
}

func (s *UpdateEditingProjectResponse) SetStatusCode(v int32) *UpdateEditingProjectResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateEditingProjectResponse) SetBody(v *UpdateEditingProjectResponseBody) *UpdateEditingProjectResponse {
	s.Body = v
	return s
}

type UpdateImageInfosRequest struct {
	// The new information about the one or more images. You can modify the information about up to 20 images at a time. For more information about the parameter structure, see the **UpdateContent*	- section.
	//
	// >  The values of the nested parameters Title, Description, and Tags under the UpdateContent parameter cannot contain emoticons.
	//
	// This parameter is required.
	//
	// example:
	//
	// [{"ImageId":"ff8fe57e3461416c6a267a4e09****","Title":"test title","Description":"test description","Tags":"tag1,tag2"}]
	UpdateContent *string `json:"UpdateContent,omitempty" xml:"UpdateContent,omitempty"`
}

func (s UpdateImageInfosRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateImageInfosRequest) GoString() string {
	return s.String()
}

func (s *UpdateImageInfosRequest) SetUpdateContent(v string) *UpdateImageInfosRequest {
	s.UpdateContent = &v
	return s
}

type UpdateImageInfosResponseBody struct {
	// The IDs of the images that do not exist.
	NonExistImageIds *UpdateImageInfosResponseBodyNonExistImageIds `json:"NonExistImageIds,omitempty" xml:"NonExistImageIds,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4AF6-D7393642CA58****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateImageInfosResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateImageInfosResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateImageInfosResponseBody) SetNonExistImageIds(v *UpdateImageInfosResponseBodyNonExistImageIds) *UpdateImageInfosResponseBody {
	s.NonExistImageIds = v
	return s
}

func (s *UpdateImageInfosResponseBody) SetRequestId(v string) *UpdateImageInfosResponseBody {
	s.RequestId = &v
	return s
}

type UpdateImageInfosResponseBodyNonExistImageIds struct {
	ImageId []*string `json:"ImageId,omitempty" xml:"ImageId,omitempty" type:"Repeated"`
}

func (s UpdateImageInfosResponseBodyNonExistImageIds) String() string {
	return tea.Prettify(s)
}

func (s UpdateImageInfosResponseBodyNonExistImageIds) GoString() string {
	return s.String()
}

func (s *UpdateImageInfosResponseBodyNonExistImageIds) SetImageId(v []*string) *UpdateImageInfosResponseBodyNonExistImageIds {
	s.ImageId = v
	return s
}

type UpdateImageInfosResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateImageInfosResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateImageInfosResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateImageInfosResponse) GoString() string {
	return s.String()
}

func (s *UpdateImageInfosResponse) SetHeaders(v map[string]*string) *UpdateImageInfosResponse {
	s.Headers = v
	return s
}

func (s *UpdateImageInfosResponse) SetStatusCode(v int32) *UpdateImageInfosResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateImageInfosResponse) SetBody(v *UpdateImageInfosResponseBody) *UpdateImageInfosResponse {
	s.Body = v
	return s
}

type UpdateMediaStorageClassRequest struct {
	// Specifies whether to change the storage class of a media asset that is stored for less than the minimum storage duration. Valid values:
	//
	// 	- **true**
	//
	// 	- **false**
	//
	// >  If you forcibly change the storage class of a media asset that is stored for less than the minimum storage duration, additional data retrieval fees are incurred.
	//
	// example:
	//
	// false
	AllowUpdateWithoutTimeLimit *bool `json:"AllowUpdateWithoutTimeLimit,omitempty" xml:"AllowUpdateWithoutTimeLimit,omitempty"`
	// The media asset ID. You can specify a maximum of 20 IDs. Separate multiple IDs with commas (,). You can use one of the following methods to obtain the ID:
	//
	// 	- Log on to the [ApsaraVideo VOD](https://vod.console.aliyun.com) console. In the left-side navigation pane, choose **Media Files*	- > **Audio/Video**. On the Video and Audio page, you can view the ID of the media asset. This method is applicable to files that are uploaded by using the ApsaraVideo VOD console.
	//
	// 	- Obtain the value of the VideoId parameter from the response to the [CreateUploadVideo](https://help.aliyun.com/document_detail/55407.html) operation that you call to upload media assets.
	//
	// 	- Obtain the value of the VideoId parameter from the response to the [SearchMedia](https://help.aliyun.com/document_detail/86044.html) operation that you call to query the media ID after the media asset is uploaded.
	//
	// This parameter is required.
	//
	// example:
	//
	// d56c2ac0cee271ed80004710b5ba****
	MediaIds *string `json:"MediaIds,omitempty" xml:"MediaIds,omitempty"`
	// The restoration priority. This parameter is required only when you restore a Cold Archive media asset. Valid values:
	//
	// 	- **Expedited**
	//
	// 	- **Standard**
	//
	// 	- **Bulk**
	//
	// example:
	//
	// Standard
	RestoreTier *string `json:"RestoreTier,omitempty" xml:"RestoreTier,omitempty"`
	// The modification range. Valid values:
	//
	// 	- **All**: modifies the storage classes of all resources including the source files and transcoded streams.
	//
	// 	- **SourceFile**: modifies the storage classes of only the source files. The storage class of other resources is Standard.
	//
	// example:
	//
	// All
	Scope *string `json:"Scope,omitempty" xml:"Scope,omitempty"`
	// The storage class. Valid values:
	//
	// 	- **Standard**
	//
	// 	- **IA**
	//
	// 	- **Archive**
	//
	// 	- **ColdArchive**
	//
	// This parameter is required.
	//
	// example:
	//
	// Archive
	StorageClass *string `json:"StorageClass,omitempty" xml:"StorageClass,omitempty"`
}

func (s UpdateMediaStorageClassRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateMediaStorageClassRequest) GoString() string {
	return s.String()
}

func (s *UpdateMediaStorageClassRequest) SetAllowUpdateWithoutTimeLimit(v bool) *UpdateMediaStorageClassRequest {
	s.AllowUpdateWithoutTimeLimit = &v
	return s
}

func (s *UpdateMediaStorageClassRequest) SetMediaIds(v string) *UpdateMediaStorageClassRequest {
	s.MediaIds = &v
	return s
}

func (s *UpdateMediaStorageClassRequest) SetRestoreTier(v string) *UpdateMediaStorageClassRequest {
	s.RestoreTier = &v
	return s
}

func (s *UpdateMediaStorageClassRequest) SetScope(v string) *UpdateMediaStorageClassRequest {
	s.Scope = &v
	return s
}

func (s *UpdateMediaStorageClassRequest) SetStorageClass(v string) *UpdateMediaStorageClassRequest {
	s.StorageClass = &v
	return s
}

type UpdateMediaStorageClassResponseBody struct {
	// The IDs of the media assets that failed to be processed.
	ForbiddenList *UpdateMediaStorageClassResponseBodyForbiddenList `json:"ForbiddenList,omitempty" xml:"ForbiddenList,omitempty" type:"Struct"`
	// The IDs of the media assets that failed to be obtained.
	IgnoredList *UpdateMediaStorageClassResponseBodyIgnoredList `json:"IgnoredList,omitempty" xml:"IgnoredList,omitempty" type:"Struct"`
	// The ID of the request.
	//
	// example:
	//
	// 30FA0B7C-3A81-5449-93CD-ACA149E6****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The state of the task. Valid values:
	//
	// 	- **Processing**
	//
	// 	- **Failed**
	//
	// example:
	//
	// Processing
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s UpdateMediaStorageClassResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateMediaStorageClassResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateMediaStorageClassResponseBody) SetForbiddenList(v *UpdateMediaStorageClassResponseBodyForbiddenList) *UpdateMediaStorageClassResponseBody {
	s.ForbiddenList = v
	return s
}

func (s *UpdateMediaStorageClassResponseBody) SetIgnoredList(v *UpdateMediaStorageClassResponseBodyIgnoredList) *UpdateMediaStorageClassResponseBody {
	s.IgnoredList = v
	return s
}

func (s *UpdateMediaStorageClassResponseBody) SetRequestId(v string) *UpdateMediaStorageClassResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateMediaStorageClassResponseBody) SetStatus(v string) *UpdateMediaStorageClassResponseBody {
	s.Status = &v
	return s
}

type UpdateMediaStorageClassResponseBodyForbiddenList struct {
	MediaForbiddenReasonDTO []*UpdateMediaStorageClassResponseBodyForbiddenListMediaForbiddenReasonDTO `json:"MediaForbiddenReasonDTO,omitempty" xml:"MediaForbiddenReasonDTO,omitempty" type:"Repeated"`
}

func (s UpdateMediaStorageClassResponseBodyForbiddenList) String() string {
	return tea.Prettify(s)
}

func (s UpdateMediaStorageClassResponseBodyForbiddenList) GoString() string {
	return s.String()
}

func (s *UpdateMediaStorageClassResponseBodyForbiddenList) SetMediaForbiddenReasonDTO(v []*UpdateMediaStorageClassResponseBodyForbiddenListMediaForbiddenReasonDTO) *UpdateMediaStorageClassResponseBodyForbiddenList {
	s.MediaForbiddenReasonDTO = v
	return s
}

type UpdateMediaStorageClassResponseBodyForbiddenListMediaForbiddenReasonDTO struct {
	// The ID of the media asset.
	//
	// example:
	//
	// 19e231ee6e3e417fbf2e92ec2680****
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The reason for the failure.
	//
	// example:
	//
	// TargetStorageClassInconsistent
	Reason *string `json:"Reason,omitempty" xml:"Reason,omitempty"`
}

func (s UpdateMediaStorageClassResponseBodyForbiddenListMediaForbiddenReasonDTO) String() string {
	return tea.Prettify(s)
}

func (s UpdateMediaStorageClassResponseBodyForbiddenListMediaForbiddenReasonDTO) GoString() string {
	return s.String()
}

func (s *UpdateMediaStorageClassResponseBodyForbiddenListMediaForbiddenReasonDTO) SetMediaId(v string) *UpdateMediaStorageClassResponseBodyForbiddenListMediaForbiddenReasonDTO {
	s.MediaId = &v
	return s
}

func (s *UpdateMediaStorageClassResponseBodyForbiddenListMediaForbiddenReasonDTO) SetReason(v string) *UpdateMediaStorageClassResponseBodyForbiddenListMediaForbiddenReasonDTO {
	s.Reason = &v
	return s
}

type UpdateMediaStorageClassResponseBodyIgnoredList struct {
	MediaId []*string `json:"MediaId,omitempty" xml:"MediaId,omitempty" type:"Repeated"`
}

func (s UpdateMediaStorageClassResponseBodyIgnoredList) String() string {
	return tea.Prettify(s)
}

func (s UpdateMediaStorageClassResponseBodyIgnoredList) GoString() string {
	return s.String()
}

func (s *UpdateMediaStorageClassResponseBodyIgnoredList) SetMediaId(v []*string) *UpdateMediaStorageClassResponseBodyIgnoredList {
	s.MediaId = v
	return s
}

type UpdateMediaStorageClassResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateMediaStorageClassResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateMediaStorageClassResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateMediaStorageClassResponse) GoString() string {
	return s.String()
}

func (s *UpdateMediaStorageClassResponse) SetHeaders(v map[string]*string) *UpdateMediaStorageClassResponse {
	s.Headers = v
	return s
}

func (s *UpdateMediaStorageClassResponse) SetStatusCode(v int32) *UpdateMediaStorageClassResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateMediaStorageClassResponse) SetBody(v *UpdateMediaStorageClassResponseBody) *UpdateMediaStorageClassResponse {
	s.Body = v
	return s
}

type UpdateTranscodeTemplateGroupRequest struct {
	// The lock status of the transcoding template group. Valid values:
	//
	// 	- **Enabled**: The transcoding template group is locked and cannot be modified.
	//
	// 	- **Disabled*	- (default): The transcoding template group is not locked.
	//
	// example:
	//
	// Disabled
	Locked *string `json:"Locked,omitempty" xml:"Locked,omitempty"`
	// The name of the transcoding template group.
	//
	// 	- The name cannot exceed 128 bytes.
	//
	// 	- The value must be encoded in UTF-8.
	//
	// example:
	//
	// transcodetemplate
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the transcoding template group.
	//
	// This parameter is required.
	//
	// example:
	//
	// 4c71a339fe*****52b4fa6f4527
	TranscodeTemplateGroupId *string `json:"TranscodeTemplateGroupId,omitempty" xml:"TranscodeTemplateGroupId,omitempty"`
	// The configurations of the transcoding template. The value must be a JSON string. For more information about the data structure, see [TranscodeTemplate](~~52839#title-9mb-8o2-uu6~~).
	//
	// example:
	//
	// [{"Video":{"Bitrate":"400","Codec":"H.264","Fps":"30"},"Audio":{"Codec":"AAC","Bitrate":"64","Definition":"SD","EncryptType":"Private","Container":{"Format":"m3u8"},"PackageType":"HLSPackage"}}]
	TranscodeTemplateList *string `json:"TranscodeTemplateList,omitempty" xml:"TranscodeTemplateList,omitempty"`
}

func (s UpdateTranscodeTemplateGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTranscodeTemplateGroupRequest) GoString() string {
	return s.String()
}

func (s *UpdateTranscodeTemplateGroupRequest) SetLocked(v string) *UpdateTranscodeTemplateGroupRequest {
	s.Locked = &v
	return s
}

func (s *UpdateTranscodeTemplateGroupRequest) SetName(v string) *UpdateTranscodeTemplateGroupRequest {
	s.Name = &v
	return s
}

func (s *UpdateTranscodeTemplateGroupRequest) SetTranscodeTemplateGroupId(v string) *UpdateTranscodeTemplateGroupRequest {
	s.TranscodeTemplateGroupId = &v
	return s
}

func (s *UpdateTranscodeTemplateGroupRequest) SetTranscodeTemplateList(v string) *UpdateTranscodeTemplateGroupRequest {
	s.TranscodeTemplateList = &v
	return s
}

type UpdateTranscodeTemplateGroupResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A*****F6-D7393642CA58
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the transcoding template group.
	//
	// example:
	//
	// 34e908aa4024a*****f7821c31f93a2a
	TranscodeTemplateGroupId *string `json:"TranscodeTemplateGroupId,omitempty" xml:"TranscodeTemplateGroupId,omitempty"`
}

func (s UpdateTranscodeTemplateGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTranscodeTemplateGroupResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTranscodeTemplateGroupResponseBody) SetRequestId(v string) *UpdateTranscodeTemplateGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateTranscodeTemplateGroupResponseBody) SetTranscodeTemplateGroupId(v string) *UpdateTranscodeTemplateGroupResponseBody {
	s.TranscodeTemplateGroupId = &v
	return s
}

type UpdateTranscodeTemplateGroupResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateTranscodeTemplateGroupResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateTranscodeTemplateGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTranscodeTemplateGroupResponse) GoString() string {
	return s.String()
}

func (s *UpdateTranscodeTemplateGroupResponse) SetHeaders(v map[string]*string) *UpdateTranscodeTemplateGroupResponse {
	s.Headers = v
	return s
}

func (s *UpdateTranscodeTemplateGroupResponse) SetStatusCode(v int32) *UpdateTranscodeTemplateGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTranscodeTemplateGroupResponse) SetBody(v *UpdateTranscodeTemplateGroupResponseBody) *UpdateTranscodeTemplateGroupResponse {
	s.Body = v
	return s
}

type UpdateVideoInfoRequest struct {
	// The category ID. You can use one of the following methods to obtain the ID:
	//
	// 	- Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Configuration Management*	- > **Media Management*	- > **Categories*	- to view the category ID of the media file.
	//
	// 	- View the value of the CateId parameter returned by the [AddCategory](https://help.aliyun.com/document_detail/56401.html) operation that you called to create a category.
	//
	// 	- View the value of the CateId parameter returned by the [GetCategories](https://help.aliyun.com/document_detail/56406.html) operation that you called to query a category.
	//
	// example:
	//
	// 384761111
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The URL of the audio/video thumbnail.
	//
	// example:
	//
	// https://example.aliyundoc.com/****.jpg
	CoverURL *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	// The description of the audio or video file.
	//
	// 	- The description can be up to 1,024 bytes in length.
	//
	// 	- The value is encoded in UTF-8.
	//
	// example:
	//
	// video description
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The tags of the media file.
	//
	// 	- Each tag can be up to 32 bytes in length. You can specify up to 16 tags.
	//
	// 	- Separate multiple tags with commas (,).
	//
	// 	- The value is encoded in UTF-8.
	//
	// example:
	//
	// tag1,tag2
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The title of the audio or video file.
	//
	// 	- The name cannot exceed 128 bytes.
	//
	// 	- The value is encoded in UTF-8.
	//
	// example:
	//
	// video title
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// Custom settings. This is a JSON string that supports message callbacks, upload acceleration, and other settings. For more information, please refer to [UserData](https://help.aliyun.com/document_detail/86952.html).
	//
	// example:
	//
	// {"MessageCallback":{"CallbackURL":"http://example.aliyundoc.com"},"Extend":{"localId":"*****","test":"www"}}
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
	// The ID of the audio or video file. Perform the following operations to obtain the storage address:
	//
	// 	- Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Media Files*	- > **Audio/Video**. On the Video and Audio page, view the ID of the audio or video file. This method is applicable to files that are uploaded by using the ApsaraVideo VOD console.
	//
	// 	- Obtain the value of VideoId from the response to the [CreateUploadVideo](https://help.aliyun.com/document_detail/55407.html) operation that you called to obtain the upload URL and credential.
	//
	// 	- View the value of the VideoId parameter returned by the [SearchMedia](https://help.aliyun.com/document_detail/86044.html) operation that you called to query media information after the audio or video file is uploaded.
	//
	// This parameter is required.
	//
	// example:
	//
	// 2deda93265312baf9b0ed810d****
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s UpdateVideoInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateVideoInfoRequest) GoString() string {
	return s.String()
}

func (s *UpdateVideoInfoRequest) SetCateId(v int64) *UpdateVideoInfoRequest {
	s.CateId = &v
	return s
}

func (s *UpdateVideoInfoRequest) SetCoverURL(v string) *UpdateVideoInfoRequest {
	s.CoverURL = &v
	return s
}

func (s *UpdateVideoInfoRequest) SetDescription(v string) *UpdateVideoInfoRequest {
	s.Description = &v
	return s
}

func (s *UpdateVideoInfoRequest) SetTags(v string) *UpdateVideoInfoRequest {
	s.Tags = &v
	return s
}

func (s *UpdateVideoInfoRequest) SetTitle(v string) *UpdateVideoInfoRequest {
	s.Title = &v
	return s
}

func (s *UpdateVideoInfoRequest) SetUserData(v string) *UpdateVideoInfoRequest {
	s.UserData = &v
	return s
}

func (s *UpdateVideoInfoRequest) SetVideoId(v string) *UpdateVideoInfoRequest {
	s.VideoId = &v
	return s
}

type UpdateVideoInfoResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 25818875-5F78-4AF6-D7393642CA58****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateVideoInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateVideoInfoResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateVideoInfoResponseBody) SetRequestId(v string) *UpdateVideoInfoResponseBody {
	s.RequestId = &v
	return s
}

type UpdateVideoInfoResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateVideoInfoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateVideoInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateVideoInfoResponse) GoString() string {
	return s.String()
}

func (s *UpdateVideoInfoResponse) SetHeaders(v map[string]*string) *UpdateVideoInfoResponse {
	s.Headers = v
	return s
}

func (s *UpdateVideoInfoResponse) SetStatusCode(v int32) *UpdateVideoInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateVideoInfoResponse) SetBody(v *UpdateVideoInfoResponseBody) *UpdateVideoInfoResponse {
	s.Body = v
	return s
}

type UpdateVideoInfosRequest struct {
	// The new information about audios or videos. You can modify the information about up to 20 audios or videos at a time. Separate multiple audios or videos with commas (,). When you modify the information exceed 20 audios or videos at a time, the update will fail with an error code **CountExceededMax**.
	//
	// The value is a JSON string. For more information, see the **UpdateContent*	- section of this topic.
	//
	// This parameter is required.
	//
	// example:
	//
	// [{"VideoId":"f45cf4eba5cb90233389558c39****","Title":"test title1"},{"VideoId":"f45cf4eba5c84233389558c36****","Title":"test title2"}]
	UpdateContent *string `json:"UpdateContent,omitempty" xml:"UpdateContent,omitempty"`
}

func (s UpdateVideoInfosRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateVideoInfosRequest) GoString() string {
	return s.String()
}

func (s *UpdateVideoInfosRequest) SetUpdateContent(v string) *UpdateVideoInfosRequest {
	s.UpdateContent = &v
	return s
}

type UpdateVideoInfosResponseBody struct {
	// The IDs of the videos that cannot be modified. Generally, videos cannot be modified if you do not have required [permissions](https://help.aliyun.com/document_detail/113600.html).
	ForbiddenVideoIds []*string `json:"ForbiddenVideoIds,omitempty" xml:"ForbiddenVideoIds,omitempty" type:"Repeated"`
	// The IDs of the videos that do not exist.
	NonExistVideoIds []*string `json:"NonExistVideoIds,omitempty" xml:"NonExistVideoIds,omitempty" type:"Repeated"`
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4AF6-D7393642CA58****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateVideoInfosResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateVideoInfosResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateVideoInfosResponseBody) SetForbiddenVideoIds(v []*string) *UpdateVideoInfosResponseBody {
	s.ForbiddenVideoIds = v
	return s
}

func (s *UpdateVideoInfosResponseBody) SetNonExistVideoIds(v []*string) *UpdateVideoInfosResponseBody {
	s.NonExistVideoIds = v
	return s
}

func (s *UpdateVideoInfosResponseBody) SetRequestId(v string) *UpdateVideoInfosResponseBody {
	s.RequestId = &v
	return s
}

type UpdateVideoInfosResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateVideoInfosResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateVideoInfosResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateVideoInfosResponse) GoString() string {
	return s.String()
}

func (s *UpdateVideoInfosResponse) SetHeaders(v map[string]*string) *UpdateVideoInfosResponse {
	s.Headers = v
	return s
}

func (s *UpdateVideoInfosResponse) SetStatusCode(v int32) *UpdateVideoInfosResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateVideoInfosResponse) SetBody(v *UpdateVideoInfosResponseBody) *UpdateVideoInfosResponse {
	s.Body = v
	return s
}

type UpdateVodDomainRequest struct {
	// The domain name.
	//
	// This parameter is required.
	//
	// example:
	//
	// example.com
	DomainName    *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The information about the addresses of origin servers.
	//
	// example:
	//
	// [{"content":"1.1.1.1","type":"ipaddr","priority":"20","port":80}]
	Sources *string `json:"Sources,omitempty" xml:"Sources,omitempty"`
	// The top-level domain.
	//
	// example:
	//
	// example.com
	TopLevelDomain *string `json:"TopLevelDomain,omitempty" xml:"TopLevelDomain,omitempty"`
}

func (s UpdateVodDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateVodDomainRequest) GoString() string {
	return s.String()
}

func (s *UpdateVodDomainRequest) SetDomainName(v string) *UpdateVodDomainRequest {
	s.DomainName = &v
	return s
}

func (s *UpdateVodDomainRequest) SetOwnerId(v int64) *UpdateVodDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdateVodDomainRequest) SetSecurityToken(v string) *UpdateVodDomainRequest {
	s.SecurityToken = &v
	return s
}

func (s *UpdateVodDomainRequest) SetSources(v string) *UpdateVodDomainRequest {
	s.Sources = &v
	return s
}

func (s *UpdateVodDomainRequest) SetTopLevelDomain(v string) *UpdateVodDomainRequest {
	s.TopLevelDomain = &v
	return s
}

type UpdateVodDomainResponseBody struct {
	// The request ID.
	//
	// example:
	//
	// 15C66C7B-671A-4297-****-2C4477247A74
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateVodDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateVodDomainResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateVodDomainResponseBody) SetRequestId(v string) *UpdateVodDomainResponseBody {
	s.RequestId = &v
	return s
}

type UpdateVodDomainResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateVodDomainResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateVodDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateVodDomainResponse) GoString() string {
	return s.String()
}

func (s *UpdateVodDomainResponse) SetHeaders(v map[string]*string) *UpdateVodDomainResponse {
	s.Headers = v
	return s
}

func (s *UpdateVodDomainResponse) SetStatusCode(v int32) *UpdateVodDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateVodDomainResponse) SetBody(v *UpdateVodDomainResponseBody) *UpdateVodDomainResponse {
	s.Body = v
	return s
}

type UpdateVodTemplateRequest struct {
	// The name of the template.
	//
	// 	- The name can be up to 128 bytes in length.
	//
	// 	- The value must be encoded in UTF-8.
	//
	// example:
	//
	// test
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The configurations of the snapshot template. The value is a JSON-formatted string. For more information about the data structure, see the "SnapshotTemplateConfig" section of the [Media processing parameters](https://help.aliyun.com/document_detail/98618.html) topic.
	//
	// example:
	//
	// {"SnapshotConfig":{"Count":10,"SpecifiedOffsetTime":0,"Interval":1}
	TemplateConfig *string `json:"TemplateConfig,omitempty" xml:"TemplateConfig,omitempty"`
	// The ID of the snapshot template.
	//
	// This parameter is required.
	//
	// example:
	//
	// 8c75a02e339b*****0b0d2c48171a22
	VodTemplateId *string `json:"VodTemplateId,omitempty" xml:"VodTemplateId,omitempty"`
}

func (s UpdateVodTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateVodTemplateRequest) GoString() string {
	return s.String()
}

func (s *UpdateVodTemplateRequest) SetName(v string) *UpdateVodTemplateRequest {
	s.Name = &v
	return s
}

func (s *UpdateVodTemplateRequest) SetTemplateConfig(v string) *UpdateVodTemplateRequest {
	s.TemplateConfig = &v
	return s
}

func (s *UpdateVodTemplateRequest) SetVodTemplateId(v string) *UpdateVodTemplateRequest {
	s.VodTemplateId = &v
	return s
}

type UpdateVodTemplateResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A*****F6-D7393642CA58
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the snapshot template.
	//
	// example:
	//
	// 8c75a02e339b*****0b0d2c48171a22
	VodTemplateId *string `json:"VodTemplateId,omitempty" xml:"VodTemplateId,omitempty"`
}

func (s UpdateVodTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateVodTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateVodTemplateResponseBody) SetRequestId(v string) *UpdateVodTemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateVodTemplateResponseBody) SetVodTemplateId(v string) *UpdateVodTemplateResponseBody {
	s.VodTemplateId = &v
	return s
}

type UpdateVodTemplateResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateVodTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateVodTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateVodTemplateResponse) GoString() string {
	return s.String()
}

func (s *UpdateVodTemplateResponse) SetHeaders(v map[string]*string) *UpdateVodTemplateResponse {
	s.Headers = v
	return s
}

func (s *UpdateVodTemplateResponse) SetStatusCode(v int32) *UpdateVodTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateVodTemplateResponse) SetBody(v *UpdateVodTemplateResponseBody) *UpdateVodTemplateResponse {
	s.Body = v
	return s
}

type UpdateWatermarkRequest struct {
	// The name of the watermark template to which you want to change.
	//
	// 	- Only letters and digits are supported.
	//
	// 	- The name cannot exceed 128 bytes.
	//
	// 	- The value must be encoded in UTF-8.
	//
	// example:
	//
	// test
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The configuration information of the watermark such as the display position and special effects. The value must be a JSON string. The configuration parameters for image and text watermarks are different. For more information about the parameter structure, see [WatermarkConfig](~~98618#section-h01-44s-2lr~~).
	//
	// This parameter is required.
	//
	// example:
	//
	// {"Width":"55","Height":"55","Dx":"9","Dy":"9","ReferPos":"BottonLeft","Type":"Image"}
	WatermarkConfig *string `json:"WatermarkConfig,omitempty" xml:"WatermarkConfig,omitempty"`
	// The ID of the watermark template. You can specify only one watermark template ID. You can obtain the ID by using one of the following methods:
	//
	// 	- Obtain the watermark template ID from the response to the [AddWatermark](~~AddWatermark~~) operation that you call to create a watermark template.
	//
	// 	- Obtain the watermark template ID from the response to the [ListWatermark](~~ListWatermark~~) operation that you call to query all watermark templates within your account.
	//
	// This parameter is required.
	//
	// example:
	//
	// af2afe4761992c*****bd947dae97337
	WatermarkId *string `json:"WatermarkId,omitempty" xml:"WatermarkId,omitempty"`
}

func (s UpdateWatermarkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateWatermarkRequest) GoString() string {
	return s.String()
}

func (s *UpdateWatermarkRequest) SetName(v string) *UpdateWatermarkRequest {
	s.Name = &v
	return s
}

func (s *UpdateWatermarkRequest) SetWatermarkConfig(v string) *UpdateWatermarkRequest {
	s.WatermarkConfig = &v
	return s
}

func (s *UpdateWatermarkRequest) SetWatermarkId(v string) *UpdateWatermarkRequest {
	s.WatermarkId = &v
	return s
}

type UpdateWatermarkResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4A*****F6-D7393642CA58
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the watermark template.
	WatermarkInfo *UpdateWatermarkResponseBodyWatermarkInfo `json:"WatermarkInfo,omitempty" xml:"WatermarkInfo,omitempty" type:"Struct"`
}

func (s UpdateWatermarkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateWatermarkResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateWatermarkResponseBody) SetRequestId(v string) *UpdateWatermarkResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateWatermarkResponseBody) SetWatermarkInfo(v *UpdateWatermarkResponseBodyWatermarkInfo) *UpdateWatermarkResponseBody {
	s.WatermarkInfo = v
	return s
}

type UpdateWatermarkResponseBodyWatermarkInfo struct {
	// The time when the watermark template was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	//
	// example:
	//
	// 2018-11-06T08:03:17Z
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The URL of the watermark file. The URL is an Object Storage Service (OSS) URL or an Alibaba Cloud CDN URL.
	//
	// >  This parameter is returned only for image watermark templates.
	//
	// example:
	//
	// https://outin-32****9f4b3e7.oss-cn-shanghai.aliyuncs.com/image/cover/E6C3448CC8B715E6F8A72EC6B-6-2.png?Expires=1541600583&OSSAccessKeyId=****&Signature=gmf1eYMoDVg%2BHQCb4UGozBW****
	FileUrl *string `json:"FileUrl,omitempty" xml:"FileUrl,omitempty"`
	// Indicates whether the watermark template is the default one.
	//
	// 	- **Default**
	//
	// 	- **NotDefault**
	//
	// example:
	//
	// NotDefault
	IsDefault *string `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	// The name of the watermark template.
	//
	// example:
	//
	// image watermark test
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of the watermark template.
	//
	// 	- **Image**: image watermark template
	//
	// 	- **Text**: text watermark template
	//
	// example:
	//
	// Text
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The configuration information of the watermark such as the display position and special effects. The value is a JSON string. The configuration parameters for image and text watermarks are different. For more information about the parameter structure, see [WatermarkConfig](~~98618#section-h01-44s-2lr~~).
	//
	// example:
	//
	// {"Width":"55","Height":"55","Dx":"9","Dy":"9","ReferPos":"BottonLeft","Type":"Image"}
	WatermarkConfig *string `json:"WatermarkConfig,omitempty" xml:"WatermarkConfig,omitempty"`
	// The ID of the watermark template.
	//
	// example:
	//
	// 505e2e287ea*****ecfddd386d384
	WatermarkId *string `json:"WatermarkId,omitempty" xml:"WatermarkId,omitempty"`
}

func (s UpdateWatermarkResponseBodyWatermarkInfo) String() string {
	return tea.Prettify(s)
}

func (s UpdateWatermarkResponseBodyWatermarkInfo) GoString() string {
	return s.String()
}

func (s *UpdateWatermarkResponseBodyWatermarkInfo) SetCreationTime(v string) *UpdateWatermarkResponseBodyWatermarkInfo {
	s.CreationTime = &v
	return s
}

func (s *UpdateWatermarkResponseBodyWatermarkInfo) SetFileUrl(v string) *UpdateWatermarkResponseBodyWatermarkInfo {
	s.FileUrl = &v
	return s
}

func (s *UpdateWatermarkResponseBodyWatermarkInfo) SetIsDefault(v string) *UpdateWatermarkResponseBodyWatermarkInfo {
	s.IsDefault = &v
	return s
}

func (s *UpdateWatermarkResponseBodyWatermarkInfo) SetName(v string) *UpdateWatermarkResponseBodyWatermarkInfo {
	s.Name = &v
	return s
}

func (s *UpdateWatermarkResponseBodyWatermarkInfo) SetType(v string) *UpdateWatermarkResponseBodyWatermarkInfo {
	s.Type = &v
	return s
}

func (s *UpdateWatermarkResponseBodyWatermarkInfo) SetWatermarkConfig(v string) *UpdateWatermarkResponseBodyWatermarkInfo {
	s.WatermarkConfig = &v
	return s
}

func (s *UpdateWatermarkResponseBodyWatermarkInfo) SetWatermarkId(v string) *UpdateWatermarkResponseBodyWatermarkInfo {
	s.WatermarkId = &v
	return s
}

type UpdateWatermarkResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateWatermarkResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateWatermarkResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateWatermarkResponse) GoString() string {
	return s.String()
}

func (s *UpdateWatermarkResponse) SetHeaders(v map[string]*string) *UpdateWatermarkResponse {
	s.Headers = v
	return s
}

func (s *UpdateWatermarkResponse) SetStatusCode(v int32) *UpdateWatermarkResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateWatermarkResponse) SetBody(v *UpdateWatermarkResponseBody) *UpdateWatermarkResponse {
	s.Body = v
	return s
}

type UploadMediaByURLRequest struct {
	// The ID of the application. Default value: **app-1000000**. For more information, see [Overview](https://help.aliyun.com/document_detail/113600.html).
	//
	// example:
	//
	// app-****
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The custom identifier for deduplication. If you specify this parameter and send a request, an error is returned if a request with the same identifier was sent in the last 10 minutes. A custom identifier can be up to 50 characters in length and can contain letters, digits, hyphens (-), and underscores (_). If you do not specify this parameter or leave this parameter empty, duplicate requests are not filtered.
	//
	// example:
	//
	// 5c62d40299034bbaa4c195da330****
	SessionId *string `json:"SessionId,omitempty" xml:"SessionId,omitempty"`
	// The storage address of the media file.
	//
	// To view the storage address, log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com/?spm=a2c4g.11186623.2.15.6948257eaZ4m54#/vod/settings/censored). In the left-side navigation pane, choose **Configuration Management*	- > **Media Management*	- > **Storage**. If you do not specify a storage address, the default storage address is used.
	//
	// example:
	//
	// outin-bfefbb90a47c******163e1c7426.oss-cn-shanghai.aliyuncs.com
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	// The ID of the transcoding template group. You can use one of the following methods to obtain the ID of the transcoding template group:
	//
	// 	- Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Configuration Management*	- > **Media Processing*	- > **Transcoding Template Groups**. On the Transcoding Template Groups page, view the ID of the transcoding template group.
	//
	// 	- Obtain the value of TranscodeTemplateGroupId from the response to the [AddTranscodeTemplateGroup](https://help.aliyun.com/document_detail/102665.html) operation.
	//
	// 	- Obtain the value of TranscodeTemplateGroupId from the response to the [ListTranscodeTemplateGroup](https://help.aliyun.com/document_detail/102669.html) operation.
	//
	// >-   If you leave this parameter empty, the default transcoding template group is used for transcoding. If you specify this parameter, the specified transcoding template group is used for transcoding.
	//
	// >-   You can also specify the ID of the transcoding template group in `UploadMetadatas`. If you specify this parameter and TemplateGroupId in UploadMetadatas, the TemplateGroupId in UploadMetadatas takes effect.
	//
	// example:
	//
	// ca3a8f6e4957b65806709586****
	TemplateGroupId *string `json:"TemplateGroupId,omitempty" xml:"TemplateGroupId,omitempty"`
	// The metadata of the media file that you want to upload. The value must be a JSON string.
	//
	// 	- This parameter takes effect only if SourceURL matches the URL that you specified for UploadURLs.
	//
	// 	- You must convert the JSON-formatted data such as `[UploadMetadata, UploadMetadata,…]` to a JSON string.
	//
	// 	- For more information, see the **UploadMetadata*	- table.
	//
	// example:
	//
	// [{"SourceURL":"https://example.aliyundoc.com/video01.mp4","Title":"urlUploadTest"}]
	UploadMetadatas *string `json:"UploadMetadatas,omitempty" xml:"UploadMetadatas,omitempty"`
	// The URL of the media file.
	//
	// 	- You must include a file name extension in the URL, such as `https://****.mp4`.
	//
	//     	- If the URL does not contain a file name extension, specify a file name extension for `FileExtension` in `UploadMetadatas`.
	//
	//     	- If you specify `FileExtension` when the URL contains a file name extension, the file name extension that you specified for `FileExtension` takes effect.
	//
	//     	- For more information about file name extensions supported by ApsaraVideo VOD, see [Overview](https://help.aliyun.com/document_detail/55396.html).
	//
	// 	- URL encoding is required. Separate multiple URLs with commas (,). You can specify a maximum of 20 URLs.
	//
	// 	- Special characters may cause upload failures. You must encode URLs before you separate them with commas (,).
	//
	// This parameter is required.
	//
	// example:
	//
	// https://****.mp4
	UploadURLs *string `json:"UploadURLs,omitempty" xml:"UploadURLs,omitempty"`
	// The custom configurations such as callback configurations and upload acceleration configurations. The value must be a JSON string. For more information, see [Request parameters](~~86952#UserData~~).
	//
	// >-   The callback configurations take effect only after you specify the HTTP callback URL and select specific callback events in the ApsaraVideo VOD console. For more information about how to configure HTTP callback settings in the ApsaraVideo VOD console, see [Configure callback settings](https://help.aliyun.com/document_detail/86071.html).
	//
	// >-   If you want to enable the upload acceleration feature, [submit a request on Yida](https://yida.alibaba-inc.com/o/ticketapply). For more information, see [Overview](https://help.aliyun.com/document_detail/55396.html).
	//
	// example:
	//
	// {"MessageCallback":{"CallbackURL":"http://example.aliyundoc.com"},"Extend":{"localId":"xxx","test":"www"}}
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
	// The ID of the workflow. To view the ID of the workflow, log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Configuration Management*	- > **Media Processing*	- > **Workflows**.
	//
	// > If you specify WorkflowId and TemplateGroupId, the value of WorkflowId takes effect. For more information, see [Workflows](https://help.aliyun.com/document_detail/115347.html).
	//
	// example:
	//
	// e1e243b42548248197d6f74f9****
	WorkflowId *string `json:"WorkflowId,omitempty" xml:"WorkflowId,omitempty"`
}

func (s UploadMediaByURLRequest) String() string {
	return tea.Prettify(s)
}

func (s UploadMediaByURLRequest) GoString() string {
	return s.String()
}

func (s *UploadMediaByURLRequest) SetAppId(v string) *UploadMediaByURLRequest {
	s.AppId = &v
	return s
}

func (s *UploadMediaByURLRequest) SetSessionId(v string) *UploadMediaByURLRequest {
	s.SessionId = &v
	return s
}

func (s *UploadMediaByURLRequest) SetStorageLocation(v string) *UploadMediaByURLRequest {
	s.StorageLocation = &v
	return s
}

func (s *UploadMediaByURLRequest) SetTemplateGroupId(v string) *UploadMediaByURLRequest {
	s.TemplateGroupId = &v
	return s
}

func (s *UploadMediaByURLRequest) SetUploadMetadatas(v string) *UploadMediaByURLRequest {
	s.UploadMetadatas = &v
	return s
}

func (s *UploadMediaByURLRequest) SetUploadURLs(v string) *UploadMediaByURLRequest {
	s.UploadURLs = &v
	return s
}

func (s *UploadMediaByURLRequest) SetUserData(v string) *UploadMediaByURLRequest {
	s.UserData = &v
	return s
}

func (s *UploadMediaByURLRequest) SetWorkflowId(v string) *UploadMediaByURLRequest {
	s.WorkflowId = &v
	return s
}

type UploadMediaByURLResponseBody struct {
	// The ID of the request.
	//
	// example:
	//
	// 25818875-5F78-4AF6-D7393642CA58****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the upload job.
	UploadJobs []*UploadMediaByURLResponseBodyUploadJobs `json:"UploadJobs,omitempty" xml:"UploadJobs,omitempty" type:"Repeated"`
}

func (s UploadMediaByURLResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UploadMediaByURLResponseBody) GoString() string {
	return s.String()
}

func (s *UploadMediaByURLResponseBody) SetRequestId(v string) *UploadMediaByURLResponseBody {
	s.RequestId = &v
	return s
}

func (s *UploadMediaByURLResponseBody) SetUploadJobs(v []*UploadMediaByURLResponseBodyUploadJobs) *UploadMediaByURLResponseBody {
	s.UploadJobs = v
	return s
}

type UploadMediaByURLResponseBodyUploadJobs struct {
	// The ID of the upload job.
	//
	// example:
	//
	// ad90a501b1b94fb72374ad005046****
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The URL of the source file that is uploaded in the upload job.
	//
	// example:
	//
	// http://example****.mp4
	SourceURL *string `json:"SourceURL,omitempty" xml:"SourceURL,omitempty"`
}

func (s UploadMediaByURLResponseBodyUploadJobs) String() string {
	return tea.Prettify(s)
}

func (s UploadMediaByURLResponseBodyUploadJobs) GoString() string {
	return s.String()
}

func (s *UploadMediaByURLResponseBodyUploadJobs) SetJobId(v string) *UploadMediaByURLResponseBodyUploadJobs {
	s.JobId = &v
	return s
}

func (s *UploadMediaByURLResponseBodyUploadJobs) SetSourceURL(v string) *UploadMediaByURLResponseBodyUploadJobs {
	s.SourceURL = &v
	return s
}

type UploadMediaByURLResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UploadMediaByURLResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UploadMediaByURLResponse) String() string {
	return tea.Prettify(s)
}

func (s UploadMediaByURLResponse) GoString() string {
	return s.String()
}

func (s *UploadMediaByURLResponse) SetHeaders(v map[string]*string) *UploadMediaByURLResponse {
	s.Headers = v
	return s
}

func (s *UploadMediaByURLResponse) SetStatusCode(v int32) *UploadMediaByURLResponse {
	s.StatusCode = &v
	return s
}

func (s *UploadMediaByURLResponse) SetBody(v *UploadMediaByURLResponseBody) *UploadMediaByURLResponse {
	s.Body = v
	return s
}

type UploadStreamByURLRequest struct {
	// The quality of the video stream.
	//
	// For more information about valid values of this parameter, see [Parameters for media assets](https://help.aliyun.com/document_detail/124671.html).
	//
	// This parameter is required.
	//
	// example:
	//
	// HD
	Definition *string `json:"Definition,omitempty" xml:"Definition,omitempty"`
	// The file name extension of the transcoded stream.
	//
	// For more information, see the Supported media file formats section in [Overview](https://help.aliyun.com/document_detail/55396.html).
	//
	// If you set a value for this parameter, the file name extension specified in StreamURL is overwritten.
	//
	// >  This parameter is required if you do not specify a file name extension in StreamURL.
	//
	// example:
	//
	// mp4
	FileExtension *string `json:"FileExtension,omitempty" xml:"FileExtension,omitempty"`
	// The HDR type of the transcoded stream. Valid values:
	//
	// 	- HDR
	//
	// 	- HDR10
	//
	// 	- HLG
	//
	// 	- DolbyVision
	//
	// 	- HDRVivid
	//
	// 	- SDR+
	//
	// >
	//
	// 	- The HDR type of the transcoded stream is not case-sensitive.
	//
	// 	- You can leave this parameter empty for non-HDR streams.
	//
	// example:
	//
	// HDR10
	HDRType *string `json:"HDRType,omitempty" xml:"HDRType,omitempty"`
	// The media ID in ApsaraVideo VOD.
	//
	// This parameter is required.
	//
	// example:
	//
	// ca3a8f6e49*****57b65806709586
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The URL of the transcoded stream.
	//
	// If URL authentication is required, you must pass authentication information in this parameter and make sure that the URL can be accessed over the Internet.
	//
	// This parameter is required.
	//
	// example:
	//
	// https://example.com/lesson-01.mp4
	StreamURL *string `json:"StreamURL,omitempty" xml:"StreamURL,omitempty"`
	// Metadata information for uploading media files, in JSON string format.
	//
	// For more information, please refer to the table below for UploadMetadata.
	//
	// example:
	//
	// {"AddressMapping":"1","CustomPath":"test/xxx","CustomFileName":"xxx.mp4","isOverwritePath":"0"}
	UploadMetadata *string `json:"UploadMetadata,omitempty" xml:"UploadMetadata,omitempty"`
	// The user-defined parameter. For more information, see the "UserData: specifies the custom configurations for media upload" section of the [Request parameters](https://help.aliyun.com/document_detail/86952.html) topic.
	//
	// >  The callback configurations you specify for this parameter take effect only after you specify the HTTP callback URL and select specific callback events in the ApsaraVideo VOD console. For more information about how to configure HTTP callback settings in the ApsaraVideo VOD console, see [Configure callback settings](https://help.aliyun.com/document_detail/86071.html).
	//
	// example:
	//
	// {"MessageCallback":{"CallbackURL":"http://aliyundoc.com"}, "Extend":{"localId":"xxx","test":"www"}}
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
}

func (s UploadStreamByURLRequest) String() string {
	return tea.Prettify(s)
}

func (s UploadStreamByURLRequest) GoString() string {
	return s.String()
}

func (s *UploadStreamByURLRequest) SetDefinition(v string) *UploadStreamByURLRequest {
	s.Definition = &v
	return s
}

func (s *UploadStreamByURLRequest) SetFileExtension(v string) *UploadStreamByURLRequest {
	s.FileExtension = &v
	return s
}

func (s *UploadStreamByURLRequest) SetHDRType(v string) *UploadStreamByURLRequest {
	s.HDRType = &v
	return s
}

func (s *UploadStreamByURLRequest) SetMediaId(v string) *UploadStreamByURLRequest {
	s.MediaId = &v
	return s
}

func (s *UploadStreamByURLRequest) SetStreamURL(v string) *UploadStreamByURLRequest {
	s.StreamURL = &v
	return s
}

func (s *UploadStreamByURLRequest) SetUploadMetadata(v string) *UploadStreamByURLRequest {
	s.UploadMetadata = &v
	return s
}

func (s *UploadStreamByURLRequest) SetUserData(v string) *UploadStreamByURLRequest {
	s.UserData = &v
	return s
}

type UploadStreamByURLResponseBody struct {
	// The URL of the OSS object.
	//
	// example:
	//
	// http://outin-31059bcee7810a200163e1c8dba****.oss-cn-shanghai.aliyuncs.com/lesson-01.mp4
	FileURL *string `json:"FileURL,omitempty" xml:"FileURL,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// 7AE96389-DF1E-598D-816B-7B40F13B4620
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The URL of the input stream. This parameter is used when you call the [GetURLUploadInfos](https://help.aliyun.com/document_detail/106830.html) operation.
	//
	// example:
	//
	// https://example.com/lesson-01.mp4
	SourceURL *string `json:"SourceURL,omitempty" xml:"SourceURL,omitempty"`
	// The ID of the stream upload job. This parameter is used when you call the [GetURLUploadInfos](https://help.aliyun.com/document_detail/106830.html) operation.
	//
	// In ApsaraVideo VOD, you can upload only one transcoded stream in an upload job. For more information, see the PlayInfo: the playback information about a video stream section in [Basic structures](https://help.aliyun.com/document_detail/52839.html).
	//
	// example:
	//
	// e304b34fb3d959f92baef97b6496****
	StreamJobId *string `json:"StreamJobId,omitempty" xml:"StreamJobId,omitempty"`
}

func (s UploadStreamByURLResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UploadStreamByURLResponseBody) GoString() string {
	return s.String()
}

func (s *UploadStreamByURLResponseBody) SetFileURL(v string) *UploadStreamByURLResponseBody {
	s.FileURL = &v
	return s
}

func (s *UploadStreamByURLResponseBody) SetRequestId(v string) *UploadStreamByURLResponseBody {
	s.RequestId = &v
	return s
}

func (s *UploadStreamByURLResponseBody) SetSourceURL(v string) *UploadStreamByURLResponseBody {
	s.SourceURL = &v
	return s
}

func (s *UploadStreamByURLResponseBody) SetStreamJobId(v string) *UploadStreamByURLResponseBody {
	s.StreamJobId = &v
	return s
}

type UploadStreamByURLResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UploadStreamByURLResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UploadStreamByURLResponse) String() string {
	return tea.Prettify(s)
}

func (s UploadStreamByURLResponse) GoString() string {
	return s.String()
}

func (s *UploadStreamByURLResponse) SetHeaders(v map[string]*string) *UploadStreamByURLResponse {
	s.Headers = v
	return s
}

func (s *UploadStreamByURLResponse) SetStatusCode(v int32) *UploadStreamByURLResponse {
	s.StatusCode = &v
	return s
}

func (s *UploadStreamByURLResponse) SetBody(v *UploadStreamByURLResponseBody) *UploadStreamByURLResponse {
	s.Body = v
	return s
}

type VerifyVodDomainOwnerRequest struct {
	// The domain name of which you want to verify the ownership. You can specify only one domain name in each call.
	//
	// This parameter is required.
	//
	// example:
	//
	// example.com
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId    *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The verification method. Valid values:
	//
	// 	- **dnsCheck**: uses a Domain Name System (DNS) record
	//
	// 	- **fileCheck**: uses a verification file
	//
	// This parameter is required.
	//
	// example:
	//
	// dnsCheck
	VerifyType *string `json:"VerifyType,omitempty" xml:"VerifyType,omitempty"`
}

func (s VerifyVodDomainOwnerRequest) String() string {
	return tea.Prettify(s)
}

func (s VerifyVodDomainOwnerRequest) GoString() string {
	return s.String()
}

func (s *VerifyVodDomainOwnerRequest) SetDomainName(v string) *VerifyVodDomainOwnerRequest {
	s.DomainName = &v
	return s
}

func (s *VerifyVodDomainOwnerRequest) SetOwnerId(v int64) *VerifyVodDomainOwnerRequest {
	s.OwnerId = &v
	return s
}

func (s *VerifyVodDomainOwnerRequest) SetVerifyType(v string) *VerifyVodDomainOwnerRequest {
	s.VerifyType = &v
	return s
}

type VerifyVodDomainOwnerResponseBody struct {
	// The verification content.
	//
	// example:
	//
	// verify_dffeb661*********a59c32cd91f
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the request.
	//
	// example:
	//
	// E4EBD2BF-5EB0-4476-8829-9D94E1B1****
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s VerifyVodDomainOwnerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s VerifyVodDomainOwnerResponseBody) GoString() string {
	return s.String()
}

func (s *VerifyVodDomainOwnerResponseBody) SetContent(v string) *VerifyVodDomainOwnerResponseBody {
	s.Content = &v
	return s
}

func (s *VerifyVodDomainOwnerResponseBody) SetRequestId(v string) *VerifyVodDomainOwnerResponseBody {
	s.RequestId = &v
	return s
}

type VerifyVodDomainOwnerResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *VerifyVodDomainOwnerResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s VerifyVodDomainOwnerResponse) String() string {
	return tea.Prettify(s)
}

func (s VerifyVodDomainOwnerResponse) GoString() string {
	return s.String()
}

func (s *VerifyVodDomainOwnerResponse) SetHeaders(v map[string]*string) *VerifyVodDomainOwnerResponse {
	s.Headers = v
	return s
}

func (s *VerifyVodDomainOwnerResponse) SetStatusCode(v int32) *VerifyVodDomainOwnerResponse {
	s.StatusCode = &v
	return s
}

func (s *VerifyVodDomainOwnerResponse) SetBody(v *VerifyVodDomainOwnerResponseBody) *VerifyVodDomainOwnerResponse {
	s.Body = v
	return s
}

type Client struct {
	openapi.Client
}

func NewClient(config *openapi.Config) (*Client, error) {
	client := new(Client)
	err := client.Init(config)
	return client, err
}

func (client *Client) Init(config *openapi.Config) (_err error) {
	_err = client.Client.Init(config)
	if _err != nil {
		return _err
	}
	client.SignatureAlgorithm = tea.String("v2")
	client.EndpointRule = tea.String("regional")
	client.EndpointMap = map[string]*string{
		"cn-hangzhou":                 tea.String("vod.cn-shanghai.aliyuncs.com"),
		"ap-northeast-2-pop":          tea.String("vod.aliyuncs.com"),
		"ap-southeast-2":              tea.String("vod.aliyuncs.com"),
		"ap-southeast-3":              tea.String("vod.aliyuncs.com"),
		"cn-beijing-finance-1":        tea.String("vod.aliyuncs.com"),
		"cn-beijing-finance-pop":      tea.String("vod.aliyuncs.com"),
		"cn-beijing-gov-1":            tea.String("vod.aliyuncs.com"),
		"cn-beijing-nu16-b01":         tea.String("vod.aliyuncs.com"),
		"cn-chengdu":                  tea.String("vod.aliyuncs.com"),
		"cn-edge-1":                   tea.String("vod.aliyuncs.com"),
		"cn-fujian":                   tea.String("vod.aliyuncs.com"),
		"cn-haidian-cm12-c01":         tea.String("vod.aliyuncs.com"),
		"cn-hangzhou-bj-b01":          tea.String("vod.aliyuncs.com"),
		"cn-hangzhou-finance":         tea.String("vod.aliyuncs.com"),
		"cn-hangzhou-internal-prod-1": tea.String("vod.aliyuncs.com"),
		"cn-hangzhou-internal-test-1": tea.String("vod.aliyuncs.com"),
		"cn-hangzhou-internal-test-2": tea.String("vod.aliyuncs.com"),
		"cn-hangzhou-internal-test-3": tea.String("vod.aliyuncs.com"),
		"cn-hangzhou-test-306":        tea.String("vod.aliyuncs.com"),
		"cn-hongkong-finance-pop":     tea.String("vod.aliyuncs.com"),
		"cn-huhehaote":                tea.String("vod.aliyuncs.com"),
		"cn-huhehaote-nebula-1":       tea.String("vod.aliyuncs.com"),
		"cn-qingdao":                  tea.String("vod.aliyuncs.com"),
		"cn-qingdao-nebula":           tea.String("vod.aliyuncs.com"),
		"cn-shanghai-et15-b01":        tea.String("vod.aliyuncs.com"),
		"cn-shanghai-et2-b01":         tea.String("vod.aliyuncs.com"),
		"cn-shanghai-finance-1":       tea.String("vod.aliyuncs.com"),
		"cn-shanghai-inner":           tea.String("vod.aliyuncs.com"),
		"cn-shanghai-internal-test-1": tea.String("vod.aliyuncs.com"),
		"cn-shenzhen-finance-1":       tea.String("vod.aliyuncs.com"),
		"cn-shenzhen-inner":           tea.String("vod.aliyuncs.com"),
		"cn-shenzhen-st4-d01":         tea.String("vod.aliyuncs.com"),
		"cn-shenzhen-su18-b01":        tea.String("vod.aliyuncs.com"),
		"cn-wuhan":                    tea.String("vod.aliyuncs.com"),
		"cn-wulanchabu":               tea.String("vod.aliyuncs.com"),
		"cn-yushanfang":               tea.String("vod.aliyuncs.com"),
		"cn-zhangbei":                 tea.String("vod.aliyuncs.com"),
		"cn-zhangbei-na61-b01":        tea.String("vod.aliyuncs.com"),
		"cn-zhangjiakou-na62-a01":     tea.String("vod.aliyuncs.com"),
		"cn-zhengzhou-nebula-1":       tea.String("vod.aliyuncs.com"),
		"eu-west-1-oxs":               tea.String("vod.aliyuncs.com"),
		"me-east-1":                   tea.String("vod.aliyuncs.com"),
		"rus-west-1-pop":              tea.String("vod.aliyuncs.com"),
		"us-east-1":                   tea.String("vod.aliyuncs.com"),
	}
	_err = client.CheckConfig(config)
	if _err != nil {
		return _err
	}
	client.Endpoint, _err = client.GetEndpoint(tea.String("vod"), client.RegionId, client.EndpointRule, client.Network, client.Suffix, client.EndpointMap, client.Endpoint)
	if _err != nil {
		return _err
	}

	return nil
}

func (client *Client) GetEndpoint(productId *string, regionId *string, endpointRule *string, network *string, suffix *string, endpointMap map[string]*string, endpoint *string) (_result *string, _err error) {
	if !tea.BoolValue(util.Empty(endpoint)) {
		_result = endpoint
		return _result, _err
	}

	if !tea.BoolValue(util.IsUnset(endpointMap)) && !tea.BoolValue(util.Empty(endpointMap[tea.StringValue(regionId)])) {
		_result = endpointMap[tea.StringValue(regionId)]
		return _result, _err
	}

	_body, _err := endpointutil.GetEndpointRules(productId, regionId, endpointRule, network, suffix)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Adds an AI template for automated review and smart thumbnail tasks.
//
// Description:
//
//   Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
//
// 	- Before you add an AI template for automated review and smart thumbnail tasks, make sure that [automated review](https://ai.aliyun.com/vi/censor) and [smart thumbnail](https://ai.aliyun.com/vi/cover) are enabled.
//
// @param request - AddAITemplateRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AddAITemplateResponse
func (client *Client) AddAITemplateWithOptions(request *AddAITemplateRequest, runtime *util.RuntimeOptions) (_result *AddAITemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TemplateConfig)) {
		query["TemplateConfig"] = request.TemplateConfig
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateName)) {
		query["TemplateName"] = request.TemplateName
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateType)) {
		query["TemplateType"] = request.TemplateType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddAITemplate"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &AddAITemplateResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &AddAITemplateResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Adds an AI template for automated review and smart thumbnail tasks.
//
// Description:
//
//   Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
//
// 	- Before you add an AI template for automated review and smart thumbnail tasks, make sure that [automated review](https://ai.aliyun.com/vi/censor) and [smart thumbnail](https://ai.aliyun.com/vi/cover) are enabled.
//
// @param request - AddAITemplateRequest
//
// @return AddAITemplateResponse
func (client *Client) AddAITemplate(request *AddAITemplateRequest) (_result *AddAITemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddAITemplateResponse{}
	_body, _err := client.AddAITemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a video category. You can call this operation to categorize media assets including audio or video files, images, and short video materials in ApsaraVideo VOD. This simplifies the query and management of media assets.
//
// Description:
//
//   You can create a maximum of 3 levels of categories for audio, video, and image files and 2 levels of categories for short video materials. Each category level can contain a maximum of 100 subcategories. To create categories for audio and video files, set `Type` to `default`. To create categories for short video materials, set `Type` to `material`.
//
// 	- After you create a category, you can categorize media resources during upload or categorize the uploaded media resources. For more information, see [Manage video categories](https://help.aliyun.com/document_detail/86070.html).
//
// @param request - AddCategoryRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AddCategoryResponse
func (client *Client) AddCategoryWithOptions(request *AddCategoryRequest, runtime *util.RuntimeOptions) (_result *AddCategoryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CateName)) {
		query["CateName"] = request.CateName
	}

	if !tea.BoolValue(util.IsUnset(request.ParentId)) {
		query["ParentId"] = request.ParentId
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddCategory"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &AddCategoryResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &AddCategoryResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Creates a video category. You can call this operation to categorize media assets including audio or video files, images, and short video materials in ApsaraVideo VOD. This simplifies the query and management of media assets.
//
// Description:
//
//   You can create a maximum of 3 levels of categories for audio, video, and image files and 2 levels of categories for short video materials. Each category level can contain a maximum of 100 subcategories. To create categories for audio and video files, set `Type` to `default`. To create categories for short video materials, set `Type` to `material`.
//
// 	- After you create a category, you can categorize media resources during upload or categorize the uploaded media resources. For more information, see [Manage video categories](https://help.aliyun.com/document_detail/86070.html).
//
// @param request - AddCategoryRequest
//
// @return AddCategoryResponse
func (client *Client) AddCategory(request *AddCategoryRequest) (_result *AddCategoryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddCategoryResponse{}
	_body, _err := client.AddCategoryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates an online editing project.
//
// Description:
//
//   For more information about the online editing feature, see [Overview](https://help.aliyun.com/document_detail/95482.html).
//
// @param request - AddEditingProjectRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AddEditingProjectResponse
func (client *Client) AddEditingProjectWithOptions(request *AddEditingProjectRequest, runtime *util.RuntimeOptions) (_result *AddEditingProjectResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CoverURL)) {
		query["CoverURL"] = request.CoverURL
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Division)) {
		query["Division"] = request.Division
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Timeline)) {
		query["Timeline"] = request.Timeline
	}

	if !tea.BoolValue(util.IsUnset(request.Title)) {
		query["Title"] = request.Title
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddEditingProject"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &AddEditingProjectResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &AddEditingProjectResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Creates an online editing project.
//
// Description:
//
//   For more information about the online editing feature, see [Overview](https://help.aliyun.com/document_detail/95482.html).
//
// @param request - AddEditingProjectRequest
//
// @return AddEditingProjectResponse
func (client *Client) AddEditingProject(request *AddEditingProjectRequest) (_result *AddEditingProjectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddEditingProjectResponse{}
	_body, _err := client.AddEditingProjectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Adds one or more materials to an editing project.
//
// @param request - AddEditingProjectMaterialsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AddEditingProjectMaterialsResponse
func (client *Client) AddEditingProjectMaterialsWithOptions(request *AddEditingProjectMaterialsRequest, runtime *util.RuntimeOptions) (_result *AddEditingProjectMaterialsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaterialIds)) {
		query["MaterialIds"] = request.MaterialIds
	}

	if !tea.BoolValue(util.IsUnset(request.MaterialType)) {
		query["MaterialType"] = request.MaterialType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddEditingProjectMaterials"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &AddEditingProjectMaterialsResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &AddEditingProjectMaterialsResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Adds one or more materials to an editing project.
//
// @param request - AddEditingProjectMaterialsRequest
//
// @return AddEditingProjectMaterialsResponse
func (client *Client) AddEditingProjectMaterials(request *AddEditingProjectMaterialsRequest) (_result *AddEditingProjectMaterialsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddEditingProjectMaterialsResponse{}
	_body, _err := client.AddEditingProjectMaterialsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates a transcoding template group or adds transcoding templates to a transcoding template group.
//
// Description:
//
//   You cannot perform custom operations on transcoding template groups that are **locked*	- in the ApsaraVideo VOD console. You can call the [GetTranscodeTemplateGroup](~~GetTranscodeTemplateGroup~~) operation to query the information about a transcoding template group and check whether the transcoding template group is locked based on the value of the Locked parameter. You can call the [UpdateTranscodeTemplateGroup](~~UpdateTranscodeTemplateGroup~~) operation to unlock a transcoding template group if it is locked. Then, you can perform custom operations on the transcoding template group.
//
// 	- An Object Storage Service (OSS) bucket is required to store files that are used for transcoding. You cannot create a transcoding template group if no bucket is available. To activate a bucket, perform the following operations: Log on to the ApsaraVideo VOD console. In the left-side navigation pane, choose **Configuration Management > Media Management > Storage**. On the **Storage*	- page, activate the bucket that is allocated by ApsaraVideo VOD.
//
// 	- You cannot add transcoding templates to the **No Transcoding*	- template group.
//
// 	- You can create a maximum of 20 transcoding template groups.
//
// 	- You can add a maximum of 20 transcoding templates to a transcoding template group.
//
// 	- If you want to generate a URL for adaptive bitrate streaming, you can add video packaging templates to a transcoding template group. You can add a maximum of 10 video packaging templates to a transcoding template group. If you add more than 10 video packaging templates, URLs of the video transcoded based on the video packaging templates are generated but the URL for adaptive bitrate streaming is not generated.
//
// ### QPS limits
//
// You can call this operation up to five times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/342790.html).
//
// @param request - AddTranscodeTemplateGroupRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AddTranscodeTemplateGroupResponse
func (client *Client) AddTranscodeTemplateGroupWithOptions(request *AddTranscodeTemplateGroupRequest, runtime *util.RuntimeOptions) (_result *AddTranscodeTemplateGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.TranscodeTemplateGroupId)) {
		query["TranscodeTemplateGroupId"] = request.TranscodeTemplateGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.TranscodeTemplateList)) {
		query["TranscodeTemplateList"] = request.TranscodeTemplateList
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddTranscodeTemplateGroup"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &AddTranscodeTemplateGroupResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &AddTranscodeTemplateGroupResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Creates a transcoding template group or adds transcoding templates to a transcoding template group.
//
// Description:
//
//   You cannot perform custom operations on transcoding template groups that are **locked*	- in the ApsaraVideo VOD console. You can call the [GetTranscodeTemplateGroup](~~GetTranscodeTemplateGroup~~) operation to query the information about a transcoding template group and check whether the transcoding template group is locked based on the value of the Locked parameter. You can call the [UpdateTranscodeTemplateGroup](~~UpdateTranscodeTemplateGroup~~) operation to unlock a transcoding template group if it is locked. Then, you can perform custom operations on the transcoding template group.
//
// 	- An Object Storage Service (OSS) bucket is required to store files that are used for transcoding. You cannot create a transcoding template group if no bucket is available. To activate a bucket, perform the following operations: Log on to the ApsaraVideo VOD console. In the left-side navigation pane, choose **Configuration Management > Media Management > Storage**. On the **Storage*	- page, activate the bucket that is allocated by ApsaraVideo VOD.
//
// 	- You cannot add transcoding templates to the **No Transcoding*	- template group.
//
// 	- You can create a maximum of 20 transcoding template groups.
//
// 	- You can add a maximum of 20 transcoding templates to a transcoding template group.
//
// 	- If you want to generate a URL for adaptive bitrate streaming, you can add video packaging templates to a transcoding template group. You can add a maximum of 10 video packaging templates to a transcoding template group. If you add more than 10 video packaging templates, URLs of the video transcoded based on the video packaging templates are generated but the URL for adaptive bitrate streaming is not generated.
//
// ### QPS limits
//
// You can call this operation up to five times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/342790.html).
//
// @param request - AddTranscodeTemplateGroupRequest
//
// @return AddTranscodeTemplateGroupResponse
func (client *Client) AddTranscodeTemplateGroup(request *AddTranscodeTemplateGroupRequest) (_result *AddTranscodeTemplateGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddTranscodeTemplateGroupResponse{}
	_body, _err := client.AddTranscodeTemplateGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Adds a domain name to accelerate in ApsaraVideo VOD.
//
// Description:
//
//   This operation is available only in the **China (Shanghai)*	- region.
//
// 	- Before you add a domain name to accelerate, you must activate ApsaraVideo VOD and apply for an Internet content provider (ICP) filing for the domain name. For more information about how to activate ApsaraVideo VOD, see [Activate ApsaraVideo VOD](https://help.aliyun.com/document_detail/51512.html).
//
// 	- If the content on the origin server is not stored on Alibaba Cloud, the content must be reviewed by Alibaba Cloud. The review will be complete by the end of the next business day after you submit an application.
//
// 	- You can add only one domain name to accelerate in a request. You can add a maximum of 20 accelerated domain names within an Alibaba Cloud account.
//
// @param request - AddVodDomainRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AddVodDomainResponse
func (client *Client) AddVodDomainWithOptions(request *AddVodDomainRequest, runtime *util.RuntimeOptions) (_result *AddVodDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CheckUrl)) {
		query["CheckUrl"] = request.CheckUrl
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Scope)) {
		query["Scope"] = request.Scope
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.Sources)) {
		query["Sources"] = request.Sources
	}

	if !tea.BoolValue(util.IsUnset(request.TopLevelDomain)) {
		query["TopLevelDomain"] = request.TopLevelDomain
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddVodDomain"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &AddVodDomainResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &AddVodDomainResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Adds a domain name to accelerate in ApsaraVideo VOD.
//
// Description:
//
//   This operation is available only in the **China (Shanghai)*	- region.
//
// 	- Before you add a domain name to accelerate, you must activate ApsaraVideo VOD and apply for an Internet content provider (ICP) filing for the domain name. For more information about how to activate ApsaraVideo VOD, see [Activate ApsaraVideo VOD](https://help.aliyun.com/document_detail/51512.html).
//
// 	- If the content on the origin server is not stored on Alibaba Cloud, the content must be reviewed by Alibaba Cloud. The review will be complete by the end of the next business day after you submit an application.
//
// 	- You can add only one domain name to accelerate in a request. You can add a maximum of 20 accelerated domain names within an Alibaba Cloud account.
//
// @param request - AddVodDomainRequest
//
// @return AddVodDomainResponse
func (client *Client) AddVodDomain(request *AddVodDomainRequest) (_result *AddVodDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddVodDomainResponse{}
	_body, _err := client.AddVodDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Binds a storage bucket to one or more applications in ApsaraVideo VOD.
//
// Description:
//
// You can call this operation to add a buckets to an ApsaraVideo VOD applications.
//
// > You can add only one ApsaraVideo VOD bucket for each application. If you specify an AppId that does not exist or the ID of an application for which an VOD bucket is enabled, an error is returned.
//
// @param request - AddVodStorageForAppRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AddVodStorageForAppResponse
func (client *Client) AddVodStorageForAppWithOptions(request *AddVodStorageForAppRequest, runtime *util.RuntimeOptions) (_result *AddVodStorageForAppResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.StorageLocation)) {
		query["StorageLocation"] = request.StorageLocation
	}

	if !tea.BoolValue(util.IsUnset(request.StorageType)) {
		query["StorageType"] = request.StorageType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddVodStorageForApp"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &AddVodStorageForAppResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &AddVodStorageForAppResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Binds a storage bucket to one or more applications in ApsaraVideo VOD.
//
// Description:
//
// You can call this operation to add a buckets to an ApsaraVideo VOD applications.
//
// > You can add only one ApsaraVideo VOD bucket for each application. If you specify an AppId that does not exist or the ID of an application for which an VOD bucket is enabled, an error is returned.
//
// @param request - AddVodStorageForAppRequest
//
// @return AddVodStorageForAppResponse
func (client *Client) AddVodStorageForApp(request *AddVodStorageForAppRequest) (_result *AddVodStorageForAppResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddVodStorageForAppResponse{}
	_body, _err := client.AddVodStorageForAppWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Adds a snapshot template or frame animation template.
//
// Description:
//
//   After you add a snapshot template, you can call the [SubmitSnapshotJob](https://help.aliyun.com/document_detail/72213.html) operation and specify the template ID to submit a snapshot job.
//
// 	- You can use the HTTP (HTTPS compatible) callback or MNS callback method to receive the [SnapshotComplete](https://help.aliyun.com/document_detail/57337.html) callback. For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
//
// @param request - AddVodTemplateRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AddVodTemplateResponse
func (client *Client) AddVodTemplateWithOptions(request *AddVodTemplateRequest, runtime *util.RuntimeOptions) (_result *AddVodTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateConfig)) {
		query["TemplateConfig"] = request.TemplateConfig
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateType)) {
		query["TemplateType"] = request.TemplateType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddVodTemplate"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &AddVodTemplateResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &AddVodTemplateResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Adds a snapshot template or frame animation template.
//
// Description:
//
//   After you add a snapshot template, you can call the [SubmitSnapshotJob](https://help.aliyun.com/document_detail/72213.html) operation and specify the template ID to submit a snapshot job.
//
// 	- You can use the HTTP (HTTPS compatible) callback or MNS callback method to receive the [SnapshotComplete](https://help.aliyun.com/document_detail/57337.html) callback. For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
//
// @param request - AddVodTemplateRequest
//
// @return AddVodTemplateResponse
func (client *Client) AddVodTemplate(request *AddVodTemplateRequest) (_result *AddVodTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddVodTemplateResponse{}
	_body, _err := client.AddVodTemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates an image or text watermark. ApsaraVideo VOD allows you to create watermark templates to reuse your parameter configurations such as watermark position, size, font, and color. Each watermark template is assigned a unique ID. This simplifies the progress of creating watermark tasks.
//
// Description:
//
//   You can call this operation to create an `Image` watermark template or a `Text` watermark template. You can use static images in the PNG format or dynamic images in the GIF, APNG, and MOV formats as image watermarks.
//
// 	- After you call this operation to create a watermark template, you must call the [AddTranscodeTemplateGroup](~~AddTranscodeTemplateGroup~~) or [UpdateTranscodeTemplateGroup](~~UpdateTranscodeTemplateGroup~~) operation to associate the watermark template with a transcoding template group. This way, you can add watermarks to videos during transcoding.
//
// 	- For more information, see [Video watermarks](https://help.aliyun.com/document_detail/99369.html).
//
// @param request - AddWatermarkRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AddWatermarkResponse
func (client *Client) AddWatermarkWithOptions(request *AddWatermarkRequest, runtime *util.RuntimeOptions) (_result *AddWatermarkResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.FileUrl)) {
		query["FileUrl"] = request.FileUrl
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	if !tea.BoolValue(util.IsUnset(request.WatermarkConfig)) {
		query["WatermarkConfig"] = request.WatermarkConfig
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddWatermark"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &AddWatermarkResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &AddWatermarkResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Creates an image or text watermark. ApsaraVideo VOD allows you to create watermark templates to reuse your parameter configurations such as watermark position, size, font, and color. Each watermark template is assigned a unique ID. This simplifies the progress of creating watermark tasks.
//
// Description:
//
//   You can call this operation to create an `Image` watermark template or a `Text` watermark template. You can use static images in the PNG format or dynamic images in the GIF, APNG, and MOV formats as image watermarks.
//
// 	- After you call this operation to create a watermark template, you must call the [AddTranscodeTemplateGroup](~~AddTranscodeTemplateGroup~~) or [UpdateTranscodeTemplateGroup](~~UpdateTranscodeTemplateGroup~~) operation to associate the watermark template with a transcoding template group. This way, you can add watermarks to videos during transcoding.
//
// 	- For more information, see [Video watermarks](https://help.aliyun.com/document_detail/99369.html).
//
// @param request - AddWatermarkRequest
//
// @return AddWatermarkResponse
func (client *Client) AddWatermark(request *AddWatermarkRequest) (_result *AddWatermarkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddWatermarkResponse{}
	_body, _err := client.AddWatermarkWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Grants a RAM user or RAM role permissions to access ApsaraVideo VOD applications.
//
// Description:
//
// > You can grant a RAM user or RAM role permissions to access up to 10 applications.
//
// @param request - AttachAppPolicyToIdentityRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return AttachAppPolicyToIdentityResponse
func (client *Client) AttachAppPolicyToIdentityWithOptions(request *AttachAppPolicyToIdentityRequest, runtime *util.RuntimeOptions) (_result *AttachAppPolicyToIdentityResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.IdentityName)) {
		query["IdentityName"] = request.IdentityName
	}

	if !tea.BoolValue(util.IsUnset(request.IdentityType)) {
		query["IdentityType"] = request.IdentityType
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyNames)) {
		query["PolicyNames"] = request.PolicyNames
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AttachAppPolicyToIdentity"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &AttachAppPolicyToIdentityResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &AttachAppPolicyToIdentityResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Grants a RAM user or RAM role permissions to access ApsaraVideo VOD applications.
//
// Description:
//
// > You can grant a RAM user or RAM role permissions to access up to 10 applications.
//
// @param request - AttachAppPolicyToIdentityRequest
//
// @return AttachAppPolicyToIdentityResponse
func (client *Client) AttachAppPolicyToIdentity(request *AttachAppPolicyToIdentityRequest) (_result *AttachAppPolicyToIdentityResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AttachAppPolicyToIdentityResponse{}
	_body, _err := client.AttachAppPolicyToIdentityWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Obtains the basic information and source file information of multiple media assets.
//
// Description:
//
//   You can specify up to 20 audio or video file IDs in each request.
//
// 	- After a media file is uploaded, ApsaraVideo VOD processes the source file. Then, information about the media file is asynchronously generated. You can configure notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event and call this operation to query information about a media file after you receive notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event. For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
//
// @param request - BatchGetMediaInfosRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return BatchGetMediaInfosResponse
func (client *Client) BatchGetMediaInfosWithOptions(request *BatchGetMediaInfosRequest, runtime *util.RuntimeOptions) (_result *BatchGetMediaInfosResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaIds)) {
		query["MediaIds"] = request.MediaIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchGetMediaInfos"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &BatchGetMediaInfosResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &BatchGetMediaInfosResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Obtains the basic information and source file information of multiple media assets.
//
// Description:
//
//   You can specify up to 20 audio or video file IDs in each request.
//
// 	- After a media file is uploaded, ApsaraVideo VOD processes the source file. Then, information about the media file is asynchronously generated. You can configure notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event and call this operation to query information about a media file after you receive notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event. For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
//
// @param request - BatchGetMediaInfosRequest
//
// @return BatchGetMediaInfosResponse
func (client *Client) BatchGetMediaInfos(request *BatchGetMediaInfosRequest) (_result *BatchGetMediaInfosResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchGetMediaInfosResponse{}
	_body, _err := client.BatchGetMediaInfosWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Configures one or more domain names for CDN.
//
// Description:
//
// > This operation is available only in the **China (Shanghai)*	- region.
//
// @param request - BatchSetVodDomainConfigsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return BatchSetVodDomainConfigsResponse
func (client *Client) BatchSetVodDomainConfigsWithOptions(request *BatchSetVodDomainConfigsRequest, runtime *util.RuntimeOptions) (_result *BatchSetVodDomainConfigsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainNames)) {
		query["DomainNames"] = request.DomainNames
	}

	if !tea.BoolValue(util.IsUnset(request.Functions)) {
		query["Functions"] = request.Functions
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchSetVodDomainConfigs"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &BatchSetVodDomainConfigsResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &BatchSetVodDomainConfigsResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Configures one or more domain names for CDN.
//
// Description:
//
// > This operation is available only in the **China (Shanghai)*	- region.
//
// @param request - BatchSetVodDomainConfigsRequest
//
// @return BatchSetVodDomainConfigsResponse
func (client *Client) BatchSetVodDomainConfigs(request *BatchSetVodDomainConfigsRequest) (_result *BatchSetVodDomainConfigsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchSetVodDomainConfigsResponse{}
	_body, _err := client.BatchSetVodDomainConfigsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Enables accelerated domain names that are in the disabled state.
//
// Description:
//
//   This operation is available only in the **China (Shanghai)*	- region.
//
// 	- If the domain name that you want to enable is invalid or your Alibaba Cloud account has overdue payments, you cannot call this operation to enable the domain name.
//
// @param request - BatchStartVodDomainRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return BatchStartVodDomainResponse
func (client *Client) BatchStartVodDomainWithOptions(request *BatchStartVodDomainRequest, runtime *util.RuntimeOptions) (_result *BatchStartVodDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainNames)) {
		query["DomainNames"] = request.DomainNames
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchStartVodDomain"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &BatchStartVodDomainResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &BatchStartVodDomainResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Enables accelerated domain names that are in the disabled state.
//
// Description:
//
//   This operation is available only in the **China (Shanghai)*	- region.
//
// 	- If the domain name that you want to enable is invalid or your Alibaba Cloud account has overdue payments, you cannot call this operation to enable the domain name.
//
// @param request - BatchStartVodDomainRequest
//
// @return BatchStartVodDomainResponse
func (client *Client) BatchStartVodDomain(request *BatchStartVodDomainRequest) (_result *BatchStartVodDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchStartVodDomainResponse{}
	_body, _err := client.BatchStartVodDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Disables accelerated domain names.
//
// Description:
//
//   This operation is available only in the **China (Shanghai)*	- region.
//
// 	- After you disable an accelerated domain name, the information about the domain name is retained. The system automatically reroutes all the requests that are destined for the domain name to the origin server.
//
// @param request - BatchStopVodDomainRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return BatchStopVodDomainResponse
func (client *Client) BatchStopVodDomainWithOptions(request *BatchStopVodDomainRequest, runtime *util.RuntimeOptions) (_result *BatchStopVodDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainNames)) {
		query["DomainNames"] = request.DomainNames
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchStopVodDomain"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &BatchStopVodDomainResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &BatchStopVodDomainResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Disables accelerated domain names.
//
// Description:
//
//   This operation is available only in the **China (Shanghai)*	- region.
//
// 	- After you disable an accelerated domain name, the information about the domain name is retained. The system automatically reroutes all the requests that are destined for the domain name to the origin server.
//
// @param request - BatchStopVodDomainRequest
//
// @return BatchStopVodDomainResponse
func (client *Client) BatchStopVodDomain(request *BatchStopVodDomainRequest) (_result *BatchStopVodDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchStopVodDomainResponse{}
	_body, _err := client.BatchStopVodDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Cancels URL-based upload jobs in the queue.
//
// Description:
//
//   You can cancel only URL-based upload jobs in the **Pending*	- state. You can query the status of a URL-based upload job by calling the [GetURLUploadInfos](https://help.aliyun.com/document_detail/106830.html) operation.
//
// 	- You cannot cancel an upload job that already starts.
//
// 	- You must specify either JobIds or UploadUrls. If you specify both parameters, only JobIds takes effect.
//
// @param request - CancelUrlUploadJobsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CancelUrlUploadJobsResponse
func (client *Client) CancelUrlUploadJobsWithOptions(request *CancelUrlUploadJobsRequest, runtime *util.RuntimeOptions) (_result *CancelUrlUploadJobsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.JobIds)) {
		query["JobIds"] = request.JobIds
	}

	if !tea.BoolValue(util.IsUnset(request.UploadUrls)) {
		query["UploadUrls"] = request.UploadUrls
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CancelUrlUploadJobs"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &CancelUrlUploadJobsResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &CancelUrlUploadJobsResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Cancels URL-based upload jobs in the queue.
//
// Description:
//
//   You can cancel only URL-based upload jobs in the **Pending*	- state. You can query the status of a URL-based upload job by calling the [GetURLUploadInfos](https://help.aliyun.com/document_detail/106830.html) operation.
//
// 	- You cannot cancel an upload job that already starts.
//
// 	- You must specify either JobIds or UploadUrls. If you specify both parameters, only JobIds takes effect.
//
// @param request - CancelUrlUploadJobsRequest
//
// @return CancelUrlUploadJobsResponse
func (client *Client) CancelUrlUploadJobs(request *CancelUrlUploadJobsRequest) (_result *CancelUrlUploadJobsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CancelUrlUploadJobsResponse{}
	_body, _err := client.CancelUrlUploadJobsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Transfers a resource to a specified resource group.
//
// @param request - ChangeResourceGroupRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ChangeResourceGroupResponse
func (client *Client) ChangeResourceGroupWithOptions(request *ChangeResourceGroupRequest, runtime *util.RuntimeOptions) (_result *ChangeResourceGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceRegionId)) {
		query["ResourceRegionId"] = request.ResourceRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ChangeResourceGroup"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &ChangeResourceGroupResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &ChangeResourceGroupResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Transfers a resource to a specified resource group.
//
// @param request - ChangeResourceGroupRequest
//
// @return ChangeResourceGroupResponse
func (client *Client) ChangeResourceGroup(request *ChangeResourceGroupRequest) (_result *ChangeResourceGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ChangeResourceGroupResponse{}
	_body, _err := client.ChangeResourceGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Creates an application.
//
// Description:
//
// You can create up to 10 applications within an Alibaba Cloud account. For more information, see [Multi-application service](https://help.aliyun.com/document_detail/113600.html).
//
// ### QPS limits
//
// You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations in ApsaraVideo VOD](https://help.aliyun.com/document_detail/342790.html).
//
// @param request - CreateAppInfoRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateAppInfoResponse
func (client *Client) CreateAppInfoWithOptions(request *CreateAppInfoRequest, runtime *util.RuntimeOptions) (_result *CreateAppInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateAppInfo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &CreateAppInfoResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &CreateAppInfoResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Creates an application.
//
// Description:
//
// You can create up to 10 applications within an Alibaba Cloud account. For more information, see [Multi-application service](https://help.aliyun.com/document_detail/113600.html).
//
// ### QPS limits
//
// You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations in ApsaraVideo VOD](https://help.aliyun.com/document_detail/342790.html).
//
// @param request - CreateAppInfoRequest
//
// @return CreateAppInfoResponse
func (client *Client) CreateAppInfo(request *CreateAppInfoRequest) (_result *CreateAppInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateAppInfoResponse{}
	_body, _err := client.CreateAppInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Performs manual review on media files, such as audio and video files.
//
// @param request - CreateAuditRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateAuditResponse
func (client *Client) CreateAuditWithOptions(request *CreateAuditRequest, runtime *util.RuntimeOptions) (_result *CreateAuditResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AuditContent)) {
		query["AuditContent"] = request.AuditContent
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateAudit"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &CreateAuditResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &CreateAuditResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Performs manual review on media files, such as audio and video files.
//
// @param request - CreateAuditRequest
//
// @return CreateAuditResponse
func (client *Client) CreateAudit(request *CreateAuditRequest) (_result *CreateAuditResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateAuditResponse{}
	_body, _err := client.CreateAuditWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Obtains an upload URL and an upload credential for an auxiliary media asset such as a watermark image, subtitle file, or material and generates the media ID. ApsaraVideo VOD issues upload URLs and credentials to perform authorization and ensure security. This prevents unauthorized users from uploading media files. ApsaraVideo VOD generates media IDs together with upload URLs and credentials. Media IDs are used in lifecycle management and media processing.
//
// Description:
//
//   **Make sure that you understand the billing method and prices of ApsaraVideo VOD before you call this operation. You are charged storage fees after you upload media files to ApsaraVideo VOD. For more information, see [Billing of media asset storage](~~188308#section_e97_xrp_mzz~~). If you have activated the acceleration service, you are charged acceleration fees when you upload media files to ApsaraVideo VOD. For more information, see [Billing of acceleration traffic](~~188310#section_sta_zm2_tsv~~).**
//
// 	- You can call this operation only to obtain the upload URLs and credentials for media files and create media assets in ApsaraVideo VOD. You cannot call this operation to upload media files. For more information about how to upload media files by calling API operations, see [Upload media files by calling API operations](https://help.aliyun.com/document_detail/476208.html).
//
// 	- If the upload credential expires after 3,000 seconds, you can call the CreateUploadAttachedMedia operation again to obtain a new upload URL and a new upload credential.
//
// 	- You can configure a callback to receive an [AttachedMediaUploadComplete](https://help.aliyun.com/document_detail/103250.html) event notification to determine whether the upload is successful.
//
// 	- You must obtain a URL and a credential before you upload a media file to ApsaraVideo VOD. ApsaraVideo VOD supports multiple upload methods. Each method has different requirements on upload URLs and credentials. For more information, see [Upload URLs and credentials](https://help.aliyun.com/document_detail/55397.html).
//
// @param request - CreateUploadAttachedMediaRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateUploadAttachedMediaResponse
func (client *Client) CreateUploadAttachedMediaWithOptions(request *CreateUploadAttachedMediaRequest, runtime *util.RuntimeOptions) (_result *CreateUploadAttachedMediaResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.BusinessType)) {
		query["BusinessType"] = request.BusinessType
	}

	if !tea.BoolValue(util.IsUnset(request.CateIds)) {
		query["CateIds"] = request.CateIds
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.FileName)) {
		query["FileName"] = request.FileName
	}

	if !tea.BoolValue(util.IsUnset(request.FileSize)) {
		query["FileSize"] = request.FileSize
	}

	if !tea.BoolValue(util.IsUnset(request.MediaExt)) {
		query["MediaExt"] = request.MediaExt
	}

	if !tea.BoolValue(util.IsUnset(request.StorageLocation)) {
		query["StorageLocation"] = request.StorageLocation
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.Title)) {
		query["Title"] = request.Title
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateUploadAttachedMedia"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &CreateUploadAttachedMediaResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &CreateUploadAttachedMediaResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Obtains an upload URL and an upload credential for an auxiliary media asset such as a watermark image, subtitle file, or material and generates the media ID. ApsaraVideo VOD issues upload URLs and credentials to perform authorization and ensure security. This prevents unauthorized users from uploading media files. ApsaraVideo VOD generates media IDs together with upload URLs and credentials. Media IDs are used in lifecycle management and media processing.
//
// Description:
//
//   **Make sure that you understand the billing method and prices of ApsaraVideo VOD before you call this operation. You are charged storage fees after you upload media files to ApsaraVideo VOD. For more information, see [Billing of media asset storage](~~188308#section_e97_xrp_mzz~~). If you have activated the acceleration service, you are charged acceleration fees when you upload media files to ApsaraVideo VOD. For more information, see [Billing of acceleration traffic](~~188310#section_sta_zm2_tsv~~).**
//
// 	- You can call this operation only to obtain the upload URLs and credentials for media files and create media assets in ApsaraVideo VOD. You cannot call this operation to upload media files. For more information about how to upload media files by calling API operations, see [Upload media files by calling API operations](https://help.aliyun.com/document_detail/476208.html).
//
// 	- If the upload credential expires after 3,000 seconds, you can call the CreateUploadAttachedMedia operation again to obtain a new upload URL and a new upload credential.
//
// 	- You can configure a callback to receive an [AttachedMediaUploadComplete](https://help.aliyun.com/document_detail/103250.html) event notification to determine whether the upload is successful.
//
// 	- You must obtain a URL and a credential before you upload a media file to ApsaraVideo VOD. ApsaraVideo VOD supports multiple upload methods. Each method has different requirements on upload URLs and credentials. For more information, see [Upload URLs and credentials](https://help.aliyun.com/document_detail/55397.html).
//
// @param request - CreateUploadAttachedMediaRequest
//
// @return CreateUploadAttachedMediaResponse
func (client *Client) CreateUploadAttachedMedia(request *CreateUploadAttachedMediaRequest) (_result *CreateUploadAttachedMediaResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateUploadAttachedMediaResponse{}
	_body, _err := client.CreateUploadAttachedMediaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries a URL and a credential for uploading an image.
//
// Description:
//
//   **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. You are charged storage fees after you upload media files to ApsaraVideo VOD. For more information, see [Billing of media asset storage](~~188308#section_e97_xrp_mzz~~). If you have activated the acceleration service, you are charged acceleration fees when you upload media files to ApsaraVideo VOD. For more information, see [Billing of acceleration traffic](~~188310#section_sta_zm2_tsv~~).**
//
// 	- You must obtain a URL and a credential before you upload an image to ApsaraVideo VOD. ApsaraVideo VOD provides multiple upload methods. You can upload files by using server upload SDKs, client upload SDKs, URLs, Object Storage Service (OSS) API, or OSS SDKs. Each upload method has different requirements for obtaining upload URLs and credentials. For more information, see the "Usage notes" section of the [Upload URLs and credentials](https://help.aliyun.com/document_detail/55397.html) topic.
//
// 	- You cannot refresh the upload URL or credential when you upload images. If the image upload credential expires, you can call this operation to obtain a new upload URL and credential. By default, the validity period of an image upload credential is 3,000 seconds.
//
// 	- You can call the [CreateUploadAttachedMedia](https://help.aliyun.com/document_detail/98467.html) operation to upload image watermarks.
//
// 	- You can configure a callback for [ImageUploadComplete](https://help.aliyun.com/document_detail/91968.html) to receive notifications about the image upload status.
//
// @param request - CreateUploadImageRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateUploadImageResponse
func (client *Client) CreateUploadImageWithOptions(request *CreateUploadImageRequest, runtime *util.RuntimeOptions) (_result *CreateUploadImageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.CateId)) {
		query["CateId"] = request.CateId
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.ImageExt)) {
		query["ImageExt"] = request.ImageExt
	}

	if !tea.BoolValue(util.IsUnset(request.ImageType)) {
		query["ImageType"] = request.ImageType
	}

	if !tea.BoolValue(util.IsUnset(request.OriginalFileName)) {
		query["OriginalFileName"] = request.OriginalFileName
	}

	if !tea.BoolValue(util.IsUnset(request.StorageLocation)) {
		query["StorageLocation"] = request.StorageLocation
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.Title)) {
		query["Title"] = request.Title
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateUploadImage"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &CreateUploadImageResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &CreateUploadImageResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries a URL and a credential for uploading an image.
//
// Description:
//
//   **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. You are charged storage fees after you upload media files to ApsaraVideo VOD. For more information, see [Billing of media asset storage](~~188308#section_e97_xrp_mzz~~). If you have activated the acceleration service, you are charged acceleration fees when you upload media files to ApsaraVideo VOD. For more information, see [Billing of acceleration traffic](~~188310#section_sta_zm2_tsv~~).**
//
// 	- You must obtain a URL and a credential before you upload an image to ApsaraVideo VOD. ApsaraVideo VOD provides multiple upload methods. You can upload files by using server upload SDKs, client upload SDKs, URLs, Object Storage Service (OSS) API, or OSS SDKs. Each upload method has different requirements for obtaining upload URLs and credentials. For more information, see the "Usage notes" section of the [Upload URLs and credentials](https://help.aliyun.com/document_detail/55397.html) topic.
//
// 	- You cannot refresh the upload URL or credential when you upload images. If the image upload credential expires, you can call this operation to obtain a new upload URL and credential. By default, the validity period of an image upload credential is 3,000 seconds.
//
// 	- You can call the [CreateUploadAttachedMedia](https://help.aliyun.com/document_detail/98467.html) operation to upload image watermarks.
//
// 	- You can configure a callback for [ImageUploadComplete](https://help.aliyun.com/document_detail/91968.html) to receive notifications about the image upload status.
//
// @param request - CreateUploadImageRequest
//
// @return CreateUploadImageResponse
func (client *Client) CreateUploadImage(request *CreateUploadImageRequest) (_result *CreateUploadImageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateUploadImageResponse{}
	_body, _err := client.CreateUploadImageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Obtains an upload URL and an upload credential for uploading an audio or video file and generates the audio or video ID. ApsaraVideo VOD issues upload URLs and credentials to perform authorization and ensure security. This prevents unauthorized users from uploading media files. ApsaraVideo VOD generates media IDs, video IDs, and image IDs together with upload URLs and credentials. Media IDs are used in lifecycle management and media processing.
//
// Description:
//
//   **Make sure that you understand the billing method and prices of ApsaraVideo VOD before you call this operation. You are charged storage fees after you upload media files to ApsaraVideo VOD. For more information, see [Billing of media asset storage](~~188308#section_e97_xrp_mzz~~). If you have activated the acceleration service, you are charged acceleration fees when you upload media files to ApsaraVideo VOD. For more information, see [Billing of acceleration traffic](~~188310#section_sta_zm2_tsv~~).**
//
// 	- You can call this operation to obtain upload URLs and credentials for video and audio files. For more information, see [Upload URLs and credentials](https://help.aliyun.com/document_detail/55397.html).
//
// 	- You can call this operation only to obtain the upload URLs and credentials for media files and create media assets in ApsaraVideo VOD. You cannot call this operation to upload media files. For more information about how to upload media files by calling API operations, see [Upload media files by calling API operations](https://help.aliyun.com/document_detail/476208.html).
//
// 	- If the upload credential expires, call the [RefreshUploadVideo](~~RefreshUploadVideo~~) operation to obtain a new upload credential. The default validity period of an upload credential is 3,000 seconds.
//
// 	- You can configure a callback to receive an event notification when an audio or video file is uploaded. Alternatively, after you upload an audio or video file, you can call the [GetMezzanineInfo](https://help.aliyun.com/document_detail/59624.html) operation to determine whether the upload is successful. For more information, see [Overview](https://help.aliyun.com/document_detail/55396.html).
//
// 	- The value of the VideoId parameter that is returned after you call this operation can be used for media processing or the lifecycle management of media assets.
//
// 	- You must obtain a URL and a credential before you upload a media file to ApsaraVideo VOD. ApsaraVideo VOD supports multiple upload methods. Each method has different requirements on upload URLs and credentials. For more information, see [Upload URLs and credentials](https://help.aliyun.com/document_detail/55397.html).
//
// @param request - CreateUploadVideoRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return CreateUploadVideoResponse
func (client *Client) CreateUploadVideoWithOptions(request *CreateUploadVideoRequest, runtime *util.RuntimeOptions) (_result *CreateUploadVideoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.CateId)) {
		query["CateId"] = request.CateId
	}

	if !tea.BoolValue(util.IsUnset(request.CoverURL)) {
		query["CoverURL"] = request.CoverURL
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.FileName)) {
		query["FileName"] = request.FileName
	}

	if !tea.BoolValue(util.IsUnset(request.FileSize)) {
		query["FileSize"] = request.FileSize
	}

	if !tea.BoolValue(util.IsUnset(request.StorageLocation)) {
		query["StorageLocation"] = request.StorageLocation
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateGroupId)) {
		query["TemplateGroupId"] = request.TemplateGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Title)) {
		query["Title"] = request.Title
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	if !tea.BoolValue(util.IsUnset(request.WorkflowId)) {
		query["WorkflowId"] = request.WorkflowId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateUploadVideo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &CreateUploadVideoResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &CreateUploadVideoResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Obtains an upload URL and an upload credential for uploading an audio or video file and generates the audio or video ID. ApsaraVideo VOD issues upload URLs and credentials to perform authorization and ensure security. This prevents unauthorized users from uploading media files. ApsaraVideo VOD generates media IDs, video IDs, and image IDs together with upload URLs and credentials. Media IDs are used in lifecycle management and media processing.
//
// Description:
//
//   **Make sure that you understand the billing method and prices of ApsaraVideo VOD before you call this operation. You are charged storage fees after you upload media files to ApsaraVideo VOD. For more information, see [Billing of media asset storage](~~188308#section_e97_xrp_mzz~~). If you have activated the acceleration service, you are charged acceleration fees when you upload media files to ApsaraVideo VOD. For more information, see [Billing of acceleration traffic](~~188310#section_sta_zm2_tsv~~).**
//
// 	- You can call this operation to obtain upload URLs and credentials for video and audio files. For more information, see [Upload URLs and credentials](https://help.aliyun.com/document_detail/55397.html).
//
// 	- You can call this operation only to obtain the upload URLs and credentials for media files and create media assets in ApsaraVideo VOD. You cannot call this operation to upload media files. For more information about how to upload media files by calling API operations, see [Upload media files by calling API operations](https://help.aliyun.com/document_detail/476208.html).
//
// 	- If the upload credential expires, call the [RefreshUploadVideo](~~RefreshUploadVideo~~) operation to obtain a new upload credential. The default validity period of an upload credential is 3,000 seconds.
//
// 	- You can configure a callback to receive an event notification when an audio or video file is uploaded. Alternatively, after you upload an audio or video file, you can call the [GetMezzanineInfo](https://help.aliyun.com/document_detail/59624.html) operation to determine whether the upload is successful. For more information, see [Overview](https://help.aliyun.com/document_detail/55396.html).
//
// 	- The value of the VideoId parameter that is returned after you call this operation can be used for media processing or the lifecycle management of media assets.
//
// 	- You must obtain a URL and a credential before you upload a media file to ApsaraVideo VOD. ApsaraVideo VOD supports multiple upload methods. Each method has different requirements on upload URLs and credentials. For more information, see [Upload URLs and credentials](https://help.aliyun.com/document_detail/55397.html).
//
// @param request - CreateUploadVideoRequest
//
// @return CreateUploadVideoResponse
func (client *Client) CreateUploadVideo(request *CreateUploadVideoRequest) (_result *CreateUploadVideoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateUploadVideoResponse{}
	_body, _err := client.CreateUploadVideoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Decrypts the ciphertext specified by CiphertextBlob in the Key Management Service (KMS) data key.
//
// @param request - DecryptKMSDataKeyRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DecryptKMSDataKeyResponse
func (client *Client) DecryptKMSDataKeyWithOptions(request *DecryptKMSDataKeyRequest, runtime *util.RuntimeOptions) (_result *DecryptKMSDataKeyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CipherText)) {
		query["CipherText"] = request.CipherText
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DecryptKMSDataKey"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DecryptKMSDataKeyResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DecryptKMSDataKeyResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Decrypts the ciphertext specified by CiphertextBlob in the Key Management Service (KMS) data key.
//
// @param request - DecryptKMSDataKeyRequest
//
// @return DecryptKMSDataKeyResponse
func (client *Client) DecryptKMSDataKey(request *DecryptKMSDataKeyRequest) (_result *DecryptKMSDataKeyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DecryptKMSDataKeyResponse{}
	_body, _err := client.DecryptKMSDataKeyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes the information about one or more images that are submitted for AI processing.
//
// Description:
//
//   Regions that support this operation: **China (Beijing)*	- and **China (Shanghai)**.
//
// 	- This operation deletes only information about images that are submitted for AI processing. The image files are not deleted.
//
// @param request - DeleteAIImageInfosRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteAIImageInfosResponse
func (client *Client) DeleteAIImageInfosWithOptions(request *DeleteAIImageInfosRequest, runtime *util.RuntimeOptions) (_result *DeleteAIImageInfosResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AIImageInfoIds)) {
		query["AIImageInfoIds"] = request.AIImageInfoIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAIImageInfos"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DeleteAIImageInfosResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DeleteAIImageInfosResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Deletes the information about one or more images that are submitted for AI processing.
//
// Description:
//
//   Regions that support this operation: **China (Beijing)*	- and **China (Shanghai)**.
//
// 	- This operation deletes only information about images that are submitted for AI processing. The image files are not deleted.
//
// @param request - DeleteAIImageInfosRequest
//
// @return DeleteAIImageInfosResponse
func (client *Client) DeleteAIImageInfos(request *DeleteAIImageInfosRequest) (_result *DeleteAIImageInfosResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAIImageInfosResponse{}
	_body, _err := client.DeleteAIImageInfosWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes an AI template.
//
// Description:
//
//   Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
//
// 	- You cannot delete an AI template that is set as the default template.
//
// @param request - DeleteAITemplateRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteAITemplateResponse
func (client *Client) DeleteAITemplateWithOptions(request *DeleteAITemplateRequest, runtime *util.RuntimeOptions) (_result *DeleteAITemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		query["TemplateId"] = request.TemplateId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAITemplate"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DeleteAITemplateResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DeleteAITemplateResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Deletes an AI template.
//
// Description:
//
//   Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
//
// 	- You cannot delete an AI template that is set as the default template.
//
// @param request - DeleteAITemplateRequest
//
// @return DeleteAITemplateResponse
func (client *Client) DeleteAITemplate(request *DeleteAITemplateRequest) (_result *DeleteAITemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAITemplateResponse{}
	_body, _err := client.DeleteAITemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes an application.
//
// Description:
//
// Application with resources can not be deleted.
//
// @param request - DeleteAppInfoRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteAppInfoResponse
func (client *Client) DeleteAppInfoWithOptions(request *DeleteAppInfoRequest, runtime *util.RuntimeOptions) (_result *DeleteAppInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAppInfo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DeleteAppInfoResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DeleteAppInfoResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Deletes an application.
//
// Description:
//
// Application with resources can not be deleted.
//
// @param request - DeleteAppInfoRequest
//
// @return DeleteAppInfoResponse
func (client *Client) DeleteAppInfo(request *DeleteAppInfoRequest) (_result *DeleteAppInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAppInfoResponse{}
	_body, _err := client.DeleteAppInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes auxiliary media assets from ApsaraVideo VOD. You can delete multiple auxiliary media assets such as watermark images, subtitle files, and materials in a batch.
//
// Description:
//
//   **This operation physically deletes auxiliary media assets. You cannot recover the auxiliary media assets that you deleted. Exercise caution when you call this operation.**
//
// 	- You can delete a maximum of 20 auxiliary media assets in one request.
//
// @param request - DeleteAttachedMediaRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteAttachedMediaResponse
func (client *Client) DeleteAttachedMediaWithOptions(request *DeleteAttachedMediaRequest, runtime *util.RuntimeOptions) (_result *DeleteAttachedMediaResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaIds)) {
		query["MediaIds"] = request.MediaIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAttachedMedia"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DeleteAttachedMediaResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DeleteAttachedMediaResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Deletes auxiliary media assets from ApsaraVideo VOD. You can delete multiple auxiliary media assets such as watermark images, subtitle files, and materials in a batch.
//
// Description:
//
//   **This operation physically deletes auxiliary media assets. You cannot recover the auxiliary media assets that you deleted. Exercise caution when you call this operation.**
//
// 	- You can delete a maximum of 20 auxiliary media assets in one request.
//
// @param request - DeleteAttachedMediaRequest
//
// @return DeleteAttachedMediaResponse
func (client *Client) DeleteAttachedMedia(request *DeleteAttachedMediaRequest) (_result *DeleteAttachedMediaResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAttachedMediaResponse{}
	_body, _err := client.DeleteAttachedMediaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a category and its subcategories.
//
// Description:
//
//   **After you call this operation to delete a category, all subcategories including level 2 and level 3 categories are deleted at the same time. Exercise caution when you call this operation.**
//
// 	- If you have classified specific media resources to a category, the category names labeled on these media resources are automatically deleted when you delete the category.
//
// @param request - DeleteCategoryRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteCategoryResponse
func (client *Client) DeleteCategoryWithOptions(request *DeleteCategoryRequest, runtime *util.RuntimeOptions) (_result *DeleteCategoryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CateId)) {
		query["CateId"] = request.CateId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteCategory"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DeleteCategoryResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DeleteCategoryResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Deletes a category and its subcategories.
//
// Description:
//
//   **After you call this operation to delete a category, all subcategories including level 2 and level 3 categories are deleted at the same time. Exercise caution when you call this operation.**
//
// 	- If you have classified specific media resources to a category, the category names labeled on these media resources are automatically deleted when you delete the category.
//
// @param request - DeleteCategoryRequest
//
// @return DeleteCategoryResponse
func (client *Client) DeleteCategory(request *DeleteCategoryRequest) (_result *DeleteCategoryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteCategoryResponse{}
	_body, _err := client.DeleteCategoryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes the information about animated stickers.
//
// Description:
//
// > This operation deletes only the information about animated stickers, but not the animated stickers themselves.
//
// @param request - DeleteDynamicImageRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteDynamicImageResponse
func (client *Client) DeleteDynamicImageWithOptions(request *DeleteDynamicImageRequest, runtime *util.RuntimeOptions) (_result *DeleteDynamicImageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DynamicImageIds)) {
		query["DynamicImageIds"] = request.DynamicImageIds
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDynamicImage"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DeleteDynamicImageResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DeleteDynamicImageResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Deletes the information about animated stickers.
//
// Description:
//
// > This operation deletes only the information about animated stickers, but not the animated stickers themselves.
//
// @param request - DeleteDynamicImageRequest
//
// @return DeleteDynamicImageResponse
func (client *Client) DeleteDynamicImage(request *DeleteDynamicImageRequest) (_result *DeleteDynamicImageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDynamicImageResponse{}
	_body, _err := client.DeleteDynamicImageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes online editing projects.
//
// Description:
//
//   You can call this operation to delete multiple online editing projects at a time.
//
// @param request - DeleteEditingProjectRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteEditingProjectResponse
func (client *Client) DeleteEditingProjectWithOptions(request *DeleteEditingProjectRequest, runtime *util.RuntimeOptions) (_result *DeleteEditingProjectResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIds)) {
		query["ProjectIds"] = request.ProjectIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteEditingProject"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DeleteEditingProjectResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DeleteEditingProjectResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Deletes online editing projects.
//
// Description:
//
//   You can call this operation to delete multiple online editing projects at a time.
//
// @param request - DeleteEditingProjectRequest
//
// @return DeleteEditingProjectResponse
func (client *Client) DeleteEditingProject(request *DeleteEditingProjectRequest) (_result *DeleteEditingProjectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteEditingProjectResponse{}
	_body, _err := client.DeleteEditingProjectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 删除剪辑资源
//
// @param request - DeleteEditingProjectMaterialsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteEditingProjectMaterialsResponse
func (client *Client) DeleteEditingProjectMaterialsWithOptions(request *DeleteEditingProjectMaterialsRequest, runtime *util.RuntimeOptions) (_result *DeleteEditingProjectMaterialsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaterialIds)) {
		query["MaterialIds"] = request.MaterialIds
	}

	if !tea.BoolValue(util.IsUnset(request.MaterialType)) {
		query["MaterialType"] = request.MaterialType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteEditingProjectMaterials"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DeleteEditingProjectMaterialsResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DeleteEditingProjectMaterialsResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// 删除剪辑资源
//
// @param request - DeleteEditingProjectMaterialsRequest
//
// @return DeleteEditingProjectMaterialsResponse
func (client *Client) DeleteEditingProjectMaterials(request *DeleteEditingProjectMaterialsRequest) (_result *DeleteEditingProjectMaterialsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteEditingProjectMaterialsResponse{}
	_body, _err := client.DeleteEditingProjectMaterialsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes uploaded images and video snapshots that are automatically captured.
//
// Description:
//
//   **After you call this operation to delete an image, the source file is permanently deleted and cannot be recovered. Exercise caution when you call this operation.**
//
// 	- If some images are cached on Alibaba Cloud CDN points of presence (POPs), the image URLs do not immediately become invalid.
//
// 	- You can call this operation to delete uploaded images and video snapshots.
//
// @param request - DeleteImageRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteImageResponse
func (client *Client) DeleteImageWithOptions(request *DeleteImageRequest, runtime *util.RuntimeOptions) (_result *DeleteImageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeleteImageType)) {
		query["DeleteImageType"] = request.DeleteImageType
	}

	if !tea.BoolValue(util.IsUnset(request.ImageIds)) {
		query["ImageIds"] = request.ImageIds
	}

	if !tea.BoolValue(util.IsUnset(request.ImageType)) {
		query["ImageType"] = request.ImageType
	}

	if !tea.BoolValue(util.IsUnset(request.ImageURLs)) {
		query["ImageURLs"] = request.ImageURLs
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteImage"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DeleteImageResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DeleteImageResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Deletes uploaded images and video snapshots that are automatically captured.
//
// Description:
//
//   **After you call this operation to delete an image, the source file is permanently deleted and cannot be recovered. Exercise caution when you call this operation.**
//
// 	- If some images are cached on Alibaba Cloud CDN points of presence (POPs), the image URLs do not immediately become invalid.
//
// 	- You can call this operation to delete uploaded images and video snapshots.
//
// @param request - DeleteImageRequest
//
// @return DeleteImageResponse
func (client *Client) DeleteImage(request *DeleteImageRequest) (_result *DeleteImageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteImageResponse{}
	_body, _err := client.DeleteImageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes the callback method, callback URL, and event type of an event notification.
//
// Description:
//
// > For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
//
// @param request - DeleteMessageCallbackRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteMessageCallbackResponse
func (client *Client) DeleteMessageCallbackWithOptions(request *DeleteMessageCallbackRequest, runtime *util.RuntimeOptions) (_result *DeleteMessageCallbackResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteMessageCallback"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DeleteMessageCallbackResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DeleteMessageCallbackResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Deletes the callback method, callback URL, and event type of an event notification.
//
// Description:
//
// > For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
//
// @param request - DeleteMessageCallbackRequest
//
// @return DeleteMessageCallbackResponse
func (client *Client) DeleteMessageCallback(request *DeleteMessageCallbackRequest) (_result *DeleteMessageCallbackResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteMessageCallbackResponse{}
	_body, _err := client.DeleteMessageCallbackWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes one or more source files at a time.
//
// Description:
//
// All media processing operations in ApsaraVideo VOD, such as transcoding, snapshot capture, and content moderation, are performed based on source files. If you delete the source files, you cannot perform media processing operations. Exercise caution when you call this operation.
//
// @param request - DeleteMezzaninesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteMezzaninesResponse
func (client *Client) DeleteMezzaninesWithOptions(request *DeleteMezzaninesRequest, runtime *util.RuntimeOptions) (_result *DeleteMezzaninesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Force)) {
		query["Force"] = request.Force
	}

	if !tea.BoolValue(util.IsUnset(request.VideoIds)) {
		query["VideoIds"] = request.VideoIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteMezzanines"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DeleteMezzaninesResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DeleteMezzaninesResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Deletes one or more source files at a time.
//
// Description:
//
// All media processing operations in ApsaraVideo VOD, such as transcoding, snapshot capture, and content moderation, are performed based on source files. If you delete the source files, you cannot perform media processing operations. Exercise caution when you call this operation.
//
// @param request - DeleteMezzaninesRequest
//
// @return DeleteMezzaninesResponse
func (client *Client) DeleteMezzanines(request *DeleteMezzaninesRequest) (_result *DeleteMezzaninesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteMezzaninesResponse{}
	_body, _err := client.DeleteMezzaninesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes the parts generated during an upload.
//
// Description:
//
//   During multipart upload, useless parts may be retained if the upload fails. These useless parts are automatically deleted after 7 days. You can call this operation to delete the generated parts after the upload is successful or fails.
//
// 	- This operation does not delete the source file or transcoded file, but deletes only the parts generated during the upload.
//
// 	- If you call the [DeleteVideo](https://help.aliyun.com/document_detail/52837.html) operation, the entire video file is deleted, including the generated parts.
//
// @param request - DeleteMultipartUploadRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteMultipartUploadResponse
func (client *Client) DeleteMultipartUploadWithOptions(request *DeleteMultipartUploadRequest, runtime *util.RuntimeOptions) (_result *DeleteMultipartUploadResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaId)) {
		query["MediaId"] = request.MediaId
	}

	if !tea.BoolValue(util.IsUnset(request.MediaType)) {
		query["MediaType"] = request.MediaType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteMultipartUpload"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DeleteMultipartUploadResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DeleteMultipartUploadResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Deletes the parts generated during an upload.
//
// Description:
//
//   During multipart upload, useless parts may be retained if the upload fails. These useless parts are automatically deleted after 7 days. You can call this operation to delete the generated parts after the upload is successful or fails.
//
// 	- This operation does not delete the source file or transcoded file, but deletes only the parts generated during the upload.
//
// 	- If you call the [DeleteVideo](https://help.aliyun.com/document_detail/52837.html) operation, the entire video file is deleted, including the generated parts.
//
// @param request - DeleteMultipartUploadRequest
//
// @return DeleteMultipartUploadResponse
func (client *Client) DeleteMultipartUpload(request *DeleteMultipartUploadRequest) (_result *DeleteMultipartUploadResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteMultipartUploadResponse{}
	_body, _err := client.DeleteMultipartUploadWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes one or more video or audio streams and their storage files at a time.
//
// @param request - DeleteStreamRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteStreamResponse
func (client *Client) DeleteStreamWithOptions(request *DeleteStreamRequest, runtime *util.RuntimeOptions) (_result *DeleteStreamResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.JobIds)) {
		query["JobIds"] = request.JobIds
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteStream"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DeleteStreamResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DeleteStreamResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Deletes one or more video or audio streams and their storage files at a time.
//
// @param request - DeleteStreamRequest
//
// @return DeleteStreamResponse
func (client *Client) DeleteStream(request *DeleteStreamRequest) (_result *DeleteStreamResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteStreamResponse{}
	_body, _err := client.DeleteStreamWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes one or more transcoding templates from a transcoding template group or forcibly deletes a transcoding template group.
//
// Description:
//
//   You cannot call this operation to delete the default transcoding template. You can delete the transcoding template when it is no longer specified as the default one.
//
// 	- For security purposes, you cannot add, modify, or delete transcoding templates in a transcoding template group that is locked. To check whether a transcoding template group is locked, call the [GetTranscodeTemplateGroup](~~GetTranscodeTemplateGroup~~) operation and obtain the Locked parameter from the response. To modify transcoding templates within a locked transcoding template group, you must call the [UpdateTranscodeTemplateGroup](~~UpdateTranscodeTemplateGroup~~) operation to unlock the transcoding template group first.
//
// @param request - DeleteTranscodeTemplateGroupRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteTranscodeTemplateGroupResponse
func (client *Client) DeleteTranscodeTemplateGroupWithOptions(request *DeleteTranscodeTemplateGroupRequest, runtime *util.RuntimeOptions) (_result *DeleteTranscodeTemplateGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ForceDelGroup)) {
		query["ForceDelGroup"] = request.ForceDelGroup
	}

	if !tea.BoolValue(util.IsUnset(request.TranscodeTemplateGroupId)) {
		query["TranscodeTemplateGroupId"] = request.TranscodeTemplateGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.TranscodeTemplateIds)) {
		query["TranscodeTemplateIds"] = request.TranscodeTemplateIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteTranscodeTemplateGroup"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DeleteTranscodeTemplateGroupResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DeleteTranscodeTemplateGroupResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Deletes one or more transcoding templates from a transcoding template group or forcibly deletes a transcoding template group.
//
// Description:
//
//   You cannot call this operation to delete the default transcoding template. You can delete the transcoding template when it is no longer specified as the default one.
//
// 	- For security purposes, you cannot add, modify, or delete transcoding templates in a transcoding template group that is locked. To check whether a transcoding template group is locked, call the [GetTranscodeTemplateGroup](~~GetTranscodeTemplateGroup~~) operation and obtain the Locked parameter from the response. To modify transcoding templates within a locked transcoding template group, you must call the [UpdateTranscodeTemplateGroup](~~UpdateTranscodeTemplateGroup~~) operation to unlock the transcoding template group first.
//
// @param request - DeleteTranscodeTemplateGroupRequest
//
// @return DeleteTranscodeTemplateGroupResponse
func (client *Client) DeleteTranscodeTemplateGroup(request *DeleteTranscodeTemplateGroupRequest) (_result *DeleteTranscodeTemplateGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteTranscodeTemplateGroupResponse{}
	_body, _err := client.DeleteTranscodeTemplateGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes one or more videos at a time, including their mezzanine files, transcoded stream files, and thumbnail snapshots.
//
// Description:
//
//   This operation physically deletes videos. Deleted videos cannot be recovered. Exercise caution when you call this operation.
//
// 	- You can call this operation to delete multiple videos at a time.
//
// 	- When you delete a video, its source file, transcoded stream file, and thumbnail screenshot are also deleted. However, the Alibaba Cloud Content Delivery Network (CDN) cache is not refreshed simultaneously. You can use the refresh feature in the ApsaraVideo VOD console to clear garbage data on CDN nodes. For more information, see [Refresh and prefetch](https://help.aliyun.com/document_detail/86098.html).
//
// @param request - DeleteVideoRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteVideoResponse
func (client *Client) DeleteVideoWithOptions(request *DeleteVideoRequest, runtime *util.RuntimeOptions) (_result *DeleteVideoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.VideoIds)) {
		query["VideoIds"] = request.VideoIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteVideo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DeleteVideoResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DeleteVideoResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Deletes one or more videos at a time, including their mezzanine files, transcoded stream files, and thumbnail snapshots.
//
// Description:
//
//   This operation physically deletes videos. Deleted videos cannot be recovered. Exercise caution when you call this operation.
//
// 	- You can call this operation to delete multiple videos at a time.
//
// 	- When you delete a video, its source file, transcoded stream file, and thumbnail screenshot are also deleted. However, the Alibaba Cloud Content Delivery Network (CDN) cache is not refreshed simultaneously. You can use the refresh feature in the ApsaraVideo VOD console to clear garbage data on CDN nodes. For more information, see [Refresh and prefetch](https://help.aliyun.com/document_detail/86098.html).
//
// @param request - DeleteVideoRequest
//
// @return DeleteVideoResponse
func (client *Client) DeleteVideo(request *DeleteVideoRequest) (_result *DeleteVideoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteVideoResponse{}
	_body, _err := client.DeleteVideoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Removes a domain name for CDN from ApsaraVideo VOD.
//
// Description:
//
// > 	- This operation is available only in the **China (Shanghai)*	- region.
//
// > 	- After a domain name for CDN is removed from ApsaraVideo VOD, the domain name becomes unavailable. Proceed with caution. We recommend that you restore the A record at your DNS service provider before you remove the domain name for CDN.
//
// > 	- After you call this operation to remove a domain name for CDN from ApsaraVideo VOD, all records that are related to the domain name are deleted. If you only want to disable a domain name for CDN, call the [BatchStopVodDomain](https://help.aliyun.com/document_detail/120208.html) operation.
//
// @param request - DeleteVodDomainRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteVodDomainResponse
func (client *Client) DeleteVodDomainWithOptions(request *DeleteVodDomainRequest, runtime *util.RuntimeOptions) (_result *DeleteVodDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteVodDomain"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DeleteVodDomainResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DeleteVodDomainResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Removes a domain name for CDN from ApsaraVideo VOD.
//
// Description:
//
// > 	- This operation is available only in the **China (Shanghai)*	- region.
//
// > 	- After a domain name for CDN is removed from ApsaraVideo VOD, the domain name becomes unavailable. Proceed with caution. We recommend that you restore the A record at your DNS service provider before you remove the domain name for CDN.
//
// > 	- After you call this operation to remove a domain name for CDN from ApsaraVideo VOD, all records that are related to the domain name are deleted. If you only want to disable a domain name for CDN, call the [BatchStopVodDomain](https://help.aliyun.com/document_detail/120208.html) operation.
//
// @param request - DeleteVodDomainRequest
//
// @return DeleteVodDomainResponse
func (client *Client) DeleteVodDomain(request *DeleteVodDomainRequest) (_result *DeleteVodDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteVodDomainResponse{}
	_body, _err := client.DeleteVodDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes the configurations of a domain name for CDN.
//
// Description:
//
// >
//
// 	- This operation is available only in the **China (Shanghai)*	- region.
//
// 	- After the configurations of a domain name for CDN are deleted, the domain name becomes unavailable. We recommend that you restore the A record at your DNS service provider before you delete the configurations of the domain name for CDN.
//
// 	- After you call this operation to remove a domain name for CDN from ApsaraVideo VOD, all records that are related to the domain name are deleted. If you only want to disable a domain name for CDN, call the [BatchStopVodDomain](https://help.aliyun.com/document_detail/120208.html) operation.
//
// @param request - DeleteVodSpecificConfigRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteVodSpecificConfigResponse
func (client *Client) DeleteVodSpecificConfigWithOptions(request *DeleteVodSpecificConfigRequest, runtime *util.RuntimeOptions) (_result *DeleteVodSpecificConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigId)) {
		query["ConfigId"] = request.ConfigId
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Env)) {
		query["Env"] = request.Env
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteVodSpecificConfig"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DeleteVodSpecificConfigResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DeleteVodSpecificConfigResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Deletes the configurations of a domain name for CDN.
//
// Description:
//
// >
//
// 	- This operation is available only in the **China (Shanghai)*	- region.
//
// 	- After the configurations of a domain name for CDN are deleted, the domain name becomes unavailable. We recommend that you restore the A record at your DNS service provider before you delete the configurations of the domain name for CDN.
//
// 	- After you call this operation to remove a domain name for CDN from ApsaraVideo VOD, all records that are related to the domain name are deleted. If you only want to disable a domain name for CDN, call the [BatchStopVodDomain](https://help.aliyun.com/document_detail/120208.html) operation.
//
// @param request - DeleteVodSpecificConfigRequest
//
// @return DeleteVodSpecificConfigResponse
func (client *Client) DeleteVodSpecificConfig(request *DeleteVodSpecificConfigRequest) (_result *DeleteVodSpecificConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteVodSpecificConfigResponse{}
	_body, _err := client.DeleteVodSpecificConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a snapshot template.
//
// @param request - DeleteVodTemplateRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteVodTemplateResponse
func (client *Client) DeleteVodTemplateWithOptions(request *DeleteVodTemplateRequest, runtime *util.RuntimeOptions) (_result *DeleteVodTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.VodTemplateId)) {
		query["VodTemplateId"] = request.VodTemplateId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteVodTemplate"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DeleteVodTemplateResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DeleteVodTemplateResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Deletes a snapshot template.
//
// @param request - DeleteVodTemplateRequest
//
// @return DeleteVodTemplateResponse
func (client *Client) DeleteVodTemplate(request *DeleteVodTemplateRequest) (_result *DeleteVodTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteVodTemplateResponse{}
	_body, _err := client.DeleteVodTemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes an image watermark or text watermark template.
//
// Description:
//
//   **After you delete an image watermark template, the source watermark file is physically deleted and cannot be restored. Exercise caution when you call this operation.**
//
// 	- You cannot delete the default watermark template. To delete a default watermark template, call the [SetDefaultWatermark](~~SetDefaultWatermark~~) operation to set another watermark template as the default one.
//
// @param request - DeleteWatermarkRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DeleteWatermarkResponse
func (client *Client) DeleteWatermarkWithOptions(request *DeleteWatermarkRequest, runtime *util.RuntimeOptions) (_result *DeleteWatermarkResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.WatermarkId)) {
		query["WatermarkId"] = request.WatermarkId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteWatermark"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DeleteWatermarkResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DeleteWatermarkResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Deletes an image watermark or text watermark template.
//
// Description:
//
//   **After you delete an image watermark template, the source watermark file is physically deleted and cannot be restored. Exercise caution when you call this operation.**
//
// 	- You cannot delete the default watermark template. To delete a default watermark template, call the [SetDefaultWatermark](~~SetDefaultWatermark~~) operation to set another watermark template as the default one.
//
// @param request - DeleteWatermarkRequest
//
// @return DeleteWatermarkResponse
func (client *Client) DeleteWatermark(request *DeleteWatermarkRequest) (_result *DeleteWatermarkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteWatermarkResponse{}
	_body, _err := client.DeleteWatermarkWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the distribution of media asset data by time. The maximum time range to query is 6 months.
//
// Description:
//
//   This operation is available only in the China (Shanghai) region.
//
// 	- If you do not set the StartTime or EndTime parameter, the request returns the data collected in the previous 7 days. If you set both the parameters, the request returns the data collected within the specified time range.
//
// @param request - DescribeMediaDistributionRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeMediaDistributionResponse
func (client *Client) DescribeMediaDistributionWithOptions(request *DescribeMediaDistributionRequest, runtime *util.RuntimeOptions) (_result *DescribeMediaDistributionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.StorageClass)) {
		query["StorageClass"] = request.StorageClass
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeMediaDistribution"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeMediaDistributionResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeMediaDistributionResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the distribution of media asset data by time. The maximum time range to query is 6 months.
//
// Description:
//
//   This operation is available only in the China (Shanghai) region.
//
// 	- If you do not set the StartTime or EndTime parameter, the request returns the data collected in the previous 7 days. If you set both the parameters, the request returns the data collected within the specified time range.
//
// @param request - DescribeMediaDistributionRequest
//
// @return DescribeMediaDistributionResponse
func (client *Client) DescribeMediaDistribution(request *DescribeMediaDistributionRequest) (_result *DescribeMediaDistributionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeMediaDistributionResponse{}
	_body, _err := client.DescribeMediaDistributionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries daily playback statistics on top videos, including video views, unique visitors, and total playback duration.
//
// Description:
//
//   This operation is available only in the **China (Shanghai)*	- region.
//
// 	- You can query playback statistics on top 1,000 videos at most on a specified day. By default, top videos are sorted in descending order based on video views.
//
// 	- You can call this operation to query only playback statistics collected on videos that are played by using ApsaraVideo Player SDKs.
//
// 	- Playback statistics for the previous day are generated at 09:00 on the current day, in UTC+8.
//
// 	- You can query data that is generated since January 1, 2018. The maximum time range to query is 180 days.
//
// @param request - DescribePlayTopVideosRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribePlayTopVideosResponse
func (client *Client) DescribePlayTopVideosWithOptions(request *DescribePlayTopVideosRequest, runtime *util.RuntimeOptions) (_result *DescribePlayTopVideosResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BizDate)) {
		query["BizDate"] = request.BizDate
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		query["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePlayTopVideos"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribePlayTopVideosResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribePlayTopVideosResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries daily playback statistics on top videos, including video views, unique visitors, and total playback duration.
//
// Description:
//
//   This operation is available only in the **China (Shanghai)*	- region.
//
// 	- You can query playback statistics on top 1,000 videos at most on a specified day. By default, top videos are sorted in descending order based on video views.
//
// 	- You can call this operation to query only playback statistics collected on videos that are played by using ApsaraVideo Player SDKs.
//
// 	- Playback statistics for the previous day are generated at 09:00 on the current day, in UTC+8.
//
// 	- You can query data that is generated since January 1, 2018. The maximum time range to query is 180 days.
//
// @param request - DescribePlayTopVideosRequest
//
// @return DescribePlayTopVideosResponse
func (client *Client) DescribePlayTopVideos(request *DescribePlayTopVideosRequest) (_result *DescribePlayTopVideosResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePlayTopVideosResponse{}
	_body, _err := client.DescribePlayTopVideosWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the statistics on average playback each day in a specified time range.
//
// Description:
//
// > 	- This operation is available only in the **China (Shanghai)*	- region.
//
// > 	- You can call this operation to query only playback statistics collected on videos that are played by using ApsaraVideo Player SDKs.
//
// > 	- Playback statistics for the previous day are generated at 09:00 on the current day, in UTC+8.
//
// > 	- You can query data that is generated since January 1, 2018. The maximum time range to query is 180 days.
//
// @param request - DescribePlayUserAvgRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribePlayUserAvgResponse
func (client *Client) DescribePlayUserAvgWithOptions(request *DescribePlayUserAvgRequest, runtime *util.RuntimeOptions) (_result *DescribePlayUserAvgResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePlayUserAvg"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribePlayUserAvgResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribePlayUserAvgResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the statistics on average playback each day in a specified time range.
//
// Description:
//
// > 	- This operation is available only in the **China (Shanghai)*	- region.
//
// > 	- You can call this operation to query only playback statistics collected on videos that are played by using ApsaraVideo Player SDKs.
//
// > 	- Playback statistics for the previous day are generated at 09:00 on the current day, in UTC+8.
//
// > 	- You can query data that is generated since January 1, 2018. The maximum time range to query is 180 days.
//
// @param request - DescribePlayUserAvgRequest
//
// @return DescribePlayUserAvgResponse
func (client *Client) DescribePlayUserAvg(request *DescribePlayUserAvgRequest) (_result *DescribePlayUserAvgResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePlayUserAvgResponse{}
	_body, _err := client.DescribePlayUserAvgWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the daily playback statistics in a specified time range. The playback statistics include the total number of views, total number of viewers, total playback duration, and playback duration distribution.
//
// Description:
//
//   This operation is available only in the **China (Shanghai)*	- region.
//
// 	- You can call this operation to query only playback statistics collected on videos that are played by using ApsaraVideo Player SDKs.
//
// 	- Playback statistics for the current day are generated at 09:00 (UTC+8) on the next day.
//
// 	- You can query data that is generated since January 1, 2018. The maximum time range to query is 180 days.
//
// @param request - DescribePlayUserTotalRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribePlayUserTotalResponse
func (client *Client) DescribePlayUserTotalWithOptions(request *DescribePlayUserTotalRequest, runtime *util.RuntimeOptions) (_result *DescribePlayUserTotalResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePlayUserTotal"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribePlayUserTotalResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribePlayUserTotalResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the daily playback statistics in a specified time range. The playback statistics include the total number of views, total number of viewers, total playback duration, and playback duration distribution.
//
// Description:
//
//   This operation is available only in the **China (Shanghai)*	- region.
//
// 	- You can call this operation to query only playback statistics collected on videos that are played by using ApsaraVideo Player SDKs.
//
// 	- Playback statistics for the current day are generated at 09:00 (UTC+8) on the next day.
//
// 	- You can query data that is generated since January 1, 2018. The maximum time range to query is 180 days.
//
// @param request - DescribePlayUserTotalRequest
//
// @return DescribePlayUserTotalResponse
func (client *Client) DescribePlayUserTotal(request *DescribePlayUserTotalRequest) (_result *DescribePlayUserTotalResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePlayUserTotalResponse{}
	_body, _err := client.DescribePlayUserTotalWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries daily playback statistics on a video in the specified time range.
//
// Description:
//
//   This operation is available only in the **China (Shanghai)*	- region.
//
// 	- You can call this operation to query only playback statistics collected on videos that are played by using ApsaraVideo Player SDKs.
//
// 	- Playback statistics for the current day are generated at 09:00 (UTC+8) on the next day.
//
// 	- You can query only data in the last 730 days. The maximum time range to query is 180 days.
//
// @param request - DescribePlayVideoStatisRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribePlayVideoStatisResponse
func (client *Client) DescribePlayVideoStatisWithOptions(request *DescribePlayVideoStatisRequest, runtime *util.RuntimeOptions) (_result *DescribePlayVideoStatisResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePlayVideoStatis"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribePlayVideoStatisResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribePlayVideoStatisResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries daily playback statistics on a video in the specified time range.
//
// Description:
//
//   This operation is available only in the **China (Shanghai)*	- region.
//
// 	- You can call this operation to query only playback statistics collected on videos that are played by using ApsaraVideo Player SDKs.
//
// 	- Playback statistics for the current day are generated at 09:00 (UTC+8) on the next day.
//
// 	- You can query only data in the last 730 days. The maximum time range to query is 180 days.
//
// @param request - DescribePlayVideoStatisRequest
//
// @return DescribePlayVideoStatisResponse
func (client *Client) DescribePlayVideoStatis(request *DescribePlayVideoStatisRequest) (_result *DescribePlayVideoStatisResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePlayVideoStatisResponse{}
	_body, _err := client.DescribePlayVideoStatisWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the statistics on video AI of different types, such as automated review and media fingerprinting.
//
// Description:
//
// > 	- This operation is available only in the **China (Shanghai)*	- region.
//
// >	- If the time range to query is less than or equal to seven days, the system returns the statistics collected on an hourly basis. If the time range to query is greater than seven days, the system returns the statistics collected on a daily basis. The maximum time range that you can specify to query is 31 days.
//
// @param request - DescribeVodAIDataRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodAIDataResponse
func (client *Client) DescribeVodAIDataWithOptions(request *DescribeVodAIDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodAIDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AIType)) {
		query["AIType"] = request.AIType
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodAIData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodAIDataResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodAIDataResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the statistics on video AI of different types, such as automated review and media fingerprinting.
//
// Description:
//
// > 	- This operation is available only in the **China (Shanghai)*	- region.
//
// >	- If the time range to query is less than or equal to seven days, the system returns the statistics collected on an hourly basis. If the time range to query is greater than seven days, the system returns the statistics collected on a daily basis. The maximum time range that you can specify to query is 31 days.
//
// @param request - DescribeVodAIDataRequest
//
// @return DescribeVodAIDataResponse
func (client *Client) DescribeVodAIData(request *DescribeVodAIDataRequest) (_result *DescribeVodAIDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodAIDataResponse{}
	_body, _err := client.DescribeVodAIDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the certificates of a specified domain name for CDN or all the domain names for CDN within your Alibaba Cloud account.
//
// Description:
//
// >  This operation is available only in the **China (Shanghai)*	- region.
//
// @param request - DescribeVodCertificateListRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodCertificateListResponse
func (client *Client) DescribeVodCertificateListWithOptions(request *DescribeVodCertificateListRequest, runtime *util.RuntimeOptions) (_result *DescribeVodCertificateListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodCertificateList"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodCertificateListResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodCertificateListResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the certificates of a specified domain name for CDN or all the domain names for CDN within your Alibaba Cloud account.
//
// Description:
//
// >  This operation is available only in the **China (Shanghai)*	- region.
//
// @param request - DescribeVodCertificateListRequest
//
// @return DescribeVodCertificateListResponse
func (client *Client) DescribeVodCertificateList(request *DescribeVodCertificateListRequest) (_result *DescribeVodCertificateListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodCertificateListResponse{}
	_body, _err := client.DescribeVodCertificateListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the bandwidth for one or more specified domain names for CDN.
//
// Description:
//
// If you specify neither the StartTime parameter nor the EndTime parameter, the data in the last 24 hours is queried. Alternatively, you can specify both the StartTime and EndTime parameters to query data that is generated in the specified duration. You can query data for the last 90 days at most.
//
// @param request - DescribeVodDomainBpsDataRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodDomainBpsDataResponse
func (client *Client) DescribeVodDomainBpsDataWithOptions(request *DescribeVodDomainBpsDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodDomainBpsDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodDomainBpsData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodDomainBpsDataResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodDomainBpsDataResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the bandwidth for one or more specified domain names for CDN.
//
// Description:
//
// If you specify neither the StartTime parameter nor the EndTime parameter, the data in the last 24 hours is queried. Alternatively, you can specify both the StartTime and EndTime parameters to query data that is generated in the specified duration. You can query data for the last 90 days at most.
//
// @param request - DescribeVodDomainBpsDataRequest
//
// @return DescribeVodDomainBpsDataResponse
func (client *Client) DescribeVodDomainBpsData(request *DescribeVodDomainBpsDataRequest) (_result *DescribeVodDomainBpsDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodDomainBpsDataResponse{}
	_body, _err := client.DescribeVodDomainBpsDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the bandwidth data by protocol.
//
// Description:
//
// You can call this API operation up to 20 times per second per account. If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range. Time granularity
//
// The time granularity supported by Interval, the maximum time period within which historical data is available, and the data delay vary based on the time range to query, as described in the following table.
//
// |Time granularity|Time range per query|Historical data available|Data delay|
//
// |---|---|---|---|
//
// |15 minutes|3 days|93 days|15 minutes|
//
// |1 hour|31 days|186 days|3 to 4 hours|
//
// |1 day|90 days|366 days|4 hours in most cases, not more than 24 hours|
//
// @param request - DescribeVodDomainBpsDataByLayerRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodDomainBpsDataByLayerResponse
func (client *Client) DescribeVodDomainBpsDataByLayerWithOptions(request *DescribeVodDomainBpsDataByLayerRequest, runtime *util.RuntimeOptions) (_result *DescribeVodDomainBpsDataByLayerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.Layer)) {
		query["Layer"] = request.Layer
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodDomainBpsDataByLayer"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodDomainBpsDataByLayerResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodDomainBpsDataByLayerResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the bandwidth data by protocol.
//
// Description:
//
// You can call this API operation up to 20 times per second per account. If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range. Time granularity
//
// The time granularity supported by Interval, the maximum time period within which historical data is available, and the data delay vary based on the time range to query, as described in the following table.
//
// |Time granularity|Time range per query|Historical data available|Data delay|
//
// |---|---|---|---|
//
// |15 minutes|3 days|93 days|15 minutes|
//
// |1 hour|31 days|186 days|3 to 4 hours|
//
// |1 day|90 days|366 days|4 hours in most cases, not more than 24 hours|
//
// @param request - DescribeVodDomainBpsDataByLayerRequest
//
// @return DescribeVodDomainBpsDataByLayerResponse
func (client *Client) DescribeVodDomainBpsDataByLayer(request *DescribeVodDomainBpsDataByLayerRequest) (_result *DescribeVodDomainBpsDataByLayerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodDomainBpsDataByLayerResponse{}
	_body, _err := client.DescribeVodDomainBpsDataByLayerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the certificate information about an accelerated domain name.
//
// Description:
//
// This operation is available only in the **China (Shanghai)*	- region.
//
// @param request - DescribeVodDomainCertificateInfoRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodDomainCertificateInfoResponse
func (client *Client) DescribeVodDomainCertificateInfoWithOptions(request *DescribeVodDomainCertificateInfoRequest, runtime *util.RuntimeOptions) (_result *DescribeVodDomainCertificateInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodDomainCertificateInfo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodDomainCertificateInfoResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodDomainCertificateInfoResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the certificate information about an accelerated domain name.
//
// Description:
//
// This operation is available only in the **China (Shanghai)*	- region.
//
// @param request - DescribeVodDomainCertificateInfoRequest
//
// @return DescribeVodDomainCertificateInfoResponse
func (client *Client) DescribeVodDomainCertificateInfo(request *DescribeVodDomainCertificateInfoRequest) (_result *DescribeVodDomainCertificateInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodDomainCertificateInfoResponse{}
	_body, _err := client.DescribeVodDomainCertificateInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the configurations of a domain name for CDN. You can query the configurations of multiple features at a time.
//
// Description:
//
// > This operation is available only in the **China (Shanghai)*	- region.
//
// @param request - DescribeVodDomainConfigsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodDomainConfigsResponse
func (client *Client) DescribeVodDomainConfigsWithOptions(request *DescribeVodDomainConfigsRequest, runtime *util.RuntimeOptions) (_result *DescribeVodDomainConfigsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.FunctionNames)) {
		query["FunctionNames"] = request.FunctionNames
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodDomainConfigs"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodDomainConfigsResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodDomainConfigsResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the configurations of a domain name for CDN. You can query the configurations of multiple features at a time.
//
// Description:
//
// > This operation is available only in the **China (Shanghai)*	- region.
//
// @param request - DescribeVodDomainConfigsRequest
//
// @return DescribeVodDomainConfigsResponse
func (client *Client) DescribeVodDomainConfigs(request *DescribeVodDomainConfigsRequest) (_result *DescribeVodDomainConfigsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodDomainConfigsResponse{}
	_body, _err := client.DescribeVodDomainConfigsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the basic information about a specified domain name for CDN.
//
// Description:
//
// > This operation is available only in the **China (Shanghai)*	- region.
//
// @param request - DescribeVodDomainDetailRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodDomainDetailResponse
func (client *Client) DescribeVodDomainDetailWithOptions(request *DescribeVodDomainDetailRequest, runtime *util.RuntimeOptions) (_result *DescribeVodDomainDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodDomainDetail"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodDomainDetailResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodDomainDetailResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the basic information about a specified domain name for CDN.
//
// Description:
//
// > This operation is available only in the **China (Shanghai)*	- region.
//
// @param request - DescribeVodDomainDetailRequest
//
// @return DescribeVodDomainDetailResponse
func (client *Client) DescribeVodDomainDetail(request *DescribeVodDomainDetailRequest) (_result *DescribeVodDomainDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodDomainDetailResponse{}
	_body, _err := client.DescribeVodDomainDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the byte hit ratios of accelerated domain names. Byte hit ratios are measured in percentage.
//
// Description:
//
// This operation is supported only in the **China (Shanghai)*	- region.
//
// 	- You can specify a maximum of 500 accelerated domain names.
//
// 	- If you specify neither `StartTime` nor `EndTime`, the data of the last 24 hours is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
//
// **Time granularity**
//
// The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay when you do not set `Interval`.
//
// |Time granularity|Time range per query|Historical data available|Data delay|
//
// |---|---|---|---|
//
// |5 minutes|Time range per query &#x3C; 3 days|93 days|15 minutes|
//
// |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
//
// |1 day|31 days ≤ Time span of a single query ≤ 366 days|366 days|4 hours in most cases, not more than 24 hours|
//
// @param request - DescribeVodDomainHitRateDataRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodDomainHitRateDataResponse
func (client *Client) DescribeVodDomainHitRateDataWithOptions(request *DescribeVodDomainHitRateDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodDomainHitRateDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodDomainHitRateData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodDomainHitRateDataResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodDomainHitRateDataResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the byte hit ratios of accelerated domain names. Byte hit ratios are measured in percentage.
//
// Description:
//
// This operation is supported only in the **China (Shanghai)*	- region.
//
// 	- You can specify a maximum of 500 accelerated domain names.
//
// 	- If you specify neither `StartTime` nor `EndTime`, the data of the last 24 hours is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
//
// **Time granularity**
//
// The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay when you do not set `Interval`.
//
// |Time granularity|Time range per query|Historical data available|Data delay|
//
// |---|---|---|---|
//
// |5 minutes|Time range per query &#x3C; 3 days|93 days|15 minutes|
//
// |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
//
// |1 day|31 days ≤ Time span of a single query ≤ 366 days|366 days|4 hours in most cases, not more than 24 hours|
//
// @param request - DescribeVodDomainHitRateDataRequest
//
// @return DescribeVodDomainHitRateDataResponse
func (client *Client) DescribeVodDomainHitRateData(request *DescribeVodDomainHitRateDataRequest) (_result *DescribeVodDomainHitRateDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodDomainHitRateDataResponse{}
	_body, _err := client.DescribeVodDomainHitRateDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the information about the CDN access logs for a domain name, including the log path.
//
// Description:
//
//   This operation is available only in the **China (Shanghai)*	- region.
//
// 	- For more information about the log format and latency, see [Download logs](https://help.aliyun.com/document_detail/86099.html).
//
// 	- If you specify neither the StartTime parameter nor the EndTime parameter, the log data in the last 24 hours is queried.
//
// 	- You can specify both the StartTime and EndTime parameters to query the log data that is generated in the specified time range.
//
// @param request - DescribeVodDomainLogRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodDomainLogResponse
func (client *Client) DescribeVodDomainLogWithOptions(request *DescribeVodDomainLogRequest, runtime *util.RuntimeOptions) (_result *DescribeVodDomainLogResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodDomainLog"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodDomainLogResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodDomainLogResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the information about the CDN access logs for a domain name, including the log path.
//
// Description:
//
//   This operation is available only in the **China (Shanghai)*	- region.
//
// 	- For more information about the log format and latency, see [Download logs](https://help.aliyun.com/document_detail/86099.html).
//
// 	- If you specify neither the StartTime parameter nor the EndTime parameter, the log data in the last 24 hours is queried.
//
// 	- You can specify both the StartTime and EndTime parameters to query the log data that is generated in the specified time range.
//
// @param request - DescribeVodDomainLogRequest
//
// @return DescribeVodDomainLogResponse
func (client *Client) DescribeVodDomainLog(request *DescribeVodDomainLogRequest) (_result *DescribeVodDomainLogResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodDomainLogResponse{}
	_body, _err := client.DescribeVodDomainLogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the 95th percentile bandwidth data of an accelerated domain name.
//
// @param request - DescribeVodDomainMax95BpsDataRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodDomainMax95BpsDataResponse
func (client *Client) DescribeVodDomainMax95BpsDataWithOptions(request *DescribeVodDomainMax95BpsDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodDomainMax95BpsDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodDomainMax95BpsData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodDomainMax95BpsDataResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodDomainMax95BpsDataResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the 95th percentile bandwidth data of an accelerated domain name.
//
// @param request - DescribeVodDomainMax95BpsDataRequest
//
// @return DescribeVodDomainMax95BpsDataResponse
func (client *Client) DescribeVodDomainMax95BpsData(request *DescribeVodDomainMax95BpsDataRequest) (_result *DescribeVodDomainMax95BpsDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodDomainMax95BpsDataResponse{}
	_body, _err := client.DescribeVodDomainMax95BpsDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the number of queries per second (QPS) for one or more accelerated domain names. Data is collected every 5 minutes. You can query data collected in the last 90 days.
//
// Description:
//
// This operation is available only in the China (Shanghai) region.
//
// 	- You can call this operation up to 100 times per second per account.
//
// 	- If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
//
// **Time granularity**
//
// The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
//
// |Time granularity|Maximum time range per query|Historical data available|Data delay|
//
// |---|---|---|---|
//
// |5 minutes|3 days|93 days|15 minutes|
//
// |1 hour|31 days|186 days|3 to 4 hours|
//
// |1 day|366 days|366 days|4 to 24 hours|
//
// ---
//
// @param request - DescribeVodDomainQpsDataRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodDomainQpsDataResponse
func (client *Client) DescribeVodDomainQpsDataWithOptions(request *DescribeVodDomainQpsDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodDomainQpsDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodDomainQpsData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodDomainQpsDataResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodDomainQpsDataResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the number of queries per second (QPS) for one or more accelerated domain names. Data is collected every 5 minutes. You can query data collected in the last 90 days.
//
// Description:
//
// This operation is available only in the China (Shanghai) region.
//
// 	- You can call this operation up to 100 times per second per account.
//
// 	- If you do not set the StartTime or EndTime parameter, the request returns the data collected in the last 24 hours. If you set both these parameters, the request returns the data collected within the specified time range.
//
// **Time granularity**
//
// The time granularity supported by the Interval parameter, the maximum time period within which historical data is available, and the data delay vary with the maximum time range per query, as described in the following table.
//
// |Time granularity|Maximum time range per query|Historical data available|Data delay|
//
// |---|---|---|---|
//
// |5 minutes|3 days|93 days|15 minutes|
//
// |1 hour|31 days|186 days|3 to 4 hours|
//
// |1 day|366 days|366 days|4 to 24 hours|
//
// ---
//
// @param request - DescribeVodDomainQpsDataRequest
//
// @return DescribeVodDomainQpsDataResponse
func (client *Client) DescribeVodDomainQpsData(request *DescribeVodDomainQpsDataRequest) (_result *DescribeVodDomainQpsDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodDomainQpsDataResponse{}
	_body, _err := client.DescribeVodDomainQpsDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the bandwidth data for one or more accelerated domains. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days. Compared with the DescribeVodDomainBpsData operation, this operation provides a smaller time granularity, lower data latency, and allows you to query historical data within a shorter time period.
//
// Description:
//
// This operation is supported only in the **China (Shanghai)*	- region.
//
// 	- You can specify a maximum of 500 accelerated domain names.
//
// 	- If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
//
// **Time granularity**
//
// The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
//
// |Time granularity|Time range per query|Historical data available|Data delay|
//
// |---|---|---|---|
//
// |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
//
// |5 minutes|1 Hour &#x3C; Time range per query ≤ 3 days|93 days|15 minutes|
//
// |1 hour|3 days &#x3C; Time range per query ≤ 31 days|186 days|3 to 4 hours|
//
// @param request - DescribeVodDomainRealTimeBpsDataRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodDomainRealTimeBpsDataResponse
func (client *Client) DescribeVodDomainRealTimeBpsDataWithOptions(request *DescribeVodDomainRealTimeBpsDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodDomainRealTimeBpsDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodDomainRealTimeBpsData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodDomainRealTimeBpsDataResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodDomainRealTimeBpsDataResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the bandwidth data for one or more accelerated domains. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days. Compared with the DescribeVodDomainBpsData operation, this operation provides a smaller time granularity, lower data latency, and allows you to query historical data within a shorter time period.
//
// Description:
//
// This operation is supported only in the **China (Shanghai)*	- region.
//
// 	- You can specify a maximum of 500 accelerated domain names.
//
// 	- If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
//
// **Time granularity**
//
// The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
//
// |Time granularity|Time range per query|Historical data available|Data delay|
//
// |---|---|---|---|
//
// |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
//
// |5 minutes|1 Hour &#x3C; Time range per query ≤ 3 days|93 days|15 minutes|
//
// |1 hour|3 days &#x3C; Time range per query ≤ 31 days|186 days|3 to 4 hours|
//
// @param request - DescribeVodDomainRealTimeBpsDataRequest
//
// @return DescribeVodDomainRealTimeBpsDataResponse
func (client *Client) DescribeVodDomainRealTimeBpsData(request *DescribeVodDomainRealTimeBpsDataRequest) (_result *DescribeVodDomainRealTimeBpsDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodDomainRealTimeBpsDataResponse{}
	_body, _err := client.DescribeVodDomainRealTimeBpsDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the byte hit ratio for one or more accelerated domains. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days.
//
// Description:
//
// This operation is supported only in the **China (Shanghai)*	- region.
//
// 	- You can specify a maximum of 100 accelerated domain names.
//
// 	- If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
//
// **Time granularity**
//
// The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
//
// |Time granularity|Time range per query|Historical data available|Data delay|
//
// |---|---|---|---|
//
// |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
//
// |5 minutes|1 Hour &#x3C; Time range per query ≤ 3 days|93 days|15 minutes|
//
// |1 hour|3 days &#x3C; Time range per query ≤ 31 days|186 days|3 to 4 hours|
//
// @param request - DescribeVodDomainRealTimeByteHitRateDataRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodDomainRealTimeByteHitRateDataResponse
func (client *Client) DescribeVodDomainRealTimeByteHitRateDataWithOptions(request *DescribeVodDomainRealTimeByteHitRateDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodDomainRealTimeByteHitRateDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodDomainRealTimeByteHitRateData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodDomainRealTimeByteHitRateDataResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodDomainRealTimeByteHitRateDataResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the byte hit ratio for one or more accelerated domains. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days.
//
// Description:
//
// This operation is supported only in the **China (Shanghai)*	- region.
//
// 	- You can specify a maximum of 100 accelerated domain names.
//
// 	- If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
//
// **Time granularity**
//
// The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
//
// |Time granularity|Time range per query|Historical data available|Data delay|
//
// |---|---|---|---|
//
// |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
//
// |5 minutes|1 Hour &#x3C; Time range per query ≤ 3 days|93 days|15 minutes|
//
// |1 hour|3 days &#x3C; Time range per query ≤ 31 days|186 days|3 to 4 hours|
//
// @param request - DescribeVodDomainRealTimeByteHitRateDataRequest
//
// @return DescribeVodDomainRealTimeByteHitRateDataResponse
func (client *Client) DescribeVodDomainRealTimeByteHitRateData(request *DescribeVodDomainRealTimeByteHitRateDataRequest) (_result *DescribeVodDomainRealTimeByteHitRateDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodDomainRealTimeByteHitRateDataResponse{}
	_body, _err := client.DescribeVodDomainRealTimeByteHitRateDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries real-time monitoring data of one or more accelerated domain names.
//
// Description:
//
// You can query data within the last seven days. Data is collected every minute. You can call this API operation up to 10 times per second per account.
//
// @param request - DescribeVodDomainRealTimeDetailDataRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodDomainRealTimeDetailDataResponse
func (client *Client) DescribeVodDomainRealTimeDetailDataWithOptions(request *DescribeVodDomainRealTimeDetailDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodDomainRealTimeDetailDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodDomainRealTimeDetailData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodDomainRealTimeDetailDataResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodDomainRealTimeDetailDataResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries real-time monitoring data of one or more accelerated domain names.
//
// Description:
//
// You can query data within the last seven days. Data is collected every minute. You can call this API operation up to 10 times per second per account.
//
// @param request - DescribeVodDomainRealTimeDetailDataRequest
//
// @return DescribeVodDomainRealTimeDetailDataResponse
func (client *Client) DescribeVodDomainRealTimeDetailData(request *DescribeVodDomainRealTimeDetailDataRequest) (_result *DescribeVodDomainRealTimeDetailDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodDomainRealTimeDetailDataResponse{}
	_body, _err := client.DescribeVodDomainRealTimeDetailDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the total number of HTTP status codes and proportion of each HTTP status code for one or more accelerated domains. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days.
//
// Description:
//
// This operation is supported only in the **China (Shanghai)*	- region.
//
// 	- You can specify a maximum of 100 accelerated domain names.
//
// 	- If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
//
// **Time granularity**
//
// The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
//
// |Time granularity|Time range per query|Historical data available (days)|Data latency|
//
// |---|---|---|---|
//
// |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
//
// |5 minutes|1 hour &#x3C; Time range per query &#x3C; 3 days|93 days|15 minutes|
//
// |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
//
// @param request - DescribeVodDomainRealTimeHttpCodeDataRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodDomainRealTimeHttpCodeDataResponse
func (client *Client) DescribeVodDomainRealTimeHttpCodeDataWithOptions(request *DescribeVodDomainRealTimeHttpCodeDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodDomainRealTimeHttpCodeDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodDomainRealTimeHttpCodeData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodDomainRealTimeHttpCodeDataResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodDomainRealTimeHttpCodeDataResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the total number of HTTP status codes and proportion of each HTTP status code for one or more accelerated domains. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days.
//
// Description:
//
// This operation is supported only in the **China (Shanghai)*	- region.
//
// 	- You can specify a maximum of 100 accelerated domain names.
//
// 	- If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
//
// **Time granularity**
//
// The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
//
// |Time granularity|Time range per query|Historical data available (days)|Data latency|
//
// |---|---|---|---|
//
// |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
//
// |5 minutes|1 hour &#x3C; Time range per query &#x3C; 3 days|93 days|15 minutes|
//
// |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
//
// @param request - DescribeVodDomainRealTimeHttpCodeDataRequest
//
// @return DescribeVodDomainRealTimeHttpCodeDataResponse
func (client *Client) DescribeVodDomainRealTimeHttpCodeData(request *DescribeVodDomainRealTimeHttpCodeDataRequest) (_result *DescribeVodDomainRealTimeHttpCodeDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodDomainRealTimeHttpCodeDataResponse{}
	_body, _err := client.DescribeVodDomainRealTimeHttpCodeDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the number of queries per second (QPS) for one or more accelerated domains. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days.
//
// Description:
//
// This operation is supported only in the **China (Shanghai)*	- region.
//
// 	- You can specify a maximum of 500 accelerated domain names.
//
// 	- If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
//
// **Time granularity**
//
// The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
//
// |Time granularity|Time range per query|Historical data available|Data delay|
//
// |---|---|---|---|
//
// |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
//
// |5 minutes|1 Hour &#x3C; Time range per query ≤ 3 days|93 days|15 minutes|
//
// |1 hour|3 days &#x3C; Time range per query ≤ 31 days|186 days|3 to 4 hours|
//
// @param request - DescribeVodDomainRealTimeQpsDataRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodDomainRealTimeQpsDataResponse
func (client *Client) DescribeVodDomainRealTimeQpsDataWithOptions(request *DescribeVodDomainRealTimeQpsDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodDomainRealTimeQpsDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodDomainRealTimeQpsData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodDomainRealTimeQpsDataResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodDomainRealTimeQpsDataResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the number of queries per second (QPS) for one or more accelerated domains. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days.
//
// Description:
//
// This operation is supported only in the **China (Shanghai)*	- region.
//
// 	- You can specify a maximum of 500 accelerated domain names.
//
// 	- If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
//
// **Time granularity**
//
// The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
//
// |Time granularity|Time range per query|Historical data available|Data delay|
//
// |---|---|---|---|
//
// |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
//
// |5 minutes|1 Hour &#x3C; Time range per query ≤ 3 days|93 days|15 minutes|
//
// |1 hour|3 days &#x3C; Time range per query ≤ 31 days|186 days|3 to 4 hours|
//
// @param request - DescribeVodDomainRealTimeQpsDataRequest
//
// @return DescribeVodDomainRealTimeQpsDataResponse
func (client *Client) DescribeVodDomainRealTimeQpsData(request *DescribeVodDomainRealTimeQpsDataRequest) (_result *DescribeVodDomainRealTimeQpsDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodDomainRealTimeQpsDataResponse{}
	_body, _err := client.DescribeVodDomainRealTimeQpsDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the request hit ratio data for one or more accelerated domain names. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days.
//
// Description:
//
// This operation is supported only in the **China (Shanghai)*	- region.
//
// 	- You can specify a maximum of 100 accelerated domain names.
//
// 	- If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
//
// 	- By default, the POST method is used for Go. To use the FET method, you must declare `request.Method="GET"`.
//
// **Time granularity**
//
// The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
//
// |Time granularity|Time range per query|Historical data available|Data delay|
//
// |---|---|---|---|
//
// |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
//
// |5 minutes|1 hour &#x3C; Time range per query &#x3C; 3 days|93 days|15 minutes|
//
// |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
//
// @param request - DescribeVodDomainRealTimeReqHitRateDataRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodDomainRealTimeReqHitRateDataResponse
func (client *Client) DescribeVodDomainRealTimeReqHitRateDataWithOptions(request *DescribeVodDomainRealTimeReqHitRateDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodDomainRealTimeReqHitRateDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodDomainRealTimeReqHitRateData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodDomainRealTimeReqHitRateDataResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodDomainRealTimeReqHitRateDataResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the request hit ratio data for one or more accelerated domain names. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days.
//
// Description:
//
// This operation is supported only in the **China (Shanghai)*	- region.
//
// 	- You can specify a maximum of 100 accelerated domain names.
//
// 	- If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
//
// 	- By default, the POST method is used for Go. To use the FET method, you must declare `request.Method="GET"`.
//
// **Time granularity**
//
// The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
//
// |Time granularity|Time range per query|Historical data available|Data delay|
//
// |---|---|---|---|
//
// |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
//
// |5 minutes|1 hour &#x3C; Time range per query &#x3C; 3 days|93 days|15 minutes|
//
// |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
//
// @param request - DescribeVodDomainRealTimeReqHitRateDataRequest
//
// @return DescribeVodDomainRealTimeReqHitRateDataResponse
func (client *Client) DescribeVodDomainRealTimeReqHitRateData(request *DescribeVodDomainRealTimeReqHitRateDataRequest) (_result *DescribeVodDomainRealTimeReqHitRateDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodDomainRealTimeReqHitRateDataResponse{}
	_body, _err := client.DescribeVodDomainRealTimeReqHitRateDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the traffic data for one or more accelerated domains. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days. Compared with the DescribeVodDomainTrafficData operation, this operation provides a smaller time granularity, lower data latency, and allows you to query historical data within a shorter time period.
//
// Description:
//
// This operation is supported only in the **China (Shanghai)*	- region.
//
// 	- You can specify a maximum of 100 accelerated domain names.
//
// 	- If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
//
// **Time granularity**
//
// The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
//
// |Time granularity|Time range per query|Historical data available|Data delay|
//
// |---|---|---|---|
//
// |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
//
// |5 minutes|1 Hour &#x3C; Time range per query ≤ 3 days|93 days|15 minutes|
//
// |1 hour|3 days &#x3C; Time range per query ≤ 31 days|186 days|3 to 4 hours|
//
// @param request - DescribeVodDomainRealTimeTrafficDataRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodDomainRealTimeTrafficDataResponse
func (client *Client) DescribeVodDomainRealTimeTrafficDataWithOptions(request *DescribeVodDomainRealTimeTrafficDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodDomainRealTimeTrafficDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodDomainRealTimeTrafficData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodDomainRealTimeTrafficDataResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodDomainRealTimeTrafficDataResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the traffic data for one or more accelerated domains. The minimum time granularity is 1 minute. The minimum data latency is 5 minutes. You can query data in the last 186 days. Compared with the DescribeVodDomainTrafficData operation, this operation provides a smaller time granularity, lower data latency, and allows you to query historical data within a shorter time period.
//
// Description:
//
// This operation is supported only in the **China (Shanghai)*	- region.
//
// 	- You can specify a maximum of 100 accelerated domain names.
//
// 	- If you specify neither `StartTime` nor `EndTime`, the data of the last 1 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
//
// **Time granularity**
//
// The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay.
//
// |Time granularity|Time range per query|Historical data available|Data delay|
//
// |---|---|---|---|
//
// |1 minute|Time range per query ≤ 1 hour|7 days|5 minutes|
//
// |5 minutes|1 Hour &#x3C; Time range per query ≤ 3 days|93 days|15 minutes|
//
// |1 hour|3 days &#x3C; Time range per query ≤ 31 days|186 days|3 to 4 hours|
//
// @param request - DescribeVodDomainRealTimeTrafficDataRequest
//
// @return DescribeVodDomainRealTimeTrafficDataResponse
func (client *Client) DescribeVodDomainRealTimeTrafficData(request *DescribeVodDomainRealTimeTrafficDataRequest) (_result *DescribeVodDomainRealTimeTrafficDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodDomainRealTimeTrafficDataResponse{}
	_body, _err := client.DescribeVodDomainRealTimeTrafficDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the byte hit ratio for one or more accelerated domains. Request hit ratios are measured in percentage.
//
// Description:
//
// This operation is supported only in the **China (Shanghai)*	- region.
//
// 	- You can specify a maximum of 500 accelerated domain names.
//
// 	- If you specify neither `StartTime` nor `EndTime`, the data of the last 24 hours is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
//
// **Time granularity**
//
// The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay when you do not set `Interval`.
//
// |Time granularity|Time range per query|Historical data available|Data delay|
//
// |---|---|---|---|
//
// |5 minutes|Time range per query &#x3C; 3 days|93 days|15 minutes|
//
// |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
//
// |1 day|31 days ≤ Time range per query ≤ 90 days|366 days|4 hours in most cases, not more than 24 hours|
//
// @param request - DescribeVodDomainReqHitRateDataRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodDomainReqHitRateDataResponse
func (client *Client) DescribeVodDomainReqHitRateDataWithOptions(request *DescribeVodDomainReqHitRateDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodDomainReqHitRateDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodDomainReqHitRateData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodDomainReqHitRateDataResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodDomainReqHitRateDataResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the byte hit ratio for one or more accelerated domains. Request hit ratios are measured in percentage.
//
// Description:
//
// This operation is supported only in the **China (Shanghai)*	- region.
//
// 	- You can specify a maximum of 500 accelerated domain names.
//
// 	- If you specify neither `StartTime` nor `EndTime`, the data of the last 24 hours is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
//
// **Time granularity**
//
// The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay when you do not set `Interval`.
//
// |Time granularity|Time range per query|Historical data available|Data delay|
//
// |---|---|---|---|
//
// |5 minutes|Time range per query &#x3C; 3 days|93 days|15 minutes|
//
// |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
//
// |1 day|31 days ≤ Time range per query ≤ 90 days|366 days|4 hours in most cases, not more than 24 hours|
//
// @param request - DescribeVodDomainReqHitRateDataRequest
//
// @return DescribeVodDomainReqHitRateDataResponse
func (client *Client) DescribeVodDomainReqHitRateData(request *DescribeVodDomainReqHitRateDataRequest) (_result *DescribeVodDomainReqHitRateDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodDomainReqHitRateDataResponse{}
	_body, _err := client.DescribeVodDomainReqHitRateDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the bandwidth data during back-to-origin routing for one or more accelerated domain names.
//
// Description:
//
// This operation is supported only in the **China (Shanghai)*	- region.
//
// 	- You can specify a maximum of 500 accelerated domain names.
//
// 	- If you specify neither `StartTime` nor `EndTime`, the data of the last 24 hours is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
//
// **Time granularity**
//
// The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay when you do not set `Interval`.
//
// |Time granularity|Time range per query|Historical data available|Data delay|
//
// |---|---|---|---|
//
// |5 minutes|Time range per query &#x3C; 3 days|93 days|15 minutes|
//
// |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
//
// |1 day|31 days ≤ Time span of a single query ≤ 366 days|366 days|4 hours in most cases, not more than 24 hours|
//
// @param request - DescribeVodDomainSrcBpsDataRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodDomainSrcBpsDataResponse
func (client *Client) DescribeVodDomainSrcBpsDataWithOptions(request *DescribeVodDomainSrcBpsDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodDomainSrcBpsDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodDomainSrcBpsData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodDomainSrcBpsDataResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodDomainSrcBpsDataResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the bandwidth data during back-to-origin routing for one or more accelerated domain names.
//
// Description:
//
// This operation is supported only in the **China (Shanghai)*	- region.
//
// 	- You can specify a maximum of 500 accelerated domain names.
//
// 	- If you specify neither `StartTime` nor `EndTime`, the data of the last 24 hours is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
//
// **Time granularity**
//
// The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay when you do not set `Interval`.
//
// |Time granularity|Time range per query|Historical data available|Data delay|
//
// |---|---|---|---|
//
// |5 minutes|Time range per query &#x3C; 3 days|93 days|15 minutes|
//
// |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
//
// |1 day|31 days ≤ Time span of a single query ≤ 366 days|366 days|4 hours in most cases, not more than 24 hours|
//
// @param request - DescribeVodDomainSrcBpsDataRequest
//
// @return DescribeVodDomainSrcBpsDataResponse
func (client *Client) DescribeVodDomainSrcBpsData(request *DescribeVodDomainSrcBpsDataRequest) (_result *DescribeVodDomainSrcBpsDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodDomainSrcBpsDataResponse{}
	_body, _err := client.DescribeVodDomainSrcBpsDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries origin traffic data for accelerated domain names in ApsaraVideo VOD. The traffic is measured in bytes.
//
// Description:
//
// This operation is available only in the **China (Shanghai)*	- region.
//
// 	- ApsaraVideo VOD stores the origin traffic data for 90 days before the data is deleted.
//
// 	- If you do not set the `StartTime` or `EndTime` parameter, the request returns the data collected in the last 24 hours. If you set both the `StartTime` and `EndTime` parameters, the request returns the data collected within the specified time range.
//
// 	- You can specify a maximum of 500 domain names in a request. Separate multiple domain names with commas (,). If you specify multiple domain names in a request, aggregation results are returned.
//
// ### Time granularity
//
// The time granularity supported by the Interval parameter varies based on the time range per query specified by using `StartTime` and `EndTime`. The following table describes the time period within which historical data is available and the data delay.
//
// |Time granularity|Time range per query (days)|Historical data available (days)|Data delay|
//
// |---|---|---|---|
//
// |5 minutes|(0, 3\\]|93|15 minutes|
//
// |1 hour|(3, 31\\]|186|4 hours|
//
// |1 day|(31, 366\\]|366|04:00 on the next day|
//
// @param request - DescribeVodDomainSrcTrafficDataRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodDomainSrcTrafficDataResponse
func (client *Client) DescribeVodDomainSrcTrafficDataWithOptions(request *DescribeVodDomainSrcTrafficDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodDomainSrcTrafficDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodDomainSrcTrafficData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodDomainSrcTrafficDataResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodDomainSrcTrafficDataResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries origin traffic data for accelerated domain names in ApsaraVideo VOD. The traffic is measured in bytes.
//
// Description:
//
// This operation is available only in the **China (Shanghai)*	- region.
//
// 	- ApsaraVideo VOD stores the origin traffic data for 90 days before the data is deleted.
//
// 	- If you do not set the `StartTime` or `EndTime` parameter, the request returns the data collected in the last 24 hours. If you set both the `StartTime` and `EndTime` parameters, the request returns the data collected within the specified time range.
//
// 	- You can specify a maximum of 500 domain names in a request. Separate multiple domain names with commas (,). If you specify multiple domain names in a request, aggregation results are returned.
//
// ### Time granularity
//
// The time granularity supported by the Interval parameter varies based on the time range per query specified by using `StartTime` and `EndTime`. The following table describes the time period within which historical data is available and the data delay.
//
// |Time granularity|Time range per query (days)|Historical data available (days)|Data delay|
//
// |---|---|---|---|
//
// |5 minutes|(0, 3\\]|93|15 minutes|
//
// |1 hour|(3, 31\\]|186|4 hours|
//
// |1 day|(31, 366\\]|366|04:00 on the next day|
//
// @param request - DescribeVodDomainSrcTrafficDataRequest
//
// @return DescribeVodDomainSrcTrafficDataResponse
func (client *Client) DescribeVodDomainSrcTrafficData(request *DescribeVodDomainSrcTrafficDataRequest) (_result *DescribeVodDomainSrcTrafficDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodDomainSrcTrafficDataResponse{}
	_body, _err := client.DescribeVodDomainSrcTrafficDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the traffic data for one or more accelerated domains. The minimum time granularity is 5 minutes. You can query data in the last 366 days. Compared with the DescribeVodDomainRealTimeTrafficData operation, this operation provides a greater time granularity, higher data latency, but allows you to query historical data within a longer time period.
//
// Description:
//
// This operation is supported only in the **China (Shanghai)*	- region.
//
// 	- You can specify a maximum of 500 accelerated domain names.
//
// 	- If you specify neither `StartTime` nor `EndTime`, the data of the last 24 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
//
// **Time granularity**
//
// The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay when you do not set `Interval`.
//
// |Time granularity|Time range per query|Historical data available|Data delay|
//
// |---|---|---|---|
//
// |5 minutes|Time range per query &#x3C; 3 days|93 days|15 minutes|
//
// |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
//
// |1 day|31 days ≤ Time range per query ≤ 366 days|366 days|4 hours in most cases, not more than 24 hours|
//
// @param request - DescribeVodDomainTrafficDataRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodDomainTrafficDataResponse
func (client *Client) DescribeVodDomainTrafficDataWithOptions(request *DescribeVodDomainTrafficDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodDomainTrafficDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodDomainTrafficData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodDomainTrafficDataResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodDomainTrafficDataResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the traffic data for one or more accelerated domains. The minimum time granularity is 5 minutes. You can query data in the last 366 days. Compared with the DescribeVodDomainRealTimeTrafficData operation, this operation provides a greater time granularity, higher data latency, but allows you to query historical data within a longer time period.
//
// Description:
//
// This operation is supported only in the **China (Shanghai)*	- region.
//
// 	- You can specify a maximum of 500 accelerated domain names.
//
// 	- If you specify neither `StartTime` nor `EndTime`, the data of the last 24 hour is queried. You can specify both `StartTime` and `EndTime` parameters to query data of a specified time range.
//
// **Time granularity**
//
// The time granularity varies with the time range specified by the `StartTime` and `EndTime` parameters. The following table describes the time period within which historical data is available and the data delay when you do not set `Interval`.
//
// |Time granularity|Time range per query|Historical data available|Data delay|
//
// |---|---|---|---|
//
// |5 minutes|Time range per query &#x3C; 3 days|93 days|15 minutes|
//
// |1 hour|3 days ≤ Time range per query &#x3C; 31 days|186 days|3 to 4 hours|
//
// |1 day|31 days ≤ Time range per query ≤ 366 days|366 days|4 hours in most cases, not more than 24 hours|
//
// @param request - DescribeVodDomainTrafficDataRequest
//
// @return DescribeVodDomainTrafficDataResponse
func (client *Client) DescribeVodDomainTrafficData(request *DescribeVodDomainTrafficDataRequest) (_result *DescribeVodDomainTrafficDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodDomainTrafficDataResponse{}
	_body, _err := client.DescribeVodDomainTrafficDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the traffic or bandwidth data of one or more accelerated domain names.
//
// Description:
//
//   This operation is available only in the **China (Shanghai)*	- region.
//
// 	- You can specify up to 100 accelerated domain names in a request. Separate multiple domain names with commas (,). If you do not specify an accelerated domain name, the data of all accelerated domain names within your Alibaba Cloud account is returned.
//
// 	- You can query data in the last year. The maximum time range that can be queried is three months. If you specify a time range of one to three days, the system returns data on an hourly basis. If you specify a time range of four days or more, the system returns data on a daily basis.
//
// @param request - DescribeVodDomainUsageDataRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodDomainUsageDataResponse
func (client *Client) DescribeVodDomainUsageDataWithOptions(request *DescribeVodDomainUsageDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodDomainUsageDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Area)) {
		query["Area"] = request.Area
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Field)) {
		query["Field"] = request.Field
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodDomainUsageData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodDomainUsageDataResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodDomainUsageDataResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the traffic or bandwidth data of one or more accelerated domain names.
//
// Description:
//
//   This operation is available only in the **China (Shanghai)*	- region.
//
// 	- You can specify up to 100 accelerated domain names in a request. Separate multiple domain names with commas (,). If you do not specify an accelerated domain name, the data of all accelerated domain names within your Alibaba Cloud account is returned.
//
// 	- You can query data in the last year. The maximum time range that can be queried is three months. If you specify a time range of one to three days, the system returns data on an hourly basis. If you specify a time range of four days or more, the system returns data on a daily basis.
//
// @param request - DescribeVodDomainUsageDataRequest
//
// @return DescribeVodDomainUsageDataResponse
func (client *Client) DescribeVodDomainUsageData(request *DescribeVodDomainUsageDataRequest) (_result *DescribeVodDomainUsageDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodDomainUsageDataResponse{}
	_body, _err := client.DescribeVodDomainUsageDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// 点播云剪辑用量查询
//
// @param request - DescribeVodEditingUsageDataRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodEditingUsageDataResponse
func (client *Client) DescribeVodEditingUsageDataWithOptions(request *DescribeVodEditingUsageDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodEditingUsageDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.Specification)) {
		query["Specification"] = request.Specification
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodEditingUsageData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodEditingUsageDataResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodEditingUsageDataResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// 点播云剪辑用量查询
//
// @param request - DescribeVodEditingUsageDataRequest
//
// @return DescribeVodEditingUsageDataResponse
func (client *Client) DescribeVodEditingUsageData(request *DescribeVodEditingUsageDataRequest) (_result *DescribeVodEditingUsageDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodEditingUsageDataResponse{}
	_body, _err := client.DescribeVodEditingUsageDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the playback statistics based on the media ID. You can call this operation to query information such as the number of visits, average video views per viewer, total number of views, average playback duration per viewer, and total playback duration.
//
// Description:
//
//   This operation is available only in the **China (Shanghai)*	- region.
//
// 	- Only playback data in ApsaraVideo Player SDK is collected.
//
// 	- You can query only data within the last 30 days.
//
// 	- Before you call this operation, make sure that the following requirements are met:
//
//     	- ApsaraVideo Player SDK for Android or iOS
//
//         	- ApsaraVideo Player SDK for Android or iOS V5.4.9.2 or later is used.
//
//         	- A license for ApsaraVideo Player SDK is obtained. For more information, see [Manage licenses](https://help.aliyun.com/document_detail/469166.html).
//
//         	- The log reporting feature is enabled. By default, the feature is enabled for ApsaraVideo Player SDKs. For more information, see [Integrate ApsaraVideo Player SDK for Android](~~311525#section-dc4-gp6-xk2~~) and [Integrate ApsaraVideo Player SDK for iOS](~~313855#section-cmf-k7d-jg5~~).
//
//     	- ApsaraVideo Player SDK for Web
//
//         	- ApsaraVideo Player SDK for Web V2.16.0 or later is used.
//
//         	- A license for **playback quality monitoring*	- is obtained. To apply for the license, [submit a request on Yida to enable value-added features for ApsaraVideo Player SDK for Web](https://yida.alibaba-inc.com/o/webplayer#/). For more information, see the description of the `license` parameter in the [API operations](~~125572#section-3ty-gwp-6pa~~) topic.
//
//         	- The log reporting feature is enabled. By default, the feature is enabled for ApsaraVideo Player SDKs.
//
// @param request - DescribeVodMediaPlayDataRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodMediaPlayDataResponse
func (client *Client) DescribeVodMediaPlayDataWithOptions(request *DescribeVodMediaPlayDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodMediaPlayDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaId)) {
		query["MediaId"] = request.MediaId
	}

	if !tea.BoolValue(util.IsUnset(request.OrderName)) {
		query["OrderName"] = request.OrderName
	}

	if !tea.BoolValue(util.IsUnset(request.OrderType)) {
		query["OrderType"] = request.OrderType
	}

	if !tea.BoolValue(util.IsUnset(request.Os)) {
		query["Os"] = request.Os
	}

	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		query["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.PlayDate)) {
		query["PlayDate"] = request.PlayDate
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.TerminalType)) {
		query["TerminalType"] = request.TerminalType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodMediaPlayData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodMediaPlayDataResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodMediaPlayDataResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the playback statistics based on the media ID. You can call this operation to query information such as the number of visits, average video views per viewer, total number of views, average playback duration per viewer, and total playback duration.
//
// Description:
//
//   This operation is available only in the **China (Shanghai)*	- region.
//
// 	- Only playback data in ApsaraVideo Player SDK is collected.
//
// 	- You can query only data within the last 30 days.
//
// 	- Before you call this operation, make sure that the following requirements are met:
//
//     	- ApsaraVideo Player SDK for Android or iOS
//
//         	- ApsaraVideo Player SDK for Android or iOS V5.4.9.2 or later is used.
//
//         	- A license for ApsaraVideo Player SDK is obtained. For more information, see [Manage licenses](https://help.aliyun.com/document_detail/469166.html).
//
//         	- The log reporting feature is enabled. By default, the feature is enabled for ApsaraVideo Player SDKs. For more information, see [Integrate ApsaraVideo Player SDK for Android](~~311525#section-dc4-gp6-xk2~~) and [Integrate ApsaraVideo Player SDK for iOS](~~313855#section-cmf-k7d-jg5~~).
//
//     	- ApsaraVideo Player SDK for Web
//
//         	- ApsaraVideo Player SDK for Web V2.16.0 or later is used.
//
//         	- A license for **playback quality monitoring*	- is obtained. To apply for the license, [submit a request on Yida to enable value-added features for ApsaraVideo Player SDK for Web](https://yida.alibaba-inc.com/o/webplayer#/). For more information, see the description of the `license` parameter in the [API operations](~~125572#section-3ty-gwp-6pa~~) topic.
//
//         	- The log reporting feature is enabled. By default, the feature is enabled for ApsaraVideo Player SDKs.
//
// @param request - DescribeVodMediaPlayDataRequest
//
// @return DescribeVodMediaPlayDataResponse
func (client *Client) DescribeVodMediaPlayData(request *DescribeVodMediaPlayDataRequest) (_result *DescribeVodMediaPlayDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodMediaPlayDataResponse{}
	_body, _err := client.DescribeVodMediaPlayDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the bandwidth data by Internet service provider (ISP) and region.
//
// Description:
//
// The data is collected every 5 minutes. You can call this API operation up to 20 times per second per account. Time granularity
//
// The time granularity supported by Interval, the maximum time period within which historical data is available, and the data delay vary based on the time range to query, as described in the following table.
//
// |Time granularity|Maximum time range per query|Historical data available|Data delay|
//
// |---|---|---|---|
//
// |5 minutes|1 hour|93 days|15 minutes|
//
// @param request - DescribeVodRangeDataByLocateAndIspServiceRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodRangeDataByLocateAndIspServiceResponse
func (client *Client) DescribeVodRangeDataByLocateAndIspServiceWithOptions(request *DescribeVodRangeDataByLocateAndIspServiceRequest, runtime *util.RuntimeOptions) (_result *DescribeVodRangeDataByLocateAndIspServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodRangeDataByLocateAndIspService"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodRangeDataByLocateAndIspServiceResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodRangeDataByLocateAndIspServiceResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the bandwidth data by Internet service provider (ISP) and region.
//
// Description:
//
// The data is collected every 5 minutes. You can call this API operation up to 20 times per second per account. Time granularity
//
// The time granularity supported by Interval, the maximum time period within which historical data is available, and the data delay vary based on the time range to query, as described in the following table.
//
// |Time granularity|Maximum time range per query|Historical data available|Data delay|
//
// |---|---|---|---|
//
// |5 minutes|1 hour|93 days|15 minutes|
//
// @param request - DescribeVodRangeDataByLocateAndIspServiceRequest
//
// @return DescribeVodRangeDataByLocateAndIspServiceResponse
func (client *Client) DescribeVodRangeDataByLocateAndIspService(request *DescribeVodRangeDataByLocateAndIspServiceRequest) (_result *DescribeVodRangeDataByLocateAndIspServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodRangeDataByLocateAndIspServiceResponse{}
	_body, _err := client.DescribeVodRangeDataByLocateAndIspServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the maximum number and remaining number of requests to refresh or prefetch files on the current day. You can prefetch files based on URLs and refresh files based on URLs or directories.
//
// Description:
//
// > 	- This operation is available only in the **China (Shanghai)*	- region.
//
// > 	- You can call the [RefreshVodObjectCaches](https://help.aliyun.com/document_detail/69215.html) operation to refresh content and the [PreloadVodObjectCaches](https://help.aliyun.com/document_detail/69211.html) operation to prefetch content.
//
// @param request - DescribeVodRefreshQuotaRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodRefreshQuotaResponse
func (client *Client) DescribeVodRefreshQuotaWithOptions(request *DescribeVodRefreshQuotaRequest, runtime *util.RuntimeOptions) (_result *DescribeVodRefreshQuotaResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodRefreshQuota"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodRefreshQuotaResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodRefreshQuotaResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the maximum number and remaining number of requests to refresh or prefetch files on the current day. You can prefetch files based on URLs and refresh files based on URLs or directories.
//
// Description:
//
// > 	- This operation is available only in the **China (Shanghai)*	- region.
//
// > 	- You can call the [RefreshVodObjectCaches](https://help.aliyun.com/document_detail/69215.html) operation to refresh content and the [PreloadVodObjectCaches](https://help.aliyun.com/document_detail/69211.html) operation to prefetch content.
//
// @param request - DescribeVodRefreshQuotaRequest
//
// @return DescribeVodRefreshQuotaResponse
func (client *Client) DescribeVodRefreshQuota(request *DescribeVodRefreshQuotaRequest) (_result *DescribeVodRefreshQuotaResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodRefreshQuotaResponse{}
	_body, _err := client.DescribeVodRefreshQuotaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the information about one or more refresh or prefetch tasks.
//
// Description:
//
//   This operation is available only in the **China (Shanghai)*	- region.
//
// 	- If you do not specify the TaskId or ObjectPath parameter, the data in the last three days is returned on the first page. By default, one page displays a maximum of 20 entries. You can specify the TaskId and ObjectPath parameters at the same time.
//
// @param request - DescribeVodRefreshTasksRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodRefreshTasksResponse
func (client *Client) DescribeVodRefreshTasksWithOptions(request *DescribeVodRefreshTasksRequest, runtime *util.RuntimeOptions) (_result *DescribeVodRefreshTasksResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.ObjectPath)) {
		query["ObjectPath"] = request.ObjectPath
	}

	if !tea.BoolValue(util.IsUnset(request.ObjectType)) {
		query["ObjectType"] = request.ObjectType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodRefreshTasks"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodRefreshTasksResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodRefreshTasksResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the information about one or more refresh or prefetch tasks.
//
// Description:
//
//   This operation is available only in the **China (Shanghai)*	- region.
//
// 	- If you do not specify the TaskId or ObjectPath parameter, the data in the last three days is returned on the first page. By default, one page displays a maximum of 20 entries. You can specify the TaskId and ObjectPath parameters at the same time.
//
// @param request - DescribeVodRefreshTasksRequest
//
// @return DescribeVodRefreshTasksResponse
func (client *Client) DescribeVodRefreshTasks(request *DescribeVodRefreshTasksRequest) (_result *DescribeVodRefreshTasksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodRefreshTasksResponse{}
	_body, _err := client.DescribeVodRefreshTasksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the certificates by domain name.
//
// @param request - DescribeVodSSLCertificateListRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodSSLCertificateListResponse
func (client *Client) DescribeVodSSLCertificateListWithOptions(request *DescribeVodSSLCertificateListRequest, runtime *util.RuntimeOptions) (_result *DescribeVodSSLCertificateListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SearchKeyword)) {
		query["SearchKeyword"] = request.SearchKeyword
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodSSLCertificateList"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodSSLCertificateListResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodSSLCertificateListResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the certificates by domain name.
//
// @param request - DescribeVodSSLCertificateListRequest
//
// @return DescribeVodSSLCertificateListResponse
func (client *Client) DescribeVodSSLCertificateList(request *DescribeVodSSLCertificateListRequest) (_result *DescribeVodSSLCertificateListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodSSLCertificateListResponse{}
	_body, _err := client.DescribeVodSSLCertificateListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the usage of storage-related resources, including the storage volume and outbound traffic.
//
// Description:
//
// > 	- This operation is available only in the **China (Shanghai)*	- region.
//
// >	- If the time range to query is less than or equal to seven days, the system returns the statistics collected on an hourly basis. If the time range to query is greater than seven days, the system returns the statistics collected on a daily basis. The maximum time range that you can specify to query is 31 days.
//
// @param request - DescribeVodStorageDataRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodStorageDataResponse
func (client *Client) DescribeVodStorageDataWithOptions(request *DescribeVodStorageDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodStorageDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Storage)) {
		query["Storage"] = request.Storage
	}

	if !tea.BoolValue(util.IsUnset(request.StorageType)) {
		query["StorageType"] = request.StorageType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodStorageData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodStorageDataResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodStorageDataResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the usage of storage-related resources, including the storage volume and outbound traffic.
//
// Description:
//
// > 	- This operation is available only in the **China (Shanghai)*	- region.
//
// >	- If the time range to query is less than or equal to seven days, the system returns the statistics collected on an hourly basis. If the time range to query is greater than seven days, the system returns the statistics collected on a daily basis. The maximum time range that you can specify to query is 31 days.
//
// @param request - DescribeVodStorageDataRequest
//
// @return DescribeVodStorageDataResponse
func (client *Client) DescribeVodStorageData(request *DescribeVodStorageDataRequest) (_result *DescribeVodStorageDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodStorageDataResponse{}
	_body, _err := client.DescribeVodStorageDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the usage of tiered storage for media assets.
//
// Description:
//
//   This operation is available only in the **China (Shanghai)*	- region.
//
// 	- If you specify a time range within 7 days, the request returns the data based on hours. If you specify a time range longer than 7 days, the request returns the data based on days. The maximum time range is 31 days.
//
// @param request - DescribeVodTieringStorageDataRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodTieringStorageDataResponse
func (client *Client) DescribeVodTieringStorageDataWithOptions(request *DescribeVodTieringStorageDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodTieringStorageDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.StorageClass)) {
		query["StorageClass"] = request.StorageClass
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodTieringStorageData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodTieringStorageDataResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodTieringStorageDataResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the usage of tiered storage for media assets.
//
// Description:
//
//   This operation is available only in the **China (Shanghai)*	- region.
//
// 	- If you specify a time range within 7 days, the request returns the data based on hours. If you specify a time range longer than 7 days, the request returns the data based on days. The maximum time range is 31 days.
//
// @param request - DescribeVodTieringStorageDataRequest
//
// @return DescribeVodTieringStorageDataResponse
func (client *Client) DescribeVodTieringStorageData(request *DescribeVodTieringStorageDataRequest) (_result *DescribeVodTieringStorageDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodTieringStorageDataResponse{}
	_body, _err := client.DescribeVodTieringStorageDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the data retrieval from tiered storage.
//
// Description:
//
//   This operation is available only in the **China (Shanghai)*	- region.
//
// 	- If you specify a time range within 7 days, the request returns the data based on hours. If you specify a time range longer than 7 days, the request returns the data based on days. The maximum time range is 31 days.
//
// @param request - DescribeVodTieringStorageRetrievalDataRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodTieringStorageRetrievalDataResponse
func (client *Client) DescribeVodTieringStorageRetrievalDataWithOptions(request *DescribeVodTieringStorageRetrievalDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodTieringStorageRetrievalDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.StorageClass)) {
		query["StorageClass"] = request.StorageClass
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodTieringStorageRetrievalData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodTieringStorageRetrievalDataResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodTieringStorageRetrievalDataResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the data retrieval from tiered storage.
//
// Description:
//
//   This operation is available only in the **China (Shanghai)*	- region.
//
// 	- If you specify a time range within 7 days, the request returns the data based on hours. If you specify a time range longer than 7 days, the request returns the data based on days. The maximum time range is 31 days.
//
// @param request - DescribeVodTieringStorageRetrievalDataRequest
//
// @return DescribeVodTieringStorageRetrievalDataResponse
func (client *Client) DescribeVodTieringStorageRetrievalData(request *DescribeVodTieringStorageRetrievalDataRequest) (_result *DescribeVodTieringStorageRetrievalDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodTieringStorageRetrievalDataResponse{}
	_body, _err := client.DescribeVodTieringStorageRetrievalDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the transcoding statistics.
//
// Description:
//
//   This operation is available only in the **China (Shanghai)*	- region.
//
// 	- If the time range to query is less than or equal to seven days, the system returns the statistics collected on an hourly basis. If the time range to query is greater than seven days, the system returns the statistics collected on a daily basis. The maximum time range that you can specify to query is 31 days.
//
// @param request - DescribeVodTranscodeDataRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodTranscodeDataResponse
func (client *Client) DescribeVodTranscodeDataWithOptions(request *DescribeVodTranscodeDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodTranscodeDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.Specification)) {
		query["Specification"] = request.Specification
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Storage)) {
		query["Storage"] = request.Storage
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodTranscodeData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodTranscodeDataResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodTranscodeDataResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the transcoding statistics.
//
// Description:
//
//   This operation is available only in the **China (Shanghai)*	- region.
//
// 	- If the time range to query is less than or equal to seven days, the system returns the statistics collected on an hourly basis. If the time range to query is greater than seven days, the system returns the statistics collected on a daily basis. The maximum time range that you can specify to query is 31 days.
//
// @param request - DescribeVodTranscodeDataRequest
//
// @return DescribeVodTranscodeDataResponse
func (client *Client) DescribeVodTranscodeData(request *DescribeVodTranscodeDataRequest) (_result *DescribeVodTranscodeDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodTranscodeDataResponse{}
	_body, _err := client.DescribeVodTranscodeDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the domain names for CDN within your Alibaba Cloud account.
//
// Description:
//
//   You can filter domain names by name and status. Fuzzy match is supported for domain name-based query.
//
// 	- This operation is available only in the China (Shanghai) region.
//
// @param request - DescribeVodUserDomainsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodUserDomainsResponse
func (client *Client) DescribeVodUserDomainsWithOptions(request *DescribeVodUserDomainsRequest, runtime *util.RuntimeOptions) (_result *DescribeVodUserDomainsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.DomainSearchType)) {
		query["DomainSearchType"] = request.DomainSearchType
	}

	if !tea.BoolValue(util.IsUnset(request.DomainStatus)) {
		query["DomainStatus"] = request.DomainStatus
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodUserDomains"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodUserDomainsResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodUserDomainsResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the domain names for CDN within your Alibaba Cloud account.
//
// Description:
//
//   You can filter domain names by name and status. Fuzzy match is supported for domain name-based query.
//
// 	- This operation is available only in the China (Shanghai) region.
//
// @param request - DescribeVodUserDomainsRequest
//
// @return DescribeVodUserDomainsResponse
func (client *Client) DescribeVodUserDomains(request *DescribeVodUserDomainsRequest) (_result *DescribeVodUserDomainsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodUserDomainsResponse{}
	_body, _err := client.DescribeVodUserDomainsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the ownership verification content.
//
// Description:
//
//   This operation is available only in the **China (Shanghai)*	- region.
//
// @param request - DescribeVodVerifyContentRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DescribeVodVerifyContentResponse
func (client *Client) DescribeVodVerifyContentWithOptions(request *DescribeVodVerifyContentRequest, runtime *util.RuntimeOptions) (_result *DescribeVodVerifyContentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodVerifyContent"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DescribeVodVerifyContentResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DescribeVodVerifyContentResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the ownership verification content.
//
// Description:
//
//   This operation is available only in the **China (Shanghai)*	- region.
//
// @param request - DescribeVodVerifyContentRequest
//
// @return DescribeVodVerifyContentResponse
func (client *Client) DescribeVodVerifyContent(request *DescribeVodVerifyContentRequest) (_result *DescribeVodVerifyContentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodVerifyContentResponse{}
	_body, _err := client.DescribeVodVerifyContentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Revokes application permissions from the specified identity. The identity may a RAM user or RAM role.
//
// Description:
//
// >  You can grant a maximum of 10 application permissions to a RAM user or RAM role.
//
// @param request - DetachAppPolicyFromIdentityRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return DetachAppPolicyFromIdentityResponse
func (client *Client) DetachAppPolicyFromIdentityWithOptions(request *DetachAppPolicyFromIdentityRequest, runtime *util.RuntimeOptions) (_result *DetachAppPolicyFromIdentityResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.IdentityName)) {
		query["IdentityName"] = request.IdentityName
	}

	if !tea.BoolValue(util.IsUnset(request.IdentityType)) {
		query["IdentityType"] = request.IdentityType
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyNames)) {
		query["PolicyNames"] = request.PolicyNames
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DetachAppPolicyFromIdentity"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &DetachAppPolicyFromIdentityResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &DetachAppPolicyFromIdentityResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Revokes application permissions from the specified identity. The identity may a RAM user or RAM role.
//
// Description:
//
// >  You can grant a maximum of 10 application permissions to a RAM user or RAM role.
//
// @param request - DetachAppPolicyFromIdentityRequest
//
// @return DetachAppPolicyFromIdentityResponse
func (client *Client) DetachAppPolicyFromIdentity(request *DetachAppPolicyFromIdentityRequest) (_result *DetachAppPolicyFromIdentityResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DetachAppPolicyFromIdentityResponse{}
	_body, _err := client.DetachAppPolicyFromIdentityWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Generates a key for secure download. ApsaraVideo Player SDK provides the secure download feature. Videos that are downloaded to your local device in this mode are encrypted. You can play the encrypted videos only by using the key file generated from the app that you specified. Secure download protects your videos from malicious playback or distribution.
//
// Description:
//
//   To use the secure download feature, you must enable the download feature in the ApsaraVideo VOD console and set the download method to secure download. For more information, see [Configure download settings](https://help.aliyun.com/document_detail/86107.html).
//
// 	- After you generate a key for secure download, you must configure the key in ApsaraVideo Player SDK. For more information, see [Secure download](https://help.aliyun.com/document_detail/124735.html).
//
// @param request - GenerateDownloadSecretKeyRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GenerateDownloadSecretKeyResponse
func (client *Client) GenerateDownloadSecretKeyWithOptions(request *GenerateDownloadSecretKeyRequest, runtime *util.RuntimeOptions) (_result *GenerateDownloadSecretKeyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppDecryptKey)) {
		query["AppDecryptKey"] = request.AppDecryptKey
	}

	if !tea.BoolValue(util.IsUnset(request.AppIdentification)) {
		query["AppIdentification"] = request.AppIdentification
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GenerateDownloadSecretKey"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GenerateDownloadSecretKeyResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GenerateDownloadSecretKeyResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Generates a key for secure download. ApsaraVideo Player SDK provides the secure download feature. Videos that are downloaded to your local device in this mode are encrypted. You can play the encrypted videos only by using the key file generated from the app that you specified. Secure download protects your videos from malicious playback or distribution.
//
// Description:
//
//   To use the secure download feature, you must enable the download feature in the ApsaraVideo VOD console and set the download method to secure download. For more information, see [Configure download settings](https://help.aliyun.com/document_detail/86107.html).
//
// 	- After you generate a key for secure download, you must configure the key in ApsaraVideo Player SDK. For more information, see [Secure download](https://help.aliyun.com/document_detail/124735.html).
//
// @param request - GenerateDownloadSecretKeyRequest
//
// @return GenerateDownloadSecretKeyResponse
func (client *Client) GenerateDownloadSecretKey(request *GenerateDownloadSecretKeyRequest) (_result *GenerateDownloadSecretKeyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GenerateDownloadSecretKeyResponse{}
	_body, _err := client.GenerateDownloadSecretKeyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Generates a random Key Management Service (KMS) data key used for HLS encryption in ApsaraVideo VOD.
//
// @param request - GenerateKMSDataKeyRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GenerateKMSDataKeyResponse
func (client *Client) GenerateKMSDataKeyWithOptions(request *GenerateKMSDataKeyRequest, runtime *util.RuntimeOptions) (_result *GenerateKMSDataKeyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GenerateKMSDataKey"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GenerateKMSDataKeyResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GenerateKMSDataKeyResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Generates a random Key Management Service (KMS) data key used for HLS encryption in ApsaraVideo VOD.
//
// @param request - GenerateKMSDataKeyRequest
//
// @return GenerateKMSDataKeyResponse
func (client *Client) GenerateKMSDataKey(request *GenerateKMSDataKeyRequest) (_result *GenerateKMSDataKeyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GenerateKMSDataKeyResponse{}
	_body, _err := client.GenerateKMSDataKeyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries jobs of image AI processing.
//
// Description:
//
//   Regions that support this operation: **China (Beijing)*	- and **China (Shanghai)**.
//
// 	- Call the [SubmitAIImageJob](~~SubmitAIImageJob~~) operation to submit image AI processing jobs before you call this operation to query image AI processing jobs.
//
// 	- You can query a maximum of 10 jobs of image AI processing in one request.
//
// @param request - GetAIImageJobsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetAIImageJobsResponse
func (client *Client) GetAIImageJobsWithOptions(request *GetAIImageJobsRequest, runtime *util.RuntimeOptions) (_result *GetAIImageJobsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.JobIds)) {
		query["JobIds"] = request.JobIds
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAIImageJobs"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetAIImageJobsResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetAIImageJobsResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries jobs of image AI processing.
//
// Description:
//
//   Regions that support this operation: **China (Beijing)*	- and **China (Shanghai)**.
//
// 	- Call the [SubmitAIImageJob](~~SubmitAIImageJob~~) operation to submit image AI processing jobs before you call this operation to query image AI processing jobs.
//
// 	- You can query a maximum of 10 jobs of image AI processing in one request.
//
// @param request - GetAIImageJobsRequest
//
// @return GetAIImageJobsResponse
func (client *Client) GetAIImageJobs(request *GetAIImageJobsRequest) (_result *GetAIImageJobsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAIImageJobsResponse{}
	_body, _err := client.GetAIImageJobsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the information about an intelligent review job. After the job is submitted, it is processed asynchronously. You can call this operation to query the job information in real time.
//
// Description:
//
// ApsaraVideo VOD stores the snapshots of the intelligent review results free of charge for two weeks. After this period, the snapshots are automatically deleted.
//
// @param request - GetAIMediaAuditJobRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetAIMediaAuditJobResponse
func (client *Client) GetAIMediaAuditJobWithOptions(request *GetAIMediaAuditJobRequest, runtime *util.RuntimeOptions) (_result *GetAIMediaAuditJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.JobId)) {
		query["JobId"] = request.JobId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAIMediaAuditJob"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetAIMediaAuditJobResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetAIMediaAuditJobResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the information about an intelligent review job. After the job is submitted, it is processed asynchronously. You can call this operation to query the job information in real time.
//
// Description:
//
// ApsaraVideo VOD stores the snapshots of the intelligent review results free of charge for two weeks. After this period, the snapshots are automatically deleted.
//
// @param request - GetAIMediaAuditJobRequest
//
// @return GetAIMediaAuditJobResponse
func (client *Client) GetAIMediaAuditJob(request *GetAIMediaAuditJobRequest) (_result *GetAIMediaAuditJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAIMediaAuditJobResponse{}
	_body, _err := client.GetAIMediaAuditJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the details of an AI template.
//
// Description:
//
//   Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
//
// 	- Before you call this operation to query details of an AI template, you must obtain the ID of the AI template.
//
// @param request - GetAITemplateRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetAITemplateResponse
func (client *Client) GetAITemplateWithOptions(request *GetAITemplateRequest, runtime *util.RuntimeOptions) (_result *GetAITemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		query["TemplateId"] = request.TemplateId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAITemplate"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetAITemplateResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetAITemplateResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the details of an AI template.
//
// Description:
//
//   Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
//
// 	- Before you call this operation to query details of an AI template, you must obtain the ID of the AI template.
//
// @param request - GetAITemplateRequest
//
// @return GetAITemplateResponse
func (client *Client) GetAITemplate(request *GetAITemplateRequest) (_result *GetAITemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAITemplateResponse{}
	_body, _err := client.GetAITemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the results of smart tagging jobs.
//
// Description:
//
//   Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
//
// 	- You can obtain the smart tagging results by using the video ID.
//
// @param request - GetAIVideoTagResultRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetAIVideoTagResultResponse
func (client *Client) GetAIVideoTagResultWithOptions(request *GetAIVideoTagResultRequest, runtime *util.RuntimeOptions) (_result *GetAIVideoTagResultResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaId)) {
		query["MediaId"] = request.MediaId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAIVideoTagResult"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetAIVideoTagResultResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetAIVideoTagResultResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the results of smart tagging jobs.
//
// Description:
//
//   Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
//
// 	- You can obtain the smart tagging results by using the video ID.
//
// @param request - GetAIVideoTagResultRequest
//
// @return GetAIVideoTagResultResponse
func (client *Client) GetAIVideoTagResult(request *GetAIVideoTagResultRequest) (_result *GetAIVideoTagResultResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAIVideoTagResultResponse{}
	_body, _err := client.GetAIVideoTagResultWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the information about one or more applications based on application IDs.
//
// Description:
//
// You can specify multiple accelerated domain names in a request.
//
// @param request - GetAppInfosRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetAppInfosResponse
func (client *Client) GetAppInfosWithOptions(request *GetAppInfosRequest, runtime *util.RuntimeOptions) (_result *GetAppInfosResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppIds)) {
		query["AppIds"] = request.AppIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAppInfos"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetAppInfosResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetAppInfosResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the information about one or more applications based on application IDs.
//
// Description:
//
// You can specify multiple accelerated domain names in a request.
//
// @param request - GetAppInfosRequest
//
// @return GetAppInfosResponse
func (client *Client) GetAppInfos(request *GetAppInfosRequest) (_result *GetAppInfosResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAppInfosResponse{}
	_body, _err := client.GetAppInfosWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the URL and basic information about one or more auxiliary media assets such as watermark images, subtitle files, and materials based on IDs.
//
// Description:
//
// You can query information about up to 20 auxiliary media assets in a request.
//
// @param request - GetAttachedMediaInfoRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetAttachedMediaInfoResponse
func (client *Client) GetAttachedMediaInfoWithOptions(request *GetAttachedMediaInfoRequest, runtime *util.RuntimeOptions) (_result *GetAttachedMediaInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AuthTimeout)) {
		query["AuthTimeout"] = request.AuthTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.MediaIds)) {
		query["MediaIds"] = request.MediaIds
	}

	if !tea.BoolValue(util.IsUnset(request.OutputType)) {
		query["OutputType"] = request.OutputType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAttachedMediaInfo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetAttachedMediaInfoResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetAttachedMediaInfoResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the URL and basic information about one or more auxiliary media assets such as watermark images, subtitle files, and materials based on IDs.
//
// Description:
//
// You can query information about up to 20 auxiliary media assets in a request.
//
// @param request - GetAttachedMediaInfoRequest
//
// @return GetAttachedMediaInfoResponse
func (client *Client) GetAttachedMediaInfo(request *GetAttachedMediaInfoRequest) (_result *GetAttachedMediaInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAttachedMediaInfoResponse{}
	_body, _err := client.GetAttachedMediaInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the manual review history.
//
// @param request - GetAuditHistoryRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetAuditHistoryResponse
func (client *Client) GetAuditHistoryWithOptions(request *GetAuditHistoryRequest, runtime *util.RuntimeOptions) (_result *GetAuditHistoryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		query["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SortBy)) {
		query["SortBy"] = request.SortBy
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAuditHistory"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetAuditHistoryResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetAuditHistoryResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the manual review history.
//
// @param request - GetAuditHistoryRequest
//
// @return GetAuditHistoryResponse
func (client *Client) GetAuditHistory(request *GetAuditHistoryRequest) (_result *GetAuditHistoryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAuditHistoryResponse{}
	_body, _err := client.GetAuditHistoryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the information about a specific category and its subcategories based on the ID or type of the category.
//
// @param request - GetCategoriesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetCategoriesResponse
func (client *Client) GetCategoriesWithOptions(request *GetCategoriesRequest, runtime *util.RuntimeOptions) (_result *GetCategoriesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CateId)) {
		query["CateId"] = request.CateId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		query["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SortBy)) {
		query["SortBy"] = request.SortBy
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetCategories"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetCategoriesResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetCategoriesResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the information about a specific category and its subcategories based on the ID or type of the category.
//
// @param request - GetCategoriesRequest
//
// @return GetCategoriesResponse
func (client *Client) GetCategories(request *GetCategoriesRequest) (_result *GetCategoriesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetCategoriesResponse{}
	_body, _err := client.GetCategoriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries information about the default AI template.
//
// Description:
//
//   Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
//
// 	- You can query information only about the default AI template for automated review.
//
// @param request - GetDefaultAITemplateRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetDefaultAITemplateResponse
func (client *Client) GetDefaultAITemplateWithOptions(request *GetDefaultAITemplateRequest, runtime *util.RuntimeOptions) (_result *GetDefaultAITemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TemplateType)) {
		query["TemplateType"] = request.TemplateType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDefaultAITemplate"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetDefaultAITemplateResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetDefaultAITemplateResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries information about the default AI template.
//
// Description:
//
//   Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
//
// 	- You can query information only about the default AI template for automated review.
//
// @param request - GetDefaultAITemplateRequest
//
// @return GetDefaultAITemplateResponse
func (client *Client) GetDefaultAITemplate(request *GetDefaultAITemplateRequest) (_result *GetDefaultAITemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDefaultAITemplateResponse{}
	_body, _err := client.GetDefaultAITemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the results of a digital watermark extraction job. You can call this operation to obtain information such as the job status and the content of the copyright or user-tracing watermark.
//
// Description:
//
//   This operation is supported only in the China (Shanghai) and China (Beijing) regions.
//
// 	- You can call this operation to query the watermark content after you call the [SubmitDigitalWatermarkExtractJob](~~SubmitDigitalWatermarkExtractJob~~) operation to extract the copyright or user-tracing watermark in a video.
//
// 	- You can query watermark content extracted only from watermark extraction jobs that are submitted in the last 2 years.
//
// @param request - GetDigitalWatermarkExtractResultRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetDigitalWatermarkExtractResultResponse
func (client *Client) GetDigitalWatermarkExtractResultWithOptions(request *GetDigitalWatermarkExtractResultRequest, runtime *util.RuntimeOptions) (_result *GetDigitalWatermarkExtractResultResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ExtractType)) {
		query["ExtractType"] = request.ExtractType
	}

	if !tea.BoolValue(util.IsUnset(request.JobId)) {
		query["JobId"] = request.JobId
	}

	if !tea.BoolValue(util.IsUnset(request.MediaId)) {
		query["MediaId"] = request.MediaId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDigitalWatermarkExtractResult"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetDigitalWatermarkExtractResultResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetDigitalWatermarkExtractResultResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the results of a digital watermark extraction job. You can call this operation to obtain information such as the job status and the content of the copyright or user-tracing watermark.
//
// Description:
//
//   This operation is supported only in the China (Shanghai) and China (Beijing) regions.
//
// 	- You can call this operation to query the watermark content after you call the [SubmitDigitalWatermarkExtractJob](~~SubmitDigitalWatermarkExtractJob~~) operation to extract the copyright or user-tracing watermark in a video.
//
// 	- You can query watermark content extracted only from watermark extraction jobs that are submitted in the last 2 years.
//
// @param request - GetDigitalWatermarkExtractResultRequest
//
// @return GetDigitalWatermarkExtractResultResponse
func (client *Client) GetDigitalWatermarkExtractResult(request *GetDigitalWatermarkExtractResultRequest) (_result *GetDigitalWatermarkExtractResultResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDigitalWatermarkExtractResultResponse{}
	_body, _err := client.GetDigitalWatermarkExtractResultWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// @param request - GetEditingProjectRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetEditingProjectResponse
func (client *Client) GetEditingProjectWithOptions(request *GetEditingProjectRequest, runtime *util.RuntimeOptions) (_result *GetEditingProjectResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetEditingProject"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetEditingProjectResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetEditingProjectResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// @param request - GetEditingProjectRequest
//
// @return GetEditingProjectResponse
func (client *Client) GetEditingProject(request *GetEditingProjectRequest) (_result *GetEditingProjectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetEditingProjectResponse{}
	_body, _err := client.GetEditingProjectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries materials to be edited for an online editing project.
//
// Description:
//
// During editing, you can add materials to the timeline, but some of them may not be used.
//
// @param request - GetEditingProjectMaterialsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetEditingProjectMaterialsResponse
func (client *Client) GetEditingProjectMaterialsWithOptions(request *GetEditingProjectMaterialsRequest, runtime *util.RuntimeOptions) (_result *GetEditingProjectMaterialsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaterialType)) {
		query["MaterialType"] = request.MaterialType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetEditingProjectMaterials"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetEditingProjectMaterialsResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetEditingProjectMaterialsResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries materials to be edited for an online editing project.
//
// Description:
//
// During editing, you can add materials to the timeline, but some of them may not be used.
//
// @param request - GetEditingProjectMaterialsRequest
//
// @return GetEditingProjectMaterialsResponse
func (client *Client) GetEditingProjectMaterials(request *GetEditingProjectMaterialsRequest) (_result *GetEditingProjectMaterialsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetEditingProjectMaterialsResponse{}
	_body, _err := client.GetEditingProjectMaterialsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the basic information and access URL of an image based on the image ID.
//
// @param request - GetImageInfoRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetImageInfoResponse
func (client *Client) GetImageInfoWithOptions(request *GetImageInfoRequest, runtime *util.RuntimeOptions) (_result *GetImageInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AuthTimeout)) {
		query["AuthTimeout"] = request.AuthTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.ImageId)) {
		query["ImageId"] = request.ImageId
	}

	if !tea.BoolValue(util.IsUnset(request.OutputType)) {
		query["OutputType"] = request.OutputType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetImageInfo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetImageInfoResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetImageInfoResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the basic information and access URL of an image based on the image ID.
//
// @param request - GetImageInfoRequest
//
// @return GetImageInfoResponse
func (client *Client) GetImageInfo(request *GetImageInfoRequest) (_result *GetImageInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetImageInfoResponse{}
	_body, _err := client.GetImageInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the basic information about multiple images at a time.
//
// Description:
//
//   You can call the [CreateUploadImage](~~CreateUploadImage~~) operation to upload images to ApsaraVideo VOD and call this operation to query the basic information about multiple images at a time.
//
// 	- To query information about video snapshots, call the [ListSnapshots](~~ListSnapshots~~) operation.
//
// 	- You can specify up to 20 image IDs in one call.
//
// @param request - GetImageInfosRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetImageInfosResponse
func (client *Client) GetImageInfosWithOptions(request *GetImageInfosRequest, runtime *util.RuntimeOptions) (_result *GetImageInfosResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AuthTimeout)) {
		query["AuthTimeout"] = request.AuthTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.ImageIds)) {
		query["ImageIds"] = request.ImageIds
	}

	if !tea.BoolValue(util.IsUnset(request.OutputType)) {
		query["OutputType"] = request.OutputType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetImageInfos"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetImageInfosResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetImageInfosResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the basic information about multiple images at a time.
//
// Description:
//
//   You can call the [CreateUploadImage](~~CreateUploadImage~~) operation to upload images to ApsaraVideo VOD and call this operation to query the basic information about multiple images at a time.
//
// 	- To query information about video snapshots, call the [ListSnapshots](~~ListSnapshots~~) operation.
//
// 	- You can specify up to 20 image IDs in one call.
//
// @param request - GetImageInfosRequest
//
// @return GetImageInfosResponse
func (client *Client) GetImageInfos(request *GetImageInfosRequest) (_result *GetImageInfosResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetImageInfosResponse{}
	_body, _err := client.GetImageInfosWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the details of an asynchronous task based on jobId.
//
// Description:
//
// ***
//
// You can call this operation to query only asynchronous tasks of the last six months. The types of tasks that you can query include transcoding tasks, snapshot tasks, and AI tasks.
//
// **QPS limit**
//
// You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/342790.html).
//
// @param request - GetJobDetailRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetJobDetailResponse
func (client *Client) GetJobDetailWithOptions(request *GetJobDetailRequest, runtime *util.RuntimeOptions) (_result *GetJobDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.JobId)) {
		query["JobId"] = request.JobId
	}

	if !tea.BoolValue(util.IsUnset(request.JobType)) {
		query["JobType"] = request.JobType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetJobDetail"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetJobDetailResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetJobDetailResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the details of an asynchronous task based on jobId.
//
// Description:
//
// ***
//
// You can call this operation to query only asynchronous tasks of the last six months. The types of tasks that you can query include transcoding tasks, snapshot tasks, and AI tasks.
//
// **QPS limit**
//
// You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/342790.html).
//
// @param request - GetJobDetailRequest
//
// @return GetJobDetailResponse
func (client *Client) GetJobDetail(request *GetJobDetailRequest) (_result *GetJobDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetJobDetailResponse{}
	_body, _err := client.GetJobDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the details of audio review results.
//
// Description:
//
// If notifications for the [CreateAuditComplete](https://help.aliyun.com/document_detail/89576.html) event are configured, event notifications are sent to the callback URL after automated review is complete. You can call this operation to query the details of audio review results.
//
// @param request - GetMediaAuditAudioResultDetailRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetMediaAuditAudioResultDetailResponse
func (client *Client) GetMediaAuditAudioResultDetailWithOptions(request *GetMediaAuditAudioResultDetailRequest, runtime *util.RuntimeOptions) (_result *GetMediaAuditAudioResultDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaId)) {
		query["MediaId"] = request.MediaId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		query["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMediaAuditAudioResultDetail"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetMediaAuditAudioResultDetailResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetMediaAuditAudioResultDetailResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the details of audio review results.
//
// Description:
//
// If notifications for the [CreateAuditComplete](https://help.aliyun.com/document_detail/89576.html) event are configured, event notifications are sent to the callback URL after automated review is complete. You can call this operation to query the details of audio review results.
//
// @param request - GetMediaAuditAudioResultDetailRequest
//
// @return GetMediaAuditAudioResultDetailResponse
func (client *Client) GetMediaAuditAudioResultDetail(request *GetMediaAuditAudioResultDetailRequest) (_result *GetMediaAuditAudioResultDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMediaAuditAudioResultDetailResponse{}
	_body, _err := client.GetMediaAuditAudioResultDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the summary of automated review results.
//
// @param request - GetMediaAuditResultRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetMediaAuditResultResponse
func (client *Client) GetMediaAuditResultWithOptions(request *GetMediaAuditResultRequest, runtime *util.RuntimeOptions) (_result *GetMediaAuditResultResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaId)) {
		query["MediaId"] = request.MediaId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMediaAuditResult"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetMediaAuditResultResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetMediaAuditResultResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the summary of automated review results.
//
// @param request - GetMediaAuditResultRequest
//
// @return GetMediaAuditResultResponse
func (client *Client) GetMediaAuditResult(request *GetMediaAuditResultRequest) (_result *GetMediaAuditResultResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMediaAuditResultResponse{}
	_body, _err := client.GetMediaAuditResultWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the details of automated review results. You can call this operation to query the details of review results in real time.
//
// Description:
//
//   By default, only details of snapshots that violate content regulations and potentially violate content regulations are returned.
//
// 	- ApsaraVideo VOD stores the snapshots in the automated review results free of charge for two weeks. After this period, the snapshots are automatically deleted.
//
// 	- This operation is available only in the Singapore region.
//
// @param request - GetMediaAuditResultDetailRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetMediaAuditResultDetailResponse
func (client *Client) GetMediaAuditResultDetailWithOptions(request *GetMediaAuditResultDetailRequest, runtime *util.RuntimeOptions) (_result *GetMediaAuditResultDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaId)) {
		query["MediaId"] = request.MediaId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		query["PageNo"] = request.PageNo
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMediaAuditResultDetail"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetMediaAuditResultDetailResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetMediaAuditResultDetailResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the details of automated review results. You can call this operation to query the details of review results in real time.
//
// Description:
//
//   By default, only details of snapshots that violate content regulations and potentially violate content regulations are returned.
//
// 	- ApsaraVideo VOD stores the snapshots in the automated review results free of charge for two weeks. After this period, the snapshots are automatically deleted.
//
// 	- This operation is available only in the Singapore region.
//
// @param request - GetMediaAuditResultDetailRequest
//
// @return GetMediaAuditResultDetailResponse
func (client *Client) GetMediaAuditResultDetail(request *GetMediaAuditResultDetailRequest) (_result *GetMediaAuditResultDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMediaAuditResultDetailResponse{}
	_body, _err := client.GetMediaAuditResultDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the timelines of all snapshots that violate content regulations.
//
// Description:
//
// >  By default, only details of snapshots that violate content regulations and potentially violate content regulations are returned.
//
// This operation is available only in the Singapore region.
//
// @param request - GetMediaAuditResultTimelineRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetMediaAuditResultTimelineResponse
func (client *Client) GetMediaAuditResultTimelineWithOptions(request *GetMediaAuditResultTimelineRequest, runtime *util.RuntimeOptions) (_result *GetMediaAuditResultTimelineResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaId)) {
		query["MediaId"] = request.MediaId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMediaAuditResultTimeline"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetMediaAuditResultTimelineResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetMediaAuditResultTimelineResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the timelines of all snapshots that violate content regulations.
//
// Description:
//
// >  By default, only details of snapshots that violate content regulations and potentially violate content regulations are returned.
//
// This operation is available only in the Singapore region.
//
// @param request - GetMediaAuditResultTimelineRequest
//
// @return GetMediaAuditResultTimelineResponse
func (client *Client) GetMediaAuditResultTimeline(request *GetMediaAuditResultTimelineRequest) (_result *GetMediaAuditResultTimelineResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMediaAuditResultTimelineResponse{}
	_body, _err := client.GetMediaAuditResultTimelineWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries a media fingerprinting result. After a media fingerprinting job is complete, you can call this operation to query the media fingerprinting result.
//
// Description:
//
// Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
//
// @param request - GetMediaDNAResultRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetMediaDNAResultResponse
func (client *Client) GetMediaDNAResultWithOptions(request *GetMediaDNAResultRequest, runtime *util.RuntimeOptions) (_result *GetMediaDNAResultResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaId)) {
		query["MediaId"] = request.MediaId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMediaDNAResult"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetMediaDNAResultResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetMediaDNAResultResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries a media fingerprinting result. After a media fingerprinting job is complete, you can call this operation to query the media fingerprinting result.
//
// Description:
//
// Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
//
// @param request - GetMediaDNAResultRequest
//
// @return GetMediaDNAResultResponse
func (client *Client) GetMediaDNAResult(request *GetMediaDNAResultRequest) (_result *GetMediaDNAResultResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMediaDNAResultResponse{}
	_body, _err := client.GetMediaDNAResultWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the information about media refresh or prefetch jobs, such as the job status and filtering conditions.
//
// Description:
//
// You can query the information about all media files or a specific media file in a refresh or prefetch job.
//
// ### QPS limits
//
// You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations in ApsaraVideo VoD](https://help.aliyun.com/document_detail/342790.html).
//
// @param request - GetMediaRefreshJobsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetMediaRefreshJobsResponse
func (client *Client) GetMediaRefreshJobsWithOptions(request *GetMediaRefreshJobsRequest, runtime *util.RuntimeOptions) (_result *GetMediaRefreshJobsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMediaRefreshJobs"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetMediaRefreshJobsResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetMediaRefreshJobsResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the information about media refresh or prefetch jobs, such as the job status and filtering conditions.
//
// Description:
//
// You can query the information about all media files or a specific media file in a refresh or prefetch job.
//
// ### QPS limits
//
// You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations in ApsaraVideo VoD](https://help.aliyun.com/document_detail/342790.html).
//
// @param request - GetMediaRefreshJobsRequest
//
// @return GetMediaRefreshJobsResponse
func (client *Client) GetMediaRefreshJobs(request *GetMediaRefreshJobsRequest) (_result *GetMediaRefreshJobsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMediaRefreshJobsResponse{}
	_body, _err := client.GetMediaRefreshJobsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the callback method, callback URL, and event type for event notifications.
//
// Description:
//
// > For more information, see [Event notification](https://help.aliyun.com/document_detail/55627.html).
//
// @param request - GetMessageCallbackRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetMessageCallbackResponse
func (client *Client) GetMessageCallbackWithOptions(request *GetMessageCallbackRequest, runtime *util.RuntimeOptions) (_result *GetMessageCallbackResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMessageCallback"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetMessageCallbackResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetMessageCallbackResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the callback method, callback URL, and event type for event notifications.
//
// Description:
//
// > For more information, see [Event notification](https://help.aliyun.com/document_detail/55627.html).
//
// @param request - GetMessageCallbackRequest
//
// @return GetMessageCallbackResponse
func (client *Client) GetMessageCallback(request *GetMessageCallbackRequest) (_result *GetMessageCallbackResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMessageCallbackResponse{}
	_body, _err := client.GetMessageCallbackWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the information about the mezzanine file of an audio or video. The information includes the mezzanine file URL, resolution, and bitrate of the audio or video.
//
// Description:
//
// You can obtain complete information about the source file only after a stream is transcoded.
//
// @param request - GetMezzanineInfoRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetMezzanineInfoResponse
func (client *Client) GetMezzanineInfoWithOptions(request *GetMezzanineInfoRequest, runtime *util.RuntimeOptions) (_result *GetMezzanineInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AdditionType)) {
		query["AdditionType"] = request.AdditionType
	}

	if !tea.BoolValue(util.IsUnset(request.AuthTimeout)) {
		query["AuthTimeout"] = request.AuthTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.OutputType)) {
		query["OutputType"] = request.OutputType
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMezzanineInfo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetMezzanineInfoResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetMezzanineInfoResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the information about the mezzanine file of an audio or video. The information includes the mezzanine file URL, resolution, and bitrate of the audio or video.
//
// Description:
//
// You can obtain complete information about the source file only after a stream is transcoded.
//
// @param request - GetMezzanineInfoRequest
//
// @return GetMezzanineInfoResponse
func (client *Client) GetMezzanineInfo(request *GetMezzanineInfoRequest) (_result *GetMezzanineInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMezzanineInfoResponse{}
	_body, _err := client.GetMezzanineInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Obtains the playback URL by the audio or video ID. Then, you can use ApsaraVideo Player or a third-party player, such as a system player, open source player, orself-developed player, to play the audio or video.
//
// Description:
//
//   **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. You are charged for outbound traffic when you download or play videos based on URLs in ApsaraVideo VOD. For more information about billing of outbound traffic, see [Billing of outbound traffic](~~188308#section-rwh-e88-f7j~~). If you have configured an accelerated domain name, see [Billing of the acceleration service](~~188308#section-c5t-oq9-15e~~). If you have activated the acceleration service, you are charged acceleration fees when you upload media files to ApsaraVideo VOD. For more information, see [Billing of acceleration traffic](~~188310#section_sta_zm2_tsv~~).**
//
// 	- Only videos whose Status is Normal can be played. For more information, see [Overview](https://help.aliyun.com/document_detail/57290.html).
//
// 	- If video playback fails, you can call the [GetMezzanineInfo](~~GetMezzanineInfo~~) operation to check whether the video source information is correct.
//
// @param request - GetPlayInfoRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetPlayInfoResponse
func (client *Client) GetPlayInfoWithOptions(request *GetPlayInfoRequest, runtime *util.RuntimeOptions) (_result *GetPlayInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AdditionType)) {
		query["AdditionType"] = request.AdditionType
	}

	if !tea.BoolValue(util.IsUnset(request.AuthTimeout)) {
		query["AuthTimeout"] = request.AuthTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.Definition)) {
		query["Definition"] = request.Definition
	}

	if !tea.BoolValue(util.IsUnset(request.DigitalWatermarkType)) {
		query["DigitalWatermarkType"] = request.DigitalWatermarkType
	}

	if !tea.BoolValue(util.IsUnset(request.Formats)) {
		query["Formats"] = request.Formats
	}

	if !tea.BoolValue(util.IsUnset(request.OutputType)) {
		query["OutputType"] = request.OutputType
	}

	if !tea.BoolValue(util.IsUnset(request.PlayConfig)) {
		query["PlayConfig"] = request.PlayConfig
	}

	if !tea.BoolValue(util.IsUnset(request.ReAuthInfo)) {
		query["ReAuthInfo"] = request.ReAuthInfo
	}

	if !tea.BoolValue(util.IsUnset(request.ResultType)) {
		query["ResultType"] = request.ResultType
	}

	if !tea.BoolValue(util.IsUnset(request.StreamType)) {
		query["StreamType"] = request.StreamType
	}

	if !tea.BoolValue(util.IsUnset(request.Trace)) {
		query["Trace"] = request.Trace
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetPlayInfo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetPlayInfoResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetPlayInfoResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Obtains the playback URL by the audio or video ID. Then, you can use ApsaraVideo Player or a third-party player, such as a system player, open source player, orself-developed player, to play the audio or video.
//
// Description:
//
//   **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. You are charged for outbound traffic when you download or play videos based on URLs in ApsaraVideo VOD. For more information about billing of outbound traffic, see [Billing of outbound traffic](~~188308#section-rwh-e88-f7j~~). If you have configured an accelerated domain name, see [Billing of the acceleration service](~~188308#section-c5t-oq9-15e~~). If you have activated the acceleration service, you are charged acceleration fees when you upload media files to ApsaraVideo VOD. For more information, see [Billing of acceleration traffic](~~188310#section_sta_zm2_tsv~~).**
//
// 	- Only videos whose Status is Normal can be played. For more information, see [Overview](https://help.aliyun.com/document_detail/57290.html).
//
// 	- If video playback fails, you can call the [GetMezzanineInfo](~~GetMezzanineInfo~~) operation to check whether the video source information is correct.
//
// @param request - GetPlayInfoRequest
//
// @return GetPlayInfoResponse
func (client *Client) GetPlayInfo(request *GetPlayInfoRequest) (_result *GetPlayInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetPlayInfoResponse{}
	_body, _err := client.GetPlayInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries transcoding summaries of audio and video files based on the file ID. A transcoding summary includes the status and progress of transcoding.
//
// Description:
//
//   An audio or video file may be transcoded multiple times. This operation returns only the latest transcoding summary.
//
// 	- You can query transcoding summaries for a maximum of 10 audio and video files in one request.
//
// 	- You can call the [ListTranscodeTask](https://help.aliyun.com/document_detail/109120.html) operation to query historical transcoding tasks.
//
// 	- **You can call this operation to query information only about transcoding tasks created within the past year.
//
// @param request - GetTranscodeSummaryRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetTranscodeSummaryResponse
func (client *Client) GetTranscodeSummaryWithOptions(request *GetTranscodeSummaryRequest, runtime *util.RuntimeOptions) (_result *GetTranscodeSummaryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.VideoIds)) {
		query["VideoIds"] = request.VideoIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetTranscodeSummary"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetTranscodeSummaryResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetTranscodeSummaryResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries transcoding summaries of audio and video files based on the file ID. A transcoding summary includes the status and progress of transcoding.
//
// Description:
//
//   An audio or video file may be transcoded multiple times. This operation returns only the latest transcoding summary.
//
// 	- You can query transcoding summaries for a maximum of 10 audio and video files in one request.
//
// 	- You can call the [ListTranscodeTask](https://help.aliyun.com/document_detail/109120.html) operation to query historical transcoding tasks.
//
// 	- **You can call this operation to query information only about transcoding tasks created within the past year.
//
// @param request - GetTranscodeSummaryRequest
//
// @return GetTranscodeSummaryResponse
func (client *Client) GetTranscodeSummary(request *GetTranscodeSummaryRequest) (_result *GetTranscodeSummaryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetTranscodeSummaryResponse{}
	_body, _err := client.GetTranscodeSummaryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries details about transcoding jobs based on the transcoding task ID.
//
// Description:
//
// You can call this operation to query only transcoding tasks created within the past year.
//
// @param request - GetTranscodeTaskRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetTranscodeTaskResponse
func (client *Client) GetTranscodeTaskWithOptions(request *GetTranscodeTaskRequest, runtime *util.RuntimeOptions) (_result *GetTranscodeTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.JobIds)) {
		query["JobIds"] = request.JobIds
	}

	if !tea.BoolValue(util.IsUnset(request.TranscodeTaskId)) {
		query["TranscodeTaskId"] = request.TranscodeTaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetTranscodeTask"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetTranscodeTaskResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetTranscodeTaskResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries details about transcoding jobs based on the transcoding task ID.
//
// Description:
//
// You can call this operation to query only transcoding tasks created within the past year.
//
// @param request - GetTranscodeTaskRequest
//
// @return GetTranscodeTaskResponse
func (client *Client) GetTranscodeTask(request *GetTranscodeTaskRequest) (_result *GetTranscodeTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetTranscodeTaskResponse{}
	_body, _err := client.GetTranscodeTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the details of a transcoding template group based on the template group ID.
//
// Description:
//
// This operation returns information about the specified transcoding template group and the configurations of all the transcoding templates in the group.
//
// @param request - GetTranscodeTemplateGroupRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetTranscodeTemplateGroupResponse
func (client *Client) GetTranscodeTemplateGroupWithOptions(request *GetTranscodeTemplateGroupRequest, runtime *util.RuntimeOptions) (_result *GetTranscodeTemplateGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TranscodeTemplateGroupId)) {
		query["TranscodeTemplateGroupId"] = request.TranscodeTemplateGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetTranscodeTemplateGroup"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetTranscodeTemplateGroupResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetTranscodeTemplateGroupResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the details of a transcoding template group based on the template group ID.
//
// Description:
//
// This operation returns information about the specified transcoding template group and the configurations of all the transcoding templates in the group.
//
// @param request - GetTranscodeTemplateGroupRequest
//
// @return GetTranscodeTemplateGroupResponse
func (client *Client) GetTranscodeTemplateGroup(request *GetTranscodeTemplateGroupRequest) (_result *GetTranscodeTemplateGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetTranscodeTemplateGroupResponse{}
	_body, _err := client.GetTranscodeTemplateGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the information about URL-based upload jobs.
//
// Description:
//
// You can query the information about a URL-based upload job by specifying the upload URL or using the job ID returned when you upload media files. The information includes the status of the upload job, custom configurations, the time when the job was created, and the time when the job was complete.
//
// If the upload fails, you can view the error code and error message. If the upload is successful, you can obtain the video ID.
//
// @param request - GetURLUploadInfosRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetURLUploadInfosResponse
func (client *Client) GetURLUploadInfosWithOptions(request *GetURLUploadInfosRequest, runtime *util.RuntimeOptions) (_result *GetURLUploadInfosResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.JobIds)) {
		query["JobIds"] = request.JobIds
	}

	if !tea.BoolValue(util.IsUnset(request.UploadURLs)) {
		query["UploadURLs"] = request.UploadURLs
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetURLUploadInfos"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetURLUploadInfosResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetURLUploadInfosResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the information about URL-based upload jobs.
//
// Description:
//
// You can query the information about a URL-based upload job by specifying the upload URL or using the job ID returned when you upload media files. The information includes the status of the upload job, custom configurations, the time when the job was created, and the time when the job was complete.
//
// If the upload fails, you can view the error code and error message. If the upload is successful, you can obtain the video ID.
//
// @param request - GetURLUploadInfosRequest
//
// @return GetURLUploadInfosResponse
func (client *Client) GetURLUploadInfos(request *GetURLUploadInfosRequest) (_result *GetURLUploadInfosResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetURLUploadInfosResponse{}
	_body, _err := client.GetURLUploadInfosWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the upload details, such as the upload time, upload ratio, and upload source, about one or more media files based on the media IDs.
//
// Description:
//
//   You can call this operation to obtain the upload details only about audio and video files.
//
// 	- If you use the ApsaraVideo VOD console to upload audio and video files, you can call this operation to query information such as the upload ratio. If you use an upload SDK to upload audio and video files, make sure that the version of the [upload SDK](https://help.aliyun.com/document_detail/52200.html) meets one of the following requirements:
//
//     	- The version of the upload SDK for Java is 1.4.4 or later.
//
//     	- The version of the upload SDK for C++ is 1.0.0 or later.
//
//     	- The version of the upload SDK for PHP is 1.0.2 or later.
//
//     	- The version of the upload SDK for Python is 1.3.0 or later.
//
//     	- The version of the upload SDK for JavaScript is 1.4.0 or later.
//
//     	- The version of the upload SDK for Android is 1.5.0 or later.
//
//     	- The version of the upload SDK for iOS is 1.5.0 or later.
//
// @param request - GetUploadDetailsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetUploadDetailsResponse
func (client *Client) GetUploadDetailsWithOptions(request *GetUploadDetailsRequest, runtime *util.RuntimeOptions) (_result *GetUploadDetailsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaIds)) {
		query["MediaIds"] = request.MediaIds
	}

	if !tea.BoolValue(util.IsUnset(request.MediaType)) {
		query["MediaType"] = request.MediaType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetUploadDetails"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetUploadDetailsResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetUploadDetailsResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the upload details, such as the upload time, upload ratio, and upload source, about one or more media files based on the media IDs.
//
// Description:
//
//   You can call this operation to obtain the upload details only about audio and video files.
//
// 	- If you use the ApsaraVideo VOD console to upload audio and video files, you can call this operation to query information such as the upload ratio. If you use an upload SDK to upload audio and video files, make sure that the version of the [upload SDK](https://help.aliyun.com/document_detail/52200.html) meets one of the following requirements:
//
//     	- The version of the upload SDK for Java is 1.4.4 or later.
//
//     	- The version of the upload SDK for C++ is 1.0.0 or later.
//
//     	- The version of the upload SDK for PHP is 1.0.2 or later.
//
//     	- The version of the upload SDK for Python is 1.3.0 or later.
//
//     	- The version of the upload SDK for JavaScript is 1.4.0 or later.
//
//     	- The version of the upload SDK for Android is 1.5.0 or later.
//
//     	- The version of the upload SDK for iOS is 1.5.0 or later.
//
// @param request - GetUploadDetailsRequest
//
// @return GetUploadDetailsResponse
func (client *Client) GetUploadDetails(request *GetUploadDetailsRequest) (_result *GetUploadDetailsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetUploadDetailsResponse{}
	_body, _err := client.GetUploadDetailsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Obtains the title, description, duration, thumbnail URL, status, creation time, size, snapshots, category, and tags of a media file based on the file ID.
//
// Description:
//
// After a media file is uploaded, ApsaraVideo VOD processes the source file. Then, information about the media file is asynchronously generated. You can configure notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event and call this operation to query information about a media file after you receive notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event. For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
//
// @param request - GetVideoInfoRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetVideoInfoResponse
func (client *Client) GetVideoInfoWithOptions(request *GetVideoInfoRequest, runtime *util.RuntimeOptions) (_result *GetVideoInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetVideoInfo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetVideoInfoResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetVideoInfoResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Obtains the title, description, duration, thumbnail URL, status, creation time, size, snapshots, category, and tags of a media file based on the file ID.
//
// Description:
//
// After a media file is uploaded, ApsaraVideo VOD processes the source file. Then, information about the media file is asynchronously generated. You can configure notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event and call this operation to query information about a media file after you receive notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event. For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
//
// @param request - GetVideoInfoRequest
//
// @return GetVideoInfoResponse
func (client *Client) GetVideoInfo(request *GetVideoInfoRequest) (_result *GetVideoInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetVideoInfoResponse{}
	_body, _err := client.GetVideoInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries information such as the title, description, duration, thumbnail URL, status, creation time, size, snapshots, category, and tags about multiple audio or video files based on IDs.
//
// Description:
//
//   You can specify up to 20 audio or video file IDs in each request.
//
// 	- After a media file is uploaded, ApsaraVideo VOD processes the source file. Then, information about the media file is asynchronously generated. You can configure notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event and call this operation to query information about a media file after you receive notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event. For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
//
// @param request - GetVideoInfosRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetVideoInfosResponse
func (client *Client) GetVideoInfosWithOptions(request *GetVideoInfosRequest, runtime *util.RuntimeOptions) (_result *GetVideoInfosResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.VideoIds)) {
		query["VideoIds"] = request.VideoIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetVideoInfos"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetVideoInfosResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetVideoInfosResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries information such as the title, description, duration, thumbnail URL, status, creation time, size, snapshots, category, and tags about multiple audio or video files based on IDs.
//
// Description:
//
//   You can specify up to 20 audio or video file IDs in each request.
//
// 	- After a media file is uploaded, ApsaraVideo VOD processes the source file. Then, information about the media file is asynchronously generated. You can configure notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event and call this operation to query information about a media file after you receive notifications for the [VideoAnalysisComplete](https://help.aliyun.com/document_detail/99935.html) event. For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
//
// @param request - GetVideoInfosRequest
//
// @return GetVideoInfosResponse
func (client *Client) GetVideoInfos(request *GetVideoInfosRequest) (_result *GetVideoInfosResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetVideoInfosResponse{}
	_body, _err := client.GetVideoInfosWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries information about media files.
//
// Description:
//
// You can call this operation to query information about media files based on the filter conditions that you specify, such as video status and category ID. Information about a maximum of **5,000*	- media files can be returned for each request. We recommend that you set the StartTime and EndTime parameters to specify a time range for each request. For more information about how to query information about more media files or even all media files, see [SearchMedia](https://help.aliyun.com/document_detail/86044.html).
//
// @param request - GetVideoListRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetVideoListResponse
func (client *Client) GetVideoListWithOptions(request *GetVideoListRequest, runtime *util.RuntimeOptions) (_result *GetVideoListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CateId)) {
		query["CateId"] = request.CateId
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		query["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SortBy)) {
		query["SortBy"] = request.SortBy
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.StorageLocation)) {
		query["StorageLocation"] = request.StorageLocation
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetVideoList"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetVideoListResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetVideoListResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries information about media files.
//
// Description:
//
// You can call this operation to query information about media files based on the filter conditions that you specify, such as video status and category ID. Information about a maximum of **5,000*	- media files can be returned for each request. We recommend that you set the StartTime and EndTime parameters to specify a time range for each request. For more information about how to query information about more media files or even all media files, see [SearchMedia](https://help.aliyun.com/document_detail/86044.html).
//
// @param request - GetVideoListRequest
//
// @return GetVideoListResponse
func (client *Client) GetVideoList(request *GetVideoListRequest) (_result *GetVideoListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetVideoListResponse{}
	_body, _err := client.GetVideoListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the credential required for media playback. ApsaraVideo Player SDK automatically obtains the playback URL based on the playback credential. Each playback credential can be used to obtain the playback URL only for a specific video in a specific period of time. You cannot obtain the playback URL if the credential expires or is incorrect. You can use PlayAuth-based playback when you require high security for audio and video playback.
//
// Description:
//
//   You can call this operation to obtain a playback credential when you use ApsaraVideo Player SDK to play a media file based on PlayAuth. The credential is used to obtain the playback URL. For more information, see [ApsaraVideo Player SDK](https://help.aliyun.com/document_detail/125579.html).
//
// 	- You cannot obtain the playback URL of a video by using a credential that has expired. A new credential is required.
//
// @param request - GetVideoPlayAuthRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetVideoPlayAuthResponse
func (client *Client) GetVideoPlayAuthWithOptions(request *GetVideoPlayAuthRequest, runtime *util.RuntimeOptions) (_result *GetVideoPlayAuthResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApiVersion)) {
		query["ApiVersion"] = request.ApiVersion
	}

	if !tea.BoolValue(util.IsUnset(request.AuthInfoTimeout)) {
		query["AuthInfoTimeout"] = request.AuthInfoTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetVideoPlayAuth"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetVideoPlayAuthResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetVideoPlayAuthResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the credential required for media playback. ApsaraVideo Player SDK automatically obtains the playback URL based on the playback credential. Each playback credential can be used to obtain the playback URL only for a specific video in a specific period of time. You cannot obtain the playback URL if the credential expires or is incorrect. You can use PlayAuth-based playback when you require high security for audio and video playback.
//
// Description:
//
//   You can call this operation to obtain a playback credential when you use ApsaraVideo Player SDK to play a media file based on PlayAuth. The credential is used to obtain the playback URL. For more information, see [ApsaraVideo Player SDK](https://help.aliyun.com/document_detail/125579.html).
//
// 	- You cannot obtain the playback URL of a video by using a credential that has expired. A new credential is required.
//
// @param request - GetVideoPlayAuthRequest
//
// @return GetVideoPlayAuthResponse
func (client *Client) GetVideoPlayAuth(request *GetVideoPlayAuthRequest) (_result *GetVideoPlayAuthResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetVideoPlayAuthResponse{}
	_body, _err := client.GetVideoPlayAuthWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries a single snapshot template.
//
// @param request - GetVodTemplateRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetVodTemplateResponse
func (client *Client) GetVodTemplateWithOptions(request *GetVodTemplateRequest, runtime *util.RuntimeOptions) (_result *GetVodTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.VodTemplateId)) {
		query["VodTemplateId"] = request.VodTemplateId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetVodTemplate"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetVodTemplateResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetVodTemplateResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries a single snapshot template.
//
// @param request - GetVodTemplateRequest
//
// @return GetVodTemplateResponse
func (client *Client) GetVodTemplate(request *GetVodTemplateRequest) (_result *GetVodTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetVodTemplateResponse{}
	_body, _err := client.GetVodTemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the information about an image or text watermark based on the watermark template ID. You can call this operation to obtain information such as the position, size, and display time of an image watermark or the content, position, font, and font color of a text watermark.
//
// @param request - GetWatermarkRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return GetWatermarkResponse
func (client *Client) GetWatermarkWithOptions(request *GetWatermarkRequest, runtime *util.RuntimeOptions) (_result *GetWatermarkResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.WatermarkId)) {
		query["WatermarkId"] = request.WatermarkId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetWatermark"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &GetWatermarkResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &GetWatermarkResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the information about an image or text watermark based on the watermark template ID. You can call this operation to obtain information such as the position, size, and display time of an image watermark or the content, position, font, and font color of a text watermark.
//
// @param request - GetWatermarkRequest
//
// @return GetWatermarkResponse
func (client *Client) GetWatermark(request *GetWatermarkRequest) (_result *GetWatermarkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetWatermarkResponse{}
	_body, _err := client.GetWatermarkWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the AI processing results about the images of a specified video.
//
// Description:
//
//   Regions that support this operation: **China (Beijing)*	- and **China (Shanghai)**.
//
// 	- You can call this operation to query AI processing results about images of a specified video. Images of different videos cannot be queried in one request.
//
// @param request - ListAIImageInfoRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListAIImageInfoResponse
func (client *Client) ListAIImageInfoWithOptions(request *ListAIImageInfoRequest, runtime *util.RuntimeOptions) (_result *ListAIImageInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAIImageInfo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &ListAIImageInfoResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &ListAIImageInfoResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the AI processing results about the images of a specified video.
//
// Description:
//
//   Regions that support this operation: **China (Beijing)*	- and **China (Shanghai)**.
//
// 	- You can call this operation to query AI processing results about images of a specified video. Images of different videos cannot be queried in one request.
//
// @param request - ListAIImageInfoRequest
//
// @return ListAIImageInfoResponse
func (client *Client) ListAIImageInfo(request *ListAIImageInfoRequest) (_result *ListAIImageInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAIImageInfoResponse{}
	_body, _err := client.ListAIImageInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries AI jobs. After a job is submitted, ApsaraVideo VOD asynchronously processes the job. You can call this operation to query the job information in real time.
//
// Description:
//
//   Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
//
// 	- You can call this operation to query video fingerprinting jobs and smart tagging jobs.
//
// @param request - ListAIJobRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListAIJobResponse
func (client *Client) ListAIJobWithOptions(request *ListAIJobRequest, runtime *util.RuntimeOptions) (_result *ListAIJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.JobIds)) {
		query["JobIds"] = request.JobIds
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAIJob"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &ListAIJobResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &ListAIJobResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries AI jobs. After a job is submitted, ApsaraVideo VOD asynchronously processes the job. You can call this operation to query the job information in real time.
//
// Description:
//
//   Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
//
// 	- You can call this operation to query video fingerprinting jobs and smart tagging jobs.
//
// @param request - ListAIJobRequest
//
// @return ListAIJobResponse
func (client *Client) ListAIJob(request *ListAIJobRequest) (_result *ListAIJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAIJobResponse{}
	_body, _err := client.ListAIJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries AI templates.
//
// Description:
//
//   Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
//
// 	- You can call this operation to query AI templates of a specified type.
//
// @param request - ListAITemplateRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListAITemplateResponse
func (client *Client) ListAITemplateWithOptions(request *ListAITemplateRequest, runtime *util.RuntimeOptions) (_result *ListAITemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TemplateType)) {
		query["TemplateType"] = request.TemplateType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAITemplate"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &ListAITemplateResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &ListAITemplateResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries AI templates.
//
// Description:
//
//   Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
//
// 	- You can call this operation to query AI templates of a specified type.
//
// @param request - ListAITemplateRequest
//
// @return ListAITemplateResponse
func (client *Client) ListAITemplate(request *ListAITemplateRequest) (_result *ListAITemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAITemplateResponse{}
	_body, _err := client.ListAITemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the applications that you are authorized to manage based on query conditions.
//
// Description:
//
// ### [](#)Usage notes
//
// You can query applications based on states.
//
// ### [](#qps-)QPS limit
//
// You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations](https://help.aliyun.com/document_detail/342790.html).
//
// @param request - ListAppInfoRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListAppInfoResponse
func (client *Client) ListAppInfoWithOptions(request *ListAppInfoRequest, runtime *util.RuntimeOptions) (_result *ListAppInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		query["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAppInfo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &ListAppInfoResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &ListAppInfoResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the applications that you are authorized to manage based on query conditions.
//
// Description:
//
// ### [](#)Usage notes
//
// You can query applications based on states.
//
// ### [](#qps-)QPS limit
//
// You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations](https://help.aliyun.com/document_detail/342790.html).
//
// @param request - ListAppInfoRequest
//
// @return ListAppInfoResponse
func (client *Client) ListAppInfo(request *ListAppInfoRequest) (_result *ListAppInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAppInfoResponse{}
	_body, _err := client.ListAppInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the application policies that are attached to the specified identity. The identity may be a RAM user or RAM role.
//
// Description:
//
// > The IdentityType and IdentityName parameters take effect only when an identity assumes the application administrator role to call this operation. Otherwise, only application policies that are attached to the current identity are returned.
//
// @param request - ListAppPoliciesForIdentityRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListAppPoliciesForIdentityResponse
func (client *Client) ListAppPoliciesForIdentityWithOptions(request *ListAppPoliciesForIdentityRequest, runtime *util.RuntimeOptions) (_result *ListAppPoliciesForIdentityResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.IdentityName)) {
		query["IdentityName"] = request.IdentityName
	}

	if !tea.BoolValue(util.IsUnset(request.IdentityType)) {
		query["IdentityType"] = request.IdentityType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAppPoliciesForIdentity"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &ListAppPoliciesForIdentityResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &ListAppPoliciesForIdentityResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the application policies that are attached to the specified identity. The identity may be a RAM user or RAM role.
//
// Description:
//
// > The IdentityType and IdentityName parameters take effect only when an identity assumes the application administrator role to call this operation. Otherwise, only application policies that are attached to the current identity are returned.
//
// @param request - ListAppPoliciesForIdentityRequest
//
// @return ListAppPoliciesForIdentityResponse
func (client *Client) ListAppPoliciesForIdentity(request *ListAppPoliciesForIdentityRequest) (_result *ListAppPoliciesForIdentityResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAppPoliciesForIdentityResponse{}
	_body, _err := client.ListAppPoliciesForIdentityWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the IP addresses in a review security group.
//
// @param request - ListAuditSecurityIpRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListAuditSecurityIpResponse
func (client *Client) ListAuditSecurityIpWithOptions(request *ListAuditSecurityIpRequest, runtime *util.RuntimeOptions) (_result *ListAuditSecurityIpResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.SecurityGroupName)) {
		query["SecurityGroupName"] = request.SecurityGroupName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAuditSecurityIp"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &ListAuditSecurityIpResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &ListAuditSecurityIpResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the IP addresses in a review security group.
//
// @param request - ListAuditSecurityIpRequest
//
// @return ListAuditSecurityIpResponse
func (client *Client) ListAuditSecurityIp(request *ListAuditSecurityIpRequest) (_result *ListAuditSecurityIpResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAuditSecurityIpResponse{}
	_body, _err := client.ListAuditSecurityIpWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the information about animated stickers of a video based on the video ID.
//
// @param request - ListDynamicImageRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListDynamicImageResponse
func (client *Client) ListDynamicImageWithOptions(request *ListDynamicImageRequest, runtime *util.RuntimeOptions) (_result *ListDynamicImageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDynamicImage"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &ListDynamicImageResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &ListDynamicImageResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the information about animated stickers of a video based on the video ID.
//
// @param request - ListDynamicImageRequest
//
// @return ListDynamicImageResponse
func (client *Client) ListDynamicImage(request *ListDynamicImageRequest) (_result *ListDynamicImageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDynamicImageResponse{}
	_body, _err := client.ListDynamicImageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries historical tasks based on the media asset ID.
//
// Description:
//
// ***
//
// 	- You can call the [GetJobDetail](https://apiworkbench.aliyun-inc.com/document/vod/2017-03-21/GetJobDetail?spm=openapi-amp.newDocPublishment.0.0.616a281fSegn0e) operation to query detailed information about the tasks.
//
// 	- You can call this operation to query only asynchronous tasks of the last six months. The types of tasks that you can query include transcoding tasks, snapshot tasks, and AI tasks.
//
// **QPS limits**
//
// You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/342790.html).
//
// @param request - ListJobInfoRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListJobInfoResponse
func (client *Client) ListJobInfoWithOptions(request *ListJobInfoRequest, runtime *util.RuntimeOptions) (_result *ListJobInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.JobType)) {
		query["JobType"] = request.JobType
	}

	if !tea.BoolValue(util.IsUnset(request.MediaId)) {
		query["MediaId"] = request.MediaId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListJobInfo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &ListJobInfoResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &ListJobInfoResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries historical tasks based on the media asset ID.
//
// Description:
//
// ***
//
// 	- You can call the [GetJobDetail](https://apiworkbench.aliyun-inc.com/document/vod/2017-03-21/GetJobDetail?spm=openapi-amp.newDocPublishment.0.0.616a281fSegn0e) operation to query detailed information about the tasks.
//
// 	- You can call this operation to query only asynchronous tasks of the last six months. The types of tasks that you can query include transcoding tasks, snapshot tasks, and AI tasks.
//
// **QPS limits**
//
// You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/342790.html).
//
// @param request - ListJobInfoRequest
//
// @return ListJobInfoResponse
func (client *Client) ListJobInfo(request *ListJobInfoRequest) (_result *ListJobInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListJobInfoResponse{}
	_body, _err := client.ListJobInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries live-to-VOD videos.
//
// Description:
//
// You can query up to 5,000 videos based on the specified filter condition.
//
// @param request - ListLiveRecordVideoRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListLiveRecordVideoResponse
func (client *Client) ListLiveRecordVideoWithOptions(request *ListLiveRecordVideoRequest, runtime *util.RuntimeOptions) (_result *ListLiveRecordVideoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		query["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SortBy)) {
		query["SortBy"] = request.SortBy
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.StreamName)) {
		query["StreamName"] = request.StreamName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListLiveRecordVideo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &ListLiveRecordVideoResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &ListLiveRecordVideoResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries live-to-VOD videos.
//
// Description:
//
// You can query up to 5,000 videos based on the specified filter condition.
//
// @param request - ListLiveRecordVideoRequest
//
// @return ListLiveRecordVideoResponse
func (client *Client) ListLiveRecordVideo(request *ListLiveRecordVideoRequest) (_result *ListLiveRecordVideoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListLiveRecordVideoResponse{}
	_body, _err := client.ListLiveRecordVideoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the snapshots that are captured by submitting snapshot jobs or snapshots that are generated by the system when you upload the video.
//
// Description:
//
// If multiple snapshots exist for a video, you can call this operation to query information about the latest snapshot.
//
// @param request - ListSnapshotsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListSnapshotsResponse
func (client *Client) ListSnapshotsWithOptions(request *ListSnapshotsRequest, runtime *util.RuntimeOptions) (_result *ListSnapshotsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AuthTimeout)) {
		query["AuthTimeout"] = request.AuthTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		query["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SnapshotType)) {
		query["SnapshotType"] = request.SnapshotType
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListSnapshots"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &ListSnapshotsResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &ListSnapshotsResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the snapshots that are captured by submitting snapshot jobs or snapshots that are generated by the system when you upload the video.
//
// Description:
//
// If multiple snapshots exist for a video, you can call this operation to query information about the latest snapshot.
//
// @param request - ListSnapshotsRequest
//
// @return ListSnapshotsResponse
func (client *Client) ListSnapshots(request *ListSnapshotsRequest) (_result *ListSnapshotsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListSnapshotsResponse{}
	_body, _err := client.ListSnapshotsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries transcoding tasks based on the media ID. This operation does not return specific job information.
//
// Description:
//
//   You can call the [GetTranscodeTask](https://help.aliyun.com/document_detail/109121.html) operation to query details about transcoding jobs.
//
// 	- **You can call this operation to query only transcoding tasks created within the past year.**
//
// @param request - ListTranscodeTaskRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListTranscodeTaskResponse
func (client *Client) ListTranscodeTaskWithOptions(request *ListTranscodeTaskRequest, runtime *util.RuntimeOptions) (_result *ListTranscodeTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		query["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTranscodeTask"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &ListTranscodeTaskResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &ListTranscodeTaskResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries transcoding tasks based on the media ID. This operation does not return specific job information.
//
// Description:
//
//   You can call the [GetTranscodeTask](https://help.aliyun.com/document_detail/109121.html) operation to query details about transcoding jobs.
//
// 	- **You can call this operation to query only transcoding tasks created within the past year.**
//
// @param request - ListTranscodeTaskRequest
//
// @return ListTranscodeTaskResponse
func (client *Client) ListTranscodeTask(request *ListTranscodeTaskRequest) (_result *ListTranscodeTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTranscodeTaskResponse{}
	_body, _err := client.ListTranscodeTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries transcoding template groups.
//
// Description:
//
// > This operation does not return the configurations of transcoding templates in each transcoding template group. To query the configurations of transcoding templates in a specific transcoding template group, call the [GetTranscodeTemplateGroup](https://help.aliyun.com/document_detail/102670.html) operation.
//
// @param request - ListTranscodeTemplateGroupRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListTranscodeTemplateGroupResponse
func (client *Client) ListTranscodeTemplateGroupWithOptions(request *ListTranscodeTemplateGroupRequest, runtime *util.RuntimeOptions) (_result *ListTranscodeTemplateGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTranscodeTemplateGroup"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &ListTranscodeTemplateGroupResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &ListTranscodeTemplateGroupResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries transcoding template groups.
//
// Description:
//
// > This operation does not return the configurations of transcoding templates in each transcoding template group. To query the configurations of transcoding templates in a specific transcoding template group, call the [GetTranscodeTemplateGroup](https://help.aliyun.com/document_detail/102670.html) operation.
//
// @param request - ListTranscodeTemplateGroupRequest
//
// @return ListTranscodeTemplateGroupResponse
func (client *Client) ListTranscodeTemplateGroup(request *ListTranscodeTemplateGroupRequest) (_result *ListTranscodeTemplateGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTranscodeTemplateGroupResponse{}
	_body, _err := client.ListTranscodeTemplateGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries snapshot templates.
//
// @param request - ListVodTemplateRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListVodTemplateResponse
func (client *Client) ListVodTemplateWithOptions(request *ListVodTemplateRequest, runtime *util.RuntimeOptions) (_result *ListVodTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateType)) {
		query["TemplateType"] = request.TemplateType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListVodTemplate"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &ListVodTemplateResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &ListVodTemplateResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries snapshot templates.
//
// @param request - ListVodTemplateRequest
//
// @return ListVodTemplateResponse
func (client *Client) ListVodTemplate(request *ListVodTemplateRequest) (_result *ListVodTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListVodTemplateResponse{}
	_body, _err := client.ListVodTemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries the configuration information about all image and text watermark templates in a region. You can call this operation to obtain information such as the position, size, and display time of image watermarks or the content, position, font, and font color of text watermarks.
//
// @param request - ListWatermarkRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ListWatermarkResponse
func (client *Client) ListWatermarkWithOptions(request *ListWatermarkRequest, runtime *util.RuntimeOptions) (_result *ListWatermarkResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListWatermark"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &ListWatermarkResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &ListWatermarkResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries the configuration information about all image and text watermark templates in a region. You can call this operation to obtain information such as the position, size, and display time of image watermarks or the content, position, font, and font color of text watermarks.
//
// @param request - ListWatermarkRequest
//
// @return ListWatermarkResponse
func (client *Client) ListWatermark(request *ListWatermarkRequest) (_result *ListWatermarkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListWatermarkResponse{}
	_body, _err := client.ListWatermarkWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Migrates resources between applications. The application administrator can directly migrate resources between applications. Resource Access Management (RAM) users or RAM roles must obtain the write permissions on the source and destination applications before they migrate resources between applications. Multiple resources can be migrated at a time.
//
// @param request - MoveAppResourceRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return MoveAppResourceResponse
func (client *Client) MoveAppResourceWithOptions(request *MoveAppResourceRequest, runtime *util.RuntimeOptions) (_result *MoveAppResourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceIds)) {
		query["ResourceIds"] = request.ResourceIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TargetAppId)) {
		query["TargetAppId"] = request.TargetAppId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("MoveAppResource"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &MoveAppResourceResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &MoveAppResourceResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Migrates resources between applications. The application administrator can directly migrate resources between applications. Resource Access Management (RAM) users or RAM roles must obtain the write permissions on the source and destination applications before they migrate resources between applications. Multiple resources can be migrated at a time.
//
// @param request - MoveAppResourceRequest
//
// @return MoveAppResourceResponse
func (client *Client) MoveAppResource(request *MoveAppResourceRequest) (_result *MoveAppResourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &MoveAppResourceResponse{}
	_body, _err := client.MoveAppResourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Prefetches resources from an origin server to L2 nodes. Users can directly hit the cache upon their first visits. This way, workloads on the origin server can be reduced.
//
// Description:
//
// > 	- This operation is available only in the **China (Shanghai)*	- region.
//
// > 	- You can submit a maximum of 500 requests to prefetch resources based on URLs each day by using an Alibaba Cloud account. You cannot prefetch resources based on directories.
//
// > 	- You can call the [RefreshVodObjectCaches](https://help.aliyun.com/document_detail/69215.html) operation to refresh content and the [PreloadVodObjectCaches](https://help.aliyun.com/document_detail/69211.htmll) operation to prefetch content.
//
// @param request - PreloadVodObjectCachesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return PreloadVodObjectCachesResponse
func (client *Client) PreloadVodObjectCachesWithOptions(request *PreloadVodObjectCachesRequest, runtime *util.RuntimeOptions) (_result *PreloadVodObjectCachesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Area)) {
		query["Area"] = request.Area
	}

	if !tea.BoolValue(util.IsUnset(request.L2Preload)) {
		query["L2Preload"] = request.L2Preload
	}

	if !tea.BoolValue(util.IsUnset(request.ObjectPath)) {
		query["ObjectPath"] = request.ObjectPath
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.WithHeader)) {
		query["WithHeader"] = request.WithHeader
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("PreloadVodObjectCaches"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &PreloadVodObjectCachesResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &PreloadVodObjectCachesResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Prefetches resources from an origin server to L2 nodes. Users can directly hit the cache upon their first visits. This way, workloads on the origin server can be reduced.
//
// Description:
//
// > 	- This operation is available only in the **China (Shanghai)*	- region.
//
// > 	- You can submit a maximum of 500 requests to prefetch resources based on URLs each day by using an Alibaba Cloud account. You cannot prefetch resources based on directories.
//
// > 	- You can call the [RefreshVodObjectCaches](https://help.aliyun.com/document_detail/69215.html) operation to refresh content and the [PreloadVodObjectCaches](https://help.aliyun.com/document_detail/69211.htmll) operation to prefetch content.
//
// @param request - PreloadVodObjectCachesRequest
//
// @return PreloadVodObjectCachesResponse
func (client *Client) PreloadVodObjectCaches(request *PreloadVodObjectCachesRequest) (_result *PreloadVodObjectCachesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PreloadVodObjectCachesResponse{}
	_body, _err := client.PreloadVodObjectCachesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Produces a video from one or more source files. You can directly specify source files by configuring the Timeline parameter. Alternatively, you can specify source files after you create an online editing project.
//
// Description:
//
//   **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. You are charged for using the online editing feature. For more information, see [Billing](~~188310#section-pyv-b8h-bo7~~).**
//
// 	- This operation returns only the submission result of a video production task. When the submission result is returned, video production may still be in progress. After a video production task is submitted, the task is queued in the background for asynchronous processing.
//
// 	- The source files that are used in the timeline of an online editing project can be materials directly uploaded to the online project or selected from the media asset library. Only media assets that are in the Normal state can be used in the project.
//
// 	- Videos are produced based on ProjectId and Timeline. The following content describes the parameter configurations:
//
//     	- You must specify ProjectId or Timeline. If you leave both parameters empty, the video cannot be produced.
//
//     	- If you specify Timeline and leave ProjectId empty, the system automatically creates an online editing project based on Timeline and adds the materials specified in the Timeline to the project to produce videos.
//
//     	- If you specify ProjectId and leave Timeline empty, the system automatically uses the latest timeline information of the project to produce videos.
//
//     	- If you specify both ProjectId and Timeline, the system automatically uses the timeline information that you specified to produce videos and updates the project timeline and materials. You can also specify other parameters to update the corresponding information about the online editing project.
//
// 	- You can create up to 100 video tracks, 100 image tracks, and 100 subtitle tracks in a project.
//
// 	- The total size of material files cannot exceed 1 TB.
//
// 	- The buckets in which the materials reside and where the exported videos are stored must be in the same region as the region where ApsaraVideo VOD is activated.
//
// 	- The exported videos must meet the following requirements:
//
//     	- The width and height of the video image cannot be less than 128 pixels.
//
//     	- The width and height of the video image cannot exceed 4,096 pixels.
//
//     	- The width cannot exceed 2,160 pixels.
//
// 	- After a video is produced, the video is automatically uploaded to ApsaraVideo VOD. Then, the **ProduceMediaComplete*	- and **FileUploadComplete*	- event notifications are sent to you. After the produced video is transcoded, the **StreamTranscodeComplete*	- and **TranscodeComplete*	- event notifications are sent to you.
//
// 	- You can add special effects to the video. For more information, see [Special effects](https://help.aliyun.com/document_detail/69082.html).
//
// @param request - ProduceEditingProjectVideoRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return ProduceEditingProjectVideoResponse
func (client *Client) ProduceEditingProjectVideoWithOptions(request *ProduceEditingProjectVideoRequest, runtime *util.RuntimeOptions) (_result *ProduceEditingProjectVideoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.CoverURL)) {
		query["CoverURL"] = request.CoverURL
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.MediaMetadata)) {
		query["MediaMetadata"] = request.MediaMetadata
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProduceConfig)) {
		query["ProduceConfig"] = request.ProduceConfig
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Timeline)) {
		query["Timeline"] = request.Timeline
	}

	if !tea.BoolValue(util.IsUnset(request.Title)) {
		query["Title"] = request.Title
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ProduceEditingProjectVideo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &ProduceEditingProjectVideoResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &ProduceEditingProjectVideoResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Produces a video from one or more source files. You can directly specify source files by configuring the Timeline parameter. Alternatively, you can specify source files after you create an online editing project.
//
// Description:
//
//   **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. You are charged for using the online editing feature. For more information, see [Billing](~~188310#section-pyv-b8h-bo7~~).**
//
// 	- This operation returns only the submission result of a video production task. When the submission result is returned, video production may still be in progress. After a video production task is submitted, the task is queued in the background for asynchronous processing.
//
// 	- The source files that are used in the timeline of an online editing project can be materials directly uploaded to the online project or selected from the media asset library. Only media assets that are in the Normal state can be used in the project.
//
// 	- Videos are produced based on ProjectId and Timeline. The following content describes the parameter configurations:
//
//     	- You must specify ProjectId or Timeline. If you leave both parameters empty, the video cannot be produced.
//
//     	- If you specify Timeline and leave ProjectId empty, the system automatically creates an online editing project based on Timeline and adds the materials specified in the Timeline to the project to produce videos.
//
//     	- If you specify ProjectId and leave Timeline empty, the system automatically uses the latest timeline information of the project to produce videos.
//
//     	- If you specify both ProjectId and Timeline, the system automatically uses the timeline information that you specified to produce videos and updates the project timeline and materials. You can also specify other parameters to update the corresponding information about the online editing project.
//
// 	- You can create up to 100 video tracks, 100 image tracks, and 100 subtitle tracks in a project.
//
// 	- The total size of material files cannot exceed 1 TB.
//
// 	- The buckets in which the materials reside and where the exported videos are stored must be in the same region as the region where ApsaraVideo VOD is activated.
//
// 	- The exported videos must meet the following requirements:
//
//     	- The width and height of the video image cannot be less than 128 pixels.
//
//     	- The width and height of the video image cannot exceed 4,096 pixels.
//
//     	- The width cannot exceed 2,160 pixels.
//
// 	- After a video is produced, the video is automatically uploaded to ApsaraVideo VOD. Then, the **ProduceMediaComplete*	- and **FileUploadComplete*	- event notifications are sent to you. After the produced video is transcoded, the **StreamTranscodeComplete*	- and **TranscodeComplete*	- event notifications are sent to you.
//
// 	- You can add special effects to the video. For more information, see [Special effects](https://help.aliyun.com/document_detail/69082.html).
//
// @param request - ProduceEditingProjectVideoRequest
//
// @return ProduceEditingProjectVideoResponse
func (client *Client) ProduceEditingProjectVideo(request *ProduceEditingProjectVideoRequest) (_result *ProduceEditingProjectVideoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ProduceEditingProjectVideoResponse{}
	_body, _err := client.ProduceEditingProjectVideoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Submits media refresh or prefetch tasks based on the media IDs.
//
// Description:
//
//   ApsaraVideo VOD allows you to purge and prefetch resources. The purge feature forces the point of presence (POP) to clear cached resources and retrieve the latest resources from origin servers. The prefetch feature allows the POP to retrieve frequently accessed resources from origin servers during off-peak hours. This increases the cache hit ratio.
//
// 	- You can call this operation to submit purge or prefetch tasks based on the media ID. You can also specify the format and resolution of the media streams to purge or prefetch based on your business requirements.
//
// 	- You can submit a maximum of 20 purge or prefetch tasks at a time.
//
// @param request - RefreshMediaPlayUrlsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return RefreshMediaPlayUrlsResponse
func (client *Client) RefreshMediaPlayUrlsWithOptions(request *RefreshMediaPlayUrlsRequest, runtime *util.RuntimeOptions) (_result *RefreshMediaPlayUrlsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Definitions)) {
		query["Definitions"] = request.Definitions
	}

	if !tea.BoolValue(util.IsUnset(request.Formats)) {
		query["Formats"] = request.Formats
	}

	if !tea.BoolValue(util.IsUnset(request.MediaIds)) {
		query["MediaIds"] = request.MediaIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResultType)) {
		query["ResultType"] = request.ResultType
	}

	if !tea.BoolValue(util.IsUnset(request.SliceCount)) {
		query["SliceCount"] = request.SliceCount
	}

	if !tea.BoolValue(util.IsUnset(request.SliceFlag)) {
		query["SliceFlag"] = request.SliceFlag
	}

	if !tea.BoolValue(util.IsUnset(request.StreamType)) {
		query["StreamType"] = request.StreamType
	}

	if !tea.BoolValue(util.IsUnset(request.TaskType)) {
		query["TaskType"] = request.TaskType
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RefreshMediaPlayUrls"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &RefreshMediaPlayUrlsResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &RefreshMediaPlayUrlsResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Submits media refresh or prefetch tasks based on the media IDs.
//
// Description:
//
//   ApsaraVideo VOD allows you to purge and prefetch resources. The purge feature forces the point of presence (POP) to clear cached resources and retrieve the latest resources from origin servers. The prefetch feature allows the POP to retrieve frequently accessed resources from origin servers during off-peak hours. This increases the cache hit ratio.
//
// 	- You can call this operation to submit purge or prefetch tasks based on the media ID. You can also specify the format and resolution of the media streams to purge or prefetch based on your business requirements.
//
// 	- You can submit a maximum of 20 purge or prefetch tasks at a time.
//
// @param request - RefreshMediaPlayUrlsRequest
//
// @return RefreshMediaPlayUrlsResponse
func (client *Client) RefreshMediaPlayUrls(request *RefreshMediaPlayUrlsRequest) (_result *RefreshMediaPlayUrlsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RefreshMediaPlayUrlsResponse{}
	_body, _err := client.RefreshMediaPlayUrlsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Obtains a new upload credential after a file failed to be uploaded.
//
// Description:
//
// You can also call this operation to overwrite the source file of an audio or video file. After you call this operation, the system obtains the upload URL and uploads a new source file without changing the ID of the audio or video file. If you have configured transcoding or snapshot capture for the upload, the transcoding or snapshot capture job is automatically triggered. For more information, see [Upload URLs and credentials](https://help.aliyun.com/document_detail/55397.html).
//
// @param request - RefreshUploadVideoRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return RefreshUploadVideoResponse
func (client *Client) RefreshUploadVideoWithOptions(request *RefreshUploadVideoRequest, runtime *util.RuntimeOptions) (_result *RefreshUploadVideoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RefreshUploadVideo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &RefreshUploadVideoResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &RefreshUploadVideoResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Obtains a new upload credential after a file failed to be uploaded.
//
// Description:
//
// You can also call this operation to overwrite the source file of an audio or video file. After you call this operation, the system obtains the upload URL and uploads a new source file without changing the ID of the audio or video file. If you have configured transcoding or snapshot capture for the upload, the transcoding or snapshot capture job is automatically triggered. For more information, see [Upload URLs and credentials](https://help.aliyun.com/document_detail/55397.html).
//
// @param request - RefreshUploadVideoRequest
//
// @return RefreshUploadVideoResponse
func (client *Client) RefreshUploadVideo(request *RefreshUploadVideoRequest) (_result *RefreshUploadVideoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RefreshUploadVideoResponse{}
	_body, _err := client.RefreshUploadVideoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Refreshes files on Alibaba Cloud CDN nodes. You can refresh multiple files at a time based on URLs.
//
// Description:
//
//   This operation is available only in the **China (Shanghai)*	- region.
//
// 	- You can submit a maximum of 2,000 requests to refresh resources based on URLs and 100 requests to refresh resources based on directories each day by using an Alibaba Cloud account.
//
// 	- You can call the [RefreshVodObjectCaches](https://help.aliyun.com/document_detail/69215.html) operation to refresh content and the [PreloadVodObjectCaches](https://help.aliyun.com/document_detail/69211.html) operation to prefetch content.
//
// @param request - RefreshVodObjectCachesRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return RefreshVodObjectCachesResponse
func (client *Client) RefreshVodObjectCachesWithOptions(request *RefreshVodObjectCachesRequest, runtime *util.RuntimeOptions) (_result *RefreshVodObjectCachesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Force)) {
		query["Force"] = request.Force
	}

	if !tea.BoolValue(util.IsUnset(request.ObjectPath)) {
		query["ObjectPath"] = request.ObjectPath
	}

	if !tea.BoolValue(util.IsUnset(request.ObjectType)) {
		query["ObjectType"] = request.ObjectType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RefreshVodObjectCaches"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &RefreshVodObjectCachesResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &RefreshVodObjectCachesResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Refreshes files on Alibaba Cloud CDN nodes. You can refresh multiple files at a time based on URLs.
//
// Description:
//
//   This operation is available only in the **China (Shanghai)*	- region.
//
// 	- You can submit a maximum of 2,000 requests to refresh resources based on URLs and 100 requests to refresh resources based on directories each day by using an Alibaba Cloud account.
//
// 	- You can call the [RefreshVodObjectCaches](https://help.aliyun.com/document_detail/69215.html) operation to refresh content and the [PreloadVodObjectCaches](https://help.aliyun.com/document_detail/69211.html) operation to prefetch content.
//
// @param request - RefreshVodObjectCachesRequest
//
// @return RefreshVodObjectCachesResponse
func (client *Client) RefreshVodObjectCaches(request *RefreshVodObjectCachesRequest) (_result *RefreshVodObjectCachesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RefreshVodObjectCachesResponse{}
	_body, _err := client.RefreshVodObjectCachesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Registers media files. After you add an Object Storage Service (OSS) bucket to ApsaraVideo VOD, you must register the media files in the bucket to generate the required information before you use features such as transcoding and snapshot capture on the media files.
//
// Description:
//
//   After you add an OSS bucket to ApsaraVideo VOD, you must register media files in the OSS bucket to generate the required information. Then, you can use media IDs for features such as transcoding, snapshot capture, and AI processing.use features such as xxx on media files by specifying their IDs?
//
// 	- You can register up to 10 media files in an OSS bucket in a request. The media files must be stored in the same bucket.
//
// 	- If you do not specify a transcoding template group ID when you upload a media file to ApsaraVideo VOD, the media file is automatically transcoded based on the default template group. If you do not specify a transcoding template group ID after you register a media file, the media file is not automatically transcoded. The registered media files are automatically transcoded only if you specify a transcoding template group ID.
//
// 	- If the media file that you want to register has been registered, this operation returns only the unique media ID that is associated with the media file. No further operation is performed.
//
// 	- Make sure that the media file that you want to register has a valid suffix. Otherwise, the registration fails.
//
// @param request - RegisterMediaRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return RegisterMediaResponse
func (client *Client) RegisterMediaWithOptions(request *RegisterMediaRequest, runtime *util.RuntimeOptions) (_result *RegisterMediaResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegisterMetadatas)) {
		query["RegisterMetadatas"] = request.RegisterMetadatas
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateGroupId)) {
		query["TemplateGroupId"] = request.TemplateGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	if !tea.BoolValue(util.IsUnset(request.WorkflowId)) {
		query["WorkflowId"] = request.WorkflowId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RegisterMedia"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &RegisterMediaResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &RegisterMediaResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Registers media files. After you add an Object Storage Service (OSS) bucket to ApsaraVideo VOD, you must register the media files in the bucket to generate the required information before you use features such as transcoding and snapshot capture on the media files.
//
// Description:
//
//   After you add an OSS bucket to ApsaraVideo VOD, you must register media files in the OSS bucket to generate the required information. Then, you can use media IDs for features such as transcoding, snapshot capture, and AI processing.use features such as xxx on media files by specifying their IDs?
//
// 	- You can register up to 10 media files in an OSS bucket in a request. The media files must be stored in the same bucket.
//
// 	- If you do not specify a transcoding template group ID when you upload a media file to ApsaraVideo VOD, the media file is automatically transcoded based on the default template group. If you do not specify a transcoding template group ID after you register a media file, the media file is not automatically transcoded. The registered media files are automatically transcoded only if you specify a transcoding template group ID.
//
// 	- If the media file that you want to register has been registered, this operation returns only the unique media ID that is associated with the media file. No further operation is performed.
//
// 	- Make sure that the media file that you want to register has a valid suffix. Otherwise, the registration fails.
//
// @param request - RegisterMediaRequest
//
// @return RegisterMediaResponse
func (client *Client) RegisterMedia(request *RegisterMediaRequest) (_result *RegisterMediaResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RegisterMediaResponse{}
	_body, _err := client.RegisterMediaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Restores media assets.
//
// Description:
//
// You can call this operation to restore only Archive and Cold Archive audio and video files. You can access the audio and video files after the files are restored. You cannot change the storage class of an audio or video file that is being restored. You are charged for the retrieval traffic generated during restoration. After a Cold Archive audio or video file is restored, a Standard replica of the file is generated for access. You are charged for the storage of the replica before the file returns to the frozen state.
//
// @param request - RestoreMediaRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return RestoreMediaResponse
func (client *Client) RestoreMediaWithOptions(request *RestoreMediaRequest, runtime *util.RuntimeOptions) (_result *RestoreMediaResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaIds)) {
		query["MediaIds"] = request.MediaIds
	}

	if !tea.BoolValue(util.IsUnset(request.RestoreDays)) {
		query["RestoreDays"] = request.RestoreDays
	}

	if !tea.BoolValue(util.IsUnset(request.RestoreTier)) {
		query["RestoreTier"] = request.RestoreTier
	}

	if !tea.BoolValue(util.IsUnset(request.Scope)) {
		query["Scope"] = request.Scope
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RestoreMedia"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &RestoreMediaResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &RestoreMediaResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Restores media assets.
//
// Description:
//
// You can call this operation to restore only Archive and Cold Archive audio and video files. You can access the audio and video files after the files are restored. You cannot change the storage class of an audio or video file that is being restored. You are charged for the retrieval traffic generated during restoration. After a Cold Archive audio or video file is restored, a Standard replica of the file is generated for access. You are charged for the storage of the replica before the file returns to the frozen state.
//
// @param request - RestoreMediaRequest
//
// @return RestoreMediaResponse
func (client *Client) RestoreMedia(request *RestoreMediaRequest) (_result *RestoreMediaResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RestoreMediaResponse{}
	_body, _err := client.RestoreMediaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries online editing projects.
//
// @param request - SearchEditingProjectRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return SearchEditingProjectResponse
func (client *Client) SearchEditingProjectWithOptions(request *SearchEditingProjectRequest, runtime *util.RuntimeOptions) (_result *SearchEditingProjectResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		query["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SortBy)) {
		query["SortBy"] = request.SortBy
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.Title)) {
		query["Title"] = request.Title
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SearchEditingProject"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &SearchEditingProjectResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &SearchEditingProjectResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries online editing projects.
//
// @param request - SearchEditingProjectRequest
//
// @return SearchEditingProjectResponse
func (client *Client) SearchEditingProject(request *SearchEditingProjectRequest) (_result *SearchEditingProjectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SearchEditingProjectResponse{}
	_body, _err := client.SearchEditingProjectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Queries information about videos, audio, images, and auxiliary media assets. You can call this operation and specify the search protocol to query media assets based on the return fields, fields used for exact match, fields used for fuzzy match, fields used for a multi-value query, fields used for a range query, and sort fields.
//
// Description:
//
// The maximum number of data records that you can query varies based on the method used to query the data. You can use the following methods to query data:
//
// 	- Method 1: Traverse data by page
//
//     You can use the PageNo and PageSize parameters to traverse up to 5,000 data records that meet the specified filter condition. PageNo specifies the page number and PageSize specifies the number of data records displayed on a page. If the number of data records that meet the specified filter condition exceeds 5,000, change the filter conditions to narrow down the results. You cannot use this method to traverse all data records. If you want to traverse more data records, use Method 2.
//
// 	- Method 2: Traverse all data (available only for audio and video files)
//
//     You can use this method to traverse up to 2 million data records related to audio and video files. If the number of data records that meet the specified filter condition exceeds 2 million, change the filter conditions to narrow down the results. To traverse data page by page, you must set the PageNo, PageSize, and ScrollToken parameters. The total number of data records from the current page to the target page cannot exceed 100. For example, you set PageSize to 20. The following content describes the traverse logic:
//
//     	- When the PageNo parameter is set to 1, you can traverse data records from page 1 to page 5.
//
//     	- When the PageNo parameter is set to 2, you can traverse data records from page 2 to page 6.
//
// Make sure that you set the appropriate page number and page size, and use a traverse method based on the number of results that meet your filter condition.
//
// @param request - SearchMediaRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return SearchMediaResponse
func (client *Client) SearchMediaWithOptions(request *SearchMediaRequest, runtime *util.RuntimeOptions) (_result *SearchMediaResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Fields)) {
		query["Fields"] = request.Fields
	}

	if !tea.BoolValue(util.IsUnset(request.Match)) {
		query["Match"] = request.Match
	}

	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		query["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ScrollToken)) {
		query["ScrollToken"] = request.ScrollToken
	}

	if !tea.BoolValue(util.IsUnset(request.SearchType)) {
		query["SearchType"] = request.SearchType
	}

	if !tea.BoolValue(util.IsUnset(request.SortBy)) {
		query["SortBy"] = request.SortBy
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SearchMedia"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &SearchMediaResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &SearchMediaResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Queries information about videos, audio, images, and auxiliary media assets. You can call this operation and specify the search protocol to query media assets based on the return fields, fields used for exact match, fields used for fuzzy match, fields used for a multi-value query, fields used for a range query, and sort fields.
//
// Description:
//
// The maximum number of data records that you can query varies based on the method used to query the data. You can use the following methods to query data:
//
// 	- Method 1: Traverse data by page
//
//     You can use the PageNo and PageSize parameters to traverse up to 5,000 data records that meet the specified filter condition. PageNo specifies the page number and PageSize specifies the number of data records displayed on a page. If the number of data records that meet the specified filter condition exceeds 5,000, change the filter conditions to narrow down the results. You cannot use this method to traverse all data records. If you want to traverse more data records, use Method 2.
//
// 	- Method 2: Traverse all data (available only for audio and video files)
//
//     You can use this method to traverse up to 2 million data records related to audio and video files. If the number of data records that meet the specified filter condition exceeds 2 million, change the filter conditions to narrow down the results. To traverse data page by page, you must set the PageNo, PageSize, and ScrollToken parameters. The total number of data records from the current page to the target page cannot exceed 100. For example, you set PageSize to 20. The following content describes the traverse logic:
//
//     	- When the PageNo parameter is set to 1, you can traverse data records from page 1 to page 5.
//
//     	- When the PageNo parameter is set to 2, you can traverse data records from page 2 to page 6.
//
// Make sure that you set the appropriate page number and page size, and use a traverse method based on the number of results that meet your filter condition.
//
// @param request - SearchMediaRequest
//
// @return SearchMediaResponse
func (client *Client) SearchMedia(request *SearchMediaRequest) (_result *SearchMediaResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SearchMediaResponse{}
	_body, _err := client.SearchMediaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Manages the IP addresses in review security groups.
//
// Description:
//
// You can play videos in the Checking or Blocked state only from the IP addresses that are added to review security groups.
//
// @param request - SetAuditSecurityIpRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return SetAuditSecurityIpResponse
func (client *Client) SetAuditSecurityIpWithOptions(request *SetAuditSecurityIpRequest, runtime *util.RuntimeOptions) (_result *SetAuditSecurityIpResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Ips)) {
		query["Ips"] = request.Ips
	}

	if !tea.BoolValue(util.IsUnset(request.OperateMode)) {
		query["OperateMode"] = request.OperateMode
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityGroupName)) {
		query["SecurityGroupName"] = request.SecurityGroupName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetAuditSecurityIp"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &SetAuditSecurityIpResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &SetAuditSecurityIpResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Manages the IP addresses in review security groups.
//
// Description:
//
// You can play videos in the Checking or Blocked state only from the IP addresses that are added to review security groups.
//
// @param request - SetAuditSecurityIpRequest
//
// @return SetAuditSecurityIpResponse
func (client *Client) SetAuditSecurityIp(request *SetAuditSecurityIpRequest) (_result *SetAuditSecurityIpResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetAuditSecurityIpResponse{}
	_body, _err := client.SetAuditSecurityIpWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates the cross-domain policy file crossdomain.xml.
//
// Description:
//
// > After you use the cross-domain policy file to update the resources on the origin server, you must refresh the resources that are cached on Alibaba Cloud CDN nodes. You can use the ApsaraVideo VOD console to refresh resources. For more information, see [Refresh and prefetch](https://help.aliyun.com/document_detail/86098.html). Alternatively, you can call the [RefreshVodObjectCaches](https://help.aliyun.com/document_detail/69215.html) operation to refresh resources.
//
// @param request - SetCrossdomainContentRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return SetCrossdomainContentResponse
func (client *Client) SetCrossdomainContentWithOptions(request *SetCrossdomainContentRequest, runtime *util.RuntimeOptions) (_result *SetCrossdomainContentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Content)) {
		query["Content"] = request.Content
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceRealOwnerId)) {
		query["ResourceRealOwnerId"] = request.ResourceRealOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StorageLocation)) {
		query["StorageLocation"] = request.StorageLocation
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetCrossdomainContent"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &SetCrossdomainContentResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &SetCrossdomainContentResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Updates the cross-domain policy file crossdomain.xml.
//
// Description:
//
// > After you use the cross-domain policy file to update the resources on the origin server, you must refresh the resources that are cached on Alibaba Cloud CDN nodes. You can use the ApsaraVideo VOD console to refresh resources. For more information, see [Refresh and prefetch](https://help.aliyun.com/document_detail/86098.html). Alternatively, you can call the [RefreshVodObjectCaches](https://help.aliyun.com/document_detail/69215.html) operation to refresh resources.
//
// @param request - SetCrossdomainContentRequest
//
// @return SetCrossdomainContentResponse
func (client *Client) SetCrossdomainContent(request *SetCrossdomainContentRequest) (_result *SetCrossdomainContentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetCrossdomainContentResponse{}
	_body, _err := client.SetCrossdomainContentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Specifies an AI template as the default template.
//
// Description:
//
// Specifies an AI template as the default template.
//
// @param request - SetDefaultAITemplateRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return SetDefaultAITemplateResponse
func (client *Client) SetDefaultAITemplateWithOptions(request *SetDefaultAITemplateRequest, runtime *util.RuntimeOptions) (_result *SetDefaultAITemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		query["TemplateId"] = request.TemplateId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetDefaultAITemplate"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &SetDefaultAITemplateResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &SetDefaultAITemplateResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Specifies an AI template as the default template.
//
// Description:
//
// Specifies an AI template as the default template.
//
// @param request - SetDefaultAITemplateRequest
//
// @return SetDefaultAITemplateResponse
func (client *Client) SetDefaultAITemplate(request *SetDefaultAITemplateRequest) (_result *SetDefaultAITemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetDefaultAITemplateResponse{}
	_body, _err := client.SetDefaultAITemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Specifies a transcoding template group as the default one.
//
// @param request - SetDefaultTranscodeTemplateGroupRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return SetDefaultTranscodeTemplateGroupResponse
func (client *Client) SetDefaultTranscodeTemplateGroupWithOptions(request *SetDefaultTranscodeTemplateGroupRequest, runtime *util.RuntimeOptions) (_result *SetDefaultTranscodeTemplateGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TranscodeTemplateGroupId)) {
		query["TranscodeTemplateGroupId"] = request.TranscodeTemplateGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetDefaultTranscodeTemplateGroup"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &SetDefaultTranscodeTemplateGroupResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &SetDefaultTranscodeTemplateGroupResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Specifies a transcoding template group as the default one.
//
// @param request - SetDefaultTranscodeTemplateGroupRequest
//
// @return SetDefaultTranscodeTemplateGroupResponse
func (client *Client) SetDefaultTranscodeTemplateGroup(request *SetDefaultTranscodeTemplateGroupRequest) (_result *SetDefaultTranscodeTemplateGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetDefaultTranscodeTemplateGroupResponse{}
	_body, _err := client.SetDefaultTranscodeTemplateGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Sets a watermark template as the default one.
//
// @param request - SetDefaultWatermarkRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return SetDefaultWatermarkResponse
func (client *Client) SetDefaultWatermarkWithOptions(request *SetDefaultWatermarkRequest, runtime *util.RuntimeOptions) (_result *SetDefaultWatermarkResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.WatermarkId)) {
		query["WatermarkId"] = request.WatermarkId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetDefaultWatermark"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &SetDefaultWatermarkResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &SetDefaultWatermarkResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Sets a watermark template as the default one.
//
// @param request - SetDefaultWatermarkRequest
//
// @return SetDefaultWatermarkResponse
func (client *Client) SetDefaultWatermark(request *SetDefaultWatermarkRequest) (_result *SetDefaultWatermarkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetDefaultWatermarkResponse{}
	_body, _err := client.SetDefaultWatermarkWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Specifies the media assets that you want to edit in an online editing project.
//
// @param request - SetEditingProjectMaterialsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return SetEditingProjectMaterialsResponse
func (client *Client) SetEditingProjectMaterialsWithOptions(request *SetEditingProjectMaterialsRequest, runtime *util.RuntimeOptions) (_result *SetEditingProjectMaterialsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaterialIds)) {
		query["MaterialIds"] = request.MaterialIds
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetEditingProjectMaterials"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &SetEditingProjectMaterialsResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &SetEditingProjectMaterialsResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Specifies the media assets that you want to edit in an online editing project.
//
// @param request - SetEditingProjectMaterialsRequest
//
// @return SetEditingProjectMaterialsResponse
func (client *Client) SetEditingProjectMaterials(request *SetEditingProjectMaterialsRequest) (_result *SetEditingProjectMaterialsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetEditingProjectMaterialsResponse{}
	_body, _err := client.SetEditingProjectMaterialsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Sets the callback method, callback URL, and event type of an event notification.
//
// Description:
//
// HTTP callbacks and MNS callbacks are supported. For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
//
// @param request - SetMessageCallbackRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return SetMessageCallbackResponse
func (client *Client) SetMessageCallbackWithOptions(request *SetMessageCallbackRequest, runtime *util.RuntimeOptions) (_result *SetMessageCallbackResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AuthKey)) {
		query["AuthKey"] = request.AuthKey
	}

	if !tea.BoolValue(util.IsUnset(request.AuthSwitch)) {
		query["AuthSwitch"] = request.AuthSwitch
	}

	if !tea.BoolValue(util.IsUnset(request.CallbackType)) {
		query["CallbackType"] = request.CallbackType
	}

	if !tea.BoolValue(util.IsUnset(request.CallbackURL)) {
		query["CallbackURL"] = request.CallbackURL
	}

	if !tea.BoolValue(util.IsUnset(request.EventTypeList)) {
		query["EventTypeList"] = request.EventTypeList
	}

	if !tea.BoolValue(util.IsUnset(request.MnsEndpoint)) {
		query["MnsEndpoint"] = request.MnsEndpoint
	}

	if !tea.BoolValue(util.IsUnset(request.MnsQueueName)) {
		query["MnsQueueName"] = request.MnsQueueName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetMessageCallback"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &SetMessageCallbackResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &SetMessageCallbackResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Sets the callback method, callback URL, and event type of an event notification.
//
// Description:
//
// HTTP callbacks and MNS callbacks are supported. For more information, see [Overview](https://help.aliyun.com/document_detail/55627.html).
//
// @param request - SetMessageCallbackRequest
//
// @return SetMessageCallbackResponse
func (client *Client) SetMessageCallback(request *SetMessageCallbackRequest) (_result *SetMessageCallbackResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetMessageCallbackResponse{}
	_body, _err := client.SetMessageCallbackWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Enables or disables the certificate of a domain name and modifies the certificate information.
//
// Description:
//
// > This operation is available only in the **China (Shanghai)*	- region.
//
// @param request - SetVodDomainCertificateRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return SetVodDomainCertificateResponse
func (client *Client) SetVodDomainCertificateWithOptions(request *SetVodDomainCertificateRequest, runtime *util.RuntimeOptions) (_result *SetVodDomainCertificateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CertName)) {
		query["CertName"] = request.CertName
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SSLPri)) {
		query["SSLPri"] = request.SSLPri
	}

	if !tea.BoolValue(util.IsUnset(request.SSLProtocol)) {
		query["SSLProtocol"] = request.SSLProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.SSLPub)) {
		query["SSLPub"] = request.SSLPub
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetVodDomainCertificate"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &SetVodDomainCertificateResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &SetVodDomainCertificateResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Enables or disables the certificate of a domain name and modifies the certificate information.
//
// Description:
//
// > This operation is available only in the **China (Shanghai)*	- region.
//
// @param request - SetVodDomainCertificateRequest
//
// @return SetVodDomainCertificateResponse
func (client *Client) SetVodDomainCertificate(request *SetVodDomainCertificateRequest) (_result *SetVodDomainCertificateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetVodDomainCertificateResponse{}
	_body, _err := client.SetVodDomainCertificateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Enables or disables the SSL certificate of a domain name and updates the certificate information.
//
// @param request - SetVodDomainSSLCertificateRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return SetVodDomainSSLCertificateResponse
func (client *Client) SetVodDomainSSLCertificateWithOptions(request *SetVodDomainSSLCertificateRequest, runtime *util.RuntimeOptions) (_result *SetVodDomainSSLCertificateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CertId)) {
		query["CertId"] = request.CertId
	}

	if !tea.BoolValue(util.IsUnset(request.CertName)) {
		query["CertName"] = request.CertName
	}

	if !tea.BoolValue(util.IsUnset(request.CertRegion)) {
		query["CertRegion"] = request.CertRegion
	}

	if !tea.BoolValue(util.IsUnset(request.CertType)) {
		query["CertType"] = request.CertType
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.Env)) {
		query["Env"] = request.Env
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SSLPri)) {
		query["SSLPri"] = request.SSLPri
	}

	if !tea.BoolValue(util.IsUnset(request.SSLProtocol)) {
		query["SSLProtocol"] = request.SSLProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.SSLPub)) {
		query["SSLPub"] = request.SSLPub
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetVodDomainSSLCertificate"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &SetVodDomainSSLCertificateResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &SetVodDomainSSLCertificateResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Enables or disables the SSL certificate of a domain name and updates the certificate information.
//
// @param request - SetVodDomainSSLCertificateRequest
//
// @return SetVodDomainSSLCertificateResponse
func (client *Client) SetVodDomainSSLCertificate(request *SetVodDomainSSLCertificateRequest) (_result *SetVodDomainSSLCertificateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetVodDomainSSLCertificateResponse{}
	_body, _err := client.SetVodDomainSSLCertificateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Submits an automated review job for an image. After the job is submitted, the job is processed in an asynchronous manner. The operation may return a response before the job is complete.
//
// Description:
//
// This operation is available only in the Singapore region.
//
// @param request - SubmitAIImageAuditJobRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return SubmitAIImageAuditJobResponse
func (client *Client) SubmitAIImageAuditJobWithOptions(request *SubmitAIImageAuditJobRequest, runtime *util.RuntimeOptions) (_result *SubmitAIImageAuditJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaAuditConfiguration)) {
		query["MediaAuditConfiguration"] = request.MediaAuditConfiguration
	}

	if !tea.BoolValue(util.IsUnset(request.MediaId)) {
		query["MediaId"] = request.MediaId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		query["TemplateId"] = request.TemplateId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SubmitAIImageAuditJob"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &SubmitAIImageAuditJobResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &SubmitAIImageAuditJobResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Submits an automated review job for an image. After the job is submitted, the job is processed in an asynchronous manner. The operation may return a response before the job is complete.
//
// Description:
//
// This operation is available only in the Singapore region.
//
// @param request - SubmitAIImageAuditJobRequest
//
// @return SubmitAIImageAuditJobResponse
func (client *Client) SubmitAIImageAuditJob(request *SubmitAIImageAuditJobRequest) (_result *SubmitAIImageAuditJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SubmitAIImageAuditJobResponse{}
	_body, _err := client.SubmitAIImageAuditJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Submits jobs of image AI processing.
//
// Description:
//
//   Regions that support this operation: **China (Beijing)*	- and **China (Shanghai)**.
//
// 	- After you call this operation, you can call the [GetAIImageJobs](https://help.aliyun.com/document_detail/186923.html) operation to query the job execution result.
//
// @param request - SubmitAIImageJobRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return SubmitAIImageJobResponse
func (client *Client) SubmitAIImageJobWithOptions(request *SubmitAIImageJobRequest, runtime *util.RuntimeOptions) (_result *SubmitAIImageJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AIPipelineId)) {
		query["AIPipelineId"] = request.AIPipelineId
	}

	if !tea.BoolValue(util.IsUnset(request.AITemplateId)) {
		query["AITemplateId"] = request.AITemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SubmitAIImageJob"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &SubmitAIImageJobResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &SubmitAIImageJobResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Submits jobs of image AI processing.
//
// Description:
//
//   Regions that support this operation: **China (Beijing)*	- and **China (Shanghai)**.
//
// 	- After you call this operation, you can call the [GetAIImageJobs](https://help.aliyun.com/document_detail/186923.html) operation to query the job execution result.
//
// @param request - SubmitAIImageJobRequest
//
// @return SubmitAIImageJobResponse
func (client *Client) SubmitAIImageJob(request *SubmitAIImageJobRequest) (_result *SubmitAIImageJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SubmitAIImageJobResponse{}
	_body, _err := client.SubmitAIImageJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Submits a smart tagging or video fingerprinting job.
//
// Description:
//
//   **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. You are charged for using the smart tagging and video fingerprinting features. For more information, see [Billing of video AI](~~188310#section-g7l-s3o-9ng~~).**
//
// 	- Regions that support the video fingerprinting feature: **China (Beijing)**, **China (Shanghai)**, and **Singapore**. Regions that support the smart tagging feature: **China (Beijing)*	- and **China (Shanghai)**.
//
// 	- You need to enable the video fingerprinting feature or the smart tagging feature before you can call this operation to submit jobs. For more information, see [Overview](https://help.aliyun.com/document_detail/101148.html).
//
// 	- If this is the first time you use the video fingerprinting feature, you must submit a ticket to apply for using the media fingerprint library for free. Otherwise, the video fingerprinting feature will be affected. For more information about how to submit a ticket, see [Contact us](https://help.aliyun.com/document_detail/464625.html).
//
// 	- After you submit an AI job, ApsaraVideo VOD asynchronously processes the job. The operation may return a response before the job is complete. You can configure the [Event Notification](https://help.aliyun.com/document_detail/55627.html) feature and set the callback event to **AI Processing Completed**. After you receive the event notification, you can query the execution result of the AI job.
//
// @param request - SubmitAIJobRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return SubmitAIJobResponse
func (client *Client) SubmitAIJobWithOptions(request *SubmitAIJobRequest, runtime *util.RuntimeOptions) (_result *SubmitAIJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Config)) {
		query["Config"] = request.Config
	}

	if !tea.BoolValue(util.IsUnset(request.MediaId)) {
		query["MediaId"] = request.MediaId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Types)) {
		query["Types"] = request.Types
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SubmitAIJob"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &SubmitAIJobResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &SubmitAIJobResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Submits a smart tagging or video fingerprinting job.
//
// Description:
//
//   **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. You are charged for using the smart tagging and video fingerprinting features. For more information, see [Billing of video AI](~~188310#section-g7l-s3o-9ng~~).**
//
// 	- Regions that support the video fingerprinting feature: **China (Beijing)**, **China (Shanghai)**, and **Singapore**. Regions that support the smart tagging feature: **China (Beijing)*	- and **China (Shanghai)**.
//
// 	- You need to enable the video fingerprinting feature or the smart tagging feature before you can call this operation to submit jobs. For more information, see [Overview](https://help.aliyun.com/document_detail/101148.html).
//
// 	- If this is the first time you use the video fingerprinting feature, you must submit a ticket to apply for using the media fingerprint library for free. Otherwise, the video fingerprinting feature will be affected. For more information about how to submit a ticket, see [Contact us](https://help.aliyun.com/document_detail/464625.html).
//
// 	- After you submit an AI job, ApsaraVideo VOD asynchronously processes the job. The operation may return a response before the job is complete. You can configure the [Event Notification](https://help.aliyun.com/document_detail/55627.html) feature and set the callback event to **AI Processing Completed**. After you receive the event notification, you can query the execution result of the AI job.
//
// @param request - SubmitAIJobRequest
//
// @return SubmitAIJobResponse
func (client *Client) SubmitAIJob(request *SubmitAIJobRequest) (_result *SubmitAIJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SubmitAIJobResponse{}
	_body, _err := client.SubmitAIJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Submits an automated review job for a media file. After the job is submitted, ApsaraVideo VOD asynchronously processes the job. Therefore, the operation may return a response before the job is complete.
//
// Description:
//
//   **Make sure that you understand the billing methods and price of ApsaraVideo VOD before you call this operation. You are charged for using the automated review feature. For more information about billing, submit a ticket or contact your account manager.**
//
// 	- You can call this operation only in the **China (Shanghai)**, **China (Beijing)**, and **Singapore*	- regions.
//
// 	- For more information, see [Automated review](https://help.aliyun.com/document_detail/101148.html).
//
// 	- After an automated review job is complete, the images generated during the review are stored in the VOD bucket for two weeks free of charge. The images are automatically deleted after two weeks.
//
// @param request - SubmitAIMediaAuditJobRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return SubmitAIMediaAuditJobResponse
func (client *Client) SubmitAIMediaAuditJobWithOptions(request *SubmitAIMediaAuditJobRequest, runtime *util.RuntimeOptions) (_result *SubmitAIMediaAuditJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaAuditConfiguration)) {
		query["MediaAuditConfiguration"] = request.MediaAuditConfiguration
	}

	if !tea.BoolValue(util.IsUnset(request.MediaId)) {
		query["MediaId"] = request.MediaId
	}

	if !tea.BoolValue(util.IsUnset(request.MediaType)) {
		query["MediaType"] = request.MediaType
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		query["TemplateId"] = request.TemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SubmitAIMediaAuditJob"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &SubmitAIMediaAuditJobResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &SubmitAIMediaAuditJobResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Submits an automated review job for a media file. After the job is submitted, ApsaraVideo VOD asynchronously processes the job. Therefore, the operation may return a response before the job is complete.
//
// Description:
//
//   **Make sure that you understand the billing methods and price of ApsaraVideo VOD before you call this operation. You are charged for using the automated review feature. For more information about billing, submit a ticket or contact your account manager.**
//
// 	- You can call this operation only in the **China (Shanghai)**, **China (Beijing)**, and **Singapore*	- regions.
//
// 	- For more information, see [Automated review](https://help.aliyun.com/document_detail/101148.html).
//
// 	- After an automated review job is complete, the images generated during the review are stored in the VOD bucket for two weeks free of charge. The images are automatically deleted after two weeks.
//
// @param request - SubmitAIMediaAuditJobRequest
//
// @return SubmitAIMediaAuditJobResponse
func (client *Client) SubmitAIMediaAuditJob(request *SubmitAIMediaAuditJobRequest) (_result *SubmitAIMediaAuditJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SubmitAIMediaAuditJobResponse{}
	_body, _err := client.SubmitAIMediaAuditJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Submits a digital watermark extraction job. You can call this operation to asynchronously extract a copyright watermark or user-tracing watermark.
//
// Description:
//
//   **Make sure that you understand the billing methods and price of ApsaraVideo VOD before you call this operation. You are charged for generating and extracting digital watermarks. For more information, see [Billing](~~188310#62b9c940403se~~).**
//
// 	- This operation is supported only in the **China (Shanghai)*	- and **China (Beijing)*	- regions.
//
// 	- Before you submit a digital watermark extraction job, make sure that the following conditions are met:
//
//     	- The video from which you want to extract the watermark is uploaded to the ApsaraVideo VOD.
//
//     	- The video from which you want to extract the watermark is longer than 6 minutes.
//
// @param request - SubmitDigitalWatermarkExtractJobRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return SubmitDigitalWatermarkExtractJobResponse
func (client *Client) SubmitDigitalWatermarkExtractJobWithOptions(request *SubmitDigitalWatermarkExtractJobRequest, runtime *util.RuntimeOptions) (_result *SubmitDigitalWatermarkExtractJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ExtractType)) {
		query["ExtractType"] = request.ExtractType
	}

	if !tea.BoolValue(util.IsUnset(request.MediaId)) {
		query["MediaId"] = request.MediaId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SubmitDigitalWatermarkExtractJob"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &SubmitDigitalWatermarkExtractJobResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &SubmitDigitalWatermarkExtractJobResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Submits a digital watermark extraction job. You can call this operation to asynchronously extract a copyright watermark or user-tracing watermark.
//
// Description:
//
//   **Make sure that you understand the billing methods and price of ApsaraVideo VOD before you call this operation. You are charged for generating and extracting digital watermarks. For more information, see [Billing](~~188310#62b9c940403se~~).**
//
// 	- This operation is supported only in the **China (Shanghai)*	- and **China (Beijing)*	- regions.
//
// 	- Before you submit a digital watermark extraction job, make sure that the following conditions are met:
//
//     	- The video from which you want to extract the watermark is uploaded to the ApsaraVideo VOD.
//
//     	- The video from which you want to extract the watermark is longer than 6 minutes.
//
// @param request - SubmitDigitalWatermarkExtractJobRequest
//
// @return SubmitDigitalWatermarkExtractJobResponse
func (client *Client) SubmitDigitalWatermarkExtractJob(request *SubmitDigitalWatermarkExtractJobRequest) (_result *SubmitDigitalWatermarkExtractJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SubmitDigitalWatermarkExtractJobResponse{}
	_body, _err := client.SubmitDigitalWatermarkExtractJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Submits a frame animation job and starts asynchronous processing.
//
// Description:
//
//   You can capture a part of a video and generate animated images only when the video is in the **Uploaded**, **Transcoding**, **Normal**, **Reviewing**, or **Flagged*	- state.
//
// 	- The fees for frame animation are included in your video transcoding bill. You are charged based on the output resolution and the duration. For more information, see [Billing of basic services](https://help.aliyun.com/document_detail/188308.html).
//
// ### QPS limits
//
// You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on API operations](https://help.aliyun.com/document_detail/342790.html).
//
// @param request - SubmitDynamicImageJobRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return SubmitDynamicImageJobResponse
func (client *Client) SubmitDynamicImageJobWithOptions(request *SubmitDynamicImageJobRequest, runtime *util.RuntimeOptions) (_result *SubmitDynamicImageJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DynamicImageTemplateId)) {
		query["DynamicImageTemplateId"] = request.DynamicImageTemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.OverrideParams)) {
		query["OverrideParams"] = request.OverrideParams
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SubmitDynamicImageJob"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &SubmitDynamicImageJobResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &SubmitDynamicImageJobResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Submits a frame animation job and starts asynchronous processing.
//
// Description:
//
//   You can capture a part of a video and generate animated images only when the video is in the **Uploaded**, **Transcoding**, **Normal**, **Reviewing**, or **Flagged*	- state.
//
// 	- The fees for frame animation are included in your video transcoding bill. You are charged based on the output resolution and the duration. For more information, see [Billing of basic services](https://help.aliyun.com/document_detail/188308.html).
//
// ### QPS limits
//
// You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on API operations](https://help.aliyun.com/document_detail/342790.html).
//
// @param request - SubmitDynamicImageJobRequest
//
// @return SubmitDynamicImageJobResponse
func (client *Client) SubmitDynamicImageJob(request *SubmitDynamicImageJobRequest) (_result *SubmitDynamicImageJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SubmitDynamicImageJobResponse{}
	_body, _err := client.SubmitDynamicImageJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Deletes a video fingerprinting job.
//
// Description:
//
// Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
//
// @param request - SubmitMediaDNADeleteJobRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return SubmitMediaDNADeleteJobResponse
func (client *Client) SubmitMediaDNADeleteJobWithOptions(request *SubmitMediaDNADeleteJobRequest, runtime *util.RuntimeOptions) (_result *SubmitMediaDNADeleteJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaId)) {
		query["MediaId"] = request.MediaId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SubmitMediaDNADeleteJob"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &SubmitMediaDNADeleteJobResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &SubmitMediaDNADeleteJobResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Deletes a video fingerprinting job.
//
// Description:
//
// Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
//
// @param request - SubmitMediaDNADeleteJobRequest
//
// @return SubmitMediaDNADeleteJobResponse
func (client *Client) SubmitMediaDNADeleteJob(request *SubmitMediaDNADeleteJobRequest) (_result *SubmitMediaDNADeleteJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SubmitMediaDNADeleteJobResponse{}
	_body, _err := client.SubmitMediaDNADeleteJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Transcodes a video by using the production studio.
//
// Description:
//
//   During video preprocessing, videos are transcoded to meet the playback requirements of the production studio. Therefore, **you are charged for video preprocessing**. For more information about billing, see [Billing of production studios](https://help.aliyun.com/document_detail/64531.html).
//
// 	- You can obtain the preprocessing result in the [TranscodeComplete](https://help.aliyun.com/document_detail/55638.html) event notification. If **Preprocess=true*	- is returned in the event notification, the video is transcoded.
//
// @param request - SubmitPreprocessJobsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return SubmitPreprocessJobsResponse
func (client *Client) SubmitPreprocessJobsWithOptions(request *SubmitPreprocessJobsRequest, runtime *util.RuntimeOptions) (_result *SubmitPreprocessJobsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PreprocessType)) {
		query["PreprocessType"] = request.PreprocessType
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SubmitPreprocessJobs"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &SubmitPreprocessJobsResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &SubmitPreprocessJobsResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Transcodes a video by using the production studio.
//
// Description:
//
//   During video preprocessing, videos are transcoded to meet the playback requirements of the production studio. Therefore, **you are charged for video preprocessing**. For more information about billing, see [Billing of production studios](https://help.aliyun.com/document_detail/64531.html).
//
// 	- You can obtain the preprocessing result in the [TranscodeComplete](https://help.aliyun.com/document_detail/55638.html) event notification. If **Preprocess=true*	- is returned in the event notification, the video is transcoded.
//
// @param request - SubmitPreprocessJobsRequest
//
// @return SubmitPreprocessJobsResponse
func (client *Client) SubmitPreprocessJobs(request *SubmitPreprocessJobsRequest) (_result *SubmitPreprocessJobsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SubmitPreprocessJobsResponse{}
	_body, _err := client.SubmitPreprocessJobsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Submits a snapshot job for a video and starts asynchronous snapshot processing.
//
// Description:
//
//   Only snapshots in the JPG format are generated.
//
// 	- After a snapshot is captured, the [SnapshotComplete](https://help.aliyun.com/document_detail/57337.html) callback is fired and EventType=SnapshotComplete, SubType=SpecifiedTime is returned.
//
// ### [](#qps-)QPS limits
//
// You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/342790.html).
//
// @param tmpReq - SubmitSnapshotJobRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return SubmitSnapshotJobResponse
func (client *Client) SubmitSnapshotJobWithOptions(tmpReq *SubmitSnapshotJobRequest, runtime *util.RuntimeOptions) (_result *SubmitSnapshotJobResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &SubmitSnapshotJobShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.SpecifiedOffsetTimes)) {
		request.SpecifiedOffsetTimesShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.SpecifiedOffsetTimes, tea.String("SpecifiedOffsetTimes"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Count)) {
		query["Count"] = request.Count
	}

	if !tea.BoolValue(util.IsUnset(request.Height)) {
		query["Height"] = request.Height
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.SnapshotTemplateId)) {
		query["SnapshotTemplateId"] = request.SnapshotTemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.SpecifiedOffsetTime)) {
		query["SpecifiedOffsetTime"] = request.SpecifiedOffsetTime
	}

	if !tea.BoolValue(util.IsUnset(request.SpecifiedOffsetTimesShrink)) {
		query["SpecifiedOffsetTimes"] = request.SpecifiedOffsetTimesShrink
	}

	if !tea.BoolValue(util.IsUnset(request.SpriteSnapshotConfig)) {
		query["SpriteSnapshotConfig"] = request.SpriteSnapshotConfig
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	if !tea.BoolValue(util.IsUnset(request.Width)) {
		query["Width"] = request.Width
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SubmitSnapshotJob"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &SubmitSnapshotJobResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &SubmitSnapshotJobResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Submits a snapshot job for a video and starts asynchronous snapshot processing.
//
// Description:
//
//   Only snapshots in the JPG format are generated.
//
// 	- After a snapshot is captured, the [SnapshotComplete](https://help.aliyun.com/document_detail/57337.html) callback is fired and EventType=SnapshotComplete, SubType=SpecifiedTime is returned.
//
// ### [](#qps-)QPS limits
//
// You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/342790.html).
//
// @param request - SubmitSnapshotJobRequest
//
// @return SubmitSnapshotJobResponse
func (client *Client) SubmitSnapshotJob(request *SubmitSnapshotJobRequest) (_result *SubmitSnapshotJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SubmitSnapshotJobResponse{}
	_body, _err := client.SubmitSnapshotJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Submits a transcoding job to start transcoding in an asynchronous manner.
//
// Description:
//
// ### [](#)Usage notes
//
// 	- **Make sure that you understand the billing methods and prices of ApsaraVideo VOD before you call this operation. For more information about billing of the transcoding feature, see [Billing of basic services](~~188308#section-ejb-nii-nqa~~).**
//
// 	- You can transcode a video only in the Uploaded, Normal, or Reviewing state.
//
// 	- You can obtain the transcoding results from the [StreamTranscodeComplete](https://help.aliyun.com/document_detail/55636.html) or [TranscodeComplete](https://help.aliyun.com/document_detail/55638.html) callback.
//
// 	- You can call this operation to dynamically override the subtitle URL in an HTTP Live Streaming (HLS) packaging task. If the packaging task does not contain subtitles, we recommend that you specify the ID of the specific packaging template group when you upload the video instead of calling this operation.
//
// @param request - SubmitTranscodeJobsRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return SubmitTranscodeJobsResponse
func (client *Client) SubmitTranscodeJobsWithOptions(request *SubmitTranscodeJobsRequest, runtime *util.RuntimeOptions) (_result *SubmitTranscodeJobsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EncryptConfig)) {
		query["EncryptConfig"] = request.EncryptConfig
	}

	if !tea.BoolValue(util.IsUnset(request.OverrideParams)) {
		query["OverrideParams"] = request.OverrideParams
	}

	if !tea.BoolValue(util.IsUnset(request.PipelineId)) {
		query["PipelineId"] = request.PipelineId
	}

	if !tea.BoolValue(util.IsUnset(request.Priority)) {
		query["Priority"] = request.Priority
	}

	if !tea.BoolValue(util.IsUnset(request.SessionId)) {
		query["SessionId"] = request.SessionId
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateGroupId)) {
		query["TemplateGroupId"] = request.TemplateGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SubmitTranscodeJobs"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &SubmitTranscodeJobsResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &SubmitTranscodeJobsResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Submits a transcoding job to start transcoding in an asynchronous manner.
//
// Description:
//
// ### [](#)Usage notes
//
// 	- **Make sure that you understand the billing methods and prices of ApsaraVideo VOD before you call this operation. For more information about billing of the transcoding feature, see [Billing of basic services](~~188308#section-ejb-nii-nqa~~).**
//
// 	- You can transcode a video only in the Uploaded, Normal, or Reviewing state.
//
// 	- You can obtain the transcoding results from the [StreamTranscodeComplete](https://help.aliyun.com/document_detail/55636.html) or [TranscodeComplete](https://help.aliyun.com/document_detail/55638.html) callback.
//
// 	- You can call this operation to dynamically override the subtitle URL in an HTTP Live Streaming (HLS) packaging task. If the packaging task does not contain subtitles, we recommend that you specify the ID of the specific packaging template group when you upload the video instead of calling this operation.
//
// @param request - SubmitTranscodeJobsRequest
//
// @return SubmitTranscodeJobsResponse
func (client *Client) SubmitTranscodeJobs(request *SubmitTranscodeJobsRequest) (_result *SubmitTranscodeJobsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SubmitTranscodeJobsResponse{}
	_body, _err := client.SubmitTranscodeJobsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Initiates a workflow to process media files.
//
// Description:
//
// **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. When you use workflows to process videos, you may be charged for transcoding, encryption, and automated review. For more information, see [Billing overview](https://help.aliyun.com/document_detail/188307.html).**
//
// 	- You can call this operation to initiate a VOD workflow to process media files. For more information, see [Workflows](https://help.aliyun.com/document_detail/115347.html).
//
// @param request - SubmitWorkflowJobRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return SubmitWorkflowJobResponse
func (client *Client) SubmitWorkflowJobWithOptions(request *SubmitWorkflowJobRequest, runtime *util.RuntimeOptions) (_result *SubmitWorkflowJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaId)) {
		query["MediaId"] = request.MediaId
	}

	if !tea.BoolValue(util.IsUnset(request.WorkflowId)) {
		query["WorkflowId"] = request.WorkflowId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SubmitWorkflowJob"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &SubmitWorkflowJobResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &SubmitWorkflowJobResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Initiates a workflow to process media files.
//
// Description:
//
// **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. When you use workflows to process videos, you may be charged for transcoding, encryption, and automated review. For more information, see [Billing overview](https://help.aliyun.com/document_detail/188307.html).**
//
// 	- You can call this operation to initiate a VOD workflow to process media files. For more information, see [Workflows](https://help.aliyun.com/document_detail/115347.html).
//
// @param request - SubmitWorkflowJobRequest
//
// @return SubmitWorkflowJobResponse
func (client *Client) SubmitWorkflowJob(request *SubmitWorkflowJobRequest) (_result *SubmitWorkflowJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SubmitWorkflowJobResponse{}
	_body, _err := client.SubmitWorkflowJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies an AI template.
//
// Description:
//
//   Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
//
// 	- After you call the [AddAITemplate](https://help.aliyun.com/document_detail/102930.html) operation to add an AI template, you can call this operation to modify the AI template.
//
// @param request - UpdateAITemplateRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateAITemplateResponse
func (client *Client) UpdateAITemplateWithOptions(request *UpdateAITemplateRequest, runtime *util.RuntimeOptions) (_result *UpdateAITemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TemplateConfig)) {
		query["TemplateConfig"] = request.TemplateConfig
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		query["TemplateId"] = request.TemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateName)) {
		query["TemplateName"] = request.TemplateName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAITemplate"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &UpdateAITemplateResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &UpdateAITemplateResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Modifies an AI template.
//
// Description:
//
//   Regions that support this operation: **China (Beijing)**, **China (Shanghai)**, and **Singapore**.
//
// 	- After you call the [AddAITemplate](https://help.aliyun.com/document_detail/102930.html) operation to add an AI template, you can call this operation to modify the AI template.
//
// @param request - UpdateAITemplateRequest
//
// @return UpdateAITemplateResponse
func (client *Client) UpdateAITemplate(request *UpdateAITemplateRequest) (_result *UpdateAITemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateAITemplateResponse{}
	_body, _err := client.UpdateAITemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Updates the information about an application.
//
// Description:
//
// ## QPS limit
//
// A single user can perform a maximum of 30 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation.
//
// @param request - UpdateAppInfoRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateAppInfoResponse
func (client *Client) UpdateAppInfoWithOptions(request *UpdateAppInfoRequest, runtime *util.RuntimeOptions) (_result *UpdateAppInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAppInfo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &UpdateAppInfoResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &UpdateAppInfoResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Updates the information about an application.
//
// Description:
//
// ## QPS limit
//
// A single user can perform a maximum of 30 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation.
//
// @param request - UpdateAppInfoRequest
//
// @return UpdateAppInfoResponse
func (client *Client) UpdateAppInfo(request *UpdateAppInfoRequest) (_result *UpdateAppInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateAppInfoResponse{}
	_body, _err := client.UpdateAppInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the information about multiple auxiliary media assets such as watermark images, subtitle files, and materials in a batch based on IDs. You can modify information such as the title, description, tags, and category.
//
// Description:
//
// You can modify the information about up to 20 auxiliary media assets at a time.
//
// @param request - UpdateAttachedMediaInfosRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateAttachedMediaInfosResponse
func (client *Client) UpdateAttachedMediaInfosWithOptions(request *UpdateAttachedMediaInfosRequest, runtime *util.RuntimeOptions) (_result *UpdateAttachedMediaInfosResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.UpdateContent)) {
		query["UpdateContent"] = request.UpdateContent
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAttachedMediaInfos"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &UpdateAttachedMediaInfosResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &UpdateAttachedMediaInfosResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Modifies the information about multiple auxiliary media assets such as watermark images, subtitle files, and materials in a batch based on IDs. You can modify information such as the title, description, tags, and category.
//
// Description:
//
// You can modify the information about up to 20 auxiliary media assets at a time.
//
// @param request - UpdateAttachedMediaInfosRequest
//
// @return UpdateAttachedMediaInfosResponse
func (client *Client) UpdateAttachedMediaInfos(request *UpdateAttachedMediaInfosRequest) (_result *UpdateAttachedMediaInfosResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateAttachedMediaInfosResponse{}
	_body, _err := client.UpdateAttachedMediaInfosWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies a video category.
//
// Description:
//
// After you create a category, you can call this operation to modify the name of the category. If you have classified specific media resources to this category, the category names that are labeled on the media resources are automatically updated.
//
// @param request - UpdateCategoryRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateCategoryResponse
func (client *Client) UpdateCategoryWithOptions(request *UpdateCategoryRequest, runtime *util.RuntimeOptions) (_result *UpdateCategoryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CateId)) {
		query["CateId"] = request.CateId
	}

	if !tea.BoolValue(util.IsUnset(request.CateName)) {
		query["CateName"] = request.CateName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateCategory"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &UpdateCategoryResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &UpdateCategoryResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Modifies a video category.
//
// Description:
//
// After you create a category, you can call this operation to modify the name of the category. If you have classified specific media resources to this category, the category names that are labeled on the media resources are automatically updated.
//
// @param request - UpdateCategoryRequest
//
// @return UpdateCategoryResponse
func (client *Client) UpdateCategory(request *UpdateCategoryRequest) (_result *UpdateCategoryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateCategoryResponse{}
	_body, _err := client.UpdateCategoryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies an online editing project.
//
// @param request - UpdateEditingProjectRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateEditingProjectResponse
func (client *Client) UpdateEditingProjectWithOptions(request *UpdateEditingProjectRequest, runtime *util.RuntimeOptions) (_result *UpdateEditingProjectResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CoverURL)) {
		query["CoverURL"] = request.CoverURL
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Timeline)) {
		query["Timeline"] = request.Timeline
	}

	if !tea.BoolValue(util.IsUnset(request.Title)) {
		query["Title"] = request.Title
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateEditingProject"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &UpdateEditingProjectResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &UpdateEditingProjectResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Modifies an online editing project.
//
// @param request - UpdateEditingProjectRequest
//
// @return UpdateEditingProjectResponse
func (client *Client) UpdateEditingProject(request *UpdateEditingProjectRequest) (_result *UpdateEditingProjectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateEditingProjectResponse{}
	_body, _err := client.UpdateEditingProjectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the information about one or more images at a time.
//
// Description:
//
//   You can call this operation to modify information such as the title, tags, description, and category about images based on image IDs. You must pass in the parameters that you want to modify. Otherwise, parameter configurations are not overwritten.
//
// 	- You can modify the information about up to 20 images at a time.
//
// @param request - UpdateImageInfosRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateImageInfosResponse
func (client *Client) UpdateImageInfosWithOptions(request *UpdateImageInfosRequest, runtime *util.RuntimeOptions) (_result *UpdateImageInfosResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.UpdateContent)) {
		query["UpdateContent"] = request.UpdateContent
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateImageInfos"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &UpdateImageInfosResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &UpdateImageInfosResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Modifies the information about one or more images at a time.
//
// Description:
//
//   You can call this operation to modify information such as the title, tags, description, and category about images based on image IDs. You must pass in the parameters that you want to modify. Otherwise, parameter configurations are not overwritten.
//
// 	- You can modify the information about up to 20 images at a time.
//
// @param request - UpdateImageInfosRequest
//
// @return UpdateImageInfosResponse
func (client *Client) UpdateImageInfos(request *UpdateImageInfosRequest) (_result *UpdateImageInfosResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateImageInfosResponse{}
	_body, _err := client.UpdateImageInfosWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the storage classes of media assets.
//
// Description:
//
//   This operation is an asynchronous operation. You can call this operation to modify the storage classes of media assets. After the storage class is modified, a callback notification is sent.
//
// 	- If the storage class of the media asset is Archive or Cold Archive and you call this operation to modify the storage class of the media asset, the media asset is automatically restored before the storage class is modified. You do not need to call the RestoreMedia operation to restore the media asset. You must specify the restoration priority for Cold Archive objects. Default configuration: RestoreTier=Standard.
//
// 	- Media assets whose storage classes are being modified cannot be used or processed.
//
// 	- Non-Standard objects have minimum storage durations. If an object is stored for less than the minimum storage duration, the storage class of the object cannot be changed. The following content describes the minimum storage durations for objects in different storage classes: IA or IA storage for source files: 30 days, Archive or Archive storage for source files: 60 days, Cold Archive or Cold Archive for source files: 180 days.
//
// @param request - UpdateMediaStorageClassRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateMediaStorageClassResponse
func (client *Client) UpdateMediaStorageClassWithOptions(request *UpdateMediaStorageClassRequest, runtime *util.RuntimeOptions) (_result *UpdateMediaStorageClassResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AllowUpdateWithoutTimeLimit)) {
		query["AllowUpdateWithoutTimeLimit"] = request.AllowUpdateWithoutTimeLimit
	}

	if !tea.BoolValue(util.IsUnset(request.MediaIds)) {
		query["MediaIds"] = request.MediaIds
	}

	if !tea.BoolValue(util.IsUnset(request.RestoreTier)) {
		query["RestoreTier"] = request.RestoreTier
	}

	if !tea.BoolValue(util.IsUnset(request.Scope)) {
		query["Scope"] = request.Scope
	}

	if !tea.BoolValue(util.IsUnset(request.StorageClass)) {
		query["StorageClass"] = request.StorageClass
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateMediaStorageClass"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &UpdateMediaStorageClassResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &UpdateMediaStorageClassResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Modifies the storage classes of media assets.
//
// Description:
//
//   This operation is an asynchronous operation. You can call this operation to modify the storage classes of media assets. After the storage class is modified, a callback notification is sent.
//
// 	- If the storage class of the media asset is Archive or Cold Archive and you call this operation to modify the storage class of the media asset, the media asset is automatically restored before the storage class is modified. You do not need to call the RestoreMedia operation to restore the media asset. You must specify the restoration priority for Cold Archive objects. Default configuration: RestoreTier=Standard.
//
// 	- Media assets whose storage classes are being modified cannot be used or processed.
//
// 	- Non-Standard objects have minimum storage durations. If an object is stored for less than the minimum storage duration, the storage class of the object cannot be changed. The following content describes the minimum storage durations for objects in different storage classes: IA or IA storage for source files: 30 days, Archive or Archive storage for source files: 60 days, Cold Archive or Cold Archive for source files: 180 days.
//
// @param request - UpdateMediaStorageClassRequest
//
// @return UpdateMediaStorageClassResponse
func (client *Client) UpdateMediaStorageClass(request *UpdateMediaStorageClassRequest) (_result *UpdateMediaStorageClassResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateMediaStorageClassResponse{}
	_body, _err := client.UpdateMediaStorageClassWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the configurations of a transcoding template group or configurations of transcoding templates in the transcoding template group.
//
// Description:
//
// For security purposes, you cannot add, modify, or delete transcoding templates in a transcoding template group that is locked. You can call the [GetTranscodeTemplateGroup](~~GetTranscodeTemplateGroup~~) operation to query the configurations of a transcoding template group, check whether the transcoding template group is locked by using the response parameter Locked, and unlock the transcoding template group before you perform operations such as add, modify, and delete transcoding templates.
//
// @param request - UpdateTranscodeTemplateGroupRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateTranscodeTemplateGroupResponse
func (client *Client) UpdateTranscodeTemplateGroupWithOptions(request *UpdateTranscodeTemplateGroupRequest, runtime *util.RuntimeOptions) (_result *UpdateTranscodeTemplateGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Locked)) {
		query["Locked"] = request.Locked
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.TranscodeTemplateGroupId)) {
		query["TranscodeTemplateGroupId"] = request.TranscodeTemplateGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.TranscodeTemplateList)) {
		query["TranscodeTemplateList"] = request.TranscodeTemplateList
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTranscodeTemplateGroup"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &UpdateTranscodeTemplateGroupResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &UpdateTranscodeTemplateGroupResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Modifies the configurations of a transcoding template group or configurations of transcoding templates in the transcoding template group.
//
// Description:
//
// For security purposes, you cannot add, modify, or delete transcoding templates in a transcoding template group that is locked. You can call the [GetTranscodeTemplateGroup](~~GetTranscodeTemplateGroup~~) operation to query the configurations of a transcoding template group, check whether the transcoding template group is locked by using the response parameter Locked, and unlock the transcoding template group before you perform operations such as add, modify, and delete transcoding templates.
//
// @param request - UpdateTranscodeTemplateGroupRequest
//
// @return UpdateTranscodeTemplateGroupResponse
func (client *Client) UpdateTranscodeTemplateGroup(request *UpdateTranscodeTemplateGroupRequest) (_result *UpdateTranscodeTemplateGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTranscodeTemplateGroupResponse{}
	_body, _err := client.UpdateTranscodeTemplateGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the information about an audio or video file.
//
// Description:
//
// ### [](#)
//
// You can call this operation to modify information such as the title, tags, and description about audio and video files based on audio or video IDs. You must pass in the parameters that you want to modify. Otherwise, parameter configurations are not overwritten.
//
// ### [](#qps-)Queries per second (QPS) limit
//
// You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations](https://help.aliyun.com/document_detail/342790.html).
//
// @param request - UpdateVideoInfoRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateVideoInfoResponse
func (client *Client) UpdateVideoInfoWithOptions(request *UpdateVideoInfoRequest, runtime *util.RuntimeOptions) (_result *UpdateVideoInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CateId)) {
		query["CateId"] = request.CateId
	}

	if !tea.BoolValue(util.IsUnset(request.CoverURL)) {
		query["CoverURL"] = request.CoverURL
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.Title)) {
		query["Title"] = request.Title
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateVideoInfo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &UpdateVideoInfoResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &UpdateVideoInfoResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Modifies the information about an audio or video file.
//
// Description:
//
// ### [](#)
//
// You can call this operation to modify information such as the title, tags, and description about audio and video files based on audio or video IDs. You must pass in the parameters that you want to modify. Otherwise, parameter configurations are not overwritten.
//
// ### [](#qps-)Queries per second (QPS) limit
//
// You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations](https://help.aliyun.com/document_detail/342790.html).
//
// @param request - UpdateVideoInfoRequest
//
// @return UpdateVideoInfoResponse
func (client *Client) UpdateVideoInfo(request *UpdateVideoInfoRequest) (_result *UpdateVideoInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateVideoInfoResponse{}
	_body, _err := client.UpdateVideoInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the information about multiple videos at a time.
//
// Description:
//
// The specific parameter of a video is updated only when a new value is passed in the parameter.
//
// @param request - UpdateVideoInfosRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateVideoInfosResponse
func (client *Client) UpdateVideoInfosWithOptions(request *UpdateVideoInfosRequest, runtime *util.RuntimeOptions) (_result *UpdateVideoInfosResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.UpdateContent)) {
		query["UpdateContent"] = request.UpdateContent
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateVideoInfos"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &UpdateVideoInfosResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &UpdateVideoInfosResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Modifies the information about multiple videos at a time.
//
// Description:
//
// The specific parameter of a video is updated only when a new value is passed in the parameter.
//
// @param request - UpdateVideoInfosRequest
//
// @return UpdateVideoInfosResponse
func (client *Client) UpdateVideoInfos(request *UpdateVideoInfosRequest) (_result *UpdateVideoInfosResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateVideoInfosResponse{}
	_body, _err := client.UpdateVideoInfosWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies a specific accelerated domain name.
//
// Description:
//
// UpdateVodDomain
//
// @param request - UpdateVodDomainRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateVodDomainResponse
func (client *Client) UpdateVodDomainWithOptions(request *UpdateVodDomainRequest, runtime *util.RuntimeOptions) (_result *UpdateVodDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.Sources)) {
		query["Sources"] = request.Sources
	}

	if !tea.BoolValue(util.IsUnset(request.TopLevelDomain)) {
		query["TopLevelDomain"] = request.TopLevelDomain
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateVodDomain"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &UpdateVodDomainResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &UpdateVodDomainResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Modifies a specific accelerated domain name.
//
// Description:
//
// UpdateVodDomain
//
// @param request - UpdateVodDomainRequest
//
// @return UpdateVodDomainResponse
func (client *Client) UpdateVodDomain(request *UpdateVodDomainRequest) (_result *UpdateVodDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateVodDomainResponse{}
	_body, _err := client.UpdateVodDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies a snapshot template.
//
// @param request - UpdateVodTemplateRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateVodTemplateResponse
func (client *Client) UpdateVodTemplateWithOptions(request *UpdateVodTemplateRequest, runtime *util.RuntimeOptions) (_result *UpdateVodTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateConfig)) {
		query["TemplateConfig"] = request.TemplateConfig
	}

	if !tea.BoolValue(util.IsUnset(request.VodTemplateId)) {
		query["VodTemplateId"] = request.VodTemplateId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateVodTemplate"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &UpdateVodTemplateResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &UpdateVodTemplateResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Modifies a snapshot template.
//
// @param request - UpdateVodTemplateRequest
//
// @return UpdateVodTemplateResponse
func (client *Client) UpdateVodTemplate(request *UpdateVodTemplateRequest) (_result *UpdateVodTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateVodTemplateResponse{}
	_body, _err := client.UpdateVodTemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Modifies the name and configurations of a watermark template after you create a watermark template.
//
// Description:
//
//   You can modify the name and configurations of the watermark template after you call the [AddWatermark](~~AddWatermark~~) operation to create a watermark template.
//
// 	- You cannot call this operation to change the image in an image watermark template.
//
// @param request - UpdateWatermarkRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UpdateWatermarkResponse
func (client *Client) UpdateWatermarkWithOptions(request *UpdateWatermarkRequest, runtime *util.RuntimeOptions) (_result *UpdateWatermarkResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.WatermarkConfig)) {
		query["WatermarkConfig"] = request.WatermarkConfig
	}

	if !tea.BoolValue(util.IsUnset(request.WatermarkId)) {
		query["WatermarkId"] = request.WatermarkId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateWatermark"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &UpdateWatermarkResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &UpdateWatermarkResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Modifies the name and configurations of a watermark template after you create a watermark template.
//
// Description:
//
//   You can modify the name and configurations of the watermark template after you call the [AddWatermark](~~AddWatermark~~) operation to create a watermark template.
//
// 	- You cannot call this operation to change the image in an image watermark template.
//
// @param request - UpdateWatermarkRequest
//
// @return UpdateWatermarkResponse
func (client *Client) UpdateWatermark(request *UpdateWatermarkRequest) (_result *UpdateWatermarkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateWatermarkResponse{}
	_body, _err := client.UpdateWatermarkWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Uploads media files based on URLs.
//
// Description:
//
//   You can call this operation to upload media files that are not stored on a local server or device and must be uploaded based on URLs over the Internet.
//
// 	- The URL-based upload jobs are asynchronous. After you submit a URL-based upload job by calling this operation, it may take hours, even days to complete. If you require high timeliness, we recommend that you use the upload SDK.
//
// 	- If you configure callbacks, you can receive an [UploadByURLComplete](https://help.aliyun.com/document_detail/86326.html) event notification after the media file is uploaded. You can query the upload status by calling the [GetURLUploadInfos](https://help.aliyun.com/document_detail/106830.html) operation.
//
// 	- After you submit an upload job, the job is asynchronously processed on the cloud. All URL-based upload jobs that are submitted in each region are queued. The waiting time for the upload job depends on the number of queued jobs. After the upload job is complete, you can associate the playback URL included in the callback with the media ID.
//
// 	- You can call this operation only in the **China (Shanghai)*	- and **Singapore*	- regions.
//
// 	- Every time you submit a URL-based upload job, a new media ID is generated in ApsaraVideo VOD.
//
// @param request - UploadMediaByURLRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UploadMediaByURLResponse
func (client *Client) UploadMediaByURLWithOptions(request *UploadMediaByURLRequest, runtime *util.RuntimeOptions) (_result *UploadMediaByURLResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.SessionId)) {
		query["SessionId"] = request.SessionId
	}

	if !tea.BoolValue(util.IsUnset(request.StorageLocation)) {
		query["StorageLocation"] = request.StorageLocation
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateGroupId)) {
		query["TemplateGroupId"] = request.TemplateGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.UploadMetadatas)) {
		query["UploadMetadatas"] = request.UploadMetadatas
	}

	if !tea.BoolValue(util.IsUnset(request.UploadURLs)) {
		query["UploadURLs"] = request.UploadURLs
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	if !tea.BoolValue(util.IsUnset(request.WorkflowId)) {
		query["WorkflowId"] = request.WorkflowId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UploadMediaByURL"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &UploadMediaByURLResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &UploadMediaByURLResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Uploads media files based on URLs.
//
// Description:
//
//   You can call this operation to upload media files that are not stored on a local server or device and must be uploaded based on URLs over the Internet.
//
// 	- The URL-based upload jobs are asynchronous. After you submit a URL-based upload job by calling this operation, it may take hours, even days to complete. If you require high timeliness, we recommend that you use the upload SDK.
//
// 	- If you configure callbacks, you can receive an [UploadByURLComplete](https://help.aliyun.com/document_detail/86326.html) event notification after the media file is uploaded. You can query the upload status by calling the [GetURLUploadInfos](https://help.aliyun.com/document_detail/106830.html) operation.
//
// 	- After you submit an upload job, the job is asynchronously processed on the cloud. All URL-based upload jobs that are submitted in each region are queued. The waiting time for the upload job depends on the number of queued jobs. After the upload job is complete, you can associate the playback URL included in the callback with the media ID.
//
// 	- You can call this operation only in the **China (Shanghai)*	- and **Singapore*	- regions.
//
// 	- Every time you submit a URL-based upload job, a new media ID is generated in ApsaraVideo VOD.
//
// @param request - UploadMediaByURLRequest
//
// @return UploadMediaByURLResponse
func (client *Client) UploadMediaByURL(request *UploadMediaByURLRequest) (_result *UploadMediaByURLResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UploadMediaByURLResponse{}
	_body, _err := client.UploadMediaByURLWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Uploads transcoded streams to ApsaraVideo VOD from external storage.
//
// Description:
//
//   **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. You are charged storage fees after you upload media files to ApsaraVideo VOD. For more information, see [Billing of media asset storage](~~188308#section_e97_xrp_mzz~~). If you have activated the acceleration service, you are charged acceleration fees when you upload media files to ApsaraVideo VOD. For more information, see [Billing of acceleration traffic](~~188310#section_sta_zm2_tsv~~).**
//
// 	- This operation is available only in the **China (Shanghai)*	- and **Singapore*	- regions.
//
// 	- You can call this operation to upload transcoded streams to ApsaraVideo VOD from external storage. The following HDR types of transcoded streams are supported: HDR, HDR 10, HLG, Dolby Vision, HDR Vivid, and SDR+.
//
// 	- You can call the [GetURLUploadInfos](https://help.aliyun.com/document_detail/106830.html) operation to query the upload status. After the upload is complete, the callback of the [UploadByURLComplete](https://help.aliyun.com/document_detail/376427.html) event is returned.
//
// @param request - UploadStreamByURLRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return UploadStreamByURLResponse
func (client *Client) UploadStreamByURLWithOptions(request *UploadStreamByURLRequest, runtime *util.RuntimeOptions) (_result *UploadStreamByURLResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Definition)) {
		query["Definition"] = request.Definition
	}

	if !tea.BoolValue(util.IsUnset(request.FileExtension)) {
		query["FileExtension"] = request.FileExtension
	}

	if !tea.BoolValue(util.IsUnset(request.HDRType)) {
		query["HDRType"] = request.HDRType
	}

	if !tea.BoolValue(util.IsUnset(request.MediaId)) {
		query["MediaId"] = request.MediaId
	}

	if !tea.BoolValue(util.IsUnset(request.StreamURL)) {
		query["StreamURL"] = request.StreamURL
	}

	if !tea.BoolValue(util.IsUnset(request.UploadMetadata)) {
		query["UploadMetadata"] = request.UploadMetadata
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UploadStreamByURL"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &UploadStreamByURLResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &UploadStreamByURLResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Uploads transcoded streams to ApsaraVideo VOD from external storage.
//
// Description:
//
//   **Make sure that you understand the billing method and price of ApsaraVideo VOD before you call this operation. You are charged storage fees after you upload media files to ApsaraVideo VOD. For more information, see [Billing of media asset storage](~~188308#section_e97_xrp_mzz~~). If you have activated the acceleration service, you are charged acceleration fees when you upload media files to ApsaraVideo VOD. For more information, see [Billing of acceleration traffic](~~188310#section_sta_zm2_tsv~~).**
//
// 	- This operation is available only in the **China (Shanghai)*	- and **Singapore*	- regions.
//
// 	- You can call this operation to upload transcoded streams to ApsaraVideo VOD from external storage. The following HDR types of transcoded streams are supported: HDR, HDR 10, HLG, Dolby Vision, HDR Vivid, and SDR+.
//
// 	- You can call the [GetURLUploadInfos](https://help.aliyun.com/document_detail/106830.html) operation to query the upload status. After the upload is complete, the callback of the [UploadByURLComplete](https://help.aliyun.com/document_detail/376427.html) event is returned.
//
// @param request - UploadStreamByURLRequest
//
// @return UploadStreamByURLResponse
func (client *Client) UploadStreamByURL(request *UploadStreamByURLRequest) (_result *UploadStreamByURLResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UploadStreamByURLResponse{}
	_body, _err := client.UploadStreamByURLWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

// Summary:
//
// Verifies the ownership of a specified domain name.
//
// Description:
//
// This operation is available only in the **China (Shanghai)*	- region.
//
// @param request - VerifyVodDomainOwnerRequest
//
// @param runtime - runtime options for this request RuntimeOptions
//
// @return VerifyVodDomainOwnerResponse
func (client *Client) VerifyVodDomainOwnerWithOptions(request *VerifyVodDomainOwnerRequest, runtime *util.RuntimeOptions) (_result *VerifyVodDomainOwnerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VerifyType)) {
		query["VerifyType"] = request.VerifyType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("VerifyVodDomainOwner"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	if tea.BoolValue(util.IsUnset(client.SignatureVersion)) || !tea.BoolValue(util.EqualString(client.SignatureVersion, tea.String("v4"))) {
		_result = &VerifyVodDomainOwnerResponse{}
		_body, _err := client.CallApi(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	} else {
		_result = &VerifyVodDomainOwnerResponse{}
		_body, _err := client.Execute(params, req, runtime)
		if _err != nil {
			return _result, _err
		}
		_err = tea.Convert(_body, &_result)
		return _result, _err
	}

}

// Summary:
//
// Verifies the ownership of a specified domain name.
//
// Description:
//
// This operation is available only in the **China (Shanghai)*	- region.
//
// @param request - VerifyVodDomainOwnerRequest
//
// @return VerifyVodDomainOwnerResponse
func (client *Client) VerifyVodDomainOwner(request *VerifyVodDomainOwnerRequest) (_result *VerifyVodDomainOwnerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &VerifyVodDomainOwnerResponse{}
	_body, _err := client.VerifyVodDomainOwnerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}
