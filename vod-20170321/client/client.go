// This file is auto-generated, don't edit it. Thanks.
/**
 *
 */
package client

import (
	openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
	endpointutil "github.com/alibabacloud-go/endpoint-util/service"
	openapiutil "github.com/alibabacloud-go/openapi-util/service"
	util "github.com/alibabacloud-go/tea-utils/v2/service"
	"github.com/alibabacloud-go/tea/tea"
)

type AddAITemplateRequest struct {
	// Adds an AI template for automated review and smart thumbnail tasks.
	TemplateConfig *string `json:"TemplateConfig,omitempty" xml:"TemplateConfig,omitempty"`
	// The ID of the request.
	TemplateName *string `json:"TemplateName,omitempty" xml:"TemplateName,omitempty"`
	// The operation that you want to perform. Set the value to **AddAITemplate**.
	TemplateType *string `json:"TemplateType,omitempty" xml:"TemplateType,omitempty"`
}

func (s AddAITemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s AddAITemplateRequest) GoString() string {
	return s.String()
}

func (s *AddAITemplateRequest) SetTemplateConfig(v string) *AddAITemplateRequest {
	s.TemplateConfig = &v
	return s
}

func (s *AddAITemplateRequest) SetTemplateName(v string) *AddAITemplateRequest {
	s.TemplateName = &v
	return s
}

func (s *AddAITemplateRequest) SetTemplateType(v string) *AddAITemplateRequest {
	s.TemplateType = &v
	return s
}

type AddAITemplateResponseBody struct {
	RequestId  *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TemplateId *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
}

func (s AddAITemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddAITemplateResponseBody) GoString() string {
	return s.String()
}

func (s *AddAITemplateResponseBody) SetRequestId(v string) *AddAITemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddAITemplateResponseBody) SetTemplateId(v string) *AddAITemplateResponseBody {
	s.TemplateId = &v
	return s
}

type AddAITemplateResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddAITemplateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddAITemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s AddAITemplateResponse) GoString() string {
	return s.String()
}

func (s *AddAITemplateResponse) SetHeaders(v map[string]*string) *AddAITemplateResponse {
	s.Headers = v
	return s
}

func (s *AddAITemplateResponse) SetStatusCode(v int32) *AddAITemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *AddAITemplateResponse) SetBody(v *AddAITemplateResponseBody) *AddAITemplateResponse {
	s.Body = v
	return s
}

type AddCategoryRequest struct {
	// test
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	// test
	ParentId *int64 `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
	// The type of the category. Valid values:
	//
	// - **default** (default): default category
	// - **material**: material category
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s AddCategoryRequest) String() string {
	return tea.Prettify(s)
}

func (s AddCategoryRequest) GoString() string {
	return s.String()
}

func (s *AddCategoryRequest) SetCateName(v string) *AddCategoryRequest {
	s.CateName = &v
	return s
}

func (s *AddCategoryRequest) SetParentId(v int64) *AddCategoryRequest {
	s.ParentId = &v
	return s
}

func (s *AddCategoryRequest) SetType(v string) *AddCategoryRequest {
	s.Type = &v
	return s
}

type AddCategoryResponseBody struct {
	// The information about the video category.
	Category *AddCategoryResponseBodyCategory `json:"Category,omitempty" xml:"Category,omitempty" type:"Struct"`
	// The operation that you want to perform. Set the value to **AddCategory**.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddCategoryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddCategoryResponseBody) GoString() string {
	return s.String()
}

func (s *AddCategoryResponseBody) SetCategory(v *AddCategoryResponseBodyCategory) *AddCategoryResponseBody {
	s.Category = v
	return s
}

func (s *AddCategoryResponseBody) SetRequestId(v string) *AddCategoryResponseBody {
	s.RequestId = &v
	return s
}

type AddCategoryResponseBodyCategory struct {
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// AddCategory
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	Level    *int64  `json:"Level,omitempty" xml:"Level,omitempty"`
	// Creates a video category.
	ParentId *int64 `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
	// The ID of the video category.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s AddCategoryResponseBodyCategory) String() string {
	return tea.Prettify(s)
}

func (s AddCategoryResponseBodyCategory) GoString() string {
	return s.String()
}

func (s *AddCategoryResponseBodyCategory) SetCateId(v int64) *AddCategoryResponseBodyCategory {
	s.CateId = &v
	return s
}

func (s *AddCategoryResponseBodyCategory) SetCateName(v string) *AddCategoryResponseBodyCategory {
	s.CateName = &v
	return s
}

func (s *AddCategoryResponseBodyCategory) SetLevel(v int64) *AddCategoryResponseBodyCategory {
	s.Level = &v
	return s
}

func (s *AddCategoryResponseBodyCategory) SetParentId(v int64) *AddCategoryResponseBodyCategory {
	s.ParentId = &v
	return s
}

func (s *AddCategoryResponseBodyCategory) SetType(v string) *AddCategoryResponseBodyCategory {
	s.Type = &v
	return s
}

type AddCategoryResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddCategoryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddCategoryResponse) String() string {
	return tea.Prettify(s)
}

func (s AddCategoryResponse) GoString() string {
	return s.String()
}

func (s *AddCategoryResponse) SetHeaders(v map[string]*string) *AddCategoryResponse {
	s.Headers = v
	return s
}

func (s *AddCategoryResponse) SetStatusCode(v int32) *AddCategoryResponse {
	s.StatusCode = &v
	return s
}

func (s *AddCategoryResponse) SetBody(v *AddCategoryResponseBody) *AddCategoryResponse {
	s.Body = v
	return s
}

type AddEditingProjectRequest struct {
	// The title of the online editing project.
	CoverURL *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	// The region where you want to create the online editing project.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The title of the online editing project.
	Division             *string `json:"Division,omitempty" xml:"Division,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the online editing project.
	Timeline *string `json:"Timeline,omitempty" xml:"Timeline,omitempty"`
	// The operation that you want to perform. Set the value to **AddEditingProject**.
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
}

func (s AddEditingProjectRequest) String() string {
	return tea.Prettify(s)
}

func (s AddEditingProjectRequest) GoString() string {
	return s.String()
}

func (s *AddEditingProjectRequest) SetCoverURL(v string) *AddEditingProjectRequest {
	s.CoverURL = &v
	return s
}

func (s *AddEditingProjectRequest) SetDescription(v string) *AddEditingProjectRequest {
	s.Description = &v
	return s
}

func (s *AddEditingProjectRequest) SetDivision(v string) *AddEditingProjectRequest {
	s.Division = &v
	return s
}

func (s *AddEditingProjectRequest) SetOwnerAccount(v string) *AddEditingProjectRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AddEditingProjectRequest) SetOwnerId(v string) *AddEditingProjectRequest {
	s.OwnerId = &v
	return s
}

func (s *AddEditingProjectRequest) SetResourceOwnerAccount(v string) *AddEditingProjectRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AddEditingProjectRequest) SetResourceOwnerId(v string) *AddEditingProjectRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *AddEditingProjectRequest) SetTimeline(v string) *AddEditingProjectRequest {
	s.Timeline = &v
	return s
}

func (s *AddEditingProjectRequest) SetTitle(v string) *AddEditingProjectRequest {
	s.Title = &v
	return s
}

type AddEditingProjectResponseBody struct {
	// The time when the online editing project was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	Project *AddEditingProjectResponseBodyProject `json:"Project,omitempty" xml:"Project,omitempty" type:"Struct"`
	// The thumbnail URL of the online editing project. If you do not specify this parameter and the video track in the timeline has mezzanine files, the thumbnail of the first mezzanine file in the timeline is used.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddEditingProjectResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddEditingProjectResponseBody) GoString() string {
	return s.String()
}

func (s *AddEditingProjectResponseBody) SetProject(v *AddEditingProjectResponseBodyProject) *AddEditingProjectResponseBody {
	s.Project = v
	return s
}

func (s *AddEditingProjectResponseBody) SetRequestId(v string) *AddEditingProjectResponseBody {
	s.RequestId = &v
	return s
}

type AddEditingProjectResponseBodyProject struct {
	// The ID of the request.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// 朴灵
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// 58928
	ModifiedTime *string `json:"ModifiedTime,omitempty" xml:"ModifiedTime,omitempty"`
	ProjectId    *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// Creates an online editing project.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	Title  *string `json:"Title,omitempty" xml:"Title,omitempty"`
}

func (s AddEditingProjectResponseBodyProject) String() string {
	return tea.Prettify(s)
}

func (s AddEditingProjectResponseBodyProject) GoString() string {
	return s.String()
}

func (s *AddEditingProjectResponseBodyProject) SetCreationTime(v string) *AddEditingProjectResponseBodyProject {
	s.CreationTime = &v
	return s
}

func (s *AddEditingProjectResponseBodyProject) SetDescription(v string) *AddEditingProjectResponseBodyProject {
	s.Description = &v
	return s
}

func (s *AddEditingProjectResponseBodyProject) SetModifiedTime(v string) *AddEditingProjectResponseBodyProject {
	s.ModifiedTime = &v
	return s
}

func (s *AddEditingProjectResponseBodyProject) SetProjectId(v string) *AddEditingProjectResponseBodyProject {
	s.ProjectId = &v
	return s
}

func (s *AddEditingProjectResponseBodyProject) SetStatus(v string) *AddEditingProjectResponseBodyProject {
	s.Status = &v
	return s
}

func (s *AddEditingProjectResponseBodyProject) SetTitle(v string) *AddEditingProjectResponseBodyProject {
	s.Title = &v
	return s
}

type AddEditingProjectResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddEditingProjectResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddEditingProjectResponse) String() string {
	return tea.Prettify(s)
}

func (s AddEditingProjectResponse) GoString() string {
	return s.String()
}

func (s *AddEditingProjectResponse) SetHeaders(v map[string]*string) *AddEditingProjectResponse {
	s.Headers = v
	return s
}

func (s *AddEditingProjectResponse) SetStatusCode(v int32) *AddEditingProjectResponse {
	s.StatusCode = &v
	return s
}

func (s *AddEditingProjectResponse) SetBody(v *AddEditingProjectResponseBody) *AddEditingProjectResponse {
	s.Body = v
	return s
}

type AddTranscodeTemplateGroupRequest struct {
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// Creates a transcoding template group or adds one or more transcoding templates to a template group.
	Name                     *string `json:"Name,omitempty" xml:"Name,omitempty"`
	TranscodeTemplateGroupId *string `json:"TranscodeTemplateGroupId,omitempty" xml:"TranscodeTemplateGroupId,omitempty"`
	TranscodeTemplateList    *string `json:"TranscodeTemplateList,omitempty" xml:"TranscodeTemplateList,omitempty"`
}

func (s AddTranscodeTemplateGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s AddTranscodeTemplateGroupRequest) GoString() string {
	return s.String()
}

func (s *AddTranscodeTemplateGroupRequest) SetAppId(v string) *AddTranscodeTemplateGroupRequest {
	s.AppId = &v
	return s
}

func (s *AddTranscodeTemplateGroupRequest) SetName(v string) *AddTranscodeTemplateGroupRequest {
	s.Name = &v
	return s
}

func (s *AddTranscodeTemplateGroupRequest) SetTranscodeTemplateGroupId(v string) *AddTranscodeTemplateGroupRequest {
	s.TranscodeTemplateGroupId = &v
	return s
}

func (s *AddTranscodeTemplateGroupRequest) SetTranscodeTemplateList(v string) *AddTranscodeTemplateGroupRequest {
	s.TranscodeTemplateList = &v
	return s
}

type AddTranscodeTemplateGroupResponseBody struct {
	RequestId                *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TranscodeTemplateGroupId *string `json:"TranscodeTemplateGroupId,omitempty" xml:"TranscodeTemplateGroupId,omitempty"`
}

func (s AddTranscodeTemplateGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddTranscodeTemplateGroupResponseBody) GoString() string {
	return s.String()
}

func (s *AddTranscodeTemplateGroupResponseBody) SetRequestId(v string) *AddTranscodeTemplateGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddTranscodeTemplateGroupResponseBody) SetTranscodeTemplateGroupId(v string) *AddTranscodeTemplateGroupResponseBody {
	s.TranscodeTemplateGroupId = &v
	return s
}

type AddTranscodeTemplateGroupResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddTranscodeTemplateGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddTranscodeTemplateGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s AddTranscodeTemplateGroupResponse) GoString() string {
	return s.String()
}

func (s *AddTranscodeTemplateGroupResponse) SetHeaders(v map[string]*string) *AddTranscodeTemplateGroupResponse {
	s.Headers = v
	return s
}

func (s *AddTranscodeTemplateGroupResponse) SetStatusCode(v int32) *AddTranscodeTemplateGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *AddTranscodeTemplateGroupResponse) SetBody(v *AddTranscodeTemplateGroupResponseBody) *AddTranscodeTemplateGroupResponse {
	s.Body = v
	return s
}

type AddVodDomainRequest struct {
	// ## Common errors
	//
	// The following table describes the error codes that this operation can return.
	//
	// |Error code|Error message|HTTP status code|Description|
	// |---|---|---|---|
	// |InvalidDomainName.Malformed|Specified DomainName is malformed.|400|The error message returned because the value of the DomainName parameter is invalid.|
	// |InvalidCdnType.Malformed|Specified CdnType is malformed.|400|The error message returned because the value of the CdnType parameter is invalid.|
	// |InvalidSourceType.Malformed|Specified SourceType is malformed.|400|The error message returned because the value of the SourceType parameter is invalid.|
	// |InvalidSources.Malformed|Specified Sources is malformed.|400|The error message returned because the origin address does not match the origin type.|
	// |InvalidScope.Malformed|Specified Scope is malformed.|400|The error message returned because the value of the Scope parameter is invalid.|
	// |InvaildParameter|The Certificate you provided is malformed!|400|The error message returned because the total length of the HTTPS certificate and private key exceeds the upper limit.|
	// |BusinessExist|Business exist do not repeated submission|400|The error message returned because the domain name is being added. You cannot add duplicate domain names.|
	// |DomainAlreadyExist|This domain name is exist already|400|The error message returned because the domain name is already added.|
	// |DomainOverLimit|The Number of Domain is over the limit|403|The error message returned because the number of accelerated domain names exceeds the upper limit.|
	// |DomainNotRegistration|The Domain name is not registered|404|The error message returned because the domain name does not have an ICP filing.|
	// |IllegalOperation|Illegal domain operate is not permitted.|403|The error message returned because you are not authorized to perform this operation.|
	// |ServiceBusy|The specified Domain is configuring, please retry later.|403|The error message returned because the domain name is being configured. Try again later.|
	// |InvalidDomain.NotFound|The domain provided does not belong to you.|404|The error message returned because the specified domain name does not exist or does not belong to the current account.|
	// |InnerAddDomainDenied|Your account haven\"t bind aoneId, can not add domain.|400|The error message returned because an internal account is not bound to an Aone ID. You cannot add a domain name by using the internal account.|
	// |ExtensiveAndAllBothExist|Extensive domain and the domain begins with \"all.\" can not exist at the same time.|400|The error message returned because a wildcard domain name and a domain name that starts with all. exist. They cannot exist at the same time.|
	// |CdnTypeNotSupportExtensiveDomain|Extensive domain not supported for this cdn type.|400|The error message returned because wildcard domain names are not supported for the specified business type.|
	// |ExtensiveAndSpecificDomainConflict|Extensive domain and corresponding specific domain are mutually exclusive.|400|The error message returned because the specified domain name is an exact match of an existing wildcard domain name at the same level.|
	// |InvalidParameter|Add live region parameters have error.|400|The error message returned because the system failed to specify the region for live streaming.|
	// |InvalidRegion.Malformed|Specified Region is malformed.|400|The error message returned because the value of the region parameter is invalid.|
	// |InvalidResourceGroupId.Malformed|Specified ResourceGroupId is malformed.|400|The error message returned because the value of the ResourceGroupId parameter is invalid.|
	// |EntityNotExists.ResourceGroup|The resource group does not exist.|400|The error message returned because the specified resource group does not exist.|
	// |InvalidStatus.ResourceGroup|It\"s now allowed to do this operation because of the current status of resource-group.|400|The error message returned because the resource group is in an invalid state.|
	// |InvalidPriorities.Malformed|The length of priorities is not the same with source.|400|The error message returned because the number of priorities does not match the number of origin servers.|
	// |NotInternationRealIdentity|You need to do real name authentication when you use Chinese mainland resources.|400|The error message returned because you have not completed real-name verification that is required to use resources in the Chinese mainland.|
	CheckUrl *string `json:"CheckUrl,omitempty" xml:"CheckUrl,omitempty"`
	// *   This operation is available only in the **China (Shanghai)** region.
	// *   Before you add a domain name to accelerate, you must activate ApsaraVideo VOD and apply for an Internet content provider (ICP) filing for the domain name. For more information about how to activate ApsaraVideo VOD, see [Activate ApsaraVideo VOD](~~51512~~).
	// *   If the content on the origin server is not stored on Alibaba Cloud, the content must be reviewed by Alibaba Cloud. The review will be complete by the end of the next business day after you submit an application.
	// *   You can add only one domain name to accelerate in a request. You can add a maximum of 20 accelerated domain names within an Alibaba Cloud account.
	DomainName   *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The domain name that you want to accelerate. Wildcard domain names that start with periods (.) are supported. Example: .example.com.
	Scope         *string `json:"Scope,omitempty" xml:"Scope,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// ## Sources
	//
	// |Parameter|Type|Required|Description|
	// |---|---|---|---|
	// |type|String|Yes|The type of the origin server. Valid values: <br>**ipaddr**: an IP address. <br>**domain**: a domain name. <br>**oss**: the domain of an Object Storage Service (OSS) bucket.|
	// |content|String|Yes|The address of the origin server. You can specify an IP address or a domain name.|
	// |port|Integer|No|The port number. Valid values: **443** and **80**. <br>Default value: **80**. If you specify **443**, requests are redirected to the origin server over HTTPS. You can also specify a custom port.|
	// |priority|String|No|The priority of the origin server if multiple origin servers are specified. Valid values: **20** and **30**. Default value: **20**. **20** indicates that the origin server is the primary origin server. **30** indicates that the origin server is a secondary origin server.|
	Sources *string `json:"Sources,omitempty" xml:"Sources,omitempty"`
	// The information about the addresses of origin servers. For more information, see the **Sources** table in this topic.
	TopLevelDomain *string `json:"TopLevelDomain,omitempty" xml:"TopLevelDomain,omitempty"`
}

func (s AddVodDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s AddVodDomainRequest) GoString() string {
	return s.String()
}

func (s *AddVodDomainRequest) SetCheckUrl(v string) *AddVodDomainRequest {
	s.CheckUrl = &v
	return s
}

func (s *AddVodDomainRequest) SetDomainName(v string) *AddVodDomainRequest {
	s.DomainName = &v
	return s
}

func (s *AddVodDomainRequest) SetOwnerAccount(v string) *AddVodDomainRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AddVodDomainRequest) SetOwnerId(v int64) *AddVodDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *AddVodDomainRequest) SetScope(v string) *AddVodDomainRequest {
	s.Scope = &v
	return s
}

func (s *AddVodDomainRequest) SetSecurityToken(v string) *AddVodDomainRequest {
	s.SecurityToken = &v
	return s
}

func (s *AddVodDomainRequest) SetSources(v string) *AddVodDomainRequest {
	s.Sources = &v
	return s
}

func (s *AddVodDomainRequest) SetTopLevelDomain(v string) *AddVodDomainRequest {
	s.TopLevelDomain = &v
	return s
}

type AddVodDomainResponseBody struct {
	// The URL that is used for health checks.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddVodDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddVodDomainResponseBody) GoString() string {
	return s.String()
}

func (s *AddVodDomainResponseBody) SetRequestId(v string) *AddVodDomainResponseBody {
	s.RequestId = &v
	return s
}

type AddVodDomainResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddVodDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddVodDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s AddVodDomainResponse) GoString() string {
	return s.String()
}

func (s *AddVodDomainResponse) SetHeaders(v map[string]*string) *AddVodDomainResponse {
	s.Headers = v
	return s
}

func (s *AddVodDomainResponse) SetStatusCode(v int32) *AddVodDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *AddVodDomainResponse) SetBody(v *AddVodDomainResponseBody) *AddVodDomainResponse {
	s.Body = v
	return s
}

type AddVodTemplateRequest struct {
	// Creates a snapshot template.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the application. Default value: **app-1000000**. For more information, see [Overview](~~113600~~).
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The operation that you want to perform. Set the value to **AddVodTemplate**.
	TemplateConfig *string `json:"TemplateConfig,omitempty" xml:"TemplateConfig,omitempty"`
	// The ID of the request.
	TemplateType *string `json:"TemplateType,omitempty" xml:"TemplateType,omitempty"`
}

func (s AddVodTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s AddVodTemplateRequest) GoString() string {
	return s.String()
}

func (s *AddVodTemplateRequest) SetAppId(v string) *AddVodTemplateRequest {
	s.AppId = &v
	return s
}

func (s *AddVodTemplateRequest) SetName(v string) *AddVodTemplateRequest {
	s.Name = &v
	return s
}

func (s *AddVodTemplateRequest) SetTemplateConfig(v string) *AddVodTemplateRequest {
	s.TemplateConfig = &v
	return s
}

func (s *AddVodTemplateRequest) SetTemplateType(v string) *AddVodTemplateRequest {
	s.TemplateType = &v
	return s
}

type AddVodTemplateResponseBody struct {
	RequestId     *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	VodTemplateId *string `json:"VodTemplateId,omitempty" xml:"VodTemplateId,omitempty"`
}

func (s AddVodTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddVodTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *AddVodTemplateResponseBody) SetRequestId(v string) *AddVodTemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddVodTemplateResponseBody) SetVodTemplateId(v string) *AddVodTemplateResponseBody {
	s.VodTemplateId = &v
	return s
}

type AddVodTemplateResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddVodTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddVodTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s AddVodTemplateResponse) GoString() string {
	return s.String()
}

func (s *AddVodTemplateResponse) SetHeaders(v map[string]*string) *AddVodTemplateResponse {
	s.Headers = v
	return s
}

func (s *AddVodTemplateResponse) SetStatusCode(v int32) *AddVodTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *AddVodTemplateResponse) SetBody(v *AddVodTemplateResponseBody) *AddVodTemplateResponse {
	s.Body = v
	return s
}

type AddWatermarkRequest struct {
	// The ID of the request.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The OSS URL or Content Delivery Network (CDN) URL of the watermark file. A text watermark does not have a file URL.
	FileUrl *string `json:"FileUrl,omitempty" xml:"FileUrl,omitempty"`
	// The ID of the application. Default value: **app-1000000**. For more information, see [Overview](~~113600~~).
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the watermark.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The time when the watermark was added. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	WatermarkConfig *string `json:"WatermarkConfig,omitempty" xml:"WatermarkConfig,omitempty"`
}

func (s AddWatermarkRequest) String() string {
	return tea.Prettify(s)
}

func (s AddWatermarkRequest) GoString() string {
	return s.String()
}

func (s *AddWatermarkRequest) SetAppId(v string) *AddWatermarkRequest {
	s.AppId = &v
	return s
}

func (s *AddWatermarkRequest) SetFileUrl(v string) *AddWatermarkRequest {
	s.FileUrl = &v
	return s
}

func (s *AddWatermarkRequest) SetName(v string) *AddWatermarkRequest {
	s.Name = &v
	return s
}

func (s *AddWatermarkRequest) SetType(v string) *AddWatermarkRequest {
	s.Type = &v
	return s
}

func (s *AddWatermarkRequest) SetWatermarkConfig(v string) *AddWatermarkRequest {
	s.WatermarkConfig = &v
	return s
}

type AddWatermarkResponseBody struct {
	// > For more information about how to upload a watermark file, see [CreateUploadAttachedMedia](~~98467~~).
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Adds a watermark.
	WatermarkInfo *AddWatermarkResponseBodyWatermarkInfo `json:"WatermarkInfo,omitempty" xml:"WatermarkInfo,omitempty" type:"Struct"`
}

func (s AddWatermarkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddWatermarkResponseBody) GoString() string {
	return s.String()
}

func (s *AddWatermarkResponseBody) SetRequestId(v string) *AddWatermarkResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddWatermarkResponseBody) SetWatermarkInfo(v *AddWatermarkResponseBodyWatermarkInfo) *AddWatermarkResponseBody {
	s.WatermarkInfo = v
	return s
}

type AddWatermarkResponseBodyWatermarkInfo struct {
	CreationTime    *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	FileUrl         *string `json:"FileUrl,omitempty" xml:"FileUrl,omitempty"`
	IsDefault       *string `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	Name            *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Type            *string `json:"Type,omitempty" xml:"Type,omitempty"`
	WatermarkConfig *string `json:"WatermarkConfig,omitempty" xml:"WatermarkConfig,omitempty"`
	WatermarkId     *string `json:"WatermarkId,omitempty" xml:"WatermarkId,omitempty"`
}

func (s AddWatermarkResponseBodyWatermarkInfo) String() string {
	return tea.Prettify(s)
}

func (s AddWatermarkResponseBodyWatermarkInfo) GoString() string {
	return s.String()
}

func (s *AddWatermarkResponseBodyWatermarkInfo) SetCreationTime(v string) *AddWatermarkResponseBodyWatermarkInfo {
	s.CreationTime = &v
	return s
}

func (s *AddWatermarkResponseBodyWatermarkInfo) SetFileUrl(v string) *AddWatermarkResponseBodyWatermarkInfo {
	s.FileUrl = &v
	return s
}

func (s *AddWatermarkResponseBodyWatermarkInfo) SetIsDefault(v string) *AddWatermarkResponseBodyWatermarkInfo {
	s.IsDefault = &v
	return s
}

func (s *AddWatermarkResponseBodyWatermarkInfo) SetName(v string) *AddWatermarkResponseBodyWatermarkInfo {
	s.Name = &v
	return s
}

func (s *AddWatermarkResponseBodyWatermarkInfo) SetType(v string) *AddWatermarkResponseBodyWatermarkInfo {
	s.Type = &v
	return s
}

func (s *AddWatermarkResponseBodyWatermarkInfo) SetWatermarkConfig(v string) *AddWatermarkResponseBodyWatermarkInfo {
	s.WatermarkConfig = &v
	return s
}

func (s *AddWatermarkResponseBodyWatermarkInfo) SetWatermarkId(v string) *AddWatermarkResponseBodyWatermarkInfo {
	s.WatermarkId = &v
	return s
}

type AddWatermarkResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddWatermarkResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddWatermarkResponse) String() string {
	return tea.Prettify(s)
}

func (s AddWatermarkResponse) GoString() string {
	return s.String()
}

func (s *AddWatermarkResponse) SetHeaders(v map[string]*string) *AddWatermarkResponse {
	s.Headers = v
	return s
}

func (s *AddWatermarkResponse) SetStatusCode(v int32) *AddWatermarkResponse {
	s.StatusCode = &v
	return s
}

func (s *AddWatermarkResponse) SetBody(v *AddWatermarkResponseBody) *AddWatermarkResponse {
	s.Body = v
	return s
}

type AttachAppPolicyToIdentityRequest struct {
	// The ID of the request.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the policy. Only system policies are supported. Separate multiple policies with commas (,). Valid values:
	//
	// *   **VODAppFullAccess**: authorizes an identity to manage all resources in an application.
	// *   **VODAppReadOnlyAccess**: authorizes an identity to access all resources in an application in read-only mode.
	// *   **VODAppAdministratorAccess**: assigns the application administrator role to an identity.
	IdentityName *string `json:"IdentityName,omitempty" xml:"IdentityName,omitempty"`
	// The ID of the application. Default value: **app-1000000**. For more information, see [Overview](~~113600~~).
	//
	// > This parameter is optional when the PolicyNames parameter is set to VODAppAdministratorAccess. This parameter is required when the PolicyNames parameter is set to other values.
	IdentityType *string `json:"IdentityType,omitempty" xml:"IdentityType,omitempty"`
	// The operation that you want to perform. Set the value to **AttachAppPolicyToIdentity**.
	PolicyNames *string `json:"PolicyNames,omitempty" xml:"PolicyNames,omitempty"`
}

func (s AttachAppPolicyToIdentityRequest) String() string {
	return tea.Prettify(s)
}

func (s AttachAppPolicyToIdentityRequest) GoString() string {
	return s.String()
}

func (s *AttachAppPolicyToIdentityRequest) SetAppId(v string) *AttachAppPolicyToIdentityRequest {
	s.AppId = &v
	return s
}

func (s *AttachAppPolicyToIdentityRequest) SetIdentityName(v string) *AttachAppPolicyToIdentityRequest {
	s.IdentityName = &v
	return s
}

func (s *AttachAppPolicyToIdentityRequest) SetIdentityType(v string) *AttachAppPolicyToIdentityRequest {
	s.IdentityType = &v
	return s
}

func (s *AttachAppPolicyToIdentityRequest) SetPolicyNames(v string) *AttachAppPolicyToIdentityRequest {
	s.PolicyNames = &v
	return s
}

type AttachAppPolicyToIdentityResponseBody struct {
	FailedPolicyNames   []*string `json:"FailedPolicyNames,omitempty" xml:"FailedPolicyNames,omitempty" type:"Repeated"`
	NonExistPolicyNames []*string `json:"NonExistPolicyNames,omitempty" xml:"NonExistPolicyNames,omitempty" type:"Repeated"`
	// Authorizes the specified identity to access the applications of ApsaraVideo VOD. The identity may be a RAM user or RAM role.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AttachAppPolicyToIdentityResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AttachAppPolicyToIdentityResponseBody) GoString() string {
	return s.String()
}

func (s *AttachAppPolicyToIdentityResponseBody) SetFailedPolicyNames(v []*string) *AttachAppPolicyToIdentityResponseBody {
	s.FailedPolicyNames = v
	return s
}

func (s *AttachAppPolicyToIdentityResponseBody) SetNonExistPolicyNames(v []*string) *AttachAppPolicyToIdentityResponseBody {
	s.NonExistPolicyNames = v
	return s
}

func (s *AttachAppPolicyToIdentityResponseBody) SetRequestId(v string) *AttachAppPolicyToIdentityResponseBody {
	s.RequestId = &v
	return s
}

type AttachAppPolicyToIdentityResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AttachAppPolicyToIdentityResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AttachAppPolicyToIdentityResponse) String() string {
	return tea.Prettify(s)
}

func (s AttachAppPolicyToIdentityResponse) GoString() string {
	return s.String()
}

func (s *AttachAppPolicyToIdentityResponse) SetHeaders(v map[string]*string) *AttachAppPolicyToIdentityResponse {
	s.Headers = v
	return s
}

func (s *AttachAppPolicyToIdentityResponse) SetStatusCode(v int32) *AttachAppPolicyToIdentityResponse {
	s.StatusCode = &v
	return s
}

func (s *AttachAppPolicyToIdentityResponse) SetBody(v *AttachAppPolicyToIdentityResponseBody) *AttachAppPolicyToIdentityResponse {
	s.Body = v
	return s
}

type BatchSetVodDomainConfigsRequest struct {
	// Configures one or more domain names for CDN.
	DomainNames   *string `json:"DomainNames,omitempty" xml:"DomainNames,omitempty"`
	Functions     *string `json:"Functions,omitempty" xml:"Functions,omitempty"`
	OwnerAccount  *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s BatchSetVodDomainConfigsRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchSetVodDomainConfigsRequest) GoString() string {
	return s.String()
}

func (s *BatchSetVodDomainConfigsRequest) SetDomainNames(v string) *BatchSetVodDomainConfigsRequest {
	s.DomainNames = &v
	return s
}

func (s *BatchSetVodDomainConfigsRequest) SetFunctions(v string) *BatchSetVodDomainConfigsRequest {
	s.Functions = &v
	return s
}

func (s *BatchSetVodDomainConfigsRequest) SetOwnerAccount(v string) *BatchSetVodDomainConfigsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *BatchSetVodDomainConfigsRequest) SetOwnerId(v int64) *BatchSetVodDomainConfigsRequest {
	s.OwnerId = &v
	return s
}

func (s *BatchSetVodDomainConfigsRequest) SetSecurityToken(v string) *BatchSetVodDomainConfigsRequest {
	s.SecurityToken = &v
	return s
}

type BatchSetVodDomainConfigsResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BatchSetVodDomainConfigsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchSetVodDomainConfigsResponseBody) GoString() string {
	return s.String()
}

func (s *BatchSetVodDomainConfigsResponseBody) SetRequestId(v string) *BatchSetVodDomainConfigsResponseBody {
	s.RequestId = &v
	return s
}

type BatchSetVodDomainConfigsResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchSetVodDomainConfigsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchSetVodDomainConfigsResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchSetVodDomainConfigsResponse) GoString() string {
	return s.String()
}

func (s *BatchSetVodDomainConfigsResponse) SetHeaders(v map[string]*string) *BatchSetVodDomainConfigsResponse {
	s.Headers = v
	return s
}

func (s *BatchSetVodDomainConfigsResponse) SetStatusCode(v int32) *BatchSetVodDomainConfigsResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchSetVodDomainConfigsResponse) SetBody(v *BatchSetVodDomainConfigsResponseBody) *BatchSetVodDomainConfigsResponse {
	s.Body = v
	return s
}

type BatchStartVodDomainRequest struct {
	DomainNames   *string `json:"DomainNames,omitempty" xml:"DomainNames,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s BatchStartVodDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchStartVodDomainRequest) GoString() string {
	return s.String()
}

func (s *BatchStartVodDomainRequest) SetDomainNames(v string) *BatchStartVodDomainRequest {
	s.DomainNames = &v
	return s
}

func (s *BatchStartVodDomainRequest) SetOwnerId(v int64) *BatchStartVodDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *BatchStartVodDomainRequest) SetSecurityToken(v string) *BatchStartVodDomainRequest {
	s.SecurityToken = &v
	return s
}

type BatchStartVodDomainResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BatchStartVodDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchStartVodDomainResponseBody) GoString() string {
	return s.String()
}

func (s *BatchStartVodDomainResponseBody) SetRequestId(v string) *BatchStartVodDomainResponseBody {
	s.RequestId = &v
	return s
}

type BatchStartVodDomainResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchStartVodDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchStartVodDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchStartVodDomainResponse) GoString() string {
	return s.String()
}

func (s *BatchStartVodDomainResponse) SetHeaders(v map[string]*string) *BatchStartVodDomainResponse {
	s.Headers = v
	return s
}

func (s *BatchStartVodDomainResponse) SetStatusCode(v int32) *BatchStartVodDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchStartVodDomainResponse) SetBody(v *BatchStartVodDomainResponseBody) *BatchStartVodDomainResponse {
	s.Body = v
	return s
}

type BatchStopVodDomainRequest struct {
	DomainNames   *string `json:"DomainNames,omitempty" xml:"DomainNames,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s BatchStopVodDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchStopVodDomainRequest) GoString() string {
	return s.String()
}

func (s *BatchStopVodDomainRequest) SetDomainNames(v string) *BatchStopVodDomainRequest {
	s.DomainNames = &v
	return s
}

func (s *BatchStopVodDomainRequest) SetOwnerId(v int64) *BatchStopVodDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *BatchStopVodDomainRequest) SetSecurityToken(v string) *BatchStopVodDomainRequest {
	s.SecurityToken = &v
	return s
}

type BatchStopVodDomainResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s BatchStopVodDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchStopVodDomainResponseBody) GoString() string {
	return s.String()
}

func (s *BatchStopVodDomainResponseBody) SetRequestId(v string) *BatchStopVodDomainResponseBody {
	s.RequestId = &v
	return s
}

type BatchStopVodDomainResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchStopVodDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchStopVodDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchStopVodDomainResponse) GoString() string {
	return s.String()
}

func (s *BatchStopVodDomainResponse) SetHeaders(v map[string]*string) *BatchStopVodDomainResponse {
	s.Headers = v
	return s
}

func (s *BatchStopVodDomainResponse) SetStatusCode(v int32) *BatchStopVodDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchStopVodDomainResponse) SetBody(v *BatchStopVodDomainResponseBody) *BatchStopVodDomainResponse {
	s.Body = v
	return s
}

type CancelUrlUploadJobsRequest struct {
	// The ID of the request.
	JobIds *string `json:"JobIds,omitempty" xml:"JobIds,omitempty"`
	// The operation that you want to perform. Set the value to **CancelUrlUploadJobs**.
	UploadUrls *string `json:"UploadUrls,omitempty" xml:"UploadUrls,omitempty"`
}

func (s CancelUrlUploadJobsRequest) String() string {
	return tea.Prettify(s)
}

func (s CancelUrlUploadJobsRequest) GoString() string {
	return s.String()
}

func (s *CancelUrlUploadJobsRequest) SetJobIds(v string) *CancelUrlUploadJobsRequest {
	s.JobIds = &v
	return s
}

func (s *CancelUrlUploadJobsRequest) SetUploadUrls(v string) *CancelUrlUploadJobsRequest {
	s.UploadUrls = &v
	return s
}

type CancelUrlUploadJobsResponseBody struct {
	CanceledJobs []*string `json:"CanceledJobs,omitempty" xml:"CanceledJobs,omitempty" type:"Repeated"`
	NonExists    []*string `json:"NonExists,omitempty" xml:"NonExists,omitempty" type:"Repeated"`
	RequestId    *string   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CancelUrlUploadJobsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CancelUrlUploadJobsResponseBody) GoString() string {
	return s.String()
}

func (s *CancelUrlUploadJobsResponseBody) SetCanceledJobs(v []*string) *CancelUrlUploadJobsResponseBody {
	s.CanceledJobs = v
	return s
}

func (s *CancelUrlUploadJobsResponseBody) SetNonExists(v []*string) *CancelUrlUploadJobsResponseBody {
	s.NonExists = v
	return s
}

func (s *CancelUrlUploadJobsResponseBody) SetRequestId(v string) *CancelUrlUploadJobsResponseBody {
	s.RequestId = &v
	return s
}

type CancelUrlUploadJobsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CancelUrlUploadJobsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CancelUrlUploadJobsResponse) String() string {
	return tea.Prettify(s)
}

func (s CancelUrlUploadJobsResponse) GoString() string {
	return s.String()
}

func (s *CancelUrlUploadJobsResponse) SetHeaders(v map[string]*string) *CancelUrlUploadJobsResponse {
	s.Headers = v
	return s
}

func (s *CancelUrlUploadJobsResponse) SetStatusCode(v int32) *CancelUrlUploadJobsResponse {
	s.StatusCode = &v
	return s
}

func (s *CancelUrlUploadJobsResponse) SetBody(v *CancelUrlUploadJobsResponseBody) *CancelUrlUploadJobsResponse {
	s.Body = v
	return s
}

type CreateAppInfoRequest struct {
	// Creates an application.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// ## Common errors
	//
	// The following table describes the common errors that this operation can return.
	//
	// | Error code | Error message | HTTP status code | Description |
	// | ---------- | ------------- | ---------------- | ----------- |
	// | OperationDenied.NotOpenAppService | The app service is not open. | 403 | The error message returned because the multi-application service has not been activated. |
	// | Forbidden.OperateApp | User not authorized to operate app. | 403 | The error message returned because you are not authorized to manage the application. |
	// | AlreadyExist.AppName | The specified AppName has already exist. | 409 | The error message returned because the name of the application already exists. |
	// | LimitExceeded.AppCount | App Count has exceeded 10. | 400 | The error message returned because the number of applications that can be created exceeds the upper limit. |
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
}

func (s CreateAppInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAppInfoRequest) GoString() string {
	return s.String()
}

func (s *CreateAppInfoRequest) SetAppName(v string) *CreateAppInfoRequest {
	s.AppName = &v
	return s
}

func (s *CreateAppInfoRequest) SetDescription(v string) *CreateAppInfoRequest {
	s.Description = &v
	return s
}

type CreateAppInfoResponseBody struct {
	AppId     *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateAppInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateAppInfoResponseBody) GoString() string {
	return s.String()
}

func (s *CreateAppInfoResponseBody) SetAppId(v string) *CreateAppInfoResponseBody {
	s.AppId = &v
	return s
}

func (s *CreateAppInfoResponseBody) SetRequestId(v string) *CreateAppInfoResponseBody {
	s.RequestId = &v
	return s
}

type CreateAppInfoResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateAppInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateAppInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateAppInfoResponse) GoString() string {
	return s.String()
}

func (s *CreateAppInfoResponse) SetHeaders(v map[string]*string) *CreateAppInfoResponse {
	s.Headers = v
	return s
}

func (s *CreateAppInfoResponse) SetStatusCode(v int32) *CreateAppInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateAppInfoResponse) SetBody(v *CreateAppInfoResponseBody) *CreateAppInfoResponse {
	s.Body = v
	return s
}

type CreateAuditRequest struct {
	AuditContent *string `json:"AuditContent,omitempty" xml:"AuditContent,omitempty"`
}

func (s CreateAuditRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAuditRequest) GoString() string {
	return s.String()
}

func (s *CreateAuditRequest) SetAuditContent(v string) *CreateAuditRequest {
	s.AuditContent = &v
	return s
}

type CreateAuditResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateAuditResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateAuditResponseBody) GoString() string {
	return s.String()
}

func (s *CreateAuditResponseBody) SetRequestId(v string) *CreateAuditResponseBody {
	s.RequestId = &v
	return s
}

type CreateAuditResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateAuditResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateAuditResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateAuditResponse) GoString() string {
	return s.String()
}

func (s *CreateAuditResponse) SetHeaders(v map[string]*string) *CreateAuditResponse {
	s.Headers = v
	return s
}

func (s *CreateAuditResponse) SetStatusCode(v int32) *CreateAuditResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateAuditResponse) SetBody(v *CreateAuditResponseBody) *CreateAuditResponse {
	s.Body = v
	return s
}

type CreateUploadAttachedMediaRequest struct {
	// The ID of the application. Default value: **app-1000000**. For more information, see [Overview](~~113600~~).
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the source file.
	BusinessType *string `json:"BusinessType,omitempty" xml:"BusinessType,omitempty"`
	// The one or more category IDs of the auxiliary media asset. Separate multiple category IDs with commas (,). A maximum of five category IDs can be specified. You can use one of the following methods to obtain the category ID:
	// *   Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Configuration Management** > **Media Management** > **Categories**. On the Categories page, you can view the category ID.
	// *   View the value of the CateId parameter returned by the [AddCategory](~~56401~~) operation that you called to create a category.
	// *   View the value of the CateId parameter returned by the [GetCategories](~~56406~~) operation that you called to query a category.
	CateIds *string `json:"CateIds,omitempty" xml:"CateIds,omitempty"`
	// The description of the auxiliary media asset. Take note of the following items:
	// *   The description can be up to 1,024 bytes in length.
	// *   The value must be encoded in UTF-8.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	FileName    *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	FileSize    *string `json:"FileSize,omitempty" xml:"FileSize,omitempty"`
	// The size of the auxiliary media asset. Unit: byte.
	MediaExt *string `json:"MediaExt,omitempty" xml:"MediaExt,omitempty"`
	// The storage location. You can use one of the following methods to obtain the storage location:
	//
	// Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Configuration Management** > **Media Management** > **Storage**. On the Storage page, you can view the storage location.
	// > If this parameter is set to a specific value, the auxiliary media asset is uploaded to the specified storage location.
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	// The one or more tags of the auxiliary media asset. Take note of the following items:
	// *   You can specify a maximum of 16 tags.
	// *   If you need to specify multiple tags, separate the tags with commas (,).
	// *   Each tag can be up to 32 characters in length.
	// *   The value must be encoded in UTF-8.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The file name extension. Valid values:
	// *   Valid values for watermarks: **png, gif, apng, and mov**
	// *   Valid values for subtitles: **srt, ass, stl, ttml, and vtt**
	// *   Valid values for materials: **jpg, gif, png, mp4, mat, and zip**
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The custom configurations, including callback configurations and upload acceleration configurations. The value is a JSON string. For more information, see the "UserData: specifies the custom configurations for media upload" section of the [Request parameters](~~86952~~) topic.
	// > *   The callback configurations take effect only after you specify the HTTP callback URL and select the specific callback events in the ApsaraVideo VOD console. For more information about how to configure an HTTP callback in the ApsaraVideo VOD console, see [Configure callback settings](~~86071~~).
	// > *   To use the upload acceleration feature, submit a [ticket](https://ticket-intl.console.aliyun.com/#/ticket/createIndex) to enable this feature. For more information, see [Overview](~~55396~~).
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
}

func (s CreateUploadAttachedMediaRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateUploadAttachedMediaRequest) GoString() string {
	return s.String()
}

func (s *CreateUploadAttachedMediaRequest) SetAppId(v string) *CreateUploadAttachedMediaRequest {
	s.AppId = &v
	return s
}

func (s *CreateUploadAttachedMediaRequest) SetBusinessType(v string) *CreateUploadAttachedMediaRequest {
	s.BusinessType = &v
	return s
}

func (s *CreateUploadAttachedMediaRequest) SetCateIds(v string) *CreateUploadAttachedMediaRequest {
	s.CateIds = &v
	return s
}

func (s *CreateUploadAttachedMediaRequest) SetDescription(v string) *CreateUploadAttachedMediaRequest {
	s.Description = &v
	return s
}

func (s *CreateUploadAttachedMediaRequest) SetFileName(v string) *CreateUploadAttachedMediaRequest {
	s.FileName = &v
	return s
}

func (s *CreateUploadAttachedMediaRequest) SetFileSize(v string) *CreateUploadAttachedMediaRequest {
	s.FileSize = &v
	return s
}

func (s *CreateUploadAttachedMediaRequest) SetMediaExt(v string) *CreateUploadAttachedMediaRequest {
	s.MediaExt = &v
	return s
}

func (s *CreateUploadAttachedMediaRequest) SetStorageLocation(v string) *CreateUploadAttachedMediaRequest {
	s.StorageLocation = &v
	return s
}

func (s *CreateUploadAttachedMediaRequest) SetTags(v string) *CreateUploadAttachedMediaRequest {
	s.Tags = &v
	return s
}

func (s *CreateUploadAttachedMediaRequest) SetTitle(v string) *CreateUploadAttachedMediaRequest {
	s.Title = &v
	return s
}

func (s *CreateUploadAttachedMediaRequest) SetUserData(v string) *CreateUploadAttachedMediaRequest {
	s.UserData = &v
	return s
}

type CreateUploadAttachedMediaResponseBody struct {
	// The returned data.
	FileURL *string `json:"FileURL,omitempty" xml:"FileURL,omitempty"`
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The ID of the request.
	MediaURL  *string `json:"MediaURL,omitempty" xml:"MediaURL,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The OSS URL of the file. The URL does not contain the information used for URL signing. You can set the FileUrl parameter to this URL when you call the [AddWatermark](~~98617~~) operation.
	UploadAddress *string `json:"UploadAddress,omitempty" xml:"UploadAddress,omitempty"`
	// The upload URL.
	// > The upload URL returned by this operation is Base64-encoded. Before you can use an SDK or an API operation to upload a media asset based on the upload URL, you must decode the upload URL by using the Base64 algorithm. You must parse the upload URL only if you use native OSS SDKs or OSS API for uploads.
	UploadAuth *string `json:"UploadAuth,omitempty" xml:"UploadAuth,omitempty"`
}

func (s CreateUploadAttachedMediaResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateUploadAttachedMediaResponseBody) GoString() string {
	return s.String()
}

func (s *CreateUploadAttachedMediaResponseBody) SetFileURL(v string) *CreateUploadAttachedMediaResponseBody {
	s.FileURL = &v
	return s
}

func (s *CreateUploadAttachedMediaResponseBody) SetMediaId(v string) *CreateUploadAttachedMediaResponseBody {
	s.MediaId = &v
	return s
}

func (s *CreateUploadAttachedMediaResponseBody) SetMediaURL(v string) *CreateUploadAttachedMediaResponseBody {
	s.MediaURL = &v
	return s
}

func (s *CreateUploadAttachedMediaResponseBody) SetRequestId(v string) *CreateUploadAttachedMediaResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateUploadAttachedMediaResponseBody) SetUploadAddress(v string) *CreateUploadAttachedMediaResponseBody {
	s.UploadAddress = &v
	return s
}

func (s *CreateUploadAttachedMediaResponseBody) SetUploadAuth(v string) *CreateUploadAttachedMediaResponseBody {
	s.UploadAuth = &v
	return s
}

type CreateUploadAttachedMediaResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateUploadAttachedMediaResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateUploadAttachedMediaResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateUploadAttachedMediaResponse) GoString() string {
	return s.String()
}

func (s *CreateUploadAttachedMediaResponse) SetHeaders(v map[string]*string) *CreateUploadAttachedMediaResponse {
	s.Headers = v
	return s
}

func (s *CreateUploadAttachedMediaResponse) SetStatusCode(v int32) *CreateUploadAttachedMediaResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateUploadAttachedMediaResponse) SetBody(v *CreateUploadAttachedMediaResponseBody) *CreateUploadAttachedMediaResponse {
	s.Body = v
	return s
}

type CreateUploadImageRequest struct {
	AppId       *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	CateId      *int64  `json:"CateId,omitempty" xml:"CateId,omitempty"`
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	ImageExt    *string `json:"ImageExt,omitempty" xml:"ImageExt,omitempty"`
	ImageType   *string `json:"ImageType,omitempty" xml:"ImageType,omitempty"`
	// 图片源文件名称。
	//
	// > 必须带扩展名，且扩展名不区分大小写。
	OriginalFileName *string `json:"OriginalFileName,omitempty" xml:"OriginalFileName,omitempty"`
	StorageLocation  *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	Tags             *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	Title            *string `json:"Title,omitempty" xml:"Title,omitempty"`
	UserData         *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
}

func (s CreateUploadImageRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateUploadImageRequest) GoString() string {
	return s.String()
}

func (s *CreateUploadImageRequest) SetAppId(v string) *CreateUploadImageRequest {
	s.AppId = &v
	return s
}

func (s *CreateUploadImageRequest) SetCateId(v int64) *CreateUploadImageRequest {
	s.CateId = &v
	return s
}

func (s *CreateUploadImageRequest) SetDescription(v string) *CreateUploadImageRequest {
	s.Description = &v
	return s
}

func (s *CreateUploadImageRequest) SetImageExt(v string) *CreateUploadImageRequest {
	s.ImageExt = &v
	return s
}

func (s *CreateUploadImageRequest) SetImageType(v string) *CreateUploadImageRequest {
	s.ImageType = &v
	return s
}

func (s *CreateUploadImageRequest) SetOriginalFileName(v string) *CreateUploadImageRequest {
	s.OriginalFileName = &v
	return s
}

func (s *CreateUploadImageRequest) SetStorageLocation(v string) *CreateUploadImageRequest {
	s.StorageLocation = &v
	return s
}

func (s *CreateUploadImageRequest) SetTags(v string) *CreateUploadImageRequest {
	s.Tags = &v
	return s
}

func (s *CreateUploadImageRequest) SetTitle(v string) *CreateUploadImageRequest {
	s.Title = &v
	return s
}

func (s *CreateUploadImageRequest) SetUserData(v string) *CreateUploadImageRequest {
	s.UserData = &v
	return s
}

type CreateUploadImageResponseBody struct {
	FileURL       *string `json:"FileURL,omitempty" xml:"FileURL,omitempty"`
	ImageId       *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	ImageURL      *string `json:"ImageURL,omitempty" xml:"ImageURL,omitempty"`
	RequestId     *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	UploadAddress *string `json:"UploadAddress,omitempty" xml:"UploadAddress,omitempty"`
	UploadAuth    *string `json:"UploadAuth,omitempty" xml:"UploadAuth,omitempty"`
}

func (s CreateUploadImageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateUploadImageResponseBody) GoString() string {
	return s.String()
}

func (s *CreateUploadImageResponseBody) SetFileURL(v string) *CreateUploadImageResponseBody {
	s.FileURL = &v
	return s
}

func (s *CreateUploadImageResponseBody) SetImageId(v string) *CreateUploadImageResponseBody {
	s.ImageId = &v
	return s
}

func (s *CreateUploadImageResponseBody) SetImageURL(v string) *CreateUploadImageResponseBody {
	s.ImageURL = &v
	return s
}

func (s *CreateUploadImageResponseBody) SetRequestId(v string) *CreateUploadImageResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateUploadImageResponseBody) SetUploadAddress(v string) *CreateUploadImageResponseBody {
	s.UploadAddress = &v
	return s
}

func (s *CreateUploadImageResponseBody) SetUploadAuth(v string) *CreateUploadImageResponseBody {
	s.UploadAuth = &v
	return s
}

type CreateUploadImageResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateUploadImageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateUploadImageResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateUploadImageResponse) GoString() string {
	return s.String()
}

func (s *CreateUploadImageResponse) SetHeaders(v map[string]*string) *CreateUploadImageResponse {
	s.Headers = v
	return s
}

func (s *CreateUploadImageResponse) SetStatusCode(v int32) *CreateUploadImageResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateUploadImageResponse) SetBody(v *CreateUploadImageResponseBody) *CreateUploadImageResponse {
	s.Body = v
	return s
}

type CreateUploadVideoRequest struct {
	AppId           *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	CateId          *int64  `json:"CateId,omitempty" xml:"CateId,omitempty"`
	CoverURL        *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	Description     *string `json:"Description,omitempty" xml:"Description,omitempty"`
	FileName        *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	FileSize        *int64  `json:"FileSize,omitempty" xml:"FileSize,omitempty"`
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	Tags            *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	TemplateGroupId *string `json:"TemplateGroupId,omitempty" xml:"TemplateGroupId,omitempty"`
	Title           *string `json:"Title,omitempty" xml:"Title,omitempty"`
	UserData        *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
	WorkflowId      *string `json:"WorkflowId,omitempty" xml:"WorkflowId,omitempty"`
}

func (s CreateUploadVideoRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateUploadVideoRequest) GoString() string {
	return s.String()
}

func (s *CreateUploadVideoRequest) SetAppId(v string) *CreateUploadVideoRequest {
	s.AppId = &v
	return s
}

func (s *CreateUploadVideoRequest) SetCateId(v int64) *CreateUploadVideoRequest {
	s.CateId = &v
	return s
}

func (s *CreateUploadVideoRequest) SetCoverURL(v string) *CreateUploadVideoRequest {
	s.CoverURL = &v
	return s
}

func (s *CreateUploadVideoRequest) SetDescription(v string) *CreateUploadVideoRequest {
	s.Description = &v
	return s
}

func (s *CreateUploadVideoRequest) SetFileName(v string) *CreateUploadVideoRequest {
	s.FileName = &v
	return s
}

func (s *CreateUploadVideoRequest) SetFileSize(v int64) *CreateUploadVideoRequest {
	s.FileSize = &v
	return s
}

func (s *CreateUploadVideoRequest) SetStorageLocation(v string) *CreateUploadVideoRequest {
	s.StorageLocation = &v
	return s
}

func (s *CreateUploadVideoRequest) SetTags(v string) *CreateUploadVideoRequest {
	s.Tags = &v
	return s
}

func (s *CreateUploadVideoRequest) SetTemplateGroupId(v string) *CreateUploadVideoRequest {
	s.TemplateGroupId = &v
	return s
}

func (s *CreateUploadVideoRequest) SetTitle(v string) *CreateUploadVideoRequest {
	s.Title = &v
	return s
}

func (s *CreateUploadVideoRequest) SetUserData(v string) *CreateUploadVideoRequest {
	s.UserData = &v
	return s
}

func (s *CreateUploadVideoRequest) SetWorkflowId(v string) *CreateUploadVideoRequest {
	s.WorkflowId = &v
	return s
}

type CreateUploadVideoResponseBody struct {
	RequestId     *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	UploadAddress *string `json:"UploadAddress,omitempty" xml:"UploadAddress,omitempty"`
	UploadAuth    *string `json:"UploadAuth,omitempty" xml:"UploadAuth,omitempty"`
	VideoId       *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s CreateUploadVideoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateUploadVideoResponseBody) GoString() string {
	return s.String()
}

func (s *CreateUploadVideoResponseBody) SetRequestId(v string) *CreateUploadVideoResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateUploadVideoResponseBody) SetUploadAddress(v string) *CreateUploadVideoResponseBody {
	s.UploadAddress = &v
	return s
}

func (s *CreateUploadVideoResponseBody) SetUploadAuth(v string) *CreateUploadVideoResponseBody {
	s.UploadAuth = &v
	return s
}

func (s *CreateUploadVideoResponseBody) SetVideoId(v string) *CreateUploadVideoResponseBody {
	s.VideoId = &v
	return s
}

type CreateUploadVideoResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateUploadVideoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateUploadVideoResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateUploadVideoResponse) GoString() string {
	return s.String()
}

func (s *CreateUploadVideoResponse) SetHeaders(v map[string]*string) *CreateUploadVideoResponse {
	s.Headers = v
	return s
}

func (s *CreateUploadVideoResponse) SetStatusCode(v int32) *CreateUploadVideoResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateUploadVideoResponse) SetBody(v *CreateUploadVideoResponseBody) *CreateUploadVideoResponse {
	s.Body = v
	return s
}

type DecryptKMSDataKeyRequest struct {
	CipherText           *string `json:"CipherText,omitempty" xml:"CipherText,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DecryptKMSDataKeyRequest) String() string {
	return tea.Prettify(s)
}

func (s DecryptKMSDataKeyRequest) GoString() string {
	return s.String()
}

func (s *DecryptKMSDataKeyRequest) SetCipherText(v string) *DecryptKMSDataKeyRequest {
	s.CipherText = &v
	return s
}

func (s *DecryptKMSDataKeyRequest) SetOwnerAccount(v string) *DecryptKMSDataKeyRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DecryptKMSDataKeyRequest) SetOwnerId(v string) *DecryptKMSDataKeyRequest {
	s.OwnerId = &v
	return s
}

func (s *DecryptKMSDataKeyRequest) SetResourceOwnerAccount(v string) *DecryptKMSDataKeyRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DecryptKMSDataKeyRequest) SetResourceOwnerId(v string) *DecryptKMSDataKeyRequest {
	s.ResourceOwnerId = &v
	return s
}

type DecryptKMSDataKeyResponseBody struct {
	KeyId     *string `json:"KeyId,omitempty" xml:"KeyId,omitempty"`
	Plaintext *string `json:"Plaintext,omitempty" xml:"Plaintext,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DecryptKMSDataKeyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DecryptKMSDataKeyResponseBody) GoString() string {
	return s.String()
}

func (s *DecryptKMSDataKeyResponseBody) SetKeyId(v string) *DecryptKMSDataKeyResponseBody {
	s.KeyId = &v
	return s
}

func (s *DecryptKMSDataKeyResponseBody) SetPlaintext(v string) *DecryptKMSDataKeyResponseBody {
	s.Plaintext = &v
	return s
}

func (s *DecryptKMSDataKeyResponseBody) SetRequestId(v string) *DecryptKMSDataKeyResponseBody {
	s.RequestId = &v
	return s
}

type DecryptKMSDataKeyResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DecryptKMSDataKeyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DecryptKMSDataKeyResponse) String() string {
	return tea.Prettify(s)
}

func (s DecryptKMSDataKeyResponse) GoString() string {
	return s.String()
}

func (s *DecryptKMSDataKeyResponse) SetHeaders(v map[string]*string) *DecryptKMSDataKeyResponse {
	s.Headers = v
	return s
}

func (s *DecryptKMSDataKeyResponse) SetStatusCode(v int32) *DecryptKMSDataKeyResponse {
	s.StatusCode = &v
	return s
}

func (s *DecryptKMSDataKeyResponse) SetBody(v *DecryptKMSDataKeyResponseBody) *DecryptKMSDataKeyResponse {
	s.Body = v
	return s
}

type DeleteAIImageInfosRequest struct {
	// The IDs of the images that are submitted for AI processing. You can obtain the value of AIImageInfoId from the response to the [ListAIImageInfo](~~ListAIImageInfo~~) operation.
	//
	// - You can specify a maximum of 10 IDs.
	// - Separate multiple IDs with commas (,).
	AIImageInfoIds *string `json:"AIImageInfoIds,omitempty" xml:"AIImageInfoIds,omitempty"`
}

func (s DeleteAIImageInfosRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAIImageInfosRequest) GoString() string {
	return s.String()
}

func (s *DeleteAIImageInfosRequest) SetAIImageInfoIds(v string) *DeleteAIImageInfosRequest {
	s.AIImageInfoIds = &v
	return s
}

type DeleteAIImageInfosResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteAIImageInfosResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAIImageInfosResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAIImageInfosResponseBody) SetRequestId(v string) *DeleteAIImageInfosResponseBody {
	s.RequestId = &v
	return s
}

type DeleteAIImageInfosResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteAIImageInfosResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteAIImageInfosResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAIImageInfosResponse) GoString() string {
	return s.String()
}

func (s *DeleteAIImageInfosResponse) SetHeaders(v map[string]*string) *DeleteAIImageInfosResponse {
	s.Headers = v
	return s
}

func (s *DeleteAIImageInfosResponse) SetStatusCode(v int32) *DeleteAIImageInfosResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAIImageInfosResponse) SetBody(v *DeleteAIImageInfosResponseBody) *DeleteAIImageInfosResponse {
	s.Body = v
	return s
}

type DeleteAITemplateRequest struct {
	// The operation that you want to perform. Set the value to **DeleteAITemplate**.
	TemplateId *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
}

func (s DeleteAITemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAITemplateRequest) GoString() string {
	return s.String()
}

func (s *DeleteAITemplateRequest) SetTemplateId(v string) *DeleteAITemplateRequest {
	s.TemplateId = &v
	return s
}

type DeleteAITemplateResponseBody struct {
	RequestId  *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TemplateId *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
}

func (s DeleteAITemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAITemplateResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAITemplateResponseBody) SetRequestId(v string) *DeleteAITemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteAITemplateResponseBody) SetTemplateId(v string) *DeleteAITemplateResponseBody {
	s.TemplateId = &v
	return s
}

type DeleteAITemplateResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteAITemplateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteAITemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAITemplateResponse) GoString() string {
	return s.String()
}

func (s *DeleteAITemplateResponse) SetHeaders(v map[string]*string) *DeleteAITemplateResponse {
	s.Headers = v
	return s
}

func (s *DeleteAITemplateResponse) SetStatusCode(v int32) *DeleteAITemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAITemplateResponse) SetBody(v *DeleteAITemplateResponseBody) *DeleteAITemplateResponse {
	s.Body = v
	return s
}

type DeleteAppInfoRequest struct {
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
}

func (s DeleteAppInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAppInfoRequest) GoString() string {
	return s.String()
}

func (s *DeleteAppInfoRequest) SetAppId(v string) *DeleteAppInfoRequest {
	s.AppId = &v
	return s
}

type DeleteAppInfoResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteAppInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAppInfoResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAppInfoResponseBody) SetRequestId(v string) *DeleteAppInfoResponseBody {
	s.RequestId = &v
	return s
}

type DeleteAppInfoResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteAppInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteAppInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAppInfoResponse) GoString() string {
	return s.String()
}

func (s *DeleteAppInfoResponse) SetHeaders(v map[string]*string) *DeleteAppInfoResponse {
	s.Headers = v
	return s
}

func (s *DeleteAppInfoResponse) SetStatusCode(v int32) *DeleteAppInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAppInfoResponse) SetBody(v *DeleteAppInfoResponseBody) *DeleteAppInfoResponse {
	s.Body = v
	return s
}

type DeleteAttachedMediaRequest struct {
	// Deletes one or more auxiliary media assets at a time.
	MediaIds *string `json:"MediaIds,omitempty" xml:"MediaIds,omitempty"`
}

func (s DeleteAttachedMediaRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAttachedMediaRequest) GoString() string {
	return s.String()
}

func (s *DeleteAttachedMediaRequest) SetMediaIds(v string) *DeleteAttachedMediaRequest {
	s.MediaIds = &v
	return s
}

type DeleteAttachedMediaResponseBody struct {
	NonExistMediaIds []*string `json:"NonExistMediaIds,omitempty" xml:"NonExistMediaIds,omitempty" type:"Repeated"`
	RequestId        *string   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteAttachedMediaResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAttachedMediaResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAttachedMediaResponseBody) SetNonExistMediaIds(v []*string) *DeleteAttachedMediaResponseBody {
	s.NonExistMediaIds = v
	return s
}

func (s *DeleteAttachedMediaResponseBody) SetRequestId(v string) *DeleteAttachedMediaResponseBody {
	s.RequestId = &v
	return s
}

type DeleteAttachedMediaResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteAttachedMediaResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteAttachedMediaResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAttachedMediaResponse) GoString() string {
	return s.String()
}

func (s *DeleteAttachedMediaResponse) SetHeaders(v map[string]*string) *DeleteAttachedMediaResponse {
	s.Headers = v
	return s
}

func (s *DeleteAttachedMediaResponse) SetStatusCode(v int32) *DeleteAttachedMediaResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAttachedMediaResponse) SetBody(v *DeleteAttachedMediaResponseBody) *DeleteAttachedMediaResponse {
	s.Body = v
	return s
}

type DeleteCategoryRequest struct {
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
}

func (s DeleteCategoryRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteCategoryRequest) GoString() string {
	return s.String()
}

func (s *DeleteCategoryRequest) SetCateId(v int64) *DeleteCategoryRequest {
	s.CateId = &v
	return s
}

type DeleteCategoryResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteCategoryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteCategoryResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteCategoryResponseBody) SetRequestId(v string) *DeleteCategoryResponseBody {
	s.RequestId = &v
	return s
}

type DeleteCategoryResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteCategoryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteCategoryResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteCategoryResponse) GoString() string {
	return s.String()
}

func (s *DeleteCategoryResponse) SetHeaders(v map[string]*string) *DeleteCategoryResponse {
	s.Headers = v
	return s
}

func (s *DeleteCategoryResponse) SetStatusCode(v int32) *DeleteCategoryResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteCategoryResponse) SetBody(v *DeleteCategoryResponseBody) *DeleteCategoryResponse {
	s.Body = v
	return s
}

type DeleteDynamicImageRequest struct {
	DynamicImageIds *string `json:"DynamicImageIds,omitempty" xml:"DynamicImageIds,omitempty"`
	VideoId         *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s DeleteDynamicImageRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDynamicImageRequest) GoString() string {
	return s.String()
}

func (s *DeleteDynamicImageRequest) SetDynamicImageIds(v string) *DeleteDynamicImageRequest {
	s.DynamicImageIds = &v
	return s
}

func (s *DeleteDynamicImageRequest) SetVideoId(v string) *DeleteDynamicImageRequest {
	s.VideoId = &v
	return s
}

type DeleteDynamicImageResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDynamicImageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDynamicImageResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDynamicImageResponseBody) SetRequestId(v string) *DeleteDynamicImageResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDynamicImageResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDynamicImageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDynamicImageResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDynamicImageResponse) GoString() string {
	return s.String()
}

func (s *DeleteDynamicImageResponse) SetHeaders(v map[string]*string) *DeleteDynamicImageResponse {
	s.Headers = v
	return s
}

func (s *DeleteDynamicImageResponse) SetStatusCode(v int32) *DeleteDynamicImageResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDynamicImageResponse) SetBody(v *DeleteDynamicImageResponseBody) *DeleteDynamicImageResponse {
	s.Body = v
	return s
}

type DeleteEditingProjectRequest struct {
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ProjectIds           *string `json:"ProjectIds,omitempty" xml:"ProjectIds,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteEditingProjectRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteEditingProjectRequest) GoString() string {
	return s.String()
}

func (s *DeleteEditingProjectRequest) SetOwnerAccount(v string) *DeleteEditingProjectRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteEditingProjectRequest) SetOwnerId(v string) *DeleteEditingProjectRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteEditingProjectRequest) SetProjectIds(v string) *DeleteEditingProjectRequest {
	s.ProjectIds = &v
	return s
}

func (s *DeleteEditingProjectRequest) SetResourceOwnerAccount(v string) *DeleteEditingProjectRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteEditingProjectRequest) SetResourceOwnerId(v string) *DeleteEditingProjectRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteEditingProjectResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteEditingProjectResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteEditingProjectResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteEditingProjectResponseBody) SetRequestId(v string) *DeleteEditingProjectResponseBody {
	s.RequestId = &v
	return s
}

type DeleteEditingProjectResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteEditingProjectResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteEditingProjectResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteEditingProjectResponse) GoString() string {
	return s.String()
}

func (s *DeleteEditingProjectResponse) SetHeaders(v map[string]*string) *DeleteEditingProjectResponse {
	s.Headers = v
	return s
}

func (s *DeleteEditingProjectResponse) SetStatusCode(v int32) *DeleteEditingProjectResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteEditingProjectResponse) SetBody(v *DeleteEditingProjectResponseBody) *DeleteEditingProjectResponse {
	s.Body = v
	return s
}

type DeleteImageRequest struct {
	// The ID of the request.
	DeleteImageType *string `json:"DeleteImageType,omitempty" xml:"DeleteImageType,omitempty"`
	// The type of the image. This parameter only takes effect when the **DeleteImageType** parameter is set to **VideoId**. In this case, you must set this parameter. Valid values:
	//
	// *   **CoverSnapshot**: thumbnail snapshot.
	// *   **NormalSnapshot**: normal snapshot.
	// *   **SpriteSnapshot**: sprite snapshot.
	// *   **SpriteOriginSnapshot**: sprite source snapshot.
	// *   **All**: images of all the preceding types. If this parameter is not set to All, you can specify multiple types and separate them with commas (,).
	ImageIds  *string `json:"ImageIds,omitempty" xml:"ImageIds,omitempty"`
	ImageType *string `json:"ImageType,omitempty" xml:"ImageType,omitempty"`
	// The operation that you want to perform. Set the value to **DeleteImage**.
	ImageURLs *string `json:"ImageURLs,omitempty" xml:"ImageURLs,omitempty"`
	// Deletes uploaded images and automatic snapshots of videos.
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s DeleteImageRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteImageRequest) GoString() string {
	return s.String()
}

func (s *DeleteImageRequest) SetDeleteImageType(v string) *DeleteImageRequest {
	s.DeleteImageType = &v
	return s
}

func (s *DeleteImageRequest) SetImageIds(v string) *DeleteImageRequest {
	s.ImageIds = &v
	return s
}

func (s *DeleteImageRequest) SetImageType(v string) *DeleteImageRequest {
	s.ImageType = &v
	return s
}

func (s *DeleteImageRequest) SetImageURLs(v string) *DeleteImageRequest {
	s.ImageURLs = &v
	return s
}

func (s *DeleteImageRequest) SetVideoId(v string) *DeleteImageRequest {
	s.VideoId = &v
	return s
}

type DeleteImageResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteImageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteImageResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteImageResponseBody) SetRequestId(v string) *DeleteImageResponseBody {
	s.RequestId = &v
	return s
}

type DeleteImageResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteImageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteImageResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteImageResponse) GoString() string {
	return s.String()
}

func (s *DeleteImageResponse) SetHeaders(v map[string]*string) *DeleteImageResponse {
	s.Headers = v
	return s
}

func (s *DeleteImageResponse) SetStatusCode(v int32) *DeleteImageResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteImageResponse) SetBody(v *DeleteImageResponseBody) *DeleteImageResponse {
	s.Body = v
	return s
}

type DeleteMessageCallbackRequest struct {
	AppId        *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
}

func (s DeleteMessageCallbackRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteMessageCallbackRequest) GoString() string {
	return s.String()
}

func (s *DeleteMessageCallbackRequest) SetAppId(v string) *DeleteMessageCallbackRequest {
	s.AppId = &v
	return s
}

func (s *DeleteMessageCallbackRequest) SetOwnerAccount(v string) *DeleteMessageCallbackRequest {
	s.OwnerAccount = &v
	return s
}

type DeleteMessageCallbackResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteMessageCallbackResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteMessageCallbackResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteMessageCallbackResponseBody) SetRequestId(v string) *DeleteMessageCallbackResponseBody {
	s.RequestId = &v
	return s
}

type DeleteMessageCallbackResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteMessageCallbackResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteMessageCallbackResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteMessageCallbackResponse) GoString() string {
	return s.String()
}

func (s *DeleteMessageCallbackResponse) SetHeaders(v map[string]*string) *DeleteMessageCallbackResponse {
	s.Headers = v
	return s
}

func (s *DeleteMessageCallbackResponse) SetStatusCode(v int32) *DeleteMessageCallbackResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteMessageCallbackResponse) SetBody(v *DeleteMessageCallbackResponseBody) *DeleteMessageCallbackResponse {
	s.Body = v
	return s
}

type DeleteMezzaninesRequest struct {
	// Deletes one or more mezzanine files at a time.
	Force *bool `json:"Force,omitempty" xml:"Force,omitempty"`
	// The operation that you want to perform. Set the value to **DeleteMezzanines**.
	VideoIds *string `json:"VideoIds,omitempty" xml:"VideoIds,omitempty"`
}

func (s DeleteMezzaninesRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteMezzaninesRequest) GoString() string {
	return s.String()
}

func (s *DeleteMezzaninesRequest) SetForce(v bool) *DeleteMezzaninesRequest {
	s.Force = &v
	return s
}

func (s *DeleteMezzaninesRequest) SetVideoIds(v string) *DeleteMezzaninesRequest {
	s.VideoIds = &v
	return s
}

type DeleteMezzaninesResponseBody struct {
	NonExistVideoIds     []*string `json:"NonExistVideoIds,omitempty" xml:"NonExistVideoIds,omitempty" type:"Repeated"`
	RequestId            *string   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	UnRemoveableVideoIds []*string `json:"UnRemoveableVideoIds,omitempty" xml:"UnRemoveableVideoIds,omitempty" type:"Repeated"`
}

func (s DeleteMezzaninesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteMezzaninesResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteMezzaninesResponseBody) SetNonExistVideoIds(v []*string) *DeleteMezzaninesResponseBody {
	s.NonExistVideoIds = v
	return s
}

func (s *DeleteMezzaninesResponseBody) SetRequestId(v string) *DeleteMezzaninesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteMezzaninesResponseBody) SetUnRemoveableVideoIds(v []*string) *DeleteMezzaninesResponseBody {
	s.UnRemoveableVideoIds = v
	return s
}

type DeleteMezzaninesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteMezzaninesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteMezzaninesResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteMezzaninesResponse) GoString() string {
	return s.String()
}

func (s *DeleteMezzaninesResponse) SetHeaders(v map[string]*string) *DeleteMezzaninesResponse {
	s.Headers = v
	return s
}

func (s *DeleteMezzaninesResponse) SetStatusCode(v int32) *DeleteMezzaninesResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteMezzaninesResponse) SetBody(v *DeleteMezzaninesResponseBody) *DeleteMezzaninesResponse {
	s.Body = v
	return s
}

type DeleteMultipartUploadRequest struct {
	// Deletes the fragments generated during an upload.
	MediaId      *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	MediaType    *string `json:"MediaType,omitempty" xml:"MediaType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
}

func (s DeleteMultipartUploadRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteMultipartUploadRequest) GoString() string {
	return s.String()
}

func (s *DeleteMultipartUploadRequest) SetMediaId(v string) *DeleteMultipartUploadRequest {
	s.MediaId = &v
	return s
}

func (s *DeleteMultipartUploadRequest) SetMediaType(v string) *DeleteMultipartUploadRequest {
	s.MediaType = &v
	return s
}

func (s *DeleteMultipartUploadRequest) SetOwnerAccount(v string) *DeleteMultipartUploadRequest {
	s.OwnerAccount = &v
	return s
}

type DeleteMultipartUploadResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteMultipartUploadResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteMultipartUploadResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteMultipartUploadResponseBody) SetRequestId(v string) *DeleteMultipartUploadResponseBody {
	s.RequestId = &v
	return s
}

type DeleteMultipartUploadResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteMultipartUploadResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteMultipartUploadResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteMultipartUploadResponse) GoString() string {
	return s.String()
}

func (s *DeleteMultipartUploadResponse) SetHeaders(v map[string]*string) *DeleteMultipartUploadResponse {
	s.Headers = v
	return s
}

func (s *DeleteMultipartUploadResponse) SetStatusCode(v int32) *DeleteMultipartUploadResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteMultipartUploadResponse) SetBody(v *DeleteMultipartUploadResponseBody) *DeleteMultipartUploadResponse {
	s.Body = v
	return s
}

type DeleteStreamRequest struct {
	// Deletes one or more video or audio streams and their storage files at a time.
	JobIds  *string `json:"JobIds,omitempty" xml:"JobIds,omitempty"`
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s DeleteStreamRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteStreamRequest) GoString() string {
	return s.String()
}

func (s *DeleteStreamRequest) SetJobIds(v string) *DeleteStreamRequest {
	s.JobIds = &v
	return s
}

func (s *DeleteStreamRequest) SetVideoId(v string) *DeleteStreamRequest {
	s.VideoId = &v
	return s
}

type DeleteStreamResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteStreamResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteStreamResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteStreamResponseBody) SetRequestId(v string) *DeleteStreamResponseBody {
	s.RequestId = &v
	return s
}

type DeleteStreamResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteStreamResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteStreamResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteStreamResponse) GoString() string {
	return s.String()
}

func (s *DeleteStreamResponse) SetHeaders(v map[string]*string) *DeleteStreamResponse {
	s.Headers = v
	return s
}

func (s *DeleteStreamResponse) SetStatusCode(v int32) *DeleteStreamResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteStreamResponse) SetBody(v *DeleteStreamResponseBody) *DeleteStreamResponse {
	s.Body = v
	return s
}

type DeleteTranscodeTemplateGroupRequest struct {
	ForceDelGroup *string `json:"ForceDelGroup,omitempty" xml:"ForceDelGroup,omitempty"`
	// Removes one or more transcoding templates from a transcoding template group or forcibly deletes the entire transcoding template group.
	TranscodeTemplateGroupId *string `json:"TranscodeTemplateGroupId,omitempty" xml:"TranscodeTemplateGroupId,omitempty"`
	TranscodeTemplateIds     *string `json:"TranscodeTemplateIds,omitempty" xml:"TranscodeTemplateIds,omitempty"`
}

func (s DeleteTranscodeTemplateGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteTranscodeTemplateGroupRequest) GoString() string {
	return s.String()
}

func (s *DeleteTranscodeTemplateGroupRequest) SetForceDelGroup(v string) *DeleteTranscodeTemplateGroupRequest {
	s.ForceDelGroup = &v
	return s
}

func (s *DeleteTranscodeTemplateGroupRequest) SetTranscodeTemplateGroupId(v string) *DeleteTranscodeTemplateGroupRequest {
	s.TranscodeTemplateGroupId = &v
	return s
}

func (s *DeleteTranscodeTemplateGroupRequest) SetTranscodeTemplateIds(v string) *DeleteTranscodeTemplateGroupRequest {
	s.TranscodeTemplateIds = &v
	return s
}

type DeleteTranscodeTemplateGroupResponseBody struct {
	NonExistTranscodeTemplateIds []*string `json:"NonExistTranscodeTemplateIds,omitempty" xml:"NonExistTranscodeTemplateIds,omitempty" type:"Repeated"`
	RequestId                    *string   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteTranscodeTemplateGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteTranscodeTemplateGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteTranscodeTemplateGroupResponseBody) SetNonExistTranscodeTemplateIds(v []*string) *DeleteTranscodeTemplateGroupResponseBody {
	s.NonExistTranscodeTemplateIds = v
	return s
}

func (s *DeleteTranscodeTemplateGroupResponseBody) SetRequestId(v string) *DeleteTranscodeTemplateGroupResponseBody {
	s.RequestId = &v
	return s
}

type DeleteTranscodeTemplateGroupResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteTranscodeTemplateGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteTranscodeTemplateGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteTranscodeTemplateGroupResponse) GoString() string {
	return s.String()
}

func (s *DeleteTranscodeTemplateGroupResponse) SetHeaders(v map[string]*string) *DeleteTranscodeTemplateGroupResponse {
	s.Headers = v
	return s
}

func (s *DeleteTranscodeTemplateGroupResponse) SetStatusCode(v int32) *DeleteTranscodeTemplateGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteTranscodeTemplateGroupResponse) SetBody(v *DeleteTranscodeTemplateGroupResponseBody) *DeleteTranscodeTemplateGroupResponse {
	s.Body = v
	return s
}

type DeleteVideoRequest struct {
	// The operation that you want to perform. Set the value to **DeleteVideo**.
	VideoIds *string `json:"VideoIds,omitempty" xml:"VideoIds,omitempty"`
}

func (s DeleteVideoRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteVideoRequest) GoString() string {
	return s.String()
}

func (s *DeleteVideoRequest) SetVideoIds(v string) *DeleteVideoRequest {
	s.VideoIds = &v
	return s
}

type DeleteVideoResponseBody struct {
	ForbiddenVideoIds []*string `json:"ForbiddenVideoIds,omitempty" xml:"ForbiddenVideoIds,omitempty" type:"Repeated"`
	NonExistVideoIds  []*string `json:"NonExistVideoIds,omitempty" xml:"NonExistVideoIds,omitempty" type:"Repeated"`
	RequestId         *string   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteVideoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteVideoResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteVideoResponseBody) SetForbiddenVideoIds(v []*string) *DeleteVideoResponseBody {
	s.ForbiddenVideoIds = v
	return s
}

func (s *DeleteVideoResponseBody) SetNonExistVideoIds(v []*string) *DeleteVideoResponseBody {
	s.NonExistVideoIds = v
	return s
}

func (s *DeleteVideoResponseBody) SetRequestId(v string) *DeleteVideoResponseBody {
	s.RequestId = &v
	return s
}

type DeleteVideoResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteVideoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteVideoResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteVideoResponse) GoString() string {
	return s.String()
}

func (s *DeleteVideoResponse) SetHeaders(v map[string]*string) *DeleteVideoResponse {
	s.Headers = v
	return s
}

func (s *DeleteVideoResponse) SetStatusCode(v int32) *DeleteVideoResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteVideoResponse) SetBody(v *DeleteVideoResponseBody) *DeleteVideoResponse {
	s.Body = v
	return s
}

type DeleteVodDomainRequest struct {
	DomainName    *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerAccount  *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DeleteVodDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteVodDomainRequest) GoString() string {
	return s.String()
}

func (s *DeleteVodDomainRequest) SetDomainName(v string) *DeleteVodDomainRequest {
	s.DomainName = &v
	return s
}

func (s *DeleteVodDomainRequest) SetOwnerAccount(v string) *DeleteVodDomainRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteVodDomainRequest) SetOwnerId(v int64) *DeleteVodDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteVodDomainRequest) SetSecurityToken(v string) *DeleteVodDomainRequest {
	s.SecurityToken = &v
	return s
}

type DeleteVodDomainResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteVodDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteVodDomainResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteVodDomainResponseBody) SetRequestId(v string) *DeleteVodDomainResponseBody {
	s.RequestId = &v
	return s
}

type DeleteVodDomainResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteVodDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteVodDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteVodDomainResponse) GoString() string {
	return s.String()
}

func (s *DeleteVodDomainResponse) SetHeaders(v map[string]*string) *DeleteVodDomainResponse {
	s.Headers = v
	return s
}

func (s *DeleteVodDomainResponse) SetStatusCode(v int32) *DeleteVodDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteVodDomainResponse) SetBody(v *DeleteVodDomainResponseBody) *DeleteVodDomainResponse {
	s.Body = v
	return s
}

type DeleteVodSpecificConfigRequest struct {
	ConfigId *string `json:"ConfigId,omitempty" xml:"ConfigId,omitempty"`
	// Deletes the configurations of a domain name for CDN.
	DomainName    *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DeleteVodSpecificConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteVodSpecificConfigRequest) GoString() string {
	return s.String()
}

func (s *DeleteVodSpecificConfigRequest) SetConfigId(v string) *DeleteVodSpecificConfigRequest {
	s.ConfigId = &v
	return s
}

func (s *DeleteVodSpecificConfigRequest) SetDomainName(v string) *DeleteVodSpecificConfigRequest {
	s.DomainName = &v
	return s
}

func (s *DeleteVodSpecificConfigRequest) SetOwnerId(v int64) *DeleteVodSpecificConfigRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteVodSpecificConfigRequest) SetSecurityToken(v string) *DeleteVodSpecificConfigRequest {
	s.SecurityToken = &v
	return s
}

type DeleteVodSpecificConfigResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteVodSpecificConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteVodSpecificConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteVodSpecificConfigResponseBody) SetRequestId(v string) *DeleteVodSpecificConfigResponseBody {
	s.RequestId = &v
	return s
}

type DeleteVodSpecificConfigResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteVodSpecificConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteVodSpecificConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteVodSpecificConfigResponse) GoString() string {
	return s.String()
}

func (s *DeleteVodSpecificConfigResponse) SetHeaders(v map[string]*string) *DeleteVodSpecificConfigResponse {
	s.Headers = v
	return s
}

func (s *DeleteVodSpecificConfigResponse) SetStatusCode(v int32) *DeleteVodSpecificConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteVodSpecificConfigResponse) SetBody(v *DeleteVodSpecificConfigResponseBody) *DeleteVodSpecificConfigResponse {
	s.Body = v
	return s
}

type DeleteVodTemplateRequest struct {
	// Deletes a snapshot template.
	VodTemplateId *string `json:"VodTemplateId,omitempty" xml:"VodTemplateId,omitempty"`
}

func (s DeleteVodTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteVodTemplateRequest) GoString() string {
	return s.String()
}

func (s *DeleteVodTemplateRequest) SetVodTemplateId(v string) *DeleteVodTemplateRequest {
	s.VodTemplateId = &v
	return s
}

type DeleteVodTemplateResponseBody struct {
	RequestId     *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	VodTemplateId *string `json:"VodTemplateId,omitempty" xml:"VodTemplateId,omitempty"`
}

func (s DeleteVodTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteVodTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteVodTemplateResponseBody) SetRequestId(v string) *DeleteVodTemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteVodTemplateResponseBody) SetVodTemplateId(v string) *DeleteVodTemplateResponseBody {
	s.VodTemplateId = &v
	return s
}

type DeleteVodTemplateResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteVodTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteVodTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteVodTemplateResponse) GoString() string {
	return s.String()
}

func (s *DeleteVodTemplateResponse) SetHeaders(v map[string]*string) *DeleteVodTemplateResponse {
	s.Headers = v
	return s
}

func (s *DeleteVodTemplateResponse) SetStatusCode(v int32) *DeleteVodTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteVodTemplateResponse) SetBody(v *DeleteVodTemplateResponseBody) *DeleteVodTemplateResponse {
	s.Body = v
	return s
}

type DeleteWatermarkRequest struct {
	WatermarkId *string `json:"WatermarkId,omitempty" xml:"WatermarkId,omitempty"`
}

func (s DeleteWatermarkRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteWatermarkRequest) GoString() string {
	return s.String()
}

func (s *DeleteWatermarkRequest) SetWatermarkId(v string) *DeleteWatermarkRequest {
	s.WatermarkId = &v
	return s
}

type DeleteWatermarkResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteWatermarkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteWatermarkResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteWatermarkResponseBody) SetRequestId(v string) *DeleteWatermarkResponseBody {
	s.RequestId = &v
	return s
}

type DeleteWatermarkResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteWatermarkResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteWatermarkResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteWatermarkResponse) GoString() string {
	return s.String()
}

func (s *DeleteWatermarkResponse) SetHeaders(v map[string]*string) *DeleteWatermarkResponse {
	s.Headers = v
	return s
}

func (s *DeleteWatermarkResponse) SetStatusCode(v int32) *DeleteWatermarkResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteWatermarkResponse) SetBody(v *DeleteWatermarkResponseBody) *DeleteWatermarkResponse {
	s.Body = v
	return s
}

type DescribePlayTopVideosRequest struct {
	// The page number of the returned page.
	BizDate *string `json:"BizDate,omitempty" xml:"BizDate,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The operation that you want to perform. Set the value to **DescribePlayTopVideos**.
	PageNo *int64 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The time to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s DescribePlayTopVideosRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayTopVideosRequest) GoString() string {
	return s.String()
}

func (s *DescribePlayTopVideosRequest) SetBizDate(v string) *DescribePlayTopVideosRequest {
	s.BizDate = &v
	return s
}

func (s *DescribePlayTopVideosRequest) SetOwnerId(v int64) *DescribePlayTopVideosRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribePlayTopVideosRequest) SetPageNo(v int64) *DescribePlayTopVideosRequest {
	s.PageNo = &v
	return s
}

func (s *DescribePlayTopVideosRequest) SetPageSize(v int64) *DescribePlayTopVideosRequest {
	s.PageSize = &v
	return s
}

type DescribePlayTopVideosResponseBody struct {
	// The playback duration. Unit: milliseconds.
	PageNo *int64 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The total number of entries that were collected in playback statistics on top videos.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The number of unique visitors.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the video.
	TopPlayVideos *DescribePlayTopVideosResponseBodyTopPlayVideos `json:"TopPlayVideos,omitempty" xml:"TopPlayVideos,omitempty" type:"Struct"`
	// The number of video views.
	TotalNum *int64 `json:"TotalNum,omitempty" xml:"TotalNum,omitempty"`
}

func (s DescribePlayTopVideosResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayTopVideosResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePlayTopVideosResponseBody) SetPageNo(v int64) *DescribePlayTopVideosResponseBody {
	s.PageNo = &v
	return s
}

func (s *DescribePlayTopVideosResponseBody) SetPageSize(v int64) *DescribePlayTopVideosResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribePlayTopVideosResponseBody) SetRequestId(v string) *DescribePlayTopVideosResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribePlayTopVideosResponseBody) SetTopPlayVideos(v *DescribePlayTopVideosResponseBodyTopPlayVideos) *DescribePlayTopVideosResponseBody {
	s.TopPlayVideos = v
	return s
}

func (s *DescribePlayTopVideosResponseBody) SetTotalNum(v int64) *DescribePlayTopVideosResponseBody {
	s.TotalNum = &v
	return s
}

type DescribePlayTopVideosResponseBodyTopPlayVideos struct {
	TopPlayVideoStatis []*DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis `json:"TopPlayVideoStatis,omitempty" xml:"TopPlayVideoStatis,omitempty" type:"Repeated"`
}

func (s DescribePlayTopVideosResponseBodyTopPlayVideos) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayTopVideosResponseBodyTopPlayVideos) GoString() string {
	return s.String()
}

func (s *DescribePlayTopVideosResponseBodyTopPlayVideos) SetTopPlayVideoStatis(v []*DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis) *DescribePlayTopVideosResponseBodyTopPlayVideos {
	s.TopPlayVideoStatis = v
	return s
}

type DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis struct {
	PlayDuration *string `json:"PlayDuration,omitempty" xml:"PlayDuration,omitempty"`
	// The number of entries returned per page.
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	UV    *string `json:"UV,omitempty" xml:"UV,omitempty"`
	// Queries daily playback statistics on top videos, including video views, unique visitors, and total playback duration.
	VV      *string `json:"VV,omitempty" xml:"VV,omitempty"`
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis) GoString() string {
	return s.String()
}

func (s *DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis) SetPlayDuration(v string) *DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis {
	s.PlayDuration = &v
	return s
}

func (s *DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis) SetTitle(v string) *DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis {
	s.Title = &v
	return s
}

func (s *DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis) SetUV(v string) *DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis {
	s.UV = &v
	return s
}

func (s *DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis) SetVV(v string) *DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis {
	s.VV = &v
	return s
}

func (s *DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis) SetVideoId(v string) *DescribePlayTopVideosResponseBodyTopPlayVideosTopPlayVideoStatis {
	s.VideoId = &v
	return s
}

type DescribePlayTopVideosResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribePlayTopVideosResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribePlayTopVideosResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayTopVideosResponse) GoString() string {
	return s.String()
}

func (s *DescribePlayTopVideosResponse) SetHeaders(v map[string]*string) *DescribePlayTopVideosResponse {
	s.Headers = v
	return s
}

func (s *DescribePlayTopVideosResponse) SetStatusCode(v int32) *DescribePlayTopVideosResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePlayTopVideosResponse) SetBody(v *DescribePlayTopVideosResponseBody) *DescribePlayTopVideosResponse {
	s.Body = v
	return s
}

type DescribePlayUserAvgRequest struct {
	// The date when the statistics were generated. The date follows the *yyyy-MM-dd* format.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribePlayUserAvgRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayUserAvgRequest) GoString() string {
	return s.String()
}

func (s *DescribePlayUserAvgRequest) SetEndTime(v string) *DescribePlayUserAvgRequest {
	s.EndTime = &v
	return s
}

func (s *DescribePlayUserAvgRequest) SetOwnerId(v int64) *DescribePlayUserAvgRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribePlayUserAvgRequest) SetStartTime(v string) *DescribePlayUserAvgRequest {
	s.StartTime = &v
	return s
}

type DescribePlayUserAvgResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The operation that you want to perform. Set the value to **DescribePlayUserAvg**.
	UserPlayStatisAvgs *DescribePlayUserAvgResponseBodyUserPlayStatisAvgs `json:"UserPlayStatisAvgs,omitempty" xml:"UserPlayStatisAvgs,omitempty" type:"Struct"`
}

func (s DescribePlayUserAvgResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayUserAvgResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePlayUserAvgResponseBody) SetRequestId(v string) *DescribePlayUserAvgResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribePlayUserAvgResponseBody) SetUserPlayStatisAvgs(v *DescribePlayUserAvgResponseBodyUserPlayStatisAvgs) *DescribePlayUserAvgResponseBody {
	s.UserPlayStatisAvgs = v
	return s
}

type DescribePlayUserAvgResponseBodyUserPlayStatisAvgs struct {
	UserPlayStatisAvg []*DescribePlayUserAvgResponseBodyUserPlayStatisAvgsUserPlayStatisAvg `json:"UserPlayStatisAvg,omitempty" xml:"UserPlayStatisAvg,omitempty" type:"Repeated"`
}

func (s DescribePlayUserAvgResponseBodyUserPlayStatisAvgs) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayUserAvgResponseBodyUserPlayStatisAvgs) GoString() string {
	return s.String()
}

func (s *DescribePlayUserAvgResponseBodyUserPlayStatisAvgs) SetUserPlayStatisAvg(v []*DescribePlayUserAvgResponseBodyUserPlayStatisAvgsUserPlayStatisAvg) *DescribePlayUserAvgResponseBodyUserPlayStatisAvgs {
	s.UserPlayStatisAvg = v
	return s
}

type DescribePlayUserAvgResponseBodyUserPlayStatisAvgsUserPlayStatisAvg struct {
	AvgPlayCount    *string `json:"AvgPlayCount,omitempty" xml:"AvgPlayCount,omitempty"`
	AvgPlayDuration *string `json:"AvgPlayDuration,omitempty" xml:"AvgPlayDuration,omitempty"`
	// Queries the statistics on average playback each day in a specified time range.
	Date *string `json:"Date,omitempty" xml:"Date,omitempty"`
}

func (s DescribePlayUserAvgResponseBodyUserPlayStatisAvgsUserPlayStatisAvg) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayUserAvgResponseBodyUserPlayStatisAvgsUserPlayStatisAvg) GoString() string {
	return s.String()
}

func (s *DescribePlayUserAvgResponseBodyUserPlayStatisAvgsUserPlayStatisAvg) SetAvgPlayCount(v string) *DescribePlayUserAvgResponseBodyUserPlayStatisAvgsUserPlayStatisAvg {
	s.AvgPlayCount = &v
	return s
}

func (s *DescribePlayUserAvgResponseBodyUserPlayStatisAvgsUserPlayStatisAvg) SetAvgPlayDuration(v string) *DescribePlayUserAvgResponseBodyUserPlayStatisAvgsUserPlayStatisAvg {
	s.AvgPlayDuration = &v
	return s
}

func (s *DescribePlayUserAvgResponseBodyUserPlayStatisAvgsUserPlayStatisAvg) SetDate(v string) *DescribePlayUserAvgResponseBodyUserPlayStatisAvgsUserPlayStatisAvg {
	s.Date = &v
	return s
}

type DescribePlayUserAvgResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribePlayUserAvgResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribePlayUserAvgResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayUserAvgResponse) GoString() string {
	return s.String()
}

func (s *DescribePlayUserAvgResponse) SetHeaders(v map[string]*string) *DescribePlayUserAvgResponse {
	s.Headers = v
	return s
}

func (s *DescribePlayUserAvgResponse) SetStatusCode(v int32) *DescribePlayUserAvgResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePlayUserAvgResponse) SetBody(v *DescribePlayUserAvgResponseBody) *DescribePlayUserAvgResponse {
	s.Body = v
	return s
}

type DescribePlayUserTotalRequest struct {
	// The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The total number of unique visitors who use ApsaraVideo Player SDK for iOS.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribePlayUserTotalRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayUserTotalRequest) GoString() string {
	return s.String()
}

func (s *DescribePlayUserTotalRequest) SetEndTime(v string) *DescribePlayUserTotalRequest {
	s.EndTime = &v
	return s
}

func (s *DescribePlayUserTotalRequest) SetOwnerId(v int64) *DescribePlayUserTotalRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribePlayUserTotalRequest) SetStartTime(v string) *DescribePlayUserTotalRequest {
	s.StartTime = &v
	return s
}

type DescribePlayUserTotalResponseBody struct {
	// The total playback duration. Unit: milliseconds.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The statistics on total playback each day.
	UserPlayStatisTotals *DescribePlayUserTotalResponseBodyUserPlayStatisTotals `json:"UserPlayStatisTotals,omitempty" xml:"UserPlayStatisTotals,omitempty" type:"Struct"`
}

func (s DescribePlayUserTotalResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayUserTotalResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePlayUserTotalResponseBody) SetRequestId(v string) *DescribePlayUserTotalResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribePlayUserTotalResponseBody) SetUserPlayStatisTotals(v *DescribePlayUserTotalResponseBodyUserPlayStatisTotals) *DescribePlayUserTotalResponseBody {
	s.UserPlayStatisTotals = v
	return s
}

type DescribePlayUserTotalResponseBodyUserPlayStatisTotals struct {
	UserPlayStatisTotal []*DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal `json:"UserPlayStatisTotal,omitempty" xml:"UserPlayStatisTotal,omitempty" type:"Repeated"`
}

func (s DescribePlayUserTotalResponseBodyUserPlayStatisTotals) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayUserTotalResponseBodyUserPlayStatisTotals) GoString() string {
	return s.String()
}

func (s *DescribePlayUserTotalResponseBodyUserPlayStatisTotals) SetUserPlayStatisTotal(v []*DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal) *DescribePlayUserTotalResponseBodyUserPlayStatisTotals {
	s.UserPlayStatisTotal = v
	return s
}

type DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal struct {
	// The total number of unique visitors who use ApsaraVideo Player SDK for HTML5.
	Date *string `json:"Date,omitempty" xml:"Date,omitempty"`
	// The operation that you want to perform. Set the value to **DescribePlayUserTotal**.
	PlayDuration *string `json:"PlayDuration,omitempty" xml:"PlayDuration,omitempty"`
	// The date when the statistics were generated. The date follows the *yyyy-MM-dd* format.
	PlayRange *string `json:"PlayRange,omitempty" xml:"PlayRange,omitempty"`
	// The ID of the request.
	UV *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV `json:"UV,omitempty" xml:"UV,omitempty" type:"Struct"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	VV *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV `json:"VV,omitempty" xml:"VV,omitempty" type:"Struct"`
}

func (s DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal) GoString() string {
	return s.String()
}

func (s *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal) SetDate(v string) *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal {
	s.Date = &v
	return s
}

func (s *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal) SetPlayDuration(v string) *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal {
	s.PlayDuration = &v
	return s
}

func (s *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal) SetPlayRange(v string) *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal {
	s.PlayRange = &v
	return s
}

func (s *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal) SetUV(v *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV) *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal {
	s.UV = v
	return s
}

func (s *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal) SetVV(v *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV) *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotal {
	s.VV = v
	return s
}

type DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV struct {
	Android *string `json:"Android,omitempty" xml:"Android,omitempty"`
	// The distribution of the playback duration.
	Flash *string `json:"Flash,omitempty" xml:"Flash,omitempty"`
	HTML5 *string `json:"HTML5,omitempty" xml:"HTML5,omitempty"`
	// Queries the statistics on total playback each day in a specified time range.
	IOS *string `json:"iOS,omitempty" xml:"iOS,omitempty"`
}

func (s DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV) GoString() string {
	return s.String()
}

func (s *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV) SetAndroid(v string) *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV {
	s.Android = &v
	return s
}

func (s *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV) SetFlash(v string) *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV {
	s.Flash = &v
	return s
}

func (s *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV) SetHTML5(v string) *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV {
	s.HTML5 = &v
	return s
}

func (s *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV) SetIOS(v string) *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalUV {
	s.IOS = &v
	return s
}

type DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV struct {
	// The total number of video views that is collected for videos that are played by using ApsaraVideo Player SDK for iOS.
	Android *string `json:"Android,omitempty" xml:"Android,omitempty"`
	// The total number of video views that is collected for videos that are played by using ApsaraVideo Player SDK for Flash.
	Flash *string `json:"Flash,omitempty" xml:"Flash,omitempty"`
	// The total number of video views that is collected for videos that are played by using ApsaraVideo Player SDK for HTML5.
	HTML5 *string `json:"HTML5,omitempty" xml:"HTML5,omitempty"`
	// The total number of unique visitors who use ApsaraVideo Player SDK for Android.
	IOS *string `json:"iOS,omitempty" xml:"iOS,omitempty"`
}

func (s DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV) GoString() string {
	return s.String()
}

func (s *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV) SetAndroid(v string) *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV {
	s.Android = &v
	return s
}

func (s *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV) SetFlash(v string) *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV {
	s.Flash = &v
	return s
}

func (s *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV) SetHTML5(v string) *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV {
	s.HTML5 = &v
	return s
}

func (s *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV) SetIOS(v string) *DescribePlayUserTotalResponseBodyUserPlayStatisTotalsUserPlayStatisTotalVV {
	s.IOS = &v
	return s
}

type DescribePlayUserTotalResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribePlayUserTotalResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribePlayUserTotalResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayUserTotalResponse) GoString() string {
	return s.String()
}

func (s *DescribePlayUserTotalResponse) SetHeaders(v map[string]*string) *DescribePlayUserTotalResponse {
	s.Headers = v
	return s
}

func (s *DescribePlayUserTotalResponse) SetStatusCode(v int32) *DescribePlayUserTotalResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePlayUserTotalResponse) SetBody(v *DescribePlayUserTotalResponseBody) *DescribePlayUserTotalResponse {
	s.Body = v
	return s
}

type DescribePlayVideoStatisRequest struct {
	// The number of video views.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The date when the statistics were generated. The date follows the *yyyy-MM-dd* format.
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s DescribePlayVideoStatisRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayVideoStatisRequest) GoString() string {
	return s.String()
}

func (s *DescribePlayVideoStatisRequest) SetEndTime(v string) *DescribePlayVideoStatisRequest {
	s.EndTime = &v
	return s
}

func (s *DescribePlayVideoStatisRequest) SetOwnerId(v int64) *DescribePlayVideoStatisRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribePlayVideoStatisRequest) SetStartTime(v string) *DescribePlayVideoStatisRequest {
	s.StartTime = &v
	return s
}

func (s *DescribePlayVideoStatisRequest) SetVideoId(v string) *DescribePlayVideoStatisRequest {
	s.VideoId = &v
	return s
}

type DescribePlayVideoStatisResponseBody struct {
	// The ID of the video.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The number of unique visitors.
	VideoPlayStatisDetails *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetails `json:"VideoPlayStatisDetails,omitempty" xml:"VideoPlayStatisDetails,omitempty" type:"Struct"`
}

func (s DescribePlayVideoStatisResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayVideoStatisResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePlayVideoStatisResponseBody) SetRequestId(v string) *DescribePlayVideoStatisResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribePlayVideoStatisResponseBody) SetVideoPlayStatisDetails(v *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetails) *DescribePlayVideoStatisResponseBody {
	s.VideoPlayStatisDetails = v
	return s
}

type DescribePlayVideoStatisResponseBodyVideoPlayStatisDetails struct {
	VideoPlayStatisDetail []*DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail `json:"VideoPlayStatisDetail,omitempty" xml:"VideoPlayStatisDetail,omitempty" type:"Repeated"`
}

func (s DescribePlayVideoStatisResponseBodyVideoPlayStatisDetails) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayVideoStatisResponseBodyVideoPlayStatisDetails) GoString() string {
	return s.String()
}

func (s *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetails) SetVideoPlayStatisDetail(v []*DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail) *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetails {
	s.VideoPlayStatisDetail = v
	return s
}

type DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail struct {
	// The ID of the request.
	Date *string `json:"Date,omitempty" xml:"Date,omitempty"`
	// The title of the video.
	PlayDuration *string `json:"PlayDuration,omitempty" xml:"PlayDuration,omitempty"`
	PlayRange    *string `json:"PlayRange,omitempty" xml:"PlayRange,omitempty"`
	// Queries daily playback statistics on a specified video in a specified time range.
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	UV    *string `json:"UV,omitempty" xml:"UV,omitempty"`
	// The operation that you want to perform. Set the value to **DescribePlayVideoStatis**.
	VV *string `json:"VV,omitempty" xml:"VV,omitempty"`
}

func (s DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail) GoString() string {
	return s.String()
}

func (s *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail) SetDate(v string) *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail {
	s.Date = &v
	return s
}

func (s *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail) SetPlayDuration(v string) *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail {
	s.PlayDuration = &v
	return s
}

func (s *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail) SetPlayRange(v string) *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail {
	s.PlayRange = &v
	return s
}

func (s *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail) SetTitle(v string) *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail {
	s.Title = &v
	return s
}

func (s *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail) SetUV(v string) *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail {
	s.UV = &v
	return s
}

func (s *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail) SetVV(v string) *DescribePlayVideoStatisResponseBodyVideoPlayStatisDetailsVideoPlayStatisDetail {
	s.VV = &v
	return s
}

type DescribePlayVideoStatisResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribePlayVideoStatisResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribePlayVideoStatisResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePlayVideoStatisResponse) GoString() string {
	return s.String()
}

func (s *DescribePlayVideoStatisResponse) SetHeaders(v map[string]*string) *DescribePlayVideoStatisResponse {
	s.Headers = v
	return s
}

func (s *DescribePlayVideoStatisResponse) SetStatusCode(v int32) *DescribePlayVideoStatisResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePlayVideoStatisResponse) SetBody(v *DescribePlayVideoStatisResponseBody) *DescribePlayVideoStatisResponse {
	s.Body = v
	return s
}

type DescribeVodAIDataRequest struct {
	// The type of video AI. If you leave this parameter empty, statistics on video AI of all types are returned. Separate multiple types with commas (,). Valid values:
	//
	// *   **AIVideoCensor**: automated review
	// *   **AIVideoFPShot**: media fingerprinting
	// *   **AIVideoTag**: smart tagging
	AIType *string `json:"AIType,omitempty" xml:"AIType,omitempty"`
	// The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region in which you want to query data. If you leave this parameter empty, data in all regions is returned. Separate multiple regions with commas (,). Valid values:
	//
	// *   **cn-shanghai**: China (Shanghai)
	// *   **cn-beijing**: China (Beijing)
	// *   **eu-central-1**: Germany (Frankfurt)
	// *   **ap-southeast-1**: Singapore
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodAIDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodAIDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodAIDataRequest) SetAIType(v string) *DescribeVodAIDataRequest {
	s.AIType = &v
	return s
}

func (s *DescribeVodAIDataRequest) SetEndTime(v string) *DescribeVodAIDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodAIDataRequest) SetOwnerId(v int64) *DescribeVodAIDataRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodAIDataRequest) SetRegion(v string) *DescribeVodAIDataRequest {
	s.Region = &v
	return s
}

func (s *DescribeVodAIDataRequest) SetStartTime(v string) *DescribeVodAIDataRequest {
	s.StartTime = &v
	return s
}

type DescribeVodAIDataResponseBody struct {
	// The statistics on video AI.
	AIData *DescribeVodAIDataResponseBodyAIData `json:"AIData,omitempty" xml:"AIData,omitempty" type:"Struct"`
	// The time granularity at which the data was queried. Valid values:
	//
	// *   **hour**
	// *   **day**
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeVodAIDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodAIDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodAIDataResponseBody) SetAIData(v *DescribeVodAIDataResponseBodyAIData) *DescribeVodAIDataResponseBody {
	s.AIData = v
	return s
}

func (s *DescribeVodAIDataResponseBody) SetDataInterval(v string) *DescribeVodAIDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeVodAIDataResponseBody) SetRequestId(v string) *DescribeVodAIDataResponseBody {
	s.RequestId = &v
	return s
}

type DescribeVodAIDataResponseBodyAIData struct {
	AIDataItem []*DescribeVodAIDataResponseBodyAIDataAIDataItem `json:"AIDataItem,omitempty" xml:"AIDataItem,omitempty" type:"Repeated"`
}

func (s DescribeVodAIDataResponseBodyAIData) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodAIDataResponseBodyAIData) GoString() string {
	return s.String()
}

func (s *DescribeVodAIDataResponseBodyAIData) SetAIDataItem(v []*DescribeVodAIDataResponseBodyAIDataAIDataItem) *DescribeVodAIDataResponseBodyAIData {
	s.AIDataItem = v
	return s
}

type DescribeVodAIDataResponseBodyAIDataAIDataItem struct {
	// The statistics on video AI of each type.
	Data *DescribeVodAIDataResponseBodyAIDataAIDataItemData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The timestamp of the returned data. The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeVodAIDataResponseBodyAIDataAIDataItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodAIDataResponseBodyAIDataAIDataItem) GoString() string {
	return s.String()
}

func (s *DescribeVodAIDataResponseBodyAIDataAIDataItem) SetData(v *DescribeVodAIDataResponseBodyAIDataAIDataItemData) *DescribeVodAIDataResponseBodyAIDataAIDataItem {
	s.Data = v
	return s
}

func (s *DescribeVodAIDataResponseBodyAIDataAIDataItem) SetTimeStamp(v string) *DescribeVodAIDataResponseBodyAIDataAIDataItem {
	s.TimeStamp = &v
	return s
}

type DescribeVodAIDataResponseBodyAIDataAIDataItemData struct {
	DataItem []*DescribeVodAIDataResponseBodyAIDataAIDataItemDataDataItem `json:"DataItem,omitempty" xml:"DataItem,omitempty" type:"Repeated"`
}

func (s DescribeVodAIDataResponseBodyAIDataAIDataItemData) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodAIDataResponseBodyAIDataAIDataItemData) GoString() string {
	return s.String()
}

func (s *DescribeVodAIDataResponseBodyAIDataAIDataItemData) SetDataItem(v []*DescribeVodAIDataResponseBodyAIDataAIDataItemDataDataItem) *DescribeVodAIDataResponseBodyAIDataAIDataItemData {
	s.DataItem = v
	return s
}

type DescribeVodAIDataResponseBodyAIDataAIDataItemDataDataItem struct {
	// The type of video AI. Valid values:
	//
	// *   **AIVideoCensor**: automated review
	// *   **AIVideoFPShot**: media fingerprinting
	// *   **AIVideoTag**: smart tagging
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The processing duration. Unit: seconds.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVodAIDataResponseBodyAIDataAIDataItemDataDataItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodAIDataResponseBodyAIDataAIDataItemDataDataItem) GoString() string {
	return s.String()
}

func (s *DescribeVodAIDataResponseBodyAIDataAIDataItemDataDataItem) SetName(v string) *DescribeVodAIDataResponseBodyAIDataAIDataItemDataDataItem {
	s.Name = &v
	return s
}

func (s *DescribeVodAIDataResponseBodyAIDataAIDataItemDataDataItem) SetValue(v string) *DescribeVodAIDataResponseBodyAIDataAIDataItemDataDataItem {
	s.Value = &v
	return s
}

type DescribeVodAIDataResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVodAIDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVodAIDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodAIDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodAIDataResponse) SetHeaders(v map[string]*string) *DescribeVodAIDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodAIDataResponse) SetStatusCode(v int32) *DescribeVodAIDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodAIDataResponse) SetBody(v *DescribeVodAIDataResponseBody) *DescribeVodAIDataResponse {
	s.Body = v
	return s
}

type DescribeVodCertificateListRequest struct {
	// certificate
	DomainName    *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeVodCertificateListRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodCertificateListRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodCertificateListRequest) SetDomainName(v string) *DescribeVodCertificateListRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodCertificateListRequest) SetOwnerId(v int64) *DescribeVodCertificateListRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodCertificateListRequest) SetSecurityToken(v string) *DescribeVodCertificateListRequest {
	s.SecurityToken = &v
	return s
}

type DescribeVodCertificateListResponseBody struct {
	// The common name of the certificate.
	CertificateListModel *DescribeVodCertificateListResponseBodyCertificateListModel `json:"CertificateListModel,omitempty" xml:"CertificateListModel,omitempty" type:"Struct"`
	// The certificate authority (CA) that issued the certificate.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeVodCertificateListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodCertificateListResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodCertificateListResponseBody) SetCertificateListModel(v *DescribeVodCertificateListResponseBodyCertificateListModel) *DescribeVodCertificateListResponseBody {
	s.CertificateListModel = v
	return s
}

func (s *DescribeVodCertificateListResponseBody) SetRequestId(v string) *DescribeVodCertificateListResponseBody {
	s.RequestId = &v
	return s
}

type DescribeVodCertificateListResponseBodyCertificateListModel struct {
	// The ID of the certificate.
	CertList *DescribeVodCertificateListResponseBodyCertificateListModelCertList `json:"CertList,omitempty" xml:"CertList,omitempty" type:"Struct"`
	// The number of certificates.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
}

func (s DescribeVodCertificateListResponseBodyCertificateListModel) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodCertificateListResponseBodyCertificateListModel) GoString() string {
	return s.String()
}

func (s *DescribeVodCertificateListResponseBodyCertificateListModel) SetCertList(v *DescribeVodCertificateListResponseBodyCertificateListModelCertList) *DescribeVodCertificateListResponseBodyCertificateListModel {
	s.CertList = v
	return s
}

func (s *DescribeVodCertificateListResponseBodyCertificateListModel) SetCount(v int32) *DescribeVodCertificateListResponseBodyCertificateListModel {
	s.Count = &v
	return s
}

type DescribeVodCertificateListResponseBodyCertificateListModelCertList struct {
	Cert []*DescribeVodCertificateListResponseBodyCertificateListModelCertListCert `json:"Cert,omitempty" xml:"Cert,omitempty" type:"Repeated"`
}

func (s DescribeVodCertificateListResponseBodyCertificateListModelCertList) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodCertificateListResponseBodyCertificateListModelCertList) GoString() string {
	return s.String()
}

func (s *DescribeVodCertificateListResponseBodyCertificateListModelCertList) SetCert(v []*DescribeVodCertificateListResponseBodyCertificateListModelCertListCert) *DescribeVodCertificateListResponseBodyCertificateListModelCertList {
	s.Cert = v
	return s
}

type DescribeVodCertificateListResponseBodyCertificateListModelCertListCert struct {
	CertId *int64 `json:"CertId,omitempty" xml:"CertId,omitempty"`
	// The operation that you want to perform. Set the value to **DescribeVodCertificateList**.
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	Common   *string `json:"Common,omitempty" xml:"Common,omitempty"`
	// The ID of the request.
	Fingerprint *string `json:"Fingerprint,omitempty" xml:"Fingerprint,omitempty"`
	// Queries the certificates of a specified domain name for CDN or all the domain names for CDN within your Alibaba Cloud account.
	Issuer *string `json:"Issuer,omitempty" xml:"Issuer,omitempty"`
	// The details of each certificate.
	LastTime *int64 `json:"LastTime,omitempty" xml:"LastTime,omitempty"`
}

func (s DescribeVodCertificateListResponseBodyCertificateListModelCertListCert) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodCertificateListResponseBodyCertificateListModelCertListCert) GoString() string {
	return s.String()
}

func (s *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert) SetCertId(v int64) *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert {
	s.CertId = &v
	return s
}

func (s *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert) SetCertName(v string) *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert {
	s.CertName = &v
	return s
}

func (s *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert) SetCommon(v string) *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert {
	s.Common = &v
	return s
}

func (s *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert) SetFingerprint(v string) *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert {
	s.Fingerprint = &v
	return s
}

func (s *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert) SetIssuer(v string) *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert {
	s.Issuer = &v
	return s
}

func (s *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert) SetLastTime(v int64) *DescribeVodCertificateListResponseBodyCertificateListModelCertListCert {
	s.LastTime = &v
	return s
}

type DescribeVodCertificateListResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVodCertificateListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVodCertificateListResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodCertificateListResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodCertificateListResponse) SetHeaders(v map[string]*string) *DescribeVodCertificateListResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodCertificateListResponse) SetStatusCode(v int32) *DescribeVodCertificateListResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodCertificateListResponse) SetBody(v *DescribeVodCertificateListResponseBody) *DescribeVodCertificateListResponse {
	s.Body = v
	return s
}

type DescribeVodDomainBpsDataRequest struct {
	// The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The name of the Internet service provider (ISP). If you do not specify this parameter, the data of all ISPs is returned.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The bandwidth in mainland China. Unit: bit/s. When the bandwidth data is queried by ISP, no value is returned.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The end of the time range in which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region. If you do not specify this parameter, the data in all regions is returned. Only data in the China (Shanghai) region can be queried.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The operation that you want to perform. Set the value to **DescribeVodDomainBpsData**.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainBpsDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainBpsDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainBpsDataRequest) SetDomainName(v string) *DescribeVodDomainBpsDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainBpsDataRequest) SetEndTime(v string) *DescribeVodDomainBpsDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainBpsDataRequest) SetInterval(v string) *DescribeVodDomainBpsDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeVodDomainBpsDataRequest) SetIspNameEn(v string) *DescribeVodDomainBpsDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeVodDomainBpsDataRequest) SetLocationNameEn(v string) *DescribeVodDomainBpsDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeVodDomainBpsDataRequest) SetOwnerId(v int64) *DescribeVodDomainBpsDataRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodDomainBpsDataRequest) SetStartTime(v string) *DescribeVodDomainBpsDataRequest {
	s.StartTime = &v
	return s
}

type DescribeVodDomainBpsDataResponseBody struct {
	// The name of the ISP. By default, the data of all ISPs is returned.
	BpsDataPerInterval *DescribeVodDomainBpsDataResponseBodyBpsDataPerInterval `json:"BpsDataPerInterval,omitempty" xml:"BpsDataPerInterval,omitempty" type:"Struct"`
	// The HTTPS bandwidth on L1 nodes in mainland China. Unit: bit/s. When the bandwidth data is queried by ISP, no value is returned.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The time interval between the returned entries. Unit: seconds.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The bandwidth. Unit: bit/s.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The beginning of the time range in which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The query interval. Unit: seconds. Valid values: **300**, **3600**, and **86400**.
	//
	// *   If the time range to query is less than 3 days, valid values are **300**, **3600**, and **86400**. The default value is 300.
	// *   If the time range to query is from 3 to less than 31 days, valid values are **3600** and **86400**. The default value is 3600.
	// *   If the time range to query is from 31 to 90 days, the valid value is **86400**.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	// The name of the region. By default, the data in all regions is returned.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The domain name to be queried. If you do not specify this parameter, the merged data of all your domain names for CDN is returned. You can specify multiple domain names. Separate them with commas (,).
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainBpsDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainBpsDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainBpsDataResponseBody) SetBpsDataPerInterval(v *DescribeVodDomainBpsDataResponseBodyBpsDataPerInterval) *DescribeVodDomainBpsDataResponseBody {
	s.BpsDataPerInterval = v
	return s
}

func (s *DescribeVodDomainBpsDataResponseBody) SetDataInterval(v string) *DescribeVodDomainBpsDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeVodDomainBpsDataResponseBody) SetDomainName(v string) *DescribeVodDomainBpsDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainBpsDataResponseBody) SetEndTime(v string) *DescribeVodDomainBpsDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainBpsDataResponseBody) SetIspNameEn(v string) *DescribeVodDomainBpsDataResponseBody {
	s.IspNameEn = &v
	return s
}

func (s *DescribeVodDomainBpsDataResponseBody) SetLocationNameEn(v string) *DescribeVodDomainBpsDataResponseBody {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeVodDomainBpsDataResponseBody) SetRequestId(v string) *DescribeVodDomainBpsDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVodDomainBpsDataResponseBody) SetStartTime(v string) *DescribeVodDomainBpsDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeVodDomainBpsDataResponseBodyBpsDataPerInterval struct {
	DataModule []*DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainBpsDataResponseBodyBpsDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainBpsDataResponseBodyBpsDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainBpsDataResponseBodyBpsDataPerInterval) SetDataModule(v []*DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) *DescribeVodDomainBpsDataResponseBodyBpsDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule struct {
	DomesticValue *string `json:"DomesticValue,omitempty" xml:"DomesticValue,omitempty"`
	// The ID of the request.
	HttpsDomesticValue *string `json:"HttpsDomesticValue,omitempty" xml:"HttpsDomesticValue,omitempty"`
	HttpsOverseasValue *string `json:"HttpsOverseasValue,omitempty" xml:"HttpsOverseasValue,omitempty"`
	HttpsValue         *string `json:"HttpsValue,omitempty" xml:"HttpsValue,omitempty"`
	OverseasValue      *string `json:"OverseasValue,omitempty" xml:"OverseasValue,omitempty"`
	TimeStamp          *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// Queries the bandwidth for one or more specified domain names for CDN.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) SetDomesticValue(v string) *DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.DomesticValue = &v
	return s
}

func (s *DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) SetHttpsDomesticValue(v string) *DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.HttpsDomesticValue = &v
	return s
}

func (s *DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) SetHttpsOverseasValue(v string) *DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.HttpsOverseasValue = &v
	return s
}

func (s *DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) SetHttpsValue(v string) *DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.HttpsValue = &v
	return s
}

func (s *DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) SetOverseasValue(v string) *DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.OverseasValue = &v
	return s
}

func (s *DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule) SetValue(v string) *DescribeVodDomainBpsDataResponseBodyBpsDataPerIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeVodDomainBpsDataResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVodDomainBpsDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVodDomainBpsDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainBpsDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainBpsDataResponse) SetHeaders(v map[string]*string) *DescribeVodDomainBpsDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodDomainBpsDataResponse) SetStatusCode(v int32) *DescribeVodDomainBpsDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodDomainBpsDataResponse) SetBody(v *DescribeVodDomainBpsDataResponseBody) *DescribeVodDomainBpsDataResponse {
	s.Body = v
	return s
}

type DescribeVodDomainCertificateInfoRequest struct {
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId    *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
}

func (s DescribeVodDomainCertificateInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainCertificateInfoRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainCertificateInfoRequest) SetDomainName(v string) *DescribeVodDomainCertificateInfoRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainCertificateInfoRequest) SetOwnerId(v int64) *DescribeVodDomainCertificateInfoRequest {
	s.OwnerId = &v
	return s
}

type DescribeVodDomainCertificateInfoResponseBody struct {
	CertInfos *DescribeVodDomainCertificateInfoResponseBodyCertInfos `json:"CertInfos,omitempty" xml:"CertInfos,omitempty" type:"Struct"`
	RequestId *string                                                `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeVodDomainCertificateInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainCertificateInfoResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainCertificateInfoResponseBody) SetCertInfos(v *DescribeVodDomainCertificateInfoResponseBodyCertInfos) *DescribeVodDomainCertificateInfoResponseBody {
	s.CertInfos = v
	return s
}

func (s *DescribeVodDomainCertificateInfoResponseBody) SetRequestId(v string) *DescribeVodDomainCertificateInfoResponseBody {
	s.RequestId = &v
	return s
}

type DescribeVodDomainCertificateInfoResponseBodyCertInfos struct {
	CertInfo []*DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo `json:"CertInfo,omitempty" xml:"CertInfo,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainCertificateInfoResponseBodyCertInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainCertificateInfoResponseBodyCertInfos) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainCertificateInfoResponseBodyCertInfos) SetCertInfo(v []*DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo) *DescribeVodDomainCertificateInfoResponseBodyCertInfos {
	s.CertInfo = v
	return s
}

type DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo struct {
	CertDomainName          *string `json:"CertDomainName,omitempty" xml:"CertDomainName,omitempty"`
	CertExpireTime          *string `json:"CertExpireTime,omitempty" xml:"CertExpireTime,omitempty"`
	CertLife                *string `json:"CertLife,omitempty" xml:"CertLife,omitempty"`
	CertName                *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	CertOrg                 *string `json:"CertOrg,omitempty" xml:"CertOrg,omitempty"`
	CertType                *string `json:"CertType,omitempty" xml:"CertType,omitempty"`
	DomainName              *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	ServerCertificateStatus *string `json:"ServerCertificateStatus,omitempty" xml:"ServerCertificateStatus,omitempty"`
	Status                  *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertDomainName(v string) *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertDomainName = &v
	return s
}

func (s *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertExpireTime(v string) *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertExpireTime = &v
	return s
}

func (s *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertLife(v string) *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertLife = &v
	return s
}

func (s *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertName(v string) *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertName = &v
	return s
}

func (s *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertOrg(v string) *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertOrg = &v
	return s
}

func (s *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo) SetCertType(v string) *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.CertType = &v
	return s
}

func (s *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo) SetDomainName(v string) *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo) SetServerCertificateStatus(v string) *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.ServerCertificateStatus = &v
	return s
}

func (s *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo) SetStatus(v string) *DescribeVodDomainCertificateInfoResponseBodyCertInfosCertInfo {
	s.Status = &v
	return s
}

type DescribeVodDomainCertificateInfoResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVodDomainCertificateInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVodDomainCertificateInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainCertificateInfoResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainCertificateInfoResponse) SetHeaders(v map[string]*string) *DescribeVodDomainCertificateInfoResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodDomainCertificateInfoResponse) SetStatusCode(v int32) *DescribeVodDomainCertificateInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodDomainCertificateInfoResponse) SetBody(v *DescribeVodDomainCertificateInfoResponseBody) *DescribeVodDomainCertificateInfoResponse {
	s.Body = v
	return s
}

type DescribeVodDomainConfigsRequest struct {
	// The name of the feature. Separate multiple names with commas (,). For more information, see the **Feature description** section.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The parameters of each feature.
	FunctionNames *string `json:"FunctionNames,omitempty" xml:"FunctionNames,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeVodDomainConfigsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainConfigsRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainConfigsRequest) SetDomainName(v string) *DescribeVodDomainConfigsRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainConfigsRequest) SetFunctionNames(v string) *DescribeVodDomainConfigsRequest {
	s.FunctionNames = &v
	return s
}

func (s *DescribeVodDomainConfigsRequest) SetOwnerId(v int64) *DescribeVodDomainConfigsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodDomainConfigsRequest) SetSecurityToken(v string) *DescribeVodDomainConfigsRequest {
	s.SecurityToken = &v
	return s
}

type DescribeVodDomainConfigsResponseBody struct {
	// The value of the parameter.
	DomainConfigs *DescribeVodDomainConfigsResponseBodyDomainConfigs `json:"DomainConfigs,omitempty" xml:"DomainConfigs,omitempty" type:"Struct"`
	// The status of the configuration. Valid values:
	//
	// - **success**
	// - **testing**
	// - **failed**
	// - **configuring**
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeVodDomainConfigsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainConfigsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainConfigsResponseBody) SetDomainConfigs(v *DescribeVodDomainConfigsResponseBodyDomainConfigs) *DescribeVodDomainConfigsResponseBody {
	s.DomainConfigs = v
	return s
}

func (s *DescribeVodDomainConfigsResponseBody) SetRequestId(v string) *DescribeVodDomainConfigsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeVodDomainConfigsResponseBodyDomainConfigs struct {
	DomainConfig []*DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig `json:"DomainConfig,omitempty" xml:"DomainConfig,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainConfigsResponseBodyDomainConfigs) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainConfigsResponseBodyDomainConfigs) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainConfigsResponseBodyDomainConfigs) SetDomainConfig(v []*DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig) *DescribeVodDomainConfigsResponseBodyDomainConfigs {
	s.DomainConfig = v
	return s
}

type DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig struct {
	// ## Feature description
	//
	// | Feature | Description |
	// | ------- | ----------- |
	// | referer_white_list_set | Specifies the referer whitelist. |
	// | referer_black_list_set | Specifies the referer blacklist. |
	// | filetype_based_ttl_set | Specifies the time period after which a file expires. |
	// | path_based_ttl_set | Specifies the time period after which a directory expires. |
	// | cc_defense | Configures protection against HTTP flood attacks. |
	// | oss_auth | Configures authentication for the access to an Object Storage Service (OSS) bucket. |
	// | ip_black_list_set | Specifies the IP address blacklist. |
	// | ip_white_list_set | Specifies the IP address whitelist. |
	// | error_page | Redirects an error page to a specified page. |
	// | tesla | Optimizes pages to accelerate access. |
	// | set_req_host_header | Modifies the custom header of back-to-origin requests. |
	// | set_hashkey_args | Ignores the specified URL parameters. |
	// | aliauth | Configures Alibaba Cloud authentication. |
	// | set_resp_header | Specifies a response header. To verify the setting, you can check the response message in a browser. |
	// | video_seek | Configures video seeking. |
	// | range | Configures object chunking. |
	// | gzip | Optimizes pages by using GNU zip (Gzip) compression. |
	// | https_force | Configures force redirect to HTTPS. |
	// | http_force | Configures force redirect to HTTP. |
	// | alivod | Configures ApsaraVideo VOD. |
	// | forward_scheme | Specifies the origin protocol policy or configures whether to enable adaptive origin fetch. |
	// | tmd_signature | Specifies the self-defined rules for the rate limit. |
	ConfigId     *string                                                                    `json:"ConfigId,omitempty" xml:"ConfigId,omitempty"`
	FunctionArgs *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs `json:"FunctionArgs,omitempty" xml:"FunctionArgs,omitempty" type:"Struct"`
	// Queries the configurations of a specified domain name for CDN. You can query the configurations of one or more features at a time.
	FunctionName *string `json:"FunctionName,omitempty" xml:"FunctionName,omitempty"`
	// The operation that you want to perform. Set the value to **DescribeVodDomainConfigs**.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig) SetConfigId(v string) *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig {
	s.ConfigId = &v
	return s
}

func (s *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig) SetFunctionArgs(v *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs) *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig {
	s.FunctionArgs = v
	return s
}

func (s *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig) SetFunctionName(v string) *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig {
	s.FunctionName = &v
	return s
}

func (s *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig) SetStatus(v string) *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfig {
	s.Status = &v
	return s
}

type DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs struct {
	FunctionArg []*DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg `json:"FunctionArg,omitempty" xml:"FunctionArg,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs) SetFunctionArg(v []*DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg) *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgs {
	s.FunctionArg = v
	return s
}

type DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg struct {
	ArgName  *string `json:"ArgName,omitempty" xml:"ArgName,omitempty"`
	ArgValue *string `json:"ArgValue,omitempty" xml:"ArgValue,omitempty"`
}

func (s DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg) SetArgName(v string) *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg {
	s.ArgName = &v
	return s
}

func (s *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg) SetArgValue(v string) *DescribeVodDomainConfigsResponseBodyDomainConfigsDomainConfigFunctionArgsFunctionArg {
	s.ArgValue = &v
	return s
}

type DescribeVodDomainConfigsResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVodDomainConfigsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVodDomainConfigsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainConfigsResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainConfigsResponse) SetHeaders(v map[string]*string) *DescribeVodDomainConfigsResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodDomainConfigsResponse) SetStatusCode(v int32) *DescribeVodDomainConfigsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodDomainConfigsResponse) SetBody(v *DescribeVodDomainConfigsResponseBody) *DescribeVodDomainConfigsResponse {
	s.Body = v
	return s
}

type DescribeVodDomainDetailRequest struct {
	// The status of the origin server. Valid values:
	//
	// *   **online**: indicates that the origin server is enabled.
	// *   **offline**: indicates that the origin server is disabled.
	DomainName    *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeVodDomainDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainDetailRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainDetailRequest) SetDomainName(v string) *DescribeVodDomainDetailRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainDetailRequest) SetOwnerId(v int64) *DescribeVodDomainDetailRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodDomainDetailRequest) SetSecurityToken(v string) *DescribeVodDomainDetailRequest {
	s.SecurityToken = &v
	return s
}

type DescribeVodDomainDetailResponseBody struct {
	// The priority of the origin server.
	DomainDetail *DescribeVodDomainDetailResponseBodyDomainDetail `json:"DomainDetail,omitempty" xml:"DomainDetail,omitempty" type:"Struct"`
	// The operation that you want to perform. Set the value to **DescribeVodDomainDetail**.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeVodDomainDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainDetailResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainDetailResponseBody) SetDomainDetail(v *DescribeVodDomainDetailResponseBodyDomainDetail) *DescribeVodDomainDetailResponseBody {
	s.DomainDetail = v
	return s
}

func (s *DescribeVodDomainDetailResponseBody) SetRequestId(v string) *DescribeVodDomainDetailResponseBody {
	s.RequestId = &v
	return s
}

type DescribeVodDomainDetailResponseBodyDomainDetail struct {
	// The time when the domain name for CDN was added. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The status of the domain name for CDN. Value values:
	//
	// *   **online**: indicates that the domain name is enabled.
	// *   **offline**: indicates that the domain name is disabled.
	// *   **configuring**: indicates that the domain name is being configured.
	// *   **configure_failed**: indicates that the domain name failed to be configured.
	// *   **checking**: indicates that the domain name is under review.
	// *   **check_failed**: indicates that the domain name failed the review.
	Cname *string `json:"Cname,omitempty" xml:"Cname,omitempty"`
	// The name of the certificate. The value of this parameter is returned if HTTPS is enabled.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The port number. Valid values: 443 and 80.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The address of the origin server.
	DomainStatus *string `json:"DomainStatus,omitempty" xml:"DomainStatus,omitempty"`
	// The last time when the domain name for CDN was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	GmtCreated *string `json:"GmtCreated,omitempty" xml:"GmtCreated,omitempty"`
	// Indicates whether the Secure Sockets Layer (SSL) certificate is enabled. Valid values:
	//
	// *   **on**: indicates that the SSL certificate is enabled.
	// *   **off**: indicates that the SSL certificate is disabled.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// This parameter is applicable to users of level 3 or higher in mainland China and users outside mainland China. Valid values:
	//
	// *   **domestic**: mainland China. This is the default value.
	// *   **overseas**: outside mainland China.
	// *   **global**: regions in and outside mainland China.
	SSLProtocol *string `json:"SSLProtocol,omitempty" xml:"SSLProtocol,omitempty"`
	// The domain name for CDN.
	SSLPub *string `json:"SSLPub,omitempty" xml:"SSLPub,omitempty"`
	// The weight of the origin server.
	Scope *string `json:"Scope,omitempty" xml:"Scope,omitempty"`
	// The ID of the request.
	Sources *DescribeVodDomainDetailResponseBodyDomainDetailSources `json:"Sources,omitempty" xml:"Sources,omitempty" type:"Struct"`
	// The CNAME that is assigned to the domain name for CDN. You must add a CNAME record in the system of your Domain Name System (DNS) service provider to map the domain name for CDN to the CNAME.
	Weight *string `json:"Weight,omitempty" xml:"Weight,omitempty"`
}

func (s DescribeVodDomainDetailResponseBodyDomainDetail) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainDetailResponseBodyDomainDetail) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetail) SetCertName(v string) *DescribeVodDomainDetailResponseBodyDomainDetail {
	s.CertName = &v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetail) SetCname(v string) *DescribeVodDomainDetailResponseBodyDomainDetail {
	s.Cname = &v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetail) SetDescription(v string) *DescribeVodDomainDetailResponseBodyDomainDetail {
	s.Description = &v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetail) SetDomainName(v string) *DescribeVodDomainDetailResponseBodyDomainDetail {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetail) SetDomainStatus(v string) *DescribeVodDomainDetailResponseBodyDomainDetail {
	s.DomainStatus = &v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetail) SetGmtCreated(v string) *DescribeVodDomainDetailResponseBodyDomainDetail {
	s.GmtCreated = &v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetail) SetGmtModified(v string) *DescribeVodDomainDetailResponseBodyDomainDetail {
	s.GmtModified = &v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetail) SetSSLProtocol(v string) *DescribeVodDomainDetailResponseBodyDomainDetail {
	s.SSLProtocol = &v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetail) SetSSLPub(v string) *DescribeVodDomainDetailResponseBodyDomainDetail {
	s.SSLPub = &v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetail) SetScope(v string) *DescribeVodDomainDetailResponseBodyDomainDetail {
	s.Scope = &v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetail) SetSources(v *DescribeVodDomainDetailResponseBodyDomainDetailSources) *DescribeVodDomainDetailResponseBodyDomainDetail {
	s.Sources = v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetail) SetWeight(v string) *DescribeVodDomainDetailResponseBodyDomainDetail {
	s.Weight = &v
	return s
}

type DescribeVodDomainDetailResponseBodyDomainDetailSources struct {
	Source []*DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource `json:"Source,omitempty" xml:"Source,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainDetailResponseBodyDomainDetailSources) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainDetailResponseBodyDomainDetailSources) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetailSources) SetSource(v []*DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource) *DescribeVodDomainDetailResponseBodyDomainDetailSources {
	s.Source = v
	return s
}

type DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource struct {
	Content  *string `json:"Content,omitempty" xml:"Content,omitempty"`
	Enabled  *string `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	Port     *int32  `json:"Port,omitempty" xml:"Port,omitempty"`
	Priority *string `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// Queries the basic information about a specified domain name for CDN.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource) SetContent(v string) *DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource {
	s.Content = &v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource) SetEnabled(v string) *DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource {
	s.Enabled = &v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource) SetPort(v int32) *DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource {
	s.Port = &v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource) SetPriority(v string) *DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource {
	s.Priority = &v
	return s
}

func (s *DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource) SetType(v string) *DescribeVodDomainDetailResponseBodyDomainDetailSourcesSource {
	s.Type = &v
	return s
}

type DescribeVodDomainDetailResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVodDomainDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVodDomainDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainDetailResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainDetailResponse) SetHeaders(v map[string]*string) *DescribeVodDomainDetailResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodDomainDetailResponse) SetStatusCode(v int32) *DescribeVodDomainDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodDomainDetailResponse) SetBody(v *DescribeVodDomainDetailResponseBody) *DescribeVodDomainDetailResponse {
	s.Body = v
	return s
}

type DescribeVodDomainLogRequest struct {
	// The page number of the returned page.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The operation that you want to perform. Set the value to **DescribeVodDomainLog**.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The name of the log file.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The beginning of the time range in which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainLogRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainLogRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainLogRequest) SetDomainName(v string) *DescribeVodDomainLogRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainLogRequest) SetEndTime(v string) *DescribeVodDomainLogRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainLogRequest) SetOwnerId(v int64) *DescribeVodDomainLogRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodDomainLogRequest) SetPageNumber(v int64) *DescribeVodDomainLogRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeVodDomainLogRequest) SetPageSize(v int64) *DescribeVodDomainLogRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeVodDomainLogRequest) SetStartTime(v string) *DescribeVodDomainLogRequest {
	s.StartTime = &v
	return s
}

type DescribeVodDomainLogResponseBody struct {
	// The detailed data of Alibaba Cloud CDN logs.
	DomainLogDetails *DescribeVodDomainLogResponseBodyDomainLogDetails `json:"DomainLogDetails,omitempty" xml:"DomainLogDetails,omitempty" type:"Struct"`
	// The number of entries returned per page.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeVodDomainLogResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainLogResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainLogResponseBody) SetDomainLogDetails(v *DescribeVodDomainLogResponseBodyDomainLogDetails) *DescribeVodDomainLogResponseBody {
	s.DomainLogDetails = v
	return s
}

func (s *DescribeVodDomainLogResponseBody) SetRequestId(v string) *DescribeVodDomainLogResponseBody {
	s.RequestId = &v
	return s
}

type DescribeVodDomainLogResponseBodyDomainLogDetails struct {
	DomainLogDetail []*DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail `json:"DomainLogDetail,omitempty" xml:"DomainLogDetail,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainLogResponseBodyDomainLogDetails) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainLogResponseBodyDomainLogDetails) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainLogResponseBodyDomainLogDetails) SetDomainLogDetail(v []*DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail) *DescribeVodDomainLogResponseBodyDomainLogDetails {
	s.DomainLogDetail = v
	return s
}

type DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The detailed information about Alibaba Cloud CDN logs.
	LogCount *int64 `json:"LogCount,omitempty" xml:"LogCount,omitempty"`
	// The path of the log file.
	LogInfos  *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos  `json:"LogInfos,omitempty" xml:"LogInfos,omitempty" type:"Struct"`
	PageInfos *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos `json:"PageInfos,omitempty" xml:"PageInfos,omitempty" type:"Struct"`
}

func (s DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail) SetDomainName(v string) *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail) SetLogCount(v int64) *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail {
	s.LogCount = &v
	return s
}

func (s *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail) SetLogInfos(v *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos) *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail {
	s.LogInfos = v
	return s
}

func (s *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail) SetPageInfos(v *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos) *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetail {
	s.PageInfos = v
	return s
}

type DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos struct {
	LogInfoDetail []*DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail `json:"LogInfoDetail,omitempty" xml:"LogInfoDetail,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos) SetLogInfoDetail(v []*DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfos {
	s.LogInfoDetail = v
	return s
}

type DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail struct {
	// The total number of entries returned.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// Queries the information about the raw access logs for a specific domain name, including the log path.
	LogName *string `json:"LogName,omitempty" xml:"LogName,omitempty"`
	LogPath *string `json:"LogPath,omitempty" xml:"LogPath,omitempty"`
	// The ID of the request.
	LogSize *int64 `json:"LogSize,omitempty" xml:"LogSize,omitempty"`
	// The pagination settings of Alibaba Cloud CDN logs.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) SetEndTime(v string) *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) SetLogName(v string) *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail {
	s.LogName = &v
	return s
}

func (s *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) SetLogPath(v string) *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail {
	s.LogPath = &v
	return s
}

func (s *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) SetLogSize(v int64) *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail {
	s.LogSize = &v
	return s
}

func (s *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail) SetStartTime(v string) *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailLogInfosLogInfoDetail {
	s.StartTime = &v
	return s
}

type DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos struct {
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Total      *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos) SetPageNumber(v int64) *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos {
	s.PageNumber = &v
	return s
}

func (s *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos) SetPageSize(v int64) *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos {
	s.PageSize = &v
	return s
}

func (s *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos) SetTotal(v int64) *DescribeVodDomainLogResponseBodyDomainLogDetailsDomainLogDetailPageInfos {
	s.Total = &v
	return s
}

type DescribeVodDomainLogResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVodDomainLogResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVodDomainLogResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainLogResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainLogResponse) SetHeaders(v map[string]*string) *DescribeVodDomainLogResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodDomainLogResponse) SetStatusCode(v int32) *DescribeVodDomainLogResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodDomainLogResponse) SetBody(v *DescribeVodDomainLogResponseBody) *DescribeVodDomainLogResponse {
	s.Body = v
	return s
}

type DescribeVodDomainSrcBpsDataRequest struct {
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	EndTime    *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	Interval   *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	OwnerId    *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	StartTime  *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainSrcBpsDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainSrcBpsDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainSrcBpsDataRequest) SetDomainName(v string) *DescribeVodDomainSrcBpsDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainSrcBpsDataRequest) SetEndTime(v string) *DescribeVodDomainSrcBpsDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainSrcBpsDataRequest) SetInterval(v string) *DescribeVodDomainSrcBpsDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeVodDomainSrcBpsDataRequest) SetOwnerId(v int64) *DescribeVodDomainSrcBpsDataRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodDomainSrcBpsDataRequest) SetStartTime(v string) *DescribeVodDomainSrcBpsDataRequest {
	s.StartTime = &v
	return s
}

type DescribeVodDomainSrcBpsDataResponseBody struct {
	DataInterval          *string                                                       `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	DomainName            *string                                                       `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	EndTime               *string                                                       `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	RequestId             *string                                                       `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	SrcBpsDataPerInterval *DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerInterval `json:"SrcBpsDataPerInterval,omitempty" xml:"SrcBpsDataPerInterval,omitempty" type:"Struct"`
	StartTime             *string                                                       `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainSrcBpsDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainSrcBpsDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainSrcBpsDataResponseBody) SetDataInterval(v string) *DescribeVodDomainSrcBpsDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeVodDomainSrcBpsDataResponseBody) SetDomainName(v string) *DescribeVodDomainSrcBpsDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainSrcBpsDataResponseBody) SetEndTime(v string) *DescribeVodDomainSrcBpsDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainSrcBpsDataResponseBody) SetRequestId(v string) *DescribeVodDomainSrcBpsDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVodDomainSrcBpsDataResponseBody) SetSrcBpsDataPerInterval(v *DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerInterval) *DescribeVodDomainSrcBpsDataResponseBody {
	s.SrcBpsDataPerInterval = v
	return s
}

func (s *DescribeVodDomainSrcBpsDataResponseBody) SetStartTime(v string) *DescribeVodDomainSrcBpsDataResponseBody {
	s.StartTime = &v
	return s
}

type DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerInterval struct {
	DataModule []*DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerInterval) SetDataModule(v []*DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule) *DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule struct {
	HttpsValue *string `json:"HttpsValue,omitempty" xml:"HttpsValue,omitempty"`
	TimeStamp  *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	Value      *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule) SetHttpsValue(v string) *DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule {
	s.HttpsValue = &v
	return s
}

func (s *DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule) SetValue(v string) *DescribeVodDomainSrcBpsDataResponseBodySrcBpsDataPerIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeVodDomainSrcBpsDataResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVodDomainSrcBpsDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVodDomainSrcBpsDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainSrcBpsDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainSrcBpsDataResponse) SetHeaders(v map[string]*string) *DescribeVodDomainSrcBpsDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodDomainSrcBpsDataResponse) SetStatusCode(v int32) *DescribeVodDomainSrcBpsDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodDomainSrcBpsDataResponse) SetBody(v *DescribeVodDomainSrcBpsDataResponseBody) *DescribeVodDomainSrcBpsDataResponse {
	s.Body = v
	return s
}

type DescribeVodDomainSrcTrafficDataRequest struct {
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	EndTime    *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	Interval   *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	OwnerId    *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	StartTime  *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainSrcTrafficDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainSrcTrafficDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainSrcTrafficDataRequest) SetDomainName(v string) *DescribeVodDomainSrcTrafficDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainSrcTrafficDataRequest) SetEndTime(v string) *DescribeVodDomainSrcTrafficDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainSrcTrafficDataRequest) SetInterval(v string) *DescribeVodDomainSrcTrafficDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeVodDomainSrcTrafficDataRequest) SetOwnerId(v int64) *DescribeVodDomainSrcTrafficDataRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodDomainSrcTrafficDataRequest) SetStartTime(v string) *DescribeVodDomainSrcTrafficDataRequest {
	s.StartTime = &v
	return s
}

type DescribeVodDomainSrcTrafficDataResponseBody struct {
	DataInterval              *string                                                               `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	DomainName                *string                                                               `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	EndTime                   *string                                                               `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	RequestId                 *string                                                               `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	SrcTrafficDataPerInterval *DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval `json:"SrcTrafficDataPerInterval,omitempty" xml:"SrcTrafficDataPerInterval,omitempty" type:"Struct"`
	StartTime                 *string                                                               `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	TotalTraffic              *string                                                               `json:"TotalTraffic,omitempty" xml:"TotalTraffic,omitempty"`
}

func (s DescribeVodDomainSrcTrafficDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainSrcTrafficDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainSrcTrafficDataResponseBody) SetDataInterval(v string) *DescribeVodDomainSrcTrafficDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeVodDomainSrcTrafficDataResponseBody) SetDomainName(v string) *DescribeVodDomainSrcTrafficDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainSrcTrafficDataResponseBody) SetEndTime(v string) *DescribeVodDomainSrcTrafficDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainSrcTrafficDataResponseBody) SetRequestId(v string) *DescribeVodDomainSrcTrafficDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVodDomainSrcTrafficDataResponseBody) SetSrcTrafficDataPerInterval(v *DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval) *DescribeVodDomainSrcTrafficDataResponseBody {
	s.SrcTrafficDataPerInterval = v
	return s
}

func (s *DescribeVodDomainSrcTrafficDataResponseBody) SetStartTime(v string) *DescribeVodDomainSrcTrafficDataResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeVodDomainSrcTrafficDataResponseBody) SetTotalTraffic(v string) *DescribeVodDomainSrcTrafficDataResponseBody {
	s.TotalTraffic = &v
	return s
}

type DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval struct {
	DataModule []*DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval) SetDataModule(v []*DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule) *DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule struct {
	HttpsValue *string `json:"HttpsValue,omitempty" xml:"HttpsValue,omitempty"`
	TimeStamp  *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	Value      *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule) SetHttpsValue(v string) *DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule {
	s.HttpsValue = &v
	return s
}

func (s *DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule) SetValue(v string) *DescribeVodDomainSrcTrafficDataResponseBodySrcTrafficDataPerIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeVodDomainSrcTrafficDataResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVodDomainSrcTrafficDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVodDomainSrcTrafficDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainSrcTrafficDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainSrcTrafficDataResponse) SetHeaders(v map[string]*string) *DescribeVodDomainSrcTrafficDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodDomainSrcTrafficDataResponse) SetStatusCode(v int32) *DescribeVodDomainSrcTrafficDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodDomainSrcTrafficDataResponse) SetBody(v *DescribeVodDomainSrcTrafficDataResponseBody) *DescribeVodDomainSrcTrafficDataResponse {
	s.Body = v
	return s
}

type DescribeVodDomainTrafficDataRequest struct {
	// The accelerated domain name that you want to query. If you leave this parameter empty, the merged data of all your accelerated domain names is returned. Separate multiple domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The interval at which to return data. Unit: seconds. Valid values: **300**, **3600**, and **86400**. If you leave this parameter empty or specify an invalid value, the default value is used.
	//
	// *   Valid values if the time range to query is less than 3 days: **300**, **3600**, and **86400**. Default value: 300.
	// *   Valid values if the time range to query is 3 to less than 31 days: **3600** and **86400**. Default value: 3600.
	// *   Valid value if the time range to query is 31 to 90 days: **86400**.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The name of the Internet service provider (ISP). If you leave this parameter empty, all ISPs are queried.
	IspNameEn *string `json:"IspNameEn,omitempty" xml:"IspNameEn,omitempty"`
	// The name of the region. If you leave this parameter empty, all regions are queried. You can specify only the China (Shanghai) region.
	LocationNameEn *string `json:"LocationNameEn,omitempty" xml:"LocationNameEn,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// > The minimum time granularity to query data is 5 minutes. If you leave this parameter empty, the data in the last 24 hours is queried.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s DescribeVodDomainTrafficDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainTrafficDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainTrafficDataRequest) SetDomainName(v string) *DescribeVodDomainTrafficDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainTrafficDataRequest) SetEndTime(v string) *DescribeVodDomainTrafficDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainTrafficDataRequest) SetInterval(v string) *DescribeVodDomainTrafficDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeVodDomainTrafficDataRequest) SetIspNameEn(v string) *DescribeVodDomainTrafficDataRequest {
	s.IspNameEn = &v
	return s
}

func (s *DescribeVodDomainTrafficDataRequest) SetLocationNameEn(v string) *DescribeVodDomainTrafficDataRequest {
	s.LocationNameEn = &v
	return s
}

func (s *DescribeVodDomainTrafficDataRequest) SetOwnerId(v int64) *DescribeVodDomainTrafficDataRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodDomainTrafficDataRequest) SetStartTime(v string) *DescribeVodDomainTrafficDataRequest {
	s.StartTime = &v
	return s
}

type DescribeVodDomainTrafficDataResponseBody struct {
	// The time interval between the entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range during which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The total amount of network traffic.
	TotalTraffic *string `json:"TotalTraffic,omitempty" xml:"TotalTraffic,omitempty"`
	// The network traffic that was collected at each interval.
	TrafficDataPerInterval *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerInterval `json:"TrafficDataPerInterval,omitempty" xml:"TrafficDataPerInterval,omitempty" type:"Struct"`
}

func (s DescribeVodDomainTrafficDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainTrafficDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainTrafficDataResponseBody) SetDataInterval(v string) *DescribeVodDomainTrafficDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeVodDomainTrafficDataResponseBody) SetDomainName(v string) *DescribeVodDomainTrafficDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainTrafficDataResponseBody) SetEndTime(v string) *DescribeVodDomainTrafficDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainTrafficDataResponseBody) SetRequestId(v string) *DescribeVodDomainTrafficDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVodDomainTrafficDataResponseBody) SetStartTime(v string) *DescribeVodDomainTrafficDataResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeVodDomainTrafficDataResponseBody) SetTotalTraffic(v string) *DescribeVodDomainTrafficDataResponseBody {
	s.TotalTraffic = &v
	return s
}

func (s *DescribeVodDomainTrafficDataResponseBody) SetTrafficDataPerInterval(v *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerInterval) *DescribeVodDomainTrafficDataResponseBody {
	s.TrafficDataPerInterval = v
	return s
}

type DescribeVodDomainTrafficDataResponseBodyTrafficDataPerInterval struct {
	DataModule []*DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainTrafficDataResponseBodyTrafficDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainTrafficDataResponseBodyTrafficDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerInterval) SetDataModule(v []*DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule struct {
	// The amount of network traffic in the Chinese mainland. Unit: bytes.
	DomesticValue *string `json:"DomesticValue,omitempty" xml:"DomesticValue,omitempty"`
	// The amount of HTTPS network traffic on points of presence (POPs) in the Chinese mainland. Unit: bytes.
	HttpsDomesticValue *string `json:"HttpsDomesticValue,omitempty" xml:"HttpsDomesticValue,omitempty"`
	// The amount of HTTPS network traffic on POPs outside the Chinese mainland. Unit: bytes.
	HttpsOverseasValue *string `json:"HttpsOverseasValue,omitempty" xml:"HttpsOverseasValue,omitempty"`
	// The total amount of HTTPS network traffic on POPs. Unit: bytes.
	HttpsValue *string `json:"HttpsValue,omitempty" xml:"HttpsValue,omitempty"`
	// The amount of network traffic outside the Chinese mainland. Unit: bytes.
	OverseasValue *string `json:"OverseasValue,omitempty" xml:"OverseasValue,omitempty"`
	// The timestamp of the returned data. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The total amount of network traffic. Unit: bytes.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetDomesticValue(v string) *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.DomesticValue = &v
	return s
}

func (s *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetHttpsDomesticValue(v string) *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.HttpsDomesticValue = &v
	return s
}

func (s *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetHttpsOverseasValue(v string) *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.HttpsOverseasValue = &v
	return s
}

func (s *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetHttpsValue(v string) *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.HttpsValue = &v
	return s
}

func (s *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetOverseasValue(v string) *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.OverseasValue = &v
	return s
}

func (s *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule) SetValue(v string) *DescribeVodDomainTrafficDataResponseBodyTrafficDataPerIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeVodDomainTrafficDataResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVodDomainTrafficDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVodDomainTrafficDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainTrafficDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainTrafficDataResponse) SetHeaders(v map[string]*string) *DescribeVodDomainTrafficDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodDomainTrafficDataResponse) SetStatusCode(v int32) *DescribeVodDomainTrafficDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodDomainTrafficDataResponse) SetBody(v *DescribeVodDomainTrafficDataResponseBody) *DescribeVodDomainTrafficDataResponse {
	s.Body = v
	return s
}

type DescribeVodDomainUsageDataRequest struct {
	// The region where you want to query data. Default value: CN. Valid values:
	//
	// *   **CN**: Chinese mainland
	// *   **OverSeas**: outside the Chinese mainland
	Area *string `json:"Area,omitempty" xml:"Area,omitempty"`
	// The accelerated domain name. If you leave this parameter empty, the merged data of all your accelerated domain names is returned. Separate multiple accelerated domain names with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The type of the data to return. Valid values:
	//
	// *   **bps**: bandwidth
	// *   **traf**: traffic
	Field *string `json:"Field,omitempty" xml:"Field,omitempty"`
	// The time interval between the data entries to return. Unit: seconds. Valid values: **300** (5 minutes), **3600** (1 hour), and **86400** (1 day).
	//
	// *   If **Interval** is set to **300**, you can query usage data in the last six months. The maximum time range per query that can be specified is three days.
	// *   If **Interval** is set to **3600** or **86400**, you can query usage data of the previous year.
	// *   If you do not set the **Interval** parameter, the maximum time range that you can query is one month. If you specify a time range of 1 to 3 days, the time interval between the entries that are returned is 1 hour. If you specify a time range of at least 4 days, the time interval between the entries that are returned is 1 day.
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	OwnerId  *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The type of content that you want to query. Valid values:
	//
	// *   **static**: static content
	// *   **dynamic**: dynamic requests
	// *   **all**: all content
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeVodDomainUsageDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainUsageDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainUsageDataRequest) SetArea(v string) *DescribeVodDomainUsageDataRequest {
	s.Area = &v
	return s
}

func (s *DescribeVodDomainUsageDataRequest) SetDomainName(v string) *DescribeVodDomainUsageDataRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainUsageDataRequest) SetEndTime(v string) *DescribeVodDomainUsageDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainUsageDataRequest) SetField(v string) *DescribeVodDomainUsageDataRequest {
	s.Field = &v
	return s
}

func (s *DescribeVodDomainUsageDataRequest) SetInterval(v string) *DescribeVodDomainUsageDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeVodDomainUsageDataRequest) SetOwnerId(v int64) *DescribeVodDomainUsageDataRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodDomainUsageDataRequest) SetStartTime(v string) *DescribeVodDomainUsageDataRequest {
	s.StartTime = &v
	return s
}

func (s *DescribeVodDomainUsageDataRequest) SetType(v string) *DescribeVodDomainUsageDataRequest {
	s.Type = &v
	return s
}

type DescribeVodDomainUsageDataResponseBody struct {
	// The billable region where the data was collected.
	Area *string `json:"Area,omitempty" xml:"Area,omitempty"`
	// The time interval between the entries returned. Unit: seconds.
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The accelerated domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range during which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The start of the time range during which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The type of content returned. Valid values:
	//
	// *   **static**: static content
	// *   **dynamic**: dynamic requests
	// *   **all**: all content
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The traffic or bandwidth data returned at each interval.
	UsageDataPerInterval *DescribeVodDomainUsageDataResponseBodyUsageDataPerInterval `json:"UsageDataPerInterval,omitempty" xml:"UsageDataPerInterval,omitempty" type:"Struct"`
}

func (s DescribeVodDomainUsageDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainUsageDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainUsageDataResponseBody) SetArea(v string) *DescribeVodDomainUsageDataResponseBody {
	s.Area = &v
	return s
}

func (s *DescribeVodDomainUsageDataResponseBody) SetDataInterval(v string) *DescribeVodDomainUsageDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeVodDomainUsageDataResponseBody) SetDomainName(v string) *DescribeVodDomainUsageDataResponseBody {
	s.DomainName = &v
	return s
}

func (s *DescribeVodDomainUsageDataResponseBody) SetEndTime(v string) *DescribeVodDomainUsageDataResponseBody {
	s.EndTime = &v
	return s
}

func (s *DescribeVodDomainUsageDataResponseBody) SetRequestId(v string) *DescribeVodDomainUsageDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVodDomainUsageDataResponseBody) SetStartTime(v string) *DescribeVodDomainUsageDataResponseBody {
	s.StartTime = &v
	return s
}

func (s *DescribeVodDomainUsageDataResponseBody) SetType(v string) *DescribeVodDomainUsageDataResponseBody {
	s.Type = &v
	return s
}

func (s *DescribeVodDomainUsageDataResponseBody) SetUsageDataPerInterval(v *DescribeVodDomainUsageDataResponseBodyUsageDataPerInterval) *DescribeVodDomainUsageDataResponseBody {
	s.UsageDataPerInterval = v
	return s
}

type DescribeVodDomainUsageDataResponseBodyUsageDataPerInterval struct {
	DataModule []*DescribeVodDomainUsageDataResponseBodyUsageDataPerIntervalDataModule `json:"DataModule,omitempty" xml:"DataModule,omitempty" type:"Repeated"`
}

func (s DescribeVodDomainUsageDataResponseBodyUsageDataPerInterval) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainUsageDataResponseBodyUsageDataPerInterval) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainUsageDataResponseBodyUsageDataPerInterval) SetDataModule(v []*DescribeVodDomainUsageDataResponseBodyUsageDataPerIntervalDataModule) *DescribeVodDomainUsageDataResponseBodyUsageDataPerInterval {
	s.DataModule = v
	return s
}

type DescribeVodDomainUsageDataResponseBodyUsageDataPerIntervalDataModule struct {
	// The timestamp of the data returned. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
	// The traffic or bandwidth data. Unit: bit/s.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVodDomainUsageDataResponseBodyUsageDataPerIntervalDataModule) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainUsageDataResponseBodyUsageDataPerIntervalDataModule) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainUsageDataResponseBodyUsageDataPerIntervalDataModule) SetTimeStamp(v string) *DescribeVodDomainUsageDataResponseBodyUsageDataPerIntervalDataModule {
	s.TimeStamp = &v
	return s
}

func (s *DescribeVodDomainUsageDataResponseBodyUsageDataPerIntervalDataModule) SetValue(v string) *DescribeVodDomainUsageDataResponseBodyUsageDataPerIntervalDataModule {
	s.Value = &v
	return s
}

type DescribeVodDomainUsageDataResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVodDomainUsageDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVodDomainUsageDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodDomainUsageDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodDomainUsageDataResponse) SetHeaders(v map[string]*string) *DescribeVodDomainUsageDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodDomainUsageDataResponse) SetStatusCode(v int32) *DescribeVodDomainUsageDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodDomainUsageDataResponse) SetBody(v *DescribeVodDomainUsageDataResponseBody) *DescribeVodDomainUsageDataResponse {
	s.Body = v
	return s
}

type DescribeVodRefreshQuotaRequest struct {
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s DescribeVodRefreshQuotaRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodRefreshQuotaRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodRefreshQuotaRequest) SetOwnerId(v int64) *DescribeVodRefreshQuotaRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodRefreshQuotaRequest) SetSecurityToken(v string) *DescribeVodRefreshQuotaRequest {
	s.SecurityToken = &v
	return s
}

type DescribeVodRefreshQuotaResponseBody struct {
	// The remaining number of directories of files that can be refreshed on the current day.
	BlockQuota *string `json:"BlockQuota,omitempty" xml:"BlockQuota,omitempty"`
	// Queries the maximum number and remaining number of requests to refresh or prefetch files on the current day. You can prefetch files based on URLs and refresh files based on URLs or directories.
	DirQuota *string `json:"DirQuota,omitempty" xml:"DirQuota,omitempty"`
	// The ID of the request.
	DirRemain    *string `json:"DirRemain,omitempty" xml:"DirRemain,omitempty"`
	PreloadQuota *string `json:"PreloadQuota,omitempty" xml:"PreloadQuota,omitempty"`
	// The remaining number of OSS buckets that can be refreshed on the current day.
	PreloadRemain *string `json:"PreloadRemain,omitempty" xml:"PreloadRemain,omitempty"`
	// The maximum number of directories of files that can be refreshed each day.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	UrlQuota  *string `json:"UrlQuota,omitempty" xml:"UrlQuota,omitempty"`
	// The operation that you want to perform. Set the value to **DescribeVodRefreshQuota**.
	UrlRemain *string `json:"UrlRemain,omitempty" xml:"UrlRemain,omitempty"`
	// The maximum number of URLs of files that can be prefetched each day.
	BlockRemain *string `json:"blockRemain,omitempty" xml:"blockRemain,omitempty"`
}

func (s DescribeVodRefreshQuotaResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodRefreshQuotaResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodRefreshQuotaResponseBody) SetBlockQuota(v string) *DescribeVodRefreshQuotaResponseBody {
	s.BlockQuota = &v
	return s
}

func (s *DescribeVodRefreshQuotaResponseBody) SetDirQuota(v string) *DescribeVodRefreshQuotaResponseBody {
	s.DirQuota = &v
	return s
}

func (s *DescribeVodRefreshQuotaResponseBody) SetDirRemain(v string) *DescribeVodRefreshQuotaResponseBody {
	s.DirRemain = &v
	return s
}

func (s *DescribeVodRefreshQuotaResponseBody) SetPreloadQuota(v string) *DescribeVodRefreshQuotaResponseBody {
	s.PreloadQuota = &v
	return s
}

func (s *DescribeVodRefreshQuotaResponseBody) SetPreloadRemain(v string) *DescribeVodRefreshQuotaResponseBody {
	s.PreloadRemain = &v
	return s
}

func (s *DescribeVodRefreshQuotaResponseBody) SetRequestId(v string) *DescribeVodRefreshQuotaResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVodRefreshQuotaResponseBody) SetUrlQuota(v string) *DescribeVodRefreshQuotaResponseBody {
	s.UrlQuota = &v
	return s
}

func (s *DescribeVodRefreshQuotaResponseBody) SetUrlRemain(v string) *DescribeVodRefreshQuotaResponseBody {
	s.UrlRemain = &v
	return s
}

func (s *DescribeVodRefreshQuotaResponseBody) SetBlockRemain(v string) *DescribeVodRefreshQuotaResponseBody {
	s.BlockRemain = &v
	return s
}

type DescribeVodRefreshQuotaResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVodRefreshQuotaResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVodRefreshQuotaResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodRefreshQuotaResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodRefreshQuotaResponse) SetHeaders(v map[string]*string) *DescribeVodRefreshQuotaResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodRefreshQuotaResponse) SetStatusCode(v int32) *DescribeVodRefreshQuotaResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodRefreshQuotaResponse) SetBody(v *DescribeVodRefreshQuotaResponseBody) *DescribeVodRefreshQuotaResponse {
	s.Body = v
	return s
}

type DescribeVodRefreshTasksRequest struct {
	// The domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The path of the object. The path is used as a condition for exact matching.
	ObjectPath *string `json:"ObjectPath,omitempty" xml:"ObjectPath,omitempty"`
	// The type of the task. Valid values:
	//
	// *   **file**: refreshes one or more files.
	// *   **directory**: refreshes files in the specified directories.
	// *   **preload**: prefetches one or more files.
	//
	// > If you specify the DomainName or Status parameter, you must also specify the ObjectType parameter.
	ObjectType *string `json:"ObjectType,omitempty" xml:"ObjectType,omitempty"`
	OwnerId    *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: **20**. Maximum value: **50**.
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	//
	// > You can query data that is collected in the last three days.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The status of the task. Valid values:
	//
	// *   **Complete**: The task is complete.
	// *   **Refreshing**: The task is in progress.
	// *   **Failed**: The task failed.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the task that you want to query.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s DescribeVodRefreshTasksRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodRefreshTasksRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodRefreshTasksRequest) SetDomainName(v string) *DescribeVodRefreshTasksRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodRefreshTasksRequest) SetEndTime(v string) *DescribeVodRefreshTasksRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodRefreshTasksRequest) SetObjectPath(v string) *DescribeVodRefreshTasksRequest {
	s.ObjectPath = &v
	return s
}

func (s *DescribeVodRefreshTasksRequest) SetObjectType(v string) *DescribeVodRefreshTasksRequest {
	s.ObjectType = &v
	return s
}

func (s *DescribeVodRefreshTasksRequest) SetOwnerId(v int64) *DescribeVodRefreshTasksRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodRefreshTasksRequest) SetPageNumber(v int32) *DescribeVodRefreshTasksRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeVodRefreshTasksRequest) SetPageSize(v int32) *DescribeVodRefreshTasksRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeVodRefreshTasksRequest) SetSecurityToken(v string) *DescribeVodRefreshTasksRequest {
	s.SecurityToken = &v
	return s
}

func (s *DescribeVodRefreshTasksRequest) SetStartTime(v string) *DescribeVodRefreshTasksRequest {
	s.StartTime = &v
	return s
}

func (s *DescribeVodRefreshTasksRequest) SetStatus(v string) *DescribeVodRefreshTasksRequest {
	s.Status = &v
	return s
}

func (s *DescribeVodRefreshTasksRequest) SetTaskId(v string) *DescribeVodRefreshTasksRequest {
	s.TaskId = &v
	return s
}

type DescribeVodRefreshTasksResponseBody struct {
	// The page number of the returned page.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the returned tasks.
	Tasks *DescribeVodRefreshTasksResponseBodyTasks `json:"Tasks,omitempty" xml:"Tasks,omitempty" type:"Struct"`
	// The total number of entries returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeVodRefreshTasksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodRefreshTasksResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodRefreshTasksResponseBody) SetPageNumber(v int64) *DescribeVodRefreshTasksResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeVodRefreshTasksResponseBody) SetPageSize(v int64) *DescribeVodRefreshTasksResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeVodRefreshTasksResponseBody) SetRequestId(v string) *DescribeVodRefreshTasksResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVodRefreshTasksResponseBody) SetTasks(v *DescribeVodRefreshTasksResponseBodyTasks) *DescribeVodRefreshTasksResponseBody {
	s.Tasks = v
	return s
}

func (s *DescribeVodRefreshTasksResponseBody) SetTotalCount(v int64) *DescribeVodRefreshTasksResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeVodRefreshTasksResponseBodyTasks struct {
	Task []*DescribeVodRefreshTasksResponseBodyTasksTask `json:"Task,omitempty" xml:"Task,omitempty" type:"Repeated"`
}

func (s DescribeVodRefreshTasksResponseBodyTasks) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodRefreshTasksResponseBodyTasks) GoString() string {
	return s.String()
}

func (s *DescribeVodRefreshTasksResponseBodyTasks) SetTask(v []*DescribeVodRefreshTasksResponseBodyTasksTask) *DescribeVodRefreshTasksResponseBodyTasks {
	s.Task = v
	return s
}

type DescribeVodRefreshTasksResponseBodyTasksTask struct {
	// The time when the task was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The type of error returned when the refresh or prefetch task failed. Valid values: Valid values:
	//
	// *   **Internal Error**: An internal error occurred.
	// *   **Origin Timeout**: The response from the origin server timed out.
	// *   **Origin Return StatusCode 5XX**: The origin server returned an HTTP status code 5xx.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The URL of the object refreshed.
	ObjectPath *string `json:"ObjectPath,omitempty" xml:"ObjectPath,omitempty"`
	// The type of the task. Default value: file. Valid values:
	//
	// *   **file**: refreshes one or more files.
	// *   **directory**: refreshes files in the specified directory.
	// *   **preload**: prefetches one or more files.
	ObjectType *string `json:"ObjectType,omitempty" xml:"ObjectType,omitempty"`
	// The progress of the task in percentage.
	Process *string `json:"Process,omitempty" xml:"Process,omitempty"`
	// The status of the task. Valid values:
	//
	// *   **Complete**: The task is complete.
	// *   **Refreshing**: The task is in progress.
	// *   **Failed**: The task failed.
	// *   **Pending**: The task is pending.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s DescribeVodRefreshTasksResponseBodyTasksTask) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodRefreshTasksResponseBodyTasksTask) GoString() string {
	return s.String()
}

func (s *DescribeVodRefreshTasksResponseBodyTasksTask) SetCreationTime(v string) *DescribeVodRefreshTasksResponseBodyTasksTask {
	s.CreationTime = &v
	return s
}

func (s *DescribeVodRefreshTasksResponseBodyTasksTask) SetDescription(v string) *DescribeVodRefreshTasksResponseBodyTasksTask {
	s.Description = &v
	return s
}

func (s *DescribeVodRefreshTasksResponseBodyTasksTask) SetObjectPath(v string) *DescribeVodRefreshTasksResponseBodyTasksTask {
	s.ObjectPath = &v
	return s
}

func (s *DescribeVodRefreshTasksResponseBodyTasksTask) SetObjectType(v string) *DescribeVodRefreshTasksResponseBodyTasksTask {
	s.ObjectType = &v
	return s
}

func (s *DescribeVodRefreshTasksResponseBodyTasksTask) SetProcess(v string) *DescribeVodRefreshTasksResponseBodyTasksTask {
	s.Process = &v
	return s
}

func (s *DescribeVodRefreshTasksResponseBodyTasksTask) SetStatus(v string) *DescribeVodRefreshTasksResponseBodyTasksTask {
	s.Status = &v
	return s
}

func (s *DescribeVodRefreshTasksResponseBodyTasksTask) SetTaskId(v string) *DescribeVodRefreshTasksResponseBodyTasksTask {
	s.TaskId = &v
	return s
}

type DescribeVodRefreshTasksResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVodRefreshTasksResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVodRefreshTasksResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodRefreshTasksResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodRefreshTasksResponse) SetHeaders(v map[string]*string) *DescribeVodRefreshTasksResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodRefreshTasksResponse) SetStatusCode(v int32) *DescribeVodRefreshTasksResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodRefreshTasksResponse) SetBody(v *DescribeVodRefreshTasksResponseBody) *DescribeVodRefreshTasksResponse {
	s.Body = v
	return s
}

type DescribeVodStorageDataRequest struct {
	// The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerId *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region in which you want to query storage data. If you leave this parameter empty, data in all regions is returned. Separate multiple regions with commas (,). Valid values:
	//
	// *   **cn-shanghai**: China (Shanghai)
	// *   **cn-beijing**: China (Beijing)
	// *   **eu-central-1**: Germany (Frankfurt)
	// *   **ap-southeast-1**: Singapore
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The name of the Object Storage Service (OSS) bucket. If you leave this parameter empty, data of all buckets is returned. Separate multiple bucket names with commas (,).
	Storage *string `json:"Storage,omitempty" xml:"Storage,omitempty"`
	// The storage type. Set the value to **OSS**.
	StorageType *string `json:"StorageType,omitempty" xml:"StorageType,omitempty"`
}

func (s DescribeVodStorageDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodStorageDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodStorageDataRequest) SetEndTime(v string) *DescribeVodStorageDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodStorageDataRequest) SetOwnerId(v int64) *DescribeVodStorageDataRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodStorageDataRequest) SetRegion(v string) *DescribeVodStorageDataRequest {
	s.Region = &v
	return s
}

func (s *DescribeVodStorageDataRequest) SetStartTime(v string) *DescribeVodStorageDataRequest {
	s.StartTime = &v
	return s
}

func (s *DescribeVodStorageDataRequest) SetStorage(v string) *DescribeVodStorageDataRequest {
	s.Storage = &v
	return s
}

func (s *DescribeVodStorageDataRequest) SetStorageType(v string) *DescribeVodStorageDataRequest {
	s.StorageType = &v
	return s
}

type DescribeVodStorageDataResponseBody struct {
	// The time granularity at which the data was queried. Valid values:
	//
	// *   **hour**
	// *   **day**
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The storage usage data returned.
	StorageData *DescribeVodStorageDataResponseBodyStorageData `json:"StorageData,omitempty" xml:"StorageData,omitempty" type:"Struct"`
}

func (s DescribeVodStorageDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodStorageDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodStorageDataResponseBody) SetDataInterval(v string) *DescribeVodStorageDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeVodStorageDataResponseBody) SetRequestId(v string) *DescribeVodStorageDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVodStorageDataResponseBody) SetStorageData(v *DescribeVodStorageDataResponseBodyStorageData) *DescribeVodStorageDataResponseBody {
	s.StorageData = v
	return s
}

type DescribeVodStorageDataResponseBodyStorageData struct {
	StorageDataItem []*DescribeVodStorageDataResponseBodyStorageDataStorageDataItem `json:"StorageDataItem,omitempty" xml:"StorageDataItem,omitempty" type:"Repeated"`
}

func (s DescribeVodStorageDataResponseBodyStorageData) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodStorageDataResponseBodyStorageData) GoString() string {
	return s.String()
}

func (s *DescribeVodStorageDataResponseBodyStorageData) SetStorageDataItem(v []*DescribeVodStorageDataResponseBodyStorageDataStorageDataItem) *DescribeVodStorageDataResponseBodyStorageData {
	s.StorageDataItem = v
	return s
}

type DescribeVodStorageDataResponseBodyStorageDataStorageDataItem struct {
	// The outbound traffic. Unit: bytes. The outbound traffic is generated when videos are directly downloaded or played from OSS buckets without Alibaba Cloud CDN acceleration.
	NetworkOut *string `json:"NetworkOut,omitempty" xml:"NetworkOut,omitempty"`
	// The detailed usage data of storage-related resources. Unit: bytes.
	StorageUtilization *string `json:"StorageUtilization,omitempty" xml:"StorageUtilization,omitempty"`
	// The timestamp of the returned data. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeVodStorageDataResponseBodyStorageDataStorageDataItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodStorageDataResponseBodyStorageDataStorageDataItem) GoString() string {
	return s.String()
}

func (s *DescribeVodStorageDataResponseBodyStorageDataStorageDataItem) SetNetworkOut(v string) *DescribeVodStorageDataResponseBodyStorageDataStorageDataItem {
	s.NetworkOut = &v
	return s
}

func (s *DescribeVodStorageDataResponseBodyStorageDataStorageDataItem) SetStorageUtilization(v string) *DescribeVodStorageDataResponseBodyStorageDataStorageDataItem {
	s.StorageUtilization = &v
	return s
}

func (s *DescribeVodStorageDataResponseBodyStorageDataStorageDataItem) SetTimeStamp(v string) *DescribeVodStorageDataResponseBodyStorageDataStorageDataItem {
	s.TimeStamp = &v
	return s
}

type DescribeVodStorageDataResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVodStorageDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVodStorageDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodStorageDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodStorageDataResponse) SetHeaders(v map[string]*string) *DescribeVodStorageDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodStorageDataResponse) SetStatusCode(v int32) *DescribeVodStorageDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodStorageDataResponse) SetBody(v *DescribeVodStorageDataResponseBody) *DescribeVodStorageDataResponse {
	s.Body = v
	return s
}

type DescribeVodTranscodeDataRequest struct {
	// The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The interval at which you want to query data. Valid values:
	//
	// *   **day**: days
	// *   **hour**: hours
	Interval *string `json:"Interval,omitempty" xml:"Interval,omitempty"`
	OwnerId  *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region in which you want to query data. If you leave this parameter empty, data in all regions is returned. Separate multiple regions with commas (,). Valid values:
	//
	// *   **cn-shanghai**: China (Shanghai)
	// *   **cn-beijing**: China (Beijing)
	// *   **eu-central-1**: Germany (Frankfurt)
	// *   **ap-southeast-1**: Singapore
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The transcoding specification. If you leave this parameter empty, data of all transcoding specifications is returned. Separate multiple transcoding specifications with commas (,). Valid values:
	//
	// *   **Audio**: audio transcoding
	// *   **Segmentation**: container format conversion
	// *   **H264.LD**, **H264.SD**, **H264.HD**, **H264.2K**, **H264.4K**, and more
	Specification *string `json:"Specification,omitempty" xml:"Specification,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The name of the Object Storage Service (OSS) bucket. If you leave this parameter empty, data of all buckets is returned. Separate multiple bucket names with commas (,).
	Storage *string `json:"Storage,omitempty" xml:"Storage,omitempty"`
}

func (s DescribeVodTranscodeDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodTranscodeDataRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodTranscodeDataRequest) SetEndTime(v string) *DescribeVodTranscodeDataRequest {
	s.EndTime = &v
	return s
}

func (s *DescribeVodTranscodeDataRequest) SetInterval(v string) *DescribeVodTranscodeDataRequest {
	s.Interval = &v
	return s
}

func (s *DescribeVodTranscodeDataRequest) SetOwnerId(v int64) *DescribeVodTranscodeDataRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodTranscodeDataRequest) SetRegion(v string) *DescribeVodTranscodeDataRequest {
	s.Region = &v
	return s
}

func (s *DescribeVodTranscodeDataRequest) SetSpecification(v string) *DescribeVodTranscodeDataRequest {
	s.Specification = &v
	return s
}

func (s *DescribeVodTranscodeDataRequest) SetStartTime(v string) *DescribeVodTranscodeDataRequest {
	s.StartTime = &v
	return s
}

func (s *DescribeVodTranscodeDataRequest) SetStorage(v string) *DescribeVodTranscodeDataRequest {
	s.Storage = &v
	return s
}

type DescribeVodTranscodeDataResponseBody struct {
	// The interval at which the data was queried. Valid values:
	//
	// *   **hour**
	// *   **day**
	DataInterval *string `json:"DataInterval,omitempty" xml:"DataInterval,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The transcoding statistics returned.
	TranscodeData *DescribeVodTranscodeDataResponseBodyTranscodeData `json:"TranscodeData,omitempty" xml:"TranscodeData,omitempty" type:"Struct"`
}

func (s DescribeVodTranscodeDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodTranscodeDataResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodTranscodeDataResponseBody) SetDataInterval(v string) *DescribeVodTranscodeDataResponseBody {
	s.DataInterval = &v
	return s
}

func (s *DescribeVodTranscodeDataResponseBody) SetRequestId(v string) *DescribeVodTranscodeDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVodTranscodeDataResponseBody) SetTranscodeData(v *DescribeVodTranscodeDataResponseBodyTranscodeData) *DescribeVodTranscodeDataResponseBody {
	s.TranscodeData = v
	return s
}

type DescribeVodTranscodeDataResponseBodyTranscodeData struct {
	TranscodeDataItem []*DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItem `json:"TranscodeDataItem,omitempty" xml:"TranscodeDataItem,omitempty" type:"Repeated"`
}

func (s DescribeVodTranscodeDataResponseBodyTranscodeData) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodTranscodeDataResponseBodyTranscodeData) GoString() string {
	return s.String()
}

func (s *DescribeVodTranscodeDataResponseBodyTranscodeData) SetTranscodeDataItem(v []*DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItem) *DescribeVodTranscodeDataResponseBodyTranscodeData {
	s.TranscodeDataItem = v
	return s
}

type DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItem struct {
	// The statistics on transcoding of different specifications.
	Data *DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The timestamp of the returned data. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	TimeStamp *string `json:"TimeStamp,omitempty" xml:"TimeStamp,omitempty"`
}

func (s DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItem) GoString() string {
	return s.String()
}

func (s *DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItem) SetData(v *DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemData) *DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItem {
	s.Data = v
	return s
}

func (s *DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItem) SetTimeStamp(v string) *DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItem {
	s.TimeStamp = &v
	return s
}

type DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemData struct {
	DataItem []*DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemDataDataItem `json:"DataItem,omitempty" xml:"DataItem,omitempty" type:"Repeated"`
}

func (s DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemData) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemData) GoString() string {
	return s.String()
}

func (s *DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemData) SetDataItem(v []*DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemDataDataItem) *DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemData {
	s.DataItem = v
	return s
}

type DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemDataDataItem struct {
	// The transcoding specification. Valid values:
	//
	// *   **Audio**: audio transcoding
	// *   **Segmentation**: container format conversion
	// *   **H264.LD, H264.SD, H264.HD, H264.2K, H264.4K, and more**
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The transcoding duration. Unit: seconds.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemDataDataItem) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemDataDataItem) GoString() string {
	return s.String()
}

func (s *DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemDataDataItem) SetName(v string) *DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemDataDataItem {
	s.Name = &v
	return s
}

func (s *DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemDataDataItem) SetValue(v string) *DescribeVodTranscodeDataResponseBodyTranscodeDataTranscodeDataItemDataDataItem {
	s.Value = &v
	return s
}

type DescribeVodTranscodeDataResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVodTranscodeDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVodTranscodeDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodTranscodeDataResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodTranscodeDataResponse) SetHeaders(v map[string]*string) *DescribeVodTranscodeDataResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodTranscodeDataResponse) SetStatusCode(v int32) *DescribeVodTranscodeDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodTranscodeDataResponse) SetBody(v *DescribeVodTranscodeDataResponseBody) *DescribeVodTranscodeDataResponse {
	s.Body = v
	return s
}

type DescribeVodUserDomainsRequest struct {
	// The search method. Valid values:
	//
	// *   **fuzzy_match**: fuzzy match. This is the default value.
	// *   **pre_match**: prefix match.
	// *   **suf_match**: suffix match.
	// *   **full_match**: exact match.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The remarks.
	DomainSearchType *string `json:"DomainSearchType,omitempty" xml:"DomainSearchType,omitempty"`
	// The value of tag N. Valid values of N: **1** to **20**.
	//
	// If you do not specify this parameter, all tag values are queried.
	DomainStatus *string `json:"DomainStatus,omitempty" xml:"DomainStatus,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The detailed information about each domain name for CDN. The returned information is displayed in the format that is specified by the PageData parameter.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The operation that you want to perform. Set the value to **DescribeVodUserDomains**.
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The number of entries to return on each page. Default value: **20**. Maximum value: **50**. Valid values: integers in the range of **1** to **50**.
	Tag []*DescribeVodUserDomainsRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeVodUserDomainsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodUserDomainsRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodUserDomainsRequest) SetDomainName(v string) *DescribeVodUserDomainsRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodUserDomainsRequest) SetDomainSearchType(v string) *DescribeVodUserDomainsRequest {
	s.DomainSearchType = &v
	return s
}

func (s *DescribeVodUserDomainsRequest) SetDomainStatus(v string) *DescribeVodUserDomainsRequest {
	s.DomainStatus = &v
	return s
}

func (s *DescribeVodUserDomainsRequest) SetOwnerId(v int64) *DescribeVodUserDomainsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeVodUserDomainsRequest) SetPageNumber(v int32) *DescribeVodUserDomainsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeVodUserDomainsRequest) SetPageSize(v int32) *DescribeVodUserDomainsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeVodUserDomainsRequest) SetSecurityToken(v string) *DescribeVodUserDomainsRequest {
	s.SecurityToken = &v
	return s
}

func (s *DescribeVodUserDomainsRequest) SetTag(v []*DescribeVodUserDomainsRequestTag) *DescribeVodUserDomainsRequest {
	s.Tag = v
	return s
}

type DescribeVodUserDomainsRequestTag struct {
	// The status of the domain name for CDN. Valid values:
	//
	// *   **online**: indicates that the domain name is enabled.
	// *   **offline**: indicates that the domain name is disabled.
	// *   **configuring**: indicates that the domain name is being configured.
	// *   **configure_failed**: indicates that the domain name failed to be configured.
	// *   **checking**: indicates that the domain name is under review.
	// *   **check_failed**: indicates that the domain name failed the review.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The canonical domain name that is assigned to the domain name for CDN.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeVodUserDomainsRequestTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodUserDomainsRequestTag) GoString() string {
	return s.String()
}

func (s *DescribeVodUserDomainsRequestTag) SetKey(v string) *DescribeVodUserDomainsRequestTag {
	s.Key = &v
	return s
}

func (s *DescribeVodUserDomainsRequestTag) SetValue(v string) *DescribeVodUserDomainsRequestTag {
	s.Value = &v
	return s
}

type DescribeVodUserDomainsResponseBody struct {
	// The status of the domain name. The value of this parameter is used as a condition to filter domain names. Value values:
	//
	// *   **online**: indicates that the domain name is enabled.
	// *   **offline**: indicates that the domain name is disabled.
	// *   **configuring**: indicates that the domain name is being configured.
	// *   **configure_failed**: indicates that the domain name failed to be configured.
	// *   **checking**: indicates that the domain name is under review.
	// *   **check_failed**: indicates that the domain name failed the review.
	Domains *DescribeVodUserDomainsResponseBodyDomains `json:"Domains,omitempty" xml:"Domains,omitempty" type:"Struct"`
	// The domain name. The value of this parameter is used as a filter condition for a fuzzy match.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The time when the domain name for CDN was added. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The number of the page to return.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether HTTPS is enabled.
	//
	// - **on**: indicates that HTTPS is enabled.
	// - **off**: indicates that HTTPS is disabled.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeVodUserDomainsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodUserDomainsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodUserDomainsResponseBody) SetDomains(v *DescribeVodUserDomainsResponseBodyDomains) *DescribeVodUserDomainsResponseBody {
	s.Domains = v
	return s
}

func (s *DescribeVodUserDomainsResponseBody) SetPageNumber(v int64) *DescribeVodUserDomainsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeVodUserDomainsResponseBody) SetPageSize(v int64) *DescribeVodUserDomainsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeVodUserDomainsResponseBody) SetRequestId(v string) *DescribeVodUserDomainsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeVodUserDomainsResponseBody) SetTotalCount(v int64) *DescribeVodUserDomainsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeVodUserDomainsResponseBodyDomains struct {
	PageData []*DescribeVodUserDomainsResponseBodyDomainsPageData `json:"PageData,omitempty" xml:"PageData,omitempty" type:"Repeated"`
}

func (s DescribeVodUserDomainsResponseBodyDomains) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodUserDomainsResponseBodyDomains) GoString() string {
	return s.String()
}

func (s *DescribeVodUserDomainsResponseBodyDomains) SetPageData(v []*DescribeVodUserDomainsResponseBodyDomainsPageData) *DescribeVodUserDomainsResponseBodyDomains {
	s.PageData = v
	return s
}

type DescribeVodUserDomainsResponseBodyDomainsPageData struct {
	// Queries the domain names for CDN within your Alibaba Cloud account. You can filter domain names by name or by state. When you filter domain names by name, a fuzzy match is supported.
	Cname *string `json:"Cname,omitempty" xml:"Cname,omitempty"`
	// The number of entries returned per page.
	Description  *string `json:"Description,omitempty" xml:"Description,omitempty"`
	DomainName   *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	DomainStatus *string `json:"DomainStatus,omitempty" xml:"DomainStatus,omitempty"`
	// The page number of the returned page.
	GmtCreated  *string `json:"GmtCreated,omitempty" xml:"GmtCreated,omitempty"`
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the request.
	Sandbox *string                                                   `json:"Sandbox,omitempty" xml:"Sandbox,omitempty"`
	Sources *DescribeVodUserDomainsResponseBodyDomainsPageDataSources `json:"Sources,omitempty" xml:"Sources,omitempty" type:"Struct"`
	// The key of tag N. Valid values of N: **1** to **20**.
	//
	// If you do not specify this parameter, all tag keys are queried.
	SslProtocol *string `json:"SslProtocol,omitempty" xml:"SslProtocol,omitempty"`
}

func (s DescribeVodUserDomainsResponseBodyDomainsPageData) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodUserDomainsResponseBodyDomainsPageData) GoString() string {
	return s.String()
}

func (s *DescribeVodUserDomainsResponseBodyDomainsPageData) SetCname(v string) *DescribeVodUserDomainsResponseBodyDomainsPageData {
	s.Cname = &v
	return s
}

func (s *DescribeVodUserDomainsResponseBodyDomainsPageData) SetDescription(v string) *DescribeVodUserDomainsResponseBodyDomainsPageData {
	s.Description = &v
	return s
}

func (s *DescribeVodUserDomainsResponseBodyDomainsPageData) SetDomainName(v string) *DescribeVodUserDomainsResponseBodyDomainsPageData {
	s.DomainName = &v
	return s
}

func (s *DescribeVodUserDomainsResponseBodyDomainsPageData) SetDomainStatus(v string) *DescribeVodUserDomainsResponseBodyDomainsPageData {
	s.DomainStatus = &v
	return s
}

func (s *DescribeVodUserDomainsResponseBodyDomainsPageData) SetGmtCreated(v string) *DescribeVodUserDomainsResponseBodyDomainsPageData {
	s.GmtCreated = &v
	return s
}

func (s *DescribeVodUserDomainsResponseBodyDomainsPageData) SetGmtModified(v string) *DescribeVodUserDomainsResponseBodyDomainsPageData {
	s.GmtModified = &v
	return s
}

func (s *DescribeVodUserDomainsResponseBodyDomainsPageData) SetSandbox(v string) *DescribeVodUserDomainsResponseBodyDomainsPageData {
	s.Sandbox = &v
	return s
}

func (s *DescribeVodUserDomainsResponseBodyDomainsPageData) SetSources(v *DescribeVodUserDomainsResponseBodyDomainsPageDataSources) *DescribeVodUserDomainsResponseBodyDomainsPageData {
	s.Sources = v
	return s
}

func (s *DescribeVodUserDomainsResponseBodyDomainsPageData) SetSslProtocol(v string) *DescribeVodUserDomainsResponseBodyDomainsPageData {
	s.SslProtocol = &v
	return s
}

type DescribeVodUserDomainsResponseBodyDomainsPageDataSources struct {
	Source []*DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource `json:"Source,omitempty" xml:"Source,omitempty" type:"Repeated"`
}

func (s DescribeVodUserDomainsResponseBodyDomainsPageDataSources) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodUserDomainsResponseBodyDomainsPageDataSources) GoString() string {
	return s.String()
}

func (s *DescribeVodUserDomainsResponseBodyDomainsPageDataSources) SetSource(v []*DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource) *DescribeVodUserDomainsResponseBodyDomainsPageDataSources {
	s.Source = v
	return s
}

type DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource struct {
	Content  *string `json:"Content,omitempty" xml:"Content,omitempty"`
	Port     *int32  `json:"Port,omitempty" xml:"Port,omitempty"`
	Priority *string `json:"Priority,omitempty" xml:"Priority,omitempty"`
	Type     *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource) GoString() string {
	return s.String()
}

func (s *DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource) SetContent(v string) *DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource {
	s.Content = &v
	return s
}

func (s *DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource) SetPort(v int32) *DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource {
	s.Port = &v
	return s
}

func (s *DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource) SetPriority(v string) *DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource {
	s.Priority = &v
	return s
}

func (s *DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource) SetType(v string) *DescribeVodUserDomainsResponseBodyDomainsPageDataSourcesSource {
	s.Type = &v
	return s
}

type DescribeVodUserDomainsResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVodUserDomainsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVodUserDomainsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodUserDomainsResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodUserDomainsResponse) SetHeaders(v map[string]*string) *DescribeVodUserDomainsResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodUserDomainsResponse) SetStatusCode(v int32) *DescribeVodUserDomainsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodUserDomainsResponse) SetBody(v *DescribeVodUserDomainsResponseBody) *DescribeVodUserDomainsResponse {
	s.Body = v
	return s
}

type DescribeVodVerifyContentRequest struct {
	// Queries the ownership verification content.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId    *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
}

func (s DescribeVodVerifyContentRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodVerifyContentRequest) GoString() string {
	return s.String()
}

func (s *DescribeVodVerifyContentRequest) SetDomainName(v string) *DescribeVodVerifyContentRequest {
	s.DomainName = &v
	return s
}

func (s *DescribeVodVerifyContentRequest) SetOwnerId(v int64) *DescribeVodVerifyContentRequest {
	s.OwnerId = &v
	return s
}

type DescribeVodVerifyContentResponseBody struct {
	Content   *string `json:"Content,omitempty" xml:"Content,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeVodVerifyContentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodVerifyContentResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeVodVerifyContentResponseBody) SetContent(v string) *DescribeVodVerifyContentResponseBody {
	s.Content = &v
	return s
}

func (s *DescribeVodVerifyContentResponseBody) SetRequestId(v string) *DescribeVodVerifyContentResponseBody {
	s.RequestId = &v
	return s
}

type DescribeVodVerifyContentResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeVodVerifyContentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeVodVerifyContentResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeVodVerifyContentResponse) GoString() string {
	return s.String()
}

func (s *DescribeVodVerifyContentResponse) SetHeaders(v map[string]*string) *DescribeVodVerifyContentResponse {
	s.Headers = v
	return s
}

func (s *DescribeVodVerifyContentResponse) SetStatusCode(v int32) *DescribeVodVerifyContentResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeVodVerifyContentResponse) SetBody(v *DescribeVodVerifyContentResponseBody) *DescribeVodVerifyContentResponse {
	s.Body = v
	return s
}

type DetachAppPolicyFromIdentityRequest struct {
	// The ID of the request.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the policy. Separate multiple policies with commas (,). Only system policies are supported.
	//
	// *   **VODAppFullAccess**: authorizes an identity to manage all resources in an application.
	// *   **VODAppReadOnlyAccess**: authorizes an identity to access all resources in an application in read-only mode.
	// *   **VODAppAdministratorAccess**: assigns the application administrator role to an identity.
	IdentityName *string `json:"IdentityName,omitempty" xml:"IdentityName,omitempty"`
	// The ID of the application. This parameter is optional when the PolicyNames parameter is set to VODAppAdministratorAccess. This parameter is required when the PolicyNames parameter is set to other values.
	//
	// *   Default value: **app-1000000**.
	// *   For more information, see [Overview](~~113600~~).
	IdentityType *string `json:"IdentityType,omitempty" xml:"IdentityType,omitempty"`
	// The operation that you want to perform. Set the value to **DetachAppPolicyFromIdentity**.
	PolicyNames *string `json:"PolicyNames,omitempty" xml:"PolicyNames,omitempty"`
}

func (s DetachAppPolicyFromIdentityRequest) String() string {
	return tea.Prettify(s)
}

func (s DetachAppPolicyFromIdentityRequest) GoString() string {
	return s.String()
}

func (s *DetachAppPolicyFromIdentityRequest) SetAppId(v string) *DetachAppPolicyFromIdentityRequest {
	s.AppId = &v
	return s
}

func (s *DetachAppPolicyFromIdentityRequest) SetIdentityName(v string) *DetachAppPolicyFromIdentityRequest {
	s.IdentityName = &v
	return s
}

func (s *DetachAppPolicyFromIdentityRequest) SetIdentityType(v string) *DetachAppPolicyFromIdentityRequest {
	s.IdentityType = &v
	return s
}

func (s *DetachAppPolicyFromIdentityRequest) SetPolicyNames(v string) *DetachAppPolicyFromIdentityRequest {
	s.PolicyNames = &v
	return s
}

type DetachAppPolicyFromIdentityResponseBody struct {
	FailedPolicyNames   []*string `json:"FailedPolicyNames,omitempty" xml:"FailedPolicyNames,omitempty" type:"Repeated"`
	NonExistPolicyNames []*string `json:"NonExistPolicyNames,omitempty" xml:"NonExistPolicyNames,omitempty" type:"Repeated"`
	// Revokes application permissions from the specified identity. The identity may a RAM user or RAM role.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DetachAppPolicyFromIdentityResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DetachAppPolicyFromIdentityResponseBody) GoString() string {
	return s.String()
}

func (s *DetachAppPolicyFromIdentityResponseBody) SetFailedPolicyNames(v []*string) *DetachAppPolicyFromIdentityResponseBody {
	s.FailedPolicyNames = v
	return s
}

func (s *DetachAppPolicyFromIdentityResponseBody) SetNonExistPolicyNames(v []*string) *DetachAppPolicyFromIdentityResponseBody {
	s.NonExistPolicyNames = v
	return s
}

func (s *DetachAppPolicyFromIdentityResponseBody) SetRequestId(v string) *DetachAppPolicyFromIdentityResponseBody {
	s.RequestId = &v
	return s
}

type DetachAppPolicyFromIdentityResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DetachAppPolicyFromIdentityResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DetachAppPolicyFromIdentityResponse) String() string {
	return tea.Prettify(s)
}

func (s DetachAppPolicyFromIdentityResponse) GoString() string {
	return s.String()
}

func (s *DetachAppPolicyFromIdentityResponse) SetHeaders(v map[string]*string) *DetachAppPolicyFromIdentityResponse {
	s.Headers = v
	return s
}

func (s *DetachAppPolicyFromIdentityResponse) SetStatusCode(v int32) *DetachAppPolicyFromIdentityResponse {
	s.StatusCode = &v
	return s
}

func (s *DetachAppPolicyFromIdentityResponse) SetBody(v *DetachAppPolicyFromIdentityResponseBody) *DetachAppPolicyFromIdentityResponse {
	s.Body = v
	return s
}

type GenerateKMSDataKeyRequest struct {
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GenerateKMSDataKeyRequest) String() string {
	return tea.Prettify(s)
}

func (s GenerateKMSDataKeyRequest) GoString() string {
	return s.String()
}

func (s *GenerateKMSDataKeyRequest) SetOwnerAccount(v string) *GenerateKMSDataKeyRequest {
	s.OwnerAccount = &v
	return s
}

func (s *GenerateKMSDataKeyRequest) SetOwnerId(v string) *GenerateKMSDataKeyRequest {
	s.OwnerId = &v
	return s
}

func (s *GenerateKMSDataKeyRequest) SetResourceOwnerAccount(v string) *GenerateKMSDataKeyRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GenerateKMSDataKeyRequest) SetResourceOwnerId(v string) *GenerateKMSDataKeyRequest {
	s.ResourceOwnerId = &v
	return s
}

type GenerateKMSDataKeyResponseBody struct {
	CiphertextBlob *string `json:"CiphertextBlob,omitempty" xml:"CiphertextBlob,omitempty"`
	KeyId          *string `json:"KeyId,omitempty" xml:"KeyId,omitempty"`
	Plaintext      *string `json:"Plaintext,omitempty" xml:"Plaintext,omitempty"`
	RequestId      *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GenerateKMSDataKeyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GenerateKMSDataKeyResponseBody) GoString() string {
	return s.String()
}

func (s *GenerateKMSDataKeyResponseBody) SetCiphertextBlob(v string) *GenerateKMSDataKeyResponseBody {
	s.CiphertextBlob = &v
	return s
}

func (s *GenerateKMSDataKeyResponseBody) SetKeyId(v string) *GenerateKMSDataKeyResponseBody {
	s.KeyId = &v
	return s
}

func (s *GenerateKMSDataKeyResponseBody) SetPlaintext(v string) *GenerateKMSDataKeyResponseBody {
	s.Plaintext = &v
	return s
}

func (s *GenerateKMSDataKeyResponseBody) SetRequestId(v string) *GenerateKMSDataKeyResponseBody {
	s.RequestId = &v
	return s
}

type GenerateKMSDataKeyResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GenerateKMSDataKeyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GenerateKMSDataKeyResponse) String() string {
	return tea.Prettify(s)
}

func (s GenerateKMSDataKeyResponse) GoString() string {
	return s.String()
}

func (s *GenerateKMSDataKeyResponse) SetHeaders(v map[string]*string) *GenerateKMSDataKeyResponse {
	s.Headers = v
	return s
}

func (s *GenerateKMSDataKeyResponse) SetStatusCode(v int32) *GenerateKMSDataKeyResponse {
	s.StatusCode = &v
	return s
}

func (s *GenerateKMSDataKeyResponse) SetBody(v *GenerateKMSDataKeyResponseBody) *GenerateKMSDataKeyResponse {
	s.Body = v
	return s
}

type GetAIImageJobsRequest struct {
	// The returned data.
	JobIds               *string `json:"JobIds,omitempty" xml:"JobIds,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GetAIImageJobsRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAIImageJobsRequest) GoString() string {
	return s.String()
}

func (s *GetAIImageJobsRequest) SetJobIds(v string) *GetAIImageJobsRequest {
	s.JobIds = &v
	return s
}

func (s *GetAIImageJobsRequest) SetOwnerAccount(v string) *GetAIImageJobsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *GetAIImageJobsRequest) SetOwnerId(v string) *GetAIImageJobsRequest {
	s.OwnerId = &v
	return s
}

func (s *GetAIImageJobsRequest) SetResourceOwnerAccount(v string) *GetAIImageJobsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GetAIImageJobsRequest) SetResourceOwnerId(v string) *GetAIImageJobsRequest {
	s.ResourceOwnerId = &v
	return s
}

type GetAIImageJobsResponseBody struct {
	// The time when the image AI processing job was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	AIImageJobList []*GetAIImageJobsResponseBodyAIImageJobList `json:"AIImageJobList,omitempty" xml:"AIImageJobList,omitempty" type:"Repeated"`
	// The information about the image AI processing job.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetAIImageJobsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAIImageJobsResponseBody) GoString() string {
	return s.String()
}

func (s *GetAIImageJobsResponseBody) SetAIImageJobList(v []*GetAIImageJobsResponseBodyAIImageJobList) *GetAIImageJobsResponseBody {
	s.AIImageJobList = v
	return s
}

func (s *GetAIImageJobsResponseBody) SetRequestId(v string) *GetAIImageJobsResponseBody {
	s.RequestId = &v
	return s
}

type GetAIImageJobsResponseBodyAIImageJobList struct {
	// The Object Storage Service (OSS) URL of the image file.
	//
	// > This parameter does not include the complete authentication information. To obtain the authentication information, you must generate a signed URL. Alternatively, you can call the [ListAIImage](~~ListAIImage~~) operation to obtain the image information.
	AIImageResult *string `json:"AIImageResult,omitempty" xml:"AIImageResult,omitempty"`
	// The user data.
	//
	// *   The value must be a JSON string.
	// *   The MessageCallback or Extend parameter is returned.
	// *   The value contains a maximum of 512 bytes.
	//
	// For more information, see the "UserData: specifies the custom configurations for media upload" section of the [Request parameters](~~86952~~) topic.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The ID of the image AI processing job. You can obtain the value of JobId from the response to the [SubmitAIImageJob](~~186922~~) operation.
	//
	// *   You can specify a maximum of 10 IDs.
	// *   Separate multiple IDs with commas (,).
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The ID of the image AI processing job.
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// Queries jobs of image AI processing.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The error code.
	Status         *string `json:"Status,omitempty" xml:"Status,omitempty"`
	TemplateConfig *string `json:"TemplateConfig,omitempty" xml:"TemplateConfig,omitempty"`
	TemplateId     *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The ID of the request.
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
	// The configurations of the AI template that was used to submit the job.
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s GetAIImageJobsResponseBodyAIImageJobList) String() string {
	return tea.Prettify(s)
}

func (s GetAIImageJobsResponseBodyAIImageJobList) GoString() string {
	return s.String()
}

func (s *GetAIImageJobsResponseBodyAIImageJobList) SetAIImageResult(v string) *GetAIImageJobsResponseBodyAIImageJobList {
	s.AIImageResult = &v
	return s
}

func (s *GetAIImageJobsResponseBodyAIImageJobList) SetCode(v string) *GetAIImageJobsResponseBodyAIImageJobList {
	s.Code = &v
	return s
}

func (s *GetAIImageJobsResponseBodyAIImageJobList) SetCreationTime(v string) *GetAIImageJobsResponseBodyAIImageJobList {
	s.CreationTime = &v
	return s
}

func (s *GetAIImageJobsResponseBodyAIImageJobList) SetJobId(v string) *GetAIImageJobsResponseBodyAIImageJobList {
	s.JobId = &v
	return s
}

func (s *GetAIImageJobsResponseBodyAIImageJobList) SetMessage(v string) *GetAIImageJobsResponseBodyAIImageJobList {
	s.Message = &v
	return s
}

func (s *GetAIImageJobsResponseBodyAIImageJobList) SetStatus(v string) *GetAIImageJobsResponseBodyAIImageJobList {
	s.Status = &v
	return s
}

func (s *GetAIImageJobsResponseBodyAIImageJobList) SetTemplateConfig(v string) *GetAIImageJobsResponseBodyAIImageJobList {
	s.TemplateConfig = &v
	return s
}

func (s *GetAIImageJobsResponseBodyAIImageJobList) SetTemplateId(v string) *GetAIImageJobsResponseBodyAIImageJobList {
	s.TemplateId = &v
	return s
}

func (s *GetAIImageJobsResponseBodyAIImageJobList) SetUserData(v string) *GetAIImageJobsResponseBodyAIImageJobList {
	s.UserData = &v
	return s
}

func (s *GetAIImageJobsResponseBodyAIImageJobList) SetVideoId(v string) *GetAIImageJobsResponseBodyAIImageJobList {
	s.VideoId = &v
	return s
}

type GetAIImageJobsResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAIImageJobsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAIImageJobsResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAIImageJobsResponse) GoString() string {
	return s.String()
}

func (s *GetAIImageJobsResponse) SetHeaders(v map[string]*string) *GetAIImageJobsResponse {
	s.Headers = v
	return s
}

func (s *GetAIImageJobsResponse) SetStatusCode(v int32) *GetAIImageJobsResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAIImageJobsResponse) SetBody(v *GetAIImageJobsResponseBody) *GetAIImageJobsResponse {
	s.Body = v
	return s
}

type GetAIMediaAuditJobRequest struct {
	// http://temp-****bucket.oss-cn-shanghai.aliyuncs.com/aivideocensor/****.jpg
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
}

func (s GetAIMediaAuditJobRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobRequest) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobRequest) SetJobId(v string) *GetAIMediaAuditJobRequest {
	s.JobId = &v
	return s
}

type GetAIMediaAuditJobResponseBody struct {
	// The average score of the images of the category that is indicated by Label. Valid values: `[0, 100]`. The value is accurate to 10 decimal places. The score is representative of the confidence.
	MediaAuditJob *GetAIMediaAuditJobResponseBodyMediaAuditJob `json:"MediaAuditJob,omitempty" xml:"MediaAuditJob,omitempty" type:"Struct"`
	// The highest review score.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetAIMediaAuditJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBody) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBody) SetMediaAuditJob(v *GetAIMediaAuditJobResponseBodyMediaAuditJob) *GetAIMediaAuditJobResponseBody {
	s.MediaAuditJob = v
	return s
}

func (s *GetAIMediaAuditJobResponseBody) SetRequestId(v string) *GetAIMediaAuditJobResponseBody {
	s.RequestId = &v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJob struct {
	// The ID of the intelligent review job.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The recommendation for review results. Valid values:
	//
	// *   **block**: The content violates the regulations.
	// *   **review**: The content may violate the regulations.
	// *   **pass**: The content passes the review.
	CompleteTime *string `json:"CompleteTime,omitempty" xml:"CompleteTime,omitempty"`
	// The review scenario. Valid value: **antispam**.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The status of the job. Valid values:
	//
	// *   **success**: The job is successful.
	// *   **fail**: The job failed.
	// *   **init**: The job is being initialized.
	// *   **Processing**: The job is in progress.
	Data *GetAIMediaAuditJobResponseBodyMediaAuditJobData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// Only the job type is supported.
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// http://temp-****bucket.oss-cn-shanghai.aliyuncs.com/aivideocensor/****.jpg
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The highest score of the image of the category that is indicated by Label. Valid values: `[0, 100]`. The value is accurate to 10 decimal places. The score is representative of the confidence.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The category of the review result. Valid values:
	//
	// *   **ad**
	// *   **normal**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The category of the review result. Valid values:
	//
	// *   **terrorism**
	// *   **outfit**
	// *   **logo**
	// *   **weapon**
	// *   **politics**
	// *   **others**
	// *   **normal**
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJob) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJob) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJob) SetCode(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJob {
	s.Code = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJob) SetCompleteTime(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJob {
	s.CompleteTime = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJob) SetCreationTime(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJob {
	s.CreationTime = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJob) SetData(v *GetAIMediaAuditJobResponseBodyMediaAuditJobData) *GetAIMediaAuditJobResponseBodyMediaAuditJob {
	s.Data = v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJob) SetJobId(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJob {
	s.JobId = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJob) SetMediaId(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJob {
	s.MediaId = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJob) SetMessage(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJob {
	s.Message = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJob) SetStatus(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJob {
	s.Status = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJob) SetType(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJob {
	s.Type = &v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobData struct {
	// The ID of the video.
	AbnormalModules *string `json:"AbnormalModules,omitempty" xml:"AbnormalModules,omitempty"`
	// The job result data.
	AudioResult []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult `json:"AudioResult,omitempty" xml:"AudioResult,omitempty" type:"Repeated"`
	// The recommendation for review results. Valid values:
	//
	// *   **block**: The content violates the regulations.
	// *   **review**: The content may violate the regulations.
	// *   **pass**: The content passes the review.
	ImageResult []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult `json:"ImageResult,omitempty" xml:"ImageResult,omitempty" type:"Repeated"`
	// The content that violates the regulations. Separate multiple values with commas (,). Valid values:
	//
	// *   **video**: the video.
	// *   **image-cover**: the cover.
	// *   **text-title**: the title.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The results of pornography content review.
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The results of ad review.
	TextResult []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult `json:"TextResult,omitempty" xml:"TextResult,omitempty" type:"Repeated"`
	// The category of the review result. Valid values:
	//
	// *   **logo**
	// *   **normal**
	VideoResult *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult `json:"VideoResult,omitempty" xml:"VideoResult,omitempty" type:"Struct"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobData) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobData) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobData) SetAbnormalModules(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobData {
	s.AbnormalModules = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobData) SetAudioResult(v []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult) *GetAIMediaAuditJobResponseBodyMediaAuditJobData {
	s.AudioResult = v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobData) SetImageResult(v []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult) *GetAIMediaAuditJobResponseBodyMediaAuditJobData {
	s.ImageResult = v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobData) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobData {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobData) SetSuggestion(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobData {
	s.Suggestion = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobData) SetTextResult(v []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult) *GetAIMediaAuditJobResponseBodyMediaAuditJobData {
	s.TextResult = v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobData) SetVideoResult(v *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult) *GetAIMediaAuditJobResponseBodyMediaAuditJobData {
	s.VideoResult = v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult struct {
	// The recommendation for review results. Valid values:
	//
	// *   **block**: The content violates the regulations.
	// *   **review**: The content may violate the regulations.
	// *   **pass**: The content passes the review.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The recommendation for review results. Valid values:
	//
	// *   **block**: The content violates the regulations.
	// *   **review**: The content may violate the regulations.
	// *   **pass**: The content passes the review.
	Scene *string `json:"Scene,omitempty" xml:"Scene,omitempty"`
	// The categories of the review results and the number of images.
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The category of the review result. Valid values:
	//
	// *   **normal**
	// *   **bloody**
	// *   **explosion**
	// *   **outfit**
	// *   **logo**
	// *   **weapon**
	// *   **politics**
	// *   **violence**
	// *   **crowd**
	// *   **parade**
	// *   **carcrash**
	// *   **flag**
	// *   **location**
	// *   **others**
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult) SetScene(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult {
	s.Scene = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult) SetScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult {
	s.Score = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult) SetSuggestion(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataAudioResult {
	s.Suggestion = &v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult struct {
	// The error code. This parameter is returned if the value of Status is fail.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The results of terrorism content review.
	Result []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// The categories of the review results and the number of images.
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The information about the image with the highest score of the category that is indicated by Label.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The score of the image of the category that is indicated by Label.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult) SetResult(v []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult {
	s.Result = v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult) SetSuggestion(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult {
	s.Suggestion = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult) SetType(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult {
	s.Type = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult) SetUrl(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResult {
	s.Url = &v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult struct {
	// The recommendation for review results. Valid values:
	//
	// *   **block**: The content violates the regulations.
	// *   **review**: The content may violate the regulations.
	// *   **pass**: The content passes the review.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The category of the review result. Valid values:
	//
	// *   **ad**
	// *   **normal**
	Scene *string `json:"Scene,omitempty" xml:"Scene,omitempty"`
	// The number of images.
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The results of logo review.
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult) SetScene(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult {
	s.Scene = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult) SetScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult {
	s.Score = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult) SetSuggestion(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataImageResultResult {
	s.Suggestion = &v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult struct {
	// The number of images.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The recommendation for review results. Valid values:
	//
	// *   **block**: The content violates the regulations.
	// *   **review**: The content may violate the regulations.
	// *   **pass**: The content passes the review.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The categories of the review results and the number of images.
	Scene *string `json:"Scene,omitempty" xml:"Scene,omitempty"`
	// The URL of the image.
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The information about the intelligent review job.
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The category of the review result.
	//
	// Valid values if scene is **porn**:
	//
	// *   **porn**
	// *   **sexy**
	// *   **normal**
	//
	// Valid values if scene is **terrorism**:
	//
	// *   **normal**
	// *   **bloody**
	// *   **explosion**
	// *   **outfit**
	// *   **logo**
	// *   **weapon**
	// *   **politics**
	// *   **violence**
	// *   **crowd**
	// *   **parade**
	// *   **carcrash**
	// *   **flag**
	// *   **location**
	// *   **others**
	//
	// Valid values if scene is **ad**:
	//
	// *   **normal**
	// *   **ad**
	// *   **politics**
	// *   **porn**
	// *   **abuse**
	// *   **terrorism**
	// *   **contraband**
	// *   **spam**
	// *   **npx**: illegal ad
	// *   **qrcode**: QR code
	// *   **programCode**
	//
	// Valid values if scene is **live**:
	//
	// *   **normal**
	// *   **meaningless**
	// *   **PIP**
	// *   **smoking**
	// *   **drivelive**
	//
	// Valid values if scene is **logo**:
	//
	// *   **normal**
	// *   **TV**
	// *   **trademark**
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult) SetContent(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult {
	s.Content = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult) SetScene(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult {
	s.Scene = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult) SetScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult {
	s.Score = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult) SetSuggestion(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult {
	s.Suggestion = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult) SetType(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataTextResult {
	s.Type = &v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult struct {
	// The information about the image with the highest score of the category that is indicated by Label.
	AdResult *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult `json:"AdResult,omitempty" xml:"AdResult,omitempty" type:"Struct"`
	// The category of the review result. Valid values:
	//
	// *   **live**: The content contains undesirable scenes.
	// *   **normal**
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The recommendation for review results. Valid values:
	//
	// *   **block**: The content violates the regulations.
	// *   **review**: The content may violate the regulations.
	// *   **pass**: The content passes the review.
	LiveResult *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult `json:"LiveResult,omitempty" xml:"LiveResult,omitempty" type:"Struct"`
	LogoResult *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult `json:"LogoResult,omitempty" xml:"LogoResult,omitempty" type:"Struct"`
	// The time when the job started to run. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	PornResult *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult `json:"PornResult,omitempty" xml:"PornResult,omitempty" type:"Struct"`
	// The position in the video. Unit: milliseconds.
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The category of the review result. Valid values:
	//
	// *   **ad**
	// *   **normal**
	TerrorismResult *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult `json:"TerrorismResult,omitempty" xml:"TerrorismResult,omitempty" type:"Struct"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult) SetAdResult(v *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult {
	s.AdResult = v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult) SetLiveResult(v *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult {
	s.LiveResult = v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult) SetLogoResult(v *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult {
	s.LogoResult = v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult) SetPornResult(v *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult {
	s.PornResult = v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult) SetSuggestion(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult {
	s.Suggestion = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult) SetTerrorismResult(v *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResult {
	s.TerrorismResult = v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult struct {
	// The number of images.
	AverageScore *string `json:"AverageScore,omitempty" xml:"AverageScore,omitempty"`
	// The results of video review.
	CounterList []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultCounterList `json:"CounterList,omitempty" xml:"CounterList,omitempty" type:"Repeated"`
	// The type of the image. Valid value: **cover**.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The category of the review result. Valid values:
	//
	// *   **porn**
	// *   **sexy**
	// *   **normal**
	MaxScore *string `json:"MaxScore,omitempty" xml:"MaxScore,omitempty"`
	// The statistics about tag frames.
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The information about the image with the highest score of the category that is indicated by Label.
	TopList []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList `json:"TopList,omitempty" xml:"TopList,omitempty" type:"Repeated"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult) SetAverageScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult {
	s.AverageScore = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult) SetCounterList(v []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultCounterList) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult {
	s.CounterList = v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult) SetMaxScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult {
	s.MaxScore = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult) SetSuggestion(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult {
	s.Suggestion = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult) SetTopList(v []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResult {
	s.TopList = v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultCounterList struct {
	// The information about the image with the highest score of the category that is indicated by Label.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The results of undesired content review.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultCounterList) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultCounterList) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultCounterList) SetCount(v int32) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultCounterList {
	s.Count = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultCounterList) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultCounterList {
	s.Label = &v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList struct {
	// The URL of the image.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The average score of the review results.
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The categories of the review results and the number of images.
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	// The URL of the image.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList) SetScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList {
	s.Score = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList) SetTimestamp(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList {
	s.Timestamp = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList) SetUrl(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultAdResultTopList {
	s.Url = &v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult struct {
	// The recommendation for review results. Valid values:
	//
	// *   **block**: The content violates the regulations.
	// *   **review**: The content may violate the regulations.
	// *   **pass**: The content passes the review.
	AverageScore *string `json:"AverageScore,omitempty" xml:"AverageScore,omitempty"`
	// The position in the video. Unit: milliseconds.
	CounterList []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultCounterList `json:"CounterList,omitempty" xml:"CounterList,omitempty" type:"Repeated"`
	// The category of the review result. Separate multiple values with commas (,). Valid values:
	//
	// *   **porn**
	// *   **terrorism**
	// *   **ad**
	// *   **live**: undesirable scenes
	// *   **logo**
	// *   **audio**: audio anti-spam
	// *   **normal**
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The time when the job is complete. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	MaxScore *string `json:"MaxScore,omitempty" xml:"MaxScore,omitempty"`
	// The error message. This parameter is returned if the value of Status is fail.
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The results of image review.
	TopList []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList `json:"TopList,omitempty" xml:"TopList,omitempty" type:"Repeated"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult) SetAverageScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult {
	s.AverageScore = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult) SetCounterList(v []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultCounterList) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult {
	s.CounterList = v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult) SetMaxScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult {
	s.MaxScore = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult) SetSuggestion(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult {
	s.Suggestion = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult) SetTopList(v []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResult {
	s.TopList = v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultCounterList struct {
	// The number of images.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The recommendation for review results. Valid values:
	//
	// *   **block**: The content violates the regulations.
	// *   **review**: The content may violate the regulations.
	// *   **pass**: The content passes the review.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultCounterList) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultCounterList) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultCounterList) SetCount(v int32) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultCounterList {
	s.Count = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultCounterList) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultCounterList {
	s.Label = &v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList struct {
	// Queries the information about an intelligent review job. After the job is submitted, it is processed asynchronously. You can call this operation to query the job information in real time.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The ID of the request.
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The results of text review.
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	// The category of the review result. Valid values:
	//
	// *   **live**: The content contains undesirable scenes.
	// *   **normal**
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList) SetScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList {
	s.Score = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList) SetTimestamp(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList {
	s.Timestamp = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList) SetUrl(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLiveResultTopList {
	s.Url = &v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult struct {
	AverageScore *string                                                                            `json:"AverageScore,omitempty" xml:"AverageScore,omitempty"`
	CounterList  []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultCounterList `json:"CounterList,omitempty" xml:"CounterList,omitempty" type:"Repeated"`
	Label        *string                                                                            `json:"Label,omitempty" xml:"Label,omitempty"`
	MaxScore     *string                                                                            `json:"MaxScore,omitempty" xml:"MaxScore,omitempty"`
	Suggestion   *string                                                                            `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	TopList      []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList     `json:"TopList,omitempty" xml:"TopList,omitempty" type:"Repeated"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult) SetAverageScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult {
	s.AverageScore = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult) SetCounterList(v []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultCounterList) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult {
	s.CounterList = v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult) SetMaxScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult {
	s.MaxScore = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult) SetSuggestion(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult {
	s.Suggestion = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult) SetTopList(v []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResult {
	s.TopList = v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultCounterList struct {
	Count *int32  `json:"Count,omitempty" xml:"Count,omitempty"`
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultCounterList) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultCounterList) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultCounterList) SetCount(v int32) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultCounterList {
	s.Count = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultCounterList) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultCounterList {
	s.Label = &v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList struct {
	Label     *string `json:"Label,omitempty" xml:"Label,omitempty"`
	Score     *string `json:"Score,omitempty" xml:"Score,omitempty"`
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	Url       *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList) SetScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList {
	s.Score = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList) SetTimestamp(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList {
	s.Timestamp = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList) SetUrl(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultLogoResultTopList {
	s.Url = &v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult struct {
	// Test
	AverageScore *string `json:"AverageScore,omitempty" xml:"AverageScore,omitempty"`
	// The URL of the image.
	CounterList []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultCounterList `json:"CounterList,omitempty" xml:"CounterList,omitempty" type:"Repeated"`
	// The average score of the review results.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The number of images.
	MaxScore *string `json:"MaxScore,omitempty" xml:"MaxScore,omitempty"`
	// The score of the image of the category that is indicated by Label.
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The category of the review result. Valid values:
	//
	// *   **porn**
	// *   **sexy**
	// *   **normal**
	TopList []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList `json:"TopList,omitempty" xml:"TopList,omitempty" type:"Repeated"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult) SetAverageScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult {
	s.AverageScore = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult) SetCounterList(v []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultCounterList) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult {
	s.CounterList = v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult) SetMaxScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult {
	s.MaxScore = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult) SetSuggestion(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult {
	s.Suggestion = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult) SetTopList(v []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResult {
	s.TopList = v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultCounterList struct {
	// The results of audio review.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The category of the review result. Valid values:
	//
	// *   **live**: The content contains undesirable scenes.
	// *   **normal**
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultCounterList) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultCounterList) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultCounterList) SetCount(v int32) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultCounterList {
	s.Count = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultCounterList) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultCounterList {
	s.Label = &v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList struct {
	// The score of the image of the category that is indicated by Label. Valid values: `[0, 100]`. The value is accurate to 10 decimal places. The score is representative of the confidence.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The position in the video. Unit: milliseconds.
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The score.
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	// The score of the image of the category that is indicated by Label. Valid values: `[0, 100]`. The value is accurate to 10 decimal places. The score is representative of the confidence.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList) SetScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList {
	s.Score = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList) SetTimestamp(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList {
	s.Timestamp = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList) SetUrl(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultPornResultTopList {
	s.Url = &v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult struct {
	// The category of the review result. Valid values:
	//
	// *   **porn**
	// *   **sexy**
	// *   **normal**
	AverageScore *string `json:"AverageScore,omitempty" xml:"AverageScore,omitempty"`
	// The review scenario. Valid values:
	//
	// *   **porn**
	// *   **terrorism**
	// *   **ad**
	// *   **live**: undesirable scenes
	// *   **logo**
	CounterList []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultCounterList `json:"CounterList,omitempty" xml:"CounterList,omitempty" type:"Repeated"`
	// The category of the review result. Valid values:
	//
	// *   **logo**
	// *   **normal**
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The score of the image of the category that is indicated by Label.
	MaxScore *string `json:"MaxScore,omitempty" xml:"MaxScore,omitempty"`
	// The URL of the image.
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The score of the image of the category that is indicated by Label. Valid values: `[0, 100]`. The score is representative of the confidence.
	TopList []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList `json:"TopList,omitempty" xml:"TopList,omitempty" type:"Repeated"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult) SetAverageScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult {
	s.AverageScore = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult) SetCounterList(v []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultCounterList) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult {
	s.CounterList = v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult) SetMaxScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult {
	s.MaxScore = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult) SetSuggestion(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult {
	s.Suggestion = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult) SetTopList(v []*GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResult {
	s.TopList = v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultCounterList struct {
	// The highest score of the image of the category that is indicated by Label.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The category of the review result. Valid values:
	//
	// *   **normal**
	// *   **bloody**
	// *   **explosion**
	// *   **outfit**
	// *   **logo**
	// *   **weapon**
	// *   **politics**
	// *   **violence**
	// *   **crowd**
	// *   **parade**
	// *   **carcrash**
	// *   **flag**
	// *   **location**
	// *   **others**
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultCounterList) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultCounterList) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultCounterList) SetCount(v int32) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultCounterList {
	s.Count = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultCounterList) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultCounterList {
	s.Label = &v
	return s
}

type GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList struct {
	// The category of the review result. Valid values:
	//
	// *   **logo**
	// *   **normal**
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The ID of the job.
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The highest review score.
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	// The position in the video. Unit: milliseconds.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList) SetLabel(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList {
	s.Label = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList) SetScore(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList {
	s.Score = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList) SetTimestamp(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList {
	s.Timestamp = &v
	return s
}

func (s *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList) SetUrl(v string) *GetAIMediaAuditJobResponseBodyMediaAuditJobDataVideoResultTerrorismResultTopList {
	s.Url = &v
	return s
}

type GetAIMediaAuditJobResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAIMediaAuditJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAIMediaAuditJobResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAIMediaAuditJobResponse) GoString() string {
	return s.String()
}

func (s *GetAIMediaAuditJobResponse) SetHeaders(v map[string]*string) *GetAIMediaAuditJobResponse {
	s.Headers = v
	return s
}

func (s *GetAIMediaAuditJobResponse) SetStatusCode(v int32) *GetAIMediaAuditJobResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAIMediaAuditJobResponse) SetBody(v *GetAIMediaAuditJobResponseBody) *GetAIMediaAuditJobResponse {
	s.Body = v
	return s
}

type GetAITemplateRequest struct {
	// The source of the AI template. Valid values:
	//
	// *   **System**
	// *   **Custom**
	TemplateId *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
}

func (s GetAITemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAITemplateRequest) GoString() string {
	return s.String()
}

func (s *GetAITemplateRequest) SetTemplateId(v string) *GetAITemplateRequest {
	s.TemplateId = &v
	return s
}

type GetAITemplateResponseBody struct {
	// The information about the AI template.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the AI template.
	TemplateInfo *GetAITemplateResponseBodyTemplateInfo `json:"TemplateInfo,omitempty" xml:"TemplateInfo,omitempty" type:"Struct"`
}

func (s GetAITemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAITemplateResponseBody) GoString() string {
	return s.String()
}

func (s *GetAITemplateResponseBody) SetRequestId(v string) *GetAITemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetAITemplateResponseBody) SetTemplateInfo(v *GetAITemplateResponseBodyTemplateInfo) *GetAITemplateResponseBody {
	s.TemplateInfo = v
	return s
}

type GetAITemplateResponseBodyTemplateInfo struct {
	// The type of the AI template. Valid values:
	//
	// *   **AIMediaAudit**: automated review
	// *   **AIImage**: smart thumbnail
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The time when the AI template was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	IsDefault  *string `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	ModifyTime *string `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	// Queries the details of an AI template.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The time when the AI template was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	TemplateConfig *string `json:"TemplateConfig,omitempty" xml:"TemplateConfig,omitempty"`
	TemplateId     *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The ID of the request.
	TemplateName *string `json:"TemplateName,omitempty" xml:"TemplateName,omitempty"`
	// Indicates whether the template is the default AI template. Valid values:
	//
	// *   **Default**
	// *   **NotDefault**
	TemplateType *string `json:"TemplateType,omitempty" xml:"TemplateType,omitempty"`
}

func (s GetAITemplateResponseBodyTemplateInfo) String() string {
	return tea.Prettify(s)
}

func (s GetAITemplateResponseBodyTemplateInfo) GoString() string {
	return s.String()
}

func (s *GetAITemplateResponseBodyTemplateInfo) SetCreationTime(v string) *GetAITemplateResponseBodyTemplateInfo {
	s.CreationTime = &v
	return s
}

func (s *GetAITemplateResponseBodyTemplateInfo) SetIsDefault(v string) *GetAITemplateResponseBodyTemplateInfo {
	s.IsDefault = &v
	return s
}

func (s *GetAITemplateResponseBodyTemplateInfo) SetModifyTime(v string) *GetAITemplateResponseBodyTemplateInfo {
	s.ModifyTime = &v
	return s
}

func (s *GetAITemplateResponseBodyTemplateInfo) SetSource(v string) *GetAITemplateResponseBodyTemplateInfo {
	s.Source = &v
	return s
}

func (s *GetAITemplateResponseBodyTemplateInfo) SetTemplateConfig(v string) *GetAITemplateResponseBodyTemplateInfo {
	s.TemplateConfig = &v
	return s
}

func (s *GetAITemplateResponseBodyTemplateInfo) SetTemplateId(v string) *GetAITemplateResponseBodyTemplateInfo {
	s.TemplateId = &v
	return s
}

func (s *GetAITemplateResponseBodyTemplateInfo) SetTemplateName(v string) *GetAITemplateResponseBodyTemplateInfo {
	s.TemplateName = &v
	return s
}

func (s *GetAITemplateResponseBodyTemplateInfo) SetTemplateType(v string) *GetAITemplateResponseBodyTemplateInfo {
	s.TemplateType = &v
	return s
}

type GetAITemplateResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAITemplateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAITemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAITemplateResponse) GoString() string {
	return s.String()
}

func (s *GetAITemplateResponse) SetHeaders(v map[string]*string) *GetAITemplateResponse {
	s.Headers = v
	return s
}

func (s *GetAITemplateResponse) SetStatusCode(v int32) *GetAITemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAITemplateResponse) SetBody(v *GetAITemplateResponseBody) *GetAITemplateResponse {
	s.Body = v
	return s
}

type GetAIVideoTagResultRequest struct {
	// The point in time when the time tag is displayed. Unit: milliseconds.
	MediaId              *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GetAIVideoTagResultRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAIVideoTagResultRequest) GoString() string {
	return s.String()
}

func (s *GetAIVideoTagResultRequest) SetMediaId(v string) *GetAIVideoTagResultRequest {
	s.MediaId = &v
	return s
}

func (s *GetAIVideoTagResultRequest) SetOwnerAccount(v string) *GetAIVideoTagResultRequest {
	s.OwnerAccount = &v
	return s
}

func (s *GetAIVideoTagResultRequest) SetOwnerId(v string) *GetAIVideoTagResultRequest {
	s.OwnerId = &v
	return s
}

func (s *GetAIVideoTagResultRequest) SetResourceOwnerAccount(v string) *GetAIVideoTagResultRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GetAIVideoTagResultRequest) SetResourceOwnerId(v string) *GetAIVideoTagResultRequest {
	s.ResourceOwnerId = &v
	return s
}

type GetAIVideoTagResultResponseBody struct {
	// The location tag of the video.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The tag string.
	VideoTagResult *GetAIVideoTagResultResponseBodyVideoTagResult `json:"VideoTagResult,omitempty" xml:"VideoTagResult,omitempty" type:"Struct"`
}

func (s GetAIVideoTagResultResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAIVideoTagResultResponseBody) GoString() string {
	return s.String()
}

func (s *GetAIVideoTagResultResponseBody) SetRequestId(v string) *GetAIVideoTagResultResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetAIVideoTagResultResponseBody) SetVideoTagResult(v *GetAIVideoTagResultResponseBodyVideoTagResult) *GetAIVideoTagResultResponseBody {
	s.VideoTagResult = v
	return s
}

type GetAIVideoTagResultResponseBodyVideoTagResult struct {
	// The location tags.
	Category []*GetAIVideoTagResultResponseBodyVideoTagResultCategory `json:"Category,omitempty" xml:"Category,omitempty" type:"Repeated"`
	// The video categories.
	Keyword []*GetAIVideoTagResultResponseBodyVideoTagResultKeyword `json:"Keyword,omitempty" xml:"Keyword,omitempty" type:"Repeated"`
	// The point in time when the location tag is displayed. Unit: milliseconds.
	Location []*GetAIVideoTagResultResponseBodyVideoTagResultLocation `json:"Location,omitempty" xml:"Location,omitempty" type:"Repeated"`
	// The tag string.
	Person []*GetAIVideoTagResultResponseBodyVideoTagResultPerson `json:"Person,omitempty" xml:"Person,omitempty" type:"Repeated"`
	// The ID of the media file. You can use one of the following methods to obtain the ID:
	//
	// *   Log on to the [ApsaraVideo VOD](https://vod.console.aliyun.com) console. In the left-side navigation pane, choose **Media Files** > **Audio/Video**. On the Video and Audio page, view the ID of the audio or video file. This method is applicable to files that are uploaded by using the ApsaraVideo VOD console.
	// *   Obtain the value of VideoId from the response to the [CreateUploadVideo](~~55407~~) operation that you call to upload media files.
	// *   Obtain the value of VideoId from the response to the [SearchMedia](~~86044~~) operation after you upload media files.
	Time []*GetAIVideoTagResultResponseBodyVideoTagResultTime `json:"Time,omitempty" xml:"Time,omitempty" type:"Repeated"`
}

func (s GetAIVideoTagResultResponseBodyVideoTagResult) String() string {
	return tea.Prettify(s)
}

func (s GetAIVideoTagResultResponseBodyVideoTagResult) GoString() string {
	return s.String()
}

func (s *GetAIVideoTagResultResponseBodyVideoTagResult) SetCategory(v []*GetAIVideoTagResultResponseBodyVideoTagResultCategory) *GetAIVideoTagResultResponseBodyVideoTagResult {
	s.Category = v
	return s
}

func (s *GetAIVideoTagResultResponseBodyVideoTagResult) SetKeyword(v []*GetAIVideoTagResultResponseBodyVideoTagResultKeyword) *GetAIVideoTagResultResponseBodyVideoTagResult {
	s.Keyword = v
	return s
}

func (s *GetAIVideoTagResultResponseBodyVideoTagResult) SetLocation(v []*GetAIVideoTagResultResponseBodyVideoTagResultLocation) *GetAIVideoTagResultResponseBodyVideoTagResult {
	s.Location = v
	return s
}

func (s *GetAIVideoTagResultResponseBodyVideoTagResult) SetPerson(v []*GetAIVideoTagResultResponseBodyVideoTagResultPerson) *GetAIVideoTagResultResponseBodyVideoTagResult {
	s.Person = v
	return s
}

func (s *GetAIVideoTagResultResponseBodyVideoTagResult) SetTime(v []*GetAIVideoTagResultResponseBodyVideoTagResultTime) *GetAIVideoTagResultResponseBodyVideoTagResult {
	s.Time = v
	return s
}

type GetAIVideoTagResultResponseBodyVideoTagResultCategory struct {
	// John
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
}

func (s GetAIVideoTagResultResponseBodyVideoTagResultCategory) String() string {
	return tea.Prettify(s)
}

func (s GetAIVideoTagResultResponseBodyVideoTagResultCategory) GoString() string {
	return s.String()
}

func (s *GetAIVideoTagResultResponseBodyVideoTagResultCategory) SetTag(v string) *GetAIVideoTagResultResponseBodyVideoTagResultCategory {
	s.Tag = &v
	return s
}

type GetAIVideoTagResultResponseBodyVideoTagResultKeyword struct {
	// The URL of the profile photo.
	//
	// > This parameter is returned only when a figure tag was used.
	Tag   *string   `json:"Tag,omitempty" xml:"Tag,omitempty"`
	Times []*string `json:"Times,omitempty" xml:"Times,omitempty" type:"Repeated"`
}

func (s GetAIVideoTagResultResponseBodyVideoTagResultKeyword) String() string {
	return tea.Prettify(s)
}

func (s GetAIVideoTagResultResponseBodyVideoTagResultKeyword) GoString() string {
	return s.String()
}

func (s *GetAIVideoTagResultResponseBodyVideoTagResultKeyword) SetTag(v string) *GetAIVideoTagResultResponseBodyVideoTagResultKeyword {
	s.Tag = &v
	return s
}

func (s *GetAIVideoTagResultResponseBodyVideoTagResultKeyword) SetTimes(v []*string) *GetAIVideoTagResultResponseBodyVideoTagResultKeyword {
	s.Times = v
	return s
}

type GetAIVideoTagResultResponseBodyVideoTagResultLocation struct {
	// The figure tag of the video.
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
	// The returned result.
	Times []*string `json:"Times,omitempty" xml:"Times,omitempty" type:"Repeated"`
}

func (s GetAIVideoTagResultResponseBodyVideoTagResultLocation) String() string {
	return tea.Prettify(s)
}

func (s GetAIVideoTagResultResponseBodyVideoTagResultLocation) GoString() string {
	return s.String()
}

func (s *GetAIVideoTagResultResponseBodyVideoTagResultLocation) SetTag(v string) *GetAIVideoTagResultResponseBodyVideoTagResultLocation {
	s.Tag = &v
	return s
}

func (s *GetAIVideoTagResultResponseBodyVideoTagResultLocation) SetTimes(v []*string) *GetAIVideoTagResultResponseBodyVideoTagResultLocation {
	s.Times = v
	return s
}

type GetAIVideoTagResultResponseBodyVideoTagResultPerson struct {
	// Retouching
	FaceUrl *string `json:"FaceUrl,omitempty" xml:"FaceUrl,omitempty"`
	// The keyword tags.
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
	// The points in time when the tags are displayed. Unit: milliseconds.
	Times []*string `json:"Times,omitempty" xml:"Times,omitempty" type:"Repeated"`
}

func (s GetAIVideoTagResultResponseBodyVideoTagResultPerson) String() string {
	return tea.Prettify(s)
}

func (s GetAIVideoTagResultResponseBodyVideoTagResultPerson) GoString() string {
	return s.String()
}

func (s *GetAIVideoTagResultResponseBodyVideoTagResultPerson) SetFaceUrl(v string) *GetAIVideoTagResultResponseBodyVideoTagResultPerson {
	s.FaceUrl = &v
	return s
}

func (s *GetAIVideoTagResultResponseBodyVideoTagResultPerson) SetTag(v string) *GetAIVideoTagResultResponseBodyVideoTagResultPerson {
	s.Tag = &v
	return s
}

func (s *GetAIVideoTagResultResponseBodyVideoTagResultPerson) SetTimes(v []*string) *GetAIVideoTagResultResponseBodyVideoTagResultPerson {
	s.Times = v
	return s
}

type GetAIVideoTagResultResponseBodyVideoTagResultTime struct {
	// Cushion
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
	// The tag string.
	Times []*string `json:"Times,omitempty" xml:"Times,omitempty" type:"Repeated"`
}

func (s GetAIVideoTagResultResponseBodyVideoTagResultTime) String() string {
	return tea.Prettify(s)
}

func (s GetAIVideoTagResultResponseBodyVideoTagResultTime) GoString() string {
	return s.String()
}

func (s *GetAIVideoTagResultResponseBodyVideoTagResultTime) SetTag(v string) *GetAIVideoTagResultResponseBodyVideoTagResultTime {
	s.Tag = &v
	return s
}

func (s *GetAIVideoTagResultResponseBodyVideoTagResultTime) SetTimes(v []*string) *GetAIVideoTagResultResponseBodyVideoTagResultTime {
	s.Times = v
	return s
}

type GetAIVideoTagResultResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAIVideoTagResultResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAIVideoTagResultResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAIVideoTagResultResponse) GoString() string {
	return s.String()
}

func (s *GetAIVideoTagResultResponse) SetHeaders(v map[string]*string) *GetAIVideoTagResultResponse {
	s.Headers = v
	return s
}

func (s *GetAIVideoTagResultResponse) SetStatusCode(v int32) *GetAIVideoTagResultResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAIVideoTagResultResponse) SetBody(v *GetAIVideoTagResultResponseBody) *GetAIVideoTagResultResponse {
	s.Body = v
	return s
}

type GetAppInfosRequest struct {
	// The type of the application. Valid values:
	//
	// - **System**
	// - **Custom**
	AppIds *string `json:"AppIds,omitempty" xml:"AppIds,omitempty"`
}

func (s GetAppInfosRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAppInfosRequest) GoString() string {
	return s.String()
}

func (s *GetAppInfosRequest) SetAppIds(v string) *GetAppInfosRequest {
	s.AppIds = &v
	return s
}

type GetAppInfosResponseBody struct {
	// The time when the application was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	AppInfoList []*GetAppInfosResponseBodyAppInfoList `json:"AppInfoList,omitempty" xml:"AppInfoList,omitempty" type:"Repeated"`
	Code        *string                               `json:"Code,omitempty" xml:"Code,omitempty"`
	// The ID of the application. You can specify a maximum of 10 application IDs. Separate them with commas (,).
	NonExistAppIds []*string `json:"NonExistAppIds,omitempty" xml:"NonExistAppIds,omitempty" type:"Repeated"`
	// The last time when the application was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetAppInfosResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAppInfosResponseBody) GoString() string {
	return s.String()
}

func (s *GetAppInfosResponseBody) SetAppInfoList(v []*GetAppInfosResponseBodyAppInfoList) *GetAppInfosResponseBody {
	s.AppInfoList = v
	return s
}

func (s *GetAppInfosResponseBody) SetCode(v string) *GetAppInfosResponseBody {
	s.Code = &v
	return s
}

func (s *GetAppInfosResponseBody) SetNonExistAppIds(v []*string) *GetAppInfosResponseBody {
	s.NonExistAppIds = v
	return s
}

func (s *GetAppInfosResponseBody) SetRequestId(v string) *GetAppInfosResponseBody {
	s.RequestId = &v
	return s
}

type GetAppInfosResponseBodyAppInfoList struct {
	AppId            *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	AppName          *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	CreationTime     *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	Description      *string `json:"Description,omitempty" xml:"Description,omitempty"`
	ModificationTime *string `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	// Queries the information about one or more applications based on application IDs.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the request.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetAppInfosResponseBodyAppInfoList) String() string {
	return tea.Prettify(s)
}

func (s GetAppInfosResponseBodyAppInfoList) GoString() string {
	return s.String()
}

func (s *GetAppInfosResponseBodyAppInfoList) SetAppId(v string) *GetAppInfosResponseBodyAppInfoList {
	s.AppId = &v
	return s
}

func (s *GetAppInfosResponseBodyAppInfoList) SetAppName(v string) *GetAppInfosResponseBodyAppInfoList {
	s.AppName = &v
	return s
}

func (s *GetAppInfosResponseBodyAppInfoList) SetCreationTime(v string) *GetAppInfosResponseBodyAppInfoList {
	s.CreationTime = &v
	return s
}

func (s *GetAppInfosResponseBodyAppInfoList) SetDescription(v string) *GetAppInfosResponseBodyAppInfoList {
	s.Description = &v
	return s
}

func (s *GetAppInfosResponseBodyAppInfoList) SetModificationTime(v string) *GetAppInfosResponseBodyAppInfoList {
	s.ModificationTime = &v
	return s
}

func (s *GetAppInfosResponseBodyAppInfoList) SetStatus(v string) *GetAppInfosResponseBodyAppInfoList {
	s.Status = &v
	return s
}

func (s *GetAppInfosResponseBodyAppInfoList) SetType(v string) *GetAppInfosResponseBodyAppInfoList {
	s.Type = &v
	return s
}

type GetAppInfosResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAppInfosResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAppInfosResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAppInfosResponse) GoString() string {
	return s.String()
}

func (s *GetAppInfosResponse) SetHeaders(v map[string]*string) *GetAppInfosResponse {
	s.Headers = v
	return s
}

func (s *GetAppInfosResponse) SetStatusCode(v int32) *GetAppInfosResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAppInfosResponse) SetBody(v *GetAppInfosResponseBody) *GetAppInfosResponse {
	s.Body = v
	return s
}

type GetAttachedMediaInfoRequest struct {
	// The validity period of the URL of the auxiliary media asset. Unit: seconds.
	// > *   If the OutputType parameter is set to **cdn**:
	// >     *   The URL of the auxiliary media asset has a validity period only if URL signing is enabled. Otherwise, the URL of the auxiliary media asset is permanently valid.
	// >     *   Minimum value: **1**.
	// >     *   Maximum value: unlimited.
	// >     *   Default value: If you do not set this parameter, the default validity period that is specified in URL signing is used.
	// > *   If the OutputType parameter is set to **oss**:
	// >     *   The URL of the auxiliary media asset has a validity period only if the permissions on the Object Storage Service (OSS) bucket are private. Otherwise, the URL of the auxiliary media asset is permanently valid.
	// >     *   Minimum value: **1**.
	// >     *   Maximum value: **2592000** (30 days). The maximum value is limited to reduce security risks of the origin.
	// >     *   Default value: If you do not set this parameter, the default value is **3600**.
	AuthTimeout *int64 `json:"AuthTimeout,omitempty" xml:"AuthTimeout,omitempty"`
	// The ID of the auxiliary media asset. Separate multiple IDs with commas (,). A maximum of 20 IDs can be specified.
	MediaIds *string `json:"MediaIds,omitempty" xml:"MediaIds,omitempty"`
	// The type of the URL of the auxiliary media asset. Valid values:
	// *   **oss**: OSS URL
	// *   **cdn** (default): Content Delivery Network (CDN) URL
	OutputType *string `json:"OutputType,omitempty" xml:"OutputType,omitempty"`
}

func (s GetAttachedMediaInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAttachedMediaInfoRequest) GoString() string {
	return s.String()
}

func (s *GetAttachedMediaInfoRequest) SetAuthTimeout(v int64) *GetAttachedMediaInfoRequest {
	s.AuthTimeout = &v
	return s
}

func (s *GetAttachedMediaInfoRequest) SetMediaIds(v string) *GetAttachedMediaInfoRequest {
	s.MediaIds = &v
	return s
}

func (s *GetAttachedMediaInfoRequest) SetOutputType(v string) *GetAttachedMediaInfoRequest {
	s.OutputType = &v
	return s
}

type GetAttachedMediaInfoResponseBody struct {
	// The information about the media asset.
	AttachedMediaList []*GetAttachedMediaInfoResponseBodyAttachedMediaList `json:"AttachedMediaList,omitempty" xml:"AttachedMediaList,omitempty" type:"Repeated"`
	// The IDs of the auxiliary media assets that do not exist.
	NonExistMediaIds []*string `json:"NonExistMediaIds,omitempty" xml:"NonExistMediaIds,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetAttachedMediaInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAttachedMediaInfoResponseBody) GoString() string {
	return s.String()
}

func (s *GetAttachedMediaInfoResponseBody) SetAttachedMediaList(v []*GetAttachedMediaInfoResponseBodyAttachedMediaList) *GetAttachedMediaInfoResponseBody {
	s.AttachedMediaList = v
	return s
}

func (s *GetAttachedMediaInfoResponseBody) SetNonExistMediaIds(v []*string) *GetAttachedMediaInfoResponseBody {
	s.NonExistMediaIds = v
	return s
}

func (s *GetAttachedMediaInfoResponseBody) SetRequestId(v string) *GetAttachedMediaInfoResponseBody {
	s.RequestId = &v
	return s
}

type GetAttachedMediaInfoResponseBodyAttachedMediaList struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The list of categories.
	Categories []*GetAttachedMediaInfoResponseBodyAttachedMediaListCategories `json:"Categories,omitempty" xml:"Categories,omitempty" type:"Repeated"`
	// The time when the auxiliary media asset was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the auxiliary media asset.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the auxiliary media asset.
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The time when the auxiliary media asset was updated. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	ModificationTime *string `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	// The status of the auxiliary media asset. Valid values:
	// - **Uploading**: The auxiliary media asset is being uploaded. This is the initial status.
	// - **Normal**: The auxiliary media asset is uploaded.
	// - **UploadFail**: The auxiliary media asset fails to be uploaded.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The OSS bucket where the auxiliary media asset is stored.
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	// The tags of the auxiliary media asset.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The title of the auxiliary media asset.
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The type of the auxiliary media asset. Valid values:
	// - **watermark**
	// - **subtitle**
	// - **material**
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The URL of the auxiliary media asset.
	// > If a CDN domain name is specified, a CDN URL is returned. Otherwise, an OSS URL is returned.
	URL *string `json:"URL,omitempty" xml:"URL,omitempty"`
}

func (s GetAttachedMediaInfoResponseBodyAttachedMediaList) String() string {
	return tea.Prettify(s)
}

func (s GetAttachedMediaInfoResponseBodyAttachedMediaList) GoString() string {
	return s.String()
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaList) SetAppId(v string) *GetAttachedMediaInfoResponseBodyAttachedMediaList {
	s.AppId = &v
	return s
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaList) SetCategories(v []*GetAttachedMediaInfoResponseBodyAttachedMediaListCategories) *GetAttachedMediaInfoResponseBodyAttachedMediaList {
	s.Categories = v
	return s
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaList) SetCreationTime(v string) *GetAttachedMediaInfoResponseBodyAttachedMediaList {
	s.CreationTime = &v
	return s
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaList) SetDescription(v string) *GetAttachedMediaInfoResponseBodyAttachedMediaList {
	s.Description = &v
	return s
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaList) SetMediaId(v string) *GetAttachedMediaInfoResponseBodyAttachedMediaList {
	s.MediaId = &v
	return s
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaList) SetModificationTime(v string) *GetAttachedMediaInfoResponseBodyAttachedMediaList {
	s.ModificationTime = &v
	return s
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaList) SetStatus(v string) *GetAttachedMediaInfoResponseBodyAttachedMediaList {
	s.Status = &v
	return s
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaList) SetStorageLocation(v string) *GetAttachedMediaInfoResponseBodyAttachedMediaList {
	s.StorageLocation = &v
	return s
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaList) SetTags(v string) *GetAttachedMediaInfoResponseBodyAttachedMediaList {
	s.Tags = &v
	return s
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaList) SetTitle(v string) *GetAttachedMediaInfoResponseBodyAttachedMediaList {
	s.Title = &v
	return s
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaList) SetType(v string) *GetAttachedMediaInfoResponseBodyAttachedMediaList {
	s.Type = &v
	return s
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaList) SetURL(v string) *GetAttachedMediaInfoResponseBodyAttachedMediaList {
	s.URL = &v
	return s
}

type GetAttachedMediaInfoResponseBodyAttachedMediaListCategories struct {
	// The ID of the video category.
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The name of the category.
	// - The value can be up to 64 bytes in length.
	// - The string must be encoded in the UTF-8 format.
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	// The level of the category. A value of 0 indicates a level 1 category.
	Level *int64 `json:"Level,omitempty" xml:"Level,omitempty"`
	// The ID of the parent category. The parent category ID of a level 1 category is -1.
	ParentId *int64 `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
}

func (s GetAttachedMediaInfoResponseBodyAttachedMediaListCategories) String() string {
	return tea.Prettify(s)
}

func (s GetAttachedMediaInfoResponseBodyAttachedMediaListCategories) GoString() string {
	return s.String()
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaListCategories) SetCateId(v int64) *GetAttachedMediaInfoResponseBodyAttachedMediaListCategories {
	s.CateId = &v
	return s
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaListCategories) SetCateName(v string) *GetAttachedMediaInfoResponseBodyAttachedMediaListCategories {
	s.CateName = &v
	return s
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaListCategories) SetLevel(v int64) *GetAttachedMediaInfoResponseBodyAttachedMediaListCategories {
	s.Level = &v
	return s
}

func (s *GetAttachedMediaInfoResponseBodyAttachedMediaListCategories) SetParentId(v int64) *GetAttachedMediaInfoResponseBodyAttachedMediaListCategories {
	s.ParentId = &v
	return s
}

type GetAttachedMediaInfoResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAttachedMediaInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAttachedMediaInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAttachedMediaInfoResponse) GoString() string {
	return s.String()
}

func (s *GetAttachedMediaInfoResponse) SetHeaders(v map[string]*string) *GetAttachedMediaInfoResponse {
	s.Headers = v
	return s
}

func (s *GetAttachedMediaInfoResponse) SetStatusCode(v int32) *GetAttachedMediaInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAttachedMediaInfoResponse) SetBody(v *GetAttachedMediaInfoResponseBody) *GetAttachedMediaInfoResponse {
	s.Body = v
	return s
}

type GetAuditHistoryRequest struct {
	// The reason why the video failed the review. If the video failed the review, specify the reason.
	PageNo *int64 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The ID of the video.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The review records.
	SortBy *string `json:"SortBy,omitempty" xml:"SortBy,omitempty"`
	// The operation that you want to perform. Set the value to **GetAuditHistory**.
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s GetAuditHistoryRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAuditHistoryRequest) GoString() string {
	return s.String()
}

func (s *GetAuditHistoryRequest) SetPageNo(v int64) *GetAuditHistoryRequest {
	s.PageNo = &v
	return s
}

func (s *GetAuditHistoryRequest) SetPageSize(v int64) *GetAuditHistoryRequest {
	s.PageSize = &v
	return s
}

func (s *GetAuditHistoryRequest) SetSortBy(v string) *GetAuditHistoryRequest {
	s.SortBy = &v
	return s
}

func (s *GetAuditHistoryRequest) SetVideoId(v string) *GetAuditHistoryRequest {
	s.VideoId = &v
	return s
}

type GetAuditHistoryResponseBody struct {
	// The ID of the request.
	Histories []*GetAuditHistoryResponseBodyHistories `json:"Histories,omitempty" xml:"Histories,omitempty" type:"Repeated"`
	// The review comments, which are provided by the reviewer.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The reviewer.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The sorting rule of the results. Valid values:
	//
	// *   **CreationTime:Desc**: sorts the results based on the creation time in descending order. This is the default value.
	// *   **CreationTime:Asc**: sorts the results based on the creation time in ascending order.
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s GetAuditHistoryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAuditHistoryResponseBody) GoString() string {
	return s.String()
}

func (s *GetAuditHistoryResponseBody) SetHistories(v []*GetAuditHistoryResponseBodyHistories) *GetAuditHistoryResponseBody {
	s.Histories = v
	return s
}

func (s *GetAuditHistoryResponseBody) SetRequestId(v string) *GetAuditHistoryResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetAuditHistoryResponseBody) SetStatus(v string) *GetAuditHistoryResponseBody {
	s.Status = &v
	return s
}

func (s *GetAuditHistoryResponseBody) SetTotal(v int64) *GetAuditHistoryResponseBody {
	s.Total = &v
	return s
}

type GetAuditHistoryResponseBodyHistories struct {
	Auditor *string `json:"Auditor,omitempty" xml:"Auditor,omitempty"`
	// Queries the manual review history.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The manual review result. Valid values:
	//
	// - **Normal**: The video can be played.
	// - **Blocked**: The video is blocked.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	Reason       *string `json:"Reason,omitempty" xml:"Reason,omitempty"`
	// The time when the review record was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetAuditHistoryResponseBodyHistories) String() string {
	return tea.Prettify(s)
}

func (s GetAuditHistoryResponseBodyHistories) GoString() string {
	return s.String()
}

func (s *GetAuditHistoryResponseBodyHistories) SetAuditor(v string) *GetAuditHistoryResponseBodyHistories {
	s.Auditor = &v
	return s
}

func (s *GetAuditHistoryResponseBodyHistories) SetComment(v string) *GetAuditHistoryResponseBodyHistories {
	s.Comment = &v
	return s
}

func (s *GetAuditHistoryResponseBodyHistories) SetCreationTime(v string) *GetAuditHistoryResponseBodyHistories {
	s.CreationTime = &v
	return s
}

func (s *GetAuditHistoryResponseBodyHistories) SetReason(v string) *GetAuditHistoryResponseBodyHistories {
	s.Reason = &v
	return s
}

func (s *GetAuditHistoryResponseBodyHistories) SetStatus(v string) *GetAuditHistoryResponseBodyHistories {
	s.Status = &v
	return s
}

type GetAuditHistoryResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAuditHistoryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAuditHistoryResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAuditHistoryResponse) GoString() string {
	return s.String()
}

func (s *GetAuditHistoryResponse) SetHeaders(v map[string]*string) *GetAuditHistoryResponse {
	s.Headers = v
	return s
}

func (s *GetAuditHistoryResponse) SetStatusCode(v int32) *GetAuditHistoryResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAuditHistoryResponse) SetBody(v *GetAuditHistoryResponseBody) *GetAuditHistoryResponse {
	s.Body = v
	return s
}

type GetCategoriesRequest struct {
	// The number of the page where the subcategories to be returned are listed. Default value: **1**.
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The type of the category. Valid values:
	//
	// *   **default** (default): default category
	// *   **material**: material category
	PageNo *int64 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The number of entries to return on each page of the subcategory list. Default value: **10**. Maximum value: **100**.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The list of subcategories.
	SortBy *string `json:"SortBy,omitempty" xml:"SortBy,omitempty"`
	// The total number of subcategories.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetCategoriesRequest) String() string {
	return tea.Prettify(s)
}

func (s GetCategoriesRequest) GoString() string {
	return s.String()
}

func (s *GetCategoriesRequest) SetCateId(v int64) *GetCategoriesRequest {
	s.CateId = &v
	return s
}

func (s *GetCategoriesRequest) SetPageNo(v int64) *GetCategoriesRequest {
	s.PageNo = &v
	return s
}

func (s *GetCategoriesRequest) SetPageSize(v int64) *GetCategoriesRequest {
	s.PageSize = &v
	return s
}

func (s *GetCategoriesRequest) SetSortBy(v string) *GetCategoriesRequest {
	s.SortBy = &v
	return s
}

func (s *GetCategoriesRequest) SetType(v string) *GetCategoriesRequest {
	s.Type = &v
	return s
}

type GetCategoriesResponseBody struct {
	// The ID of the category. Default value: **-1**, which indicates the parent category ID of a level 1 category.
	Category *GetCategoriesResponseBodyCategory `json:"Category,omitempty" xml:"Category,omitempty" type:"Struct"`
	// The type of the category. Valid values:
	//
	// *   **default** (default): default category
	// *   **material**: material category
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the request.
	SubCategories *GetCategoriesResponseBodySubCategories `json:"SubCategories,omitempty" xml:"SubCategories,omitempty" type:"Struct"`
	// The information about the specified category.
	SubTotal *int64 `json:"SubTotal,omitempty" xml:"SubTotal,omitempty"`
}

func (s GetCategoriesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetCategoriesResponseBody) GoString() string {
	return s.String()
}

func (s *GetCategoriesResponseBody) SetCategory(v *GetCategoriesResponseBodyCategory) *GetCategoriesResponseBody {
	s.Category = v
	return s
}

func (s *GetCategoriesResponseBody) SetRequestId(v string) *GetCategoriesResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetCategoriesResponseBody) SetSubCategories(v *GetCategoriesResponseBodySubCategories) *GetCategoriesResponseBody {
	s.SubCategories = v
	return s
}

func (s *GetCategoriesResponseBody) SetSubTotal(v int64) *GetCategoriesResponseBody {
	s.SubTotal = &v
	return s
}

type GetCategoriesResponseBodyCategory struct {
	// The ID of the video category.
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The ID of the parent category. The parent category ID of a level 1 category is **-1**.
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	// The name of the category.
	//
	// *   The value can be up to 64 bytes in length.
	// *   The string must be encoded in the UTF-8 format.
	Level *int64 `json:"Level,omitempty" xml:"Level,omitempty"`
	// The level of the category. A value of **0** indicates a level 1 category.
	ParentId *int64 `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
	// The total number of subcategories.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetCategoriesResponseBodyCategory) String() string {
	return tea.Prettify(s)
}

func (s GetCategoriesResponseBodyCategory) GoString() string {
	return s.String()
}

func (s *GetCategoriesResponseBodyCategory) SetCateId(v int64) *GetCategoriesResponseBodyCategory {
	s.CateId = &v
	return s
}

func (s *GetCategoriesResponseBodyCategory) SetCateName(v string) *GetCategoriesResponseBodyCategory {
	s.CateName = &v
	return s
}

func (s *GetCategoriesResponseBodyCategory) SetLevel(v int64) *GetCategoriesResponseBodyCategory {
	s.Level = &v
	return s
}

func (s *GetCategoriesResponseBodyCategory) SetParentId(v int64) *GetCategoriesResponseBodyCategory {
	s.ParentId = &v
	return s
}

func (s *GetCategoriesResponseBodyCategory) SetType(v string) *GetCategoriesResponseBodyCategory {
	s.Type = &v
	return s
}

type GetCategoriesResponseBodySubCategories struct {
	Category []*GetCategoriesResponseBodySubCategoriesCategory `json:"Category,omitempty" xml:"Category,omitempty" type:"Repeated"`
}

func (s GetCategoriesResponseBodySubCategories) String() string {
	return tea.Prettify(s)
}

func (s GetCategoriesResponseBodySubCategories) GoString() string {
	return s.String()
}

func (s *GetCategoriesResponseBodySubCategories) SetCategory(v []*GetCategoriesResponseBodySubCategoriesCategory) *GetCategoriesResponseBodySubCategories {
	s.Category = v
	return s
}

type GetCategoriesResponseBodySubCategoriesCategory struct {
	CateId   *int64  `json:"CateId,omitempty" xml:"CateId,omitempty"`
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	Level    *int64  `json:"Level,omitempty" xml:"Level,omitempty"`
	ParentId *int64  `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
	SubTotal *int64  `json:"SubTotal,omitempty" xml:"SubTotal,omitempty"`
	// Queries the information about the specified category and its subcategories.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetCategoriesResponseBodySubCategoriesCategory) String() string {
	return tea.Prettify(s)
}

func (s GetCategoriesResponseBodySubCategoriesCategory) GoString() string {
	return s.String()
}

func (s *GetCategoriesResponseBodySubCategoriesCategory) SetCateId(v int64) *GetCategoriesResponseBodySubCategoriesCategory {
	s.CateId = &v
	return s
}

func (s *GetCategoriesResponseBodySubCategoriesCategory) SetCateName(v string) *GetCategoriesResponseBodySubCategoriesCategory {
	s.CateName = &v
	return s
}

func (s *GetCategoriesResponseBodySubCategoriesCategory) SetLevel(v int64) *GetCategoriesResponseBodySubCategoriesCategory {
	s.Level = &v
	return s
}

func (s *GetCategoriesResponseBodySubCategoriesCategory) SetParentId(v int64) *GetCategoriesResponseBodySubCategoriesCategory {
	s.ParentId = &v
	return s
}

func (s *GetCategoriesResponseBodySubCategoriesCategory) SetSubTotal(v int64) *GetCategoriesResponseBodySubCategoriesCategory {
	s.SubTotal = &v
	return s
}

func (s *GetCategoriesResponseBodySubCategoriesCategory) SetType(v string) *GetCategoriesResponseBodySubCategoriesCategory {
	s.Type = &v
	return s
}

type GetCategoriesResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetCategoriesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetCategoriesResponse) String() string {
	return tea.Prettify(s)
}

func (s GetCategoriesResponse) GoString() string {
	return s.String()
}

func (s *GetCategoriesResponse) SetHeaders(v map[string]*string) *GetCategoriesResponse {
	s.Headers = v
	return s
}

func (s *GetCategoriesResponse) SetStatusCode(v int32) *GetCategoriesResponse {
	s.StatusCode = &v
	return s
}

func (s *GetCategoriesResponse) SetBody(v *GetCategoriesResponseBody) *GetCategoriesResponse {
	s.Body = v
	return s
}

type GetDefaultAITemplateRequest struct {
	// The source of the AI template. Valid values:
	//
	// *   **System**
	// *   **Custom**
	TemplateType *string `json:"TemplateType,omitempty" xml:"TemplateType,omitempty"`
}

func (s GetDefaultAITemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDefaultAITemplateRequest) GoString() string {
	return s.String()
}

func (s *GetDefaultAITemplateRequest) SetTemplateType(v string) *GetDefaultAITemplateRequest {
	s.TemplateType = &v
	return s
}

type GetDefaultAITemplateResponseBody struct {
	// The information about the AI template.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the AI template.
	TemplateInfo *GetDefaultAITemplateResponseBodyTemplateInfo `json:"TemplateInfo,omitempty" xml:"TemplateInfo,omitempty" type:"Struct"`
}

func (s GetDefaultAITemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDefaultAITemplateResponseBody) GoString() string {
	return s.String()
}

func (s *GetDefaultAITemplateResponseBody) SetRequestId(v string) *GetDefaultAITemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDefaultAITemplateResponseBody) SetTemplateInfo(v *GetDefaultAITemplateResponseBodyTemplateInfo) *GetDefaultAITemplateResponseBody {
	s.TemplateInfo = v
	return s
}

type GetDefaultAITemplateResponseBodyTemplateInfo struct {
	// The type of the AI template. The value is **AIMediaAudit**, which indicates automated review.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The time when the AI template was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	IsDefault  *string `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	ModifyTime *string `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	// Queries information about the default AI template.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The time when the AI template was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	TemplateConfig *string `json:"TemplateConfig,omitempty" xml:"TemplateConfig,omitempty"`
	TemplateId     *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The ID of the request.
	TemplateName *string `json:"TemplateName,omitempty" xml:"TemplateName,omitempty"`
	// Indicates whether the template is the default AI template. Valid values:
	//
	// *   **Default**
	// *   **NotDefault**
	TemplateType *string `json:"TemplateType,omitempty" xml:"TemplateType,omitempty"`
}

func (s GetDefaultAITemplateResponseBodyTemplateInfo) String() string {
	return tea.Prettify(s)
}

func (s GetDefaultAITemplateResponseBodyTemplateInfo) GoString() string {
	return s.String()
}

func (s *GetDefaultAITemplateResponseBodyTemplateInfo) SetCreationTime(v string) *GetDefaultAITemplateResponseBodyTemplateInfo {
	s.CreationTime = &v
	return s
}

func (s *GetDefaultAITemplateResponseBodyTemplateInfo) SetIsDefault(v string) *GetDefaultAITemplateResponseBodyTemplateInfo {
	s.IsDefault = &v
	return s
}

func (s *GetDefaultAITemplateResponseBodyTemplateInfo) SetModifyTime(v string) *GetDefaultAITemplateResponseBodyTemplateInfo {
	s.ModifyTime = &v
	return s
}

func (s *GetDefaultAITemplateResponseBodyTemplateInfo) SetSource(v string) *GetDefaultAITemplateResponseBodyTemplateInfo {
	s.Source = &v
	return s
}

func (s *GetDefaultAITemplateResponseBodyTemplateInfo) SetTemplateConfig(v string) *GetDefaultAITemplateResponseBodyTemplateInfo {
	s.TemplateConfig = &v
	return s
}

func (s *GetDefaultAITemplateResponseBodyTemplateInfo) SetTemplateId(v string) *GetDefaultAITemplateResponseBodyTemplateInfo {
	s.TemplateId = &v
	return s
}

func (s *GetDefaultAITemplateResponseBodyTemplateInfo) SetTemplateName(v string) *GetDefaultAITemplateResponseBodyTemplateInfo {
	s.TemplateName = &v
	return s
}

func (s *GetDefaultAITemplateResponseBodyTemplateInfo) SetTemplateType(v string) *GetDefaultAITemplateResponseBodyTemplateInfo {
	s.TemplateType = &v
	return s
}

type GetDefaultAITemplateResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDefaultAITemplateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDefaultAITemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDefaultAITemplateResponse) GoString() string {
	return s.String()
}

func (s *GetDefaultAITemplateResponse) SetHeaders(v map[string]*string) *GetDefaultAITemplateResponse {
	s.Headers = v
	return s
}

func (s *GetDefaultAITemplateResponse) SetStatusCode(v int32) *GetDefaultAITemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDefaultAITemplateResponse) SetBody(v *GetDefaultAITemplateResponseBody) *GetDefaultAITemplateResponse {
	s.Body = v
	return s
}

type GetEditingProjectRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The timeline of the online editing project.
	ProjectId            *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GetEditingProjectRequest) String() string {
	return tea.Prettify(s)
}

func (s GetEditingProjectRequest) GoString() string {
	return s.String()
}

func (s *GetEditingProjectRequest) SetOwnerAccount(v string) *GetEditingProjectRequest {
	s.OwnerAccount = &v
	return s
}

func (s *GetEditingProjectRequest) SetOwnerId(v string) *GetEditingProjectRequest {
	s.OwnerId = &v
	return s
}

func (s *GetEditingProjectRequest) SetProjectId(v string) *GetEditingProjectRequest {
	s.ProjectId = &v
	return s
}

func (s *GetEditingProjectRequest) SetResourceOwnerAccount(v string) *GetEditingProjectRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GetEditingProjectRequest) SetResourceOwnerId(v string) *GetEditingProjectRequest {
	s.ResourceOwnerId = &v
	return s
}

type GetEditingProjectResponseBody struct {
	// The region where the online editing project was created.
	Project *GetEditingProjectResponseBodyProject `json:"Project,omitempty" xml:"Project,omitempty" type:"Struct"`
	// The ID of the online editing project.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetEditingProjectResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetEditingProjectResponseBody) GoString() string {
	return s.String()
}

func (s *GetEditingProjectResponseBody) SetProject(v *GetEditingProjectResponseBodyProject) *GetEditingProjectResponseBody {
	s.Project = v
	return s
}

func (s *GetEditingProjectResponseBody) SetRequestId(v string) *GetEditingProjectResponseBody {
	s.RequestId = &v
	return s
}

type GetEditingProjectResponseBodyProject struct {
	// The ID of the request.
	CoverURL *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	// The title of the online editing project.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The time when the online editing project was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The information about the online editing project.
	ModifiedTime *string `json:"ModifiedTime,omitempty" xml:"ModifiedTime,omitempty"`
	// 58928
	ProjectId *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	RegionId  *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The path of the Object Storage Service (OSS) bucket where the online editing project is stored.
	//
	// > To view the path of the OSS bucket, log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com/?spm=a2c4g.11186623.2.15.6948257eaZ4m54#/vod/settings/censored), and choose **Configuration Management** > **Media Management** > **Storage**. On the Storage page, you can view the path of the OSS bucket.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the online editing project.
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	// 朴灵
	Timeline *string `json:"Timeline,omitempty" xml:"Timeline,omitempty"`
	Title    *string `json:"Title,omitempty" xml:"Title,omitempty"`
}

func (s GetEditingProjectResponseBodyProject) String() string {
	return tea.Prettify(s)
}

func (s GetEditingProjectResponseBodyProject) GoString() string {
	return s.String()
}

func (s *GetEditingProjectResponseBodyProject) SetCoverURL(v string) *GetEditingProjectResponseBodyProject {
	s.CoverURL = &v
	return s
}

func (s *GetEditingProjectResponseBodyProject) SetCreationTime(v string) *GetEditingProjectResponseBodyProject {
	s.CreationTime = &v
	return s
}

func (s *GetEditingProjectResponseBodyProject) SetDescription(v string) *GetEditingProjectResponseBodyProject {
	s.Description = &v
	return s
}

func (s *GetEditingProjectResponseBodyProject) SetModifiedTime(v string) *GetEditingProjectResponseBodyProject {
	s.ModifiedTime = &v
	return s
}

func (s *GetEditingProjectResponseBodyProject) SetProjectId(v string) *GetEditingProjectResponseBodyProject {
	s.ProjectId = &v
	return s
}

func (s *GetEditingProjectResponseBodyProject) SetRegionId(v string) *GetEditingProjectResponseBodyProject {
	s.RegionId = &v
	return s
}

func (s *GetEditingProjectResponseBodyProject) SetStatus(v string) *GetEditingProjectResponseBodyProject {
	s.Status = &v
	return s
}

func (s *GetEditingProjectResponseBodyProject) SetStorageLocation(v string) *GetEditingProjectResponseBodyProject {
	s.StorageLocation = &v
	return s
}

func (s *GetEditingProjectResponseBodyProject) SetTimeline(v string) *GetEditingProjectResponseBodyProject {
	s.Timeline = &v
	return s
}

func (s *GetEditingProjectResponseBodyProject) SetTitle(v string) *GetEditingProjectResponseBodyProject {
	s.Title = &v
	return s
}

type GetEditingProjectResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetEditingProjectResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetEditingProjectResponse) String() string {
	return tea.Prettify(s)
}

func (s GetEditingProjectResponse) GoString() string {
	return s.String()
}

func (s *GetEditingProjectResponse) SetHeaders(v map[string]*string) *GetEditingProjectResponse {
	s.Headers = v
	return s
}

func (s *GetEditingProjectResponse) SetStatusCode(v int32) *GetEditingProjectResponse {
	s.StatusCode = &v
	return s
}

func (s *GetEditingProjectResponse) SetBody(v *GetEditingProjectResponseBody) *GetEditingProjectResponse {
	s.Body = v
	return s
}

type GetEditingProjectMaterialsRequest struct {
	// The URLs of material snapshots. The value is an array.
	MaterialType *string `json:"MaterialType,omitempty" xml:"MaterialType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the online editing project. You can use one of the following methods to obtain the ID of the online editing project:
	//
	// *   Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Production Center** > **Video Editing** to obtain the ID of the specified online editing project.
	// *   Call the **AddEditingProject** operation. The value of the response parameter ProjectId is the ID of the specified online editing project.
	ProjectId            *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the material.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetEditingProjectMaterialsRequest) String() string {
	return tea.Prettify(s)
}

func (s GetEditingProjectMaterialsRequest) GoString() string {
	return s.String()
}

func (s *GetEditingProjectMaterialsRequest) SetMaterialType(v string) *GetEditingProjectMaterialsRequest {
	s.MaterialType = &v
	return s
}

func (s *GetEditingProjectMaterialsRequest) SetOwnerAccount(v string) *GetEditingProjectMaterialsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *GetEditingProjectMaterialsRequest) SetOwnerId(v string) *GetEditingProjectMaterialsRequest {
	s.OwnerId = &v
	return s
}

func (s *GetEditingProjectMaterialsRequest) SetProjectId(v string) *GetEditingProjectMaterialsRequest {
	s.ProjectId = &v
	return s
}

func (s *GetEditingProjectMaterialsRequest) SetResourceOwnerAccount(v string) *GetEditingProjectMaterialsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GetEditingProjectMaterialsRequest) SetResourceOwnerId(v string) *GetEditingProjectMaterialsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *GetEditingProjectMaterialsRequest) SetType(v string) *GetEditingProjectMaterialsRequest {
	s.Type = &v
	return s
}

type GetEditingProjectMaterialsResponseBody struct {
	// The duration of the material. The value is rounded to four decimal places. Unit: seconds.
	MaterialList *GetEditingProjectMaterialsResponseBodyMaterialList `json:"MaterialList,omitempty" xml:"MaterialList,omitempty" type:"Struct"`
	// The tag of the material. Multiple tags are separated by commas (,).
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetEditingProjectMaterialsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetEditingProjectMaterialsResponseBody) GoString() string {
	return s.String()
}

func (s *GetEditingProjectMaterialsResponseBody) SetMaterialList(v *GetEditingProjectMaterialsResponseBodyMaterialList) *GetEditingProjectMaterialsResponseBody {
	s.MaterialList = v
	return s
}

func (s *GetEditingProjectMaterialsResponseBody) SetRequestId(v string) *GetEditingProjectMaterialsResponseBody {
	s.RequestId = &v
	return s
}

type GetEditingProjectMaterialsResponseBodyMaterialList struct {
	Material []*GetEditingProjectMaterialsResponseBodyMaterialListMaterial `json:"Material,omitempty" xml:"Material,omitempty" type:"Repeated"`
}

func (s GetEditingProjectMaterialsResponseBodyMaterialList) String() string {
	return tea.Prettify(s)
}

func (s GetEditingProjectMaterialsResponseBodyMaterialList) GoString() string {
	return s.String()
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialList) SetMaterial(v []*GetEditingProjectMaterialsResponseBodyMaterialListMaterial) *GetEditingProjectMaterialsResponseBodyMaterialList {
	s.Material = v
	return s
}

type GetEditingProjectMaterialsResponseBodyMaterialListMaterial struct {
	// The thumbnail URL of the material.
	CateId *int32 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The category ID of the material.
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	CoverURL *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	// The type of the material. Valid values:
	//
	// *   **video**
	// *   **audio**
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// 58928
	Description *string  `json:"Description,omitempty" xml:"Description,omitempty"`
	Duration    *float32 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	MaterialId  *string  `json:"MaterialId,omitempty" xml:"MaterialId,omitempty"`
	// The type of the material. Valid values:
	//
	// *   **video**
	// *   **audio**
	// *   **image**
	MaterialType *string `json:"MaterialType,omitempty" xml:"MaterialType,omitempty"`
	// Queries materials to be edited for an online editing project.
	ModifiedTime *string                                                              `json:"ModifiedTime,omitempty" xml:"ModifiedTime,omitempty"`
	Size         *int64                                                               `json:"Size,omitempty" xml:"Size,omitempty"`
	Snapshots    *GetEditingProjectMaterialsResponseBodyMaterialListMaterialSnapshots `json:"Snapshots,omitempty" xml:"Snapshots,omitempty" type:"Struct"`
	// The time when the material was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The URLs of material sprites. The value is an array.
	SpriteConfig *string                                                            `json:"SpriteConfig,omitempty" xml:"SpriteConfig,omitempty"`
	Sprites      *GetEditingProjectMaterialsResponseBodyMaterialListMaterialSprites `json:"Sprites,omitempty" xml:"Sprites,omitempty" type:"Struct"`
	// The configuration of the sprite.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the material. Valid values:
	//
	// *   **video**
	// *   **audio**
	// *   **image**
	Tags  *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
}

func (s GetEditingProjectMaterialsResponseBodyMaterialListMaterial) String() string {
	return tea.Prettify(s)
}

func (s GetEditingProjectMaterialsResponseBodyMaterialListMaterial) GoString() string {
	return s.String()
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetCateId(v int32) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.CateId = &v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetCateName(v string) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.CateName = &v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetCoverURL(v string) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.CoverURL = &v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetCreationTime(v string) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.CreationTime = &v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetDescription(v string) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.Description = &v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetDuration(v float32) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.Duration = &v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetMaterialId(v string) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.MaterialId = &v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetMaterialType(v string) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.MaterialType = &v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetModifiedTime(v string) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.ModifiedTime = &v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetSize(v int64) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.Size = &v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetSnapshots(v *GetEditingProjectMaterialsResponseBodyMaterialListMaterialSnapshots) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.Snapshots = v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetSource(v string) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.Source = &v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetSpriteConfig(v string) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.SpriteConfig = &v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetSprites(v *GetEditingProjectMaterialsResponseBodyMaterialListMaterialSprites) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.Sprites = v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetStatus(v string) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.Status = &v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetTags(v string) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.Tags = &v
	return s
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterial) SetTitle(v string) *GetEditingProjectMaterialsResponseBodyMaterialListMaterial {
	s.Title = &v
	return s
}

type GetEditingProjectMaterialsResponseBodyMaterialListMaterialSnapshots struct {
	Snapshot []*string `json:"Snapshot,omitempty" xml:"Snapshot,omitempty" type:"Repeated"`
}

func (s GetEditingProjectMaterialsResponseBodyMaterialListMaterialSnapshots) String() string {
	return tea.Prettify(s)
}

func (s GetEditingProjectMaterialsResponseBodyMaterialListMaterialSnapshots) GoString() string {
	return s.String()
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterialSnapshots) SetSnapshot(v []*string) *GetEditingProjectMaterialsResponseBodyMaterialListMaterialSnapshots {
	s.Snapshot = v
	return s
}

type GetEditingProjectMaterialsResponseBodyMaterialListMaterialSprites struct {
	Sprite []*string `json:"Sprite,omitempty" xml:"Sprite,omitempty" type:"Repeated"`
}

func (s GetEditingProjectMaterialsResponseBodyMaterialListMaterialSprites) String() string {
	return tea.Prettify(s)
}

func (s GetEditingProjectMaterialsResponseBodyMaterialListMaterialSprites) GoString() string {
	return s.String()
}

func (s *GetEditingProjectMaterialsResponseBodyMaterialListMaterialSprites) SetSprite(v []*string) *GetEditingProjectMaterialsResponseBodyMaterialListMaterialSprites {
	s.Sprite = v
	return s
}

type GetEditingProjectMaterialsResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetEditingProjectMaterialsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetEditingProjectMaterialsResponse) String() string {
	return tea.Prettify(s)
}

func (s GetEditingProjectMaterialsResponse) GoString() string {
	return s.String()
}

func (s *GetEditingProjectMaterialsResponse) SetHeaders(v map[string]*string) *GetEditingProjectMaterialsResponse {
	s.Headers = v
	return s
}

func (s *GetEditingProjectMaterialsResponse) SetStatusCode(v int32) *GetEditingProjectMaterialsResponse {
	s.StatusCode = &v
	return s
}

func (s *GetEditingProjectMaterialsResponse) SetBody(v *GetEditingProjectMaterialsResponseBody) *GetEditingProjectMaterialsResponse {
	s.Body = v
	return s
}

type GetImageInfoRequest struct {
	// The validity period of the image URL. Unit: seconds.
	//
	// > *   If the OutputType parameter is set to **cdn**:
	// >     *   The image URL has a validity period only if URL signing is enabled. Otherwise, the image URL is permanently valid.
	// >     *   Minimum value: **1**.
	// >     *   Maximum value: unlimited.
	// >     *   Default value: If you do not set this parameter, the default validity period that is specified in URL signing is used.
	// > *   If the OutputType parameter is set to **oss**:
	// >     *   The image URL has a validity period only if the permissions on the Object Storage Service (OSS) bucket are private. Otherwise, the image URL is permanently valid.
	// >     *   Minimum value: **1**.
	// >     *   Maximum value: **2592000** (30 days). The maximum value is limited to reduce security risks of the origin.
	// >     *   Default value: If you do not set this parameter, the default value is **3600**.
	AuthTimeout *int64 `json:"AuthTimeout,omitempty" xml:"AuthTimeout,omitempty"`
	// The ID of the image.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The type of the image URL. Valid values:
	//
	// *   **oss**: OSS URL
	// *   **cdn** (default): Content Delivery Network (CDN) URL
	OutputType *string `json:"OutputType,omitempty" xml:"OutputType,omitempty"`
}

func (s GetImageInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s GetImageInfoRequest) GoString() string {
	return s.String()
}

func (s *GetImageInfoRequest) SetAuthTimeout(v int64) *GetImageInfoRequest {
	s.AuthTimeout = &v
	return s
}

func (s *GetImageInfoRequest) SetImageId(v string) *GetImageInfoRequest {
	s.ImageId = &v
	return s
}

func (s *GetImageInfoRequest) SetOutputType(v string) *GetImageInfoRequest {
	s.OutputType = &v
	return s
}

type GetImageInfoResponseBody struct {
	// The information about the image.
	ImageInfo *GetImageInfoResponseBodyImageInfo `json:"ImageInfo,omitempty" xml:"ImageInfo,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetImageInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetImageInfoResponseBody) GoString() string {
	return s.String()
}

func (s *GetImageInfoResponseBody) SetImageInfo(v *GetImageInfoResponseBodyImageInfo) *GetImageInfoResponseBody {
	s.ImageInfo = v
	return s
}

func (s *GetImageInfoResponseBody) SetRequestId(v string) *GetImageInfoResponseBody {
	s.RequestId = &v
	return s
}

type GetImageInfoResponseBodyImageInfo struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the category.
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The name of the category.
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	// The time when the image file was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the image.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the image.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The type of the image. Valid values:
	//
	// - **CoverSnapshot**: thumbnail snapshot.
	// - **NormalSnapshot**: normal snapshot.
	// - **SpriteSnapshot**: sprite snapshot.
	// - **SpriteOriginSnapshot**: sprite source snapshot.
	// - **All**: images of all the preceding types. If this parameter is not set to All, you can specify multiple types and separate them with commas (,).
	ImageType *string `json:"ImageType,omitempty" xml:"ImageType,omitempty"`
	// The information about the image mezzanine file.
	Mezzanine *GetImageInfoResponseBodyImageInfoMezzanine `json:"Mezzanine,omitempty" xml:"Mezzanine,omitempty" type:"Struct"`
	// The status of the image. Valid values:
	//
	// - **Uploading**: The image is being uploaded. This is the initial status.
	// - **Normal**: The image is uploaded.
	// - **UploadFail**: The image fails to be uploaded.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The OSS bucket where the image is stored.
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	// The tag of the image. Multiple tags are separated by commas (,).
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The title of the image.
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The URL of the image. If a CDN domain name is specified, a CDN URL is returned. Otherwise, an OSS URL is returned.
	URL *string `json:"URL,omitempty" xml:"URL,omitempty"`
}

func (s GetImageInfoResponseBodyImageInfo) String() string {
	return tea.Prettify(s)
}

func (s GetImageInfoResponseBodyImageInfo) GoString() string {
	return s.String()
}

func (s *GetImageInfoResponseBodyImageInfo) SetAppId(v string) *GetImageInfoResponseBodyImageInfo {
	s.AppId = &v
	return s
}

func (s *GetImageInfoResponseBodyImageInfo) SetCateId(v int64) *GetImageInfoResponseBodyImageInfo {
	s.CateId = &v
	return s
}

func (s *GetImageInfoResponseBodyImageInfo) SetCateName(v string) *GetImageInfoResponseBodyImageInfo {
	s.CateName = &v
	return s
}

func (s *GetImageInfoResponseBodyImageInfo) SetCreationTime(v string) *GetImageInfoResponseBodyImageInfo {
	s.CreationTime = &v
	return s
}

func (s *GetImageInfoResponseBodyImageInfo) SetDescription(v string) *GetImageInfoResponseBodyImageInfo {
	s.Description = &v
	return s
}

func (s *GetImageInfoResponseBodyImageInfo) SetImageId(v string) *GetImageInfoResponseBodyImageInfo {
	s.ImageId = &v
	return s
}

func (s *GetImageInfoResponseBodyImageInfo) SetImageType(v string) *GetImageInfoResponseBodyImageInfo {
	s.ImageType = &v
	return s
}

func (s *GetImageInfoResponseBodyImageInfo) SetMezzanine(v *GetImageInfoResponseBodyImageInfoMezzanine) *GetImageInfoResponseBodyImageInfo {
	s.Mezzanine = v
	return s
}

func (s *GetImageInfoResponseBodyImageInfo) SetStatus(v string) *GetImageInfoResponseBodyImageInfo {
	s.Status = &v
	return s
}

func (s *GetImageInfoResponseBodyImageInfo) SetStorageLocation(v string) *GetImageInfoResponseBodyImageInfo {
	s.StorageLocation = &v
	return s
}

func (s *GetImageInfoResponseBodyImageInfo) SetTags(v string) *GetImageInfoResponseBodyImageInfo {
	s.Tags = &v
	return s
}

func (s *GetImageInfoResponseBodyImageInfo) SetTitle(v string) *GetImageInfoResponseBodyImageInfo {
	s.Title = &v
	return s
}

func (s *GetImageInfoResponseBodyImageInfo) SetURL(v string) *GetImageInfoResponseBodyImageInfo {
	s.URL = &v
	return s
}

type GetImageInfoResponseBodyImageInfoMezzanine struct {
	// The size of the file. Unit: byte.
	FileSize *string `json:"FileSize,omitempty" xml:"FileSize,omitempty"`
	// The OSS URL of the image.
	FileURL *string `json:"FileURL,omitempty" xml:"FileURL,omitempty"`
	// The height of the image. Unit: pixel.
	Height *int32 `json:"Height,omitempty" xml:"Height,omitempty"`
	// The name of the uploaded file.
	OriginalFileName *string `json:"OriginalFileName,omitempty" xml:"OriginalFileName,omitempty"`
	// The width of the image. Unit: pixel.
	Width *int32 `json:"Width,omitempty" xml:"Width,omitempty"`
}

func (s GetImageInfoResponseBodyImageInfoMezzanine) String() string {
	return tea.Prettify(s)
}

func (s GetImageInfoResponseBodyImageInfoMezzanine) GoString() string {
	return s.String()
}

func (s *GetImageInfoResponseBodyImageInfoMezzanine) SetFileSize(v string) *GetImageInfoResponseBodyImageInfoMezzanine {
	s.FileSize = &v
	return s
}

func (s *GetImageInfoResponseBodyImageInfoMezzanine) SetFileURL(v string) *GetImageInfoResponseBodyImageInfoMezzanine {
	s.FileURL = &v
	return s
}

func (s *GetImageInfoResponseBodyImageInfoMezzanine) SetHeight(v int32) *GetImageInfoResponseBodyImageInfoMezzanine {
	s.Height = &v
	return s
}

func (s *GetImageInfoResponseBodyImageInfoMezzanine) SetOriginalFileName(v string) *GetImageInfoResponseBodyImageInfoMezzanine {
	s.OriginalFileName = &v
	return s
}

func (s *GetImageInfoResponseBodyImageInfoMezzanine) SetWidth(v int32) *GetImageInfoResponseBodyImageInfoMezzanine {
	s.Width = &v
	return s
}

type GetImageInfoResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetImageInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetImageInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s GetImageInfoResponse) GoString() string {
	return s.String()
}

func (s *GetImageInfoResponse) SetHeaders(v map[string]*string) *GetImageInfoResponse {
	s.Headers = v
	return s
}

func (s *GetImageInfoResponse) SetStatusCode(v int32) *GetImageInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *GetImageInfoResponse) SetBody(v *GetImageInfoResponseBody) *GetImageInfoResponse {
	s.Body = v
	return s
}

type GetImageInfosRequest struct {
	// The time when the image URL expires. Unit: seconds.
	//
	// *   If the OutputType parameter is set to cdn:
	//
	//     *   This parameter takes effect only if URL authentication is enabled. Otherwise, the image URL does not expire.
	//     *   Minimum value: 1.
	//     *   Maximum value: unlimited.
	//     *   Default value: The default validity period that is specified in URL authentication is used.
	//
	// *   If the OutputType parameter is set to oss:
	//
	//     *   This parameter takes effect only when the ACL of the Object Storage Service (OSS) bucket is private. Otherwise, the image URL does not expire.
	//     *   Minimum value: 1.
	//     *   Maximum value: 2592000 (30 days). This limit is imposed to reduce security risks of the origin server.
	//     *   Default value: 3600.
	AuthTimeout *int64 `json:"AuthTimeout,omitempty" xml:"AuthTimeout,omitempty"`
	// The image IDs. Separate multiple IDs with commas (,). You can specify a maximum of 20 image IDs. You can use one of the following methods to obtain the image ID:
	//
	// *   Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com/) and choose Media Files > Images in the left-side navigation pane. This method is applicable to images that are uploaded by using the ApsaraVideo VOD console.
	// *   Obtain the value of ImageId from the response to the [CreateUploadImage](~~436544~~) operation that you call to obtain the upload URL and credential.
	// *   Obtain the value of ImageId from the response to the [SearchMedia](~~436559~~) operation after you upload images.
	ImageIds *string `json:"ImageIds,omitempty" xml:"ImageIds,omitempty"`
	// The type of the output image URL. Valid values:
	//
	// *   oss: OSS URL
	// *   cdn: CDN URL
	OutputType *string `json:"OutputType,omitempty" xml:"OutputType,omitempty"`
}

func (s GetImageInfosRequest) String() string {
	return tea.Prettify(s)
}

func (s GetImageInfosRequest) GoString() string {
	return s.String()
}

func (s *GetImageInfosRequest) SetAuthTimeout(v int64) *GetImageInfosRequest {
	s.AuthTimeout = &v
	return s
}

func (s *GetImageInfosRequest) SetImageIds(v string) *GetImageInfosRequest {
	s.ImageIds = &v
	return s
}

func (s *GetImageInfosRequest) SetOutputType(v string) *GetImageInfosRequest {
	s.OutputType = &v
	return s
}

type GetImageInfosResponseBody struct {
	// The image information.
	ImageInfo []*GetImageInfosResponseBodyImageInfo `json:"ImageInfo,omitempty" xml:"ImageInfo,omitempty" type:"Repeated"`
	// The IDs of the images that do not exist.
	NonExistImageIds []*string `json:"NonExistImageIds,omitempty" xml:"NonExistImageIds,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetImageInfosResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetImageInfosResponseBody) GoString() string {
	return s.String()
}

func (s *GetImageInfosResponseBody) SetImageInfo(v []*GetImageInfosResponseBodyImageInfo) *GetImageInfosResponseBody {
	s.ImageInfo = v
	return s
}

func (s *GetImageInfosResponseBody) SetNonExistImageIds(v []*string) *GetImageInfosResponseBody {
	s.NonExistImageIds = v
	return s
}

func (s *GetImageInfosResponseBody) SetRequestId(v string) *GetImageInfosResponseBody {
	s.RequestId = &v
	return s
}

type GetImageInfosResponseBodyImageInfo struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the category to which the image belongs.
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The name of the category.
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	// The time when the image was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the image.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the image file.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The type of the image. Valid values:
	//
	// *   **CoverSnapshot**: thumbnail snapshot
	// *   **NormalSnapshot**: normal snapshot
	// *   **SpriteSnapshot**: sprite snapshot
	// *   **SpriteOriginSnapshot**: sprite source snapshot
	// *   **All**: images of all the preceding types. If this parameter is not set to All, you can specify multiple types and separate the types with commas (,).
	ImageType *string `json:"ImageType,omitempty" xml:"ImageType,omitempty"`
	// The source information about the image.
	Mezzanine *GetImageInfosResponseBodyImageInfoMezzanine `json:"Mezzanine,omitempty" xml:"Mezzanine,omitempty" type:"Struct"`
	// The status of the image file. Valid values:
	//
	// *   **Uploading**: The image is being uploaded. This is the initial status.
	// *   **Normal**: The image is uploaded.
	// *   **UploadFail**: The image fails to be uploaded.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The bucket in which the image is stored.
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	// The tags of the image. Separate multiple tags with commas (,).
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The title of the image.
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The image URL. If a domain name for CDN is specified, a CDN URL is returned. Otherwise, an OSS URL is returned.
	URL *string `json:"URL,omitempty" xml:"URL,omitempty"`
}

func (s GetImageInfosResponseBodyImageInfo) String() string {
	return tea.Prettify(s)
}

func (s GetImageInfosResponseBodyImageInfo) GoString() string {
	return s.String()
}

func (s *GetImageInfosResponseBodyImageInfo) SetAppId(v string) *GetImageInfosResponseBodyImageInfo {
	s.AppId = &v
	return s
}

func (s *GetImageInfosResponseBodyImageInfo) SetCateId(v int64) *GetImageInfosResponseBodyImageInfo {
	s.CateId = &v
	return s
}

func (s *GetImageInfosResponseBodyImageInfo) SetCateName(v string) *GetImageInfosResponseBodyImageInfo {
	s.CateName = &v
	return s
}

func (s *GetImageInfosResponseBodyImageInfo) SetCreationTime(v string) *GetImageInfosResponseBodyImageInfo {
	s.CreationTime = &v
	return s
}

func (s *GetImageInfosResponseBodyImageInfo) SetDescription(v string) *GetImageInfosResponseBodyImageInfo {
	s.Description = &v
	return s
}

func (s *GetImageInfosResponseBodyImageInfo) SetImageId(v string) *GetImageInfosResponseBodyImageInfo {
	s.ImageId = &v
	return s
}

func (s *GetImageInfosResponseBodyImageInfo) SetImageType(v string) *GetImageInfosResponseBodyImageInfo {
	s.ImageType = &v
	return s
}

func (s *GetImageInfosResponseBodyImageInfo) SetMezzanine(v *GetImageInfosResponseBodyImageInfoMezzanine) *GetImageInfosResponseBodyImageInfo {
	s.Mezzanine = v
	return s
}

func (s *GetImageInfosResponseBodyImageInfo) SetStatus(v string) *GetImageInfosResponseBodyImageInfo {
	s.Status = &v
	return s
}

func (s *GetImageInfosResponseBodyImageInfo) SetStorageLocation(v string) *GetImageInfosResponseBodyImageInfo {
	s.StorageLocation = &v
	return s
}

func (s *GetImageInfosResponseBodyImageInfo) SetTags(v string) *GetImageInfosResponseBodyImageInfo {
	s.Tags = &v
	return s
}

func (s *GetImageInfosResponseBodyImageInfo) SetTitle(v string) *GetImageInfosResponseBodyImageInfo {
	s.Title = &v
	return s
}

func (s *GetImageInfosResponseBodyImageInfo) SetURL(v string) *GetImageInfosResponseBodyImageInfo {
	s.URL = &v
	return s
}

type GetImageInfosResponseBodyImageInfoMezzanine struct {
	// The size of the image file. Unit: bytes.
	FileSize *string `json:"FileSize,omitempty" xml:"FileSize,omitempty"`
	// The OSS URL of the image file.
	FileURL *string `json:"FileURL,omitempty" xml:"FileURL,omitempty"`
	// The height of the image. Unit: pixels.
	Height *int32 `json:"Height,omitempty" xml:"Height,omitempty"`
	// The name of the source file.
	OriginalFileName *string `json:"OriginalFileName,omitempty" xml:"OriginalFileName,omitempty"`
	// The width of the image. Unit: pixels.
	Width *int32 `json:"Width,omitempty" xml:"Width,omitempty"`
}

func (s GetImageInfosResponseBodyImageInfoMezzanine) String() string {
	return tea.Prettify(s)
}

func (s GetImageInfosResponseBodyImageInfoMezzanine) GoString() string {
	return s.String()
}

func (s *GetImageInfosResponseBodyImageInfoMezzanine) SetFileSize(v string) *GetImageInfosResponseBodyImageInfoMezzanine {
	s.FileSize = &v
	return s
}

func (s *GetImageInfosResponseBodyImageInfoMezzanine) SetFileURL(v string) *GetImageInfosResponseBodyImageInfoMezzanine {
	s.FileURL = &v
	return s
}

func (s *GetImageInfosResponseBodyImageInfoMezzanine) SetHeight(v int32) *GetImageInfosResponseBodyImageInfoMezzanine {
	s.Height = &v
	return s
}

func (s *GetImageInfosResponseBodyImageInfoMezzanine) SetOriginalFileName(v string) *GetImageInfosResponseBodyImageInfoMezzanine {
	s.OriginalFileName = &v
	return s
}

func (s *GetImageInfosResponseBodyImageInfoMezzanine) SetWidth(v int32) *GetImageInfosResponseBodyImageInfoMezzanine {
	s.Width = &v
	return s
}

type GetImageInfosResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetImageInfosResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetImageInfosResponse) String() string {
	return tea.Prettify(s)
}

func (s GetImageInfosResponse) GoString() string {
	return s.String()
}

func (s *GetImageInfosResponse) SetHeaders(v map[string]*string) *GetImageInfosResponse {
	s.Headers = v
	return s
}

func (s *GetImageInfosResponse) SetStatusCode(v int32) *GetImageInfosResponse {
	s.StatusCode = &v
	return s
}

func (s *GetImageInfosResponse) SetBody(v *GetImageInfosResponseBody) *GetImageInfosResponse {
	s.Body = v
	return s
}

type GetMediaAuditAudioResultDetailRequest struct {
	// The end time of the audio that failed the review. Unit: seconds.
	MediaId      *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// Details of review results.
	PageNo               *int32  `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GetMediaAuditAudioResultDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditAudioResultDetailRequest) GoString() string {
	return s.String()
}

func (s *GetMediaAuditAudioResultDetailRequest) SetMediaId(v string) *GetMediaAuditAudioResultDetailRequest {
	s.MediaId = &v
	return s
}

func (s *GetMediaAuditAudioResultDetailRequest) SetOwnerAccount(v string) *GetMediaAuditAudioResultDetailRequest {
	s.OwnerAccount = &v
	return s
}

func (s *GetMediaAuditAudioResultDetailRequest) SetOwnerId(v string) *GetMediaAuditAudioResultDetailRequest {
	s.OwnerId = &v
	return s
}

func (s *GetMediaAuditAudioResultDetailRequest) SetPageNo(v int32) *GetMediaAuditAudioResultDetailRequest {
	s.PageNo = &v
	return s
}

func (s *GetMediaAuditAudioResultDetailRequest) SetResourceOwnerAccount(v string) *GetMediaAuditAudioResultDetailRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GetMediaAuditAudioResultDetailRequest) SetResourceOwnerId(v string) *GetMediaAuditAudioResultDetailRequest {
	s.ResourceOwnerId = &v
	return s
}

type GetMediaAuditAudioResultDetailResponseBody struct {
	// The page number of the returned page.
	MediaAuditAudioResultDetail *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetail `json:"MediaAuditAudioResultDetail,omitempty" xml:"MediaAuditAudioResultDetail,omitempty" type:"Struct"`
	// The number of the page to return. This parameter is optional. If you do not specify this parameter, all results are returned without pagination.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetMediaAuditAudioResultDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditAudioResultDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetMediaAuditAudioResultDetailResponseBody) SetMediaAuditAudioResultDetail(v *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetail) *GetMediaAuditAudioResultDetailResponseBody {
	s.MediaAuditAudioResultDetail = v
	return s
}

func (s *GetMediaAuditAudioResultDetailResponseBody) SetRequestId(v string) *GetMediaAuditAudioResultDetailResponseBody {
	s.RequestId = &v
	return s
}

type GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetail struct {
	// The text that corresponds to the audio.
	List []*GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList `json:"List,omitempty" xml:"List,omitempty" type:"Repeated"`
	// The operation that you want to perform. Set the value to **GetMediaAuditAudioResultDetail**.
	PageTotal *int32 `json:"PageTotal,omitempty" xml:"PageTotal,omitempty"`
	// The ID of the request.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetail) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetail) GoString() string {
	return s.String()
}

func (s *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetail) SetList(v []*GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList) *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetail {
	s.List = v
	return s
}

func (s *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetail) SetPageTotal(v int32) *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetail {
	s.PageTotal = &v
	return s
}

func (s *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetail) SetTotal(v int32) *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetail {
	s.Total = &v
	return s
}

type GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList struct {
	// The list of results.
	EndTime *int64  `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	Label   *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// Queries the details of audio review results.
	StartTime *int64  `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	Text      *string `json:"Text,omitempty" xml:"Text,omitempty"`
}

func (s GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList) GoString() string {
	return s.String()
}

func (s *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList) SetEndTime(v int64) *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList {
	s.EndTime = &v
	return s
}

func (s *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList) SetLabel(v string) *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList {
	s.Label = &v
	return s
}

func (s *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList) SetStartTime(v int64) *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList {
	s.StartTime = &v
	return s
}

func (s *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList) SetText(v string) *GetMediaAuditAudioResultDetailResponseBodyMediaAuditAudioResultDetailList {
	s.Text = &v
	return s
}

type GetMediaAuditAudioResultDetailResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetMediaAuditAudioResultDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetMediaAuditAudioResultDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditAudioResultDetailResponse) GoString() string {
	return s.String()
}

func (s *GetMediaAuditAudioResultDetailResponse) SetHeaders(v map[string]*string) *GetMediaAuditAudioResultDetailResponse {
	s.Headers = v
	return s
}

func (s *GetMediaAuditAudioResultDetailResponse) SetStatusCode(v int32) *GetMediaAuditAudioResultDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMediaAuditAudioResultDetailResponse) SetBody(v *GetMediaAuditAudioResultDetailResponseBody) *GetMediaAuditAudioResultDetailResponse {
	s.Body = v
	return s
}

type GetMediaAuditResultRequest struct {
	// The operation that you want to perform. Set the value to **GetMediaAuditResult**.
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
}

func (s GetMediaAuditResultRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultRequest) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultRequest) SetMediaId(v string) *GetMediaAuditResultRequest {
	s.MediaId = &v
	return s
}

type GetMediaAuditResultResponseBody struct {
	// The URL of the image.
	MediaAuditResult *GetMediaAuditResultResponseBodyMediaAuditResult `json:"MediaAuditResult,omitempty" xml:"MediaAuditResult,omitempty" type:"Struct"`
	// The URL of the image.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetMediaAuditResultResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBody) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBody) SetMediaAuditResult(v *GetMediaAuditResultResponseBodyMediaAuditResult) *GetMediaAuditResultResponseBody {
	s.MediaAuditResult = v
	return s
}

func (s *GetMediaAuditResultResponseBody) SetRequestId(v string) *GetMediaAuditResultResponseBody {
	s.RequestId = &v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResult struct {
	// The ID of the video or image.
	AbnormalModules *string `json:"AbnormalModules,omitempty" xml:"AbnormalModules,omitempty"`
	// The category of the review result. Valid values:
	//
	// - **porn**
	// - **sexy**
	// - **normal**
	AudioResult []*GetMediaAuditResultResponseBodyMediaAuditResultAudioResult `json:"AudioResult,omitempty" xml:"AudioResult,omitempty" type:"Repeated"`
	// The average score of the review results.
	ImageResult []*GetMediaAuditResultResponseBodyMediaAuditResultImageResult `json:"ImageResult,omitempty" xml:"ImageResult,omitempty" type:"Repeated"`
	// The number of frames.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The URL of the image.
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The information about the image with the highest score of the category that is indicated by Label.
	TextResult []*GetMediaAuditResultResponseBodyMediaAuditResultTextResult `json:"TextResult,omitempty" xml:"TextResult,omitempty" type:"Repeated"`
	// The recommendation for review results. Valid values:
	//
	// - **block**
	// - **review**
	// - **pass**
	VideoResult *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult `json:"VideoResult,omitempty" xml:"VideoResult,omitempty" type:"Struct"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResult) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResult) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResult) SetAbnormalModules(v string) *GetMediaAuditResultResponseBodyMediaAuditResult {
	s.AbnormalModules = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResult) SetAudioResult(v []*GetMediaAuditResultResponseBodyMediaAuditResultAudioResult) *GetMediaAuditResultResponseBodyMediaAuditResult {
	s.AudioResult = v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResult) SetImageResult(v []*GetMediaAuditResultResponseBodyMediaAuditResultImageResult) *GetMediaAuditResultResponseBodyMediaAuditResult {
	s.ImageResult = v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResult) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResult {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResult) SetSuggestion(v string) *GetMediaAuditResultResponseBodyMediaAuditResult {
	s.Suggestion = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResult) SetTextResult(v []*GetMediaAuditResultResponseBodyMediaAuditResultTextResult) *GetMediaAuditResultResponseBodyMediaAuditResult {
	s.TextResult = v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResult) SetVideoResult(v *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult) *GetMediaAuditResultResponseBodyMediaAuditResult {
	s.VideoResult = v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultAudioResult struct {
	// The statistics about tag frames.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The results of undesired content review.
	Scene *string `json:"Scene,omitempty" xml:"Scene,omitempty"`
	// The results of video review.
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The category of the review result. Valid values:
	//
	// - **ad**
	// - **normal**
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultAudioResult) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultAudioResult) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultAudioResult) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultAudioResult {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultAudioResult) SetScene(v string) *GetMediaAuditResultResponseBodyMediaAuditResultAudioResult {
	s.Scene = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultAudioResult) SetScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultAudioResult {
	s.Score = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultAudioResult) SetSuggestion(v string) *GetMediaAuditResultResponseBodyMediaAuditResultAudioResult {
	s.Suggestion = &v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultImageResult struct {
	// The recommendation for review results. Valid values:
	//
	// - **block**
	// - **review**
	// - **pass**
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The URL of the image.
	Result []*GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	// The results of ad review.
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The score.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The type of the image. The value is **cover**.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultImageResult) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultImageResult) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultImageResult) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultImageResult {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultImageResult) SetResult(v []*GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult) *GetMediaAuditResultResponseBodyMediaAuditResultImageResult {
	s.Result = v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultImageResult) SetSuggestion(v string) *GetMediaAuditResultResponseBodyMediaAuditResultImageResult {
	s.Suggestion = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultImageResult) SetType(v string) *GetMediaAuditResultResponseBodyMediaAuditResultImageResult {
	s.Type = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultImageResult) SetUrl(v string) *GetMediaAuditResultResponseBodyMediaAuditResultImageResult {
	s.Url = &v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult struct {
	// The highest review score.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The category of the review result. Valid values:
	//
	// - **normal**
	// - **bloody**
	// - **explosion**
	// - **outfit**
	// - **logo**
	// - **weapon**
	// - **politics**
	// - **violence**
	// - **crowd**
	// - **parade**
	// - **carcrash**
	// - **flag**
	// - **location**
	// - **others**
	Scene *string `json:"Scene,omitempty" xml:"Scene,omitempty"`
	// The recommendation for review results. Valid values:
	//
	// *   **block**
	// *   **review**
	// *   **pass**
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The category of the review result.
	//
	// - **ad**
	// - **normal**
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult) SetScene(v string) *GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult {
	s.Scene = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult) SetScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult {
	s.Score = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult) SetSuggestion(v string) *GetMediaAuditResultResponseBodyMediaAuditResultImageResultResult {
	s.Suggestion = &v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultTextResult struct {
	// The category of the review result. Valid values:
	//
	// - **live**: The content contains undesirable scenes.
	// - **normal**: normal content.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The statistics about tag frames.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The position in the video. Unit: milliseconds.
	Scene *string `json:"Scene,omitempty" xml:"Scene,omitempty"`
	// The recommendation for review results. Valid values:
	//
	// *   **block**
	// *   **review**
	// *   **pass**
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The category of the review result. Separate multiple values with commas (,). Valid values:
	//
	// *   **porn**
	// *   **terrorism**
	// *   **normal**
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The results of terrorist content review.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultTextResult) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultTextResult) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultTextResult) SetContent(v string) *GetMediaAuditResultResponseBodyMediaAuditResultTextResult {
	s.Content = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultTextResult) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultTextResult {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultTextResult) SetScene(v string) *GetMediaAuditResultResponseBodyMediaAuditResultTextResult {
	s.Scene = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultTextResult) SetScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultTextResult {
	s.Score = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultTextResult) SetSuggestion(v string) *GetMediaAuditResultResponseBodyMediaAuditResultTextResult {
	s.Suggestion = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultTextResult) SetType(v string) *GetMediaAuditResultResponseBodyMediaAuditResultTextResult {
	s.Type = &v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResult struct {
	// The URL of the image.
	AdResult *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult `json:"AdResult,omitempty" xml:"AdResult,omitempty" type:"Struct"`
	// Details of image review results.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The category of the review result. Valid values:
	//
	// - **normal**
	// - **bloody**
	// - **explosion**
	// - **outfit**
	// - **logo**
	// - **weapon**
	// - **politics**
	// - **violence**
	// - **crowd**
	// - **parade**
	// - **carcrash**
	// - **flag**
	// - **location**
	// - **others**
	LiveResult *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult `json:"LiveResult,omitempty" xml:"LiveResult,omitempty" type:"Struct"`
	// The recommendation for review results.
	LogoResult *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult `json:"LogoResult,omitempty" xml:"LogoResult,omitempty" type:"Struct"`
	// The average score of the review results.
	PornResult *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult `json:"PornResult,omitempty" xml:"PornResult,omitempty" type:"Struct"`
	// The category of the review result.
	//
	// - **logo**
	// - **normal**
	Suggestion      *string                                                                    `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	TerrorismResult *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult `json:"TerrorismResult,omitempty" xml:"TerrorismResult,omitempty" type:"Struct"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResult) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResult) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult) SetAdResult(v *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult {
	s.AdResult = v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult) SetLiveResult(v *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult {
	s.LiveResult = v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult) SetLogoResult(v *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult {
	s.LogoResult = v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult) SetPornResult(v *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult {
	s.PornResult = v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult) SetSuggestion(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult {
	s.Suggestion = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult) SetTerrorismResult(v *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResult {
	s.TerrorismResult = v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult struct {
	// The category of the review result. Separate multiple values with commas (,). Valid values:
	//
	// *   **porn**
	// *   **terrorism**
	// *   **normal**
	AverageScore *string `json:"AverageScore,omitempty" xml:"AverageScore,omitempty"`
	// The highest review score.
	CounterList []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultCounterList `json:"CounterList,omitempty" xml:"CounterList,omitempty" type:"Repeated"`
	// The highest review score.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The information about the image with the highest score of the category that is indicated by Label.
	MaxScore *string `json:"MaxScore,omitempty" xml:"MaxScore,omitempty"`
	// The average score of the review results.
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The review scenario. The value is **antispam**.
	TopList []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList `json:"TopList,omitempty" xml:"TopList,omitempty" type:"Repeated"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult) SetAverageScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult {
	s.AverageScore = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult) SetCounterList(v []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultCounterList) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult {
	s.CounterList = v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult) SetMaxScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult {
	s.MaxScore = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult) SetSuggestion(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult {
	s.Suggestion = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult) SetTopList(v []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResult {
	s.TopList = v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultCounterList struct {
	// The statistics about tag frames.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The average score of the review results.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultCounterList) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultCounterList) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultCounterList) SetCount(v int32) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultCounterList {
	s.Count = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultCounterList) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultCounterList {
	s.Label = &v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList struct {
	// The score of the image of the category that is indicated by Label.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The recommendation for review results. Valid values:
	//
	// - **block**
	// - **review**
	// - **pass**
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The score of the image of the category that is indicated by Label.
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	// The statistics about tag frames.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList) SetScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList {
	s.Score = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList) SetTimestamp(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList {
	s.Timestamp = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList) SetUrl(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultAdResultTopList {
	s.Url = &v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult struct {
	// The category of the review result. Valid values:
	//
	// - **ad**
	// - **normal**
	AverageScore *string `json:"AverageScore,omitempty" xml:"AverageScore,omitempty"`
	// The category of the review result. Valid values:
	//
	// - **spam**
	// - **ad**
	// - **abuse**
	// - **flood**
	// - **contraband**
	// - **meaningless**
	// - **normal**
	CounterList []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultCounterList `json:"CounterList,omitempty" xml:"CounterList,omitempty" type:"Repeated"`
	// The results of image review.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The category of the review result. Valid values:
	//
	// - **porn**
	// - **sexy**
	// - **normal**
	MaxScore *string `json:"MaxScore,omitempty" xml:"MaxScore,omitempty"`
	// The number of frames.
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The category of the review result. Valid values:
	//
	// - **logo**
	// - **normal**
	TopList []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList `json:"TopList,omitempty" xml:"TopList,omitempty" type:"Repeated"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult) SetAverageScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult {
	s.AverageScore = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult) SetCounterList(v []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultCounterList) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult {
	s.CounterList = v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult) SetMaxScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult {
	s.MaxScore = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult) SetSuggestion(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult {
	s.Suggestion = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult) SetTopList(v []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResult {
	s.TopList = v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultCounterList struct {
	// The ID of the request.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The score of the image of the category that is indicated by Label.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultCounterList) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultCounterList) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultCounterList) SetCount(v int32) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultCounterList {
	s.Count = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultCounterList) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultCounterList {
	s.Label = &v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList struct {
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// Queries the summary of automated review results.
	Score     *string `json:"Score,omitempty" xml:"Score,omitempty"`
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	// The category of the review result. Separate multiple values with commas (,). Valid values:
	//
	// - **porn**
	// - **terrorism**
	// - **normal**
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList) SetScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList {
	s.Score = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList) SetTimestamp(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList {
	s.Timestamp = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList) SetUrl(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLiveResultTopList {
	s.Url = &v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult struct {
	// The average score of the review results.
	AverageScore *string `json:"AverageScore,omitempty" xml:"AverageScore,omitempty"`
	// The text content for review.
	CounterList []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultCounterList `json:"CounterList,omitempty" xml:"CounterList,omitempty" type:"Repeated"`
	// The score of the image of the category that is indicated by Label.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The information about the image with the highest score of the category that is indicated by Label.
	MaxScore *string `json:"MaxScore,omitempty" xml:"MaxScore,omitempty"`
	// The number of frames.
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The category of the review result. Valid values:
	//
	// - **logo**
	// - **normal**
	TopList []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList `json:"TopList,omitempty" xml:"TopList,omitempty" type:"Repeated"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult) SetAverageScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult {
	s.AverageScore = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult) SetCounterList(v []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultCounterList) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult {
	s.CounterList = v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult) SetMaxScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult {
	s.MaxScore = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult) SetSuggestion(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult {
	s.Suggestion = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult) SetTopList(v []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResult {
	s.TopList = v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultCounterList struct {
	// The type of the text. The value is **title**.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The results of logo review.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultCounterList) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultCounterList) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultCounterList) SetCount(v int32) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultCounterList {
	s.Count = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultCounterList) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultCounterList {
	s.Label = &v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList struct {
	// The score of the image of the category that is indicated by Label.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The recommendation for review results. Valid values:
	//
	// *   **block**
	// *   **review**
	// *   **pass**
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The category of the review result. Valid values:
	//
	// - **live**: The content contains undesirable scenes.
	// - **normal**: normal content.
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	// The number of frames.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList) SetScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList {
	s.Score = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList) SetTimestamp(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList {
	s.Timestamp = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList) SetUrl(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultLogoResultTopList {
	s.Url = &v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult struct {
	// The category of the review result. Valid values:
	//
	// - **live**: The content contains undesirable scenes.
	// - **normal**: normal content.
	AverageScore *string `json:"AverageScore,omitempty" xml:"AverageScore,omitempty"`
	// The category of the review result. Valid values:
	//
	// - **porn**
	// - **sexy**
	// - **normal**
	CounterList []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultCounterList `json:"CounterList,omitempty" xml:"CounterList,omitempty" type:"Repeated"`
	// The review scenario. Valid values:
	//
	// *   **terrorism**
	// *   **porn**
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The information about the image with the highest score of the category that is indicated by Label.
	MaxScore *string `json:"MaxScore,omitempty" xml:"MaxScore,omitempty"`
	// The position in the video. Unit: milliseconds.
	Suggestion *string `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	// The score of the image of the category that is indicated by Label.
	TopList []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList `json:"TopList,omitempty" xml:"TopList,omitempty" type:"Repeated"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult) SetAverageScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult {
	s.AverageScore = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult) SetCounterList(v []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultCounterList) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult {
	s.CounterList = v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult) SetMaxScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult {
	s.MaxScore = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult) SetSuggestion(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult {
	s.Suggestion = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult) SetTopList(v []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResult {
	s.TopList = v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultCounterList struct {
	// The highest review score.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The recommendation for review results. Valid values:
	//
	// - **block**
	// - **review**
	// - **pass**
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultCounterList) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultCounterList) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultCounterList) SetCount(v int32) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultCounterList {
	s.Count = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultCounterList) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultCounterList {
	s.Label = &v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList struct {
	// The results of text review.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The recommendation for review results. Valid values:
	//
	// *   **block**
	// *   **review**
	// *   **pass**
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The position in the video. Unit: milliseconds.
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	// The category of the review result.
	//
	// Valid values if scene is **porn**:
	//
	// *   **porn**
	// *   **sexy**
	// *   **normal**
	//
	// Valid values if scene is **terrorism**:
	//
	// *   **normal**
	// *   **bloody**
	// *   **explosion**
	// *   **outfit**
	// *   **logo**
	// *   **weapon**
	// *   **politics**
	// *   **violence**
	// *   **crowd**
	// *   **parade**
	// *   **carcrash**
	// *   **flag**
	// *   **location**
	// *   **others**
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList) SetScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList {
	s.Score = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList) SetTimestamp(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList {
	s.Timestamp = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList) SetUrl(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultPornResultTopList {
	s.Url = &v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult struct {
	AverageScore *string                                                                                 `json:"AverageScore,omitempty" xml:"AverageScore,omitempty"`
	CounterList  []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultCounterList `json:"CounterList,omitempty" xml:"CounterList,omitempty" type:"Repeated"`
	Label        *string                                                                                 `json:"Label,omitempty" xml:"Label,omitempty"`
	MaxScore     *string                                                                                 `json:"MaxScore,omitempty" xml:"MaxScore,omitempty"`
	Suggestion   *string                                                                                 `json:"Suggestion,omitempty" xml:"Suggestion,omitempty"`
	TopList      []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList     `json:"TopList,omitempty" xml:"TopList,omitempty" type:"Repeated"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult) SetAverageScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult {
	s.AverageScore = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult) SetCounterList(v []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultCounterList) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult {
	s.CounterList = v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult) SetMaxScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult {
	s.MaxScore = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult) SetSuggestion(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult {
	s.Suggestion = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult) SetTopList(v []*GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResult {
	s.TopList = v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultCounterList struct {
	Count *int32  `json:"Count,omitempty" xml:"Count,omitempty"`
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultCounterList) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultCounterList) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultCounterList) SetCount(v int32) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultCounterList {
	s.Count = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultCounterList) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultCounterList {
	s.Label = &v
	return s
}

type GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList struct {
	Label     *string `json:"Label,omitempty" xml:"Label,omitempty"`
	Score     *string `json:"Score,omitempty" xml:"Score,omitempty"`
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	Url       *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList) SetLabel(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList) SetScore(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList {
	s.Score = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList) SetTimestamp(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList {
	s.Timestamp = &v
	return s
}

func (s *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList) SetUrl(v string) *GetMediaAuditResultResponseBodyMediaAuditResultVideoResultTerrorismResultTopList {
	s.Url = &v
	return s
}

type GetMediaAuditResultResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetMediaAuditResultResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetMediaAuditResultResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultResponse) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultResponse) SetHeaders(v map[string]*string) *GetMediaAuditResultResponse {
	s.Headers = v
	return s
}

func (s *GetMediaAuditResultResponse) SetStatusCode(v int32) *GetMediaAuditResultResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMediaAuditResultResponse) SetBody(v *GetMediaAuditResultResponseBody) *GetMediaAuditResultResponse {
	s.Body = v
	return s
}

type GetMediaAuditResultDetailRequest struct {
	// The category of the pornographic content review result. Valid values:
	//
	// *   **normal**
	// *   **porn**
	// *   **sexy**
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The score of the review result category. It is representative of the confidence. Valid values: `[0.00-100.00].` The value is rounded down to 10 decimal places.
	PageNo *int32 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
}

func (s GetMediaAuditResultDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultDetailRequest) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultDetailRequest) SetMediaId(v string) *GetMediaAuditResultDetailRequest {
	s.MediaId = &v
	return s
}

func (s *GetMediaAuditResultDetailRequest) SetPageNo(v int32) *GetMediaAuditResultDetailRequest {
	s.PageNo = &v
	return s
}

type GetMediaAuditResultDetailResponseBody struct {
	// The total number of snapshots returned.
	MediaAuditResultDetail *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetail `json:"MediaAuditResultDetail,omitempty" xml:"MediaAuditResultDetail,omitempty" type:"Struct"`
	// The category of the terrorist content review result.
	//
	// *   **normal**: normal
	// *   **terrorism**: terrorist content
	// *   **outfit**: special costume
	// *   **logo**: special logo
	// *   **weapon**: weapon
	// *   **politics**: politically sensitive content
	// *   **others**: other terrorist content and politically sensitive content
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetMediaAuditResultDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultDetailResponseBody) SetMediaAuditResultDetail(v *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetail) *GetMediaAuditResultDetailResponseBody {
	s.MediaAuditResultDetail = v
	return s
}

func (s *GetMediaAuditResultDetailResponseBody) SetRequestId(v string) *GetMediaAuditResultDetailResponseBody {
	s.RequestId = &v
	return s
}

type GetMediaAuditResultDetailResponseBodyMediaAuditResultDetail struct {
	// The operation that you want to perform. Set the value to **GetMediaAuditResultDetail**.
	List []*GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList `json:"List,omitempty" xml:"List,omitempty" type:"Repeated"`
	// The score of the review result category. It is representative of the confidence. Valid values: `[0.00-100.00].` The value is rounded down to 10 decimal places.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s GetMediaAuditResultDetailResponseBodyMediaAuditResultDetail) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultDetailResponseBodyMediaAuditResultDetail) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetail) SetList(v []*GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList) *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetail {
	s.List = v
	return s
}

func (s *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetail) SetTotal(v int32) *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetail {
	s.Total = &v
	return s
}

type GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList struct {
	// The score of the review result category. It is representative of the confidence. Valid values: `[0.00-100.00].` The value is rounded down to 10 decimal places.
	AdLabel *string `json:"AdLabel,omitempty" xml:"AdLabel,omitempty"`
	// The ID of the request.
	AdScore *string `json:"AdScore,omitempty" xml:"AdScore,omitempty"`
	// The position in the video. Unit: milliseconds.
	LiveLabel *string `json:"LiveLabel,omitempty" xml:"LiveLabel,omitempty"`
	LiveScore *string `json:"LiveScore,omitempty" xml:"LiveScore,omitempty"`
	LogoLabel *string `json:"LogoLabel,omitempty" xml:"LogoLabel,omitempty"`
	LogoScore *string `json:"LogoScore,omitempty" xml:"LogoScore,omitempty"`
	// The ID of the video.
	PornLabel *string `json:"PornLabel,omitempty" xml:"PornLabel,omitempty"`
	// The category of the logo review result. Valid values:
	//
	// *   **normal**
	// *   **tlogo**
	PornScore      *string `json:"PornScore,omitempty" xml:"PornScore,omitempty"`
	TerrorismLabel *string `json:"TerrorismLabel,omitempty" xml:"TerrorismLabel,omitempty"`
	// The URL of the image.
	TerrorismScore *string `json:"TerrorismScore,omitempty" xml:"TerrorismScore,omitempty"`
	// The review results returned.
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	// The category of the ad review result. Valid values:
	//
	// *   **normal**: normal content
	// *   **ad**: ad or text violation
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList) SetAdLabel(v string) *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList {
	s.AdLabel = &v
	return s
}

func (s *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList) SetAdScore(v string) *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList {
	s.AdScore = &v
	return s
}

func (s *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList) SetLiveLabel(v string) *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList {
	s.LiveLabel = &v
	return s
}

func (s *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList) SetLiveScore(v string) *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList {
	s.LiveScore = &v
	return s
}

func (s *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList) SetLogoLabel(v string) *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList {
	s.LogoLabel = &v
	return s
}

func (s *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList) SetLogoScore(v string) *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList {
	s.LogoScore = &v
	return s
}

func (s *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList) SetPornLabel(v string) *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList {
	s.PornLabel = &v
	return s
}

func (s *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList) SetPornScore(v string) *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList {
	s.PornScore = &v
	return s
}

func (s *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList) SetTerrorismLabel(v string) *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList {
	s.TerrorismLabel = &v
	return s
}

func (s *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList) SetTerrorismScore(v string) *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList {
	s.TerrorismScore = &v
	return s
}

func (s *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList) SetTimestamp(v string) *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList {
	s.Timestamp = &v
	return s
}

func (s *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList) SetUrl(v string) *GetMediaAuditResultDetailResponseBodyMediaAuditResultDetailList {
	s.Url = &v
	return s
}

type GetMediaAuditResultDetailResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetMediaAuditResultDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetMediaAuditResultDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultDetailResponse) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultDetailResponse) SetHeaders(v map[string]*string) *GetMediaAuditResultDetailResponse {
	s.Headers = v
	return s
}

func (s *GetMediaAuditResultDetailResponse) SetStatusCode(v int32) *GetMediaAuditResultDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMediaAuditResultDetailResponse) SetBody(v *GetMediaAuditResultDetailResponseBody) *GetMediaAuditResultDetailResponse {
	s.Body = v
	return s
}

type GetMediaAuditResultTimelineRequest struct {
	// The category of the review result. Valid values:
	//
	// *   **normal**
	// *   **logo**
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
}

func (s GetMediaAuditResultTimelineRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultTimelineRequest) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultTimelineRequest) SetMediaId(v string) *GetMediaAuditResultTimelineRequest {
	s.MediaId = &v
	return s
}

type GetMediaAuditResultTimelineResponseBody struct {
	// The position in the video. Unit: milliseconds.
	MediaAuditResultTimeline *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline `json:"MediaAuditResultTimeline,omitempty" xml:"MediaAuditResultTimeline,omitempty" type:"Struct"`
	// The position in the video. Unit: milliseconds.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetMediaAuditResultTimelineResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultTimelineResponseBody) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultTimelineResponseBody) SetMediaAuditResultTimeline(v *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline) *GetMediaAuditResultTimelineResponseBody {
	s.MediaAuditResultTimeline = v
	return s
}

func (s *GetMediaAuditResultTimelineResponseBody) SetRequestId(v string) *GetMediaAuditResultTimelineResponseBody {
	s.RequestId = &v
	return s
}

type GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline struct {
	Ad []*GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineAd `json:"Ad,omitempty" xml:"Ad,omitempty" type:"Repeated"`
	// Queries the timelines of all snapshots that violate content regulations.
	Live []*GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLive `json:"Live,omitempty" xml:"Live,omitempty" type:"Repeated"`
	// The score of the review result category. Valid values: `[0, 100]`. The value is rounded down to 10 decimal places. The score is representative of the confidence.
	Logo []*GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLogo `json:"Logo,omitempty" xml:"Logo,omitempty" type:"Repeated"`
	// The score of the review result category. Valid values: `[0, 100]`. The value is rounded down to 10 decimal places. The score is representative of the confidence.
	Porn []*GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelinePorn `json:"Porn,omitempty" xml:"Porn,omitempty" type:"Repeated"`
	// The ID of the video.
	Terrorism []*GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineTerrorism `json:"Terrorism,omitempty" xml:"Terrorism,omitempty" type:"Repeated"`
}

func (s GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline) SetAd(v []*GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineAd) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline {
	s.Ad = v
	return s
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline) SetLive(v []*GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLive) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline {
	s.Live = v
	return s
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline) SetLogo(v []*GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLogo) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline {
	s.Logo = v
	return s
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline) SetPorn(v []*GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelinePorn) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline {
	s.Porn = v
	return s
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline) SetTerrorism(v []*GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineTerrorism) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimeline {
	s.Terrorism = v
	return s
}

type GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineAd struct {
	Label     *string `json:"Label,omitempty" xml:"Label,omitempty"`
	Score     *string `json:"Score,omitempty" xml:"Score,omitempty"`
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
}

func (s GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineAd) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineAd) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineAd) SetLabel(v string) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineAd {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineAd) SetScore(v string) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineAd {
	s.Score = &v
	return s
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineAd) SetTimestamp(v string) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineAd {
	s.Timestamp = &v
	return s
}

type GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLive struct {
	Label     *string `json:"Label,omitempty" xml:"Label,omitempty"`
	Score     *string `json:"Score,omitempty" xml:"Score,omitempty"`
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
}

func (s GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLive) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLive) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLive) SetLabel(v string) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLive {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLive) SetScore(v string) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLive {
	s.Score = &v
	return s
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLive) SetTimestamp(v string) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLive {
	s.Timestamp = &v
	return s
}

type GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLogo struct {
	// The ID of the request.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The category of the review result. Valid values:
	//
	// *   **normal**: normal content
	// *   **ad**: ad or text violation
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The score of the review result category. Valid values: `[0, 100]`. The value is rounded down to 10 decimal places. The score is representative of the confidence.
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
}

func (s GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLogo) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLogo) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLogo) SetLabel(v string) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLogo {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLogo) SetScore(v string) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLogo {
	s.Score = &v
	return s
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLogo) SetTimestamp(v string) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineLogo {
	s.Timestamp = &v
	return s
}

type GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelinePorn struct {
	// The collection of logo timelines.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The category of the review result. Valid values:
	//
	// *   **normal**
	// *   **terrorism**
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The operation that you want to perform. Set the value to **GetMediaAuditResultTimeline**.
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
}

func (s GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelinePorn) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelinePorn) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelinePorn) SetLabel(v string) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelinePorn {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelinePorn) SetScore(v string) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelinePorn {
	s.Score = &v
	return s
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelinePorn) SetTimestamp(v string) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelinePorn {
	s.Timestamp = &v
	return s
}

type GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineTerrorism struct {
	// The collection of pornographic content timelines.
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	// The collection of review result timelines.
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The collection of undesirable scene timelines.
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
}

func (s GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineTerrorism) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineTerrorism) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineTerrorism) SetLabel(v string) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineTerrorism {
	s.Label = &v
	return s
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineTerrorism) SetScore(v string) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineTerrorism {
	s.Score = &v
	return s
}

func (s *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineTerrorism) SetTimestamp(v string) *GetMediaAuditResultTimelineResponseBodyMediaAuditResultTimelineTerrorism {
	s.Timestamp = &v
	return s
}

type GetMediaAuditResultTimelineResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetMediaAuditResultTimelineResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetMediaAuditResultTimelineResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMediaAuditResultTimelineResponse) GoString() string {
	return s.String()
}

func (s *GetMediaAuditResultTimelineResponse) SetHeaders(v map[string]*string) *GetMediaAuditResultTimelineResponse {
	s.Headers = v
	return s
}

func (s *GetMediaAuditResultTimelineResponse) SetStatusCode(v int32) *GetMediaAuditResultTimelineResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMediaAuditResultTimelineResponse) SetBody(v *GetMediaAuditResultTimelineResponseBody) *GetMediaAuditResultTimelineResponse {
	s.Body = v
	return s
}

type GetMediaDNAResultRequest struct {
	// The ID of the video.
	MediaId              *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GetMediaDNAResultRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMediaDNAResultRequest) GoString() string {
	return s.String()
}

func (s *GetMediaDNAResultRequest) SetMediaId(v string) *GetMediaDNAResultRequest {
	s.MediaId = &v
	return s
}

func (s *GetMediaDNAResultRequest) SetOwnerAccount(v string) *GetMediaDNAResultRequest {
	s.OwnerAccount = &v
	return s
}

func (s *GetMediaDNAResultRequest) SetOwnerId(v string) *GetMediaDNAResultRequest {
	s.OwnerId = &v
	return s
}

func (s *GetMediaDNAResultRequest) SetResourceOwnerAccount(v string) *GetMediaDNAResultRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GetMediaDNAResultRequest) SetResourceOwnerId(v string) *GetMediaDNAResultRequest {
	s.ResourceOwnerId = &v
	return s
}

type GetMediaDNAResultResponseBody struct {
	// The similarity between the fingerprints of the input video and the matched video. 1 indicates that the fingerprints of the two videos are the same.
	DNAResult *GetMediaDNAResultResponseBodyDNAResult `json:"DNAResult,omitempty" xml:"DNAResult,omitempty" type:"Struct"`
	// The start time of the video. Unit: seconds.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetMediaDNAResultResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMediaDNAResultResponseBody) GoString() string {
	return s.String()
}

func (s *GetMediaDNAResultResponseBody) SetDNAResult(v *GetMediaDNAResultResponseBodyDNAResult) *GetMediaDNAResultResponseBody {
	s.DNAResult = v
	return s
}

func (s *GetMediaDNAResultResponseBody) SetRequestId(v string) *GetMediaDNAResultResponseBody {
	s.RequestId = &v
	return s
}

type GetMediaDNAResultResponseBodyDNAResult struct {
	// The media fingerprinting results.
	VideoDNA []*GetMediaDNAResultResponseBodyDNAResultVideoDNA `json:"VideoDNA,omitempty" xml:"VideoDNA,omitempty" type:"Repeated"`
}

func (s GetMediaDNAResultResponseBodyDNAResult) String() string {
	return tea.Prettify(s)
}

func (s GetMediaDNAResultResponseBodyDNAResult) GoString() string {
	return s.String()
}

func (s *GetMediaDNAResultResponseBodyDNAResult) SetVideoDNA(v []*GetMediaDNAResultResponseBodyDNAResultVideoDNA) *GetMediaDNAResultResponseBodyDNAResult {
	s.VideoDNA = v
	return s
}

type GetMediaDNAResultResponseBodyDNAResultVideoDNA struct {
	// The duration of the video. Unit: seconds.
	Detail []*GetMediaDNAResultResponseBodyDNAResultVideoDNADetail `json:"Detail,omitempty" xml:"Detail,omitempty" type:"Repeated"`
	// The start time and duration of the input video.
	PrimaryKey *string `json:"PrimaryKey,omitempty" xml:"PrimaryKey,omitempty"`
	// The video fingerprint recognition result.
	Similarity *string `json:"Similarity,omitempty" xml:"Similarity,omitempty"`
}

func (s GetMediaDNAResultResponseBodyDNAResultVideoDNA) String() string {
	return tea.Prettify(s)
}

func (s GetMediaDNAResultResponseBodyDNAResultVideoDNA) GoString() string {
	return s.String()
}

func (s *GetMediaDNAResultResponseBodyDNAResultVideoDNA) SetDetail(v []*GetMediaDNAResultResponseBodyDNAResultVideoDNADetail) *GetMediaDNAResultResponseBodyDNAResultVideoDNA {
	s.Detail = v
	return s
}

func (s *GetMediaDNAResultResponseBodyDNAResultVideoDNA) SetPrimaryKey(v string) *GetMediaDNAResultResponseBodyDNAResultVideoDNA {
	s.PrimaryKey = &v
	return s
}

func (s *GetMediaDNAResultResponseBodyDNAResultVideoDNA) SetSimilarity(v string) *GetMediaDNAResultResponseBodyDNAResultVideoDNA {
	s.Similarity = &v
	return s
}

type GetMediaDNAResultResponseBodyDNAResultVideoDNADetail struct {
	// Queries a media fingerprinting result. After a media fingerprinting job is complete, you can call this operation to query the media fingerprinting result.
	Duplication *GetMediaDNAResultResponseBodyDNAResultVideoDNADetailDuplication `json:"Duplication,omitempty" xml:"Duplication,omitempty" type:"Struct"`
	// The ID of the request.
	Input *GetMediaDNAResultResponseBodyDNAResultVideoDNADetailInput `json:"Input,omitempty" xml:"Input,omitempty" type:"Struct"`
}

func (s GetMediaDNAResultResponseBodyDNAResultVideoDNADetail) String() string {
	return tea.Prettify(s)
}

func (s GetMediaDNAResultResponseBodyDNAResultVideoDNADetail) GoString() string {
	return s.String()
}

func (s *GetMediaDNAResultResponseBodyDNAResultVideoDNADetail) SetDuplication(v *GetMediaDNAResultResponseBodyDNAResultVideoDNADetailDuplication) *GetMediaDNAResultResponseBodyDNAResultVideoDNADetail {
	s.Duplication = v
	return s
}

func (s *GetMediaDNAResultResponseBodyDNAResultVideoDNADetail) SetInput(v *GetMediaDNAResultResponseBodyDNAResultVideoDNADetailInput) *GetMediaDNAResultResponseBodyDNAResultVideoDNADetail {
	s.Input = v
	return s
}

type GetMediaDNAResultResponseBodyDNAResultVideoDNADetailDuplication struct {
	Duration *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	Start    *string `json:"Start,omitempty" xml:"Start,omitempty"`
}

func (s GetMediaDNAResultResponseBodyDNAResultVideoDNADetailDuplication) String() string {
	return tea.Prettify(s)
}

func (s GetMediaDNAResultResponseBodyDNAResultVideoDNADetailDuplication) GoString() string {
	return s.String()
}

func (s *GetMediaDNAResultResponseBodyDNAResultVideoDNADetailDuplication) SetDuration(v string) *GetMediaDNAResultResponseBodyDNAResultVideoDNADetailDuplication {
	s.Duration = &v
	return s
}

func (s *GetMediaDNAResultResponseBodyDNAResultVideoDNADetailDuplication) SetStart(v string) *GetMediaDNAResultResponseBodyDNAResultVideoDNADetailDuplication {
	s.Start = &v
	return s
}

type GetMediaDNAResultResponseBodyDNAResultVideoDNADetailInput struct {
	// The start time of the video. Unit: seconds.
	Duration *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The duration of the video. Unit: seconds.
	Start *string `json:"Start,omitempty" xml:"Start,omitempty"`
}

func (s GetMediaDNAResultResponseBodyDNAResultVideoDNADetailInput) String() string {
	return tea.Prettify(s)
}

func (s GetMediaDNAResultResponseBodyDNAResultVideoDNADetailInput) GoString() string {
	return s.String()
}

func (s *GetMediaDNAResultResponseBodyDNAResultVideoDNADetailInput) SetDuration(v string) *GetMediaDNAResultResponseBodyDNAResultVideoDNADetailInput {
	s.Duration = &v
	return s
}

func (s *GetMediaDNAResultResponseBodyDNAResultVideoDNADetailInput) SetStart(v string) *GetMediaDNAResultResponseBodyDNAResultVideoDNADetailInput {
	s.Start = &v
	return s
}

type GetMediaDNAResultResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetMediaDNAResultResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetMediaDNAResultResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMediaDNAResultResponse) GoString() string {
	return s.String()
}

func (s *GetMediaDNAResultResponse) SetHeaders(v map[string]*string) *GetMediaDNAResultResponse {
	s.Headers = v
	return s
}

func (s *GetMediaDNAResultResponse) SetStatusCode(v int32) *GetMediaDNAResultResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMediaDNAResultResponse) SetBody(v *GetMediaDNAResultResponseBody) *GetMediaDNAResultResponse {
	s.Body = v
	return s
}

type GetMediaRefreshJobsRequest struct {
	// The ID of the media file. It is the value of the `MediaIds` parameter that you specify when you call the [RefreshMediaPlayUrls](~~RefreshMediaPlayUrls~~) operation. You can specify only one media ID.
	//
	// If you leave this parameter empty, information about all media files in the refresh or prefetch job specified by `MediaRefreshJobId` is returned. If you set this parameter, only the information about the specified media file is returned.``
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The ID of the refresh or prefetch job. It is the value of the MediaRefreshJobId parameter that is returned from the call to the [RefreshMediaPlayUrls](~~RefreshMediaPlayUrls~~) operation.
	MediaRefreshJobId *string `json:"MediaRefreshJobId,omitempty" xml:"MediaRefreshJobId,omitempty"`
}

func (s GetMediaRefreshJobsRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMediaRefreshJobsRequest) GoString() string {
	return s.String()
}

func (s *GetMediaRefreshJobsRequest) SetMediaId(v string) *GetMediaRefreshJobsRequest {
	s.MediaId = &v
	return s
}

func (s *GetMediaRefreshJobsRequest) SetMediaRefreshJobId(v string) *GetMediaRefreshJobsRequest {
	s.MediaRefreshJobId = &v
	return s
}

type GetMediaRefreshJobsResponseBody struct {
	// The media refresh or prefetch jobs.
	MediaRefreshJobs []*GetMediaRefreshJobsResponseBodyMediaRefreshJobs `json:"MediaRefreshJobs,omitempty" xml:"MediaRefreshJobs,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetMediaRefreshJobsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMediaRefreshJobsResponseBody) GoString() string {
	return s.String()
}

func (s *GetMediaRefreshJobsResponseBody) SetMediaRefreshJobs(v []*GetMediaRefreshJobsResponseBodyMediaRefreshJobs) *GetMediaRefreshJobsResponseBody {
	s.MediaRefreshJobs = v
	return s
}

func (s *GetMediaRefreshJobsResponseBody) SetRequestId(v string) *GetMediaRefreshJobsResponseBody {
	s.RequestId = &v
	return s
}

type GetMediaRefreshJobsResponseBodyMediaRefreshJobs struct {
	// The error code. This parameter is returned if the refresh or prefetch task fails.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message. This parameter is returned if the refresh or prefetch task fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The filtering conditions for stream playback. The value is a JSON string. This parameter is used as a request parameter of the [RefreshMediaPlayUrls](~~RefreshMediaPlayUrls~~) operation.
	FilterPolicy *string `json:"FilterPolicy,omitempty" xml:"FilterPolicy,omitempty"`
	// The time when the task was created.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The time when the task was modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the media file.
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The ID of the job.
	MediaRefreshJobId *string `json:"MediaRefreshJobId,omitempty" xml:"MediaRefreshJobId,omitempty"`
	// The status of the job. Valid values:
	//
	// *   **success**
	// *   **fail**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The playback URLs that were refreshed or prefetched.
	SuccessPlayUrls *string `json:"SuccessPlayUrls,omitempty" xml:"SuccessPlayUrls,omitempty"`
	// The IDs of the refresh or prefetch tasks for the playback URLs of media files. Only one URL can be refreshed or prefetched in a task. This value is used in the [DescribeVodRefreshTasks](~~DescribeVodRefreshTasks~~) operation, which queries the status of refresh or prefetch tasks for playback URLs of media files.
	TaskIds *string `json:"TaskIds,omitempty" xml:"TaskIds,omitempty"`
	// The type of the job. Valid values:
	//
	// *   **Refresh**
	// *   **Preload**
	TaskType *string `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
	// The user data that you passed when you submit a refresh or prefetch task.
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
}

func (s GetMediaRefreshJobsResponseBodyMediaRefreshJobs) String() string {
	return tea.Prettify(s)
}

func (s GetMediaRefreshJobsResponseBodyMediaRefreshJobs) GoString() string {
	return s.String()
}

func (s *GetMediaRefreshJobsResponseBodyMediaRefreshJobs) SetErrorCode(v string) *GetMediaRefreshJobsResponseBodyMediaRefreshJobs {
	s.ErrorCode = &v
	return s
}

func (s *GetMediaRefreshJobsResponseBodyMediaRefreshJobs) SetErrorMessage(v string) *GetMediaRefreshJobsResponseBodyMediaRefreshJobs {
	s.ErrorMessage = &v
	return s
}

func (s *GetMediaRefreshJobsResponseBodyMediaRefreshJobs) SetFilterPolicy(v string) *GetMediaRefreshJobsResponseBodyMediaRefreshJobs {
	s.FilterPolicy = &v
	return s
}

func (s *GetMediaRefreshJobsResponseBodyMediaRefreshJobs) SetGmtCreate(v string) *GetMediaRefreshJobsResponseBodyMediaRefreshJobs {
	s.GmtCreate = &v
	return s
}

func (s *GetMediaRefreshJobsResponseBodyMediaRefreshJobs) SetGmtModified(v string) *GetMediaRefreshJobsResponseBodyMediaRefreshJobs {
	s.GmtModified = &v
	return s
}

func (s *GetMediaRefreshJobsResponseBodyMediaRefreshJobs) SetMediaId(v string) *GetMediaRefreshJobsResponseBodyMediaRefreshJobs {
	s.MediaId = &v
	return s
}

func (s *GetMediaRefreshJobsResponseBodyMediaRefreshJobs) SetMediaRefreshJobId(v string) *GetMediaRefreshJobsResponseBodyMediaRefreshJobs {
	s.MediaRefreshJobId = &v
	return s
}

func (s *GetMediaRefreshJobsResponseBodyMediaRefreshJobs) SetStatus(v string) *GetMediaRefreshJobsResponseBodyMediaRefreshJobs {
	s.Status = &v
	return s
}

func (s *GetMediaRefreshJobsResponseBodyMediaRefreshJobs) SetSuccessPlayUrls(v string) *GetMediaRefreshJobsResponseBodyMediaRefreshJobs {
	s.SuccessPlayUrls = &v
	return s
}

func (s *GetMediaRefreshJobsResponseBodyMediaRefreshJobs) SetTaskIds(v string) *GetMediaRefreshJobsResponseBodyMediaRefreshJobs {
	s.TaskIds = &v
	return s
}

func (s *GetMediaRefreshJobsResponseBodyMediaRefreshJobs) SetTaskType(v string) *GetMediaRefreshJobsResponseBodyMediaRefreshJobs {
	s.TaskType = &v
	return s
}

func (s *GetMediaRefreshJobsResponseBodyMediaRefreshJobs) SetUserData(v string) *GetMediaRefreshJobsResponseBodyMediaRefreshJobs {
	s.UserData = &v
	return s
}

type GetMediaRefreshJobsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetMediaRefreshJobsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetMediaRefreshJobsResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMediaRefreshJobsResponse) GoString() string {
	return s.String()
}

func (s *GetMediaRefreshJobsResponse) SetHeaders(v map[string]*string) *GetMediaRefreshJobsResponse {
	s.Headers = v
	return s
}

func (s *GetMediaRefreshJobsResponse) SetStatusCode(v int32) *GetMediaRefreshJobsResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMediaRefreshJobsResponse) SetBody(v *GetMediaRefreshJobsResponseBody) *GetMediaRefreshJobsResponse {
	s.Body = v
	return s
}

type GetMessageCallbackRequest struct {
	// The callback method. Valid values:
	//
	// *   **HTTP**
	// *   **MNS**
	AppId        *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
}

func (s GetMessageCallbackRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMessageCallbackRequest) GoString() string {
	return s.String()
}

func (s *GetMessageCallbackRequest) SetAppId(v string) *GetMessageCallbackRequest {
	s.AppId = &v
	return s
}

func (s *GetMessageCallbackRequest) SetOwnerAccount(v string) *GetMessageCallbackRequest {
	s.OwnerAccount = &v
	return s
}

type GetMessageCallbackResponseBody struct {
	// The cryptographic key. This parameter is returned only for HTTP callbacks.
	MessageCallback *GetMessageCallbackResponseBodyMessageCallback `json:"MessageCallback,omitempty" xml:"MessageCallback,omitempty" type:"Struct"`
	// The name of the MNS queue. This parameter is returned only for MNS callbacks.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetMessageCallbackResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMessageCallbackResponseBody) GoString() string {
	return s.String()
}

func (s *GetMessageCallbackResponseBody) SetMessageCallback(v *GetMessageCallbackResponseBodyMessageCallback) *GetMessageCallbackResponseBody {
	s.MessageCallback = v
	return s
}

func (s *GetMessageCallbackResponseBody) SetRequestId(v string) *GetMessageCallbackResponseBody {
	s.RequestId = &v
	return s
}

type GetMessageCallbackResponseBodyMessageCallback struct {
	// The operation that you want to perform. Set the value to **GetMessageCallback**.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// Queries the callback method, callback URL, and event type of an event notification.
	AuthKey    *string `json:"AuthKey,omitempty" xml:"AuthKey,omitempty"`
	AuthSwitch *string `json:"AuthSwitch,omitempty" xml:"AuthSwitch,omitempty"`
	// Indicates whether callback authentication is enabled. This parameter is returned only for HTTP callbacks. Valid values:
	//
	// *   **on**: indicates that authentication is enabled.
	// *   **off**: indicates that authentication is disabled.
	CallbackType *string `json:"CallbackType,omitempty" xml:"CallbackType,omitempty"`
	// The ID of the application.
	CallbackURL *string `json:"CallbackURL,omitempty" xml:"CallbackURL,omitempty"`
	// The ID of the request.
	EventTypeList *string `json:"EventTypeList,omitempty" xml:"EventTypeList,omitempty"`
	MnsEndpoint   *string `json:"MnsEndpoint,omitempty" xml:"MnsEndpoint,omitempty"`
	// The callback URL. This parameter is returned only for HTTP callbacks.
	MnsQueueName *string `json:"MnsQueueName,omitempty" xml:"MnsQueueName,omitempty"`
}

func (s GetMessageCallbackResponseBodyMessageCallback) String() string {
	return tea.Prettify(s)
}

func (s GetMessageCallbackResponseBodyMessageCallback) GoString() string {
	return s.String()
}

func (s *GetMessageCallbackResponseBodyMessageCallback) SetAppId(v string) *GetMessageCallbackResponseBodyMessageCallback {
	s.AppId = &v
	return s
}

func (s *GetMessageCallbackResponseBodyMessageCallback) SetAuthKey(v string) *GetMessageCallbackResponseBodyMessageCallback {
	s.AuthKey = &v
	return s
}

func (s *GetMessageCallbackResponseBodyMessageCallback) SetAuthSwitch(v string) *GetMessageCallbackResponseBodyMessageCallback {
	s.AuthSwitch = &v
	return s
}

func (s *GetMessageCallbackResponseBodyMessageCallback) SetCallbackType(v string) *GetMessageCallbackResponseBodyMessageCallback {
	s.CallbackType = &v
	return s
}

func (s *GetMessageCallbackResponseBodyMessageCallback) SetCallbackURL(v string) *GetMessageCallbackResponseBodyMessageCallback {
	s.CallbackURL = &v
	return s
}

func (s *GetMessageCallbackResponseBodyMessageCallback) SetEventTypeList(v string) *GetMessageCallbackResponseBodyMessageCallback {
	s.EventTypeList = &v
	return s
}

func (s *GetMessageCallbackResponseBodyMessageCallback) SetMnsEndpoint(v string) *GetMessageCallbackResponseBodyMessageCallback {
	s.MnsEndpoint = &v
	return s
}

func (s *GetMessageCallbackResponseBodyMessageCallback) SetMnsQueueName(v string) *GetMessageCallbackResponseBodyMessageCallback {
	s.MnsQueueName = &v
	return s
}

type GetMessageCallbackResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetMessageCallbackResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetMessageCallbackResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMessageCallbackResponse) GoString() string {
	return s.String()
}

func (s *GetMessageCallbackResponse) SetHeaders(v map[string]*string) *GetMessageCallbackResponse {
	s.Headers = v
	return s
}

func (s *GetMessageCallbackResponse) SetStatusCode(v int32) *GetMessageCallbackResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMessageCallbackResponse) SetBody(v *GetMessageCallbackResponseBody) *GetMessageCallbackResponse {
	s.Body = v
	return s
}

type GetMezzanineInfoRequest struct {
	// The ID of the video.
	AdditionType *string `json:"AdditionType,omitempty" xml:"AdditionType,omitempty"`
	// The type of the mezzanine file URL. Valid values:
	//
	// - **oss**: OSS URL
	// - **cdn** (default): CDN URL
	//
	// > If you specify an OSS URL for the video stream, the video stream must be in the MP4 format.
	AuthTimeout *int64 `json:"AuthTimeout,omitempty" xml:"AuthTimeout,omitempty"`
	// The frame rate of the file. Unit: frames per second.
	OutputType *string `json:"OutputType,omitempty" xml:"OutputType,omitempty"`
	// The operation that you want to perform. Set the value to **GetMezzanineInfo**.
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s GetMezzanineInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMezzanineInfoRequest) GoString() string {
	return s.String()
}

func (s *GetMezzanineInfoRequest) SetAdditionType(v string) *GetMezzanineInfoRequest {
	s.AdditionType = &v
	return s
}

func (s *GetMezzanineInfoRequest) SetAuthTimeout(v int64) *GetMezzanineInfoRequest {
	s.AuthTimeout = &v
	return s
}

func (s *GetMezzanineInfoRequest) SetOutputType(v string) *GetMezzanineInfoRequest {
	s.OutputType = &v
	return s
}

func (s *GetMezzanineInfoRequest) SetVideoId(v string) *GetMezzanineInfoRequest {
	s.VideoId = &v
	return s
}

type GetMezzanineInfoResponseBody struct {
	// The time base.
	Mezzanine *GetMezzanineInfoResponseBodyMezzanine `json:"Mezzanine,omitempty" xml:"Mezzanine,omitempty" type:"Struct"`
	// The codec time base.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetMezzanineInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMezzanineInfoResponseBody) GoString() string {
	return s.String()
}

func (s *GetMezzanineInfoResponseBody) SetMezzanine(v *GetMezzanineInfoResponseBodyMezzanine) *GetMezzanineInfoResponseBody {
	s.Mezzanine = v
	return s
}

func (s *GetMezzanineInfoResponseBody) SetRequestId(v string) *GetMezzanineInfoResponseBody {
	s.RequestId = &v
	return s
}

type GetMezzanineInfoResponseBodyMezzanine struct {
	// The language.
	AudioStreamList []*GetMezzanineInfoResponseBodyMezzanineAudioStreamList `json:"AudioStreamList,omitempty" xml:"AudioStreamList,omitempty" type:"Repeated"`
	// The type of the mezzanine file URL. Valid values:
	//
	// - **oss**: OSS URL
	// - **cdn** (default): Content Delivery Network (CDN) URL
	//
	// > If the mezzanine file is stored in a bucket of the in type, only an OSS URL is returned.
	Bitrate *string `json:"Bitrate,omitempty" xml:"Bitrate,omitempty"`
	// The information about the mezzanine file.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The type of additional information. Separate multiple values with commas (,). By default, only the basic information is returned. Valid values:
	//
	// *   **video**: video stream information
	// *   **audio**: audio stream information
	Duration *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The language.
	FileName *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	// The beginning of the time range that was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	FileURL *string `json:"FileURL,omitempty" xml:"FileURL,omitempty"`
	// The sample aspect ratio.
	Fps *string `json:"Fps,omitempty" xml:"Fps,omitempty"`
	// The height of the video resolution.
	Height *int64 `json:"Height,omitempty" xml:"Height,omitempty"`
	// The total number of frames.
	OutputType        *string `json:"OutputType,omitempty" xml:"OutputType,omitempty"`
	RestoreExpiration *string `json:"RestoreExpiration,omitempty" xml:"RestoreExpiration,omitempty"`
	RestoreStatus     *string `json:"RestoreStatus,omitempty" xml:"RestoreStatus,omitempty"`
	// The duration of the file. Unit: seconds.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The validity period of the mezzanine file URL. Unit: seconds. Default value: **1800**. Minimum value: **1**.
	//
	// *   If the OutputType parameter is set to **cdn**:
	//
	//     *   The mezzanine file URL has a validity period only if URL signing is enabled. Otherwise, the mezzanine file URL is permanently valid.
	//     *   Minimum value: **1**.
	//     *   Maximum Value: unlimited.
	//     *   Default value: If you do not set this parameter, the default validity period that is specified in URL signing is used.
	//
	// <!---->
	//
	// *   If the OutputType parameter is set to **oss**:
	//
	//     *   The mezzanine file URL has a validity period only if the permissions on the Object Storage Service (OSS) bucket are private. Otherwise, the mezzanine file URL is permanently valid.
	//     *   Minimum value: **1**.
	//     *   Maximum value: **2592000** (30 days). The maximum value is limited to reduce security risks of the origin.
	//     *   Default value: If you do not set this parameter, the default value is **3600**.
	Status       *string `json:"Status,omitempty" xml:"Status,omitempty"`
	StorageClass *string `json:"StorageClass,omitempty" xml:"StorageClass,omitempty"`
	// The average frame rate.
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
	// The output layout of the sound channels. Valid values:
	//
	// *   **mono**: mono sound channel
	// *   **stereo**: two sound channels
	VideoStreamList []*GetMezzanineInfoResponseBodyMezzanineVideoStreamList `json:"VideoStreamList,omitempty" xml:"VideoStreamList,omitempty" type:"Repeated"`
	// The tag of the codec format.
	Width *int64 `json:"Width,omitempty" xml:"Width,omitempty"`
}

func (s GetMezzanineInfoResponseBodyMezzanine) String() string {
	return tea.Prettify(s)
}

func (s GetMezzanineInfoResponseBodyMezzanine) GoString() string {
	return s.String()
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetAudioStreamList(v []*GetMezzanineInfoResponseBodyMezzanineAudioStreamList) *GetMezzanineInfoResponseBodyMezzanine {
	s.AudioStreamList = v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetBitrate(v string) *GetMezzanineInfoResponseBodyMezzanine {
	s.Bitrate = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetCreationTime(v string) *GetMezzanineInfoResponseBodyMezzanine {
	s.CreationTime = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetDuration(v string) *GetMezzanineInfoResponseBodyMezzanine {
	s.Duration = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetFileName(v string) *GetMezzanineInfoResponseBodyMezzanine {
	s.FileName = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetFileURL(v string) *GetMezzanineInfoResponseBodyMezzanine {
	s.FileURL = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetFps(v string) *GetMezzanineInfoResponseBodyMezzanine {
	s.Fps = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetHeight(v int64) *GetMezzanineInfoResponseBodyMezzanine {
	s.Height = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetOutputType(v string) *GetMezzanineInfoResponseBodyMezzanine {
	s.OutputType = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetRestoreExpiration(v string) *GetMezzanineInfoResponseBodyMezzanine {
	s.RestoreExpiration = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetRestoreStatus(v string) *GetMezzanineInfoResponseBodyMezzanine {
	s.RestoreStatus = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetSize(v int64) *GetMezzanineInfoResponseBodyMezzanine {
	s.Size = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetStatus(v string) *GetMezzanineInfoResponseBodyMezzanine {
	s.Status = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetStorageClass(v string) *GetMezzanineInfoResponseBodyMezzanine {
	s.StorageClass = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetVideoId(v string) *GetMezzanineInfoResponseBodyMezzanine {
	s.VideoId = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetVideoStreamList(v []*GetMezzanineInfoResponseBodyMezzanineVideoStreamList) *GetMezzanineInfoResponseBodyMezzanine {
	s.VideoStreamList = v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanine) SetWidth(v int64) *GetMezzanineInfoResponseBodyMezzanine {
	s.Width = &v
	return s
}

type GetMezzanineInfoResponseBodyMezzanineAudioStreamList struct {
	// The information about the video stream.
	Bitrate *string `json:"Bitrate,omitempty" xml:"Bitrate,omitempty"`
	// The target frame rate.
	ChannelLayout *string `json:"ChannelLayout,omitempty" xml:"ChannelLayout,omitempty"`
	// The width of the video resolution.
	Channels *string `json:"Channels,omitempty" xml:"Channels,omitempty"`
	// The time when the file was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	CodecLongName *string `json:"CodecLongName,omitempty" xml:"CodecLongName,omitempty"`
	// The duration of the video stream.
	CodecName *string `json:"CodecName,omitempty" xml:"CodecName,omitempty"`
	// The sequence number of the audio stream, which specifies the position of the audio stream in all audio streams.
	CodecTag *string `json:"CodecTag,omitempty" xml:"CodecTag,omitempty"`
	// The tag of the codec format.
	CodecTagString *string `json:"CodecTagString,omitempty" xml:"CodecTagString,omitempty"`
	// The full name of the codec format.
	CodecTimeBase *string `json:"CodecTimeBase,omitempty" xml:"CodecTimeBase,omitempty"`
	// The name of the file.
	Duration *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The short name of the codec format.
	Index *string `json:"Index,omitempty" xml:"Index,omitempty"`
	// The bitrate of the file. Unit: Kbit/s.
	Lang *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	// The codec profile.
	NumFrames *string `json:"NumFrames,omitempty" xml:"NumFrames,omitempty"`
	// The status of the file. Valid values:
	//
	// *   **Uploading**: The file is being uploaded. This is the initial status.
	// *   **Normal**: The file is uploaded.
	// *   **UploadFail**: The file fails to be uploaded.
	// *   **Deleted**: The file is deleted.
	SampleFmt *string `json:"SampleFmt,omitempty" xml:"SampleFmt,omitempty"`
	// The size of the file. Unit: byte.
	SampleRate *string `json:"SampleRate,omitempty" xml:"SampleRate,omitempty"`
	// The sample rate.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The ID of the video.
	Timebase *string `json:"Timebase,omitempty" xml:"Timebase,omitempty"`
}

func (s GetMezzanineInfoResponseBodyMezzanineAudioStreamList) String() string {
	return tea.Prettify(s)
}

func (s GetMezzanineInfoResponseBodyMezzanineAudioStreamList) GoString() string {
	return s.String()
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetBitrate(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.Bitrate = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetChannelLayout(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.ChannelLayout = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetChannels(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.Channels = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetCodecLongName(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.CodecLongName = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetCodecName(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.CodecName = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetCodecTag(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.CodecTag = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetCodecTagString(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.CodecTagString = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetCodecTimeBase(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.CodecTimeBase = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetDuration(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.Duration = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetIndex(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.Index = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetLang(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.Lang = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetNumFrames(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.NumFrames = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetSampleFmt(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.SampleFmt = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetSampleRate(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.SampleRate = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetStartTime(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.StartTime = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineAudioStreamList) SetTimebase(v string) *GetMezzanineInfoResponseBodyMezzanineAudioStreamList {
	s.Timebase = &v
	return s
}

type GetMezzanineInfoResponseBodyMezzanineVideoStreamList struct {
	// The beginning of the time range that was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	AvgFPS *string `json:"AvgFPS,omitempty" xml:"AvgFPS,omitempty"`
	// The URL of the file.
	Bitrate *string `json:"Bitrate,omitempty" xml:"Bitrate,omitempty"`
	// The codec time base.
	CodecLongName *string `json:"CodecLongName,omitempty" xml:"CodecLongName,omitempty"`
	CodecName     *string `json:"CodecName,omitempty" xml:"CodecName,omitempty"`
	CodecTag      *string `json:"CodecTag,omitempty" xml:"CodecTag,omitempty"`
	// The tag string of the codec format.
	CodecTagString *string `json:"CodecTagString,omitempty" xml:"CodecTagString,omitempty"`
	CodecTimeBase  *string `json:"CodecTimeBase,omitempty" xml:"CodecTimeBase,omitempty"`
	// Queries the information about the mezzanine file of an audio or video. The information includes the mezzanine file URL, resolution, and bitrate of the audio or video.
	Dar      *string `json:"Dar,omitempty" xml:"Dar,omitempty"`
	Duration *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	Fps      *string `json:"Fps,omitempty" xml:"Fps,omitempty"`
	HDRType  *string `json:"HDRType,omitempty" xml:"HDRType,omitempty"`
	// The rotation angle of the video. Valid values: **\[0, 360)**.
	HasBFrames *string `json:"HasBFrames,omitempty" xml:"HasBFrames,omitempty"`
	// The number of sound channels.
	Height *string `json:"Height,omitempty" xml:"Height,omitempty"`
	// The sequence number of the video stream, which indicates the position of the video stream in all video streams.
	Index *string `json:"Index,omitempty" xml:"Index,omitempty"`
	// The information about the audio stream.
	Lang  *string `json:"Lang,omitempty" xml:"Lang,omitempty"`
	Level *string `json:"Level,omitempty" xml:"Level,omitempty"`
	// The time base.
	NumFrames *string `json:"NumFrames,omitempty" xml:"NumFrames,omitempty"`
	// The short name of the codec format.
	PixFmt *string `json:"PixFmt,omitempty" xml:"PixFmt,omitempty"`
	// The ID of the request.
	Profile *string `json:"Profile,omitempty" xml:"Profile,omitempty"`
	// The duration of the audio stream.
	Rotate *string `json:"Rotate,omitempty" xml:"Rotate,omitempty"`
	// The width of the file. Unit: pixel.
	Sar *string `json:"Sar,omitempty" xml:"Sar,omitempty"`
	// The height of the file. Unit: pixel.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The pixel format.
	Timebase *string `json:"Timebase,omitempty" xml:"Timebase,omitempty"`
	Width    *string `json:"Width,omitempty" xml:"Width,omitempty"`
}

func (s GetMezzanineInfoResponseBodyMezzanineVideoStreamList) String() string {
	return tea.Prettify(s)
}

func (s GetMezzanineInfoResponseBodyMezzanineVideoStreamList) GoString() string {
	return s.String()
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetAvgFPS(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.AvgFPS = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetBitrate(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.Bitrate = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetCodecLongName(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.CodecLongName = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetCodecName(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.CodecName = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetCodecTag(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.CodecTag = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetCodecTagString(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.CodecTagString = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetCodecTimeBase(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.CodecTimeBase = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetDar(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.Dar = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetDuration(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.Duration = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetFps(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.Fps = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetHDRType(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.HDRType = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetHasBFrames(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.HasBFrames = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetHeight(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.Height = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetIndex(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.Index = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetLang(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.Lang = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetLevel(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.Level = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetNumFrames(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.NumFrames = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetPixFmt(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.PixFmt = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetProfile(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.Profile = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetRotate(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.Rotate = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetSar(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.Sar = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetStartTime(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.StartTime = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetTimebase(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.Timebase = &v
	return s
}

func (s *GetMezzanineInfoResponseBodyMezzanineVideoStreamList) SetWidth(v string) *GetMezzanineInfoResponseBodyMezzanineVideoStreamList {
	s.Width = &v
	return s
}

type GetMezzanineInfoResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetMezzanineInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetMezzanineInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMezzanineInfoResponse) GoString() string {
	return s.String()
}

func (s *GetMezzanineInfoResponse) SetHeaders(v map[string]*string) *GetMezzanineInfoResponse {
	s.Headers = v
	return s
}

func (s *GetMezzanineInfoResponse) SetStatusCode(v int32) *GetMezzanineInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMezzanineInfoResponse) SetBody(v *GetMezzanineInfoResponseBody) *GetMezzanineInfoResponse {
	s.Body = v
	return s
}

type GetPlayInfoRequest struct {
	// The ID of the media transcoding job. This ID uniquely identifies a media stream.
	AdditionType *string `json:"AdditionType,omitempty" xml:"AdditionType,omitempty"`
	// The frame rate of the media stream. Unit: frames per second.
	AuthTimeout *int64 `json:"AuthTimeout,omitempty" xml:"AuthTimeout,omitempty"`
	// The type of Narrowband HD transcoding. Valid values:
	//
	// *   **0**: regular
	// *   **1.0**: Narrowband HD 1.0
	// *   **2.0**: Narrowband HD 2.0
	//
	// This parameter is returned only when a quality that is available in the built-in Narrowband HD 1.0 transcoding template is specified. For more information, see the [Definition parameter in the TranscodeTemplate](~~52839~~) table.
	Definition *string `json:"Definition,omitempty" xml:"Definition,omitempty"`
	// The update time. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	Formats *string `json:"Formats,omitempty" xml:"Formats,omitempty"`
	// The URL of the masked live comment data. Set the value to **danmu**.
	//
	// > This parameter takes effect only when the outputType parameter is set to **cdn**.
	OutputType *string `json:"OutputType,omitempty" xml:"OutputType,omitempty"`
	// The quality of the video stream. Valid values:
	//
	// *   **FD**: low definition
	// *   **LD**: standard definition
	// *   **SD**: high definition
	// *   **HD**: ultra-high definition
	// *   **OD**: original definition
	// *   **2K**: 2K
	// *   **4K**: 4K
	// *   **SQ**: standard sound quality
	// *   **HQ**: high sound quality
	// *   **AUTO**: adaptive bitrate
	PlayConfig *string `json:"PlayConfig,omitempty" xml:"PlayConfig,omitempty"`
	// The playback URL of the video stream.
	ReAuthInfo *string `json:"ReAuthInfo,omitempty" xml:"ReAuthInfo,omitempty"`
	// The time when the audio or video file was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	ResultType *string `json:"ResultType,omitempty" xml:"ResultType,omitempty"`
	// Details of the audio or video file.
	StreamType *string `json:"StreamType,omitempty" xml:"StreamType,omitempty"`
	// The basic information about the audio or video file.
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s GetPlayInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s GetPlayInfoRequest) GoString() string {
	return s.String()
}

func (s *GetPlayInfoRequest) SetAdditionType(v string) *GetPlayInfoRequest {
	s.AdditionType = &v
	return s
}

func (s *GetPlayInfoRequest) SetAuthTimeout(v int64) *GetPlayInfoRequest {
	s.AuthTimeout = &v
	return s
}

func (s *GetPlayInfoRequest) SetDefinition(v string) *GetPlayInfoRequest {
	s.Definition = &v
	return s
}

func (s *GetPlayInfoRequest) SetFormats(v string) *GetPlayInfoRequest {
	s.Formats = &v
	return s
}

func (s *GetPlayInfoRequest) SetOutputType(v string) *GetPlayInfoRequest {
	s.OutputType = &v
	return s
}

func (s *GetPlayInfoRequest) SetPlayConfig(v string) *GetPlayInfoRequest {
	s.PlayConfig = &v
	return s
}

func (s *GetPlayInfoRequest) SetReAuthInfo(v string) *GetPlayInfoRequest {
	s.ReAuthInfo = &v
	return s
}

func (s *GetPlayInfoRequest) SetResultType(v string) *GetPlayInfoRequest {
	s.ResultType = &v
	return s
}

func (s *GetPlayInfoRequest) SetStreamType(v string) *GetPlayInfoRequest {
	s.StreamType = &v
	return s
}

func (s *GetPlayInfoRequest) SetVideoId(v string) *GetPlayInfoRequest {
	s.VideoId = &v
	return s
}

type GetPlayInfoResponseBody struct {
	// The height of the media stream. Unit: pixels.
	PlayInfoList *GetPlayInfoResponseBodyPlayInfoList `json:"PlayInfoList,omitempty" xml:"PlayInfoList,omitempty" type:"Struct"`
	// The information about the audio or video stream.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The width of the media stream. Unit: pixels.
	VideoBase *GetPlayInfoResponseBodyVideoBase `json:"VideoBase,omitempty" xml:"VideoBase,omitempty" type:"Struct"`
}

func (s GetPlayInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetPlayInfoResponseBody) GoString() string {
	return s.String()
}

func (s *GetPlayInfoResponseBody) SetPlayInfoList(v *GetPlayInfoResponseBodyPlayInfoList) *GetPlayInfoResponseBody {
	s.PlayInfoList = v
	return s
}

func (s *GetPlayInfoResponseBody) SetRequestId(v string) *GetPlayInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetPlayInfoResponseBody) SetVideoBase(v *GetPlayInfoResponseBodyVideoBase) *GetPlayInfoResponseBody {
	s.VideoBase = v
	return s
}

type GetPlayInfoResponseBodyPlayInfoList struct {
	PlayInfo []*GetPlayInfoResponseBodyPlayInfoListPlayInfo `json:"PlayInfo,omitempty" xml:"PlayInfo,omitempty" type:"Repeated"`
}

func (s GetPlayInfoResponseBodyPlayInfoList) String() string {
	return tea.Prettify(s)
}

func (s GetPlayInfoResponseBodyPlayInfoList) GoString() string {
	return s.String()
}

func (s *GetPlayInfoResponseBodyPlayInfoList) SetPlayInfo(v []*GetPlayInfoResponseBodyPlayInfoListPlayInfo) *GetPlayInfoResponseBodyPlayInfoList {
	s.PlayInfo = v
	return s
}

type GetPlayInfoResponseBodyPlayInfoListPlayInfo struct {
	BitDepth *int32 `json:"BitDepth,omitempty" xml:"BitDepth,omitempty"`
	// The format of the media stream. Separate multiple formats with commas (,). Valid values:
	//
	// *   **mp4**
	// *   **m3u8**
	// *   **mp3**
	// *   **mpd**
	//
	// > By default, ApsaraVideo VOD returns video streams in all the preceding formats. However, video streams in the MPD format are returned only if the MPD container format is specified in the transcoding template. For more information, see the [Container parameter in the TranscodeTemplate](~~52839~~) table.
	Bitrate *string `json:"Bitrate,omitempty" xml:"Bitrate,omitempty"`
	// The status of the media stream. Valid values:
	//
	// *   **Normal**
	// *   **Invisible**
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The color depth. This value must be an integer.
	Definition *string `json:"Definition,omitempty" xml:"Definition,omitempty"`
	// The encryption type of the media stream. Valid values:
	//
	// *   **AliyunVoDEncryption**: Alibaba Cloud proprietary cryptography
	// *   **HLSEncryption**: HTTP Live Streaming (HLS) encryption
	//
	// > If the encryption type is**AliyunVoDEncryption**, only ApsaraVideo Player SDK can be used to play videos.
	Duration *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The status of the audio or video file. For more information about the value range and description, see the [Status](~~52839~~) table.
	Encrypt *int64 `json:"Encrypt,omitempty" xml:"Encrypt,omitempty"`
	// The title of the audio or video file.
	EncryptType *string `json:"EncryptType,omitempty" xml:"EncryptType,omitempty"`
	// Queries the playback URL of a video or audio file by its ID.
	Format *string `json:"Format,omitempty" xml:"Format,omitempty"`
	// The type of the output URL. Default value: oss. Valid values:
	//
	// *   **oss**
	// *   **cdn**
	Fps     *string `json:"Fps,omitempty" xml:"Fps,omitempty"`
	HDRType *string `json:"HDRType,omitempty" xml:"HDRType,omitempty"`
	// The returned result.
	Height *int64 `json:"Height,omitempty" xml:"Height,omitempty"`
	// The type of the media file. Valid values:
	//
	// *   **video**
	// *   **audio**
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The validity period of the playback URL. Unit: seconds.
	//
	// *   If the OutputType parameter is set to **cdn**:
	//
	//     *   This parameter takes effect only if URL authentication is enabled. Otherwise, the playback URL does not expire.
	//     *   Minimum value: **1**.
	//     *   Maximum value: unlimited.
	//     *   Default value: The default validity period that is specified in URL authentication is used.
	//
	// *   If the OutputType parameter is set to **oss**:
	//
	//     *   This parameter takes effect only when the ACL of the Object Storage Service (OSS) bucket is private. Otherwise, the playback URL does not expire.
	//     *   Minimum value: **1**.
	//     *   Maximum value: **2592000** (30 days). This limit is imposed to reduce security risks of the origin server.
	//     *   Default value: **3600**.
	ModificationTime *string `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	// The type of the data to return. Default value: Single. Valid values:
	//
	// *   **Single**: Only one latest transcoded stream is returned for each quality and format.
	// *   **Multiple**: All transcoded streams are returned for each quality and format.
	NarrowBandType *string `json:"NarrowBandType,omitempty" xml:"NarrowBandType,omitempty"`
	// The ID of the request.
	PlayURL *string `json:"PlayURL,omitempty" xml:"PlayURL,omitempty"`
	// The custom playback configuration. The value is a JSON string. For more information, see [PlayConfig](~~86952~~).
	//
	// >
	//
	// *   If you do not specify PlayConfig or `PlayDomain` in PlayConfig, the default domain name configured in ApsaraVideo VOD is used in this operation. If no default domain name is configured, the domain names are queried in reverse chronological order based on the time when the domain names were modified. The domain name that was last modified is used as the streaming domain name. To prevent domain name issues, we recommend that you specify the default streaming domain name. You can log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com) and choose **Configuration Management** > **Media Management** > **Storage** > **Manage** > **Origin Domain Name** to set the default streaming domain name.
	//
	// *   If the `EncryptType` parameter in PlayConfig is set to `AliyunVoDEncryption`, the playback URL of the stream encrypted by using proprietary cryptography is not returned to ensure video security. If you want to return such URL, you must set the `ResultType` parameter to `Multiple`.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The size of the media stream. Unit: bytes.
	Specification *string `json:"Specification,omitempty" xml:"Specification,omitempty"`
	// The specifications of transcoded audio and video streams. For more information about the valid values, see [Output specifications](~~124671~~).
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The bitrate of the media stream. Unit: Kbit/s.
	StreamType *string `json:"StreamType,omitempty" xml:"StreamType,omitempty"`
	// The quality of the video stream. Separate multiple qualities with commas (,). Valid values:
	//
	// *   **FD**: low definition
	// *   **LD**: standard definition
	// *   **SD**: high definition
	// *   **HD**: ultra-high definition
	// *   **OD**: original definition
	// *   **2K**: 2K
	// *   **4K**: 4K
	// *   **SQ**: standard sound quality
	// *   **HQ**: high sound quality
	// *   **AUTO**: adaptive bitrate
	//
	// > By default, ApsaraVideo VOD returns video streams in all preceding qualities. However, video streams for adaptive bitrate streaming are returned only if the PackageSetting parameter is specified in the transcoding template. For more information, see the [PackageSetting parameter in the TranscodeTemplate](~~52839~~) table.
	WatermarkId *string `json:"WatermarkId,omitempty" xml:"WatermarkId,omitempty"`
	// Indicates whether the video stream was encrypted. Valid values:
	//
	// *   **0**: no
	// *   **1**: yes
	Width *int64 `json:"Width,omitempty" xml:"Width,omitempty"`
}

func (s GetPlayInfoResponseBodyPlayInfoListPlayInfo) String() string {
	return tea.Prettify(s)
}

func (s GetPlayInfoResponseBodyPlayInfoListPlayInfo) GoString() string {
	return s.String()
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetBitDepth(v int32) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.BitDepth = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetBitrate(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.Bitrate = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetCreationTime(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.CreationTime = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetDefinition(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.Definition = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetDuration(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.Duration = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetEncrypt(v int64) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.Encrypt = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetEncryptType(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.EncryptType = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetFormat(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.Format = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetFps(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.Fps = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetHDRType(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.HDRType = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetHeight(v int64) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.Height = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetJobId(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.JobId = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetModificationTime(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.ModificationTime = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetNarrowBandType(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.NarrowBandType = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetPlayURL(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.PlayURL = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetSize(v int64) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.Size = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetSpecification(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.Specification = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetStatus(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.Status = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetStreamType(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.StreamType = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetWatermarkId(v string) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.WatermarkId = &v
	return s
}

func (s *GetPlayInfoResponseBodyPlayInfoListPlayInfo) SetWidth(v int64) *GetPlayInfoResponseBodyPlayInfoListPlayInfo {
	s.Width = &v
	return s
}

type GetPlayInfoResponseBodyVideoBase struct {
	// ApsaraVideo VOD
	CoverURL *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	// The type of the media stream. Separate multiple types with commas (,). Valid values:
	//
	// *   **video**
	// *   **audio**
	//
	// By default, video and audio streams are returned.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The time when the audio or video file was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	DanMuURL *string `json:"DanMuURL,omitempty" xml:"DanMuURL,omitempty"`
	// The ID of the watermark that is associated with the media stream.
	Duration *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The ID of the audio or video file. You can use one of the following methods to obtain the ID of the file:
	//
	// *   Log on to the [ApsaraVideo VOD](https://vod.console.aliyun.com) console. In the left-side navigation pane, choose **Media Files** > **Audio/Video**. On the Video and Audio page, you can view the ID of the audio or video file. This method is applicable to files that are uploaded by using the ApsaraVideo VOD console.
	// *   Obtain the value of the VideoId parameter when you call the [CreateUploadVideo](~~55407~~) operation to upload files.
	// *   Obtain the value of the VideoId parameter by calling the [SearchMedia](~~86044~~) operation. This method is applicable to files that have been uploaded.
	MediaType *string `json:"MediaType,omitempty" xml:"MediaType,omitempty"`
	// The thumbnail URL of the audio or video file.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The format of the media stream.
	//
	// *   If the media file is a video file, the valid values are **mp4** and **m3u8**.
	// *   If the media file is an audio-only file, the value is **mp3**.
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The type of the media stream. If the media stream is a video stream, the value is **video**. If the media stream is an audio-only stream, the value is **audio**.
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s GetPlayInfoResponseBodyVideoBase) String() string {
	return tea.Prettify(s)
}

func (s GetPlayInfoResponseBodyVideoBase) GoString() string {
	return s.String()
}

func (s *GetPlayInfoResponseBodyVideoBase) SetCoverURL(v string) *GetPlayInfoResponseBodyVideoBase {
	s.CoverURL = &v
	return s
}

func (s *GetPlayInfoResponseBodyVideoBase) SetCreationTime(v string) *GetPlayInfoResponseBodyVideoBase {
	s.CreationTime = &v
	return s
}

func (s *GetPlayInfoResponseBodyVideoBase) SetDanMuURL(v string) *GetPlayInfoResponseBodyVideoBase {
	s.DanMuURL = &v
	return s
}

func (s *GetPlayInfoResponseBodyVideoBase) SetDuration(v string) *GetPlayInfoResponseBodyVideoBase {
	s.Duration = &v
	return s
}

func (s *GetPlayInfoResponseBodyVideoBase) SetMediaType(v string) *GetPlayInfoResponseBodyVideoBase {
	s.MediaType = &v
	return s
}

func (s *GetPlayInfoResponseBodyVideoBase) SetStatus(v string) *GetPlayInfoResponseBodyVideoBase {
	s.Status = &v
	return s
}

func (s *GetPlayInfoResponseBodyVideoBase) SetTitle(v string) *GetPlayInfoResponseBodyVideoBase {
	s.Title = &v
	return s
}

func (s *GetPlayInfoResponseBodyVideoBase) SetVideoId(v string) *GetPlayInfoResponseBodyVideoBase {
	s.VideoId = &v
	return s
}

type GetPlayInfoResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetPlayInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetPlayInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s GetPlayInfoResponse) GoString() string {
	return s.String()
}

func (s *GetPlayInfoResponse) SetHeaders(v map[string]*string) *GetPlayInfoResponse {
	s.Headers = v
	return s
}

func (s *GetPlayInfoResponse) SetStatusCode(v int32) *GetPlayInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *GetPlayInfoResponse) SetBody(v *GetPlayInfoResponseBody) *GetPlayInfoResponse {
	s.Body = v
	return s
}

type GetTranscodeSummaryRequest struct {
	// The ID of the audio or video file. You can specify up to 10 IDs. Separate the IDs with commas (,). You can use one of the following methods to obtain the ID:
	//
	// *   Log on to the [ApsaraVideo VOD](https://vod.console.aliyun.com) console. In the left-side navigation pane, choose **Media Files** > **Audio/Video**. On the Video and Audio page, view the ID of the audio or video file. This method is applicable to files that are uploaded by using the ApsaraVideo VOD console.
	// *   Obtain the value of VideoId from the response to the [CreateUploadVideo](~~55407~~) operation that you call to obtain the upload URL and credential.
	// *   Obtain the value of VideoId by calling the [SearchMedia](~~86044~~) operation. This method is applicable to files that have been uploaded.
	VideoIds *string `json:"VideoIds,omitempty" xml:"VideoIds,omitempty"`
}

func (s GetTranscodeSummaryRequest) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeSummaryRequest) GoString() string {
	return s.String()
}

func (s *GetTranscodeSummaryRequest) SetVideoIds(v string) *GetTranscodeSummaryRequest {
	s.VideoIds = &v
	return s
}

type GetTranscodeSummaryResponseBody struct {
	// The IDs of the audio or video files that do not exist.
	NonExistVideoIds []*string `json:"NonExistVideoIds,omitempty" xml:"NonExistVideoIds,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The transcoding summary of the file.
	TranscodeSummaryList []*GetTranscodeSummaryResponseBodyTranscodeSummaryList `json:"TranscodeSummaryList,omitempty" xml:"TranscodeSummaryList,omitempty" type:"Repeated"`
}

func (s GetTranscodeSummaryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeSummaryResponseBody) GoString() string {
	return s.String()
}

func (s *GetTranscodeSummaryResponseBody) SetNonExistVideoIds(v []*string) *GetTranscodeSummaryResponseBody {
	s.NonExistVideoIds = v
	return s
}

func (s *GetTranscodeSummaryResponseBody) SetRequestId(v string) *GetTranscodeSummaryResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetTranscodeSummaryResponseBody) SetTranscodeSummaryList(v []*GetTranscodeSummaryResponseBodyTranscodeSummaryList) *GetTranscodeSummaryResponseBody {
	s.TranscodeSummaryList = v
	return s
}

type GetTranscodeSummaryResponseBodyTranscodeSummaryList struct {
	// The time when the transcoding task was complete. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	CompleteTime *string `json:"CompleteTime,omitempty" xml:"CompleteTime,omitempty"`
	// The time when the transcoding task was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The summaries of transcoding jobs.
	TranscodeJobInfoSummaryList []*GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList `json:"TranscodeJobInfoSummaryList,omitempty" xml:"TranscodeJobInfoSummaryList,omitempty" type:"Repeated"`
	// The status of the transcoding task. Valid values:
	// *   **Processing**: In progress.
	// *   **Partial**: Some transcoding jobs were complete.
	// *   **CompleteAllSucc**: All transcoding jobs were successful.
	// *   **CompleteAllFail**: All transcoding jobs failed. If an exception occurs in the source file, no transcoding job is initiated and the transcoding task fails.
	// *   **CompletePartialSucc**: All transcoding jobs were complete but only some were successful.
	TranscodeStatus *string `json:"TranscodeStatus,omitempty" xml:"TranscodeStatus,omitempty"`
	// The ID of the transcoding template group.
	TranscodeTemplateGroupId *string `json:"TranscodeTemplateGroupId,omitempty" xml:"TranscodeTemplateGroupId,omitempty"`
	// The ID of the audio or video file.
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s GetTranscodeSummaryResponseBodyTranscodeSummaryList) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeSummaryResponseBodyTranscodeSummaryList) GoString() string {
	return s.String()
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryList) SetCompleteTime(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryList {
	s.CompleteTime = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryList) SetCreationTime(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryList {
	s.CreationTime = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryList) SetTranscodeJobInfoSummaryList(v []*GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) *GetTranscodeSummaryResponseBodyTranscodeSummaryList {
	s.TranscodeJobInfoSummaryList = v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryList) SetTranscodeStatus(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryList {
	s.TranscodeStatus = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryList) SetTranscodeTemplateGroupId(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryList {
	s.TranscodeTemplateGroupId = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryList) SetVideoId(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryList {
	s.VideoId = &v
	return s
}

type GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList struct {
	// The average bitrate of the output video. Unit: Kbit/s.
	Bitrate *string `json:"Bitrate,omitempty" xml:"Bitrate,omitempty"`
	// The time when the transcoding job was complete. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	CompleteTime *string `json:"CompleteTime,omitempty" xml:"CompleteTime,omitempty"`
	// The time when the transcoding job was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The duration of the output video. Unit: seconds.
	Duration *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The error code returned when the transcoding job failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned when the transcoding job failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The size of the output video. Unit: bytes.
	Filesize *int64 `json:"Filesize,omitempty" xml:"Filesize,omitempty"`
	// The container format of the output video.
	Format *string `json:"Format,omitempty" xml:"Format,omitempty"`
	// The frame rate of the output video. Unit: frames per second.
	Fps *string `json:"Fps,omitempty" xml:"Fps,omitempty"`
	// The height of the output video. Unit: pixels.
	Height *string `json:"Height,omitempty" xml:"Height,omitempty"`
	// The status of the transcoding job. Valid values:
	// *   **Transcoding**
	// *   **TranscodeSuccess**
	// *   **TranscodeFail**
	TranscodeJobStatus *string `json:"TranscodeJobStatus,omitempty" xml:"TranscodeJobStatus,omitempty"`
	// The transcoding progress. Valid values: `[0,100]`.
	TranscodeProgress *int64 `json:"TranscodeProgress,omitempty" xml:"TranscodeProgress,omitempty"`
	// The ID of the transcoding template.
	TranscodeTemplateId *string `json:"TranscodeTemplateId,omitempty" xml:"TranscodeTemplateId,omitempty"`
	// The IDs of the watermarks that are applied to the output video.
	WatermarkIdList []*string `json:"WatermarkIdList,omitempty" xml:"WatermarkIdList,omitempty" type:"Repeated"`
	// The width of the output video. Unit: pixels.
	Width *string `json:"Width,omitempty" xml:"Width,omitempty"`
}

func (s GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) GoString() string {
	return s.String()
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) SetBitrate(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList {
	s.Bitrate = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) SetCompleteTime(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList {
	s.CompleteTime = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) SetCreationTime(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList {
	s.CreationTime = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) SetDuration(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList {
	s.Duration = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) SetErrorCode(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList {
	s.ErrorCode = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) SetErrorMessage(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList {
	s.ErrorMessage = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) SetFilesize(v int64) *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList {
	s.Filesize = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) SetFormat(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList {
	s.Format = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) SetFps(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList {
	s.Fps = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) SetHeight(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList {
	s.Height = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) SetTranscodeJobStatus(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList {
	s.TranscodeJobStatus = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) SetTranscodeProgress(v int64) *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList {
	s.TranscodeProgress = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) SetTranscodeTemplateId(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList {
	s.TranscodeTemplateId = &v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) SetWatermarkIdList(v []*string) *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList {
	s.WatermarkIdList = v
	return s
}

func (s *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList) SetWidth(v string) *GetTranscodeSummaryResponseBodyTranscodeSummaryListTranscodeJobInfoSummaryList {
	s.Width = &v
	return s
}

type GetTranscodeSummaryResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetTranscodeSummaryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetTranscodeSummaryResponse) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeSummaryResponse) GoString() string {
	return s.String()
}

func (s *GetTranscodeSummaryResponse) SetHeaders(v map[string]*string) *GetTranscodeSummaryResponse {
	s.Headers = v
	return s
}

func (s *GetTranscodeSummaryResponse) SetStatusCode(v int32) *GetTranscodeSummaryResponse {
	s.StatusCode = &v
	return s
}

func (s *GetTranscodeSummaryResponse) SetBody(v *GetTranscodeSummaryResponseBody) *GetTranscodeSummaryResponse {
	s.Body = v
	return s
}

type GetTranscodeTaskRequest struct {
	// The OSS URL of the output file.
	TranscodeTaskId *string `json:"TranscodeTaskId,omitempty" xml:"TranscodeTaskId,omitempty"`
}

func (s GetTranscodeTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeTaskRequest) GoString() string {
	return s.String()
}

func (s *GetTranscodeTaskRequest) SetTranscodeTaskId(v string) *GetTranscodeTaskRequest {
	s.TranscodeTaskId = &v
	return s
}

type GetTranscodeTaskResponseBody struct {
	// The size of the output file. Unit: byte.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The length of the output file. Unit: seconds.
	TranscodeTask *GetTranscodeTaskResponseBodyTranscodeTask `json:"TranscodeTask,omitempty" xml:"TranscodeTask,omitempty" type:"Struct"`
}

func (s GetTranscodeTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeTaskResponseBody) GoString() string {
	return s.String()
}

func (s *GetTranscodeTaskResponseBody) SetRequestId(v string) *GetTranscodeTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetTranscodeTaskResponseBody) SetTranscodeTask(v *GetTranscodeTaskResponseBodyTranscodeTask) *GetTranscodeTaskResponseBody {
	s.TranscodeTask = v
	return s
}

type GetTranscodeTaskResponseBodyTranscodeTask struct {
	// The Object Storage Service (OSS) URL of the input file.
	CompleteTime *string `json:"CompleteTime,omitempty" xml:"CompleteTime,omitempty"`
	// The operation that you want to perform. Set the value to **GetTranscodeTask**.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The mode in which the transcoding task is triggered. Valid values:
	//
	// *   **Auto**: The transcoding task is automatically triggered when the video is uploaded.
	// *   **Manual**: The transcoding task is triggered by calling the SubmitTranscodeJobs operation.
	TaskStatus *string `json:"TaskStatus,omitempty" xml:"TaskStatus,omitempty"`
	// The information about the output file.
	TranscodeJobInfoList []*GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList `json:"TranscodeJobInfoList,omitempty" xml:"TranscodeJobInfoList,omitempty" type:"Repeated"`
	// The container format of the output file.
	TranscodeTaskId *string `json:"TranscodeTaskId,omitempty" xml:"TranscodeTaskId,omitempty"`
	// The ID of the transcoding task. You can use one of the following methods to obtain the ID:
	//
	// *   Obtain the value of TranscodeTaskId from the response to the [SubmitTranscodeJobs](~~68570~~) operation.
	// *   Obtain the value of TranscodeTaskId from the response to the [ListTranscodeTask](~~109120~~) operation.
	TranscodeTemplateGroupId *string `json:"TranscodeTemplateGroupId,omitempty" xml:"TranscodeTemplateGroupId,omitempty"`
	// The video streams.
	Trigger *string `json:"Trigger,omitempty" xml:"Trigger,omitempty"`
	// The ID of the transcoding template.
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s GetTranscodeTaskResponseBodyTranscodeTask) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeTaskResponseBodyTranscodeTask) GoString() string {
	return s.String()
}

func (s *GetTranscodeTaskResponseBodyTranscodeTask) SetCompleteTime(v string) *GetTranscodeTaskResponseBodyTranscodeTask {
	s.CompleteTime = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTask) SetCreationTime(v string) *GetTranscodeTaskResponseBodyTranscodeTask {
	s.CreationTime = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTask) SetTaskStatus(v string) *GetTranscodeTaskResponseBodyTranscodeTask {
	s.TaskStatus = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTask) SetTranscodeJobInfoList(v []*GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList) *GetTranscodeTaskResponseBodyTranscodeTask {
	s.TranscodeJobInfoList = v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTask) SetTranscodeTaskId(v string) *GetTranscodeTaskResponseBodyTranscodeTask {
	s.TranscodeTaskId = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTask) SetTranscodeTemplateGroupId(v string) *GetTranscodeTaskResponseBodyTranscodeTask {
	s.TranscodeTemplateGroupId = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTask) SetTrigger(v string) *GetTranscodeTaskResponseBodyTranscodeTask {
	s.Trigger = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTask) SetVideoId(v string) *GetTranscodeTaskResponseBodyTranscodeTask {
	s.VideoId = &v
	return s
}

type GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList struct {
	// The progress of the transcoding job. Valid values: `[0,100]`.
	CompleteTime *string `json:"CompleteTime,omitempty" xml:"CompleteTime,omitempty"`
	// The status of the transcoding job.
	//
	// *   **Transcoding**
	// *   **TranscodeSuccess**
	// *   **TranscodeFail**
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The encryption method of the output file. Valid values:
	//
	// *   **AliyunVoDEncryption**: Alibaba Cloud proprietary cryptography
	// *   **HLSEncryption**: HTTP Live Streaming (HLS) encryption
	Definition *string `json:"Definition,omitempty" xml:"Definition,omitempty"`
	// Details about transcoding jobs.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The height of the output video. Unit: pixels.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The IDs of the watermarks used by the output file.
	InputFileUrl *string `json:"InputFileUrl,omitempty" xml:"InputFileUrl,omitempty"`
	// The ID of the transcoding template group.
	OutputFile *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile `json:"OutputFile,omitempty" xml:"OutputFile,omitempty" type:"Struct"`
	// The subtitle streams.
	Priority *string `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The ID of the audio or video file.
	TranscodeJobId *string `json:"TranscodeJobId,omitempty" xml:"TranscodeJobId,omitempty"`
	// The priority of the transcoding job.
	TranscodeJobStatus *string `json:"TranscodeJobStatus,omitempty" xml:"TranscodeJobStatus,omitempty"`
	// The average bitrate of the output file. Unit: Kbit/s.
	TranscodeProgress *int64 `json:"TranscodeProgress,omitempty" xml:"TranscodeProgress,omitempty"`
	// The status of the transcoding task. Valid values:
	//
	// *   **Processing**: In progress.
	// *   **Partial**: Some transcoding jobs were complete.
	// *   **CompleteAllSucc**: All transcoding jobs were successful.
	// *   **CompleteAllFail**: All transcoding jobs failed. If an exception occurs in the source file, no transcoding job is initiated and the transcoding task fails.
	// *   **CompletePartialSucc**: All transcoding jobs were complete but only some were successful.
	TranscodeTemplateId *string `json:"TranscodeTemplateId,omitempty" xml:"TranscodeTemplateId,omitempty"`
}

func (s GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList) GoString() string {
	return s.String()
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList) SetCompleteTime(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList {
	s.CompleteTime = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList) SetCreationTime(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList {
	s.CreationTime = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList) SetDefinition(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList {
	s.Definition = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList) SetErrorCode(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList {
	s.ErrorCode = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList) SetErrorMessage(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList {
	s.ErrorMessage = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList) SetInputFileUrl(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList {
	s.InputFileUrl = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList) SetOutputFile(v *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList {
	s.OutputFile = v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList) SetPriority(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList {
	s.Priority = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList) SetTranscodeJobId(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList {
	s.TranscodeJobId = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList) SetTranscodeJobStatus(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList {
	s.TranscodeJobStatus = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList) SetTranscodeProgress(v int64) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList {
	s.TranscodeProgress = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList) SetTranscodeTemplateId(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoList {
	s.TranscodeTemplateId = &v
	return s
}

type GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile struct {
	// The ID of the transcoding job.
	AudioStreamList *string `json:"AudioStreamList,omitempty" xml:"AudioStreamList,omitempty"`
	// The time when the transcoding task was complete. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	Bitrate *string `json:"Bitrate,omitempty" xml:"Bitrate,omitempty"`
	// The frame rate of the output file. Unit: frames per second.
	Duration *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The audio streams.
	Encryption *string `json:"Encryption,omitempty" xml:"Encryption,omitempty"`
	// Queries details about transcoding jobs based on the transcoding task ID.
	Filesize *int64 `json:"Filesize,omitempty" xml:"Filesize,omitempty"`
	// The IDs of the watermarks used by the output file.
	Format *string `json:"Format,omitempty" xml:"Format,omitempty"`
	// The ID of the request.
	Fps *string `json:"Fps,omitempty" xml:"Fps,omitempty"`
	// The error message returned when the transcoding job failed.
	Height *string `json:"Height,omitempty" xml:"Height,omitempty"`
	// The ID of the transcoding task.
	OutputFileUrl *string `json:"OutputFileUrl,omitempty" xml:"OutputFileUrl,omitempty"`
	// The time when the transcoding task was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	SubtitleStreamList *string `json:"SubtitleStreamList,omitempty" xml:"SubtitleStreamList,omitempty"`
	// The time when the transcoding job was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	VideoStreamList *string   `json:"VideoStreamList,omitempty" xml:"VideoStreamList,omitempty"`
	WatermarkIdList []*string `json:"WatermarkIdList,omitempty" xml:"WatermarkIdList,omitempty" type:"Repeated"`
	// Details about transcoding tasks.
	Width *string `json:"Width,omitempty" xml:"Width,omitempty"`
}

func (s GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) GoString() string {
	return s.String()
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) SetAudioStreamList(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile {
	s.AudioStreamList = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) SetBitrate(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile {
	s.Bitrate = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) SetDuration(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile {
	s.Duration = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) SetEncryption(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile {
	s.Encryption = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) SetFilesize(v int64) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile {
	s.Filesize = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) SetFormat(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile {
	s.Format = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) SetFps(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile {
	s.Fps = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) SetHeight(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile {
	s.Height = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) SetOutputFileUrl(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile {
	s.OutputFileUrl = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) SetSubtitleStreamList(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile {
	s.SubtitleStreamList = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) SetVideoStreamList(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile {
	s.VideoStreamList = &v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) SetWatermarkIdList(v []*string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile {
	s.WatermarkIdList = v
	return s
}

func (s *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile) SetWidth(v string) *GetTranscodeTaskResponseBodyTranscodeTaskTranscodeJobInfoListOutputFile {
	s.Width = &v
	return s
}

type GetTranscodeTaskResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetTranscodeTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetTranscodeTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeTaskResponse) GoString() string {
	return s.String()
}

func (s *GetTranscodeTaskResponse) SetHeaders(v map[string]*string) *GetTranscodeTaskResponse {
	s.Headers = v
	return s
}

func (s *GetTranscodeTaskResponse) SetStatusCode(v int32) *GetTranscodeTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *GetTranscodeTaskResponse) SetBody(v *GetTranscodeTaskResponseBody) *GetTranscodeTaskResponse {
	s.Body = v
	return s
}

type GetTranscodeTemplateGroupRequest struct {
	// The transcoding configurations of the video stream. The value is a JSON-formatted string.
	TranscodeTemplateGroupId *string `json:"TranscodeTemplateGroupId,omitempty" xml:"TranscodeTemplateGroupId,omitempty"`
}

func (s GetTranscodeTemplateGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeTemplateGroupRequest) GoString() string {
	return s.String()
}

func (s *GetTranscodeTemplateGroupRequest) SetTranscodeTemplateGroupId(v string) *GetTranscodeTemplateGroupRequest {
	s.TranscodeTemplateGroupId = &v
	return s
}

type GetTranscodeTemplateGroupResponseBody struct {
	// The ID of the transcoding template.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The format of the container used to encapsulate audio and video streams. The value is a JSON-formatted string.
	TranscodeTemplateGroup *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup `json:"TranscodeTemplateGroup,omitempty" xml:"TranscodeTemplateGroup,omitempty" type:"Struct"`
}

func (s GetTranscodeTemplateGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeTemplateGroupResponseBody) GoString() string {
	return s.String()
}

func (s *GetTranscodeTemplateGroupResponseBody) SetRequestId(v string) *GetTranscodeTemplateGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBody) SetTranscodeTemplateGroup(v *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup) *GetTranscodeTemplateGroupResponseBody {
	s.TranscodeTemplateGroup = v
	return s
}

type GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup struct {
	// The configurations of the transcoding templates.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The video rotation identifier. It is used to control the image rotation angle. For example, if you set this parameter to 180, the video image is turned upside down. Valid values: `0 to 360`.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The operation that you want to perform. Set the value to **GetTranscodeTemplateGroup**.
	IsDefault *string `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	// The packaging configurations. Only HLS packaging and DASH packaging are supported. The value is a JSON-formatted string.
	Locked *string `json:"Locked,omitempty" xml:"Locked,omitempty"`
	// The information about the transcoding template group.
	ModifyTime *string `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	// The transcoding segment configurations. This parameter must be returned if HTTP-Live-Streaming (HLS) encryption is used. The value is a JSON-formatted string.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the transcoding template group.
	TranscodeTemplateGroupId *string `json:"TranscodeTemplateGroupId,omitempty" xml:"TranscodeTemplateGroupId,omitempty"`
	// The name of the transcoding template.
	TranscodeTemplateList []*GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList `json:"TranscodeTemplateList,omitempty" xml:"TranscodeTemplateList,omitempty" type:"Repeated"`
}

func (s GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup) GoString() string {
	return s.String()
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup) SetAppId(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup {
	s.AppId = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup) SetCreationTime(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup {
	s.CreationTime = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup) SetIsDefault(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup {
	s.IsDefault = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup) SetLocked(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup {
	s.Locked = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup) SetModifyTime(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup {
	s.ModifyTime = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup) SetName(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup {
	s.Name = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup) SetTranscodeTemplateGroupId(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup {
	s.TranscodeTemplateGroupId = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup) SetTranscodeTemplateList(v []*GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroup {
	s.TranscodeTemplateList = v
	return s
}

type GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList struct {
	// The encryption configuration used for transcoding.
	Audio *string `json:"Audio,omitempty" xml:"Audio,omitempty"`
	// The ID of the associated watermark.
	Clip *string `json:"Clip,omitempty" xml:"Clip,omitempty"`
	// The subtitle configurations. The value is a JSON-formatted string.
	Container *string `json:"Container,omitempty" xml:"Container,omitempty"`
	// The transcoding configurations of the audio stream. The value is a JSON-formatted string.
	Definition *string `json:"Definition,omitempty" xml:"Definition,omitempty"`
	// The conditional transcoding configurations. This parameter can be used if you want to determine the basic logic based on the bitrate and resolution of the mezzanine file before the video is transcoded. The value is a JSON-formatted string.
	EncryptSetting *string `json:"EncryptSetting,omitempty" xml:"EncryptSetting,omitempty"`
	// Queries the details of a transcoding template group based on the ID of the transcoding template group.
	MuxConfig *string `json:"MuxConfig,omitempty" xml:"MuxConfig,omitempty"`
	// The ID of the request.
	PackageSetting *string `json:"PackageSetting,omitempty" xml:"PackageSetting,omitempty"`
	// The ID of the application.
	Rotate *string `json:"Rotate,omitempty" xml:"Rotate,omitempty"`
	// The ID of the associated watermark.
	SubtitleList *string `json:"SubtitleList,omitempty" xml:"SubtitleList,omitempty"`
	// Indicates whether the template group is locked. Valid values:
	// *   **Disabled**: The template group is not locked.
	// *   **Enabled**: The template group is locked.
	TemplateName *string `json:"TemplateName,omitempty" xml:"TemplateName,omitempty"`
	// The type of the template. Valid values:
	// *   **Normal**: a common transcoding template. This is the default value. The PackageSetting parameter cannot be set for this type of template.
	// *   **VideoPackage**: a video stream package template. If this type of template is used, ApsaraVideo VOD transcodes a video into video streams in different bitrates and packages these video streams with a file. The PackageSetting parameter must be set for this type of template.
	// *   **SubtitlePackage**: a subtitle package template. If this type of template is used, ApsaraVideo VOD adds the subtitle information to the output file generated by packaging the multi-bitrate video streams of the corresponding video. You must set the PackageSetting parameter for a subtitle package template and associate the subtitle package template with a video stream package template. A template group can contain only one subtitle package template.
	TransConfig *string `json:"TransConfig,omitempty" xml:"TransConfig,omitempty"`
	// The clipping configurations of the video. The value is a JSON-formatted string. For example, you can set this parameter if you want to extract 5 seconds of content from a video to generate a new video.
	TranscodeFileRegular *string `json:"TranscodeFileRegular,omitempty" xml:"TranscodeFileRegular,omitempty"`
	// The time when the template group was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	TranscodeTemplateId *string `json:"TranscodeTemplateId,omitempty" xml:"TranscodeTemplateId,omitempty"`
	// The ID of the transcoding template group.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The time when the template group was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	Video        *string   `json:"Video,omitempty" xml:"Video,omitempty"`
	WatermarkIds []*string `json:"WatermarkIds,omitempty" xml:"WatermarkIds,omitempty" type:"Repeated"`
}

func (s GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) GoString() string {
	return s.String()
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetAudio(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.Audio = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetClip(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.Clip = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetContainer(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.Container = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetDefinition(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.Definition = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetEncryptSetting(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.EncryptSetting = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetMuxConfig(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.MuxConfig = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetPackageSetting(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.PackageSetting = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetRotate(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.Rotate = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetSubtitleList(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.SubtitleList = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetTemplateName(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.TemplateName = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetTransConfig(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.TransConfig = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetTranscodeFileRegular(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.TranscodeFileRegular = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetTranscodeTemplateId(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.TranscodeTemplateId = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetType(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.Type = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetVideo(v string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.Video = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList) SetWatermarkIds(v []*string) *GetTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupTranscodeTemplateList {
	s.WatermarkIds = v
	return s
}

type GetTranscodeTemplateGroupResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetTranscodeTemplateGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetTranscodeTemplateGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s GetTranscodeTemplateGroupResponse) GoString() string {
	return s.String()
}

func (s *GetTranscodeTemplateGroupResponse) SetHeaders(v map[string]*string) *GetTranscodeTemplateGroupResponse {
	s.Headers = v
	return s
}

func (s *GetTranscodeTemplateGroupResponse) SetStatusCode(v int32) *GetTranscodeTemplateGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *GetTranscodeTemplateGroupResponse) SetBody(v *GetTranscodeTemplateGroupResponseBody) *GetTranscodeTemplateGroupResponse {
	s.Body = v
	return s
}

type GetURLUploadInfosRequest struct {
	// The ID of the upload job.
	JobIds *string `json:"JobIds,omitempty" xml:"JobIds,omitempty"`
	// The operation that you want to perform. Set the value to **GetURLUploadInfos**.
	UploadURLs *string `json:"UploadURLs,omitempty" xml:"UploadURLs,omitempty"`
}

func (s GetURLUploadInfosRequest) String() string {
	return tea.Prettify(s)
}

func (s GetURLUploadInfosRequest) GoString() string {
	return s.String()
}

func (s *GetURLUploadInfosRequest) SetJobIds(v string) *GetURLUploadInfosRequest {
	s.JobIds = &v
	return s
}

func (s *GetURLUploadInfosRequest) SetUploadURLs(v string) *GetURLUploadInfosRequest {
	s.UploadURLs = &v
	return s
}

type GetURLUploadInfosResponseBody struct {
	// The error message returned.
	NonExists []*string `json:"NonExists,omitempty" xml:"NonExists,omitempty" type:"Repeated"`
	// The ID of the uploaded media file.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The time when the upload job was complete. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	URLUploadInfoList []*GetURLUploadInfosResponseBodyURLUploadInfoList `json:"URLUploadInfoList,omitempty" xml:"URLUploadInfoList,omitempty" type:"Repeated"`
}

func (s GetURLUploadInfosResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetURLUploadInfosResponseBody) GoString() string {
	return s.String()
}

func (s *GetURLUploadInfosResponseBody) SetNonExists(v []*string) *GetURLUploadInfosResponseBody {
	s.NonExists = v
	return s
}

func (s *GetURLUploadInfosResponseBody) SetRequestId(v string) *GetURLUploadInfosResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetURLUploadInfosResponseBody) SetURLUploadInfoList(v []*GetURLUploadInfosResponseBodyURLUploadInfoList) *GetURLUploadInfosResponseBody {
	s.URLUploadInfoList = v
	return s
}

type GetURLUploadInfosResponseBodyURLUploadInfoList struct {
	// The error code returned.
	CompleteTime *string `json:"CompleteTime,omitempty" xml:"CompleteTime,omitempty"`
	// The custom configurations. The value is a JSON string. For more information, see the "UserData: specifies the custom configurations for media upload" section of the [Request parameters](~~86952~~) topic.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The ID of the request.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The upload URL of the source file.
	//
	// > A maximum of 100 URLs can be returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	FileSize     *string `json:"FileSize,omitempty" xml:"FileSize,omitempty"`
	// Queries the information about URL-based upload jobs.
	JobId   *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The time when the upload job was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	Status    *string `json:"Status,omitempty" xml:"Status,omitempty"`
	UploadURL *string `json:"UploadURL,omitempty" xml:"UploadURL,omitempty"`
	UserData  *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
}

func (s GetURLUploadInfosResponseBodyURLUploadInfoList) String() string {
	return tea.Prettify(s)
}

func (s GetURLUploadInfosResponseBodyURLUploadInfoList) GoString() string {
	return s.String()
}

func (s *GetURLUploadInfosResponseBodyURLUploadInfoList) SetCompleteTime(v string) *GetURLUploadInfosResponseBodyURLUploadInfoList {
	s.CompleteTime = &v
	return s
}

func (s *GetURLUploadInfosResponseBodyURLUploadInfoList) SetCreationTime(v string) *GetURLUploadInfosResponseBodyURLUploadInfoList {
	s.CreationTime = &v
	return s
}

func (s *GetURLUploadInfosResponseBodyURLUploadInfoList) SetErrorCode(v string) *GetURLUploadInfosResponseBodyURLUploadInfoList {
	s.ErrorCode = &v
	return s
}

func (s *GetURLUploadInfosResponseBodyURLUploadInfoList) SetErrorMessage(v string) *GetURLUploadInfosResponseBodyURLUploadInfoList {
	s.ErrorMessage = &v
	return s
}

func (s *GetURLUploadInfosResponseBodyURLUploadInfoList) SetFileSize(v string) *GetURLUploadInfosResponseBodyURLUploadInfoList {
	s.FileSize = &v
	return s
}

func (s *GetURLUploadInfosResponseBodyURLUploadInfoList) SetJobId(v string) *GetURLUploadInfosResponseBodyURLUploadInfoList {
	s.JobId = &v
	return s
}

func (s *GetURLUploadInfosResponseBodyURLUploadInfoList) SetMediaId(v string) *GetURLUploadInfosResponseBodyURLUploadInfoList {
	s.MediaId = &v
	return s
}

func (s *GetURLUploadInfosResponseBodyURLUploadInfoList) SetStatus(v string) *GetURLUploadInfosResponseBodyURLUploadInfoList {
	s.Status = &v
	return s
}

func (s *GetURLUploadInfosResponseBodyURLUploadInfoList) SetUploadURL(v string) *GetURLUploadInfosResponseBodyURLUploadInfoList {
	s.UploadURL = &v
	return s
}

func (s *GetURLUploadInfosResponseBodyURLUploadInfoList) SetUserData(v string) *GetURLUploadInfosResponseBodyURLUploadInfoList {
	s.UserData = &v
	return s
}

type GetURLUploadInfosResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetURLUploadInfosResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetURLUploadInfosResponse) String() string {
	return tea.Prettify(s)
}

func (s GetURLUploadInfosResponse) GoString() string {
	return s.String()
}

func (s *GetURLUploadInfosResponse) SetHeaders(v map[string]*string) *GetURLUploadInfosResponse {
	s.Headers = v
	return s
}

func (s *GetURLUploadInfosResponse) SetStatusCode(v int32) *GetURLUploadInfosResponse {
	s.StatusCode = &v
	return s
}

func (s *GetURLUploadInfosResponse) SetBody(v *GetURLUploadInfosResponseBody) *GetURLUploadInfosResponse {
	s.Body = v
	return s
}

type GetUploadDetailsRequest struct {
	// The method that is used to upload the media file.
	MediaIds *string `json:"MediaIds,omitempty" xml:"MediaIds,omitempty"`
	// The upload details.
	MediaType *string `json:"MediaType,omitempty" xml:"MediaType,omitempty"`
}

func (s GetUploadDetailsRequest) String() string {
	return tea.Prettify(s)
}

func (s GetUploadDetailsRequest) GoString() string {
	return s.String()
}

func (s *GetUploadDetailsRequest) SetMediaIds(v string) *GetUploadDetailsRequest {
	s.MediaIds = &v
	return s
}

func (s *GetUploadDetailsRequest) SetMediaType(v string) *GetUploadDetailsRequest {
	s.MediaType = &v
	return s
}

type GetUploadDetailsResponseBody struct {
	// The time when the information about the media file was updated. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.
	ForbiddenMediaIds []*string `json:"ForbiddenMediaIds,omitempty" xml:"ForbiddenMediaIds,omitempty" type:"Repeated"`
	// The size of the uploaded file. Unit: byte.
	NonExistMediaIds []*string `json:"NonExistMediaIds,omitempty" xml:"NonExistMediaIds,omitempty" type:"Repeated"`
	// The operation that you want to perform. Set the value to **GetUploadDetails**.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The upload ratio.
	UploadDetails []*GetUploadDetailsResponseBodyUploadDetails `json:"UploadDetails,omitempty" xml:"UploadDetails,omitempty" type:"Repeated"`
}

func (s GetUploadDetailsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetUploadDetailsResponseBody) GoString() string {
	return s.String()
}

func (s *GetUploadDetailsResponseBody) SetForbiddenMediaIds(v []*string) *GetUploadDetailsResponseBody {
	s.ForbiddenMediaIds = v
	return s
}

func (s *GetUploadDetailsResponseBody) SetNonExistMediaIds(v []*string) *GetUploadDetailsResponseBody {
	s.NonExistMediaIds = v
	return s
}

func (s *GetUploadDetailsResponseBody) SetRequestId(v string) *GetUploadDetailsResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetUploadDetailsResponseBody) SetUploadDetails(v []*GetUploadDetailsResponseBodyUploadDetails) *GetUploadDetailsResponseBody {
	s.UploadDetails = v
	return s
}

type GetUploadDetailsResponseBodyUploadDetails struct {
	// Queries the upload details, such as the upload time, upload ratio, and upload source, about one or more media files based on the media IDs.
	CompletionTime *string `json:"CompletionTime,omitempty" xml:"CompletionTime,omitempty"`
	// The title of the media file.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The time when the upload job was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	DeviceModel *string `json:"DeviceModel,omitempty" xml:"DeviceModel,omitempty"`
	FileSize    *int64  `json:"FileSize,omitempty" xml:"FileSize,omitempty"`
	MediaId     *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The ID of the request.
	ModificationTime *string `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	// The status of the video. For more information about the valid values and value description of the parameter, see the "Status: the status of a video" section of the [Basic structures](~~52839~~) topic.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	Title  *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The upload size. Unit: byte.
	UploadIP    *string  `json:"UploadIP,omitempty" xml:"UploadIP,omitempty"`
	UploadRatio *float32 `json:"UploadRatio,omitempty" xml:"UploadRatio,omitempty"`
	UploadSize  *int64   `json:"UploadSize,omitempty" xml:"UploadSize,omitempty"`
	// The time when the upload job was complete. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	UploadSource *string `json:"UploadSource,omitempty" xml:"UploadSource,omitempty"`
	UploadStatus *string `json:"UploadStatus,omitempty" xml:"UploadStatus,omitempty"`
}

func (s GetUploadDetailsResponseBodyUploadDetails) String() string {
	return tea.Prettify(s)
}

func (s GetUploadDetailsResponseBodyUploadDetails) GoString() string {
	return s.String()
}

func (s *GetUploadDetailsResponseBodyUploadDetails) SetCompletionTime(v string) *GetUploadDetailsResponseBodyUploadDetails {
	s.CompletionTime = &v
	return s
}

func (s *GetUploadDetailsResponseBodyUploadDetails) SetCreationTime(v string) *GetUploadDetailsResponseBodyUploadDetails {
	s.CreationTime = &v
	return s
}

func (s *GetUploadDetailsResponseBodyUploadDetails) SetDeviceModel(v string) *GetUploadDetailsResponseBodyUploadDetails {
	s.DeviceModel = &v
	return s
}

func (s *GetUploadDetailsResponseBodyUploadDetails) SetFileSize(v int64) *GetUploadDetailsResponseBodyUploadDetails {
	s.FileSize = &v
	return s
}

func (s *GetUploadDetailsResponseBodyUploadDetails) SetMediaId(v string) *GetUploadDetailsResponseBodyUploadDetails {
	s.MediaId = &v
	return s
}

func (s *GetUploadDetailsResponseBodyUploadDetails) SetModificationTime(v string) *GetUploadDetailsResponseBodyUploadDetails {
	s.ModificationTime = &v
	return s
}

func (s *GetUploadDetailsResponseBodyUploadDetails) SetStatus(v string) *GetUploadDetailsResponseBodyUploadDetails {
	s.Status = &v
	return s
}

func (s *GetUploadDetailsResponseBodyUploadDetails) SetTitle(v string) *GetUploadDetailsResponseBodyUploadDetails {
	s.Title = &v
	return s
}

func (s *GetUploadDetailsResponseBodyUploadDetails) SetUploadIP(v string) *GetUploadDetailsResponseBodyUploadDetails {
	s.UploadIP = &v
	return s
}

func (s *GetUploadDetailsResponseBodyUploadDetails) SetUploadRatio(v float32) *GetUploadDetailsResponseBodyUploadDetails {
	s.UploadRatio = &v
	return s
}

func (s *GetUploadDetailsResponseBodyUploadDetails) SetUploadSize(v int64) *GetUploadDetailsResponseBodyUploadDetails {
	s.UploadSize = &v
	return s
}

func (s *GetUploadDetailsResponseBodyUploadDetails) SetUploadSource(v string) *GetUploadDetailsResponseBodyUploadDetails {
	s.UploadSource = &v
	return s
}

func (s *GetUploadDetailsResponseBodyUploadDetails) SetUploadStatus(v string) *GetUploadDetailsResponseBodyUploadDetails {
	s.UploadStatus = &v
	return s
}

type GetUploadDetailsResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetUploadDetailsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetUploadDetailsResponse) String() string {
	return tea.Prettify(s)
}

func (s GetUploadDetailsResponse) GoString() string {
	return s.String()
}

func (s *GetUploadDetailsResponse) SetHeaders(v map[string]*string) *GetUploadDetailsResponse {
	s.Headers = v
	return s
}

func (s *GetUploadDetailsResponse) SetStatusCode(v int32) *GetUploadDetailsResponse {
	s.StatusCode = &v
	return s
}

func (s *GetUploadDetailsResponse) SetBody(v *GetUploadDetailsResponseBody) *GetUploadDetailsResponse {
	s.Body = v
	return s
}

type GetVideoInfoRequest struct {
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s GetVideoInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s GetVideoInfoRequest) GoString() string {
	return s.String()
}

func (s *GetVideoInfoRequest) SetVideoId(v string) *GetVideoInfoRequest {
	s.VideoId = &v
	return s
}

type GetVideoInfoResponseBody struct {
	RequestId *string                        `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Video     *GetVideoInfoResponseBodyVideo `json:"Video,omitempty" xml:"Video,omitempty" type:"Struct"`
}

func (s GetVideoInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetVideoInfoResponseBody) GoString() string {
	return s.String()
}

func (s *GetVideoInfoResponseBody) SetRequestId(v string) *GetVideoInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetVideoInfoResponseBody) SetVideo(v *GetVideoInfoResponseBodyVideo) *GetVideoInfoResponseBody {
	s.Video = v
	return s
}

type GetVideoInfoResponseBodyVideo struct {
	AppId             *string                                 `json:"AppId,omitempty" xml:"AppId,omitempty"`
	AuditStatus       *string                                 `json:"AuditStatus,omitempty" xml:"AuditStatus,omitempty"`
	CateId            *int64                                  `json:"CateId,omitempty" xml:"CateId,omitempty"`
	CateName          *string                                 `json:"CateName,omitempty" xml:"CateName,omitempty"`
	CoverURL          *string                                 `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	CreationTime      *string                                 `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	CustomMediaInfo   *string                                 `json:"CustomMediaInfo,omitempty" xml:"CustomMediaInfo,omitempty"`
	Description       *string                                 `json:"Description,omitempty" xml:"Description,omitempty"`
	Duration          *float32                                `json:"Duration,omitempty" xml:"Duration,omitempty"`
	ModificationTime  *string                                 `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	RegionId          *string                                 `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	RestoreExpiration *string                                 `json:"RestoreExpiration,omitempty" xml:"RestoreExpiration,omitempty"`
	RestoreStatus     *string                                 `json:"RestoreStatus,omitempty" xml:"RestoreStatus,omitempty"`
	Size              *int64                                  `json:"Size,omitempty" xml:"Size,omitempty"`
	Snapshots         *GetVideoInfoResponseBodyVideoSnapshots `json:"Snapshots,omitempty" xml:"Snapshots,omitempty" type:"Struct"`
	Status            *string                                 `json:"Status,omitempty" xml:"Status,omitempty"`
	StorageClass      *string                                 `json:"StorageClass,omitempty" xml:"StorageClass,omitempty"`
	StorageLocation   *string                                 `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	Tags              *string                                 `json:"Tags,omitempty" xml:"Tags,omitempty"`
	TemplateGroupId   *string                                 `json:"TemplateGroupId,omitempty" xml:"TemplateGroupId,omitempty"`
	Title             *string                                 `json:"Title,omitempty" xml:"Title,omitempty"`
	VideoId           *string                                 `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s GetVideoInfoResponseBodyVideo) String() string {
	return tea.Prettify(s)
}

func (s GetVideoInfoResponseBodyVideo) GoString() string {
	return s.String()
}

func (s *GetVideoInfoResponseBodyVideo) SetAppId(v string) *GetVideoInfoResponseBodyVideo {
	s.AppId = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetAuditStatus(v string) *GetVideoInfoResponseBodyVideo {
	s.AuditStatus = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetCateId(v int64) *GetVideoInfoResponseBodyVideo {
	s.CateId = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetCateName(v string) *GetVideoInfoResponseBodyVideo {
	s.CateName = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetCoverURL(v string) *GetVideoInfoResponseBodyVideo {
	s.CoverURL = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetCreationTime(v string) *GetVideoInfoResponseBodyVideo {
	s.CreationTime = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetCustomMediaInfo(v string) *GetVideoInfoResponseBodyVideo {
	s.CustomMediaInfo = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetDescription(v string) *GetVideoInfoResponseBodyVideo {
	s.Description = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetDuration(v float32) *GetVideoInfoResponseBodyVideo {
	s.Duration = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetModificationTime(v string) *GetVideoInfoResponseBodyVideo {
	s.ModificationTime = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetRegionId(v string) *GetVideoInfoResponseBodyVideo {
	s.RegionId = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetRestoreExpiration(v string) *GetVideoInfoResponseBodyVideo {
	s.RestoreExpiration = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetRestoreStatus(v string) *GetVideoInfoResponseBodyVideo {
	s.RestoreStatus = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetSize(v int64) *GetVideoInfoResponseBodyVideo {
	s.Size = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetSnapshots(v *GetVideoInfoResponseBodyVideoSnapshots) *GetVideoInfoResponseBodyVideo {
	s.Snapshots = v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetStatus(v string) *GetVideoInfoResponseBodyVideo {
	s.Status = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetStorageClass(v string) *GetVideoInfoResponseBodyVideo {
	s.StorageClass = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetStorageLocation(v string) *GetVideoInfoResponseBodyVideo {
	s.StorageLocation = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetTags(v string) *GetVideoInfoResponseBodyVideo {
	s.Tags = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetTemplateGroupId(v string) *GetVideoInfoResponseBodyVideo {
	s.TemplateGroupId = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetTitle(v string) *GetVideoInfoResponseBodyVideo {
	s.Title = &v
	return s
}

func (s *GetVideoInfoResponseBodyVideo) SetVideoId(v string) *GetVideoInfoResponseBodyVideo {
	s.VideoId = &v
	return s
}

type GetVideoInfoResponseBodyVideoSnapshots struct {
	Snapshot []*string `json:"Snapshot,omitempty" xml:"Snapshot,omitempty" type:"Repeated"`
}

func (s GetVideoInfoResponseBodyVideoSnapshots) String() string {
	return tea.Prettify(s)
}

func (s GetVideoInfoResponseBodyVideoSnapshots) GoString() string {
	return s.String()
}

func (s *GetVideoInfoResponseBodyVideoSnapshots) SetSnapshot(v []*string) *GetVideoInfoResponseBodyVideoSnapshots {
	s.Snapshot = v
	return s
}

type GetVideoInfoResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetVideoInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetVideoInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s GetVideoInfoResponse) GoString() string {
	return s.String()
}

func (s *GetVideoInfoResponse) SetHeaders(v map[string]*string) *GetVideoInfoResponse {
	s.Headers = v
	return s
}

func (s *GetVideoInfoResponse) SetStatusCode(v int32) *GetVideoInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *GetVideoInfoResponse) SetBody(v *GetVideoInfoResponseBody) *GetVideoInfoResponse {
	s.Body = v
	return s
}

type GetVideoInfosRequest struct {
	// The tags of the video. Multiple tags are separated by commas (,).
	VideoIds *string `json:"VideoIds,omitempty" xml:"VideoIds,omitempty"`
}

func (s GetVideoInfosRequest) String() string {
	return tea.Prettify(s)
}

func (s GetVideoInfosRequest) GoString() string {
	return s.String()
}

func (s *GetVideoInfosRequest) SetVideoIds(v string) *GetVideoInfosRequest {
	s.VideoIds = &v
	return s
}

type GetVideoInfosResponseBody struct {
	// The status of the video. By default, videos in all states are returned. Multiple states are separated by commas (,). Valid values:
	//
	// *   **Uploading**: The video is being uploaded.
	// *   **UploadFail**: The video fails to be uploaded.
	// *   **UploadSucc**: The video is uploaded.
	// *   **Transcoding**: The video is being transcoded.
	// *   **TranscodeFail**: The video fails to be transcoded.
	// *   **Blocked**: The video is blocked.
	// *   **Normal**: The video can be played.
	NonExistVideoIds []*string `json:"NonExistVideoIds,omitempty" xml:"NonExistVideoIds,omitempty" type:"Repeated"`
	// The title of the video.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The description of the video.
	VideoList []*GetVideoInfosResponseBodyVideoList `json:"VideoList,omitempty" xml:"VideoList,omitempty" type:"Repeated"`
}

func (s GetVideoInfosResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetVideoInfosResponseBody) GoString() string {
	return s.String()
}

func (s *GetVideoInfosResponseBody) SetNonExistVideoIds(v []*string) *GetVideoInfosResponseBody {
	s.NonExistVideoIds = v
	return s
}

func (s *GetVideoInfosResponseBody) SetRequestId(v string) *GetVideoInfosResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetVideoInfosResponseBody) SetVideoList(v []*GetVideoInfosResponseBodyVideoList) *GetVideoInfosResponseBody {
	s.VideoList = v
	return s
}

type GetVideoInfosResponseBodyVideoList struct {
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The Object Storage Service (OSS) bucket where the video file is stored.
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The name of the video category.
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	CoverURL *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	// The time when the video file was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// Queries the information about multiple videos at a time.
	Description *string  `json:"Description,omitempty" xml:"Description,omitempty"`
	Duration    *float32 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The URL array of video snapshots.
	ModificationTime  *string   `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	RestoreExpiration *string   `json:"RestoreExpiration,omitempty" xml:"RestoreExpiration,omitempty"`
	RestoreStatus     *string   `json:"RestoreStatus,omitempty" xml:"RestoreStatus,omitempty"`
	Size              *int64    `json:"Size,omitempty" xml:"Size,omitempty"`
	Snapshots         []*string `json:"Snapshots,omitempty" xml:"Snapshots,omitempty" type:"Repeated"`
	// The URL of the video thumbnail.
	Status       *string `json:"Status,omitempty" xml:"Status,omitempty"`
	StorageClass *string `json:"StorageClass,omitempty" xml:"StorageClass,omitempty"`
	// The information about the video.
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	// The ID of the video category.
	Tags            *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	TemplateGroupId *string `json:"TemplateGroupId,omitempty" xml:"TemplateGroupId,omitempty"`
	Title           *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The list of video IDs. Separate multiple IDs with commas (,). A maximum of 20 IDs can be specified.
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s GetVideoInfosResponseBodyVideoList) String() string {
	return tea.Prettify(s)
}

func (s GetVideoInfosResponseBodyVideoList) GoString() string {
	return s.String()
}

func (s *GetVideoInfosResponseBodyVideoList) SetAppId(v string) *GetVideoInfosResponseBodyVideoList {
	s.AppId = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetCateId(v int64) *GetVideoInfosResponseBodyVideoList {
	s.CateId = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetCateName(v string) *GetVideoInfosResponseBodyVideoList {
	s.CateName = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetCoverURL(v string) *GetVideoInfosResponseBodyVideoList {
	s.CoverURL = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetCreationTime(v string) *GetVideoInfosResponseBodyVideoList {
	s.CreationTime = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetDescription(v string) *GetVideoInfosResponseBodyVideoList {
	s.Description = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetDuration(v float32) *GetVideoInfosResponseBodyVideoList {
	s.Duration = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetModificationTime(v string) *GetVideoInfosResponseBodyVideoList {
	s.ModificationTime = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetRestoreExpiration(v string) *GetVideoInfosResponseBodyVideoList {
	s.RestoreExpiration = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetRestoreStatus(v string) *GetVideoInfosResponseBodyVideoList {
	s.RestoreStatus = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetSize(v int64) *GetVideoInfosResponseBodyVideoList {
	s.Size = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetSnapshots(v []*string) *GetVideoInfosResponseBodyVideoList {
	s.Snapshots = v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetStatus(v string) *GetVideoInfosResponseBodyVideoList {
	s.Status = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetStorageClass(v string) *GetVideoInfosResponseBodyVideoList {
	s.StorageClass = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetStorageLocation(v string) *GetVideoInfosResponseBodyVideoList {
	s.StorageLocation = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetTags(v string) *GetVideoInfosResponseBodyVideoList {
	s.Tags = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetTemplateGroupId(v string) *GetVideoInfosResponseBodyVideoList {
	s.TemplateGroupId = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetTitle(v string) *GetVideoInfosResponseBodyVideoList {
	s.Title = &v
	return s
}

func (s *GetVideoInfosResponseBodyVideoList) SetVideoId(v string) *GetVideoInfosResponseBodyVideoList {
	s.VideoId = &v
	return s
}

type GetVideoInfosResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetVideoInfosResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetVideoInfosResponse) String() string {
	return tea.Prettify(s)
}

func (s GetVideoInfosResponse) GoString() string {
	return s.String()
}

func (s *GetVideoInfosResponse) SetHeaders(v map[string]*string) *GetVideoInfosResponse {
	s.Headers = v
	return s
}

func (s *GetVideoInfosResponse) SetStatusCode(v int32) *GetVideoInfosResponse {
	s.StatusCode = &v
	return s
}

func (s *GetVideoInfosResponse) SetBody(v *GetVideoInfosResponseBody) *GetVideoInfosResponse {
	s.Body = v
	return s
}

type GetVideoListRequest struct {
	// The category ID. You can use one of the following methods to obtain the category ID:
	//
	// *   Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Configuration Management** > **Media Management** > **Categories** to view the category ID.
	// *   Obtain the value of CateId from the response to the [AddCategory](~~56401~~) operation.
	// *   Obtain the value of CateId from the response to the [GetCategories](~~56406~~) operation.
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNo *int32 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The number of entries to return on each page. Default value: **10**. Maximum value: **100**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The sorting method of the results. Valid values:
	//
	// *   **CreationTime:Desc** (default): The results are sorted in reverse chronological order based on the creation time.
	// *   **CreationTime:Asc**: The results are sorted in chronological order based on the creation time.
	SortBy *string `json:"SortBy,omitempty" xml:"SortBy,omitempty"`
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The video status. You can specify multiple video statuses and separate them with commas (,). Valid values:
	//
	// *   **Uploading**: The video is being uploaded.
	// *   **UploadFail**: The video failed to be uploaded.
	// *   **UploadSucc**: The video has been uploaded.
	// *   **Transcoding**: The video is being transcoded.
	// *   **TranscodeFail**: The video failed to be transcoded.
	// *   **checking**: The video is being reviewed.
	// *   **Blocked**: The video is blocked.
	// *   **Normal**: The video is normal.
	// *   **ProduceFail**: The video failed to be produced.
	//
	// For more information about each video status, see the "Status: the status of a video" section of the [Basic data types](~~52839#section-p7c-jgy-070~~) topic.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The storage address of the media file.
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
}

func (s GetVideoListRequest) String() string {
	return tea.Prettify(s)
}

func (s GetVideoListRequest) GoString() string {
	return s.String()
}

func (s *GetVideoListRequest) SetCateId(v int64) *GetVideoListRequest {
	s.CateId = &v
	return s
}

func (s *GetVideoListRequest) SetEndTime(v string) *GetVideoListRequest {
	s.EndTime = &v
	return s
}

func (s *GetVideoListRequest) SetPageNo(v int32) *GetVideoListRequest {
	s.PageNo = &v
	return s
}

func (s *GetVideoListRequest) SetPageSize(v int32) *GetVideoListRequest {
	s.PageSize = &v
	return s
}

func (s *GetVideoListRequest) SetSortBy(v string) *GetVideoListRequest {
	s.SortBy = &v
	return s
}

func (s *GetVideoListRequest) SetStartTime(v string) *GetVideoListRequest {
	s.StartTime = &v
	return s
}

func (s *GetVideoListRequest) SetStatus(v string) *GetVideoListRequest {
	s.Status = &v
	return s
}

func (s *GetVideoListRequest) SetStorageLocation(v string) *GetVideoListRequest {
	s.StorageLocation = &v
	return s
}

type GetVideoListResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of media files returned.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
	// The information about the media file. Information about a maximum of 5,000 media files can be returned.
	VideoList *GetVideoListResponseBodyVideoList `json:"VideoList,omitempty" xml:"VideoList,omitempty" type:"Struct"`
}

func (s GetVideoListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetVideoListResponseBody) GoString() string {
	return s.String()
}

func (s *GetVideoListResponseBody) SetRequestId(v string) *GetVideoListResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetVideoListResponseBody) SetTotal(v int32) *GetVideoListResponseBody {
	s.Total = &v
	return s
}

func (s *GetVideoListResponseBody) SetVideoList(v *GetVideoListResponseBodyVideoList) *GetVideoListResponseBody {
	s.VideoList = v
	return s
}

type GetVideoListResponseBodyVideoList struct {
	Video []*GetVideoListResponseBodyVideoListVideo `json:"Video,omitempty" xml:"Video,omitempty" type:"Repeated"`
}

func (s GetVideoListResponseBodyVideoList) String() string {
	return tea.Prettify(s)
}

func (s GetVideoListResponseBodyVideoList) GoString() string {
	return s.String()
}

func (s *GetVideoListResponseBodyVideoList) SetVideo(v []*GetVideoListResponseBodyVideoListVideo) *GetVideoListResponseBodyVideoList {
	s.Video = v
	return s
}

type GetVideoListResponseBodyVideoListVideo struct {
	// The application ID. Default value: **app-1000000**.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The category ID.
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The category name.
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	// The thumbnail URL of the media file.
	CoverURL *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	// The time when the media file was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the media file.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The duration of the media file. Unit: seconds.
	Duration *float32 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The time when the video was updated. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	ModificationTime  *string `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	RestoreExpiration *string `json:"RestoreExpiration,omitempty" xml:"RestoreExpiration,omitempty"`
	RestoreStatus     *string `json:"RestoreStatus,omitempty" xml:"RestoreStatus,omitempty"`
	// The size of the source file. Unit: bytes.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The video snapshot URLs.
	Snapshots *GetVideoListResponseBodyVideoListVideoSnapshots `json:"Snapshots,omitempty" xml:"Snapshots,omitempty" type:"Struct"`
	// The video status. Valid values:
	//
	// *   **Uploading**: The video is being uploaded.
	// *   **UploadFail**: The video failed to be uploaded.
	// *   **UploadSucc**: The video has been uploaded.
	// *   **Transcoding**: The video is being transcoded.
	// *   **TranscodeFail**: The video failed to be transcoded.
	// *   **checking**: The video is being reviewed.
	// *   **Blocked**: The video is blocked.
	// *   **Normal**: The video is normal.
	// *   **ProduceFail**: The video failed to be produced.
	//
	// For more information about each video status, see the "Status: the status of a video" section of the [Basic data types](~~52839#section-p7c-jgy-070~~) topic.
	Status       *string `json:"Status,omitempty" xml:"Status,omitempty"`
	StorageClass *string `json:"StorageClass,omitempty" xml:"StorageClass,omitempty"`
	// The storage address of the media file.
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	// The tags of the media file. Multiple tags are separated by commas (,).
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The title of the media file.
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The ID of the media file.
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s GetVideoListResponseBodyVideoListVideo) String() string {
	return tea.Prettify(s)
}

func (s GetVideoListResponseBodyVideoListVideo) GoString() string {
	return s.String()
}

func (s *GetVideoListResponseBodyVideoListVideo) SetAppId(v string) *GetVideoListResponseBodyVideoListVideo {
	s.AppId = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetCateId(v int64) *GetVideoListResponseBodyVideoListVideo {
	s.CateId = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetCateName(v string) *GetVideoListResponseBodyVideoListVideo {
	s.CateName = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetCoverURL(v string) *GetVideoListResponseBodyVideoListVideo {
	s.CoverURL = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetCreationTime(v string) *GetVideoListResponseBodyVideoListVideo {
	s.CreationTime = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetDescription(v string) *GetVideoListResponseBodyVideoListVideo {
	s.Description = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetDuration(v float32) *GetVideoListResponseBodyVideoListVideo {
	s.Duration = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetModificationTime(v string) *GetVideoListResponseBodyVideoListVideo {
	s.ModificationTime = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetRestoreExpiration(v string) *GetVideoListResponseBodyVideoListVideo {
	s.RestoreExpiration = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetRestoreStatus(v string) *GetVideoListResponseBodyVideoListVideo {
	s.RestoreStatus = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetSize(v int64) *GetVideoListResponseBodyVideoListVideo {
	s.Size = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetSnapshots(v *GetVideoListResponseBodyVideoListVideoSnapshots) *GetVideoListResponseBodyVideoListVideo {
	s.Snapshots = v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetStatus(v string) *GetVideoListResponseBodyVideoListVideo {
	s.Status = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetStorageClass(v string) *GetVideoListResponseBodyVideoListVideo {
	s.StorageClass = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetStorageLocation(v string) *GetVideoListResponseBodyVideoListVideo {
	s.StorageLocation = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetTags(v string) *GetVideoListResponseBodyVideoListVideo {
	s.Tags = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetTitle(v string) *GetVideoListResponseBodyVideoListVideo {
	s.Title = &v
	return s
}

func (s *GetVideoListResponseBodyVideoListVideo) SetVideoId(v string) *GetVideoListResponseBodyVideoListVideo {
	s.VideoId = &v
	return s
}

type GetVideoListResponseBodyVideoListVideoSnapshots struct {
	Snapshot []*string `json:"Snapshot,omitempty" xml:"Snapshot,omitempty" type:"Repeated"`
}

func (s GetVideoListResponseBodyVideoListVideoSnapshots) String() string {
	return tea.Prettify(s)
}

func (s GetVideoListResponseBodyVideoListVideoSnapshots) GoString() string {
	return s.String()
}

func (s *GetVideoListResponseBodyVideoListVideoSnapshots) SetSnapshot(v []*string) *GetVideoListResponseBodyVideoListVideoSnapshots {
	s.Snapshot = v
	return s
}

type GetVideoListResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetVideoListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetVideoListResponse) String() string {
	return tea.Prettify(s)
}

func (s GetVideoListResponse) GoString() string {
	return s.String()
}

func (s *GetVideoListResponse) SetHeaders(v map[string]*string) *GetVideoListResponse {
	s.Headers = v
	return s
}

func (s *GetVideoListResponse) SetStatusCode(v int32) *GetVideoListResponse {
	s.StatusCode = &v
	return s
}

func (s *GetVideoListResponse) SetBody(v *GetVideoListResponseBody) *GetVideoListResponse {
	s.Body = v
	return s
}

type GetVideoPlayAuthRequest struct {
	// The duration of the audio or video file. Unit: seconds.
	ApiVersion *string `json:"ApiVersion,omitempty" xml:"ApiVersion,omitempty"`
	// The title of the audio or video file.
	AuthInfoTimeout *int64 `json:"AuthInfoTimeout,omitempty" xml:"AuthInfoTimeout,omitempty"`
	// The API version number. Set the value to **1.0.0**.
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s GetVideoPlayAuthRequest) String() string {
	return tea.Prettify(s)
}

func (s GetVideoPlayAuthRequest) GoString() string {
	return s.String()
}

func (s *GetVideoPlayAuthRequest) SetApiVersion(v string) *GetVideoPlayAuthRequest {
	s.ApiVersion = &v
	return s
}

func (s *GetVideoPlayAuthRequest) SetAuthInfoTimeout(v int64) *GetVideoPlayAuthRequest {
	s.AuthInfoTimeout = &v
	return s
}

func (s *GetVideoPlayAuthRequest) SetVideoId(v string) *GetVideoPlayAuthRequest {
	s.VideoId = &v
	return s
}

type GetVideoPlayAuthResponseBody struct {
	// The ID of the request.
	PlayAuth *string `json:"PlayAuth,omitempty" xml:"PlayAuth,omitempty"`
	// The operation that you want to perform. Set the value to **GetVideoPlayAuth**.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Queries the credential required for media playback.
	VideoMeta *GetVideoPlayAuthResponseBodyVideoMeta `json:"VideoMeta,omitempty" xml:"VideoMeta,omitempty" type:"Struct"`
}

func (s GetVideoPlayAuthResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetVideoPlayAuthResponseBody) GoString() string {
	return s.String()
}

func (s *GetVideoPlayAuthResponseBody) SetPlayAuth(v string) *GetVideoPlayAuthResponseBody {
	s.PlayAuth = &v
	return s
}

func (s *GetVideoPlayAuthResponseBody) SetRequestId(v string) *GetVideoPlayAuthResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetVideoPlayAuthResponseBody) SetVideoMeta(v *GetVideoPlayAuthResponseBodyVideoMeta) *GetVideoPlayAuthResponseBody {
	s.VideoMeta = v
	return s
}

type GetVideoPlayAuthResponseBodyVideoMeta struct {
	CoverURL *string  `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	Duration *float32 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	Status   *string  `json:"Status,omitempty" xml:"Status,omitempty"`
	Title    *string  `json:"Title,omitempty" xml:"Title,omitempty"`
	VideoId  *string  `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s GetVideoPlayAuthResponseBodyVideoMeta) String() string {
	return tea.Prettify(s)
}

func (s GetVideoPlayAuthResponseBodyVideoMeta) GoString() string {
	return s.String()
}

func (s *GetVideoPlayAuthResponseBodyVideoMeta) SetCoverURL(v string) *GetVideoPlayAuthResponseBodyVideoMeta {
	s.CoverURL = &v
	return s
}

func (s *GetVideoPlayAuthResponseBodyVideoMeta) SetDuration(v float32) *GetVideoPlayAuthResponseBodyVideoMeta {
	s.Duration = &v
	return s
}

func (s *GetVideoPlayAuthResponseBodyVideoMeta) SetStatus(v string) *GetVideoPlayAuthResponseBodyVideoMeta {
	s.Status = &v
	return s
}

func (s *GetVideoPlayAuthResponseBodyVideoMeta) SetTitle(v string) *GetVideoPlayAuthResponseBodyVideoMeta {
	s.Title = &v
	return s
}

func (s *GetVideoPlayAuthResponseBodyVideoMeta) SetVideoId(v string) *GetVideoPlayAuthResponseBodyVideoMeta {
	s.VideoId = &v
	return s
}

type GetVideoPlayAuthResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetVideoPlayAuthResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetVideoPlayAuthResponse) String() string {
	return tea.Prettify(s)
}

func (s GetVideoPlayAuthResponse) GoString() string {
	return s.String()
}

func (s *GetVideoPlayAuthResponse) SetHeaders(v map[string]*string) *GetVideoPlayAuthResponse {
	s.Headers = v
	return s
}

func (s *GetVideoPlayAuthResponse) SetStatusCode(v int32) *GetVideoPlayAuthResponse {
	s.StatusCode = &v
	return s
}

func (s *GetVideoPlayAuthResponse) SetBody(v *GetVideoPlayAuthResponseBody) *GetVideoPlayAuthResponse {
	s.Body = v
	return s
}

type GetVodTemplateRequest struct {
	// Indicates whether the template is the default one. Valid values:
	//
	// *   **Default**: The template is the default one.
	// *   **NotDefault**: The template is not the default one.
	VodTemplateId *string `json:"VodTemplateId,omitempty" xml:"VodTemplateId,omitempty"`
}

func (s GetVodTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s GetVodTemplateRequest) GoString() string {
	return s.String()
}

func (s *GetVodTemplateRequest) SetVodTemplateId(v string) *GetVodTemplateRequest {
	s.VodTemplateId = &v
	return s
}

type GetVodTemplateResponseBody struct {
	// The time when the template was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the template.
	VodTemplateInfo *GetVodTemplateResponseBodyVodTemplateInfo `json:"VodTemplateInfo,omitempty" xml:"VodTemplateInfo,omitempty" type:"Struct"`
}

func (s GetVodTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetVodTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *GetVodTemplateResponseBody) SetRequestId(v string) *GetVodTemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetVodTemplateResponseBody) SetVodTemplateInfo(v *GetVodTemplateResponseBodyVodTemplateInfo) *GetVodTemplateResponseBody {
	s.VodTemplateInfo = v
	return s
}

type GetVodTemplateResponseBodyVodTemplateInfo struct {
	// The name of the template.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The ID of the request.
	IsDefault  *string `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	ModifyTime *string `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	Name       *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Queries a single snapshot template.
	TemplateConfig *string `json:"TemplateConfig,omitempty" xml:"TemplateConfig,omitempty"`
	// The operation that you want to perform. Set the value to **GetVodTemplate**.
	TemplateType *string `json:"TemplateType,omitempty" xml:"TemplateType,omitempty"`
	// The detailed configurations of the template. The value is a JSON-formatted string. For more information about the data structure, see the "SnapshotTemplateConfig" section of the [Media processing parameters](~~98618~~) topic.
	VodTemplateId *string `json:"VodTemplateId,omitempty" xml:"VodTemplateId,omitempty"`
}

func (s GetVodTemplateResponseBodyVodTemplateInfo) String() string {
	return tea.Prettify(s)
}

func (s GetVodTemplateResponseBodyVodTemplateInfo) GoString() string {
	return s.String()
}

func (s *GetVodTemplateResponseBodyVodTemplateInfo) SetCreationTime(v string) *GetVodTemplateResponseBodyVodTemplateInfo {
	s.CreationTime = &v
	return s
}

func (s *GetVodTemplateResponseBodyVodTemplateInfo) SetIsDefault(v string) *GetVodTemplateResponseBodyVodTemplateInfo {
	s.IsDefault = &v
	return s
}

func (s *GetVodTemplateResponseBodyVodTemplateInfo) SetModifyTime(v string) *GetVodTemplateResponseBodyVodTemplateInfo {
	s.ModifyTime = &v
	return s
}

func (s *GetVodTemplateResponseBodyVodTemplateInfo) SetName(v string) *GetVodTemplateResponseBodyVodTemplateInfo {
	s.Name = &v
	return s
}

func (s *GetVodTemplateResponseBodyVodTemplateInfo) SetTemplateConfig(v string) *GetVodTemplateResponseBodyVodTemplateInfo {
	s.TemplateConfig = &v
	return s
}

func (s *GetVodTemplateResponseBodyVodTemplateInfo) SetTemplateType(v string) *GetVodTemplateResponseBodyVodTemplateInfo {
	s.TemplateType = &v
	return s
}

func (s *GetVodTemplateResponseBodyVodTemplateInfo) SetVodTemplateId(v string) *GetVodTemplateResponseBodyVodTemplateInfo {
	s.VodTemplateId = &v
	return s
}

type GetVodTemplateResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetVodTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetVodTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s GetVodTemplateResponse) GoString() string {
	return s.String()
}

func (s *GetVodTemplateResponse) SetHeaders(v map[string]*string) *GetVodTemplateResponse {
	s.Headers = v
	return s
}

func (s *GetVodTemplateResponse) SetStatusCode(v int32) *GetVodTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *GetVodTemplateResponse) SetBody(v *GetVodTemplateResponseBody) *GetVodTemplateResponse {
	s.Body = v
	return s
}

type GetWatermarkRequest struct {
	// The information about the watermark.
	WatermarkId *string `json:"WatermarkId,omitempty" xml:"WatermarkId,omitempty"`
}

func (s GetWatermarkRequest) String() string {
	return tea.Prettify(s)
}

func (s GetWatermarkRequest) GoString() string {
	return s.String()
}

func (s *GetWatermarkRequest) SetWatermarkId(v string) *GetWatermarkRequest {
	s.WatermarkId = &v
	return s
}

type GetWatermarkResponseBody struct {
	// The time when the watermark was added. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the application.
	WatermarkInfo *GetWatermarkResponseBodyWatermarkInfo `json:"WatermarkInfo,omitempty" xml:"WatermarkInfo,omitempty" type:"Struct"`
}

func (s GetWatermarkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetWatermarkResponseBody) GoString() string {
	return s.String()
}

func (s *GetWatermarkResponseBody) SetRequestId(v string) *GetWatermarkResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetWatermarkResponseBody) SetWatermarkInfo(v *GetWatermarkResponseBodyWatermarkInfo) *GetWatermarkResponseBody {
	s.WatermarkInfo = v
	return s
}

type GetWatermarkResponseBodyWatermarkInfo struct {
	// The ID of the watermark.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The name of the watermark.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The operation that you want to perform. Set the value to **GetWatermark**.
	FileUrl *string `json:"FileUrl,omitempty" xml:"FileUrl,omitempty"`
	// The ID of the request.
	IsDefault *string `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	Name      *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The Object Storage Service (OSS) URL or Content Delivery Network (CDN) URL of the watermark file. A text watermark does not have a file URL.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// Queries a single watermark.
	WatermarkConfig *string `json:"WatermarkConfig,omitempty" xml:"WatermarkConfig,omitempty"`
	WatermarkId     *string `json:"WatermarkId,omitempty" xml:"WatermarkId,omitempty"`
}

func (s GetWatermarkResponseBodyWatermarkInfo) String() string {
	return tea.Prettify(s)
}

func (s GetWatermarkResponseBodyWatermarkInfo) GoString() string {
	return s.String()
}

func (s *GetWatermarkResponseBodyWatermarkInfo) SetAppId(v string) *GetWatermarkResponseBodyWatermarkInfo {
	s.AppId = &v
	return s
}

func (s *GetWatermarkResponseBodyWatermarkInfo) SetCreationTime(v string) *GetWatermarkResponseBodyWatermarkInfo {
	s.CreationTime = &v
	return s
}

func (s *GetWatermarkResponseBodyWatermarkInfo) SetFileUrl(v string) *GetWatermarkResponseBodyWatermarkInfo {
	s.FileUrl = &v
	return s
}

func (s *GetWatermarkResponseBodyWatermarkInfo) SetIsDefault(v string) *GetWatermarkResponseBodyWatermarkInfo {
	s.IsDefault = &v
	return s
}

func (s *GetWatermarkResponseBodyWatermarkInfo) SetName(v string) *GetWatermarkResponseBodyWatermarkInfo {
	s.Name = &v
	return s
}

func (s *GetWatermarkResponseBodyWatermarkInfo) SetType(v string) *GetWatermarkResponseBodyWatermarkInfo {
	s.Type = &v
	return s
}

func (s *GetWatermarkResponseBodyWatermarkInfo) SetWatermarkConfig(v string) *GetWatermarkResponseBodyWatermarkInfo {
	s.WatermarkConfig = &v
	return s
}

func (s *GetWatermarkResponseBodyWatermarkInfo) SetWatermarkId(v string) *GetWatermarkResponseBodyWatermarkInfo {
	s.WatermarkId = &v
	return s
}

type GetWatermarkResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetWatermarkResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetWatermarkResponse) String() string {
	return tea.Prettify(s)
}

func (s GetWatermarkResponse) GoString() string {
	return s.String()
}

func (s *GetWatermarkResponse) SetHeaders(v map[string]*string) *GetWatermarkResponse {
	s.Headers = v
	return s
}

func (s *GetWatermarkResponse) SetStatusCode(v int32) *GetWatermarkResponse {
	s.StatusCode = &v
	return s
}

func (s *GetWatermarkResponse) SetBody(v *GetWatermarkResponseBody) *GetWatermarkResponse {
	s.Body = v
	return s
}

type ListAIImageInfoRequest struct {
	// The ID of the video. You can use one of the following methods to obtain the ID:
	//
	// *   Log on to the [ApsaraVideo VOD](https://vod.console.aliyun.com) console. In the left-side navigation pane, choose **Media Files** > **Audio/Video**. On the Video and Audio page, view the ID of the audio or video file. This method is applicable to files that are uploaded by using the ApsaraVideo VOD console.
	// *   Obtain the value of VideoId from the response to the [CreateUploadVideo](~~55407~~) operation that you call to upload media files.
	// *   Obtain the value of VideoId from the response to the [SearchMedia](~~86044~~) operation after you upload media files.
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s ListAIImageInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAIImageInfoRequest) GoString() string {
	return s.String()
}

func (s *ListAIImageInfoRequest) SetVideoId(v string) *ListAIImageInfoRequest {
	s.VideoId = &v
	return s
}

type ListAIImageInfoResponseBody struct {
	// The image files that are uploaded for AI processing.
	AIImageInfoList []*ListAIImageInfoResponseBodyAIImageInfoList `json:"AIImageInfoList,omitempty" xml:"AIImageInfoList,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListAIImageInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAIImageInfoResponseBody) GoString() string {
	return s.String()
}

func (s *ListAIImageInfoResponseBody) SetAIImageInfoList(v []*ListAIImageInfoResponseBodyAIImageInfoList) *ListAIImageInfoResponseBody {
	s.AIImageInfoList = v
	return s
}

func (s *ListAIImageInfoResponseBody) SetRequestId(v string) *ListAIImageInfoResponseBody {
	s.RequestId = &v
	return s
}

type ListAIImageInfoResponseBodyAIImageInfoList struct {
	// The ID of the image information.
	AIImageInfoId *string `json:"AIImageInfoId,omitempty" xml:"AIImageInfoId,omitempty"`
	// The time when the file was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The URL of the image file.
	FileURL *string `json:"FileURL,omitempty" xml:"FileURL,omitempty"`
	// The format of the image. Valid values: **gif** and **png**.
	Format *string `json:"Format,omitempty" xml:"Format,omitempty"`
	// The ID of the image AI processing job.
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The score of the image.
	Score *string `json:"Score,omitempty" xml:"Score,omitempty"`
	// The data version ID.
	Version *string `json:"Version,omitempty" xml:"Version,omitempty"`
	// The ID of the video.
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s ListAIImageInfoResponseBodyAIImageInfoList) String() string {
	return tea.Prettify(s)
}

func (s ListAIImageInfoResponseBodyAIImageInfoList) GoString() string {
	return s.String()
}

func (s *ListAIImageInfoResponseBodyAIImageInfoList) SetAIImageInfoId(v string) *ListAIImageInfoResponseBodyAIImageInfoList {
	s.AIImageInfoId = &v
	return s
}

func (s *ListAIImageInfoResponseBodyAIImageInfoList) SetCreationTime(v string) *ListAIImageInfoResponseBodyAIImageInfoList {
	s.CreationTime = &v
	return s
}

func (s *ListAIImageInfoResponseBodyAIImageInfoList) SetFileURL(v string) *ListAIImageInfoResponseBodyAIImageInfoList {
	s.FileURL = &v
	return s
}

func (s *ListAIImageInfoResponseBodyAIImageInfoList) SetFormat(v string) *ListAIImageInfoResponseBodyAIImageInfoList {
	s.Format = &v
	return s
}

func (s *ListAIImageInfoResponseBodyAIImageInfoList) SetJobId(v string) *ListAIImageInfoResponseBodyAIImageInfoList {
	s.JobId = &v
	return s
}

func (s *ListAIImageInfoResponseBodyAIImageInfoList) SetScore(v string) *ListAIImageInfoResponseBodyAIImageInfoList {
	s.Score = &v
	return s
}

func (s *ListAIImageInfoResponseBodyAIImageInfoList) SetVersion(v string) *ListAIImageInfoResponseBodyAIImageInfoList {
	s.Version = &v
	return s
}

func (s *ListAIImageInfoResponseBodyAIImageInfoList) SetVideoId(v string) *ListAIImageInfoResponseBodyAIImageInfoList {
	s.VideoId = &v
	return s
}

type ListAIImageInfoResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAIImageInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAIImageInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAIImageInfoResponse) GoString() string {
	return s.String()
}

func (s *ListAIImageInfoResponse) SetHeaders(v map[string]*string) *ListAIImageInfoResponse {
	s.Headers = v
	return s
}

func (s *ListAIImageInfoResponse) SetStatusCode(v int32) *ListAIImageInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAIImageInfoResponse) SetBody(v *ListAIImageInfoResponseBody) *ListAIImageInfoResponse {
	s.Body = v
	return s
}

type ListAIJobRequest struct {
	// The time when the job is complete. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	JobIds               *string `json:"JobIds,omitempty" xml:"JobIds,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ListAIJobRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAIJobRequest) GoString() string {
	return s.String()
}

func (s *ListAIJobRequest) SetJobIds(v string) *ListAIJobRequest {
	s.JobIds = &v
	return s
}

func (s *ListAIJobRequest) SetOwnerAccount(v string) *ListAIJobRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListAIJobRequest) SetOwnerId(v string) *ListAIJobRequest {
	s.OwnerId = &v
	return s
}

func (s *ListAIJobRequest) SetResourceOwnerAccount(v string) *ListAIJobRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListAIJobRequest) SetResourceOwnerId(v string) *ListAIJobRequest {
	s.ResourceOwnerId = &v
	return s
}

type ListAIJobResponseBody struct {
	// The list of job IDs. You can obtain the job ID from the PlayInfo parameter in the response to the [GetPlayInfo](~~56124~~) operation.
	//
	// >  You can specify a maximum of 10 job IDs in a request. Separate multiple IDs with commas (,).
	AIJobList *ListAIJobResponseBodyAIJobList `json:"AIJobList,omitempty" xml:"AIJobList,omitempty" type:"Struct"`
	// The error code. This parameter is returned if the value of Status is fail.
	NonExistAIJobIds *ListAIJobResponseBodyNonExistAIJobIds `json:"NonExistAIJobIds,omitempty" xml:"NonExistAIJobIds,omitempty" type:"Struct"`
	// The ID of the job.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListAIJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAIJobResponseBody) GoString() string {
	return s.String()
}

func (s *ListAIJobResponseBody) SetAIJobList(v *ListAIJobResponseBodyAIJobList) *ListAIJobResponseBody {
	s.AIJobList = v
	return s
}

func (s *ListAIJobResponseBody) SetNonExistAIJobIds(v *ListAIJobResponseBodyNonExistAIJobIds) *ListAIJobResponseBody {
	s.NonExistAIJobIds = v
	return s
}

func (s *ListAIJobResponseBody) SetRequestId(v string) *ListAIJobResponseBody {
	s.RequestId = &v
	return s
}

type ListAIJobResponseBodyAIJobList struct {
	AIJob []*ListAIJobResponseBodyAIJobListAIJob `json:"AIJob,omitempty" xml:"AIJob,omitempty" type:"Repeated"`
}

func (s ListAIJobResponseBodyAIJobList) String() string {
	return tea.Prettify(s)
}

func (s ListAIJobResponseBodyAIJobList) GoString() string {
	return s.String()
}

func (s *ListAIJobResponseBodyAIJobList) SetAIJob(v []*ListAIJobResponseBodyAIJobListAIJob) *ListAIJobResponseBodyAIJobList {
	s.AIJob = v
	return s
}

type ListAIJobResponseBodyAIJobListAIJob struct {
	// Queries AI jobs. After a job is submitted, ApsaraVideo VOD asynchronously processes the job. You can call this operation to query the job information in real time.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The ID of the request.
	CompleteTime *string `json:"CompleteTime,omitempty" xml:"CompleteTime,omitempty"`
	// The status of the job. Valid values:
	//
	// *   **success**: The job is complete.
	// *   **fail**: The job failed.
	// *   **init**: The job is being initialized.
	// *   **Processing**: The job is in progress.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// {"OrigASRData":{"AsrTextList":\[{"EndTime":700,"StartTime":0,"Text":"Yes.","ChannelId":0,"SpeechRate":85},{"EndTime":3750,"StartTime":1630,"Text":"No.","ChannelId":0,"SpeechRate":28},{"EndTime":5910,"StartTime":4020,"Text":"Of course.","ChannelId":0,"SpeechRate":95},{"EndTime":12750,"StartTime":10090,"Text":"Message.","ChannelId":0,"SpeechRate":45},{"EndTime":25230,"StartTime":13590,"Text":"Hello, good afternoon.","ChannelId":0,"SpeechRate":20},{"EndTime":30000,"StartTime":28220,"Text":"Yes.","ChannelId":0,"SpeechRate":33}],"Duration":"30016"}}
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The ID of the video.
	JobId   *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The error message. This parameter is returned if the value of Status is fail.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The returned data. The value is a JSON string.
	//
	// For more information, see [AITemplateConfig](~~89863~~).
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListAIJobResponseBodyAIJobListAIJob) String() string {
	return tea.Prettify(s)
}

func (s ListAIJobResponseBodyAIJobListAIJob) GoString() string {
	return s.String()
}

func (s *ListAIJobResponseBodyAIJobListAIJob) SetCode(v string) *ListAIJobResponseBodyAIJobListAIJob {
	s.Code = &v
	return s
}

func (s *ListAIJobResponseBodyAIJobListAIJob) SetCompleteTime(v string) *ListAIJobResponseBodyAIJobListAIJob {
	s.CompleteTime = &v
	return s
}

func (s *ListAIJobResponseBodyAIJobListAIJob) SetCreationTime(v string) *ListAIJobResponseBodyAIJobListAIJob {
	s.CreationTime = &v
	return s
}

func (s *ListAIJobResponseBodyAIJobListAIJob) SetData(v string) *ListAIJobResponseBodyAIJobListAIJob {
	s.Data = &v
	return s
}

func (s *ListAIJobResponseBodyAIJobListAIJob) SetJobId(v string) *ListAIJobResponseBodyAIJobListAIJob {
	s.JobId = &v
	return s
}

func (s *ListAIJobResponseBodyAIJobListAIJob) SetMediaId(v string) *ListAIJobResponseBodyAIJobListAIJob {
	s.MediaId = &v
	return s
}

func (s *ListAIJobResponseBodyAIJobListAIJob) SetMessage(v string) *ListAIJobResponseBodyAIJobListAIJob {
	s.Message = &v
	return s
}

func (s *ListAIJobResponseBodyAIJobListAIJob) SetStatus(v string) *ListAIJobResponseBodyAIJobListAIJob {
	s.Status = &v
	return s
}

func (s *ListAIJobResponseBodyAIJobListAIJob) SetType(v string) *ListAIJobResponseBodyAIJobListAIJob {
	s.Type = &v
	return s
}

type ListAIJobResponseBodyNonExistAIJobIds struct {
	String_ []*string `json:"String,omitempty" xml:"String,omitempty" type:"Repeated"`
}

func (s ListAIJobResponseBodyNonExistAIJobIds) String() string {
	return tea.Prettify(s)
}

func (s ListAIJobResponseBodyNonExistAIJobIds) GoString() string {
	return s.String()
}

func (s *ListAIJobResponseBodyNonExistAIJobIds) SetString_(v []*string) *ListAIJobResponseBodyNonExistAIJobIds {
	s.String_ = v
	return s
}

type ListAIJobResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAIJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAIJobResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAIJobResponse) GoString() string {
	return s.String()
}

func (s *ListAIJobResponse) SetHeaders(v map[string]*string) *ListAIJobResponse {
	s.Headers = v
	return s
}

func (s *ListAIJobResponse) SetStatusCode(v int32) *ListAIJobResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAIJobResponse) SetBody(v *ListAIJobResponseBody) *ListAIJobResponse {
	s.Body = v
	return s
}

type ListAITemplateRequest struct {
	// Indicates whether the template is the default AI template. Valid values:
	//
	// *   **Default**
	// *   **NotDefault**
	TemplateType *string `json:"TemplateType,omitempty" xml:"TemplateType,omitempty"`
}

func (s ListAITemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAITemplateRequest) GoString() string {
	return s.String()
}

func (s *ListAITemplateRequest) SetTemplateType(v string) *ListAITemplateRequest {
	s.TemplateType = &v
	return s
}

type ListAITemplateResponseBody struct {
	// The source of the AI template. Valid values:
	//
	// *   **System**
	// *   **Custom**
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The name of the AI template.
	TemplateInfoList []*ListAITemplateResponseBodyTemplateInfoList `json:"TemplateInfoList,omitempty" xml:"TemplateInfoList,omitempty" type:"Repeated"`
}

func (s ListAITemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAITemplateResponseBody) GoString() string {
	return s.String()
}

func (s *ListAITemplateResponseBody) SetRequestId(v string) *ListAITemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListAITemplateResponseBody) SetTemplateInfoList(v []*ListAITemplateResponseBodyTemplateInfoList) *ListAITemplateResponseBody {
	s.TemplateInfoList = v
	return s
}

type ListAITemplateResponseBodyTemplateInfoList struct {
	// The type of the AI template. Valid values:
	//
	// *   **AIMediaAudit**: automated review
	// *   **AIImage**: smart thumbnail
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// Details of the AI template.
	IsDefault  *string `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	ModifyTime *string `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	// Queries AI templates.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The ID of the request.
	TemplateConfig *string `json:"TemplateConfig,omitempty" xml:"TemplateConfig,omitempty"`
	TemplateId     *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The time when the AI template was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	TemplateName *string `json:"TemplateName,omitempty" xml:"TemplateName,omitempty"`
	// The detailed configurations of the AI template. The value is a JSON string. For more information, see [AITemplateConfig](~~89863~~#title-vd3-499-o36).
	TemplateType *string `json:"TemplateType,omitempty" xml:"TemplateType,omitempty"`
}

func (s ListAITemplateResponseBodyTemplateInfoList) String() string {
	return tea.Prettify(s)
}

func (s ListAITemplateResponseBodyTemplateInfoList) GoString() string {
	return s.String()
}

func (s *ListAITemplateResponseBodyTemplateInfoList) SetCreationTime(v string) *ListAITemplateResponseBodyTemplateInfoList {
	s.CreationTime = &v
	return s
}

func (s *ListAITemplateResponseBodyTemplateInfoList) SetIsDefault(v string) *ListAITemplateResponseBodyTemplateInfoList {
	s.IsDefault = &v
	return s
}

func (s *ListAITemplateResponseBodyTemplateInfoList) SetModifyTime(v string) *ListAITemplateResponseBodyTemplateInfoList {
	s.ModifyTime = &v
	return s
}

func (s *ListAITemplateResponseBodyTemplateInfoList) SetSource(v string) *ListAITemplateResponseBodyTemplateInfoList {
	s.Source = &v
	return s
}

func (s *ListAITemplateResponseBodyTemplateInfoList) SetTemplateConfig(v string) *ListAITemplateResponseBodyTemplateInfoList {
	s.TemplateConfig = &v
	return s
}

func (s *ListAITemplateResponseBodyTemplateInfoList) SetTemplateId(v string) *ListAITemplateResponseBodyTemplateInfoList {
	s.TemplateId = &v
	return s
}

func (s *ListAITemplateResponseBodyTemplateInfoList) SetTemplateName(v string) *ListAITemplateResponseBodyTemplateInfoList {
	s.TemplateName = &v
	return s
}

func (s *ListAITemplateResponseBodyTemplateInfoList) SetTemplateType(v string) *ListAITemplateResponseBodyTemplateInfoList {
	s.TemplateType = &v
	return s
}

type ListAITemplateResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAITemplateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAITemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAITemplateResponse) GoString() string {
	return s.String()
}

func (s *ListAITemplateResponse) SetHeaders(v map[string]*string) *ListAITemplateResponse {
	s.Headers = v
	return s
}

func (s *ListAITemplateResponse) SetStatusCode(v int32) *ListAITemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAITemplateResponse) SetBody(v *ListAITemplateResponseBody) *ListAITemplateResponse {
	s.Body = v
	return s
}

type ListAppInfoRequest struct {
	// The operation that you want to perform. Set the value to **ListAppInfo**.
	PageNo *int32 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The type of the application. Valid values:
	//
	// *   **System**
	// *   **Custom**
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The details of each application.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListAppInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAppInfoRequest) GoString() string {
	return s.String()
}

func (s *ListAppInfoRequest) SetPageNo(v int32) *ListAppInfoRequest {
	s.PageNo = &v
	return s
}

func (s *ListAppInfoRequest) SetPageSize(v int32) *ListAppInfoRequest {
	s.PageSize = &v
	return s
}

func (s *ListAppInfoRequest) SetStatus(v string) *ListAppInfoRequest {
	s.Status = &v
	return s
}

type ListAppInfoResponseBody struct {
	// The status of the application. After an application is created, it enters the **Normal** state. Valid values:
	//
	// *   **Normal**
	// *   **Disable**
	AppInfoList []*ListAppInfoResponseBodyAppInfoList `json:"AppInfoList,omitempty" xml:"AppInfoList,omitempty" type:"Repeated"`
	// The last time when the application was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The status of the application. Valid values:
	//
	// *   **Normal**
	// *   **Disable**
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListAppInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAppInfoResponseBody) GoString() string {
	return s.String()
}

func (s *ListAppInfoResponseBody) SetAppInfoList(v []*ListAppInfoResponseBodyAppInfoList) *ListAppInfoResponseBody {
	s.AppInfoList = v
	return s
}

func (s *ListAppInfoResponseBody) SetRequestId(v string) *ListAppInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListAppInfoResponseBody) SetTotal(v int32) *ListAppInfoResponseBody {
	s.Total = &v
	return s
}

type ListAppInfoResponseBodyAppInfoList struct {
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// Queries the applications that you are authorized to manage based on query conditions.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The ID of the request.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// WB01210940
	Description      *string `json:"Description,omitempty" xml:"Description,omitempty"`
	ModificationTime *string `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	// The time when the application was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the application.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListAppInfoResponseBodyAppInfoList) String() string {
	return tea.Prettify(s)
}

func (s ListAppInfoResponseBodyAppInfoList) GoString() string {
	return s.String()
}

func (s *ListAppInfoResponseBodyAppInfoList) SetAppId(v string) *ListAppInfoResponseBodyAppInfoList {
	s.AppId = &v
	return s
}

func (s *ListAppInfoResponseBodyAppInfoList) SetAppName(v string) *ListAppInfoResponseBodyAppInfoList {
	s.AppName = &v
	return s
}

func (s *ListAppInfoResponseBodyAppInfoList) SetCreationTime(v string) *ListAppInfoResponseBodyAppInfoList {
	s.CreationTime = &v
	return s
}

func (s *ListAppInfoResponseBodyAppInfoList) SetDescription(v string) *ListAppInfoResponseBodyAppInfoList {
	s.Description = &v
	return s
}

func (s *ListAppInfoResponseBodyAppInfoList) SetModificationTime(v string) *ListAppInfoResponseBodyAppInfoList {
	s.ModificationTime = &v
	return s
}

func (s *ListAppInfoResponseBodyAppInfoList) SetStatus(v string) *ListAppInfoResponseBodyAppInfoList {
	s.Status = &v
	return s
}

func (s *ListAppInfoResponseBodyAppInfoList) SetType(v string) *ListAppInfoResponseBodyAppInfoList {
	s.Type = &v
	return s
}

type ListAppInfoResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAppInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAppInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAppInfoResponse) GoString() string {
	return s.String()
}

func (s *ListAppInfoResponse) SetHeaders(v map[string]*string) *ListAppInfoResponse {
	s.Headers = v
	return s
}

func (s *ListAppInfoResponse) SetStatusCode(v int32) *ListAppInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAppInfoResponse) SetBody(v *ListAppInfoResponseBody) *ListAppInfoResponse {
	s.Body = v
	return s
}

type ListAppPoliciesForIdentityRequest struct {
	// The ID of the application.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The type of the identity. Valid values:
	//
	// *   **RamUser**: a RAM user.
	// *   **RamRole**: a RAM role.
	IdentityName *string `json:"IdentityName,omitempty" xml:"IdentityName,omitempty"`
	// The type of the policy. Valid values:
	//
	// *   **System**
	// *   **Custom**
	IdentityType *string `json:"IdentityType,omitempty" xml:"IdentityType,omitempty"`
}

func (s ListAppPoliciesForIdentityRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAppPoliciesForIdentityRequest) GoString() string {
	return s.String()
}

func (s *ListAppPoliciesForIdentityRequest) SetAppId(v string) *ListAppPoliciesForIdentityRequest {
	s.AppId = &v
	return s
}

func (s *ListAppPoliciesForIdentityRequest) SetIdentityName(v string) *ListAppPoliciesForIdentityRequest {
	s.IdentityName = &v
	return s
}

func (s *ListAppPoliciesForIdentityRequest) SetIdentityType(v string) *ListAppPoliciesForIdentityRequest {
	s.IdentityType = &v
	return s
}

type ListAppPoliciesForIdentityResponseBody struct {
	// The description of the policy.
	AppPolicyList []*ListAppPoliciesForIdentityResponseBodyAppPolicyList `json:"AppPolicyList,omitempty" xml:"AppPolicyList,omitempty" type:"Repeated"`
	// The time when the application policy was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListAppPoliciesForIdentityResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAppPoliciesForIdentityResponseBody) GoString() string {
	return s.String()
}

func (s *ListAppPoliciesForIdentityResponseBody) SetAppPolicyList(v []*ListAppPoliciesForIdentityResponseBodyAppPolicyList) *ListAppPoliciesForIdentityResponseBody {
	s.AppPolicyList = v
	return s
}

func (s *ListAppPoliciesForIdentityResponseBody) SetRequestId(v string) *ListAppPoliciesForIdentityResponseBody {
	s.RequestId = &v
	return s
}

type ListAppPoliciesForIdentityResponseBodyAppPolicyList struct {
	// The ID of the request.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The last time when the application policy was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The content of the policy.
	Description      *string `json:"Description,omitempty" xml:"Description,omitempty"`
	ModificationTime *string `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	// Queries the application policies that are attached to the specified identity. The identity may be a RAM user or RAM role.
	PolicyName *string `json:"PolicyName,omitempty" xml:"PolicyName,omitempty"`
	PolicyType *string `json:"PolicyType,omitempty" xml:"PolicyType,omitempty"`
	// The details of each policy.
	//
	// **
	//
	// **Note** A maximum of 100 entries can be returned.
	PolicyValue *string `json:"PolicyValue,omitempty" xml:"PolicyValue,omitempty"`
}

func (s ListAppPoliciesForIdentityResponseBodyAppPolicyList) String() string {
	return tea.Prettify(s)
}

func (s ListAppPoliciesForIdentityResponseBodyAppPolicyList) GoString() string {
	return s.String()
}

func (s *ListAppPoliciesForIdentityResponseBodyAppPolicyList) SetAppId(v string) *ListAppPoliciesForIdentityResponseBodyAppPolicyList {
	s.AppId = &v
	return s
}

func (s *ListAppPoliciesForIdentityResponseBodyAppPolicyList) SetCreationTime(v string) *ListAppPoliciesForIdentityResponseBodyAppPolicyList {
	s.CreationTime = &v
	return s
}

func (s *ListAppPoliciesForIdentityResponseBodyAppPolicyList) SetDescription(v string) *ListAppPoliciesForIdentityResponseBodyAppPolicyList {
	s.Description = &v
	return s
}

func (s *ListAppPoliciesForIdentityResponseBodyAppPolicyList) SetModificationTime(v string) *ListAppPoliciesForIdentityResponseBodyAppPolicyList {
	s.ModificationTime = &v
	return s
}

func (s *ListAppPoliciesForIdentityResponseBodyAppPolicyList) SetPolicyName(v string) *ListAppPoliciesForIdentityResponseBodyAppPolicyList {
	s.PolicyName = &v
	return s
}

func (s *ListAppPoliciesForIdentityResponseBodyAppPolicyList) SetPolicyType(v string) *ListAppPoliciesForIdentityResponseBodyAppPolicyList {
	s.PolicyType = &v
	return s
}

func (s *ListAppPoliciesForIdentityResponseBodyAppPolicyList) SetPolicyValue(v string) *ListAppPoliciesForIdentityResponseBodyAppPolicyList {
	s.PolicyValue = &v
	return s
}

type ListAppPoliciesForIdentityResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAppPoliciesForIdentityResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAppPoliciesForIdentityResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAppPoliciesForIdentityResponse) GoString() string {
	return s.String()
}

func (s *ListAppPoliciesForIdentityResponse) SetHeaders(v map[string]*string) *ListAppPoliciesForIdentityResponse {
	s.Headers = v
	return s
}

func (s *ListAppPoliciesForIdentityResponse) SetStatusCode(v int32) *ListAppPoliciesForIdentityResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAppPoliciesForIdentityResponse) SetBody(v *ListAppPoliciesForIdentityResponseBody) *ListAppPoliciesForIdentityResponse {
	s.Body = v
	return s
}

type ListAuditSecurityIpRequest struct {
	// The time when the review security group was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	SecurityGroupName *string `json:"SecurityGroupName,omitempty" xml:"SecurityGroupName,omitempty"`
}

func (s ListAuditSecurityIpRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAuditSecurityIpRequest) GoString() string {
	return s.String()
}

func (s *ListAuditSecurityIpRequest) SetSecurityGroupName(v string) *ListAuditSecurityIpRequest {
	s.SecurityGroupName = &v
	return s
}

type ListAuditSecurityIpResponseBody struct {
	// The name of the review security group.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the request.
	SecurityIpList []*ListAuditSecurityIpResponseBodySecurityIpList `json:"SecurityIpList,omitempty" xml:"SecurityIpList,omitempty" type:"Repeated"`
}

func (s ListAuditSecurityIpResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAuditSecurityIpResponseBody) GoString() string {
	return s.String()
}

func (s *ListAuditSecurityIpResponseBody) SetRequestId(v string) *ListAuditSecurityIpResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListAuditSecurityIpResponseBody) SetSecurityIpList(v []*ListAuditSecurityIpResponseBodySecurityIpList) *ListAuditSecurityIpResponseBody {
	s.SecurityIpList = v
	return s
}

type ListAuditSecurityIpResponseBodySecurityIpList struct {
	// The operation that you want to perform. Set the value to **ListAuditSecurityIp**.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// Queries the IP addresses in a review security group.
	Ips               *string `json:"Ips,omitempty" xml:"Ips,omitempty"`
	ModificationTime  *string `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	SecurityGroupName *string `json:"SecurityGroupName,omitempty" xml:"SecurityGroupName,omitempty"`
}

func (s ListAuditSecurityIpResponseBodySecurityIpList) String() string {
	return tea.Prettify(s)
}

func (s ListAuditSecurityIpResponseBodySecurityIpList) GoString() string {
	return s.String()
}

func (s *ListAuditSecurityIpResponseBodySecurityIpList) SetCreationTime(v string) *ListAuditSecurityIpResponseBodySecurityIpList {
	s.CreationTime = &v
	return s
}

func (s *ListAuditSecurityIpResponseBodySecurityIpList) SetIps(v string) *ListAuditSecurityIpResponseBodySecurityIpList {
	s.Ips = &v
	return s
}

func (s *ListAuditSecurityIpResponseBodySecurityIpList) SetModificationTime(v string) *ListAuditSecurityIpResponseBodySecurityIpList {
	s.ModificationTime = &v
	return s
}

func (s *ListAuditSecurityIpResponseBodySecurityIpList) SetSecurityGroupName(v string) *ListAuditSecurityIpResponseBodySecurityIpList {
	s.SecurityGroupName = &v
	return s
}

type ListAuditSecurityIpResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAuditSecurityIpResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAuditSecurityIpResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAuditSecurityIpResponse) GoString() string {
	return s.String()
}

func (s *ListAuditSecurityIpResponse) SetHeaders(v map[string]*string) *ListAuditSecurityIpResponse {
	s.Headers = v
	return s
}

func (s *ListAuditSecurityIpResponse) SetStatusCode(v int32) *ListAuditSecurityIpResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAuditSecurityIpResponse) SetBody(v *ListAuditSecurityIpResponseBody) *ListAuditSecurityIpResponse {
	s.Body = v
	return s
}

type ListDynamicImageRequest struct {
	// The size of the animated sticker file. Unit: byte.
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s ListDynamicImageRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDynamicImageRequest) GoString() string {
	return s.String()
}

func (s *ListDynamicImageRequest) SetVideoId(v string) *ListDynamicImageRequest {
	s.VideoId = &v
	return s
}

type ListDynamicImageResponseBody struct {
	// The format of the animated sticker. Valid values: gif and webp.
	DynamicImageList []*ListDynamicImageResponseBodyDynamicImageList `json:"DynamicImageList,omitempty" xml:"DynamicImageList,omitempty" type:"Repeated"`
	// The operation that you want to perform. Set the value to **ListDynamicImage**.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListDynamicImageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDynamicImageResponseBody) GoString() string {
	return s.String()
}

func (s *ListDynamicImageResponseBody) SetDynamicImageList(v []*ListDynamicImageResponseBodyDynamicImageList) *ListDynamicImageResponseBody {
	s.DynamicImageList = v
	return s
}

func (s *ListDynamicImageResponseBody) SetRequestId(v string) *ListDynamicImageResponseBody {
	s.RequestId = &v
	return s
}

type ListDynamicImageResponseBodyDynamicImageList struct {
	// The job ID for creating the animated sticker.
	CreationTime   *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	Duration       *string `json:"Duration,omitempty" xml:"Duration,omitempty"`
	DynamicImageId *string `json:"DynamicImageId,omitempty" xml:"DynamicImageId,omitempty"`
	FileSize       *string `json:"FileSize,omitempty" xml:"FileSize,omitempty"`
	// The time when the animated sticker was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	FileURL *string `json:"FileURL,omitempty" xml:"FileURL,omitempty"`
	Format  *string `json:"Format,omitempty" xml:"Format,omitempty"`
	// Queries the information about animated stickers of a video based on the video ID.
	Fps *string `json:"Fps,omitempty" xml:"Fps,omitempty"`
	// The frame rate of the animated sticker. Unit: frames per second.
	Height *string `json:"Height,omitempty" xml:"Height,omitempty"`
	// The ID of the request.
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The duration of the animated sticker. Unit: seconds.
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
	// The list of animated stickers.
	Width *string `json:"Width,omitempty" xml:"Width,omitempty"`
}

func (s ListDynamicImageResponseBodyDynamicImageList) String() string {
	return tea.Prettify(s)
}

func (s ListDynamicImageResponseBodyDynamicImageList) GoString() string {
	return s.String()
}

func (s *ListDynamicImageResponseBodyDynamicImageList) SetCreationTime(v string) *ListDynamicImageResponseBodyDynamicImageList {
	s.CreationTime = &v
	return s
}

func (s *ListDynamicImageResponseBodyDynamicImageList) SetDuration(v string) *ListDynamicImageResponseBodyDynamicImageList {
	s.Duration = &v
	return s
}

func (s *ListDynamicImageResponseBodyDynamicImageList) SetDynamicImageId(v string) *ListDynamicImageResponseBodyDynamicImageList {
	s.DynamicImageId = &v
	return s
}

func (s *ListDynamicImageResponseBodyDynamicImageList) SetFileSize(v string) *ListDynamicImageResponseBodyDynamicImageList {
	s.FileSize = &v
	return s
}

func (s *ListDynamicImageResponseBodyDynamicImageList) SetFileURL(v string) *ListDynamicImageResponseBodyDynamicImageList {
	s.FileURL = &v
	return s
}

func (s *ListDynamicImageResponseBodyDynamicImageList) SetFormat(v string) *ListDynamicImageResponseBodyDynamicImageList {
	s.Format = &v
	return s
}

func (s *ListDynamicImageResponseBodyDynamicImageList) SetFps(v string) *ListDynamicImageResponseBodyDynamicImageList {
	s.Fps = &v
	return s
}

func (s *ListDynamicImageResponseBodyDynamicImageList) SetHeight(v string) *ListDynamicImageResponseBodyDynamicImageList {
	s.Height = &v
	return s
}

func (s *ListDynamicImageResponseBodyDynamicImageList) SetJobId(v string) *ListDynamicImageResponseBodyDynamicImageList {
	s.JobId = &v
	return s
}

func (s *ListDynamicImageResponseBodyDynamicImageList) SetVideoId(v string) *ListDynamicImageResponseBodyDynamicImageList {
	s.VideoId = &v
	return s
}

func (s *ListDynamicImageResponseBodyDynamicImageList) SetWidth(v string) *ListDynamicImageResponseBodyDynamicImageList {
	s.Width = &v
	return s
}

type ListDynamicImageResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListDynamicImageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDynamicImageResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDynamicImageResponse) GoString() string {
	return s.String()
}

func (s *ListDynamicImageResponse) SetHeaders(v map[string]*string) *ListDynamicImageResponse {
	s.Headers = v
	return s
}

func (s *ListDynamicImageResponse) SetStatusCode(v int32) *ListDynamicImageResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDynamicImageResponse) SetBody(v *ListDynamicImageResponseBody) *ListDynamicImageResponse {
	s.Body = v
	return s
}

type ListLiveRecordVideoRequest struct {
	// The sorting rule of results. Valid values:
	//
	// *   **CreationTime:Desc**: sorts the results based on the creation time in descending order. This is the default value.
	// *   **CreationTime:Asc**: sorts the results based on the creation time in ascending order.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The operation that you want to perform. Set the value to **ListLiveRecordVideo**.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// CreationTime:Desc
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The name of the recorded live stream.
	PageNo *int32 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The ID of the transcoding template group.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The duration of the video. Unit: seconds.
	SortBy *string `json:"SortBy,omitempty" xml:"SortBy,omitempty"`
	// The name of the video category.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The status of the video. Valid values:
	//
	// *   **Uploading:**: indicates that the video is being uploaded.
	// *   **UploadFail**: indicates that the video failed to be uploaded.
	// *   **UploadSucces**: indicates that the video was uploaded.
	// *   **Transcoding**: indicates that the video is being transcoded.
	// *   **TranscodeFail**: indicates that the video failed to be transcoded.
	// *   **Blocked**: indicates that the video is blocked.
	// *   **Normal**: indicates that the video is in a normal state.
	StreamName *string `json:"StreamName,omitempty" xml:"StreamName,omitempty"`
}

func (s ListLiveRecordVideoRequest) String() string {
	return tea.Prettify(s)
}

func (s ListLiveRecordVideoRequest) GoString() string {
	return s.String()
}

func (s *ListLiveRecordVideoRequest) SetAppName(v string) *ListLiveRecordVideoRequest {
	s.AppName = &v
	return s
}

func (s *ListLiveRecordVideoRequest) SetDomainName(v string) *ListLiveRecordVideoRequest {
	s.DomainName = &v
	return s
}

func (s *ListLiveRecordVideoRequest) SetEndTime(v string) *ListLiveRecordVideoRequest {
	s.EndTime = &v
	return s
}

func (s *ListLiveRecordVideoRequest) SetPageNo(v int32) *ListLiveRecordVideoRequest {
	s.PageNo = &v
	return s
}

func (s *ListLiveRecordVideoRequest) SetPageSize(v int32) *ListLiveRecordVideoRequest {
	s.PageSize = &v
	return s
}

func (s *ListLiveRecordVideoRequest) SetSortBy(v string) *ListLiveRecordVideoRequest {
	s.SortBy = &v
	return s
}

func (s *ListLiveRecordVideoRequest) SetStartTime(v string) *ListLiveRecordVideoRequest {
	s.StartTime = &v
	return s
}

func (s *ListLiveRecordVideoRequest) SetStreamName(v string) *ListLiveRecordVideoRequest {
	s.StreamName = &v
	return s
}

type ListLiveRecordVideoResponseBody struct {
	// The total number of videos returned.
	LiveRecordVideoList *ListLiveRecordVideoResponseBodyLiveRecordVideoList `json:"LiveRecordVideoList,omitempty" xml:"LiveRecordVideoList,omitempty" type:"Struct"`
	// The description of the video.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The title of the video.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListLiveRecordVideoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListLiveRecordVideoResponseBody) GoString() string {
	return s.String()
}

func (s *ListLiveRecordVideoResponseBody) SetLiveRecordVideoList(v *ListLiveRecordVideoResponseBodyLiveRecordVideoList) *ListLiveRecordVideoResponseBody {
	s.LiveRecordVideoList = v
	return s
}

func (s *ListLiveRecordVideoResponseBody) SetRequestId(v string) *ListLiveRecordVideoResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListLiveRecordVideoResponseBody) SetTotal(v int32) *ListLiveRecordVideoResponseBody {
	s.Total = &v
	return s
}

type ListLiveRecordVideoResponseBodyLiveRecordVideoList struct {
	LiveRecordVideo []*ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo `json:"LiveRecordVideo,omitempty" xml:"LiveRecordVideo,omitempty" type:"Repeated"`
}

func (s ListLiveRecordVideoResponseBodyLiveRecordVideoList) String() string {
	return tea.Prettify(s)
}

func (s ListLiveRecordVideoResponseBodyLiveRecordVideoList) GoString() string {
	return s.String()
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoList) SetLiveRecordVideo(v []*ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo) *ListLiveRecordVideoResponseBodyLiveRecordVideoList {
	s.LiveRecordVideo = v
	return s
}

type ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo struct {
	// The information about the video.
	AppName *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	// The tags of the video. Separate multiple tags with commas (,).
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	// The last time when the video was updated. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	PlaylistId *string `json:"PlaylistId,omitempty" xml:"PlaylistId,omitempty"`
	// The domain name of the recorded live stream.
	RecordEndTime *string `json:"RecordEndTime,omitempty" xml:"RecordEndTime,omitempty"`
	// The array of video snapshot URLs.
	RecordStartTime *string `json:"RecordStartTime,omitempty" xml:"RecordStartTime,omitempty"`
	// The end of the time range to query. The query is performed based on the time range during which the required live streams were recorded. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	StreamName *string `json:"StreamName,omitempty" xml:"StreamName,omitempty"`
	// The name of the application that was used to record the live stream.
	Video *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo `json:"Video,omitempty" xml:"Video,omitempty" type:"Struct"`
}

func (s ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo) String() string {
	return tea.Prettify(s)
}

func (s ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo) GoString() string {
	return s.String()
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo) SetAppName(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo {
	s.AppName = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo) SetDomainName(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo {
	s.DomainName = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo) SetPlaylistId(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo {
	s.PlaylistId = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo) SetRecordEndTime(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo {
	s.RecordEndTime = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo) SetRecordStartTime(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo {
	s.RecordStartTime = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo) SetStreamName(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo {
	s.StreamName = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo) SetVideo(v *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideo {
	s.Video = v
	return s
}

type ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo struct {
	// The time when the video was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	CateId *int32 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The name of the application.
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	CoverURL *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	// The beginning of the time range to query. The query is performed based on the time range during which the required live streams were recorded. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The name of the live stream.
	Description *string  `json:"Description,omitempty" xml:"Description,omitempty"`
	Duration    *float32 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	ModifyTime  *string  `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	// Queries live-to-VOD videos.
	Size      *int64                                                                           `json:"Size,omitempty" xml:"Size,omitempty"`
	Snapshots *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideoSnapshots `json:"Snapshots,omitempty" xml:"Snapshots,omitempty" type:"Struct"`
	// The ID of the playlist.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// 2017-01-11T13:00:00Z
	Tags            *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	TemplateGroupId *string `json:"TemplateGroupId,omitempty" xml:"TemplateGroupId,omitempty"`
	Title           *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// 10
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) String() string {
	return tea.Prettify(s)
}

func (s ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) GoString() string {
	return s.String()
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) SetCateId(v int32) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo {
	s.CateId = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) SetCateName(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo {
	s.CateName = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) SetCoverURL(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo {
	s.CoverURL = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) SetCreationTime(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo {
	s.CreationTime = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) SetDescription(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo {
	s.Description = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) SetDuration(v float32) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo {
	s.Duration = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) SetModifyTime(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo {
	s.ModifyTime = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) SetSize(v int64) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo {
	s.Size = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) SetSnapshots(v *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideoSnapshots) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo {
	s.Snapshots = v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) SetStatus(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo {
	s.Status = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) SetTags(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo {
	s.Tags = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) SetTemplateGroupId(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo {
	s.TemplateGroupId = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) SetTitle(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo {
	s.Title = &v
	return s
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo) SetVideoId(v string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideo {
	s.VideoId = &v
	return s
}

type ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideoSnapshots struct {
	Snapshot []*string `json:"Snapshot,omitempty" xml:"Snapshot,omitempty" type:"Repeated"`
}

func (s ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideoSnapshots) String() string {
	return tea.Prettify(s)
}

func (s ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideoSnapshots) GoString() string {
	return s.String()
}

func (s *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideoSnapshots) SetSnapshot(v []*string) *ListLiveRecordVideoResponseBodyLiveRecordVideoListLiveRecordVideoVideoSnapshots {
	s.Snapshot = v
	return s
}

type ListLiveRecordVideoResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListLiveRecordVideoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListLiveRecordVideoResponse) String() string {
	return tea.Prettify(s)
}

func (s ListLiveRecordVideoResponse) GoString() string {
	return s.String()
}

func (s *ListLiveRecordVideoResponse) SetHeaders(v map[string]*string) *ListLiveRecordVideoResponse {
	s.Headers = v
	return s
}

func (s *ListLiveRecordVideoResponse) SetStatusCode(v int32) *ListLiveRecordVideoResponse {
	s.StatusCode = &v
	return s
}

func (s *ListLiveRecordVideoResponse) SetBody(v *ListLiveRecordVideoResponseBody) *ListLiveRecordVideoResponse {
	s.Body = v
	return s
}

type ListSnapshotsRequest struct {
	// The index of the snapshot.
	AuthTimeout *string `json:"AuthTimeout,omitempty" xml:"AuthTimeout,omitempty"`
	// The number of entries to return on each page. Default value: **20**. Maximum value: **100**.
	PageNo *string `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The ID of the video.
	PageSize *string `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The number of the page to turn. Default value: **1**.
	SnapshotType *string `json:"SnapshotType,omitempty" xml:"SnapshotType,omitempty"`
	// The operation that you want to perform. Set the value to **ListSnapshots**.
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s ListSnapshotsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListSnapshotsRequest) GoString() string {
	return s.String()
}

func (s *ListSnapshotsRequest) SetAuthTimeout(v string) *ListSnapshotsRequest {
	s.AuthTimeout = &v
	return s
}

func (s *ListSnapshotsRequest) SetPageNo(v string) *ListSnapshotsRequest {
	s.PageNo = &v
	return s
}

func (s *ListSnapshotsRequest) SetPageSize(v string) *ListSnapshotsRequest {
	s.PageSize = &v
	return s
}

func (s *ListSnapshotsRequest) SetSnapshotType(v string) *ListSnapshotsRequest {
	s.SnapshotType = &v
	return s
}

func (s *ListSnapshotsRequest) SetVideoId(v string) *ListSnapshotsRequest {
	s.VideoId = &v
	return s
}

type ListSnapshotsResponseBody struct {
	// The URL of the snapshot.
	MediaSnapshot *ListSnapshotsResponseBodyMediaSnapshot `json:"MediaSnapshot,omitempty" xml:"MediaSnapshot,omitempty" type:"Struct"`
	// The snapshot data of the media.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListSnapshotsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListSnapshotsResponseBody) GoString() string {
	return s.String()
}

func (s *ListSnapshotsResponseBody) SetMediaSnapshot(v *ListSnapshotsResponseBodyMediaSnapshot) *ListSnapshotsResponseBody {
	s.MediaSnapshot = v
	return s
}

func (s *ListSnapshotsResponseBody) SetRequestId(v string) *ListSnapshotsResponseBody {
	s.RequestId = &v
	return s
}

type ListSnapshotsResponseBodyMediaSnapshot struct {
	// The ID of the snapshot job.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// Queries the snapshots that are captured from the specified media.
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The ID of the request.
	Regular   *string                                          `json:"Regular,omitempty" xml:"Regular,omitempty"`
	Snapshots *ListSnapshotsResponseBodyMediaSnapshotSnapshots `json:"Snapshots,omitempty" xml:"Snapshots,omitempty" type:"Struct"`
	// The total number of snapshots.
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListSnapshotsResponseBodyMediaSnapshot) String() string {
	return tea.Prettify(s)
}

func (s ListSnapshotsResponseBodyMediaSnapshot) GoString() string {
	return s.String()
}

func (s *ListSnapshotsResponseBodyMediaSnapshot) SetCreationTime(v string) *ListSnapshotsResponseBodyMediaSnapshot {
	s.CreationTime = &v
	return s
}

func (s *ListSnapshotsResponseBodyMediaSnapshot) SetJobId(v string) *ListSnapshotsResponseBodyMediaSnapshot {
	s.JobId = &v
	return s
}

func (s *ListSnapshotsResponseBodyMediaSnapshot) SetRegular(v string) *ListSnapshotsResponseBodyMediaSnapshot {
	s.Regular = &v
	return s
}

func (s *ListSnapshotsResponseBodyMediaSnapshot) SetSnapshots(v *ListSnapshotsResponseBodyMediaSnapshotSnapshots) *ListSnapshotsResponseBodyMediaSnapshot {
	s.Snapshots = v
	return s
}

func (s *ListSnapshotsResponseBodyMediaSnapshot) SetTotal(v int64) *ListSnapshotsResponseBodyMediaSnapshot {
	s.Total = &v
	return s
}

type ListSnapshotsResponseBodyMediaSnapshotSnapshots struct {
	Snapshot []*ListSnapshotsResponseBodyMediaSnapshotSnapshotsSnapshot `json:"Snapshot,omitempty" xml:"Snapshot,omitempty" type:"Repeated"`
}

func (s ListSnapshotsResponseBodyMediaSnapshotSnapshots) String() string {
	return tea.Prettify(s)
}

func (s ListSnapshotsResponseBodyMediaSnapshotSnapshots) GoString() string {
	return s.String()
}

func (s *ListSnapshotsResponseBodyMediaSnapshotSnapshots) SetSnapshot(v []*ListSnapshotsResponseBodyMediaSnapshotSnapshotsSnapshot) *ListSnapshotsResponseBodyMediaSnapshotSnapshots {
	s.Snapshot = v
	return s
}

type ListSnapshotsResponseBodyMediaSnapshotSnapshotsSnapshot struct {
	Index *int64  `json:"Index,omitempty" xml:"Index,omitempty"`
	Url   *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s ListSnapshotsResponseBodyMediaSnapshotSnapshotsSnapshot) String() string {
	return tea.Prettify(s)
}

func (s ListSnapshotsResponseBodyMediaSnapshotSnapshotsSnapshot) GoString() string {
	return s.String()
}

func (s *ListSnapshotsResponseBodyMediaSnapshotSnapshotsSnapshot) SetIndex(v int64) *ListSnapshotsResponseBodyMediaSnapshotSnapshotsSnapshot {
	s.Index = &v
	return s
}

func (s *ListSnapshotsResponseBodyMediaSnapshotSnapshotsSnapshot) SetUrl(v string) *ListSnapshotsResponseBodyMediaSnapshotSnapshotsSnapshot {
	s.Url = &v
	return s
}

type ListSnapshotsResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListSnapshotsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListSnapshotsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListSnapshotsResponse) GoString() string {
	return s.String()
}

func (s *ListSnapshotsResponse) SetHeaders(v map[string]*string) *ListSnapshotsResponse {
	s.Headers = v
	return s
}

func (s *ListSnapshotsResponse) SetStatusCode(v int32) *ListSnapshotsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListSnapshotsResponse) SetBody(v *ListSnapshotsResponseBody) *ListSnapshotsResponse {
	s.Body = v
	return s
}

type ListTranscodeTaskRequest struct {
	// The time when the transcoding task was complete. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The number of the page to return. You can specify a page number to return data from the specified page. Default value: **1**.
	PageNo *int32 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The operation that you want to perform. Set the value to **ListTranscodeTask**
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the audio or video file.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s ListTranscodeTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTranscodeTaskRequest) GoString() string {
	return s.String()
}

func (s *ListTranscodeTaskRequest) SetEndTime(v string) *ListTranscodeTaskRequest {
	s.EndTime = &v
	return s
}

func (s *ListTranscodeTaskRequest) SetPageNo(v int32) *ListTranscodeTaskRequest {
	s.PageNo = &v
	return s
}

func (s *ListTranscodeTaskRequest) SetPageSize(v int32) *ListTranscodeTaskRequest {
	s.PageSize = &v
	return s
}

func (s *ListTranscodeTaskRequest) SetStartTime(v string) *ListTranscodeTaskRequest {
	s.StartTime = &v
	return s
}

func (s *ListTranscodeTaskRequest) SetVideoId(v string) *ListTranscodeTaskRequest {
	s.VideoId = &v
	return s
}

type ListTranscodeTaskResponseBody struct {
	// The ID of the transcoding template group.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the transcoding task.
	TranscodeTaskList []*ListTranscodeTaskResponseBodyTranscodeTaskList `json:"TranscodeTaskList,omitempty" xml:"TranscodeTaskList,omitempty" type:"Repeated"`
}

func (s ListTranscodeTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTranscodeTaskResponseBody) GoString() string {
	return s.String()
}

func (s *ListTranscodeTaskResponseBody) SetRequestId(v string) *ListTranscodeTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTranscodeTaskResponseBody) SetTranscodeTaskList(v []*ListTranscodeTaskResponseBodyTranscodeTaskList) *ListTranscodeTaskResponseBody {
	s.TranscodeTaskList = v
	return s
}

type ListTranscodeTaskResponseBodyTranscodeTaskList struct {
	// Queries transcoding tasks based on the media ID. This operation does not return specific job information.
	CompleteTime *string `json:"CompleteTime,omitempty" xml:"CompleteTime,omitempty"`
	// The ID of the audio or video file. You can use one of the following methods to obtain the ID of the file:
	//
	// *   Log on to the [ApsaraVideo VOD](https://vod.console.aliyun.com) console. In the left-side navigation pane, choose **Media Files** > **Audio/Video**. On the Video and Audio page, view the ID of the audio or video file. This method is applicable to files that are uploaded by using the ApsaraVideo VOD console.
	// *   Obtain the value of VideoId from the response to the [CreateUploadVideo](~~55407~~) operation that you call to obtain the upload URL and credential.
	// *   Obtain the value of VideoId by calling the [SearchMedia](~~86044~~) operation. This method is applicable to files that have been uploaded.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	TaskStatus               *string `json:"TaskStatus,omitempty" xml:"TaskStatus,omitempty"`
	TranscodeTaskId          *string `json:"TranscodeTaskId,omitempty" xml:"TranscodeTaskId,omitempty"`
	TranscodeTemplateGroupId *string `json:"TranscodeTemplateGroupId,omitempty" xml:"TranscodeTemplateGroupId,omitempty"`
	// The status of the transcoding task. Valid values:
	//
	// *   **Processing**: In progress.
	// *   **Partial**: Some transcoding jobs were complete.
	// *   **CompleteAllSucc**: All transcoding jobs were successful.
	// *   **CompleteAllFail**: All transcoding jobs failed. If an exception occurs in the source file, no transcoding job is initiated and the transcoding task fails.
	// *   **CompletePartialSucc**: All transcoding jobs were complete but only some were successful.
	Trigger *string `json:"Trigger,omitempty" xml:"Trigger,omitempty"`
	// The ID of the request.
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s ListTranscodeTaskResponseBodyTranscodeTaskList) String() string {
	return tea.Prettify(s)
}

func (s ListTranscodeTaskResponseBodyTranscodeTaskList) GoString() string {
	return s.String()
}

func (s *ListTranscodeTaskResponseBodyTranscodeTaskList) SetCompleteTime(v string) *ListTranscodeTaskResponseBodyTranscodeTaskList {
	s.CompleteTime = &v
	return s
}

func (s *ListTranscodeTaskResponseBodyTranscodeTaskList) SetCreationTime(v string) *ListTranscodeTaskResponseBodyTranscodeTaskList {
	s.CreationTime = &v
	return s
}

func (s *ListTranscodeTaskResponseBodyTranscodeTaskList) SetTaskStatus(v string) *ListTranscodeTaskResponseBodyTranscodeTaskList {
	s.TaskStatus = &v
	return s
}

func (s *ListTranscodeTaskResponseBodyTranscodeTaskList) SetTranscodeTaskId(v string) *ListTranscodeTaskResponseBodyTranscodeTaskList {
	s.TranscodeTaskId = &v
	return s
}

func (s *ListTranscodeTaskResponseBodyTranscodeTaskList) SetTranscodeTemplateGroupId(v string) *ListTranscodeTaskResponseBodyTranscodeTaskList {
	s.TranscodeTemplateGroupId = &v
	return s
}

func (s *ListTranscodeTaskResponseBodyTranscodeTaskList) SetTrigger(v string) *ListTranscodeTaskResponseBodyTranscodeTaskList {
	s.Trigger = &v
	return s
}

func (s *ListTranscodeTaskResponseBodyTranscodeTaskList) SetVideoId(v string) *ListTranscodeTaskResponseBodyTranscodeTaskList {
	s.VideoId = &v
	return s
}

type ListTranscodeTaskResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTranscodeTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTranscodeTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTranscodeTaskResponse) GoString() string {
	return s.String()
}

func (s *ListTranscodeTaskResponse) SetHeaders(v map[string]*string) *ListTranscodeTaskResponse {
	s.Headers = v
	return s
}

func (s *ListTranscodeTaskResponse) SetStatusCode(v int32) *ListTranscodeTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTranscodeTaskResponse) SetBody(v *ListTranscodeTaskResponseBody) *ListTranscodeTaskResponse {
	s.Body = v
	return s
}

type ListTranscodeTemplateGroupRequest struct {
	// The name of the template group.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
}

func (s ListTranscodeTemplateGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTranscodeTemplateGroupRequest) GoString() string {
	return s.String()
}

func (s *ListTranscodeTemplateGroupRequest) SetAppId(v string) *ListTranscodeTemplateGroupRequest {
	s.AppId = &v
	return s
}

type ListTranscodeTemplateGroupResponseBody struct {
	// The ID of the transcoding template group.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The lock status of the transcoding template group. Valid values:
	//
	// *   **Disabled**: The template group is not locked.
	// *   **Enabled**: The template group is locked.
	TranscodeTemplateGroupList []*ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList `json:"TranscodeTemplateGroupList,omitempty" xml:"TranscodeTemplateGroupList,omitempty" type:"Repeated"`
}

func (s ListTranscodeTemplateGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTranscodeTemplateGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ListTranscodeTemplateGroupResponseBody) SetRequestId(v string) *ListTranscodeTemplateGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTranscodeTemplateGroupResponseBody) SetTranscodeTemplateGroupList(v []*ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList) *ListTranscodeTemplateGroupResponseBody {
	s.TranscodeTemplateGroupList = v
	return s
}

type ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList struct {
	// The operation that you want to perform. Set the value to **ListTranscodeTemplateGroup**.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The time when the template group was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The ID of the request.
	IsDefault  *string `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	Locked     *string `json:"Locked,omitempty" xml:"Locked,omitempty"`
	ModifyTime *string `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	// Queries transcoding template groups.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the application.
	TranscodeTemplateGroupId *string `json:"TranscodeTemplateGroupId,omitempty" xml:"TranscodeTemplateGroupId,omitempty"`
}

func (s ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList) String() string {
	return tea.Prettify(s)
}

func (s ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList) GoString() string {
	return s.String()
}

func (s *ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList) SetAppId(v string) *ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList {
	s.AppId = &v
	return s
}

func (s *ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList) SetCreationTime(v string) *ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList {
	s.CreationTime = &v
	return s
}

func (s *ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList) SetIsDefault(v string) *ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList {
	s.IsDefault = &v
	return s
}

func (s *ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList) SetLocked(v string) *ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList {
	s.Locked = &v
	return s
}

func (s *ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList) SetModifyTime(v string) *ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList {
	s.ModifyTime = &v
	return s
}

func (s *ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList) SetName(v string) *ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList {
	s.Name = &v
	return s
}

func (s *ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList) SetTranscodeTemplateGroupId(v string) *ListTranscodeTemplateGroupResponseBodyTranscodeTemplateGroupList {
	s.TranscodeTemplateGroupId = &v
	return s
}

type ListTranscodeTemplateGroupResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTranscodeTemplateGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTranscodeTemplateGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTranscodeTemplateGroupResponse) GoString() string {
	return s.String()
}

func (s *ListTranscodeTemplateGroupResponse) SetHeaders(v map[string]*string) *ListTranscodeTemplateGroupResponse {
	s.Headers = v
	return s
}

func (s *ListTranscodeTemplateGroupResponse) SetStatusCode(v int32) *ListTranscodeTemplateGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTranscodeTemplateGroupResponse) SetBody(v *ListTranscodeTemplateGroupResponseBody) *ListTranscodeTemplateGroupResponse {
	s.Body = v
	return s
}

type ListVodTemplateRequest struct {
	// The snapshot templates.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// Indicates whether the template is the default one. Valid values:
	//
	// *   **Default**: The template is the default one.
	// *   **NotDefault**: The template is not the default one.
	TemplateType *string `json:"TemplateType,omitempty" xml:"TemplateType,omitempty"`
}

func (s ListVodTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s ListVodTemplateRequest) GoString() string {
	return s.String()
}

func (s *ListVodTemplateRequest) SetAppId(v string) *ListVodTemplateRequest {
	s.AppId = &v
	return s
}

func (s *ListVodTemplateRequest) SetTemplateType(v string) *ListVodTemplateRequest {
	s.TemplateType = &v
	return s
}

type ListVodTemplateResponseBody struct {
	// The time when the template was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The operation that you want to perform. Set the value to **ListVodTemplate**.
	VodTemplateInfoList []*ListVodTemplateResponseBodyVodTemplateInfoList `json:"VodTemplateInfoList,omitempty" xml:"VodTemplateInfoList,omitempty" type:"Repeated"`
}

func (s ListVodTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListVodTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *ListVodTemplateResponseBody) SetRequestId(v string) *ListVodTemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListVodTemplateResponseBody) SetVodTemplateInfoList(v []*ListVodTemplateResponseBodyVodTemplateInfoList) *ListVodTemplateResponseBody {
	s.VodTemplateInfoList = v
	return s
}

type ListVodTemplateResponseBodyVodTemplateInfoList struct {
	// The name of the template.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The ID of the application.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The type of the template. Set the value to **Snapshot**.
	IsDefault  *string `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	ModifyTime *string `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	Name       *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Queries snapshot templates.
	TemplateConfig *string `json:"TemplateConfig,omitempty" xml:"TemplateConfig,omitempty"`
	// The detailed configurations of the template. The value is a JSON-formatted string. For more information about the data structure, see the "SnapshotTemplateConfig" section of the [Media processing parameters](~~98618~~) topic.
	TemplateType *string `json:"TemplateType,omitempty" xml:"TemplateType,omitempty"`
	// The ID of the request.
	VodTemplateId *string `json:"VodTemplateId,omitempty" xml:"VodTemplateId,omitempty"`
}

func (s ListVodTemplateResponseBodyVodTemplateInfoList) String() string {
	return tea.Prettify(s)
}

func (s ListVodTemplateResponseBodyVodTemplateInfoList) GoString() string {
	return s.String()
}

func (s *ListVodTemplateResponseBodyVodTemplateInfoList) SetAppId(v string) *ListVodTemplateResponseBodyVodTemplateInfoList {
	s.AppId = &v
	return s
}

func (s *ListVodTemplateResponseBodyVodTemplateInfoList) SetCreationTime(v string) *ListVodTemplateResponseBodyVodTemplateInfoList {
	s.CreationTime = &v
	return s
}

func (s *ListVodTemplateResponseBodyVodTemplateInfoList) SetIsDefault(v string) *ListVodTemplateResponseBodyVodTemplateInfoList {
	s.IsDefault = &v
	return s
}

func (s *ListVodTemplateResponseBodyVodTemplateInfoList) SetModifyTime(v string) *ListVodTemplateResponseBodyVodTemplateInfoList {
	s.ModifyTime = &v
	return s
}

func (s *ListVodTemplateResponseBodyVodTemplateInfoList) SetName(v string) *ListVodTemplateResponseBodyVodTemplateInfoList {
	s.Name = &v
	return s
}

func (s *ListVodTemplateResponseBodyVodTemplateInfoList) SetTemplateConfig(v string) *ListVodTemplateResponseBodyVodTemplateInfoList {
	s.TemplateConfig = &v
	return s
}

func (s *ListVodTemplateResponseBodyVodTemplateInfoList) SetTemplateType(v string) *ListVodTemplateResponseBodyVodTemplateInfoList {
	s.TemplateType = &v
	return s
}

func (s *ListVodTemplateResponseBodyVodTemplateInfoList) SetVodTemplateId(v string) *ListVodTemplateResponseBodyVodTemplateInfoList {
	s.VodTemplateId = &v
	return s
}

type ListVodTemplateResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListVodTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListVodTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s ListVodTemplateResponse) GoString() string {
	return s.String()
}

func (s *ListVodTemplateResponse) SetHeaders(v map[string]*string) *ListVodTemplateResponse {
	s.Headers = v
	return s
}

func (s *ListVodTemplateResponse) SetStatusCode(v int32) *ListVodTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *ListVodTemplateResponse) SetBody(v *ListVodTemplateResponseBody) *ListVodTemplateResponse {
	s.Body = v
	return s
}

type ListWatermarkRequest struct {
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
}

func (s ListWatermarkRequest) String() string {
	return tea.Prettify(s)
}

func (s ListWatermarkRequest) GoString() string {
	return s.String()
}

func (s *ListWatermarkRequest) SetAppId(v string) *ListWatermarkRequest {
	s.AppId = &v
	return s
}

type ListWatermarkResponseBody struct {
	RequestId      *string                                    `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	WatermarkInfos []*ListWatermarkResponseBodyWatermarkInfos `json:"WatermarkInfos,omitempty" xml:"WatermarkInfos,omitempty" type:"Repeated"`
}

func (s ListWatermarkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListWatermarkResponseBody) GoString() string {
	return s.String()
}

func (s *ListWatermarkResponseBody) SetRequestId(v string) *ListWatermarkResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListWatermarkResponseBody) SetWatermarkInfos(v []*ListWatermarkResponseBodyWatermarkInfos) *ListWatermarkResponseBody {
	s.WatermarkInfos = v
	return s
}

type ListWatermarkResponseBodyWatermarkInfos struct {
	AppId           *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	CreationTime    *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	FileUrl         *string `json:"FileUrl,omitempty" xml:"FileUrl,omitempty"`
	IsDefault       *string `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	Name            *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Type            *string `json:"Type,omitempty" xml:"Type,omitempty"`
	WatermarkConfig *string `json:"WatermarkConfig,omitempty" xml:"WatermarkConfig,omitempty"`
	WatermarkId     *string `json:"WatermarkId,omitempty" xml:"WatermarkId,omitempty"`
}

func (s ListWatermarkResponseBodyWatermarkInfos) String() string {
	return tea.Prettify(s)
}

func (s ListWatermarkResponseBodyWatermarkInfos) GoString() string {
	return s.String()
}

func (s *ListWatermarkResponseBodyWatermarkInfos) SetAppId(v string) *ListWatermarkResponseBodyWatermarkInfos {
	s.AppId = &v
	return s
}

func (s *ListWatermarkResponseBodyWatermarkInfos) SetCreationTime(v string) *ListWatermarkResponseBodyWatermarkInfos {
	s.CreationTime = &v
	return s
}

func (s *ListWatermarkResponseBodyWatermarkInfos) SetFileUrl(v string) *ListWatermarkResponseBodyWatermarkInfos {
	s.FileUrl = &v
	return s
}

func (s *ListWatermarkResponseBodyWatermarkInfos) SetIsDefault(v string) *ListWatermarkResponseBodyWatermarkInfos {
	s.IsDefault = &v
	return s
}

func (s *ListWatermarkResponseBodyWatermarkInfos) SetName(v string) *ListWatermarkResponseBodyWatermarkInfos {
	s.Name = &v
	return s
}

func (s *ListWatermarkResponseBodyWatermarkInfos) SetType(v string) *ListWatermarkResponseBodyWatermarkInfos {
	s.Type = &v
	return s
}

func (s *ListWatermarkResponseBodyWatermarkInfos) SetWatermarkConfig(v string) *ListWatermarkResponseBodyWatermarkInfos {
	s.WatermarkConfig = &v
	return s
}

func (s *ListWatermarkResponseBodyWatermarkInfos) SetWatermarkId(v string) *ListWatermarkResponseBodyWatermarkInfos {
	s.WatermarkId = &v
	return s
}

type ListWatermarkResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListWatermarkResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListWatermarkResponse) String() string {
	return tea.Prettify(s)
}

func (s ListWatermarkResponse) GoString() string {
	return s.String()
}

func (s *ListWatermarkResponse) SetHeaders(v map[string]*string) *ListWatermarkResponse {
	s.Headers = v
	return s
}

func (s *ListWatermarkResponse) SetStatusCode(v int32) *ListWatermarkResponse {
	s.StatusCode = &v
	return s
}

func (s *ListWatermarkResponse) SetBody(v *ListWatermarkResponseBody) *ListWatermarkResponse {
	s.Body = v
	return s
}

type MoveAppResourceRequest struct {
	// The operation that you want to perform. Set the value to **MoveAppResource**.
	ResourceIds *string `json:"ResourceIds,omitempty" xml:"ResourceIds,omitempty"`
	// The ID of the request.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The ID of the resource. You can specify a maximum of 20 IDs at a time. Separate them with commas (,).
	TargetAppId *string `json:"TargetAppId,omitempty" xml:"TargetAppId,omitempty"`
}

func (s MoveAppResourceRequest) String() string {
	return tea.Prettify(s)
}

func (s MoveAppResourceRequest) GoString() string {
	return s.String()
}

func (s *MoveAppResourceRequest) SetResourceIds(v string) *MoveAppResourceRequest {
	s.ResourceIds = &v
	return s
}

func (s *MoveAppResourceRequest) SetResourceType(v string) *MoveAppResourceRequest {
	s.ResourceType = &v
	return s
}

func (s *MoveAppResourceRequest) SetTargetAppId(v string) *MoveAppResourceRequest {
	s.TargetAppId = &v
	return s
}

type MoveAppResourceResponseBody struct {
	FailedResourceIds   []*string `json:"FailedResourceIds,omitempty" xml:"FailedResourceIds,omitempty" type:"Repeated"`
	NonExistResourceIds []*string `json:"NonExistResourceIds,omitempty" xml:"NonExistResourceIds,omitempty" type:"Repeated"`
	// Migrates one or more resources from an application to another application.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s MoveAppResourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s MoveAppResourceResponseBody) GoString() string {
	return s.String()
}

func (s *MoveAppResourceResponseBody) SetFailedResourceIds(v []*string) *MoveAppResourceResponseBody {
	s.FailedResourceIds = v
	return s
}

func (s *MoveAppResourceResponseBody) SetNonExistResourceIds(v []*string) *MoveAppResourceResponseBody {
	s.NonExistResourceIds = v
	return s
}

func (s *MoveAppResourceResponseBody) SetRequestId(v string) *MoveAppResourceResponseBody {
	s.RequestId = &v
	return s
}

type MoveAppResourceResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *MoveAppResourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s MoveAppResourceResponse) String() string {
	return tea.Prettify(s)
}

func (s MoveAppResourceResponse) GoString() string {
	return s.String()
}

func (s *MoveAppResourceResponse) SetHeaders(v map[string]*string) *MoveAppResourceResponse {
	s.Headers = v
	return s
}

func (s *MoveAppResourceResponse) SetStatusCode(v int32) *MoveAppResourceResponse {
	s.StatusCode = &v
	return s
}

func (s *MoveAppResourceResponse) SetBody(v *MoveAppResourceResponseBody) *MoveAppResourceResponse {
	s.Body = v
	return s
}

type PreloadVodObjectCachesRequest struct {
	ObjectPath    *string `json:"ObjectPath,omitempty" xml:"ObjectPath,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s PreloadVodObjectCachesRequest) String() string {
	return tea.Prettify(s)
}

func (s PreloadVodObjectCachesRequest) GoString() string {
	return s.String()
}

func (s *PreloadVodObjectCachesRequest) SetObjectPath(v string) *PreloadVodObjectCachesRequest {
	s.ObjectPath = &v
	return s
}

func (s *PreloadVodObjectCachesRequest) SetOwnerId(v int64) *PreloadVodObjectCachesRequest {
	s.OwnerId = &v
	return s
}

func (s *PreloadVodObjectCachesRequest) SetSecurityToken(v string) *PreloadVodObjectCachesRequest {
	s.SecurityToken = &v
	return s
}

type PreloadVodObjectCachesResponseBody struct {
	PreloadTaskId *string `json:"PreloadTaskId,omitempty" xml:"PreloadTaskId,omitempty"`
	RequestId     *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s PreloadVodObjectCachesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PreloadVodObjectCachesResponseBody) GoString() string {
	return s.String()
}

func (s *PreloadVodObjectCachesResponseBody) SetPreloadTaskId(v string) *PreloadVodObjectCachesResponseBody {
	s.PreloadTaskId = &v
	return s
}

func (s *PreloadVodObjectCachesResponseBody) SetRequestId(v string) *PreloadVodObjectCachesResponseBody {
	s.RequestId = &v
	return s
}

type PreloadVodObjectCachesResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PreloadVodObjectCachesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PreloadVodObjectCachesResponse) String() string {
	return tea.Prettify(s)
}

func (s PreloadVodObjectCachesResponse) GoString() string {
	return s.String()
}

func (s *PreloadVodObjectCachesResponse) SetHeaders(v map[string]*string) *PreloadVodObjectCachesResponse {
	s.Headers = v
	return s
}

func (s *PreloadVodObjectCachesResponse) SetStatusCode(v int32) *PreloadVodObjectCachesResponse {
	s.StatusCode = &v
	return s
}

func (s *PreloadVodObjectCachesResponse) SetBody(v *PreloadVodObjectCachesResponseBody) *PreloadVodObjectCachesResponse {
	s.Body = v
	return s
}

type ProduceEditingProjectVideoRequest struct {
	// >ApsaraVideo VOD sends a FileUploadComplete event notification after video production is complete, which is similar to the action that is performed after video upload. After the produced video is transcoded, ApsaraVideo VOD sends the StreamTranscodeComplete and TranscodeComplete event notifications.
	CoverURL *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	// The description of the online editing project.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Produces a video from one or more mezzanine files. You can directly submit mezzanine files by specifying the Timeline parameter. Alternatively, you can submit mezzanine files after you create an online editing project.
	MediaMetadata *string `json:"MediaMetadata,omitempty" xml:"MediaMetadata,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// 朴灵
	ProduceConfig *string `json:"ProduceConfig,omitempty" xml:"ProduceConfig,omitempty"`
	// The thumbnail URL of the online editing project.
	ProjectId            *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the produced video.
	//
	// > *   This operation returns the ID of the produced video in synchronous mode.
	// > *   If this operation returns the MediaId parameter, the video production task is being asynchronously processed.
	Timeline *string `json:"Timeline,omitempty" xml:"Timeline,omitempty"`
	// The metadata of the produced video, in JSON format. For more information about the structure, see [MediaMetadata](~~52839~~).
	Title    *string `json:"Title,omitempty" xml:"Title,omitempty"`
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
}

func (s ProduceEditingProjectVideoRequest) String() string {
	return tea.Prettify(s)
}

func (s ProduceEditingProjectVideoRequest) GoString() string {
	return s.String()
}

func (s *ProduceEditingProjectVideoRequest) SetCoverURL(v string) *ProduceEditingProjectVideoRequest {
	s.CoverURL = &v
	return s
}

func (s *ProduceEditingProjectVideoRequest) SetDescription(v string) *ProduceEditingProjectVideoRequest {
	s.Description = &v
	return s
}

func (s *ProduceEditingProjectVideoRequest) SetMediaMetadata(v string) *ProduceEditingProjectVideoRequest {
	s.MediaMetadata = &v
	return s
}

func (s *ProduceEditingProjectVideoRequest) SetOwnerId(v int64) *ProduceEditingProjectVideoRequest {
	s.OwnerId = &v
	return s
}

func (s *ProduceEditingProjectVideoRequest) SetProduceConfig(v string) *ProduceEditingProjectVideoRequest {
	s.ProduceConfig = &v
	return s
}

func (s *ProduceEditingProjectVideoRequest) SetProjectId(v string) *ProduceEditingProjectVideoRequest {
	s.ProjectId = &v
	return s
}

func (s *ProduceEditingProjectVideoRequest) SetResourceOwnerAccount(v string) *ProduceEditingProjectVideoRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ProduceEditingProjectVideoRequest) SetResourceOwnerId(v int64) *ProduceEditingProjectVideoRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ProduceEditingProjectVideoRequest) SetTimeline(v string) *ProduceEditingProjectVideoRequest {
	s.Timeline = &v
	return s
}

func (s *ProduceEditingProjectVideoRequest) SetTitle(v string) *ProduceEditingProjectVideoRequest {
	s.Title = &v
	return s
}

func (s *ProduceEditingProjectVideoRequest) SetUserData(v string) *ProduceEditingProjectVideoRequest {
	s.UserData = &v
	return s
}

type ProduceEditingProjectVideoResponseBody struct {
	MediaId   *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	ProjectId *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ProduceEditingProjectVideoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ProduceEditingProjectVideoResponseBody) GoString() string {
	return s.String()
}

func (s *ProduceEditingProjectVideoResponseBody) SetMediaId(v string) *ProduceEditingProjectVideoResponseBody {
	s.MediaId = &v
	return s
}

func (s *ProduceEditingProjectVideoResponseBody) SetProjectId(v string) *ProduceEditingProjectVideoResponseBody {
	s.ProjectId = &v
	return s
}

func (s *ProduceEditingProjectVideoResponseBody) SetRequestId(v string) *ProduceEditingProjectVideoResponseBody {
	s.RequestId = &v
	return s
}

type ProduceEditingProjectVideoResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ProduceEditingProjectVideoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ProduceEditingProjectVideoResponse) String() string {
	return tea.Prettify(s)
}

func (s ProduceEditingProjectVideoResponse) GoString() string {
	return s.String()
}

func (s *ProduceEditingProjectVideoResponse) SetHeaders(v map[string]*string) *ProduceEditingProjectVideoResponse {
	s.Headers = v
	return s
}

func (s *ProduceEditingProjectVideoResponse) SetStatusCode(v int32) *ProduceEditingProjectVideoResponse {
	s.StatusCode = &v
	return s
}

func (s *ProduceEditingProjectVideoResponse) SetBody(v *ProduceEditingProjectVideoResponseBody) *ProduceEditingProjectVideoResponse {
	s.Body = v
	return s
}

type RefreshMediaPlayUrlsRequest struct {
	// Specifies the type of the refresh or prefetch operation. Default value: Single. Valid values:
	//
	// *   **Single**: Only one latest transcoded stream is refreshed or prefetched for each resolution and format.
	// *   **Multiple**: All transcoded streams are refreshed or prefetched for each resolution and format.
	Definitions *string `json:"Definitions,omitempty" xml:"Definitions,omitempty"`
	// Specifies the types of media streams you want to refresh or prefetch. You can specify multiple types. Separate multiple types with commas (,). If you leave this parameter empty, media streams in all types are refreshed or prefetched by default. Valid values:
	//
	// *   **video**
	// *   **audio**
	Formats *string `json:"Formats,omitempty" xml:"Formats,omitempty"`
	// Specifies whether to refresh or prefetch the playback URLs of the TS files of the M3U8 media stream. Default value: false. Valid values:
	//
	// *   **false**
	// *   **true**
	MediaIds *string `json:"MediaIds,omitempty" xml:"MediaIds,omitempty"`
	// The IDs of the media files that you want to refresh or prefetch. You can specify a maximum of 20 IDs. Separate multiple IDs with commas (,). You can use one of the following methods to obtain the ID:
	//
	// *   Log on to the [ApsaraVideo VOD](https://vod.console.aliyun.com) console. In the left-side navigation pane, choose **Media Files** > **Audio/Video**. On the Video and Audio page, view the ID of the audio or video file. This method is applicable to files that are uploaded by using the ApsaraVideo VOD console.
	// *   Obtain the value of VideoId from the response to the [CreateUploadVideo](~~55407~~) operation that you call to upload media files.
	// *   Obtain the value of VideoId from the response to the [SearchMedia](~~86044~~) operation that you call to query the media ID after the media file is uploaded.
	ResultType *string `json:"ResultType,omitempty" xml:"ResultType,omitempty"`
	// The IDs of the media files that cannot be operated on. In most cases, media files cannot be operated on because you are not authorized to perform the operations. For more information, see [Overview](~~113600~~).
	SliceCount *int32 `json:"SliceCount,omitempty" xml:"SliceCount,omitempty"`
	// The ID of the refresh or prefetch task.
	SliceFlag *bool `json:"SliceFlag,omitempty" xml:"SliceFlag,omitempty"`
	// The custom configurations such as callback configurations and upload acceleration configurations. The value is a JSON string. For more information, see [Request parameter](~~86952~~).
	// >
	// - The callback configurations take effect only after you specify the HTTP callback URL and select specific callback events in the ApsaraVideo VOD console. For more information about how to configure HTTP callback settings in the ApsaraVideo VOD console, see [Configure callback settings](~~86071~~).
	// - You must submit a ticket to enable the upload acceleration feature. For more information, see [Overview](~~55396~~).
	StreamType *string `json:"StreamType,omitempty" xml:"StreamType,omitempty"`
	// The IDs of the media files that do not exist.
	TaskType *string `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
	// Specifies the resolutions of the media streams you want to refresh or prefetch. You can specify multiple resolutions. Separate multiple resolutions with commas (,). If you leave this parameter empty, media streams in all resolutions are refreshed or prefetched by default.
	//
	// >  The value must be supported in the **Definition** section in [Parameters for media assets](~~124671~~).
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
}

func (s RefreshMediaPlayUrlsRequest) String() string {
	return tea.Prettify(s)
}

func (s RefreshMediaPlayUrlsRequest) GoString() string {
	return s.String()
}

func (s *RefreshMediaPlayUrlsRequest) SetDefinitions(v string) *RefreshMediaPlayUrlsRequest {
	s.Definitions = &v
	return s
}

func (s *RefreshMediaPlayUrlsRequest) SetFormats(v string) *RefreshMediaPlayUrlsRequest {
	s.Formats = &v
	return s
}

func (s *RefreshMediaPlayUrlsRequest) SetMediaIds(v string) *RefreshMediaPlayUrlsRequest {
	s.MediaIds = &v
	return s
}

func (s *RefreshMediaPlayUrlsRequest) SetResultType(v string) *RefreshMediaPlayUrlsRequest {
	s.ResultType = &v
	return s
}

func (s *RefreshMediaPlayUrlsRequest) SetSliceCount(v int32) *RefreshMediaPlayUrlsRequest {
	s.SliceCount = &v
	return s
}

func (s *RefreshMediaPlayUrlsRequest) SetSliceFlag(v bool) *RefreshMediaPlayUrlsRequest {
	s.SliceFlag = &v
	return s
}

func (s *RefreshMediaPlayUrlsRequest) SetStreamType(v string) *RefreshMediaPlayUrlsRequest {
	s.StreamType = &v
	return s
}

func (s *RefreshMediaPlayUrlsRequest) SetTaskType(v string) *RefreshMediaPlayUrlsRequest {
	s.TaskType = &v
	return s
}

func (s *RefreshMediaPlayUrlsRequest) SetUserData(v string) *RefreshMediaPlayUrlsRequest {
	s.UserData = &v
	return s
}

type RefreshMediaPlayUrlsResponseBody struct {
	ForbiddenMediaIds *string `json:"ForbiddenMediaIds,omitempty" xml:"ForbiddenMediaIds,omitempty"`
	// Submits media refresh or prefetch tasks based on the media IDs.
	MediaRefreshJobId *string `json:"MediaRefreshJobId,omitempty" xml:"MediaRefreshJobId,omitempty"`
	NonExistMediaIds  *string `json:"NonExistMediaIds,omitempty" xml:"NonExistMediaIds,omitempty"`
	RequestId         *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RefreshMediaPlayUrlsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RefreshMediaPlayUrlsResponseBody) GoString() string {
	return s.String()
}

func (s *RefreshMediaPlayUrlsResponseBody) SetForbiddenMediaIds(v string) *RefreshMediaPlayUrlsResponseBody {
	s.ForbiddenMediaIds = &v
	return s
}

func (s *RefreshMediaPlayUrlsResponseBody) SetMediaRefreshJobId(v string) *RefreshMediaPlayUrlsResponseBody {
	s.MediaRefreshJobId = &v
	return s
}

func (s *RefreshMediaPlayUrlsResponseBody) SetNonExistMediaIds(v string) *RefreshMediaPlayUrlsResponseBody {
	s.NonExistMediaIds = &v
	return s
}

func (s *RefreshMediaPlayUrlsResponseBody) SetRequestId(v string) *RefreshMediaPlayUrlsResponseBody {
	s.RequestId = &v
	return s
}

type RefreshMediaPlayUrlsResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RefreshMediaPlayUrlsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RefreshMediaPlayUrlsResponse) String() string {
	return tea.Prettify(s)
}

func (s RefreshMediaPlayUrlsResponse) GoString() string {
	return s.String()
}

func (s *RefreshMediaPlayUrlsResponse) SetHeaders(v map[string]*string) *RefreshMediaPlayUrlsResponse {
	s.Headers = v
	return s
}

func (s *RefreshMediaPlayUrlsResponse) SetStatusCode(v int32) *RefreshMediaPlayUrlsResponse {
	s.StatusCode = &v
	return s
}

func (s *RefreshMediaPlayUrlsResponse) SetBody(v *RefreshMediaPlayUrlsResponseBody) *RefreshMediaPlayUrlsResponse {
	s.Body = v
	return s
}

type RefreshUploadVideoRequest struct {
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The operation that you want to perform. Set the value to **RefreshUploadVideo**.
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s RefreshUploadVideoRequest) String() string {
	return tea.Prettify(s)
}

func (s RefreshUploadVideoRequest) GoString() string {
	return s.String()
}

func (s *RefreshUploadVideoRequest) SetOwnerId(v int64) *RefreshUploadVideoRequest {
	s.OwnerId = &v
	return s
}

func (s *RefreshUploadVideoRequest) SetResourceOwnerAccount(v string) *RefreshUploadVideoRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RefreshUploadVideoRequest) SetResourceOwnerId(v int64) *RefreshUploadVideoRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *RefreshUploadVideoRequest) SetVideoId(v string) *RefreshUploadVideoRequest {
	s.VideoId = &v
	return s
}

type RefreshUploadVideoResponseBody struct {
	// Obtains a new upload credential after the video upload times out.
	RequestId     *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	UploadAddress *string `json:"UploadAddress,omitempty" xml:"UploadAddress,omitempty"`
	UploadAuth    *string `json:"UploadAuth,omitempty" xml:"UploadAuth,omitempty"`
	VideoId       *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s RefreshUploadVideoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RefreshUploadVideoResponseBody) GoString() string {
	return s.String()
}

func (s *RefreshUploadVideoResponseBody) SetRequestId(v string) *RefreshUploadVideoResponseBody {
	s.RequestId = &v
	return s
}

func (s *RefreshUploadVideoResponseBody) SetUploadAddress(v string) *RefreshUploadVideoResponseBody {
	s.UploadAddress = &v
	return s
}

func (s *RefreshUploadVideoResponseBody) SetUploadAuth(v string) *RefreshUploadVideoResponseBody {
	s.UploadAuth = &v
	return s
}

func (s *RefreshUploadVideoResponseBody) SetVideoId(v string) *RefreshUploadVideoResponseBody {
	s.VideoId = &v
	return s
}

type RefreshUploadVideoResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RefreshUploadVideoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RefreshUploadVideoResponse) String() string {
	return tea.Prettify(s)
}

func (s RefreshUploadVideoResponse) GoString() string {
	return s.String()
}

func (s *RefreshUploadVideoResponse) SetHeaders(v map[string]*string) *RefreshUploadVideoResponse {
	s.Headers = v
	return s
}

func (s *RefreshUploadVideoResponse) SetStatusCode(v int32) *RefreshUploadVideoResponse {
	s.StatusCode = &v
	return s
}

func (s *RefreshUploadVideoResponse) SetBody(v *RefreshUploadVideoResponseBody) *RefreshUploadVideoResponse {
	s.Body = v
	return s
}

type RefreshVodObjectCachesRequest struct {
	// The granularity of the resources to be refreshed. Valid values:
	//
	// *   **File**: refreshes one or more files. This is the default value.
	// *   **Directory**: refreshes the files under one or more directories.
	ObjectPath *string `json:"ObjectPath,omitempty" xml:"ObjectPath,omitempty"`
	// Refreshes files on Alibaba Cloud CDN nodes. You can refresh multiple files at a time based on URLs.
	ObjectType    *string `json:"ObjectType,omitempty" xml:"ObjectType,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s RefreshVodObjectCachesRequest) String() string {
	return tea.Prettify(s)
}

func (s RefreshVodObjectCachesRequest) GoString() string {
	return s.String()
}

func (s *RefreshVodObjectCachesRequest) SetObjectPath(v string) *RefreshVodObjectCachesRequest {
	s.ObjectPath = &v
	return s
}

func (s *RefreshVodObjectCachesRequest) SetObjectType(v string) *RefreshVodObjectCachesRequest {
	s.ObjectType = &v
	return s
}

func (s *RefreshVodObjectCachesRequest) SetOwnerId(v int64) *RefreshVodObjectCachesRequest {
	s.OwnerId = &v
	return s
}

func (s *RefreshVodObjectCachesRequest) SetSecurityToken(v string) *RefreshVodObjectCachesRequest {
	s.SecurityToken = &v
	return s
}

type RefreshVodObjectCachesResponseBody struct {
	RefreshTaskId *string `json:"RefreshTaskId,omitempty" xml:"RefreshTaskId,omitempty"`
	RequestId     *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RefreshVodObjectCachesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RefreshVodObjectCachesResponseBody) GoString() string {
	return s.String()
}

func (s *RefreshVodObjectCachesResponseBody) SetRefreshTaskId(v string) *RefreshVodObjectCachesResponseBody {
	s.RefreshTaskId = &v
	return s
}

func (s *RefreshVodObjectCachesResponseBody) SetRequestId(v string) *RefreshVodObjectCachesResponseBody {
	s.RequestId = &v
	return s
}

type RefreshVodObjectCachesResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RefreshVodObjectCachesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RefreshVodObjectCachesResponse) String() string {
	return tea.Prettify(s)
}

func (s RefreshVodObjectCachesResponse) GoString() string {
	return s.String()
}

func (s *RefreshVodObjectCachesResponse) SetHeaders(v map[string]*string) *RefreshVodObjectCachesResponse {
	s.Headers = v
	return s
}

func (s *RefreshVodObjectCachesResponse) SetStatusCode(v int32) *RefreshVodObjectCachesResponse {
	s.StatusCode = &v
	return s
}

func (s *RefreshVodObjectCachesResponse) SetBody(v *RefreshVodObjectCachesResponseBody) *RefreshVodObjectCachesResponse {
	s.Body = v
	return s
}

type RegisterMediaRequest struct {
	// The URLs of the media files that failed to be registered.
	RegisterMetadatas *string `json:"RegisterMetadatas,omitempty" xml:"RegisterMetadatas,omitempty"`
	// The ID of the workflow. To view the ID of the workflow, log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Configuration Management** > **Media Processing** > **Workflows**.
	// > If both the WorkflowId and TemplateGroupId parameters are set, the value of the WorkflowId parameter takes effect. For more information, see [Workflows](~~115347~~).
	TemplateGroupId *string `json:"TemplateGroupId,omitempty" xml:"TemplateGroupId,omitempty"`
	// The ID of the media file that is registered with ApsaraVideo VOD. If the registered media file is an audio or video file, the value of the VideoId parameter returned by ApsaraVideo VOD takes effect.
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
	// The ID of the request.
	WorkflowId *string `json:"WorkflowId,omitempty" xml:"WorkflowId,omitempty"`
}

func (s RegisterMediaRequest) String() string {
	return tea.Prettify(s)
}

func (s RegisterMediaRequest) GoString() string {
	return s.String()
}

func (s *RegisterMediaRequest) SetRegisterMetadatas(v string) *RegisterMediaRequest {
	s.RegisterMetadatas = &v
	return s
}

func (s *RegisterMediaRequest) SetTemplateGroupId(v string) *RegisterMediaRequest {
	s.TemplateGroupId = &v
	return s
}

func (s *RegisterMediaRequest) SetUserData(v string) *RegisterMediaRequest {
	s.UserData = &v
	return s
}

func (s *RegisterMediaRequest) SetWorkflowId(v string) *RegisterMediaRequest {
	s.WorkflowId = &v
	return s
}

type RegisterMediaResponseBody struct {
	// ## RegisterMetadata
	//
	// The following table describes the metadata of the media file that you want to register.
	//
	// | Parameter | Type | Required | Description |
	// | --------- | ---- | -------- | ----------- |
	// | FileURL | String | Yes | The OSS URL of the source file. You can call the [GetMezzanineInfo](~~GetMezzanineInfo~~) operation to obtain the OSS URL of the source file.  <br>The URL can be up to 1,024 bytes in length. The file name must be globally unique. If the media file that you want to register is registered before, the unique media ID that is associated with the media file is returned. |
	// | Title | String | Yes | The title of the media file. The title can be up to 128 bytes in length. The value must be encoded in UTF-8. |
	// | Description | String | No | The description of the media file. The description can be up to 1,024 bytes in length. The value must be encoded in UTF-8. |
	// | Tags | String | No | The one or more tags of the media file. Each tag can be up to 32 bytes in length. You can specify a maximum of 16 tags. Separate multiple tags with commas (,). The value must be encoded in UTF-8. |
	// | CoverURL | String | No | The URL of the thumbnail. The URL can be up to 1,024 bytes in length. |
	// | CateId | Long | No | The category ID of the media file. You can use one of the following methods to obtain the category ID: <br>Log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com/). In the left-side navigation pane, choose **Configuration Management** > **Media Management** > **Categories**. On the Categories page, you can view the category ID of the media file.  <br>View the value of the CateId parameter returned by the [AddCategory](~~AddCategory~~) operation that you called to create a category.  <br>View the value of the CateId parameter returned by the [GetCategories](~~GetCategories~~) operation that you called to query a category. |
	FailedFileURLs      []*string                                       `json:"FailedFileURLs,omitempty" xml:"FailedFileURLs,omitempty" type:"Repeated"`
	RegisteredMediaList []*RegisterMediaResponseBodyRegisteredMediaList `json:"RegisteredMediaList,omitempty" xml:"RegisteredMediaList,omitempty" type:"Repeated"`
	// The OSS URL of the media file.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RegisterMediaResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RegisterMediaResponseBody) GoString() string {
	return s.String()
}

func (s *RegisterMediaResponseBody) SetFailedFileURLs(v []*string) *RegisterMediaResponseBody {
	s.FailedFileURLs = v
	return s
}

func (s *RegisterMediaResponseBody) SetRegisteredMediaList(v []*RegisterMediaResponseBodyRegisteredMediaList) *RegisterMediaResponseBody {
	s.RegisteredMediaList = v
	return s
}

func (s *RegisterMediaResponseBody) SetRequestId(v string) *RegisterMediaResponseBody {
	s.RequestId = &v
	return s
}

type RegisterMediaResponseBodyRegisteredMediaList struct {
	FileURL     *string `json:"FileURL,omitempty" xml:"FileURL,omitempty"`
	MediaId     *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	NewRegister *bool   `json:"NewRegister,omitempty" xml:"NewRegister,omitempty"`
}

func (s RegisterMediaResponseBodyRegisteredMediaList) String() string {
	return tea.Prettify(s)
}

func (s RegisterMediaResponseBodyRegisteredMediaList) GoString() string {
	return s.String()
}

func (s *RegisterMediaResponseBodyRegisteredMediaList) SetFileURL(v string) *RegisterMediaResponseBodyRegisteredMediaList {
	s.FileURL = &v
	return s
}

func (s *RegisterMediaResponseBodyRegisteredMediaList) SetMediaId(v string) *RegisterMediaResponseBodyRegisteredMediaList {
	s.MediaId = &v
	return s
}

func (s *RegisterMediaResponseBodyRegisteredMediaList) SetNewRegister(v bool) *RegisterMediaResponseBodyRegisteredMediaList {
	s.NewRegister = &v
	return s
}

type RegisterMediaResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RegisterMediaResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RegisterMediaResponse) String() string {
	return tea.Prettify(s)
}

func (s RegisterMediaResponse) GoString() string {
	return s.String()
}

func (s *RegisterMediaResponse) SetHeaders(v map[string]*string) *RegisterMediaResponse {
	s.Headers = v
	return s
}

func (s *RegisterMediaResponse) SetStatusCode(v int32) *RegisterMediaResponse {
	s.StatusCode = &v
	return s
}

func (s *RegisterMediaResponse) SetBody(v *RegisterMediaResponseBody) *RegisterMediaResponse {
	s.Body = v
	return s
}

type RestoreMediaRequest struct {
	MediaIds    *string `json:"MediaIds,omitempty" xml:"MediaIds,omitempty"`
	RestoreDays *string `json:"RestoreDays,omitempty" xml:"RestoreDays,omitempty"`
	RestoreTier *string `json:"RestoreTier,omitempty" xml:"RestoreTier,omitempty"`
	Scope       *string `json:"Scope,omitempty" xml:"Scope,omitempty"`
}

func (s RestoreMediaRequest) String() string {
	return tea.Prettify(s)
}

func (s RestoreMediaRequest) GoString() string {
	return s.String()
}

func (s *RestoreMediaRequest) SetMediaIds(v string) *RestoreMediaRequest {
	s.MediaIds = &v
	return s
}

func (s *RestoreMediaRequest) SetRestoreDays(v string) *RestoreMediaRequest {
	s.RestoreDays = &v
	return s
}

func (s *RestoreMediaRequest) SetRestoreTier(v string) *RestoreMediaRequest {
	s.RestoreTier = &v
	return s
}

func (s *RestoreMediaRequest) SetScope(v string) *RestoreMediaRequest {
	s.Scope = &v
	return s
}

type RestoreMediaResponseBody struct {
	ForbiddenList *RestoreMediaResponseBodyForbiddenList `json:"ForbiddenList,omitempty" xml:"ForbiddenList,omitempty" type:"Struct"`
	IgnoredList   *RestoreMediaResponseBodyIgnoredList   `json:"IgnoredList,omitempty" xml:"IgnoredList,omitempty" type:"Struct"`
	RequestId     *string                                `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success       *bool                                  `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RestoreMediaResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RestoreMediaResponseBody) GoString() string {
	return s.String()
}

func (s *RestoreMediaResponseBody) SetForbiddenList(v *RestoreMediaResponseBodyForbiddenList) *RestoreMediaResponseBody {
	s.ForbiddenList = v
	return s
}

func (s *RestoreMediaResponseBody) SetIgnoredList(v *RestoreMediaResponseBodyIgnoredList) *RestoreMediaResponseBody {
	s.IgnoredList = v
	return s
}

func (s *RestoreMediaResponseBody) SetRequestId(v string) *RestoreMediaResponseBody {
	s.RequestId = &v
	return s
}

func (s *RestoreMediaResponseBody) SetSuccess(v bool) *RestoreMediaResponseBody {
	s.Success = &v
	return s
}

type RestoreMediaResponseBodyForbiddenList struct {
	MediaForbiddenReasonDTO []*RestoreMediaResponseBodyForbiddenListMediaForbiddenReasonDTO `json:"MediaForbiddenReasonDTO,omitempty" xml:"MediaForbiddenReasonDTO,omitempty" type:"Repeated"`
}

func (s RestoreMediaResponseBodyForbiddenList) String() string {
	return tea.Prettify(s)
}

func (s RestoreMediaResponseBodyForbiddenList) GoString() string {
	return s.String()
}

func (s *RestoreMediaResponseBodyForbiddenList) SetMediaForbiddenReasonDTO(v []*RestoreMediaResponseBodyForbiddenListMediaForbiddenReasonDTO) *RestoreMediaResponseBodyForbiddenList {
	s.MediaForbiddenReasonDTO = v
	return s
}

type RestoreMediaResponseBodyForbiddenListMediaForbiddenReasonDTO struct {
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	Reason  *string `json:"Reason,omitempty" xml:"Reason,omitempty"`
}

func (s RestoreMediaResponseBodyForbiddenListMediaForbiddenReasonDTO) String() string {
	return tea.Prettify(s)
}

func (s RestoreMediaResponseBodyForbiddenListMediaForbiddenReasonDTO) GoString() string {
	return s.String()
}

func (s *RestoreMediaResponseBodyForbiddenListMediaForbiddenReasonDTO) SetMediaId(v string) *RestoreMediaResponseBodyForbiddenListMediaForbiddenReasonDTO {
	s.MediaId = &v
	return s
}

func (s *RestoreMediaResponseBodyForbiddenListMediaForbiddenReasonDTO) SetReason(v string) *RestoreMediaResponseBodyForbiddenListMediaForbiddenReasonDTO {
	s.Reason = &v
	return s
}

type RestoreMediaResponseBodyIgnoredList struct {
	MediaId []*string `json:"MediaId,omitempty" xml:"MediaId,omitempty" type:"Repeated"`
}

func (s RestoreMediaResponseBodyIgnoredList) String() string {
	return tea.Prettify(s)
}

func (s RestoreMediaResponseBodyIgnoredList) GoString() string {
	return s.String()
}

func (s *RestoreMediaResponseBodyIgnoredList) SetMediaId(v []*string) *RestoreMediaResponseBodyIgnoredList {
	s.MediaId = v
	return s
}

type RestoreMediaResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RestoreMediaResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RestoreMediaResponse) String() string {
	return tea.Prettify(s)
}

func (s RestoreMediaResponse) GoString() string {
	return s.String()
}

func (s *RestoreMediaResponse) SetHeaders(v map[string]*string) *RestoreMediaResponse {
	s.Headers = v
	return s
}

func (s *RestoreMediaResponse) SetStatusCode(v int32) *RestoreMediaResponse {
	s.StatusCode = &v
	return s
}

func (s *RestoreMediaResponse) SetBody(v *RestoreMediaResponseBody) *RestoreMediaResponse {
	s.Body = v
	return s
}

type SearchEditingProjectRequest struct {
	// The beginning of the time range to query. The query is performed based on the time range during which the required online editing projects were created. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	EndTime      *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The status of the online editing project. Separate multiple states with commas (,). By default, all online editing projects are queried.
	//
	// Valid values:
	//
	// *   **Normal**: indicates that the online editing project is in draft.
	// *   **Producing**: indicates that the video is being produced.
	// *   **Produced**: indicates that the video was produced.
	// *   **ProduceFailed**: indicates that the video failed to be produced.
	PageNo *int32 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The title of the online editing project.
	PageSize             *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The title of the online editing project.
	SortBy *string `json:"SortBy,omitempty" xml:"SortBy,omitempty"`
	// The region where the online editing project was created.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The list of online editing projects.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The duration of the online editing project, which must be consistent with the duration of the timeline.
	//
	// > The Timeline parameter is not included in response parameters.
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
}

func (s SearchEditingProjectRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchEditingProjectRequest) GoString() string {
	return s.String()
}

func (s *SearchEditingProjectRequest) SetEndTime(v string) *SearchEditingProjectRequest {
	s.EndTime = &v
	return s
}

func (s *SearchEditingProjectRequest) SetOwnerAccount(v string) *SearchEditingProjectRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SearchEditingProjectRequest) SetOwnerId(v string) *SearchEditingProjectRequest {
	s.OwnerId = &v
	return s
}

func (s *SearchEditingProjectRequest) SetPageNo(v int32) *SearchEditingProjectRequest {
	s.PageNo = &v
	return s
}

func (s *SearchEditingProjectRequest) SetPageSize(v int32) *SearchEditingProjectRequest {
	s.PageSize = &v
	return s
}

func (s *SearchEditingProjectRequest) SetResourceOwnerAccount(v string) *SearchEditingProjectRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SearchEditingProjectRequest) SetResourceOwnerId(v string) *SearchEditingProjectRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *SearchEditingProjectRequest) SetSortBy(v string) *SearchEditingProjectRequest {
	s.SortBy = &v
	return s
}

func (s *SearchEditingProjectRequest) SetStartTime(v string) *SearchEditingProjectRequest {
	s.StartTime = &v
	return s
}

func (s *SearchEditingProjectRequest) SetStatus(v string) *SearchEditingProjectRequest {
	s.Status = &v
	return s
}

func (s *SearchEditingProjectRequest) SetTitle(v string) *SearchEditingProjectRequest {
	s.Title = &v
	return s
}

type SearchEditingProjectResponseBody struct {
	// The number of entries to return on each page. Default value: **10**. Maximum value: **100**.
	ProjectList *SearchEditingProjectResponseBodyProjectList `json:"ProjectList,omitempty" xml:"ProjectList,omitempty" type:"Struct"`
	// The operation that you want to perform. Set the value to **SearchEditingProject**.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The time when the online editing project was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s SearchEditingProjectResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SearchEditingProjectResponseBody) GoString() string {
	return s.String()
}

func (s *SearchEditingProjectResponseBody) SetProjectList(v *SearchEditingProjectResponseBodyProjectList) *SearchEditingProjectResponseBody {
	s.ProjectList = v
	return s
}

func (s *SearchEditingProjectResponseBody) SetRequestId(v string) *SearchEditingProjectResponseBody {
	s.RequestId = &v
	return s
}

func (s *SearchEditingProjectResponseBody) SetTotal(v int32) *SearchEditingProjectResponseBody {
	s.Total = &v
	return s
}

type SearchEditingProjectResponseBodyProjectList struct {
	Project []*SearchEditingProjectResponseBodyProjectListProject `json:"Project,omitempty" xml:"Project,omitempty" type:"Repeated"`
}

func (s SearchEditingProjectResponseBodyProjectList) String() string {
	return tea.Prettify(s)
}

func (s SearchEditingProjectResponseBodyProjectList) GoString() string {
	return s.String()
}

func (s *SearchEditingProjectResponseBodyProjectList) SetProject(v []*SearchEditingProjectResponseBodyProjectListProject) *SearchEditingProjectResponseBodyProjectList {
	s.Project = v
	return s
}

type SearchEditingProjectResponseBodyProjectListProject struct {
	// The ID of the online editing project.
	CoverURL *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	// The end of the time range to query. The query is performed based on the time range during which the required online editing projects were created. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The thumbnail URL of the online editing project.
	Description *string  `json:"Description,omitempty" xml:"Description,omitempty"`
	Duration    *float32 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The number of the page to return. Default value: **1**.
	ModifiedTime *string `json:"ModifiedTime,omitempty" xml:"ModifiedTime,omitempty"`
	// Queries online editing projects.
	ProjectId *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	RegionId  *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The sorting rule of results. Valid values:
	//
	// *   **CreationTime:Desc**: sorts the results based on the creation time in descending order. This is the default value.
	// *   **CreationTime:Asc**: sorts the results based on the creation time in ascending order.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The path of the Object Storage Service (OSS) bucket where the produced video is stored.
	//
	// > To view the path of the OSS bucket, log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com/?spm=a2c4g.11186623.2.15.6948257eaZ4m54#/vod/settings/censored), and choose **Configuration Management** > **Media Management** > **Storage**. On the Storage page, you can view the path of the OSS bucket.
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	Title           *string `json:"Title,omitempty" xml:"Title,omitempty"`
}

func (s SearchEditingProjectResponseBodyProjectListProject) String() string {
	return tea.Prettify(s)
}

func (s SearchEditingProjectResponseBodyProjectListProject) GoString() string {
	return s.String()
}

func (s *SearchEditingProjectResponseBodyProjectListProject) SetCoverURL(v string) *SearchEditingProjectResponseBodyProjectListProject {
	s.CoverURL = &v
	return s
}

func (s *SearchEditingProjectResponseBodyProjectListProject) SetCreationTime(v string) *SearchEditingProjectResponseBodyProjectListProject {
	s.CreationTime = &v
	return s
}

func (s *SearchEditingProjectResponseBodyProjectListProject) SetDescription(v string) *SearchEditingProjectResponseBodyProjectListProject {
	s.Description = &v
	return s
}

func (s *SearchEditingProjectResponseBodyProjectListProject) SetDuration(v float32) *SearchEditingProjectResponseBodyProjectListProject {
	s.Duration = &v
	return s
}

func (s *SearchEditingProjectResponseBodyProjectListProject) SetModifiedTime(v string) *SearchEditingProjectResponseBodyProjectListProject {
	s.ModifiedTime = &v
	return s
}

func (s *SearchEditingProjectResponseBodyProjectListProject) SetProjectId(v string) *SearchEditingProjectResponseBodyProjectListProject {
	s.ProjectId = &v
	return s
}

func (s *SearchEditingProjectResponseBodyProjectListProject) SetRegionId(v string) *SearchEditingProjectResponseBodyProjectListProject {
	s.RegionId = &v
	return s
}

func (s *SearchEditingProjectResponseBodyProjectListProject) SetStatus(v string) *SearchEditingProjectResponseBodyProjectListProject {
	s.Status = &v
	return s
}

func (s *SearchEditingProjectResponseBodyProjectListProject) SetStorageLocation(v string) *SearchEditingProjectResponseBodyProjectListProject {
	s.StorageLocation = &v
	return s
}

func (s *SearchEditingProjectResponseBodyProjectListProject) SetTitle(v string) *SearchEditingProjectResponseBodyProjectListProject {
	s.Title = &v
	return s
}

type SearchEditingProjectResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SearchEditingProjectResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SearchEditingProjectResponse) String() string {
	return tea.Prettify(s)
}

func (s SearchEditingProjectResponse) GoString() string {
	return s.String()
}

func (s *SearchEditingProjectResponse) SetHeaders(v map[string]*string) *SearchEditingProjectResponse {
	s.Headers = v
	return s
}

func (s *SearchEditingProjectResponse) SetStatusCode(v int32) *SearchEditingProjectResponse {
	s.StatusCode = &v
	return s
}

func (s *SearchEditingProjectResponse) SetBody(v *SearchEditingProjectResponseBody) *SearchEditingProjectResponse {
	s.Body = v
	return s
}

type SearchMediaRequest struct {
	// Details about media assets.
	Fields *string `json:"Fields,omitempty" xml:"Fields,omitempty"`
	// The preprocessing status. Only preprocessed videos can be used for live streaming in the production studio. Valid values:
	//
	// *   **UnPreprocess**
	// *   **Preprocessing**
	// *   **PreprocessSucceed**
	// *   **PreprocessFailed**
	Match *string `json:"Match,omitempty" xml:"Match,omitempty"`
	// The ID of the media asset.
	PageNo *int32 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The type of the media asset that you want to query. Default value: video. Valid values:
	//
	// *   **video**
	// *   **audio**
	// *   **image**
	// *   **attached**
	//
	// > If this parameter is set to **video** or **audio** and you want to traverse all data that meets the filter criteria, you must set the ScrollToken parameter.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The tags of the image file.
	ScrollToken *string `json:"ScrollToken,omitempty" xml:"ScrollToken,omitempty"`
	// The list of sprite snapshots.
	SearchType *string `json:"SearchType,omitempty" xml:"SearchType,omitempty"`
	// The size of the video file.
	SortBy *string `json:"SortBy,omitempty" xml:"SortBy,omitempty"`
}

func (s SearchMediaRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchMediaRequest) GoString() string {
	return s.String()
}

func (s *SearchMediaRequest) SetFields(v string) *SearchMediaRequest {
	s.Fields = &v
	return s
}

func (s *SearchMediaRequest) SetMatch(v string) *SearchMediaRequest {
	s.Match = &v
	return s
}

func (s *SearchMediaRequest) SetPageNo(v int32) *SearchMediaRequest {
	s.PageNo = &v
	return s
}

func (s *SearchMediaRequest) SetPageSize(v int32) *SearchMediaRequest {
	s.PageSize = &v
	return s
}

func (s *SearchMediaRequest) SetScrollToken(v string) *SearchMediaRequest {
	s.ScrollToken = &v
	return s
}

func (s *SearchMediaRequest) SetSearchType(v string) *SearchMediaRequest {
	s.SearchType = &v
	return s
}

func (s *SearchMediaRequest) SetSortBy(v string) *SearchMediaRequest {
	s.SortBy = &v
	return s
}

type SearchMediaResponseBody struct {
	// The status of the audio file. Valid values:
	//
	// *   **Uploading**
	// *   **Normal**
	// *   **UploadFail**
	// *   **Deleted**
	MediaList []*SearchMediaResponseBodyMediaList `json:"MediaList,omitempty" xml:"MediaList,omitempty" type:"Repeated"`
	// The tags of the audio file.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The title of the auxiliary media asset.
	ScrollToken *string `json:"ScrollToken,omitempty" xml:"ScrollToken,omitempty"`
	// [Details about image files](~~86991~~).
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s SearchMediaResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SearchMediaResponseBody) GoString() string {
	return s.String()
}

func (s *SearchMediaResponseBody) SetMediaList(v []*SearchMediaResponseBodyMediaList) *SearchMediaResponseBody {
	s.MediaList = v
	return s
}

func (s *SearchMediaResponseBody) SetRequestId(v string) *SearchMediaResponseBody {
	s.RequestId = &v
	return s
}

func (s *SearchMediaResponseBody) SetScrollToken(v string) *SearchMediaResponseBody {
	s.ScrollToken = &v
	return s
}

func (s *SearchMediaResponseBody) SetTotal(v int64) *SearchMediaResponseBody {
	s.Total = &v
	return s
}

type SearchMediaResponseBodyMediaList struct {
	// AI详细信息
	AiData *SearchMediaResponseBodyMediaListAiData `json:"AiData,omitempty" xml:"AiData,omitempty" type:"Struct"`
	// AI简介数据
	AiRoughData *SearchMediaResponseBodyMediaListAiRoughData `json:"AiRoughData,omitempty" xml:"AiRoughData,omitempty" type:"Struct"`
	// Queries the information about media assets such as video, audio, and image files, and auxiliary media assets.
	AttachedMedia *SearchMediaResponseBodyMediaListAttachedMedia `json:"AttachedMedia,omitempty" xml:"AttachedMedia,omitempty" type:"Struct"`
	// The name of the category.
	Audio *SearchMediaResponseBodyMediaListAudio `json:"Audio,omitempty" xml:"Audio,omitempty" type:"Struct"`
	// The list of category IDs.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The time when the video file was updated. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	Image *SearchMediaResponseBodyMediaListImage `json:"Image,omitempty" xml:"Image,omitempty" type:"Struct"`
	// The time when the media asset was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The description of the image file.
	MediaType *string `json:"MediaType,omitempty" xml:"MediaType,omitempty"`
	// The download switch. The video file can be downloaded offline only when the download switch is turned on. Valid values:
	//
	// *   **on**
	// *   **off**
	Video *SearchMediaResponseBodyMediaListVideo `json:"Video,omitempty" xml:"Video,omitempty" type:"Struct"`
}

func (s SearchMediaResponseBodyMediaList) String() string {
	return tea.Prettify(s)
}

func (s SearchMediaResponseBodyMediaList) GoString() string {
	return s.String()
}

func (s *SearchMediaResponseBodyMediaList) SetAiData(v *SearchMediaResponseBodyMediaListAiData) *SearchMediaResponseBodyMediaList {
	s.AiData = v
	return s
}

func (s *SearchMediaResponseBodyMediaList) SetAiRoughData(v *SearchMediaResponseBodyMediaListAiRoughData) *SearchMediaResponseBodyMediaList {
	s.AiRoughData = v
	return s
}

func (s *SearchMediaResponseBodyMediaList) SetAttachedMedia(v *SearchMediaResponseBodyMediaListAttachedMedia) *SearchMediaResponseBodyMediaList {
	s.AttachedMedia = v
	return s
}

func (s *SearchMediaResponseBodyMediaList) SetAudio(v *SearchMediaResponseBodyMediaListAudio) *SearchMediaResponseBodyMediaList {
	s.Audio = v
	return s
}

func (s *SearchMediaResponseBodyMediaList) SetCreationTime(v string) *SearchMediaResponseBodyMediaList {
	s.CreationTime = &v
	return s
}

func (s *SearchMediaResponseBodyMediaList) SetImage(v *SearchMediaResponseBodyMediaListImage) *SearchMediaResponseBodyMediaList {
	s.Image = v
	return s
}

func (s *SearchMediaResponseBodyMediaList) SetMediaId(v string) *SearchMediaResponseBodyMediaList {
	s.MediaId = &v
	return s
}

func (s *SearchMediaResponseBodyMediaList) SetMediaType(v string) *SearchMediaResponseBodyMediaList {
	s.MediaType = &v
	return s
}

func (s *SearchMediaResponseBodyMediaList) SetVideo(v *SearchMediaResponseBodyMediaListVideo) *SearchMediaResponseBodyMediaList {
	s.Video = v
	return s
}

type SearchMediaResponseBodyMediaListAiData struct {
	// AI标签信息列表
	AiLabelInfo []*SearchMediaResponseBodyMediaListAiDataAiLabelInfo `json:"AiLabelInfo,omitempty" xml:"AiLabelInfo,omitempty" type:"Repeated"`
	// 字幕信息列表
	OcrInfo []*SearchMediaResponseBodyMediaListAiDataOcrInfo `json:"OcrInfo,omitempty" xml:"OcrInfo,omitempty" type:"Repeated"`
}

func (s SearchMediaResponseBodyMediaListAiData) String() string {
	return tea.Prettify(s)
}

func (s SearchMediaResponseBodyMediaListAiData) GoString() string {
	return s.String()
}

func (s *SearchMediaResponseBodyMediaListAiData) SetAiLabelInfo(v []*SearchMediaResponseBodyMediaListAiDataAiLabelInfo) *SearchMediaResponseBodyMediaListAiData {
	s.AiLabelInfo = v
	return s
}

func (s *SearchMediaResponseBodyMediaListAiData) SetOcrInfo(v []*SearchMediaResponseBodyMediaListAiDataOcrInfo) *SearchMediaResponseBodyMediaListAiData {
	s.OcrInfo = v
	return s
}

type SearchMediaResponseBodyMediaListAiDataAiLabelInfo struct {
	// 分类
	Category *string `json:"Category,omitempty" xml:"Category,omitempty"`
	// 实体ID
	LabelId *string `json:"LabelId,omitempty" xml:"LabelId,omitempty"`
	// 实体名称
	LabelName *string `json:"LabelName,omitempty" xml:"LabelName,omitempty"`
	// 片段列表
	Occurrences []*SearchMediaResponseBodyMediaListAiDataAiLabelInfoOccurrences `json:"Occurrences,omitempty" xml:"Occurrences,omitempty" type:"Repeated"`
}

func (s SearchMediaResponseBodyMediaListAiDataAiLabelInfo) String() string {
	return tea.Prettify(s)
}

func (s SearchMediaResponseBodyMediaListAiDataAiLabelInfo) GoString() string {
	return s.String()
}

func (s *SearchMediaResponseBodyMediaListAiDataAiLabelInfo) SetCategory(v string) *SearchMediaResponseBodyMediaListAiDataAiLabelInfo {
	s.Category = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAiDataAiLabelInfo) SetLabelId(v string) *SearchMediaResponseBodyMediaListAiDataAiLabelInfo {
	s.LabelId = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAiDataAiLabelInfo) SetLabelName(v string) *SearchMediaResponseBodyMediaListAiDataAiLabelInfo {
	s.LabelName = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAiDataAiLabelInfo) SetOccurrences(v []*SearchMediaResponseBodyMediaListAiDataAiLabelInfoOccurrences) *SearchMediaResponseBodyMediaListAiDataAiLabelInfo {
	s.Occurrences = v
	return s
}

type SearchMediaResponseBodyMediaListAiDataAiLabelInfoOccurrences struct {
	// 片段起始时间
	From *float64 `json:"From,omitempty" xml:"From,omitempty"`
	// 打分
	Score *float64 `json:"Score,omitempty" xml:"Score,omitempty"`
	// 片段结束时间
	To *float64 `json:"To,omitempty" xml:"To,omitempty"`
}

func (s SearchMediaResponseBodyMediaListAiDataAiLabelInfoOccurrences) String() string {
	return tea.Prettify(s)
}

func (s SearchMediaResponseBodyMediaListAiDataAiLabelInfoOccurrences) GoString() string {
	return s.String()
}

func (s *SearchMediaResponseBodyMediaListAiDataAiLabelInfoOccurrences) SetFrom(v float64) *SearchMediaResponseBodyMediaListAiDataAiLabelInfoOccurrences {
	s.From = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAiDataAiLabelInfoOccurrences) SetScore(v float64) *SearchMediaResponseBodyMediaListAiDataAiLabelInfoOccurrences {
	s.Score = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAiDataAiLabelInfoOccurrences) SetTo(v float64) *SearchMediaResponseBodyMediaListAiDataAiLabelInfoOccurrences {
	s.To = &v
	return s
}

type SearchMediaResponseBodyMediaListAiDataOcrInfo struct {
	// 文本内容
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// 片段起始时间
	From *float64 `json:"From,omitempty" xml:"From,omitempty"`
	// 片段结束时间
	To *float64 `json:"To,omitempty" xml:"To,omitempty"`
}

func (s SearchMediaResponseBodyMediaListAiDataOcrInfo) String() string {
	return tea.Prettify(s)
}

func (s SearchMediaResponseBodyMediaListAiDataOcrInfo) GoString() string {
	return s.String()
}

func (s *SearchMediaResponseBodyMediaListAiDataOcrInfo) SetContent(v string) *SearchMediaResponseBodyMediaListAiDataOcrInfo {
	s.Content = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAiDataOcrInfo) SetFrom(v float64) *SearchMediaResponseBodyMediaListAiDataOcrInfo {
	s.From = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAiDataOcrInfo) SetTo(v float64) *SearchMediaResponseBodyMediaListAiDataOcrInfo {
	s.To = &v
	return s
}

type SearchMediaResponseBodyMediaListAiRoughData struct {
	// 视频AI分类
	AiCategory *string `json:"AiCategory,omitempty" xml:"AiCategory,omitempty"`
	// AI任务ID
	AiJobId *string `json:"AiJobId,omitempty" xml:"AiJobId,omitempty"`
	// 保存类型
	SaveType *string `json:"SaveType,omitempty" xml:"SaveType,omitempty"`
	// 数据状态
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s SearchMediaResponseBodyMediaListAiRoughData) String() string {
	return tea.Prettify(s)
}

func (s SearchMediaResponseBodyMediaListAiRoughData) GoString() string {
	return s.String()
}

func (s *SearchMediaResponseBodyMediaListAiRoughData) SetAiCategory(v string) *SearchMediaResponseBodyMediaListAiRoughData {
	s.AiCategory = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAiRoughData) SetAiJobId(v string) *SearchMediaResponseBodyMediaListAiRoughData {
	s.AiJobId = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAiRoughData) SetSaveType(v string) *SearchMediaResponseBodyMediaListAiRoughData {
	s.SaveType = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAiRoughData) SetStatus(v string) *SearchMediaResponseBodyMediaListAiRoughData {
	s.Status = &v
	return s
}

type SearchMediaResponseBodyMediaListAttachedMedia struct {
	AppId            *string                                                    `json:"AppId,omitempty" xml:"AppId,omitempty"`
	BusinessType     *string                                                    `json:"BusinessType,omitempty" xml:"BusinessType,omitempty"`
	Categories       []*SearchMediaResponseBodyMediaListAttachedMediaCategories `json:"Categories,omitempty" xml:"Categories,omitempty" type:"Repeated"`
	CreationTime     *string                                                    `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	Description      *string                                                    `json:"Description,omitempty" xml:"Description,omitempty"`
	MediaId          *string                                                    `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	ModificationTime *string                                                    `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	Status           *string                                                    `json:"Status,omitempty" xml:"Status,omitempty"`
	StorageLocation  *string                                                    `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	Tags             *string                                                    `json:"Tags,omitempty" xml:"Tags,omitempty"`
	Title            *string                                                    `json:"Title,omitempty" xml:"Title,omitempty"`
	URL              *string                                                    `json:"URL,omitempty" xml:"URL,omitempty"`
}

func (s SearchMediaResponseBodyMediaListAttachedMedia) String() string {
	return tea.Prettify(s)
}

func (s SearchMediaResponseBodyMediaListAttachedMedia) GoString() string {
	return s.String()
}

func (s *SearchMediaResponseBodyMediaListAttachedMedia) SetAppId(v string) *SearchMediaResponseBodyMediaListAttachedMedia {
	s.AppId = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAttachedMedia) SetBusinessType(v string) *SearchMediaResponseBodyMediaListAttachedMedia {
	s.BusinessType = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAttachedMedia) SetCategories(v []*SearchMediaResponseBodyMediaListAttachedMediaCategories) *SearchMediaResponseBodyMediaListAttachedMedia {
	s.Categories = v
	return s
}

func (s *SearchMediaResponseBodyMediaListAttachedMedia) SetCreationTime(v string) *SearchMediaResponseBodyMediaListAttachedMedia {
	s.CreationTime = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAttachedMedia) SetDescription(v string) *SearchMediaResponseBodyMediaListAttachedMedia {
	s.Description = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAttachedMedia) SetMediaId(v string) *SearchMediaResponseBodyMediaListAttachedMedia {
	s.MediaId = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAttachedMedia) SetModificationTime(v string) *SearchMediaResponseBodyMediaListAttachedMedia {
	s.ModificationTime = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAttachedMedia) SetStatus(v string) *SearchMediaResponseBodyMediaListAttachedMedia {
	s.Status = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAttachedMedia) SetStorageLocation(v string) *SearchMediaResponseBodyMediaListAttachedMedia {
	s.StorageLocation = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAttachedMedia) SetTags(v string) *SearchMediaResponseBodyMediaListAttachedMedia {
	s.Tags = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAttachedMedia) SetTitle(v string) *SearchMediaResponseBodyMediaListAttachedMedia {
	s.Title = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAttachedMedia) SetURL(v string) *SearchMediaResponseBodyMediaListAttachedMedia {
	s.URL = &v
	return s
}

type SearchMediaResponseBodyMediaListAttachedMediaCategories struct {
	CateId   *int64  `json:"CateId,omitempty" xml:"CateId,omitempty"`
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	Level    *int64  `json:"Level,omitempty" xml:"Level,omitempty"`
	ParentId *int64  `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
}

func (s SearchMediaResponseBodyMediaListAttachedMediaCategories) String() string {
	return tea.Prettify(s)
}

func (s SearchMediaResponseBodyMediaListAttachedMediaCategories) GoString() string {
	return s.String()
}

func (s *SearchMediaResponseBodyMediaListAttachedMediaCategories) SetCateId(v int64) *SearchMediaResponseBodyMediaListAttachedMediaCategories {
	s.CateId = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAttachedMediaCategories) SetCateName(v string) *SearchMediaResponseBodyMediaListAttachedMediaCategories {
	s.CateName = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAttachedMediaCategories) SetLevel(v int64) *SearchMediaResponseBodyMediaListAttachedMediaCategories {
	s.Level = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAttachedMediaCategories) SetParentId(v int64) *SearchMediaResponseBodyMediaListAttachedMediaCategories {
	s.ParentId = &v
	return s
}

type SearchMediaResponseBodyMediaListAudio struct {
	// The number of entries to return on each page. Default value: **10**. Maximum value: **100**.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The time when the auxiliary media asset was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	AudioId *string `json:"AudioId,omitempty" xml:"AudioId,omitempty"`
	// The URL of the auxiliary media asset.
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The name of the category.
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	// The status of the auxiliary media asset. Valid values:
	//
	// *   **Uploading**: The auxiliary media asset is being uploaded. This is the initial status.
	// *   **Normal**: The auxiliary media asset is uploaded.
	// *   **UploadFail**: The auxiliary media asset fails to be uploaded.
	CoverURL *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	// The source. Valid values:
	//
	// *   **general**: The video file is uploaded by using ApsaraVideo VOD.
	// *   **short_video**: The video file is uploaded by using the short video SDK.
	// *   **editing**: The video file is produced after online editing.
	// *   **live**: The video stream is recorded and uploaded as a file.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The type of the auxiliary media asset. Valid values:
	//
	// *   **watermark**
	// *   **subtitle**
	// *   **material**
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the auxiliary media asset.
	DownloadSwitch *string `json:"DownloadSwitch,omitempty" xml:"DownloadSwitch,omitempty"`
	// The time when the image file was updated. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	Duration *float32 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// The number of the page to return. Default value: **1**.
	//
	// > If the value of this parameter exceeds **200**, we recommend that you set the ScrollToken parameter as well.
	MediaSource *string `json:"MediaSource,omitempty" xml:"MediaSource,omitempty"`
	// The pagination identifier.
	ModificationTime *string `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	// The total number of data records that meet the specified filter criteria.
	PreprocessStatus  *string `json:"PreprocessStatus,omitempty" xml:"PreprocessStatus,omitempty"`
	RestoreExpiration *string `json:"RestoreExpiration,omitempty" xml:"RestoreExpiration,omitempty"`
	RestoreStatus     *string `json:"RestoreStatus,omitempty" xml:"RestoreStatus,omitempty"`
	// The title of the video file.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The ID of the video file.
	Snapshots []*string `json:"Snapshots,omitempty" xml:"Snapshots,omitempty" type:"Repeated"`
	// The status of the image file.
	//
	// *   **Uploading**: The image file is being uploaded. This is the initial status.
	// *   **Normal**: The image file is uploaded.
	// *   **UploadFail**: The image file fails to be uploaded.
	SpriteSnapshots []*string `json:"SpriteSnapshots,omitempty" xml:"SpriteSnapshots,omitempty" type:"Repeated"`
	// The size of the audio file.
	Status       *string `json:"Status,omitempty" xml:"Status,omitempty"`
	StorageClass *string `json:"StorageClass,omitempty" xml:"StorageClass,omitempty"`
	// The duration of the audio file.
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	// The tags of the video file.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The transcoding mode. Default value: FastTranscode. Valid values:
	//
	// *   **FastTranscode**: The audio file is immediately transcoded after it is uploaded. You cannot play the file before it is transcoded.
	// *   **NoTranscode**: The audio file can be played without being transcoded. You can immediately play the file after it is uploaded.
	// *   **AsyncTranscode**: The audio file can be immediately played and asynchronously transcoded after it is uploaded.
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The time when the audio file was updated. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	TranscodeMode *string `json:"TranscodeMode,omitempty" xml:"TranscodeMode,omitempty"`
}

func (s SearchMediaResponseBodyMediaListAudio) String() string {
	return tea.Prettify(s)
}

func (s SearchMediaResponseBodyMediaListAudio) GoString() string {
	return s.String()
}

func (s *SearchMediaResponseBodyMediaListAudio) SetAppId(v string) *SearchMediaResponseBodyMediaListAudio {
	s.AppId = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetAudioId(v string) *SearchMediaResponseBodyMediaListAudio {
	s.AudioId = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetCateId(v int64) *SearchMediaResponseBodyMediaListAudio {
	s.CateId = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetCateName(v string) *SearchMediaResponseBodyMediaListAudio {
	s.CateName = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetCoverURL(v string) *SearchMediaResponseBodyMediaListAudio {
	s.CoverURL = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetCreationTime(v string) *SearchMediaResponseBodyMediaListAudio {
	s.CreationTime = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetDescription(v string) *SearchMediaResponseBodyMediaListAudio {
	s.Description = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetDownloadSwitch(v string) *SearchMediaResponseBodyMediaListAudio {
	s.DownloadSwitch = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetDuration(v float32) *SearchMediaResponseBodyMediaListAudio {
	s.Duration = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetMediaSource(v string) *SearchMediaResponseBodyMediaListAudio {
	s.MediaSource = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetModificationTime(v string) *SearchMediaResponseBodyMediaListAudio {
	s.ModificationTime = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetPreprocessStatus(v string) *SearchMediaResponseBodyMediaListAudio {
	s.PreprocessStatus = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetRestoreExpiration(v string) *SearchMediaResponseBodyMediaListAudio {
	s.RestoreExpiration = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetRestoreStatus(v string) *SearchMediaResponseBodyMediaListAudio {
	s.RestoreStatus = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetSize(v int64) *SearchMediaResponseBodyMediaListAudio {
	s.Size = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetSnapshots(v []*string) *SearchMediaResponseBodyMediaListAudio {
	s.Snapshots = v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetSpriteSnapshots(v []*string) *SearchMediaResponseBodyMediaListAudio {
	s.SpriteSnapshots = v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetStatus(v string) *SearchMediaResponseBodyMediaListAudio {
	s.Status = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetStorageClass(v string) *SearchMediaResponseBodyMediaListAudio {
	s.StorageClass = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetStorageLocation(v string) *SearchMediaResponseBodyMediaListAudio {
	s.StorageLocation = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetTags(v string) *SearchMediaResponseBodyMediaListAudio {
	s.Tags = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetTitle(v string) *SearchMediaResponseBodyMediaListAudio {
	s.Title = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListAudio) SetTranscodeMode(v string) *SearchMediaResponseBodyMediaListAudio {
	s.TranscodeMode = &v
	return s
}

type SearchMediaResponseBodyMediaListImage struct {
	// The ID of the audio file.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The duration of the video file. Unit: seconds.
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The tags of the auxiliary media asset.
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	// [Details about auxiliary media assets](~~86991~~).
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The ID of the application.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The endpoint of the OSS bucket in which the audio file is stored.
	ImageId *string `json:"ImageId,omitempty" xml:"ImageId,omitempty"`
	// The URL of the thumbnail.
	ModificationTime *string `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	// The type of the media asset. Valid values:
	//
	// *   **video**
	// *   **audio**
	// *   **image**
	// *   **attached**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the application.
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	// The list of automatic snapshots.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The ID of the request.
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The URL of the thumbnail.
	URL *string `json:"URL,omitempty" xml:"URL,omitempty"`
}

func (s SearchMediaResponseBodyMediaListImage) String() string {
	return tea.Prettify(s)
}

func (s SearchMediaResponseBodyMediaListImage) GoString() string {
	return s.String()
}

func (s *SearchMediaResponseBodyMediaListImage) SetAppId(v string) *SearchMediaResponseBodyMediaListImage {
	s.AppId = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListImage) SetCateId(v int64) *SearchMediaResponseBodyMediaListImage {
	s.CateId = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListImage) SetCateName(v string) *SearchMediaResponseBodyMediaListImage {
	s.CateName = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListImage) SetCreationTime(v string) *SearchMediaResponseBodyMediaListImage {
	s.CreationTime = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListImage) SetDescription(v string) *SearchMediaResponseBodyMediaListImage {
	s.Description = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListImage) SetImageId(v string) *SearchMediaResponseBodyMediaListImage {
	s.ImageId = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListImage) SetModificationTime(v string) *SearchMediaResponseBodyMediaListImage {
	s.ModificationTime = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListImage) SetStatus(v string) *SearchMediaResponseBodyMediaListImage {
	s.Status = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListImage) SetStorageLocation(v string) *SearchMediaResponseBodyMediaListImage {
	s.StorageLocation = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListImage) SetTags(v string) *SearchMediaResponseBodyMediaListImage {
	s.Tags = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListImage) SetTitle(v string) *SearchMediaResponseBodyMediaListImage {
	s.Title = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListImage) SetURL(v string) *SearchMediaResponseBodyMediaListImage {
	s.URL = &v
	return s
}

type SearchMediaResponseBodyMediaListVideo struct {
	// The download switch. The audio file can be downloaded offline only when the download switch is turned on. Valid values:
	//
	// *   **on**
	// *   **off**
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The status of the video file. Valid values:
	//
	// *   **Uploading**
	// *   **UploadFail**
	// *   **UploadSucc**
	// *   **Transcoding**
	// *   **TranscodeFail**
	// *   **Blocked**
	// *   **Normal**
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// The name of the category.
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
	// The filter condition. For more information about the syntax, see [Protocol for media asset search](~~86991~~).
	CoverURL *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	// The category ID of the auxiliary media asset.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The endpoint of the OSS bucket in which the image file is stored.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the application.
	DownloadSwitch *string `json:"DownloadSwitch,omitempty" xml:"DownloadSwitch,omitempty"`
	// The description of the auxiliary media asset.
	Duration *float32 `json:"Duration,omitempty" xml:"Duration,omitempty"`
	// [Details about video files](~~86991~~).
	MediaSource *string `json:"MediaSource,omitempty" xml:"MediaSource,omitempty"`
	// The description of the audio file.
	ModificationTime *string `json:"ModificationTime,omitempty" xml:"ModificationTime,omitempty"`
	// The URL of the image file.
	PreprocessStatus  *string `json:"PreprocessStatus,omitempty" xml:"PreprocessStatus,omitempty"`
	RestoreExpiration *string `json:"RestoreExpiration,omitempty" xml:"RestoreExpiration,omitempty"`
	RestoreStatus     *string `json:"RestoreStatus,omitempty" xml:"RestoreStatus,omitempty"`
	// The time when the image file was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	Size *int64 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The endpoint of the OSS bucket in which the auxiliary media asset is stored.
	Snapshots []*string `json:"Snapshots,omitempty" xml:"Snapshots,omitempty" type:"Repeated"`
	// The list of automatic snapshots.
	SpriteSnapshots []*string `json:"SpriteSnapshots,omitempty" xml:"SpriteSnapshots,omitempty" type:"Repeated"`
	// The ID of the application.
	Status       *string `json:"Status,omitempty" xml:"Status,omitempty"`
	StorageClass *string `json:"StorageClass,omitempty" xml:"StorageClass,omitempty"`
	// The time when the audio file was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	// The title of the image file.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The title of the audio file.
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The category ID of the audio file.
	TranscodeMode *string `json:"TranscodeMode,omitempty" xml:"TranscodeMode,omitempty"`
	// The time when the video file was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s SearchMediaResponseBodyMediaListVideo) String() string {
	return tea.Prettify(s)
}

func (s SearchMediaResponseBodyMediaListVideo) GoString() string {
	return s.String()
}

func (s *SearchMediaResponseBodyMediaListVideo) SetAppId(v string) *SearchMediaResponseBodyMediaListVideo {
	s.AppId = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetCateId(v int64) *SearchMediaResponseBodyMediaListVideo {
	s.CateId = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetCateName(v string) *SearchMediaResponseBodyMediaListVideo {
	s.CateName = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetCoverURL(v string) *SearchMediaResponseBodyMediaListVideo {
	s.CoverURL = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetCreationTime(v string) *SearchMediaResponseBodyMediaListVideo {
	s.CreationTime = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetDescription(v string) *SearchMediaResponseBodyMediaListVideo {
	s.Description = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetDownloadSwitch(v string) *SearchMediaResponseBodyMediaListVideo {
	s.DownloadSwitch = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetDuration(v float32) *SearchMediaResponseBodyMediaListVideo {
	s.Duration = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetMediaSource(v string) *SearchMediaResponseBodyMediaListVideo {
	s.MediaSource = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetModificationTime(v string) *SearchMediaResponseBodyMediaListVideo {
	s.ModificationTime = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetPreprocessStatus(v string) *SearchMediaResponseBodyMediaListVideo {
	s.PreprocessStatus = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetRestoreExpiration(v string) *SearchMediaResponseBodyMediaListVideo {
	s.RestoreExpiration = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetRestoreStatus(v string) *SearchMediaResponseBodyMediaListVideo {
	s.RestoreStatus = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetSize(v int64) *SearchMediaResponseBodyMediaListVideo {
	s.Size = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetSnapshots(v []*string) *SearchMediaResponseBodyMediaListVideo {
	s.Snapshots = v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetSpriteSnapshots(v []*string) *SearchMediaResponseBodyMediaListVideo {
	s.SpriteSnapshots = v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetStatus(v string) *SearchMediaResponseBodyMediaListVideo {
	s.Status = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetStorageClass(v string) *SearchMediaResponseBodyMediaListVideo {
	s.StorageClass = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetStorageLocation(v string) *SearchMediaResponseBodyMediaListVideo {
	s.StorageLocation = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetTags(v string) *SearchMediaResponseBodyMediaListVideo {
	s.Tags = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetTitle(v string) *SearchMediaResponseBodyMediaListVideo {
	s.Title = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetTranscodeMode(v string) *SearchMediaResponseBodyMediaListVideo {
	s.TranscodeMode = &v
	return s
}

func (s *SearchMediaResponseBodyMediaListVideo) SetVideoId(v string) *SearchMediaResponseBodyMediaListVideo {
	s.VideoId = &v
	return s
}

type SearchMediaResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SearchMediaResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SearchMediaResponse) String() string {
	return tea.Prettify(s)
}

func (s SearchMediaResponse) GoString() string {
	return s.String()
}

func (s *SearchMediaResponse) SetHeaders(v map[string]*string) *SearchMediaResponse {
	s.Headers = v
	return s
}

func (s *SearchMediaResponse) SetStatusCode(v int32) *SearchMediaResponse {
	s.StatusCode = &v
	return s
}

func (s *SearchMediaResponse) SetBody(v *SearchMediaResponseBody) *SearchMediaResponse {
	s.Body = v
	return s
}

type SetAuditSecurityIpRequest struct {
	// Manages the IP addresses in review security groups.
	Ips         *string `json:"Ips,omitempty" xml:"Ips,omitempty"`
	OperateMode *string `json:"OperateMode,omitempty" xml:"OperateMode,omitempty"`
	// The IP addresses to be added to a review security group. You can add a maximum of 100 IP addresses to each review security group. Separate multiple IP addresses with commas (,). You can enter individual IP addresses or a CIDR block.
	//
	// *   Individual IP address: for example, 10.23.12.24
	// *   CIDR block: for example, 10.23.12.24/24, where /24 indicates that the prefix of the CIDR block is 24 bits in length. You can replace 24 with a value that ranges from `1 to 32`.
	SecurityGroupName *string `json:"SecurityGroupName,omitempty" xml:"SecurityGroupName,omitempty"`
}

func (s SetAuditSecurityIpRequest) String() string {
	return tea.Prettify(s)
}

func (s SetAuditSecurityIpRequest) GoString() string {
	return s.String()
}

func (s *SetAuditSecurityIpRequest) SetIps(v string) *SetAuditSecurityIpRequest {
	s.Ips = &v
	return s
}

func (s *SetAuditSecurityIpRequest) SetOperateMode(v string) *SetAuditSecurityIpRequest {
	s.OperateMode = &v
	return s
}

func (s *SetAuditSecurityIpRequest) SetSecurityGroupName(v string) *SetAuditSecurityIpRequest {
	s.SecurityGroupName = &v
	return s
}

type SetAuditSecurityIpResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetAuditSecurityIpResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetAuditSecurityIpResponseBody) GoString() string {
	return s.String()
}

func (s *SetAuditSecurityIpResponseBody) SetRequestId(v string) *SetAuditSecurityIpResponseBody {
	s.RequestId = &v
	return s
}

type SetAuditSecurityIpResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetAuditSecurityIpResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetAuditSecurityIpResponse) String() string {
	return tea.Prettify(s)
}

func (s SetAuditSecurityIpResponse) GoString() string {
	return s.String()
}

func (s *SetAuditSecurityIpResponse) SetHeaders(v map[string]*string) *SetAuditSecurityIpResponse {
	s.Headers = v
	return s
}

func (s *SetAuditSecurityIpResponse) SetStatusCode(v int32) *SetAuditSecurityIpResponse {
	s.StatusCode = &v
	return s
}

func (s *SetAuditSecurityIpResponse) SetBody(v *SetAuditSecurityIpResponseBody) *SetAuditSecurityIpResponse {
	s.Body = v
	return s
}

type SetCrossdomainContentRequest struct {
	// The URL of the Object Storage Service (OSS) bucket.
	Content              *string `json:"Content,omitempty" xml:"Content,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	ResourceRealOwnerId  *string `json:"ResourceRealOwnerId,omitempty" xml:"ResourceRealOwnerId,omitempty"`
	// Updates the cross-domain policy file crossdomain.xml.
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
}

func (s SetCrossdomainContentRequest) String() string {
	return tea.Prettify(s)
}

func (s SetCrossdomainContentRequest) GoString() string {
	return s.String()
}

func (s *SetCrossdomainContentRequest) SetContent(v string) *SetCrossdomainContentRequest {
	s.Content = &v
	return s
}

func (s *SetCrossdomainContentRequest) SetOwnerAccount(v string) *SetCrossdomainContentRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SetCrossdomainContentRequest) SetOwnerId(v string) *SetCrossdomainContentRequest {
	s.OwnerId = &v
	return s
}

func (s *SetCrossdomainContentRequest) SetResourceOwnerAccount(v string) *SetCrossdomainContentRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SetCrossdomainContentRequest) SetResourceOwnerId(v string) *SetCrossdomainContentRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *SetCrossdomainContentRequest) SetResourceRealOwnerId(v string) *SetCrossdomainContentRequest {
	s.ResourceRealOwnerId = &v
	return s
}

func (s *SetCrossdomainContentRequest) SetStorageLocation(v string) *SetCrossdomainContentRequest {
	s.StorageLocation = &v
	return s
}

type SetCrossdomainContentResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetCrossdomainContentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetCrossdomainContentResponseBody) GoString() string {
	return s.String()
}

func (s *SetCrossdomainContentResponseBody) SetRequestId(v string) *SetCrossdomainContentResponseBody {
	s.RequestId = &v
	return s
}

type SetCrossdomainContentResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetCrossdomainContentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetCrossdomainContentResponse) String() string {
	return tea.Prettify(s)
}

func (s SetCrossdomainContentResponse) GoString() string {
	return s.String()
}

func (s *SetCrossdomainContentResponse) SetHeaders(v map[string]*string) *SetCrossdomainContentResponse {
	s.Headers = v
	return s
}

func (s *SetCrossdomainContentResponse) SetStatusCode(v int32) *SetCrossdomainContentResponse {
	s.StatusCode = &v
	return s
}

func (s *SetCrossdomainContentResponse) SetBody(v *SetCrossdomainContentResponseBody) *SetCrossdomainContentResponse {
	s.Body = v
	return s
}

type SetDefaultAITemplateRequest struct {
	// Specifies an AI template as the default template.
	TemplateId *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
}

func (s SetDefaultAITemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s SetDefaultAITemplateRequest) GoString() string {
	return s.String()
}

func (s *SetDefaultAITemplateRequest) SetTemplateId(v string) *SetDefaultAITemplateRequest {
	s.TemplateId = &v
	return s
}

type SetDefaultAITemplateResponseBody struct {
	RequestId  *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TemplateId *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
}

func (s SetDefaultAITemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetDefaultAITemplateResponseBody) GoString() string {
	return s.String()
}

func (s *SetDefaultAITemplateResponseBody) SetRequestId(v string) *SetDefaultAITemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *SetDefaultAITemplateResponseBody) SetTemplateId(v string) *SetDefaultAITemplateResponseBody {
	s.TemplateId = &v
	return s
}

type SetDefaultAITemplateResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetDefaultAITemplateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetDefaultAITemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s SetDefaultAITemplateResponse) GoString() string {
	return s.String()
}

func (s *SetDefaultAITemplateResponse) SetHeaders(v map[string]*string) *SetDefaultAITemplateResponse {
	s.Headers = v
	return s
}

func (s *SetDefaultAITemplateResponse) SetStatusCode(v int32) *SetDefaultAITemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *SetDefaultAITemplateResponse) SetBody(v *SetDefaultAITemplateResponseBody) *SetDefaultAITemplateResponse {
	s.Body = v
	return s
}

type SetDefaultTranscodeTemplateGroupRequest struct {
	TranscodeTemplateGroupId *string `json:"TranscodeTemplateGroupId,omitempty" xml:"TranscodeTemplateGroupId,omitempty"`
}

func (s SetDefaultTranscodeTemplateGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s SetDefaultTranscodeTemplateGroupRequest) GoString() string {
	return s.String()
}

func (s *SetDefaultTranscodeTemplateGroupRequest) SetTranscodeTemplateGroupId(v string) *SetDefaultTranscodeTemplateGroupRequest {
	s.TranscodeTemplateGroupId = &v
	return s
}

type SetDefaultTranscodeTemplateGroupResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetDefaultTranscodeTemplateGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetDefaultTranscodeTemplateGroupResponseBody) GoString() string {
	return s.String()
}

func (s *SetDefaultTranscodeTemplateGroupResponseBody) SetRequestId(v string) *SetDefaultTranscodeTemplateGroupResponseBody {
	s.RequestId = &v
	return s
}

type SetDefaultTranscodeTemplateGroupResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetDefaultTranscodeTemplateGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetDefaultTranscodeTemplateGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s SetDefaultTranscodeTemplateGroupResponse) GoString() string {
	return s.String()
}

func (s *SetDefaultTranscodeTemplateGroupResponse) SetHeaders(v map[string]*string) *SetDefaultTranscodeTemplateGroupResponse {
	s.Headers = v
	return s
}

func (s *SetDefaultTranscodeTemplateGroupResponse) SetStatusCode(v int32) *SetDefaultTranscodeTemplateGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *SetDefaultTranscodeTemplateGroupResponse) SetBody(v *SetDefaultTranscodeTemplateGroupResponseBody) *SetDefaultTranscodeTemplateGroupResponse {
	s.Body = v
	return s
}

type SetDefaultWatermarkRequest struct {
	WatermarkId *string `json:"WatermarkId,omitempty" xml:"WatermarkId,omitempty"`
}

func (s SetDefaultWatermarkRequest) String() string {
	return tea.Prettify(s)
}

func (s SetDefaultWatermarkRequest) GoString() string {
	return s.String()
}

func (s *SetDefaultWatermarkRequest) SetWatermarkId(v string) *SetDefaultWatermarkRequest {
	s.WatermarkId = &v
	return s
}

type SetDefaultWatermarkResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetDefaultWatermarkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetDefaultWatermarkResponseBody) GoString() string {
	return s.String()
}

func (s *SetDefaultWatermarkResponseBody) SetRequestId(v string) *SetDefaultWatermarkResponseBody {
	s.RequestId = &v
	return s
}

type SetDefaultWatermarkResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetDefaultWatermarkResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetDefaultWatermarkResponse) String() string {
	return tea.Prettify(s)
}

func (s SetDefaultWatermarkResponse) GoString() string {
	return s.String()
}

func (s *SetDefaultWatermarkResponse) SetHeaders(v map[string]*string) *SetDefaultWatermarkResponse {
	s.Headers = v
	return s
}

func (s *SetDefaultWatermarkResponse) SetStatusCode(v int32) *SetDefaultWatermarkResponse {
	s.StatusCode = &v
	return s
}

func (s *SetDefaultWatermarkResponse) SetBody(v *SetDefaultWatermarkResponseBody) *SetDefaultWatermarkResponse {
	s.Body = v
	return s
}

type SetEditingProjectMaterialsRequest struct {
	MaterialIds  *string `json:"MaterialIds,omitempty" xml:"MaterialIds,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// Sets materials to be edited for an online editing project.
	ProjectId            *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s SetEditingProjectMaterialsRequest) String() string {
	return tea.Prettify(s)
}

func (s SetEditingProjectMaterialsRequest) GoString() string {
	return s.String()
}

func (s *SetEditingProjectMaterialsRequest) SetMaterialIds(v string) *SetEditingProjectMaterialsRequest {
	s.MaterialIds = &v
	return s
}

func (s *SetEditingProjectMaterialsRequest) SetOwnerAccount(v string) *SetEditingProjectMaterialsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SetEditingProjectMaterialsRequest) SetOwnerId(v string) *SetEditingProjectMaterialsRequest {
	s.OwnerId = &v
	return s
}

func (s *SetEditingProjectMaterialsRequest) SetProjectId(v string) *SetEditingProjectMaterialsRequest {
	s.ProjectId = &v
	return s
}

func (s *SetEditingProjectMaterialsRequest) SetResourceOwnerAccount(v string) *SetEditingProjectMaterialsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SetEditingProjectMaterialsRequest) SetResourceOwnerId(v string) *SetEditingProjectMaterialsRequest {
	s.ResourceOwnerId = &v
	return s
}

type SetEditingProjectMaterialsResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetEditingProjectMaterialsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetEditingProjectMaterialsResponseBody) GoString() string {
	return s.String()
}

func (s *SetEditingProjectMaterialsResponseBody) SetRequestId(v string) *SetEditingProjectMaterialsResponseBody {
	s.RequestId = &v
	return s
}

type SetEditingProjectMaterialsResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetEditingProjectMaterialsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetEditingProjectMaterialsResponse) String() string {
	return tea.Prettify(s)
}

func (s SetEditingProjectMaterialsResponse) GoString() string {
	return s.String()
}

func (s *SetEditingProjectMaterialsResponse) SetHeaders(v map[string]*string) *SetEditingProjectMaterialsResponse {
	s.Headers = v
	return s
}

func (s *SetEditingProjectMaterialsResponse) SetStatusCode(v int32) *SetEditingProjectMaterialsResponse {
	s.StatusCode = &v
	return s
}

func (s *SetEditingProjectMaterialsResponse) SetBody(v *SetEditingProjectMaterialsResponseBody) *SetEditingProjectMaterialsResponse {
	s.Body = v
	return s
}

type SetMessageCallbackRequest struct {
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The operation that you want to perform. Set the value to **SetMessageCallback**.
	AuthKey *string `json:"AuthKey,omitempty" xml:"AuthKey,omitempty"`
	// The ID of the request.
	AuthSwitch *string `json:"AuthSwitch,omitempty" xml:"AuthSwitch,omitempty"`
	// The type of the callback event. If you do not set this parameter, notifications for all types of events are disabled. If you set this parameter to ALL, notifications for all types of events are enabled. You can specify the event types for which notifications are enabled. Separate multiple event types with commas (,). For more information about the valid values of this parameter, see [Event type](~~55627~~).
	CallbackType *string `json:"CallbackType,omitempty" xml:"CallbackType,omitempty"`
	// The name of the MNS queue. This parameter only takes effect when the CallbackType parameter is set to MNS.
	CallbackURL *string `json:"CallbackURL,omitempty" xml:"CallbackURL,omitempty"`
	// Specifies whether to enable callback authentication. This parameter only takes effect when the CallbackType parameter is set to HTTP. Valid values:
	//
	// *   **on**: enables authentication.
	// *   **off**: disables authentication.
	EventTypeList *string `json:"EventTypeList,omitempty" xml:"EventTypeList,omitempty"`
	// The cryptographic key. This parameter only takes effect when the CallbackType parameter is set to HTTP. The key can be up to 32 characters in length and must contain uppercase letters, lowercase letters, and digits.
	MnsEndpoint *string `json:"MnsEndpoint,omitempty" xml:"MnsEndpoint,omitempty"`
	// Sets the callback method, callback URL, and event type of an event notification.
	MnsQueueName *string `json:"MnsQueueName,omitempty" xml:"MnsQueueName,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
}

func (s SetMessageCallbackRequest) String() string {
	return tea.Prettify(s)
}

func (s SetMessageCallbackRequest) GoString() string {
	return s.String()
}

func (s *SetMessageCallbackRequest) SetAppId(v string) *SetMessageCallbackRequest {
	s.AppId = &v
	return s
}

func (s *SetMessageCallbackRequest) SetAuthKey(v string) *SetMessageCallbackRequest {
	s.AuthKey = &v
	return s
}

func (s *SetMessageCallbackRequest) SetAuthSwitch(v string) *SetMessageCallbackRequest {
	s.AuthSwitch = &v
	return s
}

func (s *SetMessageCallbackRequest) SetCallbackType(v string) *SetMessageCallbackRequest {
	s.CallbackType = &v
	return s
}

func (s *SetMessageCallbackRequest) SetCallbackURL(v string) *SetMessageCallbackRequest {
	s.CallbackURL = &v
	return s
}

func (s *SetMessageCallbackRequest) SetEventTypeList(v string) *SetMessageCallbackRequest {
	s.EventTypeList = &v
	return s
}

func (s *SetMessageCallbackRequest) SetMnsEndpoint(v string) *SetMessageCallbackRequest {
	s.MnsEndpoint = &v
	return s
}

func (s *SetMessageCallbackRequest) SetMnsQueueName(v string) *SetMessageCallbackRequest {
	s.MnsQueueName = &v
	return s
}

func (s *SetMessageCallbackRequest) SetOwnerAccount(v string) *SetMessageCallbackRequest {
	s.OwnerAccount = &v
	return s
}

type SetMessageCallbackResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetMessageCallbackResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetMessageCallbackResponseBody) GoString() string {
	return s.String()
}

func (s *SetMessageCallbackResponseBody) SetRequestId(v string) *SetMessageCallbackResponseBody {
	s.RequestId = &v
	return s
}

type SetMessageCallbackResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetMessageCallbackResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetMessageCallbackResponse) String() string {
	return tea.Prettify(s)
}

func (s SetMessageCallbackResponse) GoString() string {
	return s.String()
}

func (s *SetMessageCallbackResponse) SetHeaders(v map[string]*string) *SetMessageCallbackResponse {
	s.Headers = v
	return s
}

func (s *SetMessageCallbackResponse) SetStatusCode(v int32) *SetMessageCallbackResponse {
	s.StatusCode = &v
	return s
}

func (s *SetMessageCallbackResponse) SetBody(v *SetMessageCallbackResponseBody) *SetMessageCallbackResponse {
	s.Body = v
	return s
}

type SetVodDomainCertificateRequest struct {
	// The name of the certificate.
	CertName *string `json:"CertName,omitempty" xml:"CertName,omitempty"`
	// The domain name that is secured by the certificate. The domain name must use HTTPS acceleration.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId    *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The private key. This parameter is required only if you enable the SSL certificate.
	SSLPri *string `json:"SSLPri,omitempty" xml:"SSLPri,omitempty"`
	// Specifies whether to enable the SSL certificate. Default value: off. Valid values:
	//
	// *   **on**
	// *   **off**
	SSLProtocol *string `json:"SSLProtocol,omitempty" xml:"SSLProtocol,omitempty"`
	// The content of the certificate. This parameter is required only if you enable the SSL certificate.
	SSLPub        *string `json:"SSLPub,omitempty" xml:"SSLPub,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
}

func (s SetVodDomainCertificateRequest) String() string {
	return tea.Prettify(s)
}

func (s SetVodDomainCertificateRequest) GoString() string {
	return s.String()
}

func (s *SetVodDomainCertificateRequest) SetCertName(v string) *SetVodDomainCertificateRequest {
	s.CertName = &v
	return s
}

func (s *SetVodDomainCertificateRequest) SetDomainName(v string) *SetVodDomainCertificateRequest {
	s.DomainName = &v
	return s
}

func (s *SetVodDomainCertificateRequest) SetOwnerId(v int64) *SetVodDomainCertificateRequest {
	s.OwnerId = &v
	return s
}

func (s *SetVodDomainCertificateRequest) SetSSLPri(v string) *SetVodDomainCertificateRequest {
	s.SSLPri = &v
	return s
}

func (s *SetVodDomainCertificateRequest) SetSSLProtocol(v string) *SetVodDomainCertificateRequest {
	s.SSLProtocol = &v
	return s
}

func (s *SetVodDomainCertificateRequest) SetSSLPub(v string) *SetVodDomainCertificateRequest {
	s.SSLPub = &v
	return s
}

func (s *SetVodDomainCertificateRequest) SetSecurityToken(v string) *SetVodDomainCertificateRequest {
	s.SecurityToken = &v
	return s
}

type SetVodDomainCertificateResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetVodDomainCertificateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetVodDomainCertificateResponseBody) GoString() string {
	return s.String()
}

func (s *SetVodDomainCertificateResponseBody) SetRequestId(v string) *SetVodDomainCertificateResponseBody {
	s.RequestId = &v
	return s
}

type SetVodDomainCertificateResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetVodDomainCertificateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetVodDomainCertificateResponse) String() string {
	return tea.Prettify(s)
}

func (s SetVodDomainCertificateResponse) GoString() string {
	return s.String()
}

func (s *SetVodDomainCertificateResponse) SetHeaders(v map[string]*string) *SetVodDomainCertificateResponse {
	s.Headers = v
	return s
}

func (s *SetVodDomainCertificateResponse) SetStatusCode(v int32) *SetVodDomainCertificateResponse {
	s.StatusCode = &v
	return s
}

func (s *SetVodDomainCertificateResponse) SetBody(v *SetVodDomainCertificateResponseBody) *SetVodDomainCertificateResponse {
	s.Body = v
	return s
}

type SubmitAIImageAuditJobRequest struct {
	MediaAuditConfiguration *string `json:"MediaAuditConfiguration,omitempty" xml:"MediaAuditConfiguration,omitempty"`
	// Submits an automated review task for an image. After the task is submitted, the task is processed in an asynchronous manner. The operation may return a response before the task is complete.
	MediaId              *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	TemplateId           *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
}

func (s SubmitAIImageAuditJobRequest) String() string {
	return tea.Prettify(s)
}

func (s SubmitAIImageAuditJobRequest) GoString() string {
	return s.String()
}

func (s *SubmitAIImageAuditJobRequest) SetMediaAuditConfiguration(v string) *SubmitAIImageAuditJobRequest {
	s.MediaAuditConfiguration = &v
	return s
}

func (s *SubmitAIImageAuditJobRequest) SetMediaId(v string) *SubmitAIImageAuditJobRequest {
	s.MediaId = &v
	return s
}

func (s *SubmitAIImageAuditJobRequest) SetOwnerAccount(v string) *SubmitAIImageAuditJobRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SubmitAIImageAuditJobRequest) SetOwnerId(v string) *SubmitAIImageAuditJobRequest {
	s.OwnerId = &v
	return s
}

func (s *SubmitAIImageAuditJobRequest) SetResourceOwnerAccount(v string) *SubmitAIImageAuditJobRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SubmitAIImageAuditJobRequest) SetResourceOwnerId(v string) *SubmitAIImageAuditJobRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *SubmitAIImageAuditJobRequest) SetTemplateId(v string) *SubmitAIImageAuditJobRequest {
	s.TemplateId = &v
	return s
}

type SubmitAIImageAuditJobResponseBody struct {
	JobId     *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SubmitAIImageAuditJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SubmitAIImageAuditJobResponseBody) GoString() string {
	return s.String()
}

func (s *SubmitAIImageAuditJobResponseBody) SetJobId(v string) *SubmitAIImageAuditJobResponseBody {
	s.JobId = &v
	return s
}

func (s *SubmitAIImageAuditJobResponseBody) SetRequestId(v string) *SubmitAIImageAuditJobResponseBody {
	s.RequestId = &v
	return s
}

type SubmitAIImageAuditJobResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SubmitAIImageAuditJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SubmitAIImageAuditJobResponse) String() string {
	return tea.Prettify(s)
}

func (s SubmitAIImageAuditJobResponse) GoString() string {
	return s.String()
}

func (s *SubmitAIImageAuditJobResponse) SetHeaders(v map[string]*string) *SubmitAIImageAuditJobResponse {
	s.Headers = v
	return s
}

func (s *SubmitAIImageAuditJobResponse) SetStatusCode(v int32) *SubmitAIImageAuditJobResponse {
	s.StatusCode = &v
	return s
}

func (s *SubmitAIImageAuditJobResponse) SetBody(v *SubmitAIImageAuditJobResponseBody) *SubmitAIImageAuditJobResponse {
	s.Body = v
	return s
}

type SubmitAIImageJobRequest struct {
	// The ID of the request.
	AIPipelineId *string `json:"AIPipelineId,omitempty" xml:"AIPipelineId,omitempty"`
	// The user data.
	//
	// *   The value must be a JSON string.
	// *   You must specify the MessageCallback or Extend parameter.
	// *   The value can contain a maximum of 512 bytes.
	//
	// For more information, see the "UserData: specifies the custom configurations for media upload" section of the [Request parameters](~~86952~~) topic.
	AITemplateId         *string `json:"AITemplateId,omitempty" xml:"AITemplateId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the pipeline that is used for the AI processing job.
	//
	// <props="china">> This parameter is optional if you have specified a default pipeline ID. If you need to submit image AI processing jobs in a batch to a specific pipeline, [submit a ticket](https://smartservice.console.aliyun.com/service/create-ticket?product=vod) to contact Alibaba Cloud technical support.</props>
	// <props="intl">> This parameter is optional if you have specified a default pipeline ID. If you need to submit image AI processing jobs in a batch to a specific pipeline, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12672711.top-nav.ditem-sub.3cd51fa3WvRsjz#/ticket/add/?productId=1270) to contact Alibaba Cloud technical support.</props>
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
	// The ID of the AI template. You can use one of the following methods to obtain the ID:
	//
	// *   Obtain the value of TemplateId from the response to the [AddAITemplate](~~102930~~) that you call to create the template.
	// *   Obtain the value of TemplateId from the response to the [ListAITemplate](~~102936~~) operation after you create the template.
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s SubmitAIImageJobRequest) String() string {
	return tea.Prettify(s)
}

func (s SubmitAIImageJobRequest) GoString() string {
	return s.String()
}

func (s *SubmitAIImageJobRequest) SetAIPipelineId(v string) *SubmitAIImageJobRequest {
	s.AIPipelineId = &v
	return s
}

func (s *SubmitAIImageJobRequest) SetAITemplateId(v string) *SubmitAIImageJobRequest {
	s.AITemplateId = &v
	return s
}

func (s *SubmitAIImageJobRequest) SetOwnerAccount(v string) *SubmitAIImageJobRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SubmitAIImageJobRequest) SetOwnerId(v string) *SubmitAIImageJobRequest {
	s.OwnerId = &v
	return s
}

func (s *SubmitAIImageJobRequest) SetResourceOwnerAccount(v string) *SubmitAIImageJobRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SubmitAIImageJobRequest) SetResourceOwnerId(v string) *SubmitAIImageJobRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *SubmitAIImageJobRequest) SetUserData(v string) *SubmitAIImageJobRequest {
	s.UserData = &v
	return s
}

func (s *SubmitAIImageJobRequest) SetVideoId(v string) *SubmitAIImageJobRequest {
	s.VideoId = &v
	return s
}

type SubmitAIImageJobResponseBody struct {
	JobId     *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SubmitAIImageJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SubmitAIImageJobResponseBody) GoString() string {
	return s.String()
}

func (s *SubmitAIImageJobResponseBody) SetJobId(v string) *SubmitAIImageJobResponseBody {
	s.JobId = &v
	return s
}

func (s *SubmitAIImageJobResponseBody) SetRequestId(v string) *SubmitAIImageJobResponseBody {
	s.RequestId = &v
	return s
}

type SubmitAIImageJobResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SubmitAIImageJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SubmitAIImageJobResponse) String() string {
	return tea.Prettify(s)
}

func (s SubmitAIImageJobResponse) GoString() string {
	return s.String()
}

func (s *SubmitAIImageJobResponse) SetHeaders(v map[string]*string) *SubmitAIImageJobResponse {
	s.Headers = v
	return s
}

func (s *SubmitAIImageJobResponse) SetStatusCode(v int32) *SubmitAIImageJobResponse {
	s.StatusCode = &v
	return s
}

func (s *SubmitAIImageJobResponse) SetBody(v *SubmitAIImageJobResponseBody) *SubmitAIImageJobResponse {
	s.Body = v
	return s
}

type SubmitAIJobRequest struct {
	// The configurations of the AI job. The value is a JSON string.
	Config *string `json:"Config,omitempty" xml:"Config,omitempty"`
	// The type of the AI job. Separate multiple types with commas (,). Valid values:
	//
	// *   **AIMediaDNA**: The media fingerprinting job.
	// *   **AIVideoTag**: The smart tagging job.
	MediaId              *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the AI job.
	Types *string `json:"Types,omitempty" xml:"Types,omitempty"`
	// The custom settings. The value is a JSON string. For more information, see [Request parameters](~~86952#h2--userdata-div-id-userdata-div-3~~).
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
}

func (s SubmitAIJobRequest) String() string {
	return tea.Prettify(s)
}

func (s SubmitAIJobRequest) GoString() string {
	return s.String()
}

func (s *SubmitAIJobRequest) SetConfig(v string) *SubmitAIJobRequest {
	s.Config = &v
	return s
}

func (s *SubmitAIJobRequest) SetMediaId(v string) *SubmitAIJobRequest {
	s.MediaId = &v
	return s
}

func (s *SubmitAIJobRequest) SetOwnerAccount(v string) *SubmitAIJobRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SubmitAIJobRequest) SetOwnerId(v string) *SubmitAIJobRequest {
	s.OwnerId = &v
	return s
}

func (s *SubmitAIJobRequest) SetResourceOwnerAccount(v string) *SubmitAIJobRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SubmitAIJobRequest) SetResourceOwnerId(v string) *SubmitAIJobRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *SubmitAIJobRequest) SetTypes(v string) *SubmitAIJobRequest {
	s.Types = &v
	return s
}

func (s *SubmitAIJobRequest) SetUserData(v string) *SubmitAIJobRequest {
	s.UserData = &v
	return s
}

type SubmitAIJobResponseBody struct {
	// The ID of the video.
	AIJobList *SubmitAIJobResponseBodyAIJobList `json:"AIJobList,omitempty" xml:"AIJobList,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SubmitAIJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SubmitAIJobResponseBody) GoString() string {
	return s.String()
}

func (s *SubmitAIJobResponseBody) SetAIJobList(v *SubmitAIJobResponseBodyAIJobList) *SubmitAIJobResponseBody {
	s.AIJobList = v
	return s
}

func (s *SubmitAIJobResponseBody) SetRequestId(v string) *SubmitAIJobResponseBody {
	s.RequestId = &v
	return s
}

type SubmitAIJobResponseBodyAIJobList struct {
	AIJob []*SubmitAIJobResponseBodyAIJobListAIJob `json:"AIJob,omitempty" xml:"AIJob,omitempty" type:"Repeated"`
}

func (s SubmitAIJobResponseBodyAIJobList) String() string {
	return tea.Prettify(s)
}

func (s SubmitAIJobResponseBodyAIJobList) GoString() string {
	return s.String()
}

func (s *SubmitAIJobResponseBodyAIJobList) SetAIJob(v []*SubmitAIJobResponseBodyAIJobListAIJob) *SubmitAIJobResponseBodyAIJobList {
	s.AIJob = v
	return s
}

type SubmitAIJobResponseBodyAIJobListAIJob struct {
	JobId   *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// SubmitAIJob
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s SubmitAIJobResponseBodyAIJobListAIJob) String() string {
	return tea.Prettify(s)
}

func (s SubmitAIJobResponseBodyAIJobListAIJob) GoString() string {
	return s.String()
}

func (s *SubmitAIJobResponseBodyAIJobListAIJob) SetJobId(v string) *SubmitAIJobResponseBodyAIJobListAIJob {
	s.JobId = &v
	return s
}

func (s *SubmitAIJobResponseBodyAIJobListAIJob) SetMediaId(v string) *SubmitAIJobResponseBodyAIJobListAIJob {
	s.MediaId = &v
	return s
}

func (s *SubmitAIJobResponseBodyAIJobListAIJob) SetType(v string) *SubmitAIJobResponseBodyAIJobListAIJob {
	s.Type = &v
	return s
}

type SubmitAIJobResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SubmitAIJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SubmitAIJobResponse) String() string {
	return tea.Prettify(s)
}

func (s SubmitAIJobResponse) GoString() string {
	return s.String()
}

func (s *SubmitAIJobResponse) SetHeaders(v map[string]*string) *SubmitAIJobResponse {
	s.Headers = v
	return s
}

func (s *SubmitAIJobResponse) SetStatusCode(v int32) *SubmitAIJobResponse {
	s.StatusCode = &v
	return s
}

func (s *SubmitAIJobResponse) SetBody(v *SubmitAIJobResponseBody) *SubmitAIJobResponse {
	s.Body = v
	return s
}

type SubmitAIMediaAuditJobRequest struct {
	// Submits an automated review task. After a task is submitted, the task is processed in an asynchronous manner. The operation may return a response before the task is complete.
	MediaAuditConfiguration *string `json:"MediaAuditConfiguration,omitempty" xml:"MediaAuditConfiguration,omitempty"`
	// The type of the media file. Only **video** is supported.
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The configuration information about the review task.
	//
	// *   Other configuration items of the review task. Only the ResourceType field is supported. This field is used to specify the type of media files. You can adjust review standards and rules based on the type of media files.
	// *   If you want to adjust review standards and rules based on ResourceType, submit a ticket to request technical support.
	// *   The value of ResourceType can contain only letters, digits, and underscores (\_).
	MediaType *string `json:"MediaType,omitempty" xml:"MediaType,omitempty"`
	// The ID of the request.
	TemplateId *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The operation that you want to perform. Set the value to **SubmitAIMediaAuditJob**.
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
}

func (s SubmitAIMediaAuditJobRequest) String() string {
	return tea.Prettify(s)
}

func (s SubmitAIMediaAuditJobRequest) GoString() string {
	return s.String()
}

func (s *SubmitAIMediaAuditJobRequest) SetMediaAuditConfiguration(v string) *SubmitAIMediaAuditJobRequest {
	s.MediaAuditConfiguration = &v
	return s
}

func (s *SubmitAIMediaAuditJobRequest) SetMediaId(v string) *SubmitAIMediaAuditJobRequest {
	s.MediaId = &v
	return s
}

func (s *SubmitAIMediaAuditJobRequest) SetMediaType(v string) *SubmitAIMediaAuditJobRequest {
	s.MediaType = &v
	return s
}

func (s *SubmitAIMediaAuditJobRequest) SetTemplateId(v string) *SubmitAIMediaAuditJobRequest {
	s.TemplateId = &v
	return s
}

func (s *SubmitAIMediaAuditJobRequest) SetUserData(v string) *SubmitAIMediaAuditJobRequest {
	s.UserData = &v
	return s
}

type SubmitAIMediaAuditJobResponseBody struct {
	JobId     *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	MediaId   *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SubmitAIMediaAuditJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SubmitAIMediaAuditJobResponseBody) GoString() string {
	return s.String()
}

func (s *SubmitAIMediaAuditJobResponseBody) SetJobId(v string) *SubmitAIMediaAuditJobResponseBody {
	s.JobId = &v
	return s
}

func (s *SubmitAIMediaAuditJobResponseBody) SetMediaId(v string) *SubmitAIMediaAuditJobResponseBody {
	s.MediaId = &v
	return s
}

func (s *SubmitAIMediaAuditJobResponseBody) SetRequestId(v string) *SubmitAIMediaAuditJobResponseBody {
	s.RequestId = &v
	return s
}

type SubmitAIMediaAuditJobResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SubmitAIMediaAuditJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SubmitAIMediaAuditJobResponse) String() string {
	return tea.Prettify(s)
}

func (s SubmitAIMediaAuditJobResponse) GoString() string {
	return s.String()
}

func (s *SubmitAIMediaAuditJobResponse) SetHeaders(v map[string]*string) *SubmitAIMediaAuditJobResponse {
	s.Headers = v
	return s
}

func (s *SubmitAIMediaAuditJobResponse) SetStatusCode(v int32) *SubmitAIMediaAuditJobResponse {
	s.StatusCode = &v
	return s
}

func (s *SubmitAIMediaAuditJobResponse) SetBody(v *SubmitAIMediaAuditJobResponseBody) *SubmitAIMediaAuditJobResponse {
	s.Body = v
	return s
}

type SubmitDynamicImageJobRequest struct {
	// The ID of the animated image template.
	DynamicImageTemplateId *string `json:"DynamicImageTemplateId,omitempty" xml:"DynamicImageTemplateId,omitempty"`
	// The ID of the animated image job.
	OverrideParams *string `json:"OverrideParams,omitempty" xml:"OverrideParams,omitempty"`
	// The returned data.
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s SubmitDynamicImageJobRequest) String() string {
	return tea.Prettify(s)
}

func (s SubmitDynamicImageJobRequest) GoString() string {
	return s.String()
}

func (s *SubmitDynamicImageJobRequest) SetDynamicImageTemplateId(v string) *SubmitDynamicImageJobRequest {
	s.DynamicImageTemplateId = &v
	return s
}

func (s *SubmitDynamicImageJobRequest) SetOverrideParams(v string) *SubmitDynamicImageJobRequest {
	s.OverrideParams = &v
	return s
}

func (s *SubmitDynamicImageJobRequest) SetVideoId(v string) *SubmitDynamicImageJobRequest {
	s.VideoId = &v
	return s
}

type SubmitDynamicImageJobResponseBody struct {
	// The ID of the request.
	DynamicImageJob *SubmitDynamicImageJobResponseBodyDynamicImageJob `json:"DynamicImageJob,omitempty" xml:"DynamicImageJob,omitempty" type:"Struct"`
	// The parameters used for overriding. The value is a JSON-formatted string. For more information, see the "OverrideParams" section of the [Media processing parameters](~~98618~~) topic. The parameters are used to replace the parameters in the animated image template. For more information, see the [Basic data types](~~52839~~) topic.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SubmitDynamicImageJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SubmitDynamicImageJobResponseBody) GoString() string {
	return s.String()
}

func (s *SubmitDynamicImageJobResponseBody) SetDynamicImageJob(v *SubmitDynamicImageJobResponseBodyDynamicImageJob) *SubmitDynamicImageJobResponseBody {
	s.DynamicImageJob = v
	return s
}

func (s *SubmitDynamicImageJobResponseBody) SetRequestId(v string) *SubmitDynamicImageJobResponseBody {
	s.RequestId = &v
	return s
}

type SubmitDynamicImageJobResponseBodyDynamicImageJob struct {
	// The operation that you want to perform. Set the value to **SubmitDynamicImageJob**.
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
}

func (s SubmitDynamicImageJobResponseBodyDynamicImageJob) String() string {
	return tea.Prettify(s)
}

func (s SubmitDynamicImageJobResponseBodyDynamicImageJob) GoString() string {
	return s.String()
}

func (s *SubmitDynamicImageJobResponseBodyDynamicImageJob) SetJobId(v string) *SubmitDynamicImageJobResponseBodyDynamicImageJob {
	s.JobId = &v
	return s
}

type SubmitDynamicImageJobResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SubmitDynamicImageJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SubmitDynamicImageJobResponse) String() string {
	return tea.Prettify(s)
}

func (s SubmitDynamicImageJobResponse) GoString() string {
	return s.String()
}

func (s *SubmitDynamicImageJobResponse) SetHeaders(v map[string]*string) *SubmitDynamicImageJobResponse {
	s.Headers = v
	return s
}

func (s *SubmitDynamicImageJobResponse) SetStatusCode(v int32) *SubmitDynamicImageJobResponse {
	s.StatusCode = &v
	return s
}

func (s *SubmitDynamicImageJobResponse) SetBody(v *SubmitDynamicImageJobResponseBody) *SubmitDynamicImageJobResponse {
	s.Body = v
	return s
}

type SubmitMediaDNADeleteJobRequest struct {
	// Deletes a video fingerprinting job.
	MediaId              *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s SubmitMediaDNADeleteJobRequest) String() string {
	return tea.Prettify(s)
}

func (s SubmitMediaDNADeleteJobRequest) GoString() string {
	return s.String()
}

func (s *SubmitMediaDNADeleteJobRequest) SetMediaId(v string) *SubmitMediaDNADeleteJobRequest {
	s.MediaId = &v
	return s
}

func (s *SubmitMediaDNADeleteJobRequest) SetOwnerAccount(v string) *SubmitMediaDNADeleteJobRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SubmitMediaDNADeleteJobRequest) SetOwnerId(v string) *SubmitMediaDNADeleteJobRequest {
	s.OwnerId = &v
	return s
}

func (s *SubmitMediaDNADeleteJobRequest) SetResourceOwnerAccount(v string) *SubmitMediaDNADeleteJobRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SubmitMediaDNADeleteJobRequest) SetResourceOwnerId(v string) *SubmitMediaDNADeleteJobRequest {
	s.ResourceOwnerId = &v
	return s
}

type SubmitMediaDNADeleteJobResponseBody struct {
	JobId     *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SubmitMediaDNADeleteJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SubmitMediaDNADeleteJobResponseBody) GoString() string {
	return s.String()
}

func (s *SubmitMediaDNADeleteJobResponseBody) SetJobId(v string) *SubmitMediaDNADeleteJobResponseBody {
	s.JobId = &v
	return s
}

func (s *SubmitMediaDNADeleteJobResponseBody) SetRequestId(v string) *SubmitMediaDNADeleteJobResponseBody {
	s.RequestId = &v
	return s
}

type SubmitMediaDNADeleteJobResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SubmitMediaDNADeleteJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SubmitMediaDNADeleteJobResponse) String() string {
	return tea.Prettify(s)
}

func (s SubmitMediaDNADeleteJobResponse) GoString() string {
	return s.String()
}

func (s *SubmitMediaDNADeleteJobResponse) SetHeaders(v map[string]*string) *SubmitMediaDNADeleteJobResponse {
	s.Headers = v
	return s
}

func (s *SubmitMediaDNADeleteJobResponse) SetStatusCode(v int32) *SubmitMediaDNADeleteJobResponse {
	s.StatusCode = &v
	return s
}

func (s *SubmitMediaDNADeleteJobResponse) SetBody(v *SubmitMediaDNADeleteJobResponseBody) *SubmitMediaDNADeleteJobResponse {
	s.Body = v
	return s
}

type SubmitPreprocessJobsRequest struct {
	PreprocessType *string `json:"PreprocessType,omitempty" xml:"PreprocessType,omitempty"`
	// The operation that you want to perform. Set the value to **SubmitPreprocessJobs**.
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s SubmitPreprocessJobsRequest) String() string {
	return tea.Prettify(s)
}

func (s SubmitPreprocessJobsRequest) GoString() string {
	return s.String()
}

func (s *SubmitPreprocessJobsRequest) SetPreprocessType(v string) *SubmitPreprocessJobsRequest {
	s.PreprocessType = &v
	return s
}

func (s *SubmitPreprocessJobsRequest) SetVideoId(v string) *SubmitPreprocessJobsRequest {
	s.VideoId = &v
	return s
}

type SubmitPreprocessJobsResponseBody struct {
	PreprocessJobs *SubmitPreprocessJobsResponseBodyPreprocessJobs `json:"PreprocessJobs,omitempty" xml:"PreprocessJobs,omitempty" type:"Struct"`
	RequestId      *string                                         `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SubmitPreprocessJobsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SubmitPreprocessJobsResponseBody) GoString() string {
	return s.String()
}

func (s *SubmitPreprocessJobsResponseBody) SetPreprocessJobs(v *SubmitPreprocessJobsResponseBodyPreprocessJobs) *SubmitPreprocessJobsResponseBody {
	s.PreprocessJobs = v
	return s
}

func (s *SubmitPreprocessJobsResponseBody) SetRequestId(v string) *SubmitPreprocessJobsResponseBody {
	s.RequestId = &v
	return s
}

type SubmitPreprocessJobsResponseBodyPreprocessJobs struct {
	PreprocessJob []*SubmitPreprocessJobsResponseBodyPreprocessJobsPreprocessJob `json:"PreprocessJob,omitempty" xml:"PreprocessJob,omitempty" type:"Repeated"`
}

func (s SubmitPreprocessJobsResponseBodyPreprocessJobs) String() string {
	return tea.Prettify(s)
}

func (s SubmitPreprocessJobsResponseBodyPreprocessJobs) GoString() string {
	return s.String()
}

func (s *SubmitPreprocessJobsResponseBodyPreprocessJobs) SetPreprocessJob(v []*SubmitPreprocessJobsResponseBodyPreprocessJobsPreprocessJob) *SubmitPreprocessJobsResponseBodyPreprocessJobs {
	s.PreprocessJob = v
	return s
}

type SubmitPreprocessJobsResponseBodyPreprocessJobsPreprocessJob struct {
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
}

func (s SubmitPreprocessJobsResponseBodyPreprocessJobsPreprocessJob) String() string {
	return tea.Prettify(s)
}

func (s SubmitPreprocessJobsResponseBodyPreprocessJobsPreprocessJob) GoString() string {
	return s.String()
}

func (s *SubmitPreprocessJobsResponseBodyPreprocessJobsPreprocessJob) SetJobId(v string) *SubmitPreprocessJobsResponseBodyPreprocessJobsPreprocessJob {
	s.JobId = &v
	return s
}

type SubmitPreprocessJobsResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SubmitPreprocessJobsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SubmitPreprocessJobsResponse) String() string {
	return tea.Prettify(s)
}

func (s SubmitPreprocessJobsResponse) GoString() string {
	return s.String()
}

func (s *SubmitPreprocessJobsResponse) SetHeaders(v map[string]*string) *SubmitPreprocessJobsResponse {
	s.Headers = v
	return s
}

func (s *SubmitPreprocessJobsResponse) SetStatusCode(v int32) *SubmitPreprocessJobsResponse {
	s.StatusCode = &v
	return s
}

func (s *SubmitPreprocessJobsResponse) SetBody(v *SubmitPreprocessJobsResponseBody) *SubmitPreprocessJobsResponse {
	s.Body = v
	return s
}

type SubmitSnapshotJobRequest struct {
	// The snapshot interval. The value must be **greater than or equal to 0**. Unit: seconds. If you set this parameter to **0**, snapshots are taken at even intervals based on the video duration divided by the value of the Count parameter. Default value: **1**.
	Count *int64 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The ID of the snapshot job.
	Height *string `json:"Height,omitempty" xml:"Height,omitempty"`
	// The custom configurations, including the configuration of transparent data transmission and callback configurations. The value is a JSON-formatted string. For more information, see [UserData](~~86952~~).
	//
	// **
	//
	// **Note** The callback configurations take effect only when you specify the HTTP callback URL and select the specific callback events in the ApsaraVideo VOD console.
	Interval *int64 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The height of each snapshot. Valid values: `[8,4096]`. By default, the height of the video mezzanine file is used. Unit: pixel.
	SnapshotTemplateId *string `json:"SnapshotTemplateId,omitempty" xml:"SnapshotTemplateId,omitempty"`
	// The operation that you want to perform. Set the value to **SubmitSnapshotJob**.
	SpecifiedOffsetTime *int64 `json:"SpecifiedOffsetTime,omitempty" xml:"SpecifiedOffsetTime,omitempty"`
	// The ID of the video.
	SpriteSnapshotConfig *string `json:"SpriteSnapshotConfig,omitempty" xml:"SpriteSnapshotConfig,omitempty"`
	// The ID of the request.
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
	// The sprite snapshot configuration. If you set this parameter, sprite snapshots are generated. For more information, see [SpriteSnapshotConfig](~~86952~~).
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
	// The maximum number of snapshots. Default value: **1**.
	Width *string `json:"Width,omitempty" xml:"Width,omitempty"`
}

func (s SubmitSnapshotJobRequest) String() string {
	return tea.Prettify(s)
}

func (s SubmitSnapshotJobRequest) GoString() string {
	return s.String()
}

func (s *SubmitSnapshotJobRequest) SetCount(v int64) *SubmitSnapshotJobRequest {
	s.Count = &v
	return s
}

func (s *SubmitSnapshotJobRequest) SetHeight(v string) *SubmitSnapshotJobRequest {
	s.Height = &v
	return s
}

func (s *SubmitSnapshotJobRequest) SetInterval(v int64) *SubmitSnapshotJobRequest {
	s.Interval = &v
	return s
}

func (s *SubmitSnapshotJobRequest) SetSnapshotTemplateId(v string) *SubmitSnapshotJobRequest {
	s.SnapshotTemplateId = &v
	return s
}

func (s *SubmitSnapshotJobRequest) SetSpecifiedOffsetTime(v int64) *SubmitSnapshotJobRequest {
	s.SpecifiedOffsetTime = &v
	return s
}

func (s *SubmitSnapshotJobRequest) SetSpriteSnapshotConfig(v string) *SubmitSnapshotJobRequest {
	s.SpriteSnapshotConfig = &v
	return s
}

func (s *SubmitSnapshotJobRequest) SetUserData(v string) *SubmitSnapshotJobRequest {
	s.UserData = &v
	return s
}

func (s *SubmitSnapshotJobRequest) SetVideoId(v string) *SubmitSnapshotJobRequest {
	s.VideoId = &v
	return s
}

func (s *SubmitSnapshotJobRequest) SetWidth(v string) *SubmitSnapshotJobRequest {
	s.Width = &v
	return s
}

type SubmitSnapshotJobResponseBody struct {
	// Submits a snapshot job for a video and starts asynchronous snapshot processing.
	RequestId   *string                                   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	SnapshotJob *SubmitSnapshotJobResponseBodySnapshotJob `json:"SnapshotJob,omitempty" xml:"SnapshotJob,omitempty" type:"Struct"`
}

func (s SubmitSnapshotJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SubmitSnapshotJobResponseBody) GoString() string {
	return s.String()
}

func (s *SubmitSnapshotJobResponseBody) SetRequestId(v string) *SubmitSnapshotJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *SubmitSnapshotJobResponseBody) SetSnapshotJob(v *SubmitSnapshotJobResponseBodySnapshotJob) *SubmitSnapshotJobResponseBody {
	s.SnapshotJob = v
	return s
}

type SubmitSnapshotJobResponseBodySnapshotJob struct {
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
}

func (s SubmitSnapshotJobResponseBodySnapshotJob) String() string {
	return tea.Prettify(s)
}

func (s SubmitSnapshotJobResponseBodySnapshotJob) GoString() string {
	return s.String()
}

func (s *SubmitSnapshotJobResponseBodySnapshotJob) SetJobId(v string) *SubmitSnapshotJobResponseBodySnapshotJob {
	s.JobId = &v
	return s
}

type SubmitSnapshotJobResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SubmitSnapshotJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SubmitSnapshotJobResponse) String() string {
	return tea.Prettify(s)
}

func (s SubmitSnapshotJobResponse) GoString() string {
	return s.String()
}

func (s *SubmitSnapshotJobResponse) SetHeaders(v map[string]*string) *SubmitSnapshotJobResponse {
	s.Headers = v
	return s
}

func (s *SubmitSnapshotJobResponse) SetStatusCode(v int32) *SubmitSnapshotJobResponse {
	s.StatusCode = &v
	return s
}

func (s *SubmitSnapshotJobResponse) SetBody(v *SubmitSnapshotJobResponseBody) *SubmitSnapshotJobResponse {
	s.Body = v
	return s
}

type SubmitTranscodeJobsRequest struct {
	// The ID of the video.
	// > The VideoId parameter is required.
	EncryptConfig *string `json:"EncryptConfig,omitempty" xml:"EncryptConfig,omitempty"`
	// The transcoding jobs.
	// > This parameter is not returned for HLS packaging tasks. You must asynchronously receive the transcoding result.
	OverrideParams *string `json:"OverrideParams,omitempty" xml:"OverrideParams,omitempty"`
	// The priority of the current transcoding job in all queued jobs.
	// *   Valid values: **1** to **10**.
	// *   A value of **10** indicates the highest priority.
	// *   Default value: **6**.
	// > This parameter specifies the priority of only the current transcoding job in all queued jobs and does not affect the priorities of jobs that are running.
	PipelineId *string `json:"PipelineId,omitempty" xml:"PipelineId,omitempty"`
	// The encryption configurations. The value is a JSON-formatted string. This parameter is required only when HLS encryption is used.
	// > *   In the JSON-formatted string of the [EncryptConfig](~~86952~~) parameter, you must set the **CipherText** parameter to an AES-128 ciphertext key that is generated by calling the [GenerateDataKey](~~28948~~) operation. Otherwise, the transcoding job that uses HLS encryption fails. For more information about how to use HLS encryption, see [HLS encryption](~~68612~~).
	// > *   Regardless of whether HLS encryption or Alibaba Cloud proprietary cryptography is required, you must enable HLS encryption for the template group that is specified by the **TemplateGroupId** parameter. Otherwise, HLS encryption cannot be used.
	Priority *string `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The parameters used for overriding. The value is a JSON-formatted string. You can set this parameter to override the watermark or subtitle that is associated with the transcoding template. You can override the file URL of an image watermark, the content of a text watermark, the URL of a subtitle file, and the encoding format of a subtitle file. For more information about the data structure, see the "OverrideParams" section of the [Media processing parameters](~~98618~~) topic.
	TemplateGroupId *string `json:"TemplateGroupId,omitempty" xml:"TemplateGroupId,omitempty"`
	// The detailed information of the job.
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
	// The operation that you want to perform. Set the value to **SubmitTranscodeJobs**.
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s SubmitTranscodeJobsRequest) String() string {
	return tea.Prettify(s)
}

func (s SubmitTranscodeJobsRequest) GoString() string {
	return s.String()
}

func (s *SubmitTranscodeJobsRequest) SetEncryptConfig(v string) *SubmitTranscodeJobsRequest {
	s.EncryptConfig = &v
	return s
}

func (s *SubmitTranscodeJobsRequest) SetOverrideParams(v string) *SubmitTranscodeJobsRequest {
	s.OverrideParams = &v
	return s
}

func (s *SubmitTranscodeJobsRequest) SetPipelineId(v string) *SubmitTranscodeJobsRequest {
	s.PipelineId = &v
	return s
}

func (s *SubmitTranscodeJobsRequest) SetPriority(v string) *SubmitTranscodeJobsRequest {
	s.Priority = &v
	return s
}

func (s *SubmitTranscodeJobsRequest) SetTemplateGroupId(v string) *SubmitTranscodeJobsRequest {
	s.TemplateGroupId = &v
	return s
}

func (s *SubmitTranscodeJobsRequest) SetUserData(v string) *SubmitTranscodeJobsRequest {
	s.UserData = &v
	return s
}

func (s *SubmitTranscodeJobsRequest) SetVideoId(v string) *SubmitTranscodeJobsRequest {
	s.VideoId = &v
	return s
}

type SubmitTranscodeJobsResponseBody struct {
	// The ID of the transcoding job that was submitted.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Submits a transcoding job and starts asynchronous transcoding.
	TranscodeJobs *SubmitTranscodeJobsResponseBodyTranscodeJobs `json:"TranscodeJobs,omitempty" xml:"TranscodeJobs,omitempty" type:"Struct"`
	// The ID of the request.
	TranscodeTaskId *string `json:"TranscodeTaskId,omitempty" xml:"TranscodeTaskId,omitempty"`
}

func (s SubmitTranscodeJobsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SubmitTranscodeJobsResponseBody) GoString() string {
	return s.String()
}

func (s *SubmitTranscodeJobsResponseBody) SetRequestId(v string) *SubmitTranscodeJobsResponseBody {
	s.RequestId = &v
	return s
}

func (s *SubmitTranscodeJobsResponseBody) SetTranscodeJobs(v *SubmitTranscodeJobsResponseBodyTranscodeJobs) *SubmitTranscodeJobsResponseBody {
	s.TranscodeJobs = v
	return s
}

func (s *SubmitTranscodeJobsResponseBody) SetTranscodeTaskId(v string) *SubmitTranscodeJobsResponseBody {
	s.TranscodeTaskId = &v
	return s
}

type SubmitTranscodeJobsResponseBodyTranscodeJobs struct {
	TranscodeJob []*SubmitTranscodeJobsResponseBodyTranscodeJobsTranscodeJob `json:"TranscodeJob,omitempty" xml:"TranscodeJob,omitempty" type:"Repeated"`
}

func (s SubmitTranscodeJobsResponseBodyTranscodeJobs) String() string {
	return tea.Prettify(s)
}

func (s SubmitTranscodeJobsResponseBodyTranscodeJobs) GoString() string {
	return s.String()
}

func (s *SubmitTranscodeJobsResponseBodyTranscodeJobs) SetTranscodeJob(v []*SubmitTranscodeJobsResponseBodyTranscodeJobsTranscodeJob) *SubmitTranscodeJobsResponseBodyTranscodeJobs {
	s.TranscodeJob = v
	return s
}

type SubmitTranscodeJobsResponseBodyTranscodeJobsTranscodeJob struct {
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
}

func (s SubmitTranscodeJobsResponseBodyTranscodeJobsTranscodeJob) String() string {
	return tea.Prettify(s)
}

func (s SubmitTranscodeJobsResponseBodyTranscodeJobsTranscodeJob) GoString() string {
	return s.String()
}

func (s *SubmitTranscodeJobsResponseBodyTranscodeJobsTranscodeJob) SetJobId(v string) *SubmitTranscodeJobsResponseBodyTranscodeJobsTranscodeJob {
	s.JobId = &v
	return s
}

type SubmitTranscodeJobsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SubmitTranscodeJobsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SubmitTranscodeJobsResponse) String() string {
	return tea.Prettify(s)
}

func (s SubmitTranscodeJobsResponse) GoString() string {
	return s.String()
}

func (s *SubmitTranscodeJobsResponse) SetHeaders(v map[string]*string) *SubmitTranscodeJobsResponse {
	s.Headers = v
	return s
}

func (s *SubmitTranscodeJobsResponse) SetStatusCode(v int32) *SubmitTranscodeJobsResponse {
	s.StatusCode = &v
	return s
}

func (s *SubmitTranscodeJobsResponse) SetBody(v *SubmitTranscodeJobsResponseBody) *SubmitTranscodeJobsResponse {
	s.Body = v
	return s
}

type SubmitWorkflowJobRequest struct {
	MediaId    *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	WorkflowId *string `json:"WorkflowId,omitempty" xml:"WorkflowId,omitempty"`
}

func (s SubmitWorkflowJobRequest) String() string {
	return tea.Prettify(s)
}

func (s SubmitWorkflowJobRequest) GoString() string {
	return s.String()
}

func (s *SubmitWorkflowJobRequest) SetMediaId(v string) *SubmitWorkflowJobRequest {
	s.MediaId = &v
	return s
}

func (s *SubmitWorkflowJobRequest) SetWorkflowId(v string) *SubmitWorkflowJobRequest {
	s.WorkflowId = &v
	return s
}

type SubmitWorkflowJobResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SubmitWorkflowJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SubmitWorkflowJobResponseBody) GoString() string {
	return s.String()
}

func (s *SubmitWorkflowJobResponseBody) SetRequestId(v string) *SubmitWorkflowJobResponseBody {
	s.RequestId = &v
	return s
}

type SubmitWorkflowJobResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SubmitWorkflowJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SubmitWorkflowJobResponse) String() string {
	return tea.Prettify(s)
}

func (s SubmitWorkflowJobResponse) GoString() string {
	return s.String()
}

func (s *SubmitWorkflowJobResponse) SetHeaders(v map[string]*string) *SubmitWorkflowJobResponse {
	s.Headers = v
	return s
}

func (s *SubmitWorkflowJobResponse) SetStatusCode(v int32) *SubmitWorkflowJobResponse {
	s.StatusCode = &v
	return s
}

func (s *SubmitWorkflowJobResponse) SetBody(v *SubmitWorkflowJobResponseBody) *SubmitWorkflowJobResponse {
	s.Body = v
	return s
}

type UpdateAITemplateRequest struct {
	// The ID of the request.
	TemplateConfig *string `json:"TemplateConfig,omitempty" xml:"TemplateConfig,omitempty"`
	// The name of the AI template. The name can be up to 128 bytes in length.
	TemplateId *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The detailed configurations of the AI template. The value is a JSON string. For more information, see [AITemplateConfig](https://help.aliyun.com/document_detail/89863.html#title-vd3-499-o36).
	TemplateName *string `json:"TemplateName,omitempty" xml:"TemplateName,omitempty"`
}

func (s UpdateAITemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAITemplateRequest) GoString() string {
	return s.String()
}

func (s *UpdateAITemplateRequest) SetTemplateConfig(v string) *UpdateAITemplateRequest {
	s.TemplateConfig = &v
	return s
}

func (s *UpdateAITemplateRequest) SetTemplateId(v string) *UpdateAITemplateRequest {
	s.TemplateId = &v
	return s
}

func (s *UpdateAITemplateRequest) SetTemplateName(v string) *UpdateAITemplateRequest {
	s.TemplateName = &v
	return s
}

type UpdateAITemplateResponseBody struct {
	RequestId  *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TemplateId *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
}

func (s UpdateAITemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateAITemplateResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateAITemplateResponseBody) SetRequestId(v string) *UpdateAITemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateAITemplateResponseBody) SetTemplateId(v string) *UpdateAITemplateResponseBody {
	s.TemplateId = &v
	return s
}

type UpdateAITemplateResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateAITemplateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateAITemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAITemplateResponse) GoString() string {
	return s.String()
}

func (s *UpdateAITemplateResponse) SetHeaders(v map[string]*string) *UpdateAITemplateResponse {
	s.Headers = v
	return s
}

func (s *UpdateAITemplateResponse) SetStatusCode(v int32) *UpdateAITemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateAITemplateResponse) SetBody(v *UpdateAITemplateResponseBody) *UpdateAITemplateResponse {
	s.Body = v
	return s
}

type UpdateAppInfoRequest struct {
	AppId       *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	AppName     *string `json:"AppName,omitempty" xml:"AppName,omitempty"`
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	Status      *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s UpdateAppInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAppInfoRequest) GoString() string {
	return s.String()
}

func (s *UpdateAppInfoRequest) SetAppId(v string) *UpdateAppInfoRequest {
	s.AppId = &v
	return s
}

func (s *UpdateAppInfoRequest) SetAppName(v string) *UpdateAppInfoRequest {
	s.AppName = &v
	return s
}

func (s *UpdateAppInfoRequest) SetDescription(v string) *UpdateAppInfoRequest {
	s.Description = &v
	return s
}

func (s *UpdateAppInfoRequest) SetStatus(v string) *UpdateAppInfoRequest {
	s.Status = &v
	return s
}

type UpdateAppInfoResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateAppInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateAppInfoResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateAppInfoResponseBody) SetRequestId(v string) *UpdateAppInfoResponseBody {
	s.RequestId = &v
	return s
}

type UpdateAppInfoResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateAppInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateAppInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAppInfoResponse) GoString() string {
	return s.String()
}

func (s *UpdateAppInfoResponse) SetHeaders(v map[string]*string) *UpdateAppInfoResponse {
	s.Headers = v
	return s
}

func (s *UpdateAppInfoResponse) SetStatusCode(v int32) *UpdateAppInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateAppInfoResponse) SetBody(v *UpdateAppInfoResponseBody) *UpdateAppInfoResponse {
	s.Body = v
	return s
}

type UpdateAttachedMediaInfosRequest struct {
	// Modifies the information about multiple auxiliary media assets at a time.
	UpdateContent *string `json:"UpdateContent,omitempty" xml:"UpdateContent,omitempty"`
}

func (s UpdateAttachedMediaInfosRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAttachedMediaInfosRequest) GoString() string {
	return s.String()
}

func (s *UpdateAttachedMediaInfosRequest) SetUpdateContent(v string) *UpdateAttachedMediaInfosRequest {
	s.UpdateContent = &v
	return s
}

type UpdateAttachedMediaInfosResponseBody struct {
	NonExistMediaIds []*string `json:"NonExistMediaIds,omitempty" xml:"NonExistMediaIds,omitempty" type:"Repeated"`
	RequestId        *string   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateAttachedMediaInfosResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateAttachedMediaInfosResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateAttachedMediaInfosResponseBody) SetNonExistMediaIds(v []*string) *UpdateAttachedMediaInfosResponseBody {
	s.NonExistMediaIds = v
	return s
}

func (s *UpdateAttachedMediaInfosResponseBody) SetRequestId(v string) *UpdateAttachedMediaInfosResponseBody {
	s.RequestId = &v
	return s
}

type UpdateAttachedMediaInfosResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateAttachedMediaInfosResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateAttachedMediaInfosResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAttachedMediaInfosResponse) GoString() string {
	return s.String()
}

func (s *UpdateAttachedMediaInfosResponse) SetHeaders(v map[string]*string) *UpdateAttachedMediaInfosResponse {
	s.Headers = v
	return s
}

func (s *UpdateAttachedMediaInfosResponse) SetStatusCode(v int32) *UpdateAttachedMediaInfosResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateAttachedMediaInfosResponse) SetBody(v *UpdateAttachedMediaInfosResponseBody) *UpdateAttachedMediaInfosResponse {
	s.Body = v
	return s
}

type UpdateCategoryRequest struct {
	CateId *int64 `json:"CateId,omitempty" xml:"CateId,omitempty"`
	// Modifies a video category.
	CateName *string `json:"CateName,omitempty" xml:"CateName,omitempty"`
}

func (s UpdateCategoryRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateCategoryRequest) GoString() string {
	return s.String()
}

func (s *UpdateCategoryRequest) SetCateId(v int64) *UpdateCategoryRequest {
	s.CateId = &v
	return s
}

func (s *UpdateCategoryRequest) SetCateName(v string) *UpdateCategoryRequest {
	s.CateName = &v
	return s
}

type UpdateCategoryResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateCategoryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateCategoryResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateCategoryResponseBody) SetRequestId(v string) *UpdateCategoryResponseBody {
	s.RequestId = &v
	return s
}

type UpdateCategoryResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateCategoryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateCategoryResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateCategoryResponse) GoString() string {
	return s.String()
}

func (s *UpdateCategoryResponse) SetHeaders(v map[string]*string) *UpdateCategoryResponse {
	s.Headers = v
	return s
}

func (s *UpdateCategoryResponse) SetStatusCode(v int32) *UpdateCategoryResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateCategoryResponse) SetBody(v *UpdateCategoryResponseBody) *UpdateCategoryResponse {
	s.Body = v
	return s
}

type UpdateEditingProjectRequest struct {
	CoverURL     *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	Description  *string `json:"Description,omitempty" xml:"Description,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// Modifies an online editing project.
	ProjectId            *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *string `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Timeline             *string `json:"Timeline,omitempty" xml:"Timeline,omitempty"`
	Title                *string `json:"Title,omitempty" xml:"Title,omitempty"`
}

func (s UpdateEditingProjectRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateEditingProjectRequest) GoString() string {
	return s.String()
}

func (s *UpdateEditingProjectRequest) SetCoverURL(v string) *UpdateEditingProjectRequest {
	s.CoverURL = &v
	return s
}

func (s *UpdateEditingProjectRequest) SetDescription(v string) *UpdateEditingProjectRequest {
	s.Description = &v
	return s
}

func (s *UpdateEditingProjectRequest) SetOwnerAccount(v string) *UpdateEditingProjectRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UpdateEditingProjectRequest) SetOwnerId(v string) *UpdateEditingProjectRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdateEditingProjectRequest) SetProjectId(v string) *UpdateEditingProjectRequest {
	s.ProjectId = &v
	return s
}

func (s *UpdateEditingProjectRequest) SetResourceOwnerAccount(v string) *UpdateEditingProjectRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UpdateEditingProjectRequest) SetResourceOwnerId(v string) *UpdateEditingProjectRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UpdateEditingProjectRequest) SetTimeline(v string) *UpdateEditingProjectRequest {
	s.Timeline = &v
	return s
}

func (s *UpdateEditingProjectRequest) SetTitle(v string) *UpdateEditingProjectRequest {
	s.Title = &v
	return s
}

type UpdateEditingProjectResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateEditingProjectResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateEditingProjectResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateEditingProjectResponseBody) SetRequestId(v string) *UpdateEditingProjectResponseBody {
	s.RequestId = &v
	return s
}

type UpdateEditingProjectResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateEditingProjectResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateEditingProjectResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateEditingProjectResponse) GoString() string {
	return s.String()
}

func (s *UpdateEditingProjectResponse) SetHeaders(v map[string]*string) *UpdateEditingProjectResponse {
	s.Headers = v
	return s
}

func (s *UpdateEditingProjectResponse) SetStatusCode(v int32) *UpdateEditingProjectResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateEditingProjectResponse) SetBody(v *UpdateEditingProjectResponseBody) *UpdateEditingProjectResponse {
	s.Body = v
	return s
}

type UpdateImageInfosRequest struct {
	// The new information about the one or more images. You can modify the information about up to 20 images at a time. For more information, see the **UpdateContent** section of this topic.
	//
	// > The values of the nested parameters Title, Description, and Tags under the UpdateContent parameter cannot contain emoticons.
	UpdateContent *string `json:"UpdateContent,omitempty" xml:"UpdateContent,omitempty"`
}

func (s UpdateImageInfosRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateImageInfosRequest) GoString() string {
	return s.String()
}

func (s *UpdateImageInfosRequest) SetUpdateContent(v string) *UpdateImageInfosRequest {
	s.UpdateContent = &v
	return s
}

type UpdateImageInfosResponseBody struct {
	// The IDs of the images that do not exist.
	NonExistImageIds *UpdateImageInfosResponseBodyNonExistImageIds `json:"NonExistImageIds,omitempty" xml:"NonExistImageIds,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateImageInfosResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateImageInfosResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateImageInfosResponseBody) SetNonExistImageIds(v *UpdateImageInfosResponseBodyNonExistImageIds) *UpdateImageInfosResponseBody {
	s.NonExistImageIds = v
	return s
}

func (s *UpdateImageInfosResponseBody) SetRequestId(v string) *UpdateImageInfosResponseBody {
	s.RequestId = &v
	return s
}

type UpdateImageInfosResponseBodyNonExistImageIds struct {
	ImageId []*string `json:"ImageId,omitempty" xml:"ImageId,omitempty" type:"Repeated"`
}

func (s UpdateImageInfosResponseBodyNonExistImageIds) String() string {
	return tea.Prettify(s)
}

func (s UpdateImageInfosResponseBodyNonExistImageIds) GoString() string {
	return s.String()
}

func (s *UpdateImageInfosResponseBodyNonExistImageIds) SetImageId(v []*string) *UpdateImageInfosResponseBodyNonExistImageIds {
	s.ImageId = v
	return s
}

type UpdateImageInfosResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateImageInfosResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateImageInfosResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateImageInfosResponse) GoString() string {
	return s.String()
}

func (s *UpdateImageInfosResponse) SetHeaders(v map[string]*string) *UpdateImageInfosResponse {
	s.Headers = v
	return s
}

func (s *UpdateImageInfosResponse) SetStatusCode(v int32) *UpdateImageInfosResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateImageInfosResponse) SetBody(v *UpdateImageInfosResponseBody) *UpdateImageInfosResponse {
	s.Body = v
	return s
}

type UpdateMediaStorageClassRequest struct {
	MediaIds     *string `json:"MediaIds,omitempty" xml:"MediaIds,omitempty"`
	RestoreTier  *string `json:"RestoreTier,omitempty" xml:"RestoreTier,omitempty"`
	Scope        *string `json:"Scope,omitempty" xml:"Scope,omitempty"`
	StorageClass *string `json:"StorageClass,omitempty" xml:"StorageClass,omitempty"`
}

func (s UpdateMediaStorageClassRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateMediaStorageClassRequest) GoString() string {
	return s.String()
}

func (s *UpdateMediaStorageClassRequest) SetMediaIds(v string) *UpdateMediaStorageClassRequest {
	s.MediaIds = &v
	return s
}

func (s *UpdateMediaStorageClassRequest) SetRestoreTier(v string) *UpdateMediaStorageClassRequest {
	s.RestoreTier = &v
	return s
}

func (s *UpdateMediaStorageClassRequest) SetScope(v string) *UpdateMediaStorageClassRequest {
	s.Scope = &v
	return s
}

func (s *UpdateMediaStorageClassRequest) SetStorageClass(v string) *UpdateMediaStorageClassRequest {
	s.StorageClass = &v
	return s
}

type UpdateMediaStorageClassResponseBody struct {
	ForbiddenList *UpdateMediaStorageClassResponseBodyForbiddenList `json:"ForbiddenList,omitempty" xml:"ForbiddenList,omitempty" type:"Struct"`
	IgnoredList   *UpdateMediaStorageClassResponseBodyIgnoredList   `json:"IgnoredList,omitempty" xml:"IgnoredList,omitempty" type:"Struct"`
	RequestId     *string                                           `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Status        *string                                           `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s UpdateMediaStorageClassResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateMediaStorageClassResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateMediaStorageClassResponseBody) SetForbiddenList(v *UpdateMediaStorageClassResponseBodyForbiddenList) *UpdateMediaStorageClassResponseBody {
	s.ForbiddenList = v
	return s
}

func (s *UpdateMediaStorageClassResponseBody) SetIgnoredList(v *UpdateMediaStorageClassResponseBodyIgnoredList) *UpdateMediaStorageClassResponseBody {
	s.IgnoredList = v
	return s
}

func (s *UpdateMediaStorageClassResponseBody) SetRequestId(v string) *UpdateMediaStorageClassResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateMediaStorageClassResponseBody) SetStatus(v string) *UpdateMediaStorageClassResponseBody {
	s.Status = &v
	return s
}

type UpdateMediaStorageClassResponseBodyForbiddenList struct {
	MediaForbiddenReasonDTO []*UpdateMediaStorageClassResponseBodyForbiddenListMediaForbiddenReasonDTO `json:"MediaForbiddenReasonDTO,omitempty" xml:"MediaForbiddenReasonDTO,omitempty" type:"Repeated"`
}

func (s UpdateMediaStorageClassResponseBodyForbiddenList) String() string {
	return tea.Prettify(s)
}

func (s UpdateMediaStorageClassResponseBodyForbiddenList) GoString() string {
	return s.String()
}

func (s *UpdateMediaStorageClassResponseBodyForbiddenList) SetMediaForbiddenReasonDTO(v []*UpdateMediaStorageClassResponseBodyForbiddenListMediaForbiddenReasonDTO) *UpdateMediaStorageClassResponseBodyForbiddenList {
	s.MediaForbiddenReasonDTO = v
	return s
}

type UpdateMediaStorageClassResponseBodyForbiddenListMediaForbiddenReasonDTO struct {
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	Reason  *string `json:"Reason,omitempty" xml:"Reason,omitempty"`
}

func (s UpdateMediaStorageClassResponseBodyForbiddenListMediaForbiddenReasonDTO) String() string {
	return tea.Prettify(s)
}

func (s UpdateMediaStorageClassResponseBodyForbiddenListMediaForbiddenReasonDTO) GoString() string {
	return s.String()
}

func (s *UpdateMediaStorageClassResponseBodyForbiddenListMediaForbiddenReasonDTO) SetMediaId(v string) *UpdateMediaStorageClassResponseBodyForbiddenListMediaForbiddenReasonDTO {
	s.MediaId = &v
	return s
}

func (s *UpdateMediaStorageClassResponseBodyForbiddenListMediaForbiddenReasonDTO) SetReason(v string) *UpdateMediaStorageClassResponseBodyForbiddenListMediaForbiddenReasonDTO {
	s.Reason = &v
	return s
}

type UpdateMediaStorageClassResponseBodyIgnoredList struct {
	MediaId []*string `json:"MediaId,omitempty" xml:"MediaId,omitempty" type:"Repeated"`
}

func (s UpdateMediaStorageClassResponseBodyIgnoredList) String() string {
	return tea.Prettify(s)
}

func (s UpdateMediaStorageClassResponseBodyIgnoredList) GoString() string {
	return s.String()
}

func (s *UpdateMediaStorageClassResponseBodyIgnoredList) SetMediaId(v []*string) *UpdateMediaStorageClassResponseBodyIgnoredList {
	s.MediaId = v
	return s
}

type UpdateMediaStorageClassResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateMediaStorageClassResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateMediaStorageClassResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateMediaStorageClassResponse) GoString() string {
	return s.String()
}

func (s *UpdateMediaStorageClassResponse) SetHeaders(v map[string]*string) *UpdateMediaStorageClassResponse {
	s.Headers = v
	return s
}

func (s *UpdateMediaStorageClassResponse) SetStatusCode(v int32) *UpdateMediaStorageClassResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateMediaStorageClassResponse) SetBody(v *UpdateMediaStorageClassResponseBody) *UpdateMediaStorageClassResponse {
	s.Body = v
	return s
}

type UpdateTranscodeTemplateGroupRequest struct {
	Locked *string `json:"Locked,omitempty" xml:"Locked,omitempty"`
	// The operation that you want to perform. Set the value to **UpdateTranscodeTemplateGroup**.
	Name                     *string `json:"Name,omitempty" xml:"Name,omitempty"`
	TranscodeTemplateGroupId *string `json:"TranscodeTemplateGroupId,omitempty" xml:"TranscodeTemplateGroupId,omitempty"`
	// Modifies a transcoding template group. You can modify the configurations of the specified transcoding templates in a transcoding template group.
	TranscodeTemplateList *string `json:"TranscodeTemplateList,omitempty" xml:"TranscodeTemplateList,omitempty"`
}

func (s UpdateTranscodeTemplateGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTranscodeTemplateGroupRequest) GoString() string {
	return s.String()
}

func (s *UpdateTranscodeTemplateGroupRequest) SetLocked(v string) *UpdateTranscodeTemplateGroupRequest {
	s.Locked = &v
	return s
}

func (s *UpdateTranscodeTemplateGroupRequest) SetName(v string) *UpdateTranscodeTemplateGroupRequest {
	s.Name = &v
	return s
}

func (s *UpdateTranscodeTemplateGroupRequest) SetTranscodeTemplateGroupId(v string) *UpdateTranscodeTemplateGroupRequest {
	s.TranscodeTemplateGroupId = &v
	return s
}

func (s *UpdateTranscodeTemplateGroupRequest) SetTranscodeTemplateList(v string) *UpdateTranscodeTemplateGroupRequest {
	s.TranscodeTemplateList = &v
	return s
}

type UpdateTranscodeTemplateGroupResponseBody struct {
	RequestId                *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TranscodeTemplateGroupId *string `json:"TranscodeTemplateGroupId,omitempty" xml:"TranscodeTemplateGroupId,omitempty"`
}

func (s UpdateTranscodeTemplateGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTranscodeTemplateGroupResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTranscodeTemplateGroupResponseBody) SetRequestId(v string) *UpdateTranscodeTemplateGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateTranscodeTemplateGroupResponseBody) SetTranscodeTemplateGroupId(v string) *UpdateTranscodeTemplateGroupResponseBody {
	s.TranscodeTemplateGroupId = &v
	return s
}

type UpdateTranscodeTemplateGroupResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateTranscodeTemplateGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateTranscodeTemplateGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTranscodeTemplateGroupResponse) GoString() string {
	return s.String()
}

func (s *UpdateTranscodeTemplateGroupResponse) SetHeaders(v map[string]*string) *UpdateTranscodeTemplateGroupResponse {
	s.Headers = v
	return s
}

func (s *UpdateTranscodeTemplateGroupResponse) SetStatusCode(v int32) *UpdateTranscodeTemplateGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTranscodeTemplateGroupResponse) SetBody(v *UpdateTranscodeTemplateGroupResponseBody) *UpdateTranscodeTemplateGroupResponse {
	s.Body = v
	return s
}

type UpdateVideoInfoRequest struct {
	CateId      *int64  `json:"CateId,omitempty" xml:"CateId,omitempty"`
	CoverURL    *string `json:"CoverURL,omitempty" xml:"CoverURL,omitempty"`
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The URL of the video thumbnail.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The ID of the request.
	Title *string `json:"Title,omitempty" xml:"Title,omitempty"`
	// The description of the video.
	//
	// *   The value can be up to 1,024 bytes in length.
	// *   The string must be encoded in the UTF-8 format.
	VideoId *string `json:"VideoId,omitempty" xml:"VideoId,omitempty"`
}

func (s UpdateVideoInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateVideoInfoRequest) GoString() string {
	return s.String()
}

func (s *UpdateVideoInfoRequest) SetCateId(v int64) *UpdateVideoInfoRequest {
	s.CateId = &v
	return s
}

func (s *UpdateVideoInfoRequest) SetCoverURL(v string) *UpdateVideoInfoRequest {
	s.CoverURL = &v
	return s
}

func (s *UpdateVideoInfoRequest) SetDescription(v string) *UpdateVideoInfoRequest {
	s.Description = &v
	return s
}

func (s *UpdateVideoInfoRequest) SetTags(v string) *UpdateVideoInfoRequest {
	s.Tags = &v
	return s
}

func (s *UpdateVideoInfoRequest) SetTitle(v string) *UpdateVideoInfoRequest {
	s.Title = &v
	return s
}

func (s *UpdateVideoInfoRequest) SetVideoId(v string) *UpdateVideoInfoRequest {
	s.VideoId = &v
	return s
}

type UpdateVideoInfoResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateVideoInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateVideoInfoResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateVideoInfoResponseBody) SetRequestId(v string) *UpdateVideoInfoResponseBody {
	s.RequestId = &v
	return s
}

type UpdateVideoInfoResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateVideoInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateVideoInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateVideoInfoResponse) GoString() string {
	return s.String()
}

func (s *UpdateVideoInfoResponse) SetHeaders(v map[string]*string) *UpdateVideoInfoResponse {
	s.Headers = v
	return s
}

func (s *UpdateVideoInfoResponse) SetStatusCode(v int32) *UpdateVideoInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateVideoInfoResponse) SetBody(v *UpdateVideoInfoResponseBody) *UpdateVideoInfoResponse {
	s.Body = v
	return s
}

type UpdateVideoInfosRequest struct {
	// ## UpdateContent
	//
	// >  You must convert the UpdateContent[] parameter to a string before you pass it in.
	//
	// | Parameter | Type | Required | Description |
	// | --------- | ---- | -------- | ----------- |
	// | VideoId | String | Yes | The ID of the video. |
	// | Title | String | No | The title of the video. |
	// | Description | String | No | The description of the video. |
	// | Tags | String | No | The tag of the video. |
	// | CoverURL | String | No | The URL of the video thumbnail. |
	// | CateId | Long | No | The ID of the category. |
	UpdateContent *string `json:"UpdateContent,omitempty" xml:"UpdateContent,omitempty"`
}

func (s UpdateVideoInfosRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateVideoInfosRequest) GoString() string {
	return s.String()
}

func (s *UpdateVideoInfosRequest) SetUpdateContent(v string) *UpdateVideoInfosRequest {
	s.UpdateContent = &v
	return s
}

type UpdateVideoInfosResponseBody struct {
	ForbiddenVideoIds []*string `json:"ForbiddenVideoIds,omitempty" xml:"ForbiddenVideoIds,omitempty" type:"Repeated"`
	NonExistVideoIds  []*string `json:"NonExistVideoIds,omitempty" xml:"NonExistVideoIds,omitempty" type:"Repeated"`
	RequestId         *string   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateVideoInfosResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateVideoInfosResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateVideoInfosResponseBody) SetForbiddenVideoIds(v []*string) *UpdateVideoInfosResponseBody {
	s.ForbiddenVideoIds = v
	return s
}

func (s *UpdateVideoInfosResponseBody) SetNonExistVideoIds(v []*string) *UpdateVideoInfosResponseBody {
	s.NonExistVideoIds = v
	return s
}

func (s *UpdateVideoInfosResponseBody) SetRequestId(v string) *UpdateVideoInfosResponseBody {
	s.RequestId = &v
	return s
}

type UpdateVideoInfosResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateVideoInfosResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateVideoInfosResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateVideoInfosResponse) GoString() string {
	return s.String()
}

func (s *UpdateVideoInfosResponse) SetHeaders(v map[string]*string) *UpdateVideoInfosResponse {
	s.Headers = v
	return s
}

func (s *UpdateVideoInfosResponse) SetStatusCode(v int32) *UpdateVideoInfosResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateVideoInfosResponse) SetBody(v *UpdateVideoInfosResponseBody) *UpdateVideoInfosResponse {
	s.Body = v
	return s
}

type UpdateVodDomainRequest struct {
	// The accelerated domain name.
	DomainName    *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId       *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	SecurityToken *string `json:"SecurityToken,omitempty" xml:"SecurityToken,omitempty"`
	// The information about the addresses of origin servers.
	Sources *string `json:"Sources,omitempty" xml:"Sources,omitempty"`
	// The top-level domain.
	TopLevelDomain *string `json:"TopLevelDomain,omitempty" xml:"TopLevelDomain,omitempty"`
}

func (s UpdateVodDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateVodDomainRequest) GoString() string {
	return s.String()
}

func (s *UpdateVodDomainRequest) SetDomainName(v string) *UpdateVodDomainRequest {
	s.DomainName = &v
	return s
}

func (s *UpdateVodDomainRequest) SetOwnerId(v int64) *UpdateVodDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdateVodDomainRequest) SetSecurityToken(v string) *UpdateVodDomainRequest {
	s.SecurityToken = &v
	return s
}

func (s *UpdateVodDomainRequest) SetSources(v string) *UpdateVodDomainRequest {
	s.Sources = &v
	return s
}

func (s *UpdateVodDomainRequest) SetTopLevelDomain(v string) *UpdateVodDomainRequest {
	s.TopLevelDomain = &v
	return s
}

type UpdateVodDomainResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateVodDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateVodDomainResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateVodDomainResponseBody) SetRequestId(v string) *UpdateVodDomainResponseBody {
	s.RequestId = &v
	return s
}

type UpdateVodDomainResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateVodDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateVodDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateVodDomainResponse) GoString() string {
	return s.String()
}

func (s *UpdateVodDomainResponse) SetHeaders(v map[string]*string) *UpdateVodDomainResponse {
	s.Headers = v
	return s
}

func (s *UpdateVodDomainResponse) SetStatusCode(v int32) *UpdateVodDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateVodDomainResponse) SetBody(v *UpdateVodDomainResponseBody) *UpdateVodDomainResponse {
	s.Body = v
	return s
}

type UpdateVodTemplateRequest struct {
	// The name of the template.
	//
	// *   The name can be up to 128 bytes in length.
	// *   The value must be encoded in UTF-8.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Modifies a snapshot template.
	TemplateConfig *string `json:"TemplateConfig,omitempty" xml:"TemplateConfig,omitempty"`
	// The operation that you want to perform. Set the value to **UpdateVodTemplate**.
	VodTemplateId *string `json:"VodTemplateId,omitempty" xml:"VodTemplateId,omitempty"`
}

func (s UpdateVodTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateVodTemplateRequest) GoString() string {
	return s.String()
}

func (s *UpdateVodTemplateRequest) SetName(v string) *UpdateVodTemplateRequest {
	s.Name = &v
	return s
}

func (s *UpdateVodTemplateRequest) SetTemplateConfig(v string) *UpdateVodTemplateRequest {
	s.TemplateConfig = &v
	return s
}

func (s *UpdateVodTemplateRequest) SetVodTemplateId(v string) *UpdateVodTemplateRequest {
	s.VodTemplateId = &v
	return s
}

type UpdateVodTemplateResponseBody struct {
	RequestId     *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	VodTemplateId *string `json:"VodTemplateId,omitempty" xml:"VodTemplateId,omitempty"`
}

func (s UpdateVodTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateVodTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateVodTemplateResponseBody) SetRequestId(v string) *UpdateVodTemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateVodTemplateResponseBody) SetVodTemplateId(v string) *UpdateVodTemplateResponseBody {
	s.VodTemplateId = &v
	return s
}

type UpdateVodTemplateResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateVodTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateVodTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateVodTemplateResponse) GoString() string {
	return s.String()
}

func (s *UpdateVodTemplateResponse) SetHeaders(v map[string]*string) *UpdateVodTemplateResponse {
	s.Headers = v
	return s
}

func (s *UpdateVodTemplateResponse) SetStatusCode(v int32) *UpdateVodTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateVodTemplateResponse) SetBody(v *UpdateVodTemplateResponseBody) *UpdateVodTemplateResponse {
	s.Body = v
	return s
}

type UpdateWatermarkRequest struct {
	// The ID of the watermark.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The name of the watermark.
	WatermarkConfig *string `json:"WatermarkConfig,omitempty" xml:"WatermarkConfig,omitempty"`
	// The configurations such as the position and effect of the text watermark or image watermark. The value is a JSON-formatted string.
	//
	// > The value of this parameter varies with the watermark type. For more information about the data structure, see the "WatermarkConfig" section of the [Media processing parameters](~~98618~~) topic.
	WatermarkId *string `json:"WatermarkId,omitempty" xml:"WatermarkId,omitempty"`
}

func (s UpdateWatermarkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateWatermarkRequest) GoString() string {
	return s.String()
}

func (s *UpdateWatermarkRequest) SetName(v string) *UpdateWatermarkRequest {
	s.Name = &v
	return s
}

func (s *UpdateWatermarkRequest) SetWatermarkConfig(v string) *UpdateWatermarkRequest {
	s.WatermarkConfig = &v
	return s
}

func (s *UpdateWatermarkRequest) SetWatermarkId(v string) *UpdateWatermarkRequest {
	s.WatermarkId = &v
	return s
}

type UpdateWatermarkResponseBody struct {
	// The operation that you want to perform. Set the value to **UpdateWatermark**.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the watermark.
	WatermarkInfo *UpdateWatermarkResponseBodyWatermarkInfo `json:"WatermarkInfo,omitempty" xml:"WatermarkInfo,omitempty" type:"Struct"`
}

func (s UpdateWatermarkResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateWatermarkResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateWatermarkResponseBody) SetRequestId(v string) *UpdateWatermarkResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateWatermarkResponseBody) SetWatermarkInfo(v *UpdateWatermarkResponseBodyWatermarkInfo) *UpdateWatermarkResponseBody {
	s.WatermarkInfo = v
	return s
}

type UpdateWatermarkResponseBodyWatermarkInfo struct {
	// The name of the watermark. Only letters and digits are supported.
	//
	// *   The name can be up to 128 bytes in length.
	// *   The value must be encoded in UTF-8.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The ID of the request.
	FileUrl *string `json:"FileUrl,omitempty" xml:"FileUrl,omitempty"`
	// The Object Storage Service (OSS) URL or Content Delivery Network (CDN) URL of the watermark file. A text watermark does not have a file URL.
	IsDefault *string `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	Name      *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The time when the watermark was added. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// Modifies a watermark.
	WatermarkConfig *string `json:"WatermarkConfig,omitempty" xml:"WatermarkConfig,omitempty"`
	WatermarkId     *string `json:"WatermarkId,omitempty" xml:"WatermarkId,omitempty"`
}

func (s UpdateWatermarkResponseBodyWatermarkInfo) String() string {
	return tea.Prettify(s)
}

func (s UpdateWatermarkResponseBodyWatermarkInfo) GoString() string {
	return s.String()
}

func (s *UpdateWatermarkResponseBodyWatermarkInfo) SetCreationTime(v string) *UpdateWatermarkResponseBodyWatermarkInfo {
	s.CreationTime = &v
	return s
}

func (s *UpdateWatermarkResponseBodyWatermarkInfo) SetFileUrl(v string) *UpdateWatermarkResponseBodyWatermarkInfo {
	s.FileUrl = &v
	return s
}

func (s *UpdateWatermarkResponseBodyWatermarkInfo) SetIsDefault(v string) *UpdateWatermarkResponseBodyWatermarkInfo {
	s.IsDefault = &v
	return s
}

func (s *UpdateWatermarkResponseBodyWatermarkInfo) SetName(v string) *UpdateWatermarkResponseBodyWatermarkInfo {
	s.Name = &v
	return s
}

func (s *UpdateWatermarkResponseBodyWatermarkInfo) SetType(v string) *UpdateWatermarkResponseBodyWatermarkInfo {
	s.Type = &v
	return s
}

func (s *UpdateWatermarkResponseBodyWatermarkInfo) SetWatermarkConfig(v string) *UpdateWatermarkResponseBodyWatermarkInfo {
	s.WatermarkConfig = &v
	return s
}

func (s *UpdateWatermarkResponseBodyWatermarkInfo) SetWatermarkId(v string) *UpdateWatermarkResponseBodyWatermarkInfo {
	s.WatermarkId = &v
	return s
}

type UpdateWatermarkResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateWatermarkResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateWatermarkResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateWatermarkResponse) GoString() string {
	return s.String()
}

func (s *UpdateWatermarkResponse) SetHeaders(v map[string]*string) *UpdateWatermarkResponse {
	s.Headers = v
	return s
}

func (s *UpdateWatermarkResponse) SetStatusCode(v int32) *UpdateWatermarkResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateWatermarkResponse) SetBody(v *UpdateWatermarkResponseBody) *UpdateWatermarkResponse {
	s.Body = v
	return s
}

type UploadMediaByURLRequest struct {
	// ## UploadMetadata
	//
	// | Parameter | Type | Required | Description |
	// | --------- | ---- | -------- | ----------- |
	// | SourceURL | String | Yes | The URL of the source file to be uploaded. |
	// | Title | String | Yes | The title of the media file. The title can be up to 128 bytes in length. The value must be encoded in UTF-8. |
	// | FileSize | String | No | The size of the media file. |
	// | Description | String | No | The description of the media file. The description can be up to 1,024 bytes in length. The value must be encoded in UTF-8. |
	// | CoverURL | String | No | The URL of the custom thumbnail of the media file. |
	// | CateId | String | No | The category ID of the media file. To view the category ID of the media file, log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com/). In the left-side navigation pane, choose **Configuration Management** > **Media Management** > **Categories**. |
	// | Tags | String | No | The one or more tags of the media file. Each tag can be up to 32 bytes in length. You can set a maximum of 16 tags. Separate multiple tags with commas (,). The value must be encoded in UTF-8. |
	// | TemplateGroupId | String | No | The ID of the transcoding template group. If both the request parameter TemplateGroupId and the nested parameter TemplateGroupId are set, the value of the nested parameter takes effect. |
	// | WorkflowId | String | No | The ID of the workflow. If both the WorkflowId and TemplateGroupId parameters are set, the value of the WorkflowId parameter takes effect. For more information, see [Workflows](https://www.alibabacloud.com/help/en/apsaravideo-for-vod/latest/workflows). |
	// | FileExtension | String | No | The file name extension of the media file. For more information about file name extensions supported by ApsaraVideo VOD, see [Overview](https://www.alibabacloud.com/help/en/apsaravideo-for-vod/latest/upload-medias-overview). |
	// > - Do not include emoticons in the nested parameters, such as Title, Description, and Tags, under the UploadMetadata parameter.
	// - If you set the TemplateGroupId parameter to VOD_NO_TRANSCODE to upload videos, only the videos in the format of MP4, FLV, MP3, M3U8, or WebM can be played. Videos in the other formats are supported only for storage. You can identify the video format based on the file name extension. If you want to use ApsaraVideo Player, the version must be 3.1.0 or later.
	// - If you set the TemplateGroupId parameter to VOD_NO_TRANSCODE, only the [FileUploadComplete](https://www.alibabacloud.com/help/en/apsaravideo-for-vod/latest/fileuploadcomplete) but not the [StreamTranscodeComplete](https://www.alibabacloud.com/help/en/apsaravideo-for-vod/latest/streamtranscodecomplete) event notification is returned after the media file is uploaded.
	// - If a callback is configured, ApsaraVideo VOD sends an [UploadByURLComplete](https://www.alibabacloud.com/help/en/apsaravideo-for-vod/latest/uploadbyurlcomplete) event notification after the media file is uploaded, in addition to the FileUploadComplete and StreamTranscodeComplete event notifications.
	// - If you specify multiple media files at a time, ApsaraVideo VOD sends an event notification for each media file after the media file is uploaded.
	AppId *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The URL of the source file.
	// * The URL must contain a file name extension, such as mp4 in `https://****.mp4`.
	//     * If the URL does not contain a file name extension, you can specify one by setting the `FileExtension` parameter under the `UploadMetadatas` parameter.
	//     * If the URL contains a file name extension and the `FileExtension` parameter is set, the value of the `FileExtension` parameter is used.
	//     * For more information about file name extensions supported by ApsaraVideo VOD, see [Overview](~~55396~~).
	// * URL encoding is required. Separate multiple URLs with commas (,). You can specify a maximum of 20 URLs.
	// * Special characters may cause upload failures. Therefore, encode URLs before you separate them with commas (,).
	StorageLocation *string `json:"StorageLocation,omitempty" xml:"StorageLocation,omitempty"`
	// The information about one or more upload jobs.
	TemplateGroupId *string `json:"TemplateGroupId,omitempty" xml:"TemplateGroupId,omitempty"`
	// The metadata of the media file to be uploaded. The value is a JSON string.
	// * This parameter takes effect only if the value of the SourceURL parameter matches the URL that is specified by the UploadURLs parameter.
	// * The JSON-formatted data, such as `[UploadMetadata, UploadMetadata,…]`, must be converted into a JSON string.
	// * For more information, see the **UploadMetadata** section.
	UploadMetadatas *string `json:"UploadMetadatas,omitempty" xml:"UploadMetadatas,omitempty"`
	// The ID of the application. Default value: **app-1000000**. For more information, see [Overview](~~113600~~).
	UploadURLs *string `json:"UploadURLs,omitempty" xml:"UploadURLs,omitempty"`
	// The ID of the request.
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
	// > This operation is used to asynchronously upload media files. Upload jobs are queued for execution after they are submitted. The completion time of an upload job varies with the number of jobs in the queue.
	WorkflowId *string `json:"WorkflowId,omitempty" xml:"WorkflowId,omitempty"`
}

func (s UploadMediaByURLRequest) String() string {
	return tea.Prettify(s)
}

func (s UploadMediaByURLRequest) GoString() string {
	return s.String()
}

func (s *UploadMediaByURLRequest) SetAppId(v string) *UploadMediaByURLRequest {
	s.AppId = &v
	return s
}

func (s *UploadMediaByURLRequest) SetStorageLocation(v string) *UploadMediaByURLRequest {
	s.StorageLocation = &v
	return s
}

func (s *UploadMediaByURLRequest) SetTemplateGroupId(v string) *UploadMediaByURLRequest {
	s.TemplateGroupId = &v
	return s
}

func (s *UploadMediaByURLRequest) SetUploadMetadatas(v string) *UploadMediaByURLRequest {
	s.UploadMetadatas = &v
	return s
}

func (s *UploadMediaByURLRequest) SetUploadURLs(v string) *UploadMediaByURLRequest {
	s.UploadURLs = &v
	return s
}

func (s *UploadMediaByURLRequest) SetUserData(v string) *UploadMediaByURLRequest {
	s.UserData = &v
	return s
}

func (s *UploadMediaByURLRequest) SetWorkflowId(v string) *UploadMediaByURLRequest {
	s.WorkflowId = &v
	return s
}

type UploadMediaByURLResponseBody struct {
	RequestId  *string                                   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	UploadJobs []*UploadMediaByURLResponseBodyUploadJobs `json:"UploadJobs,omitempty" xml:"UploadJobs,omitempty" type:"Repeated"`
}

func (s UploadMediaByURLResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UploadMediaByURLResponseBody) GoString() string {
	return s.String()
}

func (s *UploadMediaByURLResponseBody) SetRequestId(v string) *UploadMediaByURLResponseBody {
	s.RequestId = &v
	return s
}

func (s *UploadMediaByURLResponseBody) SetUploadJobs(v []*UploadMediaByURLResponseBodyUploadJobs) *UploadMediaByURLResponseBody {
	s.UploadJobs = v
	return s
}

type UploadMediaByURLResponseBodyUploadJobs struct {
	JobId     *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	SourceURL *string `json:"SourceURL,omitempty" xml:"SourceURL,omitempty"`
}

func (s UploadMediaByURLResponseBodyUploadJobs) String() string {
	return tea.Prettify(s)
}

func (s UploadMediaByURLResponseBodyUploadJobs) GoString() string {
	return s.String()
}

func (s *UploadMediaByURLResponseBodyUploadJobs) SetJobId(v string) *UploadMediaByURLResponseBodyUploadJobs {
	s.JobId = &v
	return s
}

func (s *UploadMediaByURLResponseBodyUploadJobs) SetSourceURL(v string) *UploadMediaByURLResponseBodyUploadJobs {
	s.SourceURL = &v
	return s
}

type UploadMediaByURLResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UploadMediaByURLResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UploadMediaByURLResponse) String() string {
	return tea.Prettify(s)
}

func (s UploadMediaByURLResponse) GoString() string {
	return s.String()
}

func (s *UploadMediaByURLResponse) SetHeaders(v map[string]*string) *UploadMediaByURLResponse {
	s.Headers = v
	return s
}

func (s *UploadMediaByURLResponse) SetStatusCode(v int32) *UploadMediaByURLResponse {
	s.StatusCode = &v
	return s
}

func (s *UploadMediaByURLResponse) SetBody(v *UploadMediaByURLResponseBody) *UploadMediaByURLResponse {
	s.Body = v
	return s
}

type UploadStreamByURLRequest struct {
	// The media ID in ApsaraVideo VOD.
	Definition *string `json:"Definition,omitempty" xml:"Definition,omitempty"`
	// The quality of the video stream.
	//
	// For more information about valid values of this parameter, see [Parameters for media assets](~~124671~~).
	FileExtension *string `json:"FileExtension,omitempty" xml:"FileExtension,omitempty"`
	// The file name extension of the transcoded stream.
	//
	// For more information, see the Supported media file formats section in [Overview](~~55396~~).
	//
	// If you set a value for this parameter, the file name extension specified in StreamURL is overwritten.
	//
	// >  This parameter is required if you do not specify a file name extension in StreamURL.
	HDRType *string `json:"HDRType,omitempty" xml:"HDRType,omitempty"`
	// The URL of the OSS object.
	MediaId *string `json:"MediaId,omitempty" xml:"MediaId,omitempty"`
	// The basic information.
	StreamURL *string `json:"StreamURL,omitempty" xml:"StreamURL,omitempty"`
	// The ID of the request.
	UserData *string `json:"UserData,omitempty" xml:"UserData,omitempty"`
}

func (s UploadStreamByURLRequest) String() string {
	return tea.Prettify(s)
}

func (s UploadStreamByURLRequest) GoString() string {
	return s.String()
}

func (s *UploadStreamByURLRequest) SetDefinition(v string) *UploadStreamByURLRequest {
	s.Definition = &v
	return s
}

func (s *UploadStreamByURLRequest) SetFileExtension(v string) *UploadStreamByURLRequest {
	s.FileExtension = &v
	return s
}

func (s *UploadStreamByURLRequest) SetHDRType(v string) *UploadStreamByURLRequest {
	s.HDRType = &v
	return s
}

func (s *UploadStreamByURLRequest) SetMediaId(v string) *UploadStreamByURLRequest {
	s.MediaId = &v
	return s
}

func (s *UploadStreamByURLRequest) SetStreamURL(v string) *UploadStreamByURLRequest {
	s.StreamURL = &v
	return s
}

func (s *UploadStreamByURLRequest) SetUserData(v string) *UploadStreamByURLRequest {
	s.UserData = &v
	return s
}

type UploadStreamByURLResponseBody struct {
	FileURL *string `json:"FileURL,omitempty" xml:"FileURL,omitempty"`
	// Uploads transcoded streams to ApsaraVideo VOD from external storage.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	SourceURL *string `json:"SourceURL,omitempty" xml:"SourceURL,omitempty"`
	// UploadStreamByURL
	StreamJobId *string `json:"StreamJobId,omitempty" xml:"StreamJobId,omitempty"`
}

func (s UploadStreamByURLResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UploadStreamByURLResponseBody) GoString() string {
	return s.String()
}

func (s *UploadStreamByURLResponseBody) SetFileURL(v string) *UploadStreamByURLResponseBody {
	s.FileURL = &v
	return s
}

func (s *UploadStreamByURLResponseBody) SetRequestId(v string) *UploadStreamByURLResponseBody {
	s.RequestId = &v
	return s
}

func (s *UploadStreamByURLResponseBody) SetSourceURL(v string) *UploadStreamByURLResponseBody {
	s.SourceURL = &v
	return s
}

func (s *UploadStreamByURLResponseBody) SetStreamJobId(v string) *UploadStreamByURLResponseBody {
	s.StreamJobId = &v
	return s
}

type UploadStreamByURLResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UploadStreamByURLResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UploadStreamByURLResponse) String() string {
	return tea.Prettify(s)
}

func (s UploadStreamByURLResponse) GoString() string {
	return s.String()
}

func (s *UploadStreamByURLResponse) SetHeaders(v map[string]*string) *UploadStreamByURLResponse {
	s.Headers = v
	return s
}

func (s *UploadStreamByURLResponse) SetStatusCode(v int32) *UploadStreamByURLResponse {
	s.StatusCode = &v
	return s
}

func (s *UploadStreamByURLResponse) SetBody(v *UploadStreamByURLResponseBody) *UploadStreamByURLResponse {
	s.Body = v
	return s
}

type VerifyVodDomainOwnerRequest struct {
	// The DNS verification method that is used to verify the ownership of the specified domain name.
	DomainName *string `json:"DomainName,omitempty" xml:"DomainName,omitempty"`
	OwnerId    *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// Verifies the ownership of a specified domain name.
	VerifyType *string `json:"VerifyType,omitempty" xml:"VerifyType,omitempty"`
}

func (s VerifyVodDomainOwnerRequest) String() string {
	return tea.Prettify(s)
}

func (s VerifyVodDomainOwnerRequest) GoString() string {
	return s.String()
}

func (s *VerifyVodDomainOwnerRequest) SetDomainName(v string) *VerifyVodDomainOwnerRequest {
	s.DomainName = &v
	return s
}

func (s *VerifyVodDomainOwnerRequest) SetOwnerId(v int64) *VerifyVodDomainOwnerRequest {
	s.OwnerId = &v
	return s
}

func (s *VerifyVodDomainOwnerRequest) SetVerifyType(v string) *VerifyVodDomainOwnerRequest {
	s.VerifyType = &v
	return s
}

type VerifyVodDomainOwnerResponseBody struct {
	Content   *string `json:"Content,omitempty" xml:"Content,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s VerifyVodDomainOwnerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s VerifyVodDomainOwnerResponseBody) GoString() string {
	return s.String()
}

func (s *VerifyVodDomainOwnerResponseBody) SetContent(v string) *VerifyVodDomainOwnerResponseBody {
	s.Content = &v
	return s
}

func (s *VerifyVodDomainOwnerResponseBody) SetRequestId(v string) *VerifyVodDomainOwnerResponseBody {
	s.RequestId = &v
	return s
}

type VerifyVodDomainOwnerResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *VerifyVodDomainOwnerResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s VerifyVodDomainOwnerResponse) String() string {
	return tea.Prettify(s)
}

func (s VerifyVodDomainOwnerResponse) GoString() string {
	return s.String()
}

func (s *VerifyVodDomainOwnerResponse) SetHeaders(v map[string]*string) *VerifyVodDomainOwnerResponse {
	s.Headers = v
	return s
}

func (s *VerifyVodDomainOwnerResponse) SetStatusCode(v int32) *VerifyVodDomainOwnerResponse {
	s.StatusCode = &v
	return s
}

func (s *VerifyVodDomainOwnerResponse) SetBody(v *VerifyVodDomainOwnerResponseBody) *VerifyVodDomainOwnerResponse {
	s.Body = v
	return s
}

type Client struct {
	openapi.Client
}

func NewClient(config *openapi.Config) (*Client, error) {
	client := new(Client)
	err := client.Init(config)
	return client, err
}

func (client *Client) Init(config *openapi.Config) (_err error) {
	_err = client.Client.Init(config)
	if _err != nil {
		return _err
	}
	client.SignatureAlgorithm = tea.String("v2")
	client.EndpointRule = tea.String("regional")
	client.EndpointMap = map[string]*string{
		"ap-northeast-2-pop":          tea.String("vod.aliyuncs.com"),
		"ap-southeast-2":              tea.String("vod.aliyuncs.com"),
		"ap-southeast-3":              tea.String("vod.aliyuncs.com"),
		"cn-beijing-finance-1":        tea.String("vod.aliyuncs.com"),
		"cn-beijing-finance-pop":      tea.String("vod.aliyuncs.com"),
		"cn-beijing-gov-1":            tea.String("vod.aliyuncs.com"),
		"cn-beijing-nu16-b01":         tea.String("vod.aliyuncs.com"),
		"cn-chengdu":                  tea.String("vod.aliyuncs.com"),
		"cn-edge-1":                   tea.String("vod.aliyuncs.com"),
		"cn-fujian":                   tea.String("vod.aliyuncs.com"),
		"cn-haidian-cm12-c01":         tea.String("vod.aliyuncs.com"),
		"cn-hangzhou":                 tea.String("vod.aliyuncs.com"),
		"cn-hangzhou-bj-b01":          tea.String("vod.aliyuncs.com"),
		"cn-hangzhou-finance":         tea.String("vod.aliyuncs.com"),
		"cn-hangzhou-internal-prod-1": tea.String("vod.aliyuncs.com"),
		"cn-hangzhou-internal-test-1": tea.String("vod.aliyuncs.com"),
		"cn-hangzhou-internal-test-2": tea.String("vod.aliyuncs.com"),
		"cn-hangzhou-internal-test-3": tea.String("vod.aliyuncs.com"),
		"cn-hangzhou-test-306":        tea.String("vod.aliyuncs.com"),
		"cn-hongkong":                 tea.String("vod.aliyuncs.com"),
		"cn-hongkong-finance-pop":     tea.String("vod.aliyuncs.com"),
		"cn-huhehaote":                tea.String("vod.aliyuncs.com"),
		"cn-huhehaote-nebula-1":       tea.String("vod.aliyuncs.com"),
		"cn-qingdao":                  tea.String("vod.aliyuncs.com"),
		"cn-qingdao-nebula":           tea.String("vod.aliyuncs.com"),
		"cn-shanghai-et15-b01":        tea.String("vod.aliyuncs.com"),
		"cn-shanghai-et2-b01":         tea.String("vod.aliyuncs.com"),
		"cn-shanghai-finance-1":       tea.String("vod.aliyuncs.com"),
		"cn-shanghai-inner":           tea.String("vod.aliyuncs.com"),
		"cn-shanghai-internal-test-1": tea.String("vod.aliyuncs.com"),
		"cn-shenzhen-finance-1":       tea.String("vod.aliyuncs.com"),
		"cn-shenzhen-inner":           tea.String("vod.aliyuncs.com"),
		"cn-shenzhen-st4-d01":         tea.String("vod.aliyuncs.com"),
		"cn-shenzhen-su18-b01":        tea.String("vod.aliyuncs.com"),
		"cn-wuhan":                    tea.String("vod.aliyuncs.com"),
		"cn-wulanchabu":               tea.String("vod.aliyuncs.com"),
		"cn-yushanfang":               tea.String("vod.aliyuncs.com"),
		"cn-zhangbei":                 tea.String("vod.aliyuncs.com"),
		"cn-zhangbei-na61-b01":        tea.String("vod.aliyuncs.com"),
		"cn-zhangjiakou":              tea.String("vod.aliyuncs.com"),
		"cn-zhangjiakou-na62-a01":     tea.String("vod.aliyuncs.com"),
		"cn-zhengzhou-nebula-1":       tea.String("vod.aliyuncs.com"),
		"eu-west-1":                   tea.String("vod.aliyuncs.com"),
		"eu-west-1-oxs":               tea.String("vod.aliyuncs.com"),
		"me-east-1":                   tea.String("vod.aliyuncs.com"),
		"rus-west-1-pop":              tea.String("vod.aliyuncs.com"),
		"us-east-1":                   tea.String("vod.aliyuncs.com"),
		"us-west-1":                   tea.String("vod.aliyuncs.com"),
	}
	_err = client.CheckConfig(config)
	if _err != nil {
		return _err
	}
	client.Endpoint, _err = client.GetEndpoint(tea.String("vod"), client.RegionId, client.EndpointRule, client.Network, client.Suffix, client.EndpointMap, client.Endpoint)
	if _err != nil {
		return _err
	}

	return nil
}

func (client *Client) GetEndpoint(productId *string, regionId *string, endpointRule *string, network *string, suffix *string, endpointMap map[string]*string, endpoint *string) (_result *string, _err error) {
	if !tea.BoolValue(util.Empty(endpoint)) {
		_result = endpoint
		return _result, _err
	}

	if !tea.BoolValue(util.IsUnset(endpointMap)) && !tea.BoolValue(util.Empty(endpointMap[tea.StringValue(regionId)])) {
		_result = endpointMap[tea.StringValue(regionId)]
		return _result, _err
	}

	_body, _err := endpointutil.GetEndpointRules(productId, regionId, endpointRule, network, suffix)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The type of the AI template. Valid values:
 * *   **AIMediaAudit**: automated review
 * *   **AIImage**: smart thumbnail
 *
 * @param request AddAITemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddAITemplateResponse
 */
func (client *Client) AddAITemplateWithOptions(request *AddAITemplateRequest, runtime *util.RuntimeOptions) (_result *AddAITemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TemplateConfig)) {
		query["TemplateConfig"] = request.TemplateConfig
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateName)) {
		query["TemplateName"] = request.TemplateName
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateType)) {
		query["TemplateType"] = request.TemplateType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddAITemplate"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddAITemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The type of the AI template. Valid values:
 * *   **AIMediaAudit**: automated review
 * *   **AIImage**: smart thumbnail
 *
 * @param request AddAITemplateRequest
 * @return AddAITemplateResponse
 */
func (client *Client) AddAITemplate(request *AddAITemplateRequest) (_result *AddAITemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddAITemplateResponse{}
	_body, _err := client.AddAITemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The level of the category. A value of **0** indicates a level 1 category.
 *
 * @param request AddCategoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddCategoryResponse
 */
func (client *Client) AddCategoryWithOptions(request *AddCategoryRequest, runtime *util.RuntimeOptions) (_result *AddCategoryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CateName)) {
		query["CateName"] = request.CateName
	}

	if !tea.BoolValue(util.IsUnset(request.ParentId)) {
		query["ParentId"] = request.ParentId
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddCategory"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddCategoryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The level of the category. A value of **0** indicates a level 1 category.
 *
 * @param request AddCategoryRequest
 * @return AddCategoryResponse
 */
func (client *Client) AddCategory(request *AddCategoryRequest) (_result *AddCategoryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddCategoryResponse{}
	_body, _err := client.AddCategoryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddEditingProjectWithOptions(request *AddEditingProjectRequest, runtime *util.RuntimeOptions) (_result *AddEditingProjectResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CoverURL)) {
		query["CoverURL"] = request.CoverURL
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Division)) {
		query["Division"] = request.Division
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Timeline)) {
		query["Timeline"] = request.Timeline
	}

	if !tea.BoolValue(util.IsUnset(request.Title)) {
		query["Title"] = request.Title
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddEditingProject"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddEditingProjectResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddEditingProject(request *AddEditingProjectRequest) (_result *AddEditingProjectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddEditingProjectResponse{}
	_body, _err := client.AddEditingProjectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the transcoding template group.
 *
 * @param request AddTranscodeTemplateGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddTranscodeTemplateGroupResponse
 */
func (client *Client) AddTranscodeTemplateGroupWithOptions(request *AddTranscodeTemplateGroupRequest, runtime *util.RuntimeOptions) (_result *AddTranscodeTemplateGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.TranscodeTemplateGroupId)) {
		query["TranscodeTemplateGroupId"] = request.TranscodeTemplateGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.TranscodeTemplateList)) {
		query["TranscodeTemplateList"] = request.TranscodeTemplateList
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddTranscodeTemplateGroup"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddTranscodeTemplateGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the transcoding template group.
 *
 * @param request AddTranscodeTemplateGroupRequest
 * @return AddTranscodeTemplateGroupResponse
 */
func (client *Client) AddTranscodeTemplateGroup(request *AddTranscodeTemplateGroupRequest) (_result *AddTranscodeTemplateGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddTranscodeTemplateGroupResponse{}
	_body, _err := client.AddTranscodeTemplateGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request AddVodDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddVodDomainResponse
 */
func (client *Client) AddVodDomainWithOptions(request *AddVodDomainRequest, runtime *util.RuntimeOptions) (_result *AddVodDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CheckUrl)) {
		query["CheckUrl"] = request.CheckUrl
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Scope)) {
		query["Scope"] = request.Scope
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.Sources)) {
		query["Sources"] = request.Sources
	}

	if !tea.BoolValue(util.IsUnset(request.TopLevelDomain)) {
		query["TopLevelDomain"] = request.TopLevelDomain
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddVodDomain"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddVodDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request AddVodDomainRequest
 * @return AddVodDomainResponse
 */
func (client *Client) AddVodDomain(request *AddVodDomainRequest) (_result *AddVodDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddVodDomainResponse{}
	_body, _err := client.AddVodDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The type of the template. Set the value to **Snapshot**.
 *
 * @param request AddVodTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddVodTemplateResponse
 */
func (client *Client) AddVodTemplateWithOptions(request *AddVodTemplateRequest, runtime *util.RuntimeOptions) (_result *AddVodTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateConfig)) {
		query["TemplateConfig"] = request.TemplateConfig
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateType)) {
		query["TemplateType"] = request.TemplateType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddVodTemplate"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddVodTemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The type of the template. Set the value to **Snapshot**.
 *
 * @param request AddVodTemplateRequest
 * @return AddVodTemplateResponse
 */
func (client *Client) AddVodTemplate(request *AddVodTemplateRequest) (_result *AddVodTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddVodTemplateResponse{}
	_body, _err := client.AddVodTemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The name of the watermark. Only letters and digits are supported.
 * *   The name can be up to 128 bytes in length.
 * *   The value must be encoded in UTF-8.
 *
 * @param request AddWatermarkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddWatermarkResponse
 */
func (client *Client) AddWatermarkWithOptions(request *AddWatermarkRequest, runtime *util.RuntimeOptions) (_result *AddWatermarkResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.FileUrl)) {
		query["FileUrl"] = request.FileUrl
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	if !tea.BoolValue(util.IsUnset(request.WatermarkConfig)) {
		query["WatermarkConfig"] = request.WatermarkConfig
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddWatermark"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddWatermarkResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The name of the watermark. Only letters and digits are supported.
 * *   The name can be up to 128 bytes in length.
 * *   The value must be encoded in UTF-8.
 *
 * @param request AddWatermarkRequest
 * @return AddWatermarkResponse
 */
func (client *Client) AddWatermark(request *AddWatermarkRequest) (_result *AddWatermarkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddWatermarkResponse{}
	_body, _err := client.AddWatermarkWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The name of the policy that was not found.
 *
 * @param request AttachAppPolicyToIdentityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AttachAppPolicyToIdentityResponse
 */
func (client *Client) AttachAppPolicyToIdentityWithOptions(request *AttachAppPolicyToIdentityRequest, runtime *util.RuntimeOptions) (_result *AttachAppPolicyToIdentityResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.IdentityName)) {
		query["IdentityName"] = request.IdentityName
	}

	if !tea.BoolValue(util.IsUnset(request.IdentityType)) {
		query["IdentityType"] = request.IdentityType
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyNames)) {
		query["PolicyNames"] = request.PolicyNames
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AttachAppPolicyToIdentity"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AttachAppPolicyToIdentityResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The name of the policy that was not found.
 *
 * @param request AttachAppPolicyToIdentityRequest
 * @return AttachAppPolicyToIdentityResponse
 */
func (client *Client) AttachAppPolicyToIdentity(request *AttachAppPolicyToIdentityRequest) (_result *AttachAppPolicyToIdentityResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AttachAppPolicyToIdentityResponse{}
	_body, _err := client.AttachAppPolicyToIdentityWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request BatchSetVodDomainConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchSetVodDomainConfigsResponse
 */
func (client *Client) BatchSetVodDomainConfigsWithOptions(request *BatchSetVodDomainConfigsRequest, runtime *util.RuntimeOptions) (_result *BatchSetVodDomainConfigsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainNames)) {
		query["DomainNames"] = request.DomainNames
	}

	if !tea.BoolValue(util.IsUnset(request.Functions)) {
		query["Functions"] = request.Functions
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchSetVodDomainConfigs"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchSetVodDomainConfigsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request BatchSetVodDomainConfigsRequest
 * @return BatchSetVodDomainConfigsResponse
 */
func (client *Client) BatchSetVodDomainConfigs(request *BatchSetVodDomainConfigsRequest) (_result *BatchSetVodDomainConfigsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchSetVodDomainConfigsResponse{}
	_body, _err := client.BatchSetVodDomainConfigsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The operation that you want to perform. Set the value to **BatchStartVodDomain**.
 *
 * @param request BatchStartVodDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchStartVodDomainResponse
 */
func (client *Client) BatchStartVodDomainWithOptions(request *BatchStartVodDomainRequest, runtime *util.RuntimeOptions) (_result *BatchStartVodDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainNames)) {
		query["DomainNames"] = request.DomainNames
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchStartVodDomain"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchStartVodDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The operation that you want to perform. Set the value to **BatchStartVodDomain**.
 *
 * @param request BatchStartVodDomainRequest
 * @return BatchStartVodDomainResponse
 */
func (client *Client) BatchStartVodDomain(request *BatchStartVodDomainRequest) (_result *BatchStartVodDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchStartVodDomainResponse{}
	_body, _err := client.BatchStartVodDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The operation that you want to perform. Set the value to **BatchStopVodDomain**.
 *
 * @param request BatchStopVodDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchStopVodDomainResponse
 */
func (client *Client) BatchStopVodDomainWithOptions(request *BatchStopVodDomainRequest, runtime *util.RuntimeOptions) (_result *BatchStopVodDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainNames)) {
		query["DomainNames"] = request.DomainNames
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchStopVodDomain"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchStopVodDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The operation that you want to perform. Set the value to **BatchStopVodDomain**.
 *
 * @param request BatchStopVodDomainRequest
 * @return BatchStopVodDomainResponse
 */
func (client *Client) BatchStopVodDomain(request *BatchStopVodDomainRequest) (_result *BatchStopVodDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchStopVodDomainResponse{}
	_body, _err := client.BatchStopVodDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The upload URLs of source files. Separate multiple URLs with commas (,). You can specify a maximum of 10 URLs.
 * > *   You must encode the URLs before you use the URLs.
 * > *   You must set one of the JobIds and the UploadUrls parameters. If you set both the JobIds and UploadUrls parameters, only the value of the JobIds parameter takes effect.
 *
 * @param request CancelUrlUploadJobsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelUrlUploadJobsResponse
 */
func (client *Client) CancelUrlUploadJobsWithOptions(request *CancelUrlUploadJobsRequest, runtime *util.RuntimeOptions) (_result *CancelUrlUploadJobsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.JobIds)) {
		query["JobIds"] = request.JobIds
	}

	if !tea.BoolValue(util.IsUnset(request.UploadUrls)) {
		query["UploadUrls"] = request.UploadUrls
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CancelUrlUploadJobs"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CancelUrlUploadJobsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The upload URLs of source files. Separate multiple URLs with commas (,). You can specify a maximum of 10 URLs.
 * > *   You must encode the URLs before you use the URLs.
 * > *   You must set one of the JobIds and the UploadUrls parameters. If you set both the JobIds and UploadUrls parameters, only the value of the JobIds parameter takes effect.
 *
 * @param request CancelUrlUploadJobsRequest
 * @return CancelUrlUploadJobsResponse
 */
func (client *Client) CancelUrlUploadJobs(request *CancelUrlUploadJobsRequest) (_result *CancelUrlUploadJobsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CancelUrlUploadJobsResponse{}
	_body, _err := client.CancelUrlUploadJobsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The description of the application.
 * - The description can contain up to 512 characters in length.
 * - The description can contain only UTF-8 characters.
 *
 * @param request CreateAppInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAppInfoResponse
 */
func (client *Client) CreateAppInfoWithOptions(request *CreateAppInfoRequest, runtime *util.RuntimeOptions) (_result *CreateAppInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateAppInfo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateAppInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The description of the application.
 * - The description can contain up to 512 characters in length.
 * - The description can contain only UTF-8 characters.
 *
 * @param request CreateAppInfoRequest
 * @return CreateAppInfoResponse
 */
func (client *Client) CreateAppInfo(request *CreateAppInfoRequest) (_result *CreateAppInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateAppInfoResponse{}
	_body, _err := client.CreateAppInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateAuditWithOptions(request *CreateAuditRequest, runtime *util.RuntimeOptions) (_result *CreateAuditResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AuditContent)) {
		query["AuditContent"] = request.AuditContent
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateAudit"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateAuditResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateAudit(request *CreateAuditRequest) (_result *CreateAuditResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateAuditResponse{}
	_body, _err := client.CreateAuditWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The type of the media asset. Valid values:
 * *   **watermark**
 * *   **subtitle**
 * *   **material**
 *
 * @param request CreateUploadAttachedMediaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateUploadAttachedMediaResponse
 */
func (client *Client) CreateUploadAttachedMediaWithOptions(request *CreateUploadAttachedMediaRequest, runtime *util.RuntimeOptions) (_result *CreateUploadAttachedMediaResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.BusinessType)) {
		query["BusinessType"] = request.BusinessType
	}

	if !tea.BoolValue(util.IsUnset(request.CateIds)) {
		query["CateIds"] = request.CateIds
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.FileName)) {
		query["FileName"] = request.FileName
	}

	if !tea.BoolValue(util.IsUnset(request.FileSize)) {
		query["FileSize"] = request.FileSize
	}

	if !tea.BoolValue(util.IsUnset(request.MediaExt)) {
		query["MediaExt"] = request.MediaExt
	}

	if !tea.BoolValue(util.IsUnset(request.StorageLocation)) {
		query["StorageLocation"] = request.StorageLocation
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.Title)) {
		query["Title"] = request.Title
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateUploadAttachedMedia"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateUploadAttachedMediaResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The type of the media asset. Valid values:
 * *   **watermark**
 * *   **subtitle**
 * *   **material**
 *
 * @param request CreateUploadAttachedMediaRequest
 * @return CreateUploadAttachedMediaResponse
 */
func (client *Client) CreateUploadAttachedMedia(request *CreateUploadAttachedMediaRequest) (_result *CreateUploadAttachedMediaResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateUploadAttachedMediaResponse{}
	_body, _err := client.CreateUploadAttachedMediaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The custom configurations. For example, you can specify callback configurations and upload acceleration configurations. The value is a JSON string. For more information, see the "UserData: specifies the custom configurations for media upload" section of the [Request parameters](~~86952~~) topic.
 * > *   The callback configurations take effect only after you specify the HTTP callback URL and select specific callback events in the ApsaraVideo VOD console. For more information about how to configure HTTP callback settings in the ApsaraVideo VOD console, see [Configure callback settings](~~86071~~).
 * > *   To use the upload acceleration feature, submit a [ticket](https://ticket-intl.console.aliyun.com/#/ticket/createIndex) to enable this feature. For more information, see [Overview](~~55396~~).
 *
 * @param request CreateUploadImageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateUploadImageResponse
 */
func (client *Client) CreateUploadImageWithOptions(request *CreateUploadImageRequest, runtime *util.RuntimeOptions) (_result *CreateUploadImageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.CateId)) {
		query["CateId"] = request.CateId
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.ImageExt)) {
		query["ImageExt"] = request.ImageExt
	}

	if !tea.BoolValue(util.IsUnset(request.ImageType)) {
		query["ImageType"] = request.ImageType
	}

	if !tea.BoolValue(util.IsUnset(request.OriginalFileName)) {
		query["OriginalFileName"] = request.OriginalFileName
	}

	if !tea.BoolValue(util.IsUnset(request.StorageLocation)) {
		query["StorageLocation"] = request.StorageLocation
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.Title)) {
		query["Title"] = request.Title
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateUploadImage"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateUploadImageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The custom configurations. For example, you can specify callback configurations and upload acceleration configurations. The value is a JSON string. For more information, see the "UserData: specifies the custom configurations for media upload" section of the [Request parameters](~~86952~~) topic.
 * > *   The callback configurations take effect only after you specify the HTTP callback URL and select specific callback events in the ApsaraVideo VOD console. For more information about how to configure HTTP callback settings in the ApsaraVideo VOD console, see [Configure callback settings](~~86071~~).
 * > *   To use the upload acceleration feature, submit a [ticket](https://ticket-intl.console.aliyun.com/#/ticket/createIndex) to enable this feature. For more information, see [Overview](~~55396~~).
 *
 * @param request CreateUploadImageRequest
 * @return CreateUploadImageResponse
 */
func (client *Client) CreateUploadImage(request *CreateUploadImageRequest) (_result *CreateUploadImageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateUploadImageResponse{}
	_body, _err := client.CreateUploadImageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Obtains the upload URLs and credentials for media files and creates media assets in ApsaraVideo VOD.
 *
 * @param request CreateUploadVideoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateUploadVideoResponse
 */
func (client *Client) CreateUploadVideoWithOptions(request *CreateUploadVideoRequest, runtime *util.RuntimeOptions) (_result *CreateUploadVideoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.CateId)) {
		query["CateId"] = request.CateId
	}

	if !tea.BoolValue(util.IsUnset(request.CoverURL)) {
		query["CoverURL"] = request.CoverURL
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.FileName)) {
		query["FileName"] = request.FileName
	}

	if !tea.BoolValue(util.IsUnset(request.FileSize)) {
		query["FileSize"] = request.FileSize
	}

	if !tea.BoolValue(util.IsUnset(request.StorageLocation)) {
		query["StorageLocation"] = request.StorageLocation
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateGroupId)) {
		query["TemplateGroupId"] = request.TemplateGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Title)) {
		query["Title"] = request.Title
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	if !tea.BoolValue(util.IsUnset(request.WorkflowId)) {
		query["WorkflowId"] = request.WorkflowId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateUploadVideo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateUploadVideoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Obtains the upload URLs and credentials for media files and creates media assets in ApsaraVideo VOD.
 *
 * @param request CreateUploadVideoRequest
 * @return CreateUploadVideoResponse
 */
func (client *Client) CreateUploadVideo(request *CreateUploadVideoRequest) (_result *CreateUploadVideoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateUploadVideoResponse{}
	_body, _err := client.CreateUploadVideoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DecryptKMSDataKeyWithOptions(request *DecryptKMSDataKeyRequest, runtime *util.RuntimeOptions) (_result *DecryptKMSDataKeyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CipherText)) {
		query["CipherText"] = request.CipherText
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DecryptKMSDataKey"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DecryptKMSDataKeyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DecryptKMSDataKey(request *DecryptKMSDataKeyRequest) (_result *DecryptKMSDataKeyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DecryptKMSDataKeyResponse{}
	_body, _err := client.DecryptKMSDataKeyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation deletes only information about images that are submitted for AI processing. The image files are not deleted.
 * - The smart thumbnail feature is not supported. You cannot call this operation.
 * - This operation deletes only information about images that are submitted for AI processing. The image files are not deleted.
 * ### QPS limit
 * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations in ApsaraVideo VoD](~~342790~~).
 *
 * @param request DeleteAIImageInfosRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAIImageInfosResponse
 */
func (client *Client) DeleteAIImageInfosWithOptions(request *DeleteAIImageInfosRequest, runtime *util.RuntimeOptions) (_result *DeleteAIImageInfosResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AIImageInfoIds)) {
		query["AIImageInfoIds"] = request.AIImageInfoIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAIImageInfos"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteAIImageInfosResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation deletes only information about images that are submitted for AI processing. The image files are not deleted.
 * - The smart thumbnail feature is not supported. You cannot call this operation.
 * - This operation deletes only information about images that are submitted for AI processing. The image files are not deleted.
 * ### QPS limit
 * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations in ApsaraVideo VoD](~~342790~~).
 *
 * @param request DeleteAIImageInfosRequest
 * @return DeleteAIImageInfosResponse
 */
func (client *Client) DeleteAIImageInfos(request *DeleteAIImageInfosRequest) (_result *DeleteAIImageInfosResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAIImageInfosResponse{}
	_body, _err := client.DeleteAIImageInfosWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the AI template. You can use one of the following methods to obtain the ID of the AI template:
 * *   Call the [AddAITemplate](~~102930~~) operation to add an AI template if no AI template exists. The value of TemplateId from the response is the ID of the AI template.
 * *   Call the [ListAITemplate](~~102936~~) operation if the template already exists. The value of TemplateId from the response is the ID of the AI template.
 *
 * @param request DeleteAITemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAITemplateResponse
 */
func (client *Client) DeleteAITemplateWithOptions(request *DeleteAITemplateRequest, runtime *util.RuntimeOptions) (_result *DeleteAITemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		query["TemplateId"] = request.TemplateId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAITemplate"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteAITemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the AI template. You can use one of the following methods to obtain the ID of the AI template:
 * *   Call the [AddAITemplate](~~102930~~) operation to add an AI template if no AI template exists. The value of TemplateId from the response is the ID of the AI template.
 * *   Call the [ListAITemplate](~~102936~~) operation if the template already exists. The value of TemplateId from the response is the ID of the AI template.
 *
 * @param request DeleteAITemplateRequest
 * @return DeleteAITemplateResponse
 */
func (client *Client) DeleteAITemplate(request *DeleteAITemplateRequest) (_result *DeleteAITemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAITemplateResponse{}
	_body, _err := client.DeleteAITemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request DeleteAppInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAppInfoResponse
 */
func (client *Client) DeleteAppInfoWithOptions(request *DeleteAppInfoRequest, runtime *util.RuntimeOptions) (_result *DeleteAppInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAppInfo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteAppInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request DeleteAppInfoRequest
 * @return DeleteAppInfoResponse
 */
func (client *Client) DeleteAppInfo(request *DeleteAppInfoRequest) (_result *DeleteAppInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAppInfoResponse{}
	_body, _err := client.DeleteAppInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request DeleteAttachedMediaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAttachedMediaResponse
 */
func (client *Client) DeleteAttachedMediaWithOptions(request *DeleteAttachedMediaRequest, runtime *util.RuntimeOptions) (_result *DeleteAttachedMediaResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaIds)) {
		query["MediaIds"] = request.MediaIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAttachedMedia"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteAttachedMediaResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request DeleteAttachedMediaRequest
 * @return DeleteAttachedMediaResponse
 */
func (client *Client) DeleteAttachedMedia(request *DeleteAttachedMediaRequest) (_result *DeleteAttachedMediaResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAttachedMediaResponse{}
	_body, _err := client.DeleteAttachedMediaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request DeleteCategoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCategoryResponse
 */
func (client *Client) DeleteCategoryWithOptions(request *DeleteCategoryRequest, runtime *util.RuntimeOptions) (_result *DeleteCategoryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CateId)) {
		query["CateId"] = request.CateId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteCategory"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteCategoryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request DeleteCategoryRequest
 * @return DeleteCategoryResponse
 */
func (client *Client) DeleteCategory(request *DeleteCategoryRequest) (_result *DeleteCategoryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteCategoryResponse{}
	_body, _err := client.DeleteCategoryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteDynamicImageWithOptions(request *DeleteDynamicImageRequest, runtime *util.RuntimeOptions) (_result *DeleteDynamicImageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DynamicImageIds)) {
		query["DynamicImageIds"] = request.DynamicImageIds
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDynamicImage"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDynamicImageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteDynamicImage(request *DeleteDynamicImageRequest) (_result *DeleteDynamicImageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDynamicImageResponse{}
	_body, _err := client.DeleteDynamicImageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteEditingProjectWithOptions(request *DeleteEditingProjectRequest, runtime *util.RuntimeOptions) (_result *DeleteEditingProjectResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIds)) {
		query["ProjectIds"] = request.ProjectIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteEditingProject"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteEditingProjectResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteEditingProject(request *DeleteEditingProjectRequest) (_result *DeleteEditingProjectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteEditingProjectResponse{}
	_body, _err := client.DeleteEditingProjectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The URL of the image.
 * *   This parameter only takes effect when the **DeleteImageType** parameter is set to **ImageURL**. In this case, you must set this parameter.
 * *   Encode multiple image URLs and separate them with commas (,).
 * *   The use of special characters in image URLs may lead to the failure to delete the images. To prevent such failure, you must encode the image URLs before you concatenate them into a string with commas (,).
 *
 * @param request DeleteImageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteImageResponse
 */
func (client *Client) DeleteImageWithOptions(request *DeleteImageRequest, runtime *util.RuntimeOptions) (_result *DeleteImageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeleteImageType)) {
		query["DeleteImageType"] = request.DeleteImageType
	}

	if !tea.BoolValue(util.IsUnset(request.ImageIds)) {
		query["ImageIds"] = request.ImageIds
	}

	if !tea.BoolValue(util.IsUnset(request.ImageType)) {
		query["ImageType"] = request.ImageType
	}

	if !tea.BoolValue(util.IsUnset(request.ImageURLs)) {
		query["ImageURLs"] = request.ImageURLs
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteImage"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteImageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The URL of the image.
 * *   This parameter only takes effect when the **DeleteImageType** parameter is set to **ImageURL**. In this case, you must set this parameter.
 * *   Encode multiple image URLs and separate them with commas (,).
 * *   The use of special characters in image URLs may lead to the failure to delete the images. To prevent such failure, you must encode the image URLs before you concatenate them into a string with commas (,).
 *
 * @param request DeleteImageRequest
 * @return DeleteImageResponse
 */
func (client *Client) DeleteImage(request *DeleteImageRequest) (_result *DeleteImageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteImageResponse{}
	_body, _err := client.DeleteImageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The operation that you want to perform. Set the value to **DeleteMessageCallback**.
 *
 * @param request DeleteMessageCallbackRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMessageCallbackResponse
 */
func (client *Client) DeleteMessageCallbackWithOptions(request *DeleteMessageCallbackRequest, runtime *util.RuntimeOptions) (_result *DeleteMessageCallbackResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteMessageCallback"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteMessageCallbackResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The operation that you want to perform. Set the value to **DeleteMessageCallback**.
 *
 * @param request DeleteMessageCallbackRequest
 * @return DeleteMessageCallbackResponse
 */
func (client *Client) DeleteMessageCallback(request *DeleteMessageCallbackRequest) (_result *DeleteMessageCallbackResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteMessageCallbackResponse{}
	_body, _err := client.DeleteMessageCallbackWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The IDs of the videos that do not exist.
 *
 * @param request DeleteMezzaninesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMezzaninesResponse
 */
func (client *Client) DeleteMezzaninesWithOptions(request *DeleteMezzaninesRequest, runtime *util.RuntimeOptions) (_result *DeleteMezzaninesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Force)) {
		query["Force"] = request.Force
	}

	if !tea.BoolValue(util.IsUnset(request.VideoIds)) {
		query["VideoIds"] = request.VideoIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteMezzanines"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteMezzaninesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The IDs of the videos that do not exist.
 *
 * @param request DeleteMezzaninesRequest
 * @return DeleteMezzaninesResponse
 */
func (client *Client) DeleteMezzanines(request *DeleteMezzaninesRequest) (_result *DeleteMezzaninesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteMezzaninesResponse{}
	_body, _err := client.DeleteMezzaninesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request DeleteMultipartUploadRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMultipartUploadResponse
 */
func (client *Client) DeleteMultipartUploadWithOptions(request *DeleteMultipartUploadRequest, runtime *util.RuntimeOptions) (_result *DeleteMultipartUploadResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaId)) {
		query["MediaId"] = request.MediaId
	}

	if !tea.BoolValue(util.IsUnset(request.MediaType)) {
		query["MediaType"] = request.MediaType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteMultipartUpload"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteMultipartUploadResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request DeleteMultipartUploadRequest
 * @return DeleteMultipartUploadResponse
 */
func (client *Client) DeleteMultipartUpload(request *DeleteMultipartUploadRequest) (_result *DeleteMultipartUploadResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteMultipartUploadResponse{}
	_body, _err := client.DeleteMultipartUploadWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteStreamWithOptions(request *DeleteStreamRequest, runtime *util.RuntimeOptions) (_result *DeleteStreamResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.JobIds)) {
		query["JobIds"] = request.JobIds
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteStream"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteStreamResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteStream(request *DeleteStreamRequest) (_result *DeleteStreamResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteStreamResponse{}
	_body, _err := client.DeleteStreamWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Specifies whether to forcibly delete the entire transcoding template group. Valid values:
 * *   **true**: deletes the entire transcoding template group and its transcoding templates.
 * *   **false**: removes the specified transcoding templates from the transcoding template group. This is the default value.
 *
 * @param request DeleteTranscodeTemplateGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTranscodeTemplateGroupResponse
 */
func (client *Client) DeleteTranscodeTemplateGroupWithOptions(request *DeleteTranscodeTemplateGroupRequest, runtime *util.RuntimeOptions) (_result *DeleteTranscodeTemplateGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ForceDelGroup)) {
		query["ForceDelGroup"] = request.ForceDelGroup
	}

	if !tea.BoolValue(util.IsUnset(request.TranscodeTemplateGroupId)) {
		query["TranscodeTemplateGroupId"] = request.TranscodeTemplateGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.TranscodeTemplateIds)) {
		query["TranscodeTemplateIds"] = request.TranscodeTemplateIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteTranscodeTemplateGroup"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteTranscodeTemplateGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Specifies whether to forcibly delete the entire transcoding template group. Valid values:
 * *   **true**: deletes the entire transcoding template group and its transcoding templates.
 * *   **false**: removes the specified transcoding templates from the transcoding template group. This is the default value.
 *
 * @param request DeleteTranscodeTemplateGroupRequest
 * @return DeleteTranscodeTemplateGroupResponse
 */
func (client *Client) DeleteTranscodeTemplateGroup(request *DeleteTranscodeTemplateGroupRequest) (_result *DeleteTranscodeTemplateGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteTranscodeTemplateGroupResponse{}
	_body, _err := client.DeleteTranscodeTemplateGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The list of video IDs. Separate multiple IDs with commas (,). A maximum of 20 IDs can be specified. You can obtain a video ID in one of the following ways:
 * *   If the video is uploaded by using the [ApsaraVideo VOD console](https://vod.console.aliyun.com), log on to the console and choose **Media Files** > **Audio/Video** to view the ID of the video.
 * *   If the video is uploaded by calling the [CreateUploadVideo](~~55407~~) operation, the video ID is the VideoId value in the response.
 * *   You can also call the [SearchMedia](~~86044~~) operation to obtain the video ID, which is the VideoId value in the response.
 *
 * @param request DeleteVideoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVideoResponse
 */
func (client *Client) DeleteVideoWithOptions(request *DeleteVideoRequest, runtime *util.RuntimeOptions) (_result *DeleteVideoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.VideoIds)) {
		query["VideoIds"] = request.VideoIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteVideo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteVideoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The list of video IDs. Separate multiple IDs with commas (,). A maximum of 20 IDs can be specified. You can obtain a video ID in one of the following ways:
 * *   If the video is uploaded by using the [ApsaraVideo VOD console](https://vod.console.aliyun.com), log on to the console and choose **Media Files** > **Audio/Video** to view the ID of the video.
 * *   If the video is uploaded by calling the [CreateUploadVideo](~~55407~~) operation, the video ID is the VideoId value in the response.
 * *   You can also call the [SearchMedia](~~86044~~) operation to obtain the video ID, which is the VideoId value in the response.
 *
 * @param request DeleteVideoRequest
 * @return DeleteVideoResponse
 */
func (client *Client) DeleteVideo(request *DeleteVideoRequest) (_result *DeleteVideoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteVideoResponse{}
	_body, _err := client.DeleteVideoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request DeleteVodDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVodDomainResponse
 */
func (client *Client) DeleteVodDomainWithOptions(request *DeleteVodDomainRequest, runtime *util.RuntimeOptions) (_result *DeleteVodDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteVodDomain"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteVodDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request DeleteVodDomainRequest
 * @return DeleteVodDomainResponse
 */
func (client *Client) DeleteVodDomain(request *DeleteVodDomainRequest) (_result *DeleteVodDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteVodDomainResponse{}
	_body, _err := client.DeleteVodDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request DeleteVodSpecificConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVodSpecificConfigResponse
 */
func (client *Client) DeleteVodSpecificConfigWithOptions(request *DeleteVodSpecificConfigRequest, runtime *util.RuntimeOptions) (_result *DeleteVodSpecificConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigId)) {
		query["ConfigId"] = request.ConfigId
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteVodSpecificConfig"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteVodSpecificConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request DeleteVodSpecificConfigRequest
 * @return DeleteVodSpecificConfigResponse
 */
func (client *Client) DeleteVodSpecificConfig(request *DeleteVodSpecificConfigRequest) (_result *DeleteVodSpecificConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteVodSpecificConfigResponse{}
	_body, _err := client.DeleteVodSpecificConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteVodTemplateWithOptions(request *DeleteVodTemplateRequest, runtime *util.RuntimeOptions) (_result *DeleteVodTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.VodTemplateId)) {
		query["VodTemplateId"] = request.VodTemplateId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteVodTemplate"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteVodTemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteVodTemplate(request *DeleteVodTemplateRequest) (_result *DeleteVodTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteVodTemplateResponse{}
	_body, _err := client.DeleteVodTemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request DeleteWatermarkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteWatermarkResponse
 */
func (client *Client) DeleteWatermarkWithOptions(request *DeleteWatermarkRequest, runtime *util.RuntimeOptions) (_result *DeleteWatermarkResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.WatermarkId)) {
		query["WatermarkId"] = request.WatermarkId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteWatermark"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteWatermarkResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request DeleteWatermarkRequest
 * @return DeleteWatermarkResponse
 */
func (client *Client) DeleteWatermark(request *DeleteWatermarkRequest) (_result *DeleteWatermarkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteWatermarkResponse{}
	_body, _err := client.DeleteWatermarkWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The number of entries to return on each page. Default value: **100**. Maximum value: **1000**.
 *
 * @param request DescribePlayTopVideosRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePlayTopVideosResponse
 */
func (client *Client) DescribePlayTopVideosWithOptions(request *DescribePlayTopVideosRequest, runtime *util.RuntimeOptions) (_result *DescribePlayTopVideosResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BizDate)) {
		query["BizDate"] = request.BizDate
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		query["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePlayTopVideos"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePlayTopVideosResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The number of entries to return on each page. Default value: **100**. Maximum value: **1000**.
 *
 * @param request DescribePlayTopVideosRequest
 * @return DescribePlayTopVideosResponse
 */
func (client *Client) DescribePlayTopVideos(request *DescribePlayTopVideosRequest) (_result *DescribePlayTopVideosResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePlayTopVideosResponse{}
	_body, _err := client.DescribePlayTopVideosWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
 *
 * @param request DescribePlayUserAvgRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePlayUserAvgResponse
 */
func (client *Client) DescribePlayUserAvgWithOptions(request *DescribePlayUserAvgRequest, runtime *util.RuntimeOptions) (_result *DescribePlayUserAvgResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePlayUserAvg"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePlayUserAvgResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
 *
 * @param request DescribePlayUserAvgRequest
 * @return DescribePlayUserAvgResponse
 */
func (client *Client) DescribePlayUserAvg(request *DescribePlayUserAvgRequest) (_result *DescribePlayUserAvgResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePlayUserAvgResponse{}
	_body, _err := client.DescribePlayUserAvgWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The total number of unique visitors who use ApsaraVideo Player SDK for Flash.
 *
 * @param request DescribePlayUserTotalRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePlayUserTotalResponse
 */
func (client *Client) DescribePlayUserTotalWithOptions(request *DescribePlayUserTotalRequest, runtime *util.RuntimeOptions) (_result *DescribePlayUserTotalResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePlayUserTotal"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePlayUserTotalResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The total number of unique visitors who use ApsaraVideo Player SDK for Flash.
 *
 * @param request DescribePlayUserTotalRequest
 * @return DescribePlayUserTotalResponse
 */
func (client *Client) DescribePlayUserTotal(request *DescribePlayUserTotalRequest) (_result *DescribePlayUserTotalResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePlayUserTotalResponse{}
	_body, _err := client.DescribePlayUserTotalWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
 *
 * @param request DescribePlayVideoStatisRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribePlayVideoStatisResponse
 */
func (client *Client) DescribePlayVideoStatisWithOptions(request *DescribePlayVideoStatisRequest, runtime *util.RuntimeOptions) (_result *DescribePlayVideoStatisResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePlayVideoStatis"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePlayVideoStatisResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.
 *
 * @param request DescribePlayVideoStatisRequest
 * @return DescribePlayVideoStatisResponse
 */
func (client *Client) DescribePlayVideoStatis(request *DescribePlayVideoStatisRequest) (_result *DescribePlayVideoStatisResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePlayVideoStatisResponse{}
	_body, _err := client.DescribePlayVideoStatisWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > *   This operation is available only in the **China (Shanghai)** region.
 * >*   If the time range to query is less than or equal to seven days, the system returns the statistics collected on an hourly basis. If the time range to query is greater than seven days, the system returns the statistics collected on a daily basis. The maximum time range that you can specify to query is 31 days.
 *
 * @param request DescribeVodAIDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVodAIDataResponse
 */
func (client *Client) DescribeVodAIDataWithOptions(request *DescribeVodAIDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodAIDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AIType)) {
		query["AIType"] = request.AIType
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodAIData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVodAIDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > *   This operation is available only in the **China (Shanghai)** region.
 * >*   If the time range to query is less than or equal to seven days, the system returns the statistics collected on an hourly basis. If the time range to query is greater than seven days, the system returns the statistics collected on a daily basis. The maximum time range that you can specify to query is 31 days.
 *
 * @param request DescribeVodAIDataRequest
 * @return DescribeVodAIDataResponse
 */
func (client *Client) DescribeVodAIData(request *DescribeVodAIDataRequest) (_result *DescribeVodAIDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodAIDataResponse{}
	_body, _err := client.DescribeVodAIDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The domain name for CDN.
 *
 * @param request DescribeVodCertificateListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVodCertificateListResponse
 */
func (client *Client) DescribeVodCertificateListWithOptions(request *DescribeVodCertificateListRequest, runtime *util.RuntimeOptions) (_result *DescribeVodCertificateListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodCertificateList"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVodCertificateListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The domain name for CDN.
 *
 * @param request DescribeVodCertificateListRequest
 * @return DescribeVodCertificateListResponse
 */
func (client *Client) DescribeVodCertificateList(request *DescribeVodCertificateListRequest) (_result *DescribeVodCertificateListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodCertificateListResponse{}
	_body, _err := client.DescribeVodCertificateListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The domain name for CDN.
 *
 * @param request DescribeVodDomainBpsDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVodDomainBpsDataResponse
 */
func (client *Client) DescribeVodDomainBpsDataWithOptions(request *DescribeVodDomainBpsDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodDomainBpsDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodDomainBpsData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVodDomainBpsDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The domain name for CDN.
 *
 * @param request DescribeVodDomainBpsDataRequest
 * @return DescribeVodDomainBpsDataResponse
 */
func (client *Client) DescribeVodDomainBpsData(request *DescribeVodDomainBpsDataRequest) (_result *DescribeVodDomainBpsDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodDomainBpsDataResponse{}
	_body, _err := client.DescribeVodDomainBpsDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeVodDomainCertificateInfoWithOptions(request *DescribeVodDomainCertificateInfoRequest, runtime *util.RuntimeOptions) (_result *DescribeVodDomainCertificateInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodDomainCertificateInfo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVodDomainCertificateInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeVodDomainCertificateInfo(request *DescribeVodDomainCertificateInfoRequest) (_result *DescribeVodDomainCertificateInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodDomainCertificateInfoResponse{}
	_body, _err := client.DescribeVodDomainCertificateInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The name of the function.
 *
 * @param request DescribeVodDomainConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVodDomainConfigsResponse
 */
func (client *Client) DescribeVodDomainConfigsWithOptions(request *DescribeVodDomainConfigsRequest, runtime *util.RuntimeOptions) (_result *DescribeVodDomainConfigsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.FunctionNames)) {
		query["FunctionNames"] = request.FunctionNames
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodDomainConfigs"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVodDomainConfigsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The name of the function.
 *
 * @param request DescribeVodDomainConfigsRequest
 * @return DescribeVodDomainConfigsResponse
 */
func (client *Client) DescribeVodDomainConfigs(request *DescribeVodDomainConfigsRequest) (_result *DescribeVodDomainConfigsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodDomainConfigsResponse{}
	_body, _err := client.DescribeVodDomainConfigsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The description of the domain name for CDN.
 *
 * @param request DescribeVodDomainDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVodDomainDetailResponse
 */
func (client *Client) DescribeVodDomainDetailWithOptions(request *DescribeVodDomainDetailRequest, runtime *util.RuntimeOptions) (_result *DescribeVodDomainDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodDomainDetail"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVodDomainDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The description of the domain name for CDN.
 *
 * @param request DescribeVodDomainDetailRequest
 * @return DescribeVodDomainDetailResponse
 */
func (client *Client) DescribeVodDomainDetail(request *DescribeVodDomainDetailRequest) (_result *DescribeVodDomainDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodDomainDetailResponse{}
	_body, _err := client.DescribeVodDomainDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The total number of entries returned on the current page.
 *
 * @param request DescribeVodDomainLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVodDomainLogResponse
 */
func (client *Client) DescribeVodDomainLogWithOptions(request *DescribeVodDomainLogRequest, runtime *util.RuntimeOptions) (_result *DescribeVodDomainLogResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodDomainLog"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVodDomainLogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The total number of entries returned on the current page.
 *
 * @param request DescribeVodDomainLogRequest
 * @return DescribeVodDomainLogResponse
 */
func (client *Client) DescribeVodDomainLog(request *DescribeVodDomainLogRequest) (_result *DescribeVodDomainLogResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodDomainLogResponse{}
	_body, _err := client.DescribeVodDomainLogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeVodDomainSrcBpsDataWithOptions(request *DescribeVodDomainSrcBpsDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodDomainSrcBpsDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodDomainSrcBpsData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVodDomainSrcBpsDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeVodDomainSrcBpsData(request *DescribeVodDomainSrcBpsDataRequest) (_result *DescribeVodDomainSrcBpsDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodDomainSrcBpsDataResponse{}
	_body, _err := client.DescribeVodDomainSrcBpsDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeVodDomainSrcTrafficDataWithOptions(request *DescribeVodDomainSrcTrafficDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodDomainSrcTrafficDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodDomainSrcTrafficData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVodDomainSrcTrafficDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeVodDomainSrcTrafficData(request *DescribeVodDomainSrcTrafficDataRequest) (_result *DescribeVodDomainSrcTrafficDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodDomainSrcTrafficDataResponse{}
	_body, _err := client.DescribeVodDomainSrcTrafficDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   This operation is available only in the **China (Shanghai)** region.
 * *   You can specify multiple accelerated domain names in a request.
 * *   If you do not specify the StartTime or EndTime parameter, data of the last 24 hours is returned. You can specify the StartTime and EndTime parameters to query data that is generated in the specified time range. You can query data of the last 90 days.
 * ### QPS limit
 * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on API operations](~~342790~~).
 *
 * @param request DescribeVodDomainTrafficDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVodDomainTrafficDataResponse
 */
func (client *Client) DescribeVodDomainTrafficDataWithOptions(request *DescribeVodDomainTrafficDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodDomainTrafficDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.IspNameEn)) {
		query["IspNameEn"] = request.IspNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.LocationNameEn)) {
		query["LocationNameEn"] = request.LocationNameEn
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodDomainTrafficData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVodDomainTrafficDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   This operation is available only in the **China (Shanghai)** region.
 * *   You can specify multiple accelerated domain names in a request.
 * *   If you do not specify the StartTime or EndTime parameter, data of the last 24 hours is returned. You can specify the StartTime and EndTime parameters to query data that is generated in the specified time range. You can query data of the last 90 days.
 * ### QPS limit
 * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on API operations](~~342790~~).
 *
 * @param request DescribeVodDomainTrafficDataRequest
 * @return DescribeVodDomainTrafficDataResponse
 */
func (client *Client) DescribeVodDomainTrafficData(request *DescribeVodDomainTrafficDataRequest) (_result *DescribeVodDomainTrafficDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodDomainTrafficDataResponse{}
	_body, _err := client.DescribeVodDomainTrafficDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >
 * *   This operation is available only in the **China (Shanghai)** region.
 * *   You can specify up to 100 accelerated domain names in a request. Separate multiple domain names with commas (,). If you do not specify an accelerated domain name, the data of all accelerated domain names within your Alibaba Cloud account is returned.
 * *   You can query data in the last year. The maximum time range that can be queried is three months. If you specify a time range of one to three days, the system returns data on an hourly basis. If you specify a time range of four days or more, the system returns data on a daily basis.
 *
 * @param request DescribeVodDomainUsageDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVodDomainUsageDataResponse
 */
func (client *Client) DescribeVodDomainUsageDataWithOptions(request *DescribeVodDomainUsageDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodDomainUsageDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Area)) {
		query["Area"] = request.Area
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Field)) {
		query["Field"] = request.Field
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodDomainUsageData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVodDomainUsageDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >
 * *   This operation is available only in the **China (Shanghai)** region.
 * *   You can specify up to 100 accelerated domain names in a request. Separate multiple domain names with commas (,). If you do not specify an accelerated domain name, the data of all accelerated domain names within your Alibaba Cloud account is returned.
 * *   You can query data in the last year. The maximum time range that can be queried is three months. If you specify a time range of one to three days, the system returns data on an hourly basis. If you specify a time range of four days or more, the system returns data on a daily basis.
 *
 * @param request DescribeVodDomainUsageDataRequest
 * @return DescribeVodDomainUsageDataResponse
 */
func (client *Client) DescribeVodDomainUsageData(request *DescribeVodDomainUsageDataRequest) (_result *DescribeVodDomainUsageDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodDomainUsageDataResponse{}
	_body, _err := client.DescribeVodDomainUsageDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The maximum number of URLs of files that can be refreshed each day.
 *
 * @param request DescribeVodRefreshQuotaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVodRefreshQuotaResponse
 */
func (client *Client) DescribeVodRefreshQuotaWithOptions(request *DescribeVodRefreshQuotaRequest, runtime *util.RuntimeOptions) (_result *DescribeVodRefreshQuotaResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodRefreshQuota"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVodRefreshQuotaResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The maximum number of URLs of files that can be refreshed each day.
 *
 * @param request DescribeVodRefreshQuotaRequest
 * @return DescribeVodRefreshQuotaResponse
 */
func (client *Client) DescribeVodRefreshQuota(request *DescribeVodRefreshQuotaRequest) (_result *DescribeVodRefreshQuotaResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodRefreshQuotaResponse{}
	_body, _err := client.DescribeVodRefreshQuotaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > *   This operation is available only in the **China (Shanghai)** region.
 * >*   If you do not specify the TaskId or ObjectPath parameter, the data in the last three days is returned on the first page. By default, one page displays a maximum of 20 entries. You can specify the TaskId and ObjectPath parameters at the same time.
 *
 * @param request DescribeVodRefreshTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVodRefreshTasksResponse
 */
func (client *Client) DescribeVodRefreshTasksWithOptions(request *DescribeVodRefreshTasksRequest, runtime *util.RuntimeOptions) (_result *DescribeVodRefreshTasksResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.ObjectPath)) {
		query["ObjectPath"] = request.ObjectPath
	}

	if !tea.BoolValue(util.IsUnset(request.ObjectType)) {
		query["ObjectType"] = request.ObjectType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodRefreshTasks"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVodRefreshTasksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > *   This operation is available only in the **China (Shanghai)** region.
 * >*   If you do not specify the TaskId or ObjectPath parameter, the data in the last three days is returned on the first page. By default, one page displays a maximum of 20 entries. You can specify the TaskId and ObjectPath parameters at the same time.
 *
 * @param request DescribeVodRefreshTasksRequest
 * @return DescribeVodRefreshTasksResponse
 */
func (client *Client) DescribeVodRefreshTasks(request *DescribeVodRefreshTasksRequest) (_result *DescribeVodRefreshTasksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodRefreshTasksResponse{}
	_body, _err := client.DescribeVodRefreshTasksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > *   This operation is available only in the **China (Shanghai)** region.
 * >*   If the time range to query is less than or equal to seven days, the system returns the statistics collected on an hourly basis. If the time range to query is greater than seven days, the system returns the statistics collected on a daily basis. The maximum time range that you can specify to query is 31 days.
 *
 * @param request DescribeVodStorageDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVodStorageDataResponse
 */
func (client *Client) DescribeVodStorageDataWithOptions(request *DescribeVodStorageDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodStorageDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Storage)) {
		query["Storage"] = request.Storage
	}

	if !tea.BoolValue(util.IsUnset(request.StorageType)) {
		query["StorageType"] = request.StorageType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodStorageData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVodStorageDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > *   This operation is available only in the **China (Shanghai)** region.
 * >*   If the time range to query is less than or equal to seven days, the system returns the statistics collected on an hourly basis. If the time range to query is greater than seven days, the system returns the statistics collected on a daily basis. The maximum time range that you can specify to query is 31 days.
 *
 * @param request DescribeVodStorageDataRequest
 * @return DescribeVodStorageDataResponse
 */
func (client *Client) DescribeVodStorageData(request *DescribeVodStorageDataRequest) (_result *DescribeVodStorageDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodStorageDataResponse{}
	_body, _err := client.DescribeVodStorageDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   This operation is available only in the **China (Shanghai)** region.
 * *   If the time range to query is less than or equal to seven days, the system returns the statistics collected on an hourly basis. If the time range to query is greater than seven days, the system returns the statistics collected on a daily basis. The maximum time range that you can specify to query is 31 days.
 *
 * @param request DescribeVodTranscodeDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeVodTranscodeDataResponse
 */
func (client *Client) DescribeVodTranscodeDataWithOptions(request *DescribeVodTranscodeDataRequest, runtime *util.RuntimeOptions) (_result *DescribeVodTranscodeDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.Specification)) {
		query["Specification"] = request.Specification
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Storage)) {
		query["Storage"] = request.Storage
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodTranscodeData"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVodTranscodeDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   This operation is available only in the **China (Shanghai)** region.
 * *   If the time range to query is less than or equal to seven days, the system returns the statistics collected on an hourly basis. If the time range to query is greater than seven days, the system returns the statistics collected on a daily basis. The maximum time range that you can specify to query is 31 days.
 *
 * @param request DescribeVodTranscodeDataRequest
 * @return DescribeVodTranscodeDataResponse
 */
func (client *Client) DescribeVodTranscodeData(request *DescribeVodTranscodeDataRequest) (_result *DescribeVodTranscodeDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodTranscodeDataResponse{}
	_body, _err := client.DescribeVodTranscodeDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeVodUserDomainsWithOptions(request *DescribeVodUserDomainsRequest, runtime *util.RuntimeOptions) (_result *DescribeVodUserDomainsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.DomainSearchType)) {
		query["DomainSearchType"] = request.DomainSearchType
	}

	if !tea.BoolValue(util.IsUnset(request.DomainStatus)) {
		query["DomainStatus"] = request.DomainStatus
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodUserDomains"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVodUserDomainsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeVodUserDomains(request *DescribeVodUserDomainsRequest) (_result *DescribeVodUserDomainsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodUserDomainsResponse{}
	_body, _err := client.DescribeVodUserDomainsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeVodVerifyContentWithOptions(request *DescribeVodVerifyContentRequest, runtime *util.RuntimeOptions) (_result *DescribeVodVerifyContentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeVodVerifyContent"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeVodVerifyContentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeVodVerifyContent(request *DescribeVodVerifyContentRequest) (_result *DescribeVodVerifyContentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeVodVerifyContentResponse{}
	_body, _err := client.DescribeVodVerifyContentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The name of the policy that was not found.
 *
 * @param request DetachAppPolicyFromIdentityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DetachAppPolicyFromIdentityResponse
 */
func (client *Client) DetachAppPolicyFromIdentityWithOptions(request *DetachAppPolicyFromIdentityRequest, runtime *util.RuntimeOptions) (_result *DetachAppPolicyFromIdentityResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.IdentityName)) {
		query["IdentityName"] = request.IdentityName
	}

	if !tea.BoolValue(util.IsUnset(request.IdentityType)) {
		query["IdentityType"] = request.IdentityType
	}

	if !tea.BoolValue(util.IsUnset(request.PolicyNames)) {
		query["PolicyNames"] = request.PolicyNames
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DetachAppPolicyFromIdentity"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DetachAppPolicyFromIdentityResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The name of the policy that was not found.
 *
 * @param request DetachAppPolicyFromIdentityRequest
 * @return DetachAppPolicyFromIdentityResponse
 */
func (client *Client) DetachAppPolicyFromIdentity(request *DetachAppPolicyFromIdentityRequest) (_result *DetachAppPolicyFromIdentityResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DetachAppPolicyFromIdentityResponse{}
	_body, _err := client.DetachAppPolicyFromIdentityWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GenerateKMSDataKeyWithOptions(request *GenerateKMSDataKeyRequest, runtime *util.RuntimeOptions) (_result *GenerateKMSDataKeyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GenerateKMSDataKey"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GenerateKMSDataKeyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GenerateKMSDataKey(request *GenerateKMSDataKeyRequest) (_result *GenerateKMSDataKeyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GenerateKMSDataKeyResponse{}
	_body, _err := client.GenerateKMSDataKeyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The image AI processing jobs.
 *
 * @param request GetAIImageJobsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAIImageJobsResponse
 */
func (client *Client) GetAIImageJobsWithOptions(request *GetAIImageJobsRequest, runtime *util.RuntimeOptions) (_result *GetAIImageJobsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.JobIds)) {
		query["JobIds"] = request.JobIds
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAIImageJobs"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAIImageJobsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The image AI processing jobs.
 *
 * @param request GetAIImageJobsRequest
 * @return GetAIImageJobsResponse
 */
func (client *Client) GetAIImageJobs(request *GetAIImageJobsRequest) (_result *GetAIImageJobsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAIImageJobsResponse{}
	_body, _err := client.GetAIImageJobsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The recommendation for review results. Valid values:
 * *   **block**: The content violates the regulations.
 * *   **review**: The content may violate the regulations.
 * *   **pass**: The content passes the review.
 *
 * @param request GetAIMediaAuditJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAIMediaAuditJobResponse
 */
func (client *Client) GetAIMediaAuditJobWithOptions(request *GetAIMediaAuditJobRequest, runtime *util.RuntimeOptions) (_result *GetAIMediaAuditJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.JobId)) {
		query["JobId"] = request.JobId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAIMediaAuditJob"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAIMediaAuditJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The recommendation for review results. Valid values:
 * *   **block**: The content violates the regulations.
 * *   **review**: The content may violate the regulations.
 * *   **pass**: The content passes the review.
 *
 * @param request GetAIMediaAuditJobRequest
 * @return GetAIMediaAuditJobResponse
 */
func (client *Client) GetAIMediaAuditJob(request *GetAIMediaAuditJobRequest) (_result *GetAIMediaAuditJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAIMediaAuditJobResponse{}
	_body, _err := client.GetAIMediaAuditJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The detailed configurations of the AI template. The value is a JSON string. For more information, see [AITemplateConfig](https://help.aliyun.com/document_detail/89863.html#title-vd3-499-o36).
 *
 * @param request GetAITemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAITemplateResponse
 */
func (client *Client) GetAITemplateWithOptions(request *GetAITemplateRequest, runtime *util.RuntimeOptions) (_result *GetAITemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		query["TemplateId"] = request.TemplateId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAITemplate"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAITemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The detailed configurations of the AI template. The value is a JSON string. For more information, see [AITemplateConfig](https://help.aliyun.com/document_detail/89863.html#title-vd3-499-o36).
 *
 * @param request GetAITemplateRequest
 * @return GetAITemplateResponse
 */
func (client *Client) GetAITemplate(request *GetAITemplateRequest) (_result *GetAITemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAITemplateResponse{}
	_body, _err := client.GetAITemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Milliseconds
 *
 * @param request GetAIVideoTagResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAIVideoTagResultResponse
 */
func (client *Client) GetAIVideoTagResultWithOptions(request *GetAIVideoTagResultRequest, runtime *util.RuntimeOptions) (_result *GetAIVideoTagResultResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaId)) {
		query["MediaId"] = request.MediaId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAIVideoTagResult"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAIVideoTagResultResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Milliseconds
 *
 * @param request GetAIVideoTagResultRequest
 * @return GetAIVideoTagResultResponse
 */
func (client *Client) GetAIVideoTagResult(request *GetAIVideoTagResultRequest) (_result *GetAIVideoTagResultResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAIVideoTagResultResponse{}
	_body, _err := client.GetAIVideoTagResultWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The description of the application.
 *
 * @param request GetAppInfosRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAppInfosResponse
 */
func (client *Client) GetAppInfosWithOptions(request *GetAppInfosRequest, runtime *util.RuntimeOptions) (_result *GetAppInfosResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppIds)) {
		query["AppIds"] = request.AppIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAppInfos"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAppInfosResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The description of the application.
 *
 * @param request GetAppInfosRequest
 * @return GetAppInfosResponse
 */
func (client *Client) GetAppInfos(request *GetAppInfosRequest) (_result *GetAppInfosResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAppInfosResponse{}
	_body, _err := client.GetAppInfosWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetAttachedMediaInfoWithOptions(request *GetAttachedMediaInfoRequest, runtime *util.RuntimeOptions) (_result *GetAttachedMediaInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AuthTimeout)) {
		query["AuthTimeout"] = request.AuthTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.MediaIds)) {
		query["MediaIds"] = request.MediaIds
	}

	if !tea.BoolValue(util.IsUnset(request.OutputType)) {
		query["OutputType"] = request.OutputType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAttachedMediaInfo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAttachedMediaInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetAttachedMediaInfo(request *GetAttachedMediaInfoRequest) (_result *GetAttachedMediaInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAttachedMediaInfoResponse{}
	_body, _err := client.GetAttachedMediaInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetAuditHistoryWithOptions(request *GetAuditHistoryRequest, runtime *util.RuntimeOptions) (_result *GetAuditHistoryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		query["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SortBy)) {
		query["SortBy"] = request.SortBy
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAuditHistory"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAuditHistoryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetAuditHistory(request *GetAuditHistoryRequest) (_result *GetAuditHistoryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAuditHistoryResponse{}
	_body, _err := client.GetAuditHistoryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetCategoriesWithOptions(request *GetCategoriesRequest, runtime *util.RuntimeOptions) (_result *GetCategoriesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CateId)) {
		query["CateId"] = request.CateId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		query["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SortBy)) {
		query["SortBy"] = request.SortBy
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetCategories"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetCategoriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetCategories(request *GetCategoriesRequest) (_result *GetCategoriesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetCategoriesResponse{}
	_body, _err := client.GetCategoriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The detailed configurations of the AI template. The value is a JSON string. For more information, see [AITemplateConfig](https://help.aliyun.com/document_detail/89863.html#title-vd3-499-o36).
 *
 * @param request GetDefaultAITemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDefaultAITemplateResponse
 */
func (client *Client) GetDefaultAITemplateWithOptions(request *GetDefaultAITemplateRequest, runtime *util.RuntimeOptions) (_result *GetDefaultAITemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TemplateType)) {
		query["TemplateType"] = request.TemplateType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDefaultAITemplate"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDefaultAITemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The detailed configurations of the AI template. The value is a JSON string. For more information, see [AITemplateConfig](https://help.aliyun.com/document_detail/89863.html#title-vd3-499-o36).
 *
 * @param request GetDefaultAITemplateRequest
 * @return GetDefaultAITemplateResponse
 */
func (client *Client) GetDefaultAITemplate(request *GetDefaultAITemplateRequest) (_result *GetDefaultAITemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDefaultAITemplateResponse{}
	_body, _err := client.GetDefaultAITemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetEditingProjectWithOptions(request *GetEditingProjectRequest, runtime *util.RuntimeOptions) (_result *GetEditingProjectResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetEditingProject"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetEditingProjectResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetEditingProject(request *GetEditingProjectRequest) (_result *GetEditingProjectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetEditingProjectResponse{}
	_body, _err := client.GetEditingProjectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The time when the material was last updated. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
 *
 * @param request GetEditingProjectMaterialsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetEditingProjectMaterialsResponse
 */
func (client *Client) GetEditingProjectMaterialsWithOptions(request *GetEditingProjectMaterialsRequest, runtime *util.RuntimeOptions) (_result *GetEditingProjectMaterialsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaterialType)) {
		query["MaterialType"] = request.MaterialType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetEditingProjectMaterials"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetEditingProjectMaterialsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The time when the material was last updated. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
 *
 * @param request GetEditingProjectMaterialsRequest
 * @return GetEditingProjectMaterialsResponse
 */
func (client *Client) GetEditingProjectMaterials(request *GetEditingProjectMaterialsRequest) (_result *GetEditingProjectMaterialsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetEditingProjectMaterialsResponse{}
	_body, _err := client.GetEditingProjectMaterialsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetImageInfoWithOptions(request *GetImageInfoRequest, runtime *util.RuntimeOptions) (_result *GetImageInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AuthTimeout)) {
		query["AuthTimeout"] = request.AuthTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.ImageId)) {
		query["ImageId"] = request.ImageId
	}

	if !tea.BoolValue(util.IsUnset(request.OutputType)) {
		query["OutputType"] = request.OutputType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetImageInfo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetImageInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetImageInfo(request *GetImageInfoRequest) (_result *GetImageInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetImageInfoResponse{}
	_body, _err := client.GetImageInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to query the basic information about multiple images at a time, such as the image title, type, creation time, tags, and URL.
 * ### Limits
 * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](~~342790~~).
 *
 * @param request GetImageInfosRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetImageInfosResponse
 */
func (client *Client) GetImageInfosWithOptions(request *GetImageInfosRequest, runtime *util.RuntimeOptions) (_result *GetImageInfosResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AuthTimeout)) {
		query["AuthTimeout"] = request.AuthTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.ImageIds)) {
		query["ImageIds"] = request.ImageIds
	}

	if !tea.BoolValue(util.IsUnset(request.OutputType)) {
		query["OutputType"] = request.OutputType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetImageInfos"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetImageInfosResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to query the basic information about multiple images at a time, such as the image title, type, creation time, tags, and URL.
 * ### Limits
 * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](~~342790~~).
 *
 * @param request GetImageInfosRequest
 * @return GetImageInfosResponse
 */
func (client *Client) GetImageInfos(request *GetImageInfosRequest) (_result *GetImageInfosResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetImageInfosResponse{}
	_body, _err := client.GetImageInfosWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The start time of the audio that failed the review. Unit: seconds.
 *
 * @param request GetMediaAuditAudioResultDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMediaAuditAudioResultDetailResponse
 */
func (client *Client) GetMediaAuditAudioResultDetailWithOptions(request *GetMediaAuditAudioResultDetailRequest, runtime *util.RuntimeOptions) (_result *GetMediaAuditAudioResultDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaId)) {
		query["MediaId"] = request.MediaId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		query["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMediaAuditAudioResultDetail"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMediaAuditAudioResultDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The start time of the audio that failed the review. Unit: seconds.
 *
 * @param request GetMediaAuditAudioResultDetailRequest
 * @return GetMediaAuditAudioResultDetailResponse
 */
func (client *Client) GetMediaAuditAudioResultDetail(request *GetMediaAuditAudioResultDetailRequest) (_result *GetMediaAuditAudioResultDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMediaAuditAudioResultDetailResponse{}
	_body, _err := client.GetMediaAuditAudioResultDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetMediaAuditResultWithOptions(request *GetMediaAuditResultRequest, runtime *util.RuntimeOptions) (_result *GetMediaAuditResultResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaId)) {
		query["MediaId"] = request.MediaId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMediaAuditResult"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMediaAuditResultResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetMediaAuditResult(request *GetMediaAuditResultRequest) (_result *GetMediaAuditResultResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMediaAuditResultResponse{}
	_body, _err := client.GetMediaAuditResultWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Details about review results.
 *
 * @param request GetMediaAuditResultDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMediaAuditResultDetailResponse
 */
func (client *Client) GetMediaAuditResultDetailWithOptions(request *GetMediaAuditResultDetailRequest, runtime *util.RuntimeOptions) (_result *GetMediaAuditResultDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaId)) {
		query["MediaId"] = request.MediaId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		query["PageNo"] = request.PageNo
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMediaAuditResultDetail"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMediaAuditResultDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Details about review results.
 *
 * @param request GetMediaAuditResultDetailRequest
 * @return GetMediaAuditResultDetailResponse
 */
func (client *Client) GetMediaAuditResultDetail(request *GetMediaAuditResultDetailRequest) (_result *GetMediaAuditResultDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMediaAuditResultDetailResponse{}
	_body, _err := client.GetMediaAuditResultDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetMediaAuditResultTimelineWithOptions(request *GetMediaAuditResultTimelineRequest, runtime *util.RuntimeOptions) (_result *GetMediaAuditResultTimelineResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaId)) {
		query["MediaId"] = request.MediaId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMediaAuditResultTimeline"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMediaAuditResultTimelineResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetMediaAuditResultTimeline(request *GetMediaAuditResultTimelineRequest) (_result *GetMediaAuditResultTimelineResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMediaAuditResultTimelineResponse{}
	_body, _err := client.GetMediaAuditResultTimelineWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The details of the matched video. Information such as the location and duration of the video is returned.
 *
 * @param request GetMediaDNAResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMediaDNAResultResponse
 */
func (client *Client) GetMediaDNAResultWithOptions(request *GetMediaDNAResultRequest, runtime *util.RuntimeOptions) (_result *GetMediaDNAResultResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaId)) {
		query["MediaId"] = request.MediaId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMediaDNAResult"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMediaDNAResultResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The details of the matched video. Information such as the location and duration of the video is returned.
 *
 * @param request GetMediaDNAResultRequest
 * @return GetMediaDNAResultResponse
 */
func (client *Client) GetMediaDNAResult(request *GetMediaDNAResultRequest) (_result *GetMediaDNAResultResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMediaDNAResultResponse{}
	_body, _err := client.GetMediaDNAResultWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can query the information about all media files or a specific media file in a refresh or prefetch job.
 * ### QPS limits
 * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations in ApsaraVideo VoD](~~342790~~).
 *
 * @param request GetMediaRefreshJobsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMediaRefreshJobsResponse
 */
func (client *Client) GetMediaRefreshJobsWithOptions(request *GetMediaRefreshJobsRequest, runtime *util.RuntimeOptions) (_result *GetMediaRefreshJobsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMediaRefreshJobs"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMediaRefreshJobsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can query the information about all media files or a specific media file in a refresh or prefetch job.
 * ### QPS limits
 * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations in ApsaraVideo VoD](~~342790~~).
 *
 * @param request GetMediaRefreshJobsRequest
 * @return GetMediaRefreshJobsResponse
 */
func (client *Client) GetMediaRefreshJobs(request *GetMediaRefreshJobsRequest) (_result *GetMediaRefreshJobsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMediaRefreshJobsResponse{}
	_body, _err := client.GetMediaRefreshJobsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The type of the callback event.
 *
 * @param request GetMessageCallbackRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMessageCallbackResponse
 */
func (client *Client) GetMessageCallbackWithOptions(request *GetMessageCallbackRequest, runtime *util.RuntimeOptions) (_result *GetMessageCallbackResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMessageCallback"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMessageCallbackResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The type of the callback event.
 *
 * @param request GetMessageCallbackRequest
 * @return GetMessageCallbackResponse
 */
func (client *Client) GetMessageCallback(request *GetMessageCallbackRequest) (_result *GetMessageCallbackResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMessageCallbackResponse{}
	_body, _err := client.GetMessageCallbackWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The sampling format.
 *
 * @param request GetMezzanineInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMezzanineInfoResponse
 */
func (client *Client) GetMezzanineInfoWithOptions(request *GetMezzanineInfoRequest, runtime *util.RuntimeOptions) (_result *GetMezzanineInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AdditionType)) {
		query["AdditionType"] = request.AdditionType
	}

	if !tea.BoolValue(util.IsUnset(request.AuthTimeout)) {
		query["AuthTimeout"] = request.AuthTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.OutputType)) {
		query["OutputType"] = request.OutputType
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMezzanineInfo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMezzanineInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The sampling format.
 *
 * @param request GetMezzanineInfoRequest
 * @return GetMezzanineInfoResponse
 */
func (client *Client) GetMezzanineInfo(request *GetMezzanineInfoRequest) (_result *GetMezzanineInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMezzanineInfoResponse{}
	_body, _err := client.GetMezzanineInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the media file.
 *
 * @param request GetPlayInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetPlayInfoResponse
 */
func (client *Client) GetPlayInfoWithOptions(request *GetPlayInfoRequest, runtime *util.RuntimeOptions) (_result *GetPlayInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AdditionType)) {
		query["AdditionType"] = request.AdditionType
	}

	if !tea.BoolValue(util.IsUnset(request.AuthTimeout)) {
		query["AuthTimeout"] = request.AuthTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.Definition)) {
		query["Definition"] = request.Definition
	}

	if !tea.BoolValue(util.IsUnset(request.Formats)) {
		query["Formats"] = request.Formats
	}

	if !tea.BoolValue(util.IsUnset(request.OutputType)) {
		query["OutputType"] = request.OutputType
	}

	if !tea.BoolValue(util.IsUnset(request.PlayConfig)) {
		query["PlayConfig"] = request.PlayConfig
	}

	if !tea.BoolValue(util.IsUnset(request.ReAuthInfo)) {
		query["ReAuthInfo"] = request.ReAuthInfo
	}

	if !tea.BoolValue(util.IsUnset(request.ResultType)) {
		query["ResultType"] = request.ResultType
	}

	if !tea.BoolValue(util.IsUnset(request.StreamType)) {
		query["StreamType"] = request.StreamType
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetPlayInfo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetPlayInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the media file.
 *
 * @param request GetPlayInfoRequest
 * @return GetPlayInfoResponse
 */
func (client *Client) GetPlayInfo(request *GetPlayInfoRequest) (_result *GetPlayInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetPlayInfoResponse{}
	_body, _err := client.GetPlayInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   A media file may be transcoded multiple times. This operation returns only the latest transcoding summary.
 * *   You can query transcoding summaries for a maximum of 10 media files in one request.
 * *   You can call the [ListTranscodeTask](~~109120~~) operation to query historical transcoding tasks.
 * *   **You can call this operation to query information only about transcoding tasks created within the past year.**
 *
 * @param request GetTranscodeSummaryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTranscodeSummaryResponse
 */
func (client *Client) GetTranscodeSummaryWithOptions(request *GetTranscodeSummaryRequest, runtime *util.RuntimeOptions) (_result *GetTranscodeSummaryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.VideoIds)) {
		query["VideoIds"] = request.VideoIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetTranscodeSummary"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetTranscodeSummaryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   A media file may be transcoded multiple times. This operation returns only the latest transcoding summary.
 * *   You can query transcoding summaries for a maximum of 10 media files in one request.
 * *   You can call the [ListTranscodeTask](~~109120~~) operation to query historical transcoding tasks.
 * *   **You can call this operation to query information only about transcoding tasks created within the past year.**
 *
 * @param request GetTranscodeSummaryRequest
 * @return GetTranscodeSummaryResponse
 */
func (client *Client) GetTranscodeSummary(request *GetTranscodeSummaryRequest) (_result *GetTranscodeSummaryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetTranscodeSummaryResponse{}
	_body, _err := client.GetTranscodeSummaryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The video resolution. Valid values:
 * *   **LD**: low definition
 * *   **SD**: standard definition
 * *   **HD**: high definition
 * *   **FHD**: ultra high definition
 * *   **OD**: original definition
 * *   **2K**: 2K
 * *   **4K**: 4K
 * *   **SQ**: standard sound quality
 * *   **HQ**: high sound quality
 * *   **AUTO**: adaptive bitrate Adaptive bitrate streams are returned only if PackageSetting is set in the transcoding template. For more information, see [Basic structures](~~52839~~).
 * > This parameter indicates the definition that is configured in the transcoding template and does not indicate the actual resolution of the output video.
 *
 * @param request GetTranscodeTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTranscodeTaskResponse
 */
func (client *Client) GetTranscodeTaskWithOptions(request *GetTranscodeTaskRequest, runtime *util.RuntimeOptions) (_result *GetTranscodeTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TranscodeTaskId)) {
		query["TranscodeTaskId"] = request.TranscodeTaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetTranscodeTask"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetTranscodeTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The video resolution. Valid values:
 * *   **LD**: low definition
 * *   **SD**: standard definition
 * *   **HD**: high definition
 * *   **FHD**: ultra high definition
 * *   **OD**: original definition
 * *   **2K**: 2K
 * *   **4K**: 4K
 * *   **SQ**: standard sound quality
 * *   **HQ**: high sound quality
 * *   **AUTO**: adaptive bitrate Adaptive bitrate streams are returned only if PackageSetting is set in the transcoding template. For more information, see [Basic structures](~~52839~~).
 * > This parameter indicates the definition that is configured in the transcoding template and does not indicate the actual resolution of the output video.
 *
 * @param request GetTranscodeTaskRequest
 * @return GetTranscodeTaskResponse
 */
func (client *Client) GetTranscodeTask(request *GetTranscodeTaskRequest) (_result *GetTranscodeTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetTranscodeTaskResponse{}
	_body, _err := client.GetTranscodeTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Valid values for the definition of a common transcoding template:
 * *   **LD**: low definition.
 * *   **SD**: standard definition.
 * *   **HD**: high definition.
 * *   **FHD**: ultra high definition.
 * *   **OD**: original quality.
 * *   **2K**
 * *   **4K**
 * *   **SQ**: standard sound quality.
 * *   **HQ**: high sound quality.
 * Valid values for the definition of a Narrowband HD™ 1.0 transcoding template:
 * *   **LD-NBV1**: low definition.
 * *   **SD-NBV1**: standard definition.
 * *   **HD-NBV1**: high definition.
 * *   **FHD-NBV1**: ultra high definition.
 * *   **2K-NBV1**
 * *   **4K-NBV1**
 * >*   You cannot modify the definition of transcoding templates.
 * >*   You cannot modify the system parameters, such as the video resolution, audio resolution, and bitrate, of Narrowband HD™ 1.0 transcoding templates.
 * >*   You can create only Narrowband HD™ 1.0 transcoding templates that support the FLV, M3U8 (HLS), and MP4 output formats.
 *
 * @param request GetTranscodeTemplateGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTranscodeTemplateGroupResponse
 */
func (client *Client) GetTranscodeTemplateGroupWithOptions(request *GetTranscodeTemplateGroupRequest, runtime *util.RuntimeOptions) (_result *GetTranscodeTemplateGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TranscodeTemplateGroupId)) {
		query["TranscodeTemplateGroupId"] = request.TranscodeTemplateGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetTranscodeTemplateGroup"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetTranscodeTemplateGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Valid values for the definition of a common transcoding template:
 * *   **LD**: low definition.
 * *   **SD**: standard definition.
 * *   **HD**: high definition.
 * *   **FHD**: ultra high definition.
 * *   **OD**: original quality.
 * *   **2K**
 * *   **4K**
 * *   **SQ**: standard sound quality.
 * *   **HQ**: high sound quality.
 * Valid values for the definition of a Narrowband HD™ 1.0 transcoding template:
 * *   **LD-NBV1**: low definition.
 * *   **SD-NBV1**: standard definition.
 * *   **HD-NBV1**: high definition.
 * *   **FHD-NBV1**: ultra high definition.
 * *   **2K-NBV1**
 * *   **4K-NBV1**
 * >*   You cannot modify the definition of transcoding templates.
 * >*   You cannot modify the system parameters, such as the video resolution, audio resolution, and bitrate, of Narrowband HD™ 1.0 transcoding templates.
 * >*   You can create only Narrowband HD™ 1.0 transcoding templates that support the FLV, M3U8 (HLS), and MP4 output formats.
 *
 * @param request GetTranscodeTemplateGroupRequest
 * @return GetTranscodeTemplateGroupResponse
 */
func (client *Client) GetTranscodeTemplateGroup(request *GetTranscodeTemplateGroupRequest) (_result *GetTranscodeTemplateGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetTranscodeTemplateGroupResponse{}
	_body, _err := client.GetTranscodeTemplateGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The size of the uploaded media file. Unit: byte.
 *
 * @param request GetURLUploadInfosRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetURLUploadInfosResponse
 */
func (client *Client) GetURLUploadInfosWithOptions(request *GetURLUploadInfosRequest, runtime *util.RuntimeOptions) (_result *GetURLUploadInfosResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.JobIds)) {
		query["JobIds"] = request.JobIds
	}

	if !tea.BoolValue(util.IsUnset(request.UploadURLs)) {
		query["UploadURLs"] = request.UploadURLs
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetURLUploadInfos"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetURLUploadInfosResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The size of the uploaded media file. Unit: byte.
 *
 * @param request GetURLUploadInfosRequest
 * @return GetURLUploadInfosResponse
 */
func (client *Client) GetURLUploadInfos(request *GetURLUploadInfosRequest) (_result *GetURLUploadInfosResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetURLUploadInfosResponse{}
	_body, _err := client.GetURLUploadInfosWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The type of the media file. Set the value to **video**, which indicates audio and video files.
 *
 * @param request GetUploadDetailsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetUploadDetailsResponse
 */
func (client *Client) GetUploadDetailsWithOptions(request *GetUploadDetailsRequest, runtime *util.RuntimeOptions) (_result *GetUploadDetailsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaIds)) {
		query["MediaIds"] = request.MediaIds
	}

	if !tea.BoolValue(util.IsUnset(request.MediaType)) {
		query["MediaType"] = request.MediaType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetUploadDetails"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetUploadDetailsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The type of the media file. Set the value to **video**, which indicates audio and video files.
 *
 * @param request GetUploadDetailsRequest
 * @return GetUploadDetailsResponse
 */
func (client *Client) GetUploadDetails(request *GetUploadDetailsRequest) (_result *GetUploadDetailsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetUploadDetailsResponse{}
	_body, _err := client.GetUploadDetailsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The video snapshot URLs.
 *
 * @param request GetVideoInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetVideoInfoResponse
 */
func (client *Client) GetVideoInfoWithOptions(request *GetVideoInfoRequest, runtime *util.RuntimeOptions) (_result *GetVideoInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetVideoInfo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetVideoInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The video snapshot URLs.
 *
 * @param request GetVideoInfoRequest
 * @return GetVideoInfoResponse
 */
func (client *Client) GetVideoInfo(request *GetVideoInfoRequest) (_result *GetVideoInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetVideoInfoResponse{}
	_body, _err := client.GetVideoInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The duration of the video. Unit: seconds.
 *
 * @param request GetVideoInfosRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetVideoInfosResponse
 */
func (client *Client) GetVideoInfosWithOptions(request *GetVideoInfosRequest, runtime *util.RuntimeOptions) (_result *GetVideoInfosResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.VideoIds)) {
		query["VideoIds"] = request.VideoIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetVideoInfos"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetVideoInfosResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The duration of the video. Unit: seconds.
 *
 * @param request GetVideoInfosRequest
 * @return GetVideoInfosResponse
 */
func (client *Client) GetVideoInfos(request *GetVideoInfosRequest) (_result *GetVideoInfosResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetVideoInfosResponse{}
	_body, _err := client.GetVideoInfosWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to query information about media files based on the filter conditions that you specify, such as video status and category ID. Information about a maximum of **5,000** media files can be returned for each request. We recommend that you set the StartTime and EndTime parameters to specify a time range for each request. For more information about how to query information about more media files or even all media files, see [SearchMedia](~~86044~~).
 *
 * @param request GetVideoListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetVideoListResponse
 */
func (client *Client) GetVideoListWithOptions(request *GetVideoListRequest, runtime *util.RuntimeOptions) (_result *GetVideoListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CateId)) {
		query["CateId"] = request.CateId
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		query["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SortBy)) {
		query["SortBy"] = request.SortBy
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.StorageLocation)) {
		query["StorageLocation"] = request.StorageLocation
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetVideoList"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetVideoListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to query information about media files based on the filter conditions that you specify, such as video status and category ID. Information about a maximum of **5,000** media files can be returned for each request. We recommend that you set the StartTime and EndTime parameters to specify a time range for each request. For more information about how to query information about more media files or even all media files, see [SearchMedia](~~86044~~).
 *
 * @param request GetVideoListRequest
 * @return GetVideoListResponse
 */
func (client *Client) GetVideoList(request *GetVideoListRequest) (_result *GetVideoListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetVideoListResponse{}
	_body, _err := client.GetVideoListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The thumbnail URL of the audio or video file.
 *
 * @param request GetVideoPlayAuthRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetVideoPlayAuthResponse
 */
func (client *Client) GetVideoPlayAuthWithOptions(request *GetVideoPlayAuthRequest, runtime *util.RuntimeOptions) (_result *GetVideoPlayAuthResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApiVersion)) {
		query["ApiVersion"] = request.ApiVersion
	}

	if !tea.BoolValue(util.IsUnset(request.AuthInfoTimeout)) {
		query["AuthInfoTimeout"] = request.AuthInfoTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetVideoPlayAuth"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetVideoPlayAuthResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The thumbnail URL of the audio or video file.
 *
 * @param request GetVideoPlayAuthRequest
 * @return GetVideoPlayAuthResponse
 */
func (client *Client) GetVideoPlayAuth(request *GetVideoPlayAuthRequest) (_result *GetVideoPlayAuthResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetVideoPlayAuthResponse{}
	_body, _err := client.GetVideoPlayAuthWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetVodTemplateWithOptions(request *GetVodTemplateRequest, runtime *util.RuntimeOptions) (_result *GetVodTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.VodTemplateId)) {
		query["VodTemplateId"] = request.VodTemplateId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetVodTemplate"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetVodTemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetVodTemplate(request *GetVodTemplateRequest) (_result *GetVodTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetVodTemplateResponse{}
	_body, _err := client.GetVodTemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetWatermarkWithOptions(request *GetWatermarkRequest, runtime *util.RuntimeOptions) (_result *GetWatermarkResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.WatermarkId)) {
		query["WatermarkId"] = request.WatermarkId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetWatermark"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetWatermarkResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetWatermark(request *GetWatermarkRequest) (_result *GetWatermarkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetWatermarkResponse{}
	_body, _err := client.GetWatermarkWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation to query AI processing results about images of a specified video. Images of different videos cannot be queried in one request.
 * - The smart thumbnail feature is not supported. You cannot call this operation.
 * - You can call this operation to query AI processing results about images of a specified video. Images of different videos cannot be queried in one request.
 * ### QPS limit
 * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations in ApsaraVideo VoD](~~342790~~).
 *
 * @param request ListAIImageInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAIImageInfoResponse
 */
func (client *Client) ListAIImageInfoWithOptions(request *ListAIImageInfoRequest, runtime *util.RuntimeOptions) (_result *ListAIImageInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAIImageInfo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAIImageInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation to query AI processing results about images of a specified video. Images of different videos cannot be queried in one request.
 * - The smart thumbnail feature is not supported. You cannot call this operation.
 * - You can call this operation to query AI processing results about images of a specified video. Images of different videos cannot be queried in one request.
 * ### QPS limit
 * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits on API operations in ApsaraVideo VoD](~~342790~~).
 *
 * @param request ListAIImageInfoRequest
 * @return ListAIImageInfoResponse
 */
func (client *Client) ListAIImageInfo(request *ListAIImageInfoRequest) (_result *ListAIImageInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAIImageInfoResponse{}
	_body, _err := client.ListAIImageInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The IDs of the jobs that do not exist.
 *
 * @param request ListAIJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAIJobResponse
 */
func (client *Client) ListAIJobWithOptions(request *ListAIJobRequest, runtime *util.RuntimeOptions) (_result *ListAIJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.JobIds)) {
		query["JobIds"] = request.JobIds
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAIJob"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAIJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The IDs of the jobs that do not exist.
 *
 * @param request ListAIJobRequest
 * @return ListAIJobResponse
 */
func (client *Client) ListAIJob(request *ListAIJobRequest) (_result *ListAIJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAIJobResponse{}
	_body, _err := client.ListAIJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The returned result.
 *
 * @param request ListAITemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAITemplateResponse
 */
func (client *Client) ListAITemplateWithOptions(request *ListAITemplateRequest, runtime *util.RuntimeOptions) (_result *ListAITemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TemplateType)) {
		query["TemplateType"] = request.TemplateType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAITemplate"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAITemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The returned result.
 *
 * @param request ListAITemplateRequest
 * @return ListAITemplateResponse
 */
func (client *Client) ListAITemplate(request *ListAITemplateRequest) (_result *ListAITemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAITemplateResponse{}
	_body, _err := client.ListAITemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The description of the application.
 *
 * @param request ListAppInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAppInfoResponse
 */
func (client *Client) ListAppInfoWithOptions(request *ListAppInfoRequest, runtime *util.RuntimeOptions) (_result *ListAppInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		query["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAppInfo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAppInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The description of the application.
 *
 * @param request ListAppInfoRequest
 * @return ListAppInfoResponse
 */
func (client *Client) ListAppInfo(request *ListAppInfoRequest) (_result *ListAppInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAppInfoResponse{}
	_body, _err := client.ListAppInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The name of the identity.
 * *   Specifies the ID of the RAM user when the IdentityType parameter is set to RamUser.
 * *   Specifies the name of the RAM role when the IdentityType parameter is set to RamRole.
 *
 * @param request ListAppPoliciesForIdentityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAppPoliciesForIdentityResponse
 */
func (client *Client) ListAppPoliciesForIdentityWithOptions(request *ListAppPoliciesForIdentityRequest, runtime *util.RuntimeOptions) (_result *ListAppPoliciesForIdentityResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.IdentityName)) {
		query["IdentityName"] = request.IdentityName
	}

	if !tea.BoolValue(util.IsUnset(request.IdentityType)) {
		query["IdentityType"] = request.IdentityType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAppPoliciesForIdentity"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAppPoliciesForIdentityResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The name of the identity.
 * *   Specifies the ID of the RAM user when the IdentityType parameter is set to RamUser.
 * *   Specifies the name of the RAM role when the IdentityType parameter is set to RamRole.
 *
 * @param request ListAppPoliciesForIdentityRequest
 * @return ListAppPoliciesForIdentityResponse
 */
func (client *Client) ListAppPoliciesForIdentity(request *ListAppPoliciesForIdentityRequest) (_result *ListAppPoliciesForIdentityResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAppPoliciesForIdentityResponse{}
	_body, _err := client.ListAppPoliciesForIdentityWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListAuditSecurityIpWithOptions(request *ListAuditSecurityIpRequest, runtime *util.RuntimeOptions) (_result *ListAuditSecurityIpResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.SecurityGroupName)) {
		query["SecurityGroupName"] = request.SecurityGroupName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAuditSecurityIp"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAuditSecurityIpResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListAuditSecurityIp(request *ListAuditSecurityIpRequest) (_result *ListAuditSecurityIpResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAuditSecurityIpResponse{}
	_body, _err := client.ListAuditSecurityIpWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListDynamicImageWithOptions(request *ListDynamicImageRequest, runtime *util.RuntimeOptions) (_result *ListDynamicImageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDynamicImage"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDynamicImageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListDynamicImage(request *ListDynamicImageRequest) (_result *ListDynamicImageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDynamicImageResponse{}
	_body, _err := client.ListDynamicImageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the video category.
 *
 * @param request ListLiveRecordVideoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListLiveRecordVideoResponse
 */
func (client *Client) ListLiveRecordVideoWithOptions(request *ListLiveRecordVideoRequest, runtime *util.RuntimeOptions) (_result *ListLiveRecordVideoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		query["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SortBy)) {
		query["SortBy"] = request.SortBy
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.StreamName)) {
		query["StreamName"] = request.StreamName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListLiveRecordVideo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListLiveRecordVideoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the video category.
 *
 * @param request ListLiveRecordVideoRequest
 * @return ListLiveRecordVideoResponse
 */
func (client *Client) ListLiveRecordVideo(request *ListLiveRecordVideoRequest) (_result *ListLiveRecordVideoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListLiveRecordVideoResponse{}
	_body, _err := client.ListLiveRecordVideoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The type of snapshots that are returned. Valid values:
 * *   **CoverSnapshot**: thumbnail snapshot
 * *   **NormalSnapshot**: normal snapshot
 * *   **SpriteSnapshot**: sprite snapshot
 * *   **SpriteOriginSnapshot**: sprite source snapshot
 * *   **WebVttSnapshot**: WebVTT snapshot
 *
 * @param request ListSnapshotsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSnapshotsResponse
 */
func (client *Client) ListSnapshotsWithOptions(request *ListSnapshotsRequest, runtime *util.RuntimeOptions) (_result *ListSnapshotsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AuthTimeout)) {
		query["AuthTimeout"] = request.AuthTimeout
	}

	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		query["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SnapshotType)) {
		query["SnapshotType"] = request.SnapshotType
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListSnapshots"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListSnapshotsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The type of snapshots that are returned. Valid values:
 * *   **CoverSnapshot**: thumbnail snapshot
 * *   **NormalSnapshot**: normal snapshot
 * *   **SpriteSnapshot**: sprite snapshot
 * *   **SpriteOriginSnapshot**: sprite source snapshot
 * *   **WebVttSnapshot**: WebVTT snapshot
 *
 * @param request ListSnapshotsRequest
 * @return ListSnapshotsResponse
 */
func (client *Client) ListSnapshots(request *ListSnapshotsRequest) (_result *ListSnapshotsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListSnapshotsResponse{}
	_body, _err := client.ListSnapshotsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The time when the transcoding task was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
 *
 * @param request ListTranscodeTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTranscodeTaskResponse
 */
func (client *Client) ListTranscodeTaskWithOptions(request *ListTranscodeTaskRequest, runtime *util.RuntimeOptions) (_result *ListTranscodeTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		query["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTranscodeTask"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTranscodeTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The time when the transcoding task was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.
 *
 * @param request ListTranscodeTaskRequest
 * @return ListTranscodeTaskResponse
 */
func (client *Client) ListTranscodeTask(request *ListTranscodeTaskRequest) (_result *ListTranscodeTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTranscodeTaskResponse{}
	_body, _err := client.ListTranscodeTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the application. Default value: **app-1000000**. For more information, see [Overview](~~113600~~).
 *
 * @param request ListTranscodeTemplateGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTranscodeTemplateGroupResponse
 */
func (client *Client) ListTranscodeTemplateGroupWithOptions(request *ListTranscodeTemplateGroupRequest, runtime *util.RuntimeOptions) (_result *ListTranscodeTemplateGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTranscodeTemplateGroup"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTranscodeTemplateGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the application. Default value: **app-1000000**. For more information, see [Overview](~~113600~~).
 *
 * @param request ListTranscodeTemplateGroupRequest
 * @return ListTranscodeTemplateGroupResponse
 */
func (client *Client) ListTranscodeTemplateGroup(request *ListTranscodeTemplateGroupRequest) (_result *ListTranscodeTemplateGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTranscodeTemplateGroupResponse{}
	_body, _err := client.ListTranscodeTemplateGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListVodTemplateWithOptions(request *ListVodTemplateRequest, runtime *util.RuntimeOptions) (_result *ListVodTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateType)) {
		query["TemplateType"] = request.TemplateType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListVodTemplate"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListVodTemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListVodTemplate(request *ListVodTemplateRequest) (_result *ListVodTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListVodTemplateResponse{}
	_body, _err := client.ListVodTemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListWatermarkWithOptions(request *ListWatermarkRequest, runtime *util.RuntimeOptions) (_result *ListWatermarkResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListWatermark"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListWatermarkResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListWatermark(request *ListWatermarkRequest) (_result *ListWatermarkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListWatermarkResponse{}
	_body, _err := client.ListWatermarkWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) MoveAppResourceWithOptions(request *MoveAppResourceRequest, runtime *util.RuntimeOptions) (_result *MoveAppResourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceIds)) {
		query["ResourceIds"] = request.ResourceIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TargetAppId)) {
		query["TargetAppId"] = request.TargetAppId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("MoveAppResource"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &MoveAppResourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) MoveAppResource(request *MoveAppResourceRequest) (_result *MoveAppResourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &MoveAppResourceResponse{}
	_body, _err := client.MoveAppResourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The operation that you want to perform. Set the value to **PreloadVodObjectCaches**.
 *
 * @param request PreloadVodObjectCachesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PreloadVodObjectCachesResponse
 */
func (client *Client) PreloadVodObjectCachesWithOptions(request *PreloadVodObjectCachesRequest, runtime *util.RuntimeOptions) (_result *PreloadVodObjectCachesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ObjectPath)) {
		query["ObjectPath"] = request.ObjectPath
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("PreloadVodObjectCaches"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PreloadVodObjectCachesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The operation that you want to perform. Set the value to **PreloadVodObjectCaches**.
 *
 * @param request PreloadVodObjectCachesRequest
 * @return PreloadVodObjectCachesResponse
 */
func (client *Client) PreloadVodObjectCaches(request *PreloadVodObjectCachesRequest) (_result *PreloadVodObjectCachesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PreloadVodObjectCachesResponse{}
	_body, _err := client.PreloadVodObjectCachesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The title of the online editing project.
 *
 * @param request ProduceEditingProjectVideoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ProduceEditingProjectVideoResponse
 */
func (client *Client) ProduceEditingProjectVideoWithOptions(request *ProduceEditingProjectVideoRequest, runtime *util.RuntimeOptions) (_result *ProduceEditingProjectVideoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CoverURL)) {
		query["CoverURL"] = request.CoverURL
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.MediaMetadata)) {
		query["MediaMetadata"] = request.MediaMetadata
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProduceConfig)) {
		query["ProduceConfig"] = request.ProduceConfig
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Timeline)) {
		query["Timeline"] = request.Timeline
	}

	if !tea.BoolValue(util.IsUnset(request.Title)) {
		query["Title"] = request.Title
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ProduceEditingProjectVideo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ProduceEditingProjectVideoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The title of the online editing project.
 *
 * @param request ProduceEditingProjectVideoRequest
 * @return ProduceEditingProjectVideoResponse
 */
func (client *Client) ProduceEditingProjectVideo(request *ProduceEditingProjectVideoRequest) (_result *ProduceEditingProjectVideoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ProduceEditingProjectVideoResponse{}
	_body, _err := client.ProduceEditingProjectVideoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The formats of the media streams you want to refresh or prefetch. You can specify multiple formats. Separate multiple formats with commas (,). If you leave this parameter empty, media streams in all formats are refreshed or prefetched by default. Valid values:
 * *   **mp4**
 * *   **m3u8**
 * *   **mp3**
 * *   **flv**
 * *   **webm**
 * *   **ts**
 *
 * @param request RefreshMediaPlayUrlsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RefreshMediaPlayUrlsResponse
 */
func (client *Client) RefreshMediaPlayUrlsWithOptions(request *RefreshMediaPlayUrlsRequest, runtime *util.RuntimeOptions) (_result *RefreshMediaPlayUrlsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Definitions)) {
		query["Definitions"] = request.Definitions
	}

	if !tea.BoolValue(util.IsUnset(request.Formats)) {
		query["Formats"] = request.Formats
	}

	if !tea.BoolValue(util.IsUnset(request.MediaIds)) {
		query["MediaIds"] = request.MediaIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResultType)) {
		query["ResultType"] = request.ResultType
	}

	if !tea.BoolValue(util.IsUnset(request.SliceCount)) {
		query["SliceCount"] = request.SliceCount
	}

	if !tea.BoolValue(util.IsUnset(request.SliceFlag)) {
		query["SliceFlag"] = request.SliceFlag
	}

	if !tea.BoolValue(util.IsUnset(request.StreamType)) {
		query["StreamType"] = request.StreamType
	}

	if !tea.BoolValue(util.IsUnset(request.TaskType)) {
		query["TaskType"] = request.TaskType
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RefreshMediaPlayUrls"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RefreshMediaPlayUrlsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The formats of the media streams you want to refresh or prefetch. You can specify multiple formats. Separate multiple formats with commas (,). If you leave this parameter empty, media streams in all formats are refreshed or prefetched by default. Valid values:
 * *   **mp4**
 * *   **m3u8**
 * *   **mp3**
 * *   **flv**
 * *   **webm**
 * *   **ts**
 *
 * @param request RefreshMediaPlayUrlsRequest
 * @return RefreshMediaPlayUrlsResponse
 */
func (client *Client) RefreshMediaPlayUrls(request *RefreshMediaPlayUrlsRequest) (_result *RefreshMediaPlayUrlsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RefreshMediaPlayUrlsResponse{}
	_body, _err := client.RefreshMediaPlayUrlsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The upload credential.
 * > The upload credential returned by this operation is Base64-encoded. Before you can use an SDK or an API operation to upload a media asset based on the upload credential, you must decode the upload credential by using the Base64 algorithm. You must parse the upload credential only if you use native OSS SDKs or OSS API for uploads.
 *
 * @param request RefreshUploadVideoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RefreshUploadVideoResponse
 */
func (client *Client) RefreshUploadVideoWithOptions(request *RefreshUploadVideoRequest, runtime *util.RuntimeOptions) (_result *RefreshUploadVideoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RefreshUploadVideo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RefreshUploadVideoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The upload credential.
 * > The upload credential returned by this operation is Base64-encoded. Before you can use an SDK or an API operation to upload a media asset based on the upload credential, you must decode the upload credential by using the Base64 algorithm. You must parse the upload credential only if you use native OSS SDKs or OSS API for uploads.
 *
 * @param request RefreshUploadVideoRequest
 * @return RefreshUploadVideoResponse
 */
func (client *Client) RefreshUploadVideo(request *RefreshUploadVideoRequest) (_result *RefreshUploadVideoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RefreshUploadVideoResponse{}
	_body, _err := client.RefreshUploadVideoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the refresh task. Separate multiple task IDs with commas (,).
 *
 * @param request RefreshVodObjectCachesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RefreshVodObjectCachesResponse
 */
func (client *Client) RefreshVodObjectCachesWithOptions(request *RefreshVodObjectCachesRequest, runtime *util.RuntimeOptions) (_result *RefreshVodObjectCachesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ObjectPath)) {
		query["ObjectPath"] = request.ObjectPath
	}

	if !tea.BoolValue(util.IsUnset(request.ObjectType)) {
		query["ObjectType"] = request.ObjectType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RefreshVodObjectCaches"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RefreshVodObjectCachesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the refresh task. Separate multiple task IDs with commas (,).
 *
 * @param request RefreshVodObjectCachesRequest
 * @return RefreshVodObjectCachesResponse
 */
func (client *Client) RefreshVodObjectCaches(request *RefreshVodObjectCachesRequest) (_result *RefreshVodObjectCachesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RefreshVodObjectCachesResponse{}
	_body, _err := client.RefreshVodObjectCachesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The media files that are registered, including newly registered and repeatedly registered media files.
 *
 * @param request RegisterMediaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RegisterMediaResponse
 */
func (client *Client) RegisterMediaWithOptions(request *RegisterMediaRequest, runtime *util.RuntimeOptions) (_result *RegisterMediaResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegisterMetadatas)) {
		query["RegisterMetadatas"] = request.RegisterMetadatas
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateGroupId)) {
		query["TemplateGroupId"] = request.TemplateGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	if !tea.BoolValue(util.IsUnset(request.WorkflowId)) {
		query["WorkflowId"] = request.WorkflowId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RegisterMedia"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RegisterMediaResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The media files that are registered, including newly registered and repeatedly registered media files.
 *
 * @param request RegisterMediaRequest
 * @return RegisterMediaResponse
 */
func (client *Client) RegisterMedia(request *RegisterMediaRequest) (_result *RegisterMediaResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RegisterMediaResponse{}
	_body, _err := client.RegisterMediaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RestoreMediaWithOptions(request *RestoreMediaRequest, runtime *util.RuntimeOptions) (_result *RestoreMediaResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaIds)) {
		query["MediaIds"] = request.MediaIds
	}

	if !tea.BoolValue(util.IsUnset(request.RestoreDays)) {
		query["RestoreDays"] = request.RestoreDays
	}

	if !tea.BoolValue(util.IsUnset(request.RestoreTier)) {
		query["RestoreTier"] = request.RestoreTier
	}

	if !tea.BoolValue(util.IsUnset(request.Scope)) {
		query["Scope"] = request.Scope
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RestoreMedia"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RestoreMediaResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RestoreMedia(request *RestoreMediaRequest) (_result *RestoreMediaResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RestoreMediaResponse{}
	_body, _err := client.RestoreMediaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SearchEditingProjectWithOptions(request *SearchEditingProjectRequest, runtime *util.RuntimeOptions) (_result *SearchEditingProjectResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		query["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SortBy)) {
		query["SortBy"] = request.SortBy
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.Title)) {
		query["Title"] = request.Title
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SearchEditingProject"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SearchEditingProjectResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SearchEditingProject(request *SearchEditingProjectRequest) (_result *SearchEditingProjectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SearchEditingProjectResponse{}
	_body, _err := client.SearchEditingProjectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the parent category.
 *
 * @param request SearchMediaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchMediaResponse
 */
func (client *Client) SearchMediaWithOptions(request *SearchMediaRequest, runtime *util.RuntimeOptions) (_result *SearchMediaResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Fields)) {
		query["Fields"] = request.Fields
	}

	if !tea.BoolValue(util.IsUnset(request.Match)) {
		query["Match"] = request.Match
	}

	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		query["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ScrollToken)) {
		query["ScrollToken"] = request.ScrollToken
	}

	if !tea.BoolValue(util.IsUnset(request.SearchType)) {
		query["SearchType"] = request.SearchType
	}

	if !tea.BoolValue(util.IsUnset(request.SortBy)) {
		query["SortBy"] = request.SortBy
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SearchMedia"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SearchMediaResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the parent category.
 *
 * @param request SearchMediaRequest
 * @return SearchMediaResponse
 */
func (client *Client) SearchMedia(request *SearchMediaRequest) (_result *SearchMediaResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SearchMediaResponse{}
	_body, _err := client.SearchMediaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The name of the review security group. Default value: **Default**. You can specify a maximum of 10 review security groups.
 *
 * @param request SetAuditSecurityIpRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetAuditSecurityIpResponse
 */
func (client *Client) SetAuditSecurityIpWithOptions(request *SetAuditSecurityIpRequest, runtime *util.RuntimeOptions) (_result *SetAuditSecurityIpResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Ips)) {
		query["Ips"] = request.Ips
	}

	if !tea.BoolValue(util.IsUnset(request.OperateMode)) {
		query["OperateMode"] = request.OperateMode
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityGroupName)) {
		query["SecurityGroupName"] = request.SecurityGroupName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetAuditSecurityIp"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetAuditSecurityIpResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The name of the review security group. Default value: **Default**. You can specify a maximum of 10 review security groups.
 *
 * @param request SetAuditSecurityIpRequest
 * @return SetAuditSecurityIpResponse
 */
func (client *Client) SetAuditSecurityIp(request *SetAuditSecurityIpRequest) (_result *SetAuditSecurityIpResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetAuditSecurityIpResponse{}
	_body, _err := client.SetAuditSecurityIpWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request SetCrossdomainContentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetCrossdomainContentResponse
 */
func (client *Client) SetCrossdomainContentWithOptions(request *SetCrossdomainContentRequest, runtime *util.RuntimeOptions) (_result *SetCrossdomainContentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Content)) {
		query["Content"] = request.Content
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceRealOwnerId)) {
		query["ResourceRealOwnerId"] = request.ResourceRealOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.StorageLocation)) {
		query["StorageLocation"] = request.StorageLocation
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetCrossdomainContent"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetCrossdomainContentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request SetCrossdomainContentRequest
 * @return SetCrossdomainContentResponse
 */
func (client *Client) SetCrossdomainContent(request *SetCrossdomainContentRequest) (_result *SetCrossdomainContentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetCrossdomainContentResponse{}
	_body, _err := client.SetCrossdomainContentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request SetDefaultAITemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetDefaultAITemplateResponse
 */
func (client *Client) SetDefaultAITemplateWithOptions(request *SetDefaultAITemplateRequest, runtime *util.RuntimeOptions) (_result *SetDefaultAITemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		query["TemplateId"] = request.TemplateId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetDefaultAITemplate"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetDefaultAITemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request SetDefaultAITemplateRequest
 * @return SetDefaultAITemplateResponse
 */
func (client *Client) SetDefaultAITemplate(request *SetDefaultAITemplateRequest) (_result *SetDefaultAITemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetDefaultAITemplateResponse{}
	_body, _err := client.SetDefaultAITemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetDefaultTranscodeTemplateGroupWithOptions(request *SetDefaultTranscodeTemplateGroupRequest, runtime *util.RuntimeOptions) (_result *SetDefaultTranscodeTemplateGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TranscodeTemplateGroupId)) {
		query["TranscodeTemplateGroupId"] = request.TranscodeTemplateGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetDefaultTranscodeTemplateGroup"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetDefaultTranscodeTemplateGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetDefaultTranscodeTemplateGroup(request *SetDefaultTranscodeTemplateGroupRequest) (_result *SetDefaultTranscodeTemplateGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetDefaultTranscodeTemplateGroupResponse{}
	_body, _err := client.SetDefaultTranscodeTemplateGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetDefaultWatermarkWithOptions(request *SetDefaultWatermarkRequest, runtime *util.RuntimeOptions) (_result *SetDefaultWatermarkResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.WatermarkId)) {
		query["WatermarkId"] = request.WatermarkId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetDefaultWatermark"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetDefaultWatermarkResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetDefaultWatermark(request *SetDefaultWatermarkRequest) (_result *SetDefaultWatermarkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetDefaultWatermarkResponse{}
	_body, _err := client.SetDefaultWatermarkWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetEditingProjectMaterialsWithOptions(request *SetEditingProjectMaterialsRequest, runtime *util.RuntimeOptions) (_result *SetEditingProjectMaterialsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaterialIds)) {
		query["MaterialIds"] = request.MaterialIds
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetEditingProjectMaterials"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetEditingProjectMaterialsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetEditingProjectMaterials(request *SetEditingProjectMaterialsRequest) (_result *SetEditingProjectMaterialsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetEditingProjectMaterialsResponse{}
	_body, _err := client.SetEditingProjectMaterialsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the application. If you do not set this parameter, the default value **app-1000000** is used.
 *
 * @param request SetMessageCallbackRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetMessageCallbackResponse
 */
func (client *Client) SetMessageCallbackWithOptions(request *SetMessageCallbackRequest, runtime *util.RuntimeOptions) (_result *SetMessageCallbackResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AuthKey)) {
		query["AuthKey"] = request.AuthKey
	}

	if !tea.BoolValue(util.IsUnset(request.AuthSwitch)) {
		query["AuthSwitch"] = request.AuthSwitch
	}

	if !tea.BoolValue(util.IsUnset(request.CallbackType)) {
		query["CallbackType"] = request.CallbackType
	}

	if !tea.BoolValue(util.IsUnset(request.CallbackURL)) {
		query["CallbackURL"] = request.CallbackURL
	}

	if !tea.BoolValue(util.IsUnset(request.EventTypeList)) {
		query["EventTypeList"] = request.EventTypeList
	}

	if !tea.BoolValue(util.IsUnset(request.MnsEndpoint)) {
		query["MnsEndpoint"] = request.MnsEndpoint
	}

	if !tea.BoolValue(util.IsUnset(request.MnsQueueName)) {
		query["MnsQueueName"] = request.MnsQueueName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetMessageCallback"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetMessageCallbackResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the application. If you do not set this parameter, the default value **app-1000000** is used.
 *
 * @param request SetMessageCallbackRequest
 * @return SetMessageCallbackResponse
 */
func (client *Client) SetMessageCallback(request *SetMessageCallbackRequest) (_result *SetMessageCallbackResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetMessageCallbackResponse{}
	_body, _err := client.SetMessageCallbackWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > This operation is available only in the **China (Shanghai)** region.
 *
 * @param request SetVodDomainCertificateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetVodDomainCertificateResponse
 */
func (client *Client) SetVodDomainCertificateWithOptions(request *SetVodDomainCertificateRequest, runtime *util.RuntimeOptions) (_result *SetVodDomainCertificateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CertName)) {
		query["CertName"] = request.CertName
	}

	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SSLPri)) {
		query["SSLPri"] = request.SSLPri
	}

	if !tea.BoolValue(util.IsUnset(request.SSLProtocol)) {
		query["SSLProtocol"] = request.SSLProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.SSLPub)) {
		query["SSLPub"] = request.SSLPub
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetVodDomainCertificate"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetVodDomainCertificateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > This operation is available only in the **China (Shanghai)** region.
 *
 * @param request SetVodDomainCertificateRequest
 * @return SetVodDomainCertificateResponse
 */
func (client *Client) SetVodDomainCertificate(request *SetVodDomainCertificateRequest) (_result *SetVodDomainCertificateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetVodDomainCertificateResponse{}
	_body, _err := client.SetVodDomainCertificateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SubmitAIImageAuditJobWithOptions(request *SubmitAIImageAuditJobRequest, runtime *util.RuntimeOptions) (_result *SubmitAIImageAuditJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaAuditConfiguration)) {
		query["MediaAuditConfiguration"] = request.MediaAuditConfiguration
	}

	if !tea.BoolValue(util.IsUnset(request.MediaId)) {
		query["MediaId"] = request.MediaId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		query["TemplateId"] = request.TemplateId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SubmitAIImageAuditJob"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SubmitAIImageAuditJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SubmitAIImageAuditJob(request *SubmitAIImageAuditJobRequest) (_result *SubmitAIImageAuditJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SubmitAIImageAuditJobResponse{}
	_body, _err := client.SubmitAIImageAuditJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The returned data.
 *
 * @param request SubmitAIImageJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SubmitAIImageJobResponse
 */
func (client *Client) SubmitAIImageJobWithOptions(request *SubmitAIImageJobRequest, runtime *util.RuntimeOptions) (_result *SubmitAIImageJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AIPipelineId)) {
		query["AIPipelineId"] = request.AIPipelineId
	}

	if !tea.BoolValue(util.IsUnset(request.AITemplateId)) {
		query["AITemplateId"] = request.AITemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SubmitAIImageJob"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SubmitAIImageJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The returned data.
 *
 * @param request SubmitAIImageJobRequest
 * @return SubmitAIImageJobResponse
 */
func (client *Client) SubmitAIImageJob(request *SubmitAIImageJobRequest) (_result *SubmitAIImageJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SubmitAIImageJobResponse{}
	_body, _err := client.SubmitAIImageJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The returned data.
 *
 * @param request SubmitAIJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SubmitAIJobResponse
 */
func (client *Client) SubmitAIJobWithOptions(request *SubmitAIJobRequest, runtime *util.RuntimeOptions) (_result *SubmitAIJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Config)) {
		query["Config"] = request.Config
	}

	if !tea.BoolValue(util.IsUnset(request.MediaId)) {
		query["MediaId"] = request.MediaId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Types)) {
		query["Types"] = request.Types
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SubmitAIJob"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SubmitAIJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The returned data.
 *
 * @param request SubmitAIJobRequest
 * @return SubmitAIJobResponse
 */
func (client *Client) SubmitAIJob(request *SubmitAIJobRequest) (_result *SubmitAIJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SubmitAIJobResponse{}
	_body, _err := client.SubmitAIJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SubmitAIMediaAuditJobWithOptions(request *SubmitAIMediaAuditJobRequest, runtime *util.RuntimeOptions) (_result *SubmitAIMediaAuditJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaAuditConfiguration)) {
		query["MediaAuditConfiguration"] = request.MediaAuditConfiguration
	}

	if !tea.BoolValue(util.IsUnset(request.MediaId)) {
		query["MediaId"] = request.MediaId
	}

	if !tea.BoolValue(util.IsUnset(request.MediaType)) {
		query["MediaType"] = request.MediaType
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		query["TemplateId"] = request.TemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SubmitAIMediaAuditJob"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SubmitAIMediaAuditJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SubmitAIMediaAuditJob(request *SubmitAIMediaAuditJobRequest) (_result *SubmitAIMediaAuditJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SubmitAIMediaAuditJobResponse{}
	_body, _err := client.SubmitAIMediaAuditJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the video.
 *
 * @param request SubmitDynamicImageJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SubmitDynamicImageJobResponse
 */
func (client *Client) SubmitDynamicImageJobWithOptions(request *SubmitDynamicImageJobRequest, runtime *util.RuntimeOptions) (_result *SubmitDynamicImageJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DynamicImageTemplateId)) {
		query["DynamicImageTemplateId"] = request.DynamicImageTemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.OverrideParams)) {
		query["OverrideParams"] = request.OverrideParams
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SubmitDynamicImageJob"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SubmitDynamicImageJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the video.
 *
 * @param request SubmitDynamicImageJobRequest
 * @return SubmitDynamicImageJobResponse
 */
func (client *Client) SubmitDynamicImageJob(request *SubmitDynamicImageJobRequest) (_result *SubmitDynamicImageJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SubmitDynamicImageJobResponse{}
	_body, _err := client.SubmitDynamicImageJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request SubmitMediaDNADeleteJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SubmitMediaDNADeleteJobResponse
 */
func (client *Client) SubmitMediaDNADeleteJobWithOptions(request *SubmitMediaDNADeleteJobRequest, runtime *util.RuntimeOptions) (_result *SubmitMediaDNADeleteJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaId)) {
		query["MediaId"] = request.MediaId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SubmitMediaDNADeleteJob"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SubmitMediaDNADeleteJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request SubmitMediaDNADeleteJobRequest
 * @return SubmitMediaDNADeleteJobResponse
 */
func (client *Client) SubmitMediaDNADeleteJob(request *SubmitMediaDNADeleteJobRequest) (_result *SubmitMediaDNADeleteJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SubmitMediaDNADeleteJobResponse{}
	_body, _err := client.SubmitMediaDNADeleteJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the job.
 *
 * @param request SubmitPreprocessJobsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SubmitPreprocessJobsResponse
 */
func (client *Client) SubmitPreprocessJobsWithOptions(request *SubmitPreprocessJobsRequest, runtime *util.RuntimeOptions) (_result *SubmitPreprocessJobsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PreprocessType)) {
		query["PreprocessType"] = request.PreprocessType
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SubmitPreprocessJobs"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SubmitPreprocessJobsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the job.
 *
 * @param request SubmitPreprocessJobsRequest
 * @return SubmitPreprocessJobsResponse
 */
func (client *Client) SubmitPreprocessJobs(request *SubmitPreprocessJobsRequest) (_result *SubmitPreprocessJobsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SubmitPreprocessJobsResponse{}
	_body, _err := client.SubmitPreprocessJobsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the snapshot template.
 * *   We recommend that you create a snapshot template before you specify the ID of the snapshot template.
 * *   If you set the SnapshotTemplateId parameter, all the other request parameters except the Action and VideoId parameters are ignored.
 * *   For more information about how to create a snapshot template, see [AddVodTemplate](~~99406~~).
 *
 * @param request SubmitSnapshotJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SubmitSnapshotJobResponse
 */
func (client *Client) SubmitSnapshotJobWithOptions(request *SubmitSnapshotJobRequest, runtime *util.RuntimeOptions) (_result *SubmitSnapshotJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Count)) {
		query["Count"] = request.Count
	}

	if !tea.BoolValue(util.IsUnset(request.Height)) {
		query["Height"] = request.Height
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.SnapshotTemplateId)) {
		query["SnapshotTemplateId"] = request.SnapshotTemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.SpecifiedOffsetTime)) {
		query["SpecifiedOffsetTime"] = request.SpecifiedOffsetTime
	}

	if !tea.BoolValue(util.IsUnset(request.SpriteSnapshotConfig)) {
		query["SpriteSnapshotConfig"] = request.SpriteSnapshotConfig
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	if !tea.BoolValue(util.IsUnset(request.Width)) {
		query["Width"] = request.Width
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SubmitSnapshotJob"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SubmitSnapshotJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the snapshot template.
 * *   We recommend that you create a snapshot template before you specify the ID of the snapshot template.
 * *   If you set the SnapshotTemplateId parameter, all the other request parameters except the Action and VideoId parameters are ignored.
 * *   For more information about how to create a snapshot template, see [AddVodTemplate](~~99406~~).
 *
 * @param request SubmitSnapshotJobRequest
 * @return SubmitSnapshotJobResponse
 */
func (client *Client) SubmitSnapshotJob(request *SubmitSnapshotJobRequest) (_result *SubmitSnapshotJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SubmitSnapshotJobResponse{}
	_body, _err := client.SubmitSnapshotJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the transcoding template group used when the video is transcoded. To specify a transcoding template group, you can log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com/?spm=a2c4g.11186623.2.18.2f1a2267jCybwh#/vod/settings/transcode/vod) and view the ID of the transcoding template group on the Transcode page.
 *
 * @param request SubmitTranscodeJobsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SubmitTranscodeJobsResponse
 */
func (client *Client) SubmitTranscodeJobsWithOptions(request *SubmitTranscodeJobsRequest, runtime *util.RuntimeOptions) (_result *SubmitTranscodeJobsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EncryptConfig)) {
		query["EncryptConfig"] = request.EncryptConfig
	}

	if !tea.BoolValue(util.IsUnset(request.OverrideParams)) {
		query["OverrideParams"] = request.OverrideParams
	}

	if !tea.BoolValue(util.IsUnset(request.PipelineId)) {
		query["PipelineId"] = request.PipelineId
	}

	if !tea.BoolValue(util.IsUnset(request.Priority)) {
		query["Priority"] = request.Priority
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateGroupId)) {
		query["TemplateGroupId"] = request.TemplateGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SubmitTranscodeJobs"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SubmitTranscodeJobsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the transcoding template group used when the video is transcoded. To specify a transcoding template group, you can log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com/?spm=a2c4g.11186623.2.18.2f1a2267jCybwh#/vod/settings/transcode/vod) and view the ID of the transcoding template group on the Transcode page.
 *
 * @param request SubmitTranscodeJobsRequest
 * @return SubmitTranscodeJobsResponse
 */
func (client *Client) SubmitTranscodeJobs(request *SubmitTranscodeJobsRequest) (_result *SubmitTranscodeJobsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SubmitTranscodeJobsResponse{}
	_body, _err := client.SubmitTranscodeJobsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SubmitWorkflowJobWithOptions(request *SubmitWorkflowJobRequest, runtime *util.RuntimeOptions) (_result *SubmitWorkflowJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaId)) {
		query["MediaId"] = request.MediaId
	}

	if !tea.BoolValue(util.IsUnset(request.WorkflowId)) {
		query["WorkflowId"] = request.WorkflowId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SubmitWorkflowJob"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SubmitWorkflowJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SubmitWorkflowJob(request *SubmitWorkflowJobRequest) (_result *SubmitWorkflowJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SubmitWorkflowJobResponse{}
	_body, _err := client.SubmitWorkflowJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The returned result.
 *
 * @param request UpdateAITemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAITemplateResponse
 */
func (client *Client) UpdateAITemplateWithOptions(request *UpdateAITemplateRequest, runtime *util.RuntimeOptions) (_result *UpdateAITemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TemplateConfig)) {
		query["TemplateConfig"] = request.TemplateConfig
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		query["TemplateId"] = request.TemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateName)) {
		query["TemplateName"] = request.TemplateName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAITemplate"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateAITemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The returned result.
 *
 * @param request UpdateAITemplateRequest
 * @return UpdateAITemplateResponse
 */
func (client *Client) UpdateAITemplate(request *UpdateAITemplateRequest) (_result *UpdateAITemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateAITemplateResponse{}
	_body, _err := client.UpdateAITemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request UpdateAppInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAppInfoResponse
 */
func (client *Client) UpdateAppInfoWithOptions(request *UpdateAppInfoRequest, runtime *util.RuntimeOptions) (_result *UpdateAppInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AppName)) {
		query["AppName"] = request.AppName
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAppInfo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateAppInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request UpdateAppInfoRequest
 * @return UpdateAppInfoResponse
 */
func (client *Client) UpdateAppInfo(request *UpdateAppInfoRequest) (_result *UpdateAppInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateAppInfoResponse{}
	_body, _err := client.UpdateAppInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request UpdateAttachedMediaInfosRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAttachedMediaInfosResponse
 */
func (client *Client) UpdateAttachedMediaInfosWithOptions(request *UpdateAttachedMediaInfosRequest, runtime *util.RuntimeOptions) (_result *UpdateAttachedMediaInfosResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.UpdateContent)) {
		query["UpdateContent"] = request.UpdateContent
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAttachedMediaInfos"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateAttachedMediaInfosResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request UpdateAttachedMediaInfosRequest
 * @return UpdateAttachedMediaInfosResponse
 */
func (client *Client) UpdateAttachedMediaInfos(request *UpdateAttachedMediaInfosRequest) (_result *UpdateAttachedMediaInfosResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateAttachedMediaInfosResponse{}
	_body, _err := client.UpdateAttachedMediaInfosWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateCategoryWithOptions(request *UpdateCategoryRequest, runtime *util.RuntimeOptions) (_result *UpdateCategoryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CateId)) {
		query["CateId"] = request.CateId
	}

	if !tea.BoolValue(util.IsUnset(request.CateName)) {
		query["CateName"] = request.CateName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateCategory"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateCategoryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateCategory(request *UpdateCategoryRequest) (_result *UpdateCategoryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateCategoryResponse{}
	_body, _err := client.UpdateCategoryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateEditingProjectWithOptions(request *UpdateEditingProjectRequest, runtime *util.RuntimeOptions) (_result *UpdateEditingProjectResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CoverURL)) {
		query["CoverURL"] = request.CoverURL
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Timeline)) {
		query["Timeline"] = request.Timeline
	}

	if !tea.BoolValue(util.IsUnset(request.Title)) {
		query["Title"] = request.Title
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateEditingProject"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateEditingProjectResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateEditingProject(request *UpdateEditingProjectRequest) (_result *UpdateEditingProjectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateEditingProjectResponse{}
	_body, _err := client.UpdateEditingProjectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateImageInfosWithOptions(request *UpdateImageInfosRequest, runtime *util.RuntimeOptions) (_result *UpdateImageInfosResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.UpdateContent)) {
		query["UpdateContent"] = request.UpdateContent
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateImageInfos"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateImageInfosResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateImageInfos(request *UpdateImageInfosRequest) (_result *UpdateImageInfosResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateImageInfosResponse{}
	_body, _err := client.UpdateImageInfosWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateMediaStorageClassWithOptions(request *UpdateMediaStorageClassRequest, runtime *util.RuntimeOptions) (_result *UpdateMediaStorageClassResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MediaIds)) {
		query["MediaIds"] = request.MediaIds
	}

	if !tea.BoolValue(util.IsUnset(request.RestoreTier)) {
		query["RestoreTier"] = request.RestoreTier
	}

	if !tea.BoolValue(util.IsUnset(request.Scope)) {
		query["Scope"] = request.Scope
	}

	if !tea.BoolValue(util.IsUnset(request.StorageClass)) {
		query["StorageClass"] = request.StorageClass
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateMediaStorageClass"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateMediaStorageClassResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateMediaStorageClass(request *UpdateMediaStorageClassRequest) (_result *UpdateMediaStorageClassResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateMediaStorageClassResponse{}
	_body, _err := client.UpdateMediaStorageClassWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the transcoding template group.
 *
 * @param request UpdateTranscodeTemplateGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTranscodeTemplateGroupResponse
 */
func (client *Client) UpdateTranscodeTemplateGroupWithOptions(request *UpdateTranscodeTemplateGroupRequest, runtime *util.RuntimeOptions) (_result *UpdateTranscodeTemplateGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Locked)) {
		query["Locked"] = request.Locked
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.TranscodeTemplateGroupId)) {
		query["TranscodeTemplateGroupId"] = request.TranscodeTemplateGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.TranscodeTemplateList)) {
		query["TranscodeTemplateList"] = request.TranscodeTemplateList
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTranscodeTemplateGroup"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTranscodeTemplateGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the transcoding template group.
 *
 * @param request UpdateTranscodeTemplateGroupRequest
 * @return UpdateTranscodeTemplateGroupResponse
 */
func (client *Client) UpdateTranscodeTemplateGroup(request *UpdateTranscodeTemplateGroupRequest) (_result *UpdateTranscodeTemplateGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTranscodeTemplateGroupResponse{}
	_body, _err := client.UpdateTranscodeTemplateGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the video.
 *
 * @param request UpdateVideoInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateVideoInfoResponse
 */
func (client *Client) UpdateVideoInfoWithOptions(request *UpdateVideoInfoRequest, runtime *util.RuntimeOptions) (_result *UpdateVideoInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CateId)) {
		query["CateId"] = request.CateId
	}

	if !tea.BoolValue(util.IsUnset(request.CoverURL)) {
		query["CoverURL"] = request.CoverURL
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	if !tea.BoolValue(util.IsUnset(request.Title)) {
		query["Title"] = request.Title
	}

	if !tea.BoolValue(util.IsUnset(request.VideoId)) {
		query["VideoId"] = request.VideoId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateVideoInfo"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateVideoInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the video.
 *
 * @param request UpdateVideoInfoRequest
 * @return UpdateVideoInfoResponse
 */
func (client *Client) UpdateVideoInfo(request *UpdateVideoInfoRequest) (_result *UpdateVideoInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateVideoInfoResponse{}
	_body, _err := client.UpdateVideoInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The IDs of the videos that do not exist.
 *
 * @param request UpdateVideoInfosRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateVideoInfosResponse
 */
func (client *Client) UpdateVideoInfosWithOptions(request *UpdateVideoInfosRequest, runtime *util.RuntimeOptions) (_result *UpdateVideoInfosResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.UpdateContent)) {
		query["UpdateContent"] = request.UpdateContent
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateVideoInfos"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateVideoInfosResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The IDs of the videos that do not exist.
 *
 * @param request UpdateVideoInfosRequest
 * @return UpdateVideoInfosResponse
 */
func (client *Client) UpdateVideoInfos(request *UpdateVideoInfosRequest) (_result *UpdateVideoInfosResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateVideoInfosResponse{}
	_body, _err := client.UpdateVideoInfosWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > This operation is available only in the **China (Shanghai)** region.
 *
 * @param request UpdateVodDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateVodDomainResponse
 */
func (client *Client) UpdateVodDomainWithOptions(request *UpdateVodDomainRequest, runtime *util.RuntimeOptions) (_result *UpdateVodDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SecurityToken)) {
		query["SecurityToken"] = request.SecurityToken
	}

	if !tea.BoolValue(util.IsUnset(request.Sources)) {
		query["Sources"] = request.Sources
	}

	if !tea.BoolValue(util.IsUnset(request.TopLevelDomain)) {
		query["TopLevelDomain"] = request.TopLevelDomain
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateVodDomain"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateVodDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > This operation is available only in the **China (Shanghai)** region.
 *
 * @param request UpdateVodDomainRequest
 * @return UpdateVodDomainResponse
 */
func (client *Client) UpdateVodDomain(request *UpdateVodDomainRequest) (_result *UpdateVodDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateVodDomainResponse{}
	_body, _err := client.UpdateVodDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateVodTemplateWithOptions(request *UpdateVodTemplateRequest, runtime *util.RuntimeOptions) (_result *UpdateVodTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateConfig)) {
		query["TemplateConfig"] = request.TemplateConfig
	}

	if !tea.BoolValue(util.IsUnset(request.VodTemplateId)) {
		query["VodTemplateId"] = request.VodTemplateId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateVodTemplate"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateVodTemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateVodTemplate(request *UpdateVodTemplateRequest) (_result *UpdateVodTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateVodTemplateResponse{}
	_body, _err := client.UpdateVodTemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The configurations such as the position and effect of the text watermark or image watermark. The value is a JSON-formatted string.
 * > The value of this parameter varies with the watermark type. For more information about the data structure, see the "WatermarkConfig" section of the [Media processing parameters](~~98618~~) topic.
 *
 * @param request UpdateWatermarkRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateWatermarkResponse
 */
func (client *Client) UpdateWatermarkWithOptions(request *UpdateWatermarkRequest, runtime *util.RuntimeOptions) (_result *UpdateWatermarkResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.WatermarkConfig)) {
		query["WatermarkConfig"] = request.WatermarkConfig
	}

	if !tea.BoolValue(util.IsUnset(request.WatermarkId)) {
		query["WatermarkId"] = request.WatermarkId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateWatermark"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateWatermarkResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The configurations such as the position and effect of the text watermark or image watermark. The value is a JSON-formatted string.
 * > The value of this parameter varies with the watermark type. For more information about the data structure, see the "WatermarkConfig" section of the [Media processing parameters](~~98618~~) topic.
 *
 * @param request UpdateWatermarkRequest
 * @return UpdateWatermarkResponse
 */
func (client *Client) UpdateWatermark(request *UpdateWatermarkRequest) (_result *UpdateWatermarkResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateWatermarkResponse{}
	_body, _err := client.UpdateWatermarkWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the workflow. To view the ID of the workflow, log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Configuration Management** > **Media Processing** > **Workflows**.
 * > If both the WorkflowId and TemplateGroupId parameters are set, the value of the WorkflowId parameter takes effect. For more information, see [Workflows](~~115347~~).
 *
 * @param request UploadMediaByURLRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UploadMediaByURLResponse
 */
func (client *Client) UploadMediaByURLWithOptions(request *UploadMediaByURLRequest, runtime *util.RuntimeOptions) (_result *UploadMediaByURLResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		query["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.StorageLocation)) {
		query["StorageLocation"] = request.StorageLocation
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateGroupId)) {
		query["TemplateGroupId"] = request.TemplateGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.UploadMetadatas)) {
		query["UploadMetadatas"] = request.UploadMetadatas
	}

	if !tea.BoolValue(util.IsUnset(request.UploadURLs)) {
		query["UploadURLs"] = request.UploadURLs
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	if !tea.BoolValue(util.IsUnset(request.WorkflowId)) {
		query["WorkflowId"] = request.WorkflowId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UploadMediaByURL"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UploadMediaByURLResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the workflow. To view the ID of the workflow, log on to the [ApsaraVideo VOD console](https://vod.console.aliyun.com). In the left-side navigation pane, choose **Configuration Management** > **Media Processing** > **Workflows**.
 * > If both the WorkflowId and TemplateGroupId parameters are set, the value of the WorkflowId parameter takes effect. For more information, see [Workflows](~~115347~~).
 *
 * @param request UploadMediaByURLRequest
 * @return UploadMediaByURLResponse
 */
func (client *Client) UploadMediaByURL(request *UploadMediaByURLRequest) (_result *UploadMediaByURLResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UploadMediaByURLResponse{}
	_body, _err := client.UploadMediaByURLWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The URL of the transcoded stream.
 * If URL authentication is required, you must pass authentication information in this parameter and make sure that the URL can be accessed over the Internet.
 *
 * @param request UploadStreamByURLRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UploadStreamByURLResponse
 */
func (client *Client) UploadStreamByURLWithOptions(request *UploadStreamByURLRequest, runtime *util.RuntimeOptions) (_result *UploadStreamByURLResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Definition)) {
		query["Definition"] = request.Definition
	}

	if !tea.BoolValue(util.IsUnset(request.FileExtension)) {
		query["FileExtension"] = request.FileExtension
	}

	if !tea.BoolValue(util.IsUnset(request.HDRType)) {
		query["HDRType"] = request.HDRType
	}

	if !tea.BoolValue(util.IsUnset(request.MediaId)) {
		query["MediaId"] = request.MediaId
	}

	if !tea.BoolValue(util.IsUnset(request.StreamURL)) {
		query["StreamURL"] = request.StreamURL
	}

	if !tea.BoolValue(util.IsUnset(request.UserData)) {
		query["UserData"] = request.UserData
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UploadStreamByURL"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UploadStreamByURLResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The URL of the transcoded stream.
 * If URL authentication is required, you must pass authentication information in this parameter and make sure that the URL can be accessed over the Internet.
 *
 * @param request UploadStreamByURLRequest
 * @return UploadStreamByURLResponse
 */
func (client *Client) UploadStreamByURL(request *UploadStreamByURLRequest) (_result *UploadStreamByURLResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UploadStreamByURLResponse{}
	_body, _err := client.UploadStreamByURLWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) VerifyVodDomainOwnerWithOptions(request *VerifyVodDomainOwnerRequest, runtime *util.RuntimeOptions) (_result *VerifyVodDomainOwnerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DomainName)) {
		query["DomainName"] = request.DomainName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VerifyType)) {
		query["VerifyType"] = request.VerifyType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("VerifyVodDomainOwner"),
		Version:     tea.String("2017-03-21"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &VerifyVodDomainOwnerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) VerifyVodDomainOwner(request *VerifyVodDomainOwnerRequest) (_result *VerifyVodDomainOwnerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &VerifyVodDomainOwnerResponse{}
	_body, _err := client.VerifyVodDomainOwnerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}
